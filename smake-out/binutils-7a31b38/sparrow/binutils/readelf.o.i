# 1 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
# 1 "/doner/binutils/binutils-7a31b38/binutils//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
# 43 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
# 1 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 1
# 23 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h"
# 1 "./../include/alloca-conf.h" 1
# 16 "./../include/alloca-conf.h"
# 1 "./config.h" 1
# 17 "./../include/alloca-conf.h" 2






# 1 "/usr/include/alloca.h" 1 3 4
# 21 "/usr/include/alloca.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 22 "/usr/include/alloca.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 24 "./../include/alloca-conf.h" 2
# 24 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 1 "./../include/ansidecl.h" 1
# 25 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 26 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 27 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2

# 1 "../bfd/bfdver.h" 1
# 29 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 31 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2




# 1 "./../include/fopen-same.h" 1
# 36 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 39 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2





# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 45 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2



# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 49 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 64 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
# 574 "/usr/include/stdlib.h" 3 4
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 65 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2



# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 69 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2







# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 77 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2


# 1 "./../include/binary-io.h" 1
# 80 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 147 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 148 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2



# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 152 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 173 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 174 "/doner/binutils/binutils-7a31b38/binutils/sysdep.h" 2
# 44 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 45 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 46 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../zlib/zlib.h" 1
# 34 "./../zlib/zlib.h"
# 1 "./../zlib/zconf.h" 1
# 247 "./../zlib/zconf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 248 "./../zlib/zconf.h" 2
     
# 248 "./../zlib/zconf.h"
    typedef size_t z_size_t;
# 391 "./../zlib/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 419 "./../zlib/zconf.h" 2
# 429 "./../zlib/zconf.h"
   typedef unsigned z_crc_t;
# 35 "./../zlib/zlib.h" 2
# 81 "./../zlib/zlib.h"
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;

    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 220 "./../zlib/zlib.h"
extern const char * zlibVersion (void);
# 250 "./../zlib/zlib.h"
extern int deflate (z_streamp strm, int flush);
# 363 "./../zlib/zlib.h"
extern int deflateEnd (z_streamp strm);
# 400 "./../zlib/zlib.h"
extern int inflate (z_streamp strm, int flush);
# 520 "./../zlib/zlib.h"
extern int inflateEnd (z_streamp strm);
# 611 "./../zlib/zlib.h"
extern int deflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength)

                                                               ;
# 655 "./../zlib/zlib.h"
extern int deflateGetDictionary (z_streamp strm, Bytef *dictionary, uInt *dictLength)

                                                                ;
# 677 "./../zlib/zlib.h"
extern int deflateCopy (z_streamp dest, z_streamp source)
                                                      ;
# 695 "./../zlib/zlib.h"
extern int deflateReset (z_streamp strm);
# 706 "./../zlib/zlib.h"
extern int deflateParams (z_streamp strm, int level, int strategy)

                                                    ;
# 743 "./../zlib/zlib.h"
extern int deflateTune (z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain)



                                                   ;
# 760 "./../zlib/zlib.h"
extern uLong deflateBound (z_streamp strm, uLong sourceLen)
                                                        ;
# 775 "./../zlib/zlib.h"
extern int deflatePending (z_streamp strm, unsigned *pending, int *bits)

                                                  ;
# 790 "./../zlib/zlib.h"
extern int deflatePrime (z_streamp strm, int bits, int value)

                                                ;
# 807 "./../zlib/zlib.h"
extern int deflateSetHeader (z_streamp strm, gz_headerp head)
                                                          ;
# 884 "./../zlib/zlib.h"
extern int inflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength)

                                                               ;
# 907 "./../zlib/zlib.h"
extern int inflateGetDictionary (z_streamp strm, Bytef *dictionary, uInt *dictLength)

                                                                ;
# 922 "./../zlib/zlib.h"
extern int inflateSync (z_streamp strm);
# 941 "./../zlib/zlib.h"
extern int inflateCopy (z_streamp dest, z_streamp source)
                                                      ;
# 957 "./../zlib/zlib.h"
extern int inflateReset (z_streamp strm);
# 967 "./../zlib/zlib.h"
extern int inflateReset2 (z_streamp strm, int windowBits)
                                                      ;
# 981 "./../zlib/zlib.h"
extern int inflatePrime (z_streamp strm, int bits, int value)

                                                ;
# 1002 "./../zlib/zlib.h"
extern long inflateMark (z_streamp strm);
# 1030 "./../zlib/zlib.h"
extern int inflateGetHeader (z_streamp strm, gz_headerp head)
                                                          ;
# 1092 "./../zlib/zlib.h"
typedef unsigned (*in_func) (void *, unsigned char * *)
                                                                   ;
typedef int (*out_func) (void *, unsigned char *, unsigned);

extern int inflateBack (z_streamp strm, in_func in, void *in_desc, out_func out, void *out_desc)

                                                                      ;
# 1166 "./../zlib/zlib.h"
extern int inflateBackEnd (z_streamp strm);







extern uLong zlibCompileFlags (void);
# 1227 "./../zlib/zlib.h"
extern int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
                                                                       ;
# 1242 "./../zlib/zlib.h"
extern int compress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)

                                             ;
# 1258 "./../zlib/zlib.h"
extern uLong compressBound (uLong sourceLen);






extern int uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
                                                                         ;
# 1283 "./../zlib/zlib.h"
extern int uncompress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong *sourceLen)
                                                                           ;
# 1300 "./../zlib/zlib.h"
typedef struct gzFile_s *gzFile;
# 1340 "./../zlib/zlib.h"
extern gzFile gzdopen (int fd, const char *mode);
# 1363 "./../zlib/zlib.h"
extern int gzbuffer (gzFile file, unsigned size);
# 1379 "./../zlib/zlib.h"
extern int gzsetparams (gzFile file, int level, int strategy);
# 1390 "./../zlib/zlib.h"
extern int gzread (gzFile file, voidp buf, unsigned len);
# 1420 "./../zlib/zlib.h"
extern z_size_t gzfread (voidp buf, z_size_t size, z_size_t nitems, gzFile file)
                                                  ;
# 1446 "./../zlib/zlib.h"
extern int gzwrite (gzFile file, voidpc buf, unsigned len)
                                                          ;






extern z_size_t gzfwrite (voidpc buf, z_size_t size, z_size_t nitems, gzFile file)
                                                                    ;
# 1468 "./../zlib/zlib.h"
extern int gzprintf (gzFile file, const char *format, ...);
# 1483 "./../zlib/zlib.h"
extern int gzputs (gzFile file, const char *s);







extern char * gzgets (gzFile file, char *buf, int len);
# 1504 "./../zlib/zlib.h"
extern int gzputc (gzFile file, int c);





extern int gzgetc (gzFile file);
# 1519 "./../zlib/zlib.h"
extern int gzungetc (int c, gzFile file);
# 1531 "./../zlib/zlib.h"
extern int gzflush (gzFile file, int flush);
# 1566 "./../zlib/zlib.h"
extern int gzrewind (gzFile file);
# 1594 "./../zlib/zlib.h"
extern int gzeof (gzFile file);
# 1609 "./../zlib/zlib.h"
extern int gzdirect (gzFile file);
# 1630 "./../zlib/zlib.h"
extern int gzclose (gzFile file);
# 1643 "./../zlib/zlib.h"
extern int gzclose_r (gzFile file);
extern int gzclose_w (gzFile file);
# 1655 "./../zlib/zlib.h"
extern const char * gzerror (gzFile file, int *errnum);
# 1671 "./../zlib/zlib.h"
extern void gzclearerr (gzFile file);
# 1688 "./../zlib/zlib.h"
extern uLong adler32 (uLong adler, const Bytef *buf, uInt len);
# 1707 "./../zlib/zlib.h"
extern uLong adler32_z (uLong adler, const Bytef *buf, z_size_t len)
                                                  ;
# 1725 "./../zlib/zlib.h"
extern uLong crc32 (uLong crc, const Bytef *buf, uInt len);
# 1742 "./../zlib/zlib.h"
extern uLong crc32_z (uLong adler, const Bytef *buf, z_size_t len)
                                                ;
# 1764 "./../zlib/zlib.h"
extern int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size)
                                                                           ;
extern int inflateInit_ (z_streamp strm, const char *version, int stream_size)
                                                                           ;
extern int deflateInit2_ (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)


                                                       ;
extern int inflateInit2_ (z_streamp strm, int windowBits, const char *version, int stream_size)
                                                                            ;
extern int inflateBackInit_ (z_streamp strm, int windowBits, unsigned char *window, const char *version, int stream_size)


                                                          ;
# 1817 "./../zlib/zlib.h"
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    off64_t pos;
};
extern int gzgetc_ (gzFile file);
# 1839 "./../zlib/zlib.h"
   extern gzFile gzopen64 (const char *, const char *);
   extern off64_t gzseek64 (gzFile, off64_t, int);
   extern off64_t gztell64 (gzFile);
   extern off64_t gzoffset64 (gzFile);
   extern uLong adler32_combine64 (uLong, uLong, off64_t);
   extern uLong crc32_combine64 (uLong, uLong, off64_t);
# 1872 "./../zlib/zlib.h"
   extern gzFile gzopen (const char *, const char *);
   extern off_t gzseek (gzFile, off_t, int);
   extern off_t gztell (gzFile);
   extern off_t gzoffset (gzFile);
   extern uLong adler32_combine (uLong, uLong, off_t);
   extern uLong crc32_combine (uLong, uLong, off_t);
# 1888 "./../zlib/zlib.h"
extern const char * zError (int);
extern int inflateSyncPoint (z_streamp);
extern const z_crc_t * get_crc_table (void);
extern int inflateUndermine (z_streamp, int);
extern int inflateValidate (z_streamp, int);
extern unsigned long inflateCodesUsed (z_streamp);
extern int inflateResetKeep (z_streamp);
extern int deflateResetKeep (z_streamp);






extern int gzvprintf (gzFile file, const char *format, va_list va)

                                                              ;
# 47 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2

# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4

# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4




struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wcsdup (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 164 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 174 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 201 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 212 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcslen (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 233 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 253 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));





extern wint_t btowc (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int mbsinit (const mbstate_t *__ps) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wcswidth (const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ , __leaf__));





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__ , __leaf__));






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__));





extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ , __leaf__));






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_swscanf") __attribute__ ((__nothrow__ , __leaf__))


                                                          ;
# 671 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vswscanf") __attribute__ ((__nothrow__ , __leaf__))


                                                          ;
# 726 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 781 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 807 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 817 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 856 "/usr/include/wchar.h" 3 4

# 49 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 59 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
# 1 "../bfd/bfd.h" 1
# 43 "../bfd/bfd.h"
# 1 "./../include/symcat.h" 1
# 44 "../bfd/bfd.h" 2
# 97 "../bfd/bfd.h"

# 97 "../bfd/bfd.h"
typedef long bfd_int64_t;
typedef unsigned long bfd_uint64_t;
# 115 "../bfd/bfd.h"
typedef unsigned long bfd_hostptr_t;


typedef struct bfd bfd;
# 129 "../bfd/bfd.h"
typedef int bfd_boolean;
# 141 "../bfd/bfd.h"
typedef unsigned long bfd_vma;
typedef long bfd_signed_vma;
typedef unsigned long bfd_size_type;
typedef unsigned long symvalue;
# 196 "../bfd/bfd.h"
typedef long file_ptr;
typedef unsigned long ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);




typedef unsigned int flagword;
typedef unsigned char bfd_byte;



typedef enum bfd_format
{
  bfd_unknown = 0,
  bfd_object,
  bfd_archive,
  bfd_core,
  bfd_type_end
}
bfd_format;




typedef unsigned long symindex;


typedef const struct reloc_howto_struct reloc_howto_type;
# 248 "../bfd/bfd.h"
typedef struct carsym
{
  char *name;
  file_ptr file_offset;
}
carsym;



struct orl
{
  char **name;
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;
  int namidx;
};


typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;


typedef struct bfd_section *sec_ptr;
# 326 "../bfd/bfd.h"
typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;



extern const char *bfd_get_stab_name (int);






struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int);


extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int, unsigned int);


extern void bfd_hash_table_free
  (struct bfd_hash_table *);





extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);


extern struct bfd_hash_entry *bfd_hash_insert
  (struct bfd_hash_table *, const char *, unsigned long);


extern void bfd_hash_rename
  (struct bfd_hash_table *, const char *, struct bfd_hash_entry *);


extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);


extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);




extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);




extern unsigned long bfd_hash_set_default_size (unsigned long);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG = 1 << 0,
  COMPRESS_DEBUG_GNU_ZLIB = COMPRESS_DEBUG | 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = COMPRESS_DEBUG | 1 << 2
};




struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 486 "../bfd/bfd.h"
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
# 509 "../bfd/bfd.h"
extern void _bfd_warn_deprecated (const char *, const char *, int, const char *);
# 545 "../bfd/bfd.h"
extern bfd_boolean bfd_cache_close
  (bfd *abfd);


extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);



bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);



bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);


struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_section_already_linked;
struct bfd_elf_version_tree;


extern bfd_boolean bfd_section_already_linked_table_init (void);
extern void bfd_section_already_linked_table_free (void);
extern bfd_boolean _bfd_handle_already_linked
  (struct bfd_section *, struct bfd_section_already_linked *,
   struct bfd_link_info *);



extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);



struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2,
  DYN_NO_ADD_NEEDED = 4,
  DYN_NO_NEEDED = 8
};

enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_stack_segment_size (bfd *, struct bfd_link_info *,
            const char *, bfd_vma);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char *, const char *,
   const char * const *, struct bfd_link_info *, struct bfd_section **);
extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
  (bfd *, struct bfd_link_info *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, enum dynamic_lib_link_class);
extern int bfd_elf_get_dyn_lib_class
  (bfd *);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern int bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
extern unsigned int _bfd_elf_default_action_discarded
  (struct bfd_section *);




extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);
# 707 "../bfd/bfd.h"
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);
# 724 "../bfd/bfd.h"
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
         bfd_size_type len));

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern struct bfd_section *
_bfd_nearby_section (bfd *, struct bfd_section *, bfd_vma);

extern void _bfd_fix_excluded_sec_syms
  (bfd *, struct bfd_link_info *);

extern unsigned bfd_m68k_mach_to_features (int);

extern int bfd_m68k_features_to_mach (unsigned);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern void bfd_elf_m68k_set_target_options (struct bfd_link_info *, int);

extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern bfd_boolean bfd_cr16_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);



extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **,
   struct bfd_section **, struct bfd_section **);



extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);



struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);



extern bfd_boolean bfd_xcoff_split_import_path
  (bfd *, const char *, const char **, const char **);
extern bfd_boolean bfd_xcoff_set_archive_import_path
  (struct bfd_link_info *, bfd *, const char *);
extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);


extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);




struct internal_syment;
union internal_auxent;


extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);


typedef enum
{
  BFD_ARM_VFP11_FIX_DEFAULT,
  BFD_ARM_VFP11_FIX_NONE,
  BFD_ARM_VFP11_FIX_SCALAR,
  BFD_ARM_VFP11_FIX_VECTOR
} bfd_arm_vfp11_fix;

extern void bfd_elf32_arm_init_maps
  (bfd *);

extern void bfd_elf32_arm_set_vfp11_fix
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_set_cortex_a8_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_vfp11_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


typedef enum
{
  BFD_ARM_STM32L4XX_FIX_NONE,
  BFD_ARM_STM32L4XX_FIX_DEFAULT,
  BFD_ARM_STM32L4XX_FIX_ALL
} bfd_arm_stm32l4xx_fix;

extern void bfd_elf32_arm_set_stm32l4xx_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_stm32l4xx_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_stm32l4xx_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *);

struct elf32_arm_params {
  char *thumb_entry_symbol;
  int byteswap_code;
  int target1_is_rel;
  char * target2_type;
  int fix_v4bx;
  int use_blx;
  bfd_arm_vfp11_fix vfp11_denorm_fix;
  bfd_arm_stm32l4xx_fix stm32l4xx_fix;
  int no_enum_size_warning;
  int no_wchar_size_warning;
  int pic_veneer;
  int fix_cortex_a8;
  int fix_arm1176;
  int merge_exidx_entries;
  int cmse_implib;
  bfd *in_implib_bfd;
};

void bfd_elf32_arm_set_target_params
  (bfd *, struct bfd_link_info *, struct elf32_arm_params *);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_keep_private_stub_output_sections
  (struct bfd_link_info *);







extern bfd_boolean bfd_is_arm_special_symbol_name
  (const char *, int);

extern void bfd_elf32_arm_set_byteswap_code
  (struct bfd_link_info *, int);

extern void bfd_elf32_arm_use_long_plt (void);


extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);


extern int elf32_arm_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_arm_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_arm_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *,
        struct bfd_section *, unsigned int),
   void (*) (void));
extern bfd_boolean elf32_arm_build_stubs
  (struct bfd_link_info *);


extern bfd_boolean elf32_arm_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);


extern bfd_boolean elf32_tic6x_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);

extern void bfd_elf64_aarch64_init_maps
  (bfd *);

extern void bfd_elf32_aarch64_init_maps
  (bfd *);

extern void bfd_elf64_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);

extern void bfd_elf32_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);






extern bfd_boolean bfd_is_aarch64_special_symbol_name
  (const char * name, int type);


extern int elf64_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf64_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf64_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf64_aarch64_build_stubs
  (struct bfd_link_info *);

extern int elf32_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf32_aarch64_build_stubs
  (struct bfd_link_info *);



extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);


extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);


extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);


extern bfd_boolean v850_elf_create_sections
  (struct bfd_link_info *);

extern bfd_boolean v850_elf_set_note
  (bfd *, unsigned int, unsigned int);


struct elf_internal_abiflags_v0;
extern struct elf_internal_abiflags_v0 *bfd_mips_elf_get_abiflags (bfd *);

void bfd_init (void);



extern unsigned int bfd_use_reserved_id;
bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target,
    void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
    void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
    void *stream,
    void *buf,
    file_ptr nbytes,
    file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
    void *stream),
    int (*stat_func) (struct bfd *abfd,
    void *stream,
    struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd_boolean bfd_close (bfd *abfd);

bfd_boolean bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);

bfd_boolean bfd_make_writable (bfd *abfd);

bfd_boolean bfd_make_readable (bfd *abfd);

void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
# 1241 "../bfd/bfd.h"
long bfd_get_mtime (bfd *abfd);

ufile_ptr bfd_get_size (bfd *abfd);

ufile_ptr bfd_get_file_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);




typedef struct bfd_section
{


  const char *name;


  unsigned int id;


  unsigned int index;


  struct bfd_section *next;


  struct bfd_section *prev;




  flagword flags;
# 1475 "../bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;







  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 1509 "../bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 1529 "../bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 1549 "../bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;


  struct relax_table *relax;


  int relax_count;
# 1568 "../bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  unsigned int alignment_power;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  unsigned char *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;





  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
  } map_head, map_tail;
} asection;




struct relax_table {

  bfd_vma addr;


  int size;
};





static inline bfd_boolean
bfd_set_section_userdata (bfd * abfd __attribute__ ((__unused__)), asection * ptr, void * val)
{
  ptr->userdata = val;
  return 1;
}

static inline bfd_boolean
bfd_set_section_vma (bfd * abfd __attribute__ ((__unused__)), asection * ptr, bfd_vma val)
{
  ptr->vma = ptr->lma = val;
  ptr->user_set_vma = 1;
  return 1;
}

static inline bfd_boolean
bfd_set_section_alignment (bfd * abfd __attribute__ ((__unused__)), asection * ptr, unsigned int val)
{
  ptr->alignment_power = val;
  return 1;
}




extern asection _bfd_std_section[4];
# 1856 "../bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);

int bfd_get_next_section_id (void);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_rename_section
   (bfd *abfd, asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);




bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);

bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1964 "../bfd/bfd.h"
  bfd_arch_vax,
  bfd_arch_i960,
# 1983 "../bfd/bfd.h"
  bfd_arch_or1k,



  bfd_arch_sparc,
# 2025 "../bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 2074 "../bfd/bfd.h"
  bfd_arch_i386,
# 2083 "../bfd/bfd.h"
  bfd_arch_l1om,


  bfd_arch_k1om,






  bfd_arch_iamcu,



  bfd_arch_we32k,
  bfd_arch_tahoe,
  bfd_arch_i860,
  bfd_arch_i370,
  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m88k,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_plugin,
  bfd_arch_powerpc,
# 2143 "../bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_z8k,


  bfd_arch_h8500,
  bfd_arch_sh,
# 2192 "../bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 2211 "../bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_w65,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_tic80,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 2264 "../bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,

  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 2311 "../bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_cr16c,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,

  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 2364 "../bfd/bfd.h"
  bfd_arch_xc16x,



  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,




  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,


  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_wasm32,

  bfd_arch_pru,

  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  bfd_boolean the_default;
  const struct bfd_arch_info * (*compatible)
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);

  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,
                 bfd_boolean code);

  const struct bfd_arch_info *next;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);

bfd_boolean bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (bfd *abfd);

unsigned long bfd_get_mach (bfd *abfd);

unsigned int bfd_arch_bits_per_byte (bfd *abfd);

unsigned int bfd_arch_bits_per_address (bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (bfd *abfd);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);



typedef enum bfd_reloc_status
{

  bfd_reloc_ok,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,





  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;


typedef struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

}
arelent;


enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};
struct bfd_symbol;

struct reloc_howto_struct
{






  unsigned int type;



  unsigned int rightshift;




  int size;



  unsigned int bitsize;


  bfd_boolean pc_relative;



  unsigned int bitpos;



  enum complain_overflow complain_on_overflow;





  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  char *name;
# 2597 "../bfd/bfd.h"
  bfd_boolean partial_inplace;
# 2607 "../bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;







  bfd_boolean pcrel_offset;
};
# 2647 "../bfd/bfd.h"
unsigned int bfd_get_reloc_size (reloc_howto_type *);

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,






  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,


  BFD_RELOC_I960_CALLJ,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 2939 "../bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_16DX_HA,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,
  BFD_RELOC_RISCV_32_PCREL,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5046 "../bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,


  BFD_RELOC_16C_NUM08,
  BFD_RELOC_16C_NUM08_C,
  BFD_RELOC_16C_NUM16,
  BFD_RELOC_16C_NUM16_C,
  BFD_RELOC_16C_NUM32,
  BFD_RELOC_16C_NUM32_C,
  BFD_RELOC_16C_DISP04,
  BFD_RELOC_16C_DISP04_C,
  BFD_RELOC_16C_DISP08,
  BFD_RELOC_16C_DISP08_C,
  BFD_RELOC_16C_DISP16,
  BFD_RELOC_16C_DISP16_C,
  BFD_RELOC_16C_DISP24,
  BFD_RELOC_16C_DISP24_C,
  BFD_RELOC_16C_DISP24a,
  BFD_RELOC_16C_DISP24a_C,
  BFD_RELOC_16C_REG04,
  BFD_RELOC_16C_REG04_C,
  BFD_RELOC_16C_REG04a,
  BFD_RELOC_16C_REG04a_C,
  BFD_RELOC_16C_REG14,
  BFD_RELOC_16C_REG14_C,
  BFD_RELOC_16C_REG16,
  BFD_RELOC_16C_REG16_C,
  BFD_RELOC_16C_REG20,
  BFD_RELOC_16C_REG20_C,
  BFD_RELOC_16C_ABS20,
  BFD_RELOC_16C_ABS20_C,
  BFD_RELOC_16C_ABS24,
  BFD_RELOC_16C_ABS24_C,
  BFD_RELOC_16C_IMM04,
  BFD_RELOC_16C_IMM04_C,
  BFD_RELOC_16C_IMM16,
  BFD_RELOC_16C_IMM16_C,
  BFD_RELOC_16C_IMM20,
  BFD_RELOC_16C_IMM20_C,
  BFD_RELOC_16C_IMM24,
  BFD_RELOC_16C_IMM24_C,
  BFD_RELOC_16C_IMM32,
  BFD_RELOC_16C_IMM32_C,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_GOTOFF_HI16,
  BFD_RELOC_OR1K_GOTOFF_LO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_XC16X_PAG,
  BFD_RELOC_XC16X_POF,
  BFD_RELOC_XC16X_SEG,
  BFD_RELOC_XC16X_SOF,


  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 5621 "../bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,







  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,


  BFD_RELOC_WASM32_LEB128,
  BFD_RELOC_WASM32_LEB128_GOT,
  BFD_RELOC_WASM32_LEB128_GOT_CODE,
  BFD_RELOC_WASM32_LEB128_PLT,
  BFD_RELOC_WASM32_PLT_INDEX,
  BFD_RELOC_WASM32_ABS32_CODE,
  BFD_RELOC_WASM32_COPY,
  BFD_RELOC_WASM32_CODE_POINTER,
  BFD_RELOC_WASM32_INDEX,
  BFD_RELOC_WASM32_PLT_SIG,
  BFD_RELOC_UNUSED };

typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);



typedef struct bfd_symbol
{
# 6522 "../bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 6637 "../bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;




bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);




bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);







bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);

bfd_boolean bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);







enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;



  ufile_ptr where;


  long mtime;


  unsigned int id;


  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;


  flagword flags : 20;
# 6856 "../bfd/bfd.h"
  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;



  bfd *plugin_dummy_bfd;




  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;



  int archive_pass;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct _oasys_data *oasys_obj_data;
      struct _oasys_ar_data *oasys_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct ieee_data_struct *ieee_data;
      struct ieee_ar_data_struct *ieee_ar_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct nlm_obj_tdata *nlm_obj_data;
      struct bout_data_struct *bout_data;
      struct mmo_data_struct *mmo_data;
      struct sun_core_struct *sun_core_data;
      struct sco5_core_struct *sco5_core_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct versados_data_struct *versados_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};


static inline bfd_boolean
bfd_set_cacheable (bfd * abfd, bfd_boolean val)
{
  abfd->cacheable = val;
  return 1;
}


typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag, ...);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);


typedef void (*bfd_error_handler_type) (const char *, va_list);

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);


typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
                                         const char *bfd_version,
                                         const char *bfd_file,
                                         int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);



bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);

bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
# 7205 "../bfd/bfd.h"
extern bfd_byte *bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);

bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

void bfd_emul_set_maxpagesize (const char *, bfd_vma);

bfd_vma bfd_emul_get_commonpagesize (const char *);

void bfd_emul_set_commonpagesize (const char *, bfd_vma);

char *bfd_demangle (bfd *, const char *, int);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

bfd_boolean bfd_check_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec,
    bfd_size_type *uncompressed_size);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);

bfd_size_type bfd_convert_section_size
   (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);

bfd_boolean bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);

bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);

bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);

bfd_boolean generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);
# 7280 "../bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


typedef struct bfd_link_info _bfd_link_info;


typedef struct flag_info flag_info;

typedef struct bfd_target
{

  char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;




  bfd_uint64_t (*bfd_getx64) (const void *);
  bfd_int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  bfd_uint64_t (*bfd_h_getx64) (const void *);
  bfd_int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);





  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7400 "../bfd/bfd.h"
  bfd_boolean (*_close_and_cleanup) (bfd *);

  bfd_boolean (*_bfd_free_cached_info) (bfd *);

  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);

  bfd_boolean (*_bfd_get_section_contents)
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
  bfd_boolean (*_bfd_get_section_contents_in_window)
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
# 7424 "../bfd/bfd.h"
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);




  bfd_boolean (*_bfd_init_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);


  bfd_boolean (*_bfd_copy_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr);


  bfd_boolean (*_bfd_copy_private_symbol_data)
    (bfd *, asymbol *, bfd *, asymbol *);


  bfd_boolean (*_bfd_copy_private_header_data)
    (bfd *, bfd *);

  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);


  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7459 "../bfd/bfd.h"
  char * (*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7478 "../bfd/bfd.h"
  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
  bfd_boolean (*_bfd_construct_extended_name_table)
    (bfd *, char **, bfd_size_type *, const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  bfd_boolean (*write_armap)
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void * (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd * (*openr_next_archived_file) (bfd *, bfd *);

  bfd * (*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
# 7511 "../bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol)
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);

  void (*_bfd_get_symbol_info)
    (bfd *, struct bfd_symbol *, symbol_info *);

  const char *(*_bfd_get_symbol_version_string)
    (bfd *, struct bfd_symbol *, bfd_boolean *);

  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent * (*_get_lineno) (bfd *, struct bfd_symbol *);
  bfd_boolean (*_bfd_find_nearest_line)
    (bfd *, struct bfd_symbol **, struct bfd_section *, bfd_vma,
     const char **, const char **, unsigned int *, unsigned int *);
  bfd_boolean (*_bfd_find_line)
    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
     const char **, unsigned int *);
  bfd_boolean (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol * (*_bfd_make_debug_symbol)
    (bfd *, void *, unsigned long size);


  long (*_read_minisymbols)
    (bfd *, bfd_boolean, void **, unsigned int *);


  asymbol * (*_minisymbol_to_symbol)
    (bfd *, bfd_boolean, const void *, asymbol *);
# 7558 "../bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc)
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
  void (*_bfd_set_reloc)
    (bfd *, sec_ptr, arelent **, unsigned int);

  reloc_howto_type *
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
              (*reloc_name_lookup) (bfd *, const char *);







  bfd_boolean (*_bfd_set_arch_mach)
    (bfd *, enum bfd_architecture, unsigned long);
  bfd_boolean (*_bfd_set_section_contents)
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
# 7601 "../bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte * (*_bfd_get_relocated_section_contents)
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);

  bfd_boolean (*_bfd_relax_section)
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);



  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) (bfd *);


  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type)
    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);



  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
                                            struct flag_info *,
                                            asection *);


  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);



  bfd_boolean (*_section_already_linked) (bfd *, asection *,
                                          struct bfd_link_info *);


  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
                                            struct bfd_link_hash_entry *);


  struct bfd_link_hash_entry *(*_bfd_define_start_stop) (struct bfd_link_info *,
                                                         const char *,
                                                         asection *);
# 7677 "../bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab)
    (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab)
    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
     struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc)
    (bfd *, arelent **, struct bfd_symbol **);


  const struct bfd_target * alternative_target;



  const void *backend_data;

} bfd_target;

bfd_boolean bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    bfd_boolean *is_bigendian,
    int *underscoring,
    const char **def_target_arch);
const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);


bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);

bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);


bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);




bfd_boolean bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);




bfd_boolean bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_link_hash_entry *bfd_generic_define_start_stop
   (struct bfd_link_info *info,
    const char *symbol, asection *sec);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, bfd_boolean *hide);

bfd_boolean bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);

bfd_boolean bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);





bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


bfd_boolean bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);

void bfd_cache_section_contents
   (asection *sec, void *contents);

bfd_boolean bfd_is_section_compressed_with_header
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p);

bfd_boolean bfd_is_section_compressed
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_decompress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_compress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);
# 60 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/binutils/bucomm.h" 1
# 27 "/doner/binutils/binutils-7a31b38/binutils/bucomm.h"
const char *bfd_get_archive_filename (const bfd *);

void bfd_nonfatal (const char *);

void bfd_nonfatal_message (const char *, const bfd *, const asection *,
      const char *, ...);

void bfd_fatal (const char *) __attribute__ ((__noreturn__));

void report (const char *, va_list) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));

void fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__noreturn__));

void non_fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

void set_default_bfd_target (void);

void list_matching_formats (char **);

void list_supported_targets (const char *, FILE *);

void list_supported_architectures (const char *, FILE *);

int display_info (void);

void print_arelt_descr (FILE *, bfd *, bfd_boolean);

char *make_tempname (char *);
char *make_tempdir (char *);

bfd_vma parse_vma (const char *, const char *);

off_t get_file_size (const char *);

bfd_boolean is_valid_archive_path (char const *);

extern char *program_name;


void mode_string (unsigned long, char *);


extern void print_version (const char *);


extern void set_times (const char *, const struct stat *);

extern int smart_rename (const char *, const char *, int);


void *xmalloc (size_t);

void *xrealloc (void *, size_t);
# 61 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/binutils/elfcomm.h" 1
# 27 "/doner/binutils/binutils-7a31b38/binutils/elfcomm.h"
# 1 "./../include/aout/ar.h" 1
# 44 "./../include/aout/ar.h"
struct ar_hdr
{
  char ar_name[16];
  char ar_date[12];
  char ar_uid[6];
  char ar_gid[6];
  char ar_mode[8];
  char ar_size[10];
  char ar_fmag[2];
};
# 28 "/doner/binutils/binutils-7a31b38/binutils/elfcomm.h" 2

void error (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
void warn (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

typedef unsigned long elf_vma;

extern void (*byte_put) (unsigned char *, elf_vma, int);
extern void byte_put_little_endian (unsigned char *, elf_vma, int);
extern void byte_put_big_endian (unsigned char *, elf_vma, int);

extern elf_vma (*byte_get) (unsigned char *, int);
extern elf_vma byte_get_signed (unsigned char *, int);
extern elf_vma byte_get_little_endian (unsigned char *, int);
extern elf_vma byte_get_big_endian (unsigned char *, int);
extern void byte_get_64 (unsigned char *, elf_vma *, elf_vma *);
# 55 "/doner/binutils/binutils-7a31b38/binutils/elfcomm.h"
struct archive_info
{
  char * file_name;
  FILE * file;
  elf_vma index_num;
  elf_vma * index_array;
  char * sym_table;
  unsigned long sym_size;
  char * longnames;
  unsigned long longnames_size;
  unsigned long nested_member_origin;
  unsigned long next_arhdr_offset;
  bfd_boolean is_thin_archive;
  bfd_boolean uses_64bit_indicies;
  struct ar_hdr arhdr;
};


extern char *adjust_relative_path (const char *, const char *, unsigned long);


extern int setup_archive (struct archive_info *, const char *, FILE *,
     bfd_boolean, bfd_boolean);


extern int setup_nested_archive (struct archive_info *, const char *);


extern void release_archive (struct archive_info *);



extern char *get_archive_member_name (struct archive_info *,
          struct archive_info *);




extern char *get_archive_member_name_at (struct archive_info *,
      unsigned long,
      struct archive_info *);




extern char *make_qualified_name (struct archive_info *,
      struct archive_info *,
      const char *);
# 62 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/binutils/dwarf.h" 1
# 21 "/doner/binutils/binutils-7a31b38/binutils/dwarf.h"
# 1 "./../include/dwarf2.h" 1
# 80 "./../include/dwarf2.h"
# 1 "./../include/dwarf2.def" 1
# 71 "./../include/dwarf2.def"
enum dwarf_tag { DW_TAG_padding = 0x00
, DW_TAG_array_type = 0x01
, DW_TAG_class_type = 0x02
, DW_TAG_entry_point = 0x03
, DW_TAG_enumeration_type = 0x04
, DW_TAG_formal_parameter = 0x05
, DW_TAG_imported_declaration = 0x08
, DW_TAG_label = 0x0a
, DW_TAG_lexical_block = 0x0b
, DW_TAG_member = 0x0d
, DW_TAG_pointer_type = 0x0f
, DW_TAG_reference_type = 0x10
, DW_TAG_compile_unit = 0x11
, DW_TAG_string_type = 0x12
, DW_TAG_structure_type = 0x13
, DW_TAG_subroutine_type = 0x15
, DW_TAG_typedef = 0x16
, DW_TAG_union_type = 0x17
, DW_TAG_unspecified_parameters = 0x18
, DW_TAG_variant = 0x19
, DW_TAG_common_block = 0x1a
, DW_TAG_common_inclusion = 0x1b
, DW_TAG_inheritance = 0x1c
, DW_TAG_inlined_subroutine = 0x1d
, DW_TAG_module = 0x1e
, DW_TAG_ptr_to_member_type = 0x1f
, DW_TAG_set_type = 0x20
, DW_TAG_subrange_type = 0x21
, DW_TAG_with_stmt = 0x22
, DW_TAG_access_declaration = 0x23
, DW_TAG_base_type = 0x24
, DW_TAG_catch_block = 0x25
, DW_TAG_const_type = 0x26
, DW_TAG_constant = 0x27
, DW_TAG_enumerator = 0x28
, DW_TAG_file_type = 0x29
, DW_TAG_friend = 0x2a
, DW_TAG_namelist = 0x2b
, DW_TAG_namelist_item = 0x2c
, DW_TAG_packed_type = 0x2d
, DW_TAG_subprogram = 0x2e
, DW_TAG_template_type_param = 0x2f
, DW_TAG_template_value_param = 0x30
, DW_TAG_thrown_type = 0x31
, DW_TAG_try_block = 0x32
, DW_TAG_variant_part = 0x33
, DW_TAG_variable = 0x34
, DW_TAG_volatile_type = 0x35

, DW_TAG_dwarf_procedure = 0x36
, DW_TAG_restrict_type = 0x37
, DW_TAG_interface_type = 0x38
, DW_TAG_namespace = 0x39
, DW_TAG_imported_module = 0x3a
, DW_TAG_unspecified_type = 0x3b
, DW_TAG_partial_unit = 0x3c
, DW_TAG_imported_unit = 0x3d
, DW_TAG_condition = 0x3f
, DW_TAG_shared_type = 0x40

, DW_TAG_type_unit = 0x41
, DW_TAG_rvalue_reference_type = 0x42
, DW_TAG_template_alias = 0x43

, DW_TAG_coarray_type = 0x44
, DW_TAG_generic_subrange = 0x45
, DW_TAG_dynamic_type = 0x46
, DW_TAG_atomic_type = 0x47
, DW_TAG_call_site = 0x48
, DW_TAG_call_site_parameter = 0x49
, DW_TAG_skeleton_unit = 0x4a
, DW_TAG_immutable_type = 0x4b

, DW_TAG_lo_user = 0x4080
, DW_TAG_hi_user = 0xffff


, DW_TAG_MIPS_loop = 0x4081


, DW_TAG_HP_array_descriptor = 0x4090
, DW_TAG_HP_Bliss_field = 0x4091
, DW_TAG_HP_Bliss_field_set = 0x4092


, DW_TAG_format_label = 0x4101
, DW_TAG_function_template = 0x4102
, DW_TAG_class_template = 0x4103
, DW_TAG_GNU_BINCL = 0x4104
, DW_TAG_GNU_EINCL = 0x4105


, DW_TAG_GNU_template_template_param = 0x4106





, DW_TAG_GNU_template_parameter_pack = 0x4107
, DW_TAG_GNU_formal_parameter_pack = 0x4108




, DW_TAG_GNU_call_site = 0x4109
, DW_TAG_GNU_call_site_parameter = 0x410a

, DW_TAG_upc_shared_type = 0x8765
, DW_TAG_upc_strict_type = 0x8766
, DW_TAG_upc_relaxed_type = 0x8767

, DW_TAG_PGI_kanji_type = 0xA000
, DW_TAG_PGI_interface_block = 0xA020
};

enum dwarf_form { DW_FORM_addr = 0x01
, DW_FORM_block2 = 0x03
, DW_FORM_block4 = 0x04
, DW_FORM_data2 = 0x05
, DW_FORM_data4 = 0x06
, DW_FORM_data8 = 0x07
, DW_FORM_string = 0x08
, DW_FORM_block = 0x09
, DW_FORM_block1 = 0x0a
, DW_FORM_data1 = 0x0b
, DW_FORM_flag = 0x0c
, DW_FORM_sdata = 0x0d
, DW_FORM_strp = 0x0e
, DW_FORM_udata = 0x0f
, DW_FORM_ref_addr = 0x10
, DW_FORM_ref1 = 0x11
, DW_FORM_ref2 = 0x12
, DW_FORM_ref4 = 0x13
, DW_FORM_ref8 = 0x14
, DW_FORM_ref_udata = 0x15
, DW_FORM_indirect = 0x16

, DW_FORM_sec_offset = 0x17
, DW_FORM_exprloc = 0x18
, DW_FORM_flag_present = 0x19
, DW_FORM_ref_sig8 = 0x20

, DW_FORM_strx = 0x1a
, DW_FORM_addrx = 0x1b
, DW_FORM_ref_sup4 = 0x1c
, DW_FORM_strp_sup = 0x1d
, DW_FORM_data16 = 0x1e
, DW_FORM_line_strp = 0x1f
, DW_FORM_implicit_const = 0x21
, DW_FORM_loclistx = 0x22
, DW_FORM_rnglistx = 0x23
, DW_FORM_ref_sup8 = 0x24

, DW_FORM_GNU_addr_index = 0x1f01
, DW_FORM_GNU_str_index = 0x1f02


, DW_FORM_GNU_ref_alt = 0x1f20
, DW_FORM_GNU_strp_alt = 0x1f21
};

enum dwarf_attribute { DW_AT_sibling = 0x01
, DW_AT_location = 0x02
, DW_AT_name = 0x03
, DW_AT_ordering = 0x09
, DW_AT_subscr_data = 0x0a
, DW_AT_byte_size = 0x0b
, DW_AT_bit_offset = 0x0c
, DW_AT_bit_size = 0x0d
, DW_AT_element_list = 0x0f
, DW_AT_stmt_list = 0x10
, DW_AT_low_pc = 0x11
, DW_AT_high_pc = 0x12
, DW_AT_language = 0x13
, DW_AT_member = 0x14
, DW_AT_discr = 0x15
, DW_AT_discr_value = 0x16
, DW_AT_visibility = 0x17
, DW_AT_import = 0x18
, DW_AT_string_length = 0x19
, DW_AT_common_reference = 0x1a
, DW_AT_comp_dir = 0x1b
, DW_AT_const_value = 0x1c
, DW_AT_containing_type = 0x1d
, DW_AT_default_value = 0x1e
, DW_AT_inline = 0x20
, DW_AT_is_optional = 0x21
, DW_AT_lower_bound = 0x22
, DW_AT_producer = 0x25
, DW_AT_prototyped = 0x27
, DW_AT_return_addr = 0x2a
, DW_AT_start_scope = 0x2c
, DW_AT_bit_stride = 0x2e
, DW_AT_upper_bound = 0x2f
, DW_AT_abstract_origin = 0x31
, DW_AT_accessibility = 0x32
, DW_AT_address_class = 0x33
, DW_AT_artificial = 0x34
, DW_AT_base_types = 0x35
, DW_AT_calling_convention = 0x36
, DW_AT_count = 0x37
, DW_AT_data_member_location = 0x38
, DW_AT_decl_column = 0x39
, DW_AT_decl_file = 0x3a
, DW_AT_decl_line = 0x3b
, DW_AT_declaration = 0x3c
, DW_AT_discr_list = 0x3d
, DW_AT_encoding = 0x3e
, DW_AT_external = 0x3f
, DW_AT_frame_base = 0x40
, DW_AT_friend = 0x41
, DW_AT_identifier_case = 0x42
, DW_AT_macro_info = 0x43
, DW_AT_namelist_items = 0x44
, DW_AT_priority = 0x45
, DW_AT_segment = 0x46
, DW_AT_specification = 0x47
, DW_AT_static_link = 0x48
, DW_AT_type = 0x49
, DW_AT_use_location = 0x4a
, DW_AT_variable_parameter = 0x4b
, DW_AT_virtuality = 0x4c
, DW_AT_vtable_elem_location = 0x4d

, DW_AT_allocated = 0x4e
, DW_AT_associated = 0x4f
, DW_AT_data_location = 0x50
, DW_AT_byte_stride = 0x51
, DW_AT_entry_pc = 0x52
, DW_AT_use_UTF8 = 0x53
, DW_AT_extension = 0x54
, DW_AT_ranges = 0x55
, DW_AT_trampoline = 0x56
, DW_AT_call_column = 0x57
, DW_AT_call_file = 0x58
, DW_AT_call_line = 0x59
, DW_AT_description = 0x5a
, DW_AT_binary_scale = 0x5b
, DW_AT_decimal_scale = 0x5c
, DW_AT_small = 0x5d
, DW_AT_decimal_sign = 0x5e
, DW_AT_digit_count = 0x5f
, DW_AT_picture_string = 0x60
, DW_AT_mutable = 0x61
, DW_AT_threads_scaled = 0x62
, DW_AT_explicit = 0x63
, DW_AT_object_pointer = 0x64
, DW_AT_endianity = 0x65
, DW_AT_elemental = 0x66
, DW_AT_pure = 0x67
, DW_AT_recursive = 0x68

, DW_AT_signature = 0x69
, DW_AT_main_subprogram = 0x6a
, DW_AT_data_bit_offset = 0x6b
, DW_AT_const_expr = 0x6c
, DW_AT_enum_class = 0x6d
, DW_AT_linkage_name = 0x6e

, DW_AT_string_length_bit_size = 0x6f
, DW_AT_string_length_byte_size = 0x70
, DW_AT_rank = 0x71
, DW_AT_str_offsets_base = 0x72
, DW_AT_addr_base = 0x73
, DW_AT_rnglists_base = 0x74
, DW_AT_dwo_name = 0x76
, DW_AT_reference = 0x77
, DW_AT_rvalue_reference = 0x78
, DW_AT_macros = 0x79
, DW_AT_call_all_calls = 0x7a
, DW_AT_call_all_source_calls = 0x7b
, DW_AT_call_all_tail_calls = 0x7c
, DW_AT_call_return_pc = 0x7d
, DW_AT_call_value = 0x7e
, DW_AT_call_origin = 0x7f
, DW_AT_call_parameter = 0x80
, DW_AT_call_pc = 0x81
, DW_AT_call_tail_call = 0x82
, DW_AT_call_target = 0x83
, DW_AT_call_target_clobbered = 0x84
, DW_AT_call_data_location = 0x85
, DW_AT_call_data_value = 0x86
, DW_AT_noreturn = 0x87
, DW_AT_alignment = 0x88
, DW_AT_export_symbols = 0x89
, DW_AT_deleted = 0x8a
, DW_AT_defaulted = 0x8b
, DW_AT_loclists_base = 0x8c

, DW_AT_lo_user = 0x2000
, DW_AT_hi_user = 0x3fff


, DW_AT_MIPS_fde = 0x2001
, DW_AT_MIPS_loop_begin = 0x2002
, DW_AT_MIPS_tail_loop_begin = 0x2003
, DW_AT_MIPS_epilog_begin = 0x2004
, DW_AT_MIPS_loop_unroll_factor = 0x2005
, DW_AT_MIPS_software_pipeline_depth = 0x2006
, DW_AT_MIPS_linkage_name = 0x2007
, DW_AT_MIPS_stride = 0x2008
, DW_AT_MIPS_abstract_name = 0x2009
, DW_AT_MIPS_clone_origin = 0x200a
, DW_AT_MIPS_has_inlines = 0x200b

, DW_AT_HP_block_index = 0x2000
, DW_AT_HP_unmodifiable = 0x2001
, DW_AT_HP_prologue = 0x2005
, DW_AT_HP_epilogue = 0x2008
, DW_AT_HP_actuals_stmt_list = 0x2010
, DW_AT_HP_proc_per_section = 0x2011
, DW_AT_HP_raw_data_ptr = 0x2012
, DW_AT_HP_pass_by_reference = 0x2013
, DW_AT_HP_opt_level = 0x2014
, DW_AT_HP_prof_version_id = 0x2015
, DW_AT_HP_opt_flags = 0x2016
, DW_AT_HP_cold_region_low_pc = 0x2017
, DW_AT_HP_cold_region_high_pc = 0x2018
, DW_AT_HP_all_variables_modifiable = 0x2019
, DW_AT_HP_linkage_name = 0x201a
, DW_AT_HP_prof_flags = 0x201b
, DW_AT_HP_unit_name = 0x201f
, DW_AT_HP_unit_size = 0x2020
, DW_AT_HP_widened_byte_size = 0x2021
, DW_AT_HP_definition_points = 0x2022
, DW_AT_HP_default_location = 0x2023
, DW_AT_HP_is_result_param = 0x2029


, DW_AT_sf_names = 0x2101
, DW_AT_src_info = 0x2102
, DW_AT_mac_info = 0x2103
, DW_AT_src_coords = 0x2104
, DW_AT_body_begin = 0x2105
, DW_AT_body_end = 0x2106
, DW_AT_GNU_vector = 0x2107


, DW_AT_GNU_guarded_by = 0x2108
, DW_AT_GNU_pt_guarded_by = 0x2109
, DW_AT_GNU_guarded = 0x210a
, DW_AT_GNU_pt_guarded = 0x210b
, DW_AT_GNU_locks_excluded = 0x210c
, DW_AT_GNU_exclusive_locks_required = 0x210d
, DW_AT_GNU_shared_locks_required = 0x210e


, DW_AT_GNU_odr_signature = 0x210f


, DW_AT_GNU_template_name = 0x2110


, DW_AT_GNU_call_site_value = 0x2111
, DW_AT_GNU_call_site_data_value = 0x2112
, DW_AT_GNU_call_site_target = 0x2113
, DW_AT_GNU_call_site_target_clobbered = 0x2114
, DW_AT_GNU_tail_call = 0x2115
, DW_AT_GNU_all_tail_call_sites = 0x2116
, DW_AT_GNU_all_call_sites = 0x2117
, DW_AT_GNU_all_source_call_sites = 0x2118

, DW_AT_GNU_macros = 0x2119

, DW_AT_GNU_deleted = 0x211a

, DW_AT_GNU_dwo_name = 0x2130
, DW_AT_GNU_dwo_id = 0x2131
, DW_AT_GNU_ranges_base = 0x2132
, DW_AT_GNU_addr_base = 0x2133
, DW_AT_GNU_pubnames = 0x2134
, DW_AT_GNU_pubtypes = 0x2135


, DW_AT_GNU_discriminator = 0x2136

, DW_AT_VMS_rtnbeg_pd_address = 0x2201



, DW_AT_use_GNAT_descriptive_type = 0x2301
, DW_AT_GNAT_descriptive_type = 0x2302


, DW_AT_GNU_numerator = 0x2303
, DW_AT_GNU_denominator = 0x2304


, DW_AT_GNU_bias = 0x2305

, DW_AT_upc_threads_scaled = 0x3210

, DW_AT_PGI_lbase = 0x3a00
, DW_AT_PGI_soffset = 0x3a01
, DW_AT_PGI_lstride = 0x3a02

, DW_AT_APPLE_optimized = 0x3fe1
, DW_AT_APPLE_flags = 0x3fe2
, DW_AT_APPLE_isa = 0x3fe3
, DW_AT_APPLE_block = 0x3fe4
, DW_AT_APPLE_major_runtime_vers = 0x3fe5
, DW_AT_APPLE_runtime_class = 0x3fe6
, DW_AT_APPLE_omit_frame_ptr = 0x3fe7
, DW_AT_APPLE_property_name = 0x3fe8
, DW_AT_APPLE_property_getter = 0x3fe9
, DW_AT_APPLE_property_setter = 0x3fea
, DW_AT_APPLE_property_attribute = 0x3feb
, DW_AT_APPLE_objc_complete_type = 0x3fec
, DW_AT_APPLE_property = 0x3fed
};

enum dwarf_location_atom { DW_OP_addr = 0x03
, DW_OP_deref = 0x06
, DW_OP_const1u = 0x08
, DW_OP_const1s = 0x09
, DW_OP_const2u = 0x0a
, DW_OP_const2s = 0x0b
, DW_OP_const4u = 0x0c
, DW_OP_const4s = 0x0d
, DW_OP_const8u = 0x0e
, DW_OP_const8s = 0x0f
, DW_OP_constu = 0x10
, DW_OP_consts = 0x11
, DW_OP_dup = 0x12
, DW_OP_drop = 0x13
, DW_OP_over = 0x14
, DW_OP_pick = 0x15
, DW_OP_swap = 0x16
, DW_OP_rot = 0x17
, DW_OP_xderef = 0x18
, DW_OP_abs = 0x19
, DW_OP_and = 0x1a
, DW_OP_div = 0x1b
, DW_OP_minus = 0x1c
, DW_OP_mod = 0x1d
, DW_OP_mul = 0x1e
, DW_OP_neg = 0x1f
, DW_OP_not = 0x20
, DW_OP_or = 0x21
, DW_OP_plus = 0x22
, DW_OP_plus_uconst = 0x23
, DW_OP_shl = 0x24
, DW_OP_shr = 0x25
, DW_OP_shra = 0x26
, DW_OP_xor = 0x27
, DW_OP_bra = 0x28
, DW_OP_eq = 0x29
, DW_OP_ge = 0x2a
, DW_OP_gt = 0x2b
, DW_OP_le = 0x2c
, DW_OP_lt = 0x2d
, DW_OP_ne = 0x2e
, DW_OP_skip = 0x2f
, DW_OP_lit0 = 0x30
, DW_OP_lit1 = 0x31
, DW_OP_lit2 = 0x32
, DW_OP_lit3 = 0x33
, DW_OP_lit4 = 0x34
, DW_OP_lit5 = 0x35
, DW_OP_lit6 = 0x36
, DW_OP_lit7 = 0x37
, DW_OP_lit8 = 0x38
, DW_OP_lit9 = 0x39
, DW_OP_lit10 = 0x3a
, DW_OP_lit11 = 0x3b
, DW_OP_lit12 = 0x3c
, DW_OP_lit13 = 0x3d
, DW_OP_lit14 = 0x3e
, DW_OP_lit15 = 0x3f
, DW_OP_lit16 = 0x40
, DW_OP_lit17 = 0x41
, DW_OP_lit18 = 0x42
, DW_OP_lit19 = 0x43
, DW_OP_lit20 = 0x44
, DW_OP_lit21 = 0x45
, DW_OP_lit22 = 0x46
, DW_OP_lit23 = 0x47
, DW_OP_lit24 = 0x48
, DW_OP_lit25 = 0x49
, DW_OP_lit26 = 0x4a
, DW_OP_lit27 = 0x4b
, DW_OP_lit28 = 0x4c
, DW_OP_lit29 = 0x4d
, DW_OP_lit30 = 0x4e
, DW_OP_lit31 = 0x4f
, DW_OP_reg0 = 0x50
, DW_OP_reg1 = 0x51
, DW_OP_reg2 = 0x52
, DW_OP_reg3 = 0x53
, DW_OP_reg4 = 0x54
, DW_OP_reg5 = 0x55
, DW_OP_reg6 = 0x56
, DW_OP_reg7 = 0x57
, DW_OP_reg8 = 0x58
, DW_OP_reg9 = 0x59
, DW_OP_reg10 = 0x5a
, DW_OP_reg11 = 0x5b
, DW_OP_reg12 = 0x5c
, DW_OP_reg13 = 0x5d
, DW_OP_reg14 = 0x5e
, DW_OP_reg15 = 0x5f
, DW_OP_reg16 = 0x60
, DW_OP_reg17 = 0x61
, DW_OP_reg18 = 0x62
, DW_OP_reg19 = 0x63
, DW_OP_reg20 = 0x64
, DW_OP_reg21 = 0x65
, DW_OP_reg22 = 0x66
, DW_OP_reg23 = 0x67
, DW_OP_reg24 = 0x68
, DW_OP_reg25 = 0x69
, DW_OP_reg26 = 0x6a
, DW_OP_reg27 = 0x6b
, DW_OP_reg28 = 0x6c
, DW_OP_reg29 = 0x6d
, DW_OP_reg30 = 0x6e
, DW_OP_reg31 = 0x6f
, DW_OP_breg0 = 0x70
, DW_OP_breg1 = 0x71
, DW_OP_breg2 = 0x72
, DW_OP_breg3 = 0x73
, DW_OP_breg4 = 0x74
, DW_OP_breg5 = 0x75
, DW_OP_breg6 = 0x76
, DW_OP_breg7 = 0x77
, DW_OP_breg8 = 0x78
, DW_OP_breg9 = 0x79
, DW_OP_breg10 = 0x7a
, DW_OP_breg11 = 0x7b
, DW_OP_breg12 = 0x7c
, DW_OP_breg13 = 0x7d
, DW_OP_breg14 = 0x7e
, DW_OP_breg15 = 0x7f
, DW_OP_breg16 = 0x80
, DW_OP_breg17 = 0x81
, DW_OP_breg18 = 0x82
, DW_OP_breg19 = 0x83
, DW_OP_breg20 = 0x84
, DW_OP_breg21 = 0x85
, DW_OP_breg22 = 0x86
, DW_OP_breg23 = 0x87
, DW_OP_breg24 = 0x88
, DW_OP_breg25 = 0x89
, DW_OP_breg26 = 0x8a
, DW_OP_breg27 = 0x8b
, DW_OP_breg28 = 0x8c
, DW_OP_breg29 = 0x8d
, DW_OP_breg30 = 0x8e
, DW_OP_breg31 = 0x8f
, DW_OP_regx = 0x90
, DW_OP_fbreg = 0x91
, DW_OP_bregx = 0x92
, DW_OP_piece = 0x93
, DW_OP_deref_size = 0x94
, DW_OP_xderef_size = 0x95
, DW_OP_nop = 0x96

, DW_OP_push_object_address = 0x97
, DW_OP_call2 = 0x98
, DW_OP_call4 = 0x99
, DW_OP_call_ref = 0x9a
, DW_OP_form_tls_address = 0x9b
, DW_OP_call_frame_cfa = 0x9c
, DW_OP_bit_piece = 0x9d


, DW_OP_implicit_value = 0x9e
, DW_OP_stack_value = 0x9f


, DW_OP_implicit_pointer = 0xa0
, DW_OP_addrx = 0xa1
, DW_OP_constx = 0xa2
, DW_OP_entry_value = 0xa3
, DW_OP_const_type = 0xa4
, DW_OP_regval_type = 0xa5
, DW_OP_deref_type = 0xa6
, DW_OP_xderef_type = 0xa7
, DW_OP_convert = 0xa8
, DW_OP_reinterpret = 0xa9

, DW_OP_lo_user = 0xe0
, DW_OP_hi_user = 0xff


, DW_OP_GNU_push_tls_address = 0xe0

, DW_OP_GNU_uninit = 0xf0
, DW_OP_GNU_encoded_addr = 0xf1


, DW_OP_GNU_implicit_pointer = 0xf2


, DW_OP_GNU_entry_value = 0xf3


, DW_OP_GNU_const_type = 0xf4
, DW_OP_GNU_regval_type = 0xf5
, DW_OP_GNU_deref_type = 0xf6
, DW_OP_GNU_convert = 0xf7
, DW_OP_GNU_reinterpret = 0xf9

, DW_OP_GNU_parameter_ref = 0xfa

, DW_OP_GNU_addr_index = 0xfb
, DW_OP_GNU_const_index = 0xfc


, DW_OP_GNU_variable_value = 0xfd

, DW_OP_HP_unknown = 0xe0
, DW_OP_HP_is_value = 0xe1
, DW_OP_HP_fltconst4 = 0xe2
, DW_OP_HP_fltconst8 = 0xe3
, DW_OP_HP_mod_range = 0xe4
, DW_OP_HP_unmod_range = 0xe5
, DW_OP_HP_tls = 0xe6

, DW_OP_PGI_omp_thread_num = 0xf8





, DW_OP_AARCH64_operation = 0xea
};

enum dwarf_type { DW_ATE_void = 0x0
, DW_ATE_address = 0x1
, DW_ATE_boolean = 0x2
, DW_ATE_complex_float = 0x3
, DW_ATE_float = 0x4
, DW_ATE_signed = 0x5
, DW_ATE_signed_char = 0x6
, DW_ATE_unsigned = 0x7
, DW_ATE_unsigned_char = 0x8

, DW_ATE_imaginary_float = 0x9
, DW_ATE_packed_decimal = 0xa
, DW_ATE_numeric_string = 0xb
, DW_ATE_edited = 0xc
, DW_ATE_signed_fixed = 0xd
, DW_ATE_unsigned_fixed = 0xe
, DW_ATE_decimal_float = 0xf

, DW_ATE_UTF = 0x10

, DW_ATE_UCS = 0x11
, DW_ATE_ASCII = 0x12

, DW_ATE_lo_user = 0x80
, DW_ATE_hi_user = 0xff


, DW_ATE_HP_float80 = 0x80
, DW_ATE_HP_complex_float80 = 0x81
, DW_ATE_HP_float128 = 0x82
, DW_ATE_HP_complex_float128 = 0x83
, DW_ATE_HP_floathpintel = 0x84
, DW_ATE_HP_imaginary_float80 = 0x85
, DW_ATE_HP_imaginary_float128 = 0x86
, DW_ATE_HP_VAX_float = 0x88
, DW_ATE_HP_VAX_float_d = 0x89
, DW_ATE_HP_packed_decimal = 0x8a
, DW_ATE_HP_zoned_decimal = 0x8b
, DW_ATE_HP_edited = 0x8c
, DW_ATE_HP_signed_fixed = 0x8d
, DW_ATE_HP_unsigned_fixed = 0x8e
, DW_ATE_HP_VAX_complex_float = 0x8f
, DW_ATE_HP_VAX_complex_float_d = 0x90

};

enum dwarf_call_frame_info { DW_CFA_advance_loc = 0x40
, DW_CFA_offset = 0x80
, DW_CFA_restore = 0xc0
, DW_CFA_nop = 0x00
, DW_CFA_set_loc = 0x01
, DW_CFA_advance_loc1 = 0x02
, DW_CFA_advance_loc2 = 0x03
, DW_CFA_advance_loc4 = 0x04
, DW_CFA_offset_extended = 0x05
, DW_CFA_restore_extended = 0x06
, DW_CFA_undefined = 0x07
, DW_CFA_same_value = 0x08
, DW_CFA_register = 0x09
, DW_CFA_remember_state = 0x0a
, DW_CFA_restore_state = 0x0b
, DW_CFA_def_cfa = 0x0c
, DW_CFA_def_cfa_register = 0x0d
, DW_CFA_def_cfa_offset = 0x0e

, DW_CFA_def_cfa_expression = 0x0f
, DW_CFA_expression = 0x10
, DW_CFA_offset_extended_sf = 0x11
, DW_CFA_def_cfa_sf = 0x12
, DW_CFA_def_cfa_offset_sf = 0x13
, DW_CFA_val_offset = 0x14
, DW_CFA_val_offset_sf = 0x15
, DW_CFA_val_expression = 0x16

, DW_CFA_lo_user = 0x1c
, DW_CFA_hi_user = 0x3f


, DW_CFA_MIPS_advance_loc8 = 0x1d


, DW_CFA_GNU_window_save = 0x2d
, DW_CFA_GNU_args_size = 0x2e
, DW_CFA_GNU_negative_offset_extended = 0x2f

};


enum dwarf_name_index_attribute { DW_IDX_compile_unit = 1
, DW_IDX_type_unit = 2
, DW_IDX_die_offset = 3
, DW_IDX_parent = 4
, DW_IDX_type_hash = 5
, DW_IDX_lo_user = 0x2000
, DW_IDX_hi_user = 0x3fff
, DW_IDX_GNU_internal = 0x2000
, DW_IDX_GNU_external = 0x2001
};
# 81 "./../include/dwarf2.h" 2
# 118 "./../include/dwarf2.h"
enum dwarf_decimal_sign_encoding
  {

    DW_DS_unsigned = 0x01,
    DW_DS_leading_overpunch = 0x02,
    DW_DS_trailing_overpunch = 0x03,
    DW_DS_leading_separate = 0x04,
    DW_DS_trailing_separate = 0x05
  };


enum dwarf_endianity_encoding
  {

    DW_END_default = 0x00,
    DW_END_big = 0x01,
    DW_END_little = 0x02,

    DW_END_lo_user = 0x40,
    DW_END_hi_user = 0xff
  };


enum dwarf_array_dim_ordering
  {
    DW_ORD_row_major = 0,
    DW_ORD_col_major = 1
  };


enum dwarf_access_attribute
  {
    DW_ACCESS_public = 1,
    DW_ACCESS_protected = 2,
    DW_ACCESS_private = 3
  };


enum dwarf_visibility_attribute
  {
    DW_VIS_local = 1,
    DW_VIS_exported = 2,
    DW_VIS_qualified = 3
  };


enum dwarf_virtuality_attribute
  {
    DW_VIRTUALITY_none = 0,
    DW_VIRTUALITY_virtual = 1,
    DW_VIRTUALITY_pure_virtual = 2
  };


enum dwarf_id_case
  {
    DW_ID_case_sensitive = 0,
    DW_ID_up_case = 1,
    DW_ID_down_case = 2,
    DW_ID_case_insensitive = 3
  };


enum dwarf_calling_convention
  {
    DW_CC_normal = 0x1,
    DW_CC_program = 0x2,
    DW_CC_nocall = 0x3,


    DW_CC_pass_by_reference = 0x4,
    DW_CC_pass_by_value = 0x5,

    DW_CC_lo_user = 0x40,
    DW_CC_hi_user = 0xff,

    DW_CC_GNU_renesas_sh = 0x40,
    DW_CC_GNU_borland_fastcall_i386 = 0x41,







    DW_CC_GDB_IBM_OpenCL = 0xff
  };


enum dwarf_inline_attribute
  {
    DW_INL_not_inlined = 0,
    DW_INL_inlined = 1,
    DW_INL_declared_not_inlined = 2,
    DW_INL_declared_inlined = 3
  };


enum dwarf_discrim_list
  {
    DW_DSC_label = 0,
    DW_DSC_range = 1
  };


enum dwarf_line_number_ops
  {
    DW_LNS_extended_op = 0,
    DW_LNS_copy = 1,
    DW_LNS_advance_pc = 2,
    DW_LNS_advance_line = 3,
    DW_LNS_set_file = 4,
    DW_LNS_set_column = 5,
    DW_LNS_negate_stmt = 6,
    DW_LNS_set_basic_block = 7,
    DW_LNS_const_add_pc = 8,
    DW_LNS_fixed_advance_pc = 9,

    DW_LNS_set_prologue_end = 10,
    DW_LNS_set_epilogue_begin = 11,
    DW_LNS_set_isa = 12
  };


enum dwarf_line_number_x_ops
  {
    DW_LNE_end_sequence = 1,
    DW_LNE_set_address = 2,
    DW_LNE_define_file = 3,
    DW_LNE_set_discriminator = 4,

    DW_LNE_HP_negate_is_UV_update = 0x11,
    DW_LNE_HP_push_context = 0x12,
    DW_LNE_HP_pop_context = 0x13,
    DW_LNE_HP_set_file_line_column = 0x14,
    DW_LNE_HP_set_routine_name = 0x15,
    DW_LNE_HP_set_sequence = 0x16,
    DW_LNE_HP_negate_post_semantics = 0x17,
    DW_LNE_HP_negate_function_exit = 0x18,
    DW_LNE_HP_negate_front_end_logical = 0x19,
    DW_LNE_HP_define_proc = 0x20,
    DW_LNE_HP_source_file_correlation = 0x80,

    DW_LNE_lo_user = 0x80,
    DW_LNE_hi_user = 0xff
  };


enum dwarf_line_number_hp_sfc_ops
  {
    DW_LNE_HP_SFC_formfeed = 1,
    DW_LNE_HP_SFC_set_listing_line = 2,
    DW_LNE_HP_SFC_associate = 3
  };



enum dwarf_line_number_content_type
  {
    DW_LNCT_path = 0x1,
    DW_LNCT_directory_index = 0x2,
    DW_LNCT_timestamp = 0x3,
    DW_LNCT_size = 0x4,
    DW_LNCT_MD5 = 0x5,
    DW_LNCT_lo_user = 0x2000,
    DW_LNCT_hi_user = 0x3fff
  };


enum dwarf_location_list_entry_type
  {
    DW_LLE_end_of_list = 0x00,
    DW_LLE_base_addressx = 0x01,
    DW_LLE_startx_endx = 0x02,
    DW_LLE_startx_length = 0x03,
    DW_LLE_offset_pair = 0x04,
    DW_LLE_default_location = 0x05,
    DW_LLE_base_address = 0x06,
    DW_LLE_start_end = 0x07,
    DW_LLE_start_length = 0x08,



    DW_LLE_GNU_end_of_list_entry = 0x00,
    DW_LLE_GNU_base_address_selection_entry = 0x01,
    DW_LLE_GNU_start_end_entry = 0x02,
    DW_LLE_GNU_start_length_entry = 0x03
  };
# 319 "./../include/dwarf2.h"
enum dwarf_source_language
  {
    DW_LANG_C89 = 0x0001,
    DW_LANG_C = 0x0002,
    DW_LANG_Ada83 = 0x0003,
    DW_LANG_C_plus_plus = 0x0004,
    DW_LANG_Cobol74 = 0x0005,
    DW_LANG_Cobol85 = 0x0006,
    DW_LANG_Fortran77 = 0x0007,
    DW_LANG_Fortran90 = 0x0008,
    DW_LANG_Pascal83 = 0x0009,
    DW_LANG_Modula2 = 0x000a,

    DW_LANG_Java = 0x000b,
    DW_LANG_C99 = 0x000c,
    DW_LANG_Ada95 = 0x000d,
    DW_LANG_Fortran95 = 0x000e,
    DW_LANG_PLI = 0x000f,
    DW_LANG_ObjC = 0x0010,
    DW_LANG_ObjC_plus_plus = 0x0011,
    DW_LANG_UPC = 0x0012,
    DW_LANG_D = 0x0013,

    DW_LANG_Python = 0x0014,

    DW_LANG_OpenCL = 0x0015,
    DW_LANG_Go = 0x0016,
    DW_LANG_Modula3 = 0x0017,
    DW_LANG_Haskell = 0x0018,
    DW_LANG_C_plus_plus_03 = 0x0019,
    DW_LANG_C_plus_plus_11 = 0x001a,
    DW_LANG_OCaml = 0x001b,
    DW_LANG_Rust = 0x001c,
    DW_LANG_C11 = 0x001d,
    DW_LANG_Swift = 0x001e,
    DW_LANG_Julia = 0x001f,
    DW_LANG_Dylan = 0x0020,
    DW_LANG_C_plus_plus_14 = 0x0021,
    DW_LANG_Fortran03 = 0x0022,
    DW_LANG_Fortran08 = 0x0023,
    DW_LANG_RenderScript = 0x0024,

    DW_LANG_lo_user = 0x8000,
    DW_LANG_hi_user = 0xffff,


    DW_LANG_Mips_Assembler = 0x8001,

    DW_LANG_Upc = 0x8765,

    DW_LANG_HP_Bliss = 0x8003,
    DW_LANG_HP_Basic91 = 0x8004,
    DW_LANG_HP_Pascal91 = 0x8005,
    DW_LANG_HP_IMacro = 0x8006,
    DW_LANG_HP_Assembler = 0x8007,


    DW_LANG_Rust_old = 0x9000
  };


enum dwarf_macinfo_record_type
  {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
  };


enum dwarf_defaulted_attribute
  {
    DW_DEFAULTED_no = 0x00,
    DW_DEFAULTED_in_class = 0x01,
    DW_DEFAULTED_out_of_class = 0x02
  };


enum dwarf_macro_record_type
  {
    DW_MACRO_define = 0x01,
    DW_MACRO_undef = 0x02,
    DW_MACRO_start_file = 0x03,
    DW_MACRO_end_file = 0x04,
    DW_MACRO_define_strp = 0x05,
    DW_MACRO_undef_strp = 0x06,
    DW_MACRO_import = 0x07,
    DW_MACRO_define_sup = 0x08,
    DW_MACRO_undef_sup = 0x09,
    DW_MACRO_import_sup = 0x0a,
    DW_MACRO_define_strx = 0x0b,
    DW_MACRO_undef_strx = 0x0c,
    DW_MACRO_lo_user = 0xe0,
    DW_MACRO_hi_user = 0xff,


    DW_MACRO_GNU_define = 0x01,
    DW_MACRO_GNU_undef = 0x02,
    DW_MACRO_GNU_start_file = 0x03,
    DW_MACRO_GNU_end_file = 0x04,
    DW_MACRO_GNU_define_indirect = 0x05,
    DW_MACRO_GNU_undef_indirect = 0x06,
    DW_MACRO_GNU_transparent_include = 0x07,


    DW_MACRO_GNU_define_indirect_alt = 0x08,
    DW_MACRO_GNU_undef_indirect_alt = 0x09,
    DW_MACRO_GNU_transparent_include_alt = 0x0a,
    DW_MACRO_GNU_lo_user = 0xe0,
    DW_MACRO_GNU_hi_user = 0xff
  };


enum dwarf_range_list_entry
  {
    DW_RLE_end_of_list = 0x00,
    DW_RLE_base_addressx = 0x01,
    DW_RLE_startx_endx = 0x02,
    DW_RLE_startx_length = 0x03,
    DW_RLE_offset_pair = 0x04,
    DW_RLE_base_address = 0x05,
    DW_RLE_start_end = 0x06,
    DW_RLE_start_length = 0x07
  };


enum dwarf_unit_type
  {
    DW_UT_compile = 0x01,
    DW_UT_type = 0x02,
    DW_UT_partial = 0x03,
    DW_UT_skeleton = 0x04,
    DW_UT_split_compile = 0x05,
    DW_UT_split_type = 0x06,
    DW_UT_lo_user = 0x80,
    DW_UT_hi_user = 0xff
  };
# 483 "./../include/dwarf2.h"
enum dwarf_sect
  {
    DW_SECT_INFO = 1,
    DW_SECT_TYPES = 2,
    DW_SECT_ABBREV = 3,
    DW_SECT_LINE = 4,
    DW_SECT_LOC = 5,
    DW_SECT_STR_OFFSETS = 6,
    DW_SECT_MACINFO = 7,
    DW_SECT_MACRO = 8,
    DW_SECT_MAX = 8
  };







extern const char *get_DW_TAG_name (unsigned int tag);



extern const char *get_DW_AT_name (unsigned int attr);



extern const char *get_DW_FORM_name (unsigned int form);



extern const char *get_DW_OP_name (unsigned int op);



extern const char *get_DW_ATE_name (unsigned int enc);



extern const char *get_DW_CFA_name (unsigned int opc);



extern const char *get_DW_IDX_name (unsigned int idx);
# 22 "/doner/binutils/binutils-7a31b38/binutils/dwarf.h" 2

typedef unsigned long dwarf_vma;
typedef long dwarf_signed_vma;
typedef unsigned long dwarf_size_type;


typedef struct
{
  dwarf_vma li_length;
  unsigned short li_version;
  dwarf_vma li_prologue_length;
  unsigned char li_min_insn_length;
  unsigned char li_max_ops_per_insn;
  unsigned char li_default_is_stmt;
  int li_line_base;
  unsigned char li_line_range;
  unsigned char li_opcode_base;
  unsigned int li_offset_size;
}
DWARF2_Internal_LineInfo;


typedef struct
{
  dwarf_vma pn_length;
  unsigned short pn_version;
  dwarf_vma pn_offset;
  dwarf_vma pn_size;
}
DWARF2_Internal_PubNames;


typedef struct
{
  dwarf_vma cu_length;
  unsigned short cu_version;
  dwarf_vma cu_abbrev_offset;
  unsigned char cu_pointer_size;
  enum dwarf_unit_type cu_unit_type;
}
DWARF2_Internal_CompUnit;


typedef struct
{
  dwarf_vma ar_length;
  unsigned short ar_version;
  dwarf_vma ar_info_offset;
  unsigned char ar_pointer_size;
  unsigned char ar_segment_size;
}
DWARF2_Internal_ARange;



enum dwarf_section_display_enum
{
  abbrev = 0,
  aranges,
  frame,
  info,
  line,
  pubnames,
  gnu_pubnames,
  eh_frame,
  macinfo,
  macro,
  str,
  line_str,
  loc,
  loclists,
  pubtypes,
  gnu_pubtypes,
  ranges,
  rnglists,
  static_func,
  static_vars,
  types,
  weaknames,
  gdb_index,
  debug_names,
  trace_info,
  trace_abbrev,
  trace_aranges,
  info_dwo,
  abbrev_dwo,
  types_dwo,
  line_dwo,
  loc_dwo,
  macro_dwo,
  macinfo_dwo,
  str_dwo,
  str_index,
  str_index_dwo,
  debug_addr,
  dwp_cu_index,
  dwp_tu_index,
  max
};

struct dwarf_section
{




  const char *uncompressed_name;
  const char *compressed_name;
  const char *name;
  unsigned char *start;
  dwarf_vma address;
  dwarf_size_type size;
  enum dwarf_section_display_enum abbrev_sec;


  void * reloc_info;
  unsigned long num_relocs;


  void *user_data;
};



struct dwarf_section_display
{
  struct dwarf_section section;
  int (*display) (struct dwarf_section *, void *);
  int *enabled;
  bfd_boolean relocate;
};

extern struct dwarf_section_display debug_displays [];



typedef struct
{
  unsigned int pointer_size;
  unsigned int offset_size;
  int dwarf_version;
  dwarf_vma cu_offset;
  dwarf_vma base_address;


  dwarf_vma addr_base;


  dwarf_vma ranges_base;

  dwarf_vma * loc_offsets;
  int * have_frame_base;
  unsigned int num_loc_offsets;
  unsigned int max_loc_offsets;

  dwarf_vma * range_lists;
  unsigned int num_range_lists;
  unsigned int max_range_lists;
}
debug_info;

extern unsigned int eh_addr_size;

extern int do_debug_info;
extern int do_debug_abbrevs;
extern int do_debug_lines;
extern int do_debug_pubnames;
extern int do_debug_pubtypes;
extern int do_debug_aranges;
extern int do_debug_ranges;
extern int do_debug_frames;
extern int do_debug_frames_interp;
extern int do_debug_macinfo;
extern int do_debug_str;
extern int do_debug_loc;
extern int do_gdb_index;
extern int do_trace_info;
extern int do_trace_abbrevs;
extern int do_trace_aranges;
extern int do_debug_addr;
extern int do_debug_cu_index;
extern int do_wide;

extern int dwarf_cutoff_level;
extern unsigned long dwarf_start_die;

extern int dwarf_check;

extern void init_dwarf_regnames (unsigned int);
extern void init_dwarf_regnames_i386 (void);
extern void init_dwarf_regnames_iamcu (void);
extern void init_dwarf_regnames_x86_64 (void);
extern void init_dwarf_regnames_aarch64 (void);
extern void init_dwarf_regnames_s390 (void);

extern int load_debug_section (enum dwarf_section_display_enum, void *);
extern void free_debug_section (enum dwarf_section_display_enum);

extern void free_debug_memory (void);

extern void dwarf_select_sections_by_names (const char *);
extern void dwarf_select_sections_by_letters (const char *);
extern void dwarf_select_sections_all (void);

extern unsigned int * find_cu_tu_set (void *, unsigned int);

extern void * cmalloc (size_t, size_t);
extern void * xcalloc2 (size_t, size_t);
extern void * xcmalloc (size_t, size_t);
extern void * xcrealloc (void *, size_t, size_t);

extern dwarf_vma read_leb128 (unsigned char *, unsigned int *, bfd_boolean, const unsigned char * const);




extern bfd_boolean reloc_at (struct dwarf_section *, dwarf_vma);
# 63 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2

# 1 "./../include/elf/common.h" 1
# 65 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/external.h" 1
# 52 "./../include/elf/external.h"
typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[4];
  unsigned char e_phoff[4];
  unsigned char e_shoff[4];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf32_External_Ehdr;

typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[8];
  unsigned char e_phoff[8];
  unsigned char e_shoff[8];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf64_External_Ehdr;



typedef struct {
  unsigned char p_type[4];
  unsigned char p_offset[4];
  unsigned char p_vaddr[4];
  unsigned char p_paddr[4];
  unsigned char p_filesz[4];
  unsigned char p_memsz[4];
  unsigned char p_flags[4];
  unsigned char p_align[4];
} Elf32_External_Phdr;

typedef struct {
  unsigned char p_type[4];
  unsigned char p_flags[4];
  unsigned char p_offset[8];
  unsigned char p_vaddr[8];
  unsigned char p_paddr[8];
  unsigned char p_filesz[8];
  unsigned char p_memsz[8];
  unsigned char p_align[8];
} Elf64_External_Phdr;



typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[4];
  unsigned char sh_addr[4];
  unsigned char sh_offset[4];
  unsigned char sh_size[4];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[4];
  unsigned char sh_entsize[4];
} Elf32_External_Shdr;

typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[8];
  unsigned char sh_addr[8];
  unsigned char sh_offset[8];
  unsigned char sh_size[8];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[8];
  unsigned char sh_entsize[8];
} Elf64_External_Shdr;



typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_size[4];
  unsigned char ch_addralign[4];
} Elf32_External_Chdr;

typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_reserved[4];
  unsigned char ch_size[8];
  unsigned char ch_addralign[8];
} Elf64_External_Chdr;



typedef struct {
  unsigned char st_name[4];
  unsigned char st_value[4];
  unsigned char st_size[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
} Elf32_External_Sym;

typedef struct {
  unsigned char st_name[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
  unsigned char st_value[8];
  unsigned char st_size[8];
} Elf64_External_Sym;

typedef struct {
  unsigned char est_shndx[4];
} Elf_External_Sym_Shndx;



typedef struct {
  unsigned char namesz[4];
  unsigned char descsz[4];
  unsigned char type[4];
  char name[1];
} Elf_External_Note;


typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
} Elf32_External_Rel;

typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
  unsigned char r_addend[4];
} Elf32_External_Rela;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
} Elf64_External_Rel;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
  unsigned char r_addend[8];
} Elf64_External_Rela;



typedef struct {
  unsigned char d_tag[4];
  union {
    unsigned char d_val[4];
    unsigned char d_ptr[4];
  } d_un;
} Elf32_External_Dyn;

typedef struct {
  unsigned char d_tag[8];
  union {
    unsigned char d_val[8];
    unsigned char d_ptr[8];
  } d_un;
} Elf64_External_Dyn;







typedef struct {
  unsigned char vd_version[2];
  unsigned char vd_flags[2];
  unsigned char vd_ndx[2];
  unsigned char vd_cnt[2];
  unsigned char vd_hash[4];
  unsigned char vd_aux[4];
  unsigned char vd_next[4];
} Elf_External_Verdef;



typedef struct {
  unsigned char vda_name[4];
  unsigned char vda_next[4];
} Elf_External_Verdaux;



typedef struct {
  unsigned char vn_version[2];
  unsigned char vn_cnt[2];
  unsigned char vn_file[4];
  unsigned char vn_aux[4];
  unsigned char vn_next[4];
} Elf_External_Verneed;



typedef struct {
  unsigned char vna_hash[4];
  unsigned char vna_flags[2];
  unsigned char vna_other[2];
  unsigned char vna_name[4];
  unsigned char vna_next[4];
} Elf_External_Vernaux;




typedef struct {
  unsigned char vs_vers[2];
} __attribute__ ((packed)) Elf_External_Versym;


typedef struct
{
  unsigned char si_boundto[2];
  unsigned char si_flags[2];
} Elf_External_Syminfo;



typedef struct
{
  unsigned char a_type[4];
  unsigned char a_val[4];
} Elf32_External_Auxv;

typedef struct
{
  unsigned char a_type[8];
  unsigned char a_val[8];
} Elf64_External_Auxv;
# 66 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/internal.h" 1
# 67 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr {
  unsigned char e_ident[16];
  bfd_vma e_entry;
  bfd_size_type e_phoff;
  bfd_size_type e_shoff;
  unsigned long e_version;
  unsigned long e_flags;
  unsigned short e_type;
  unsigned short e_machine;
  unsigned int e_ehsize;
  unsigned int e_phentsize;
  unsigned int e_phnum;
  unsigned int e_shentsize;
  unsigned int e_shnum;
  unsigned int e_shstrndx;
} Elf_Internal_Ehdr;



struct elf_internal_phdr {
  unsigned long p_type;
  unsigned long p_flags;
  bfd_vma p_offset;
  bfd_vma p_vaddr;
  bfd_vma p_paddr;
  bfd_vma p_filesz;
  bfd_vma p_memsz;
  bfd_vma p_align;
};

typedef struct elf_internal_phdr Elf_Internal_Phdr;



typedef struct elf_internal_shdr {
  unsigned int sh_name;
  unsigned int sh_type;
  bfd_vma sh_flags;
  bfd_vma sh_addr;
  file_ptr sh_offset;
  bfd_size_type sh_size;
  unsigned int sh_link;
  unsigned int sh_info;
  bfd_vma sh_addralign;
  bfd_size_type sh_entsize;


  asection * bfd_section;
  unsigned char *contents;
} Elf_Internal_Shdr;



typedef struct elf_internal_chdr {
  unsigned int ch_type;
  bfd_size_type ch_size;
  bfd_vma ch_addralign;
} Elf_Internal_Chdr;



struct elf_internal_sym {
  bfd_vma st_value;
  bfd_vma st_size;
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
  unsigned char st_target_internal;
  unsigned int st_shndx;
};

typedef struct elf_internal_sym Elf_Internal_Sym;



typedef struct elf_internal_note {
  unsigned long namesz;
  unsigned long descsz;
  unsigned long type;
  char * namedata;
  char * descdata;
  bfd_vma descpos;
} Elf_Internal_Note;



typedef struct elf_internal_rela {
  bfd_vma r_offset;
  bfd_vma r_info;
  bfd_vma r_addend;
} Elf_Internal_Rela;



typedef struct elf_internal_dyn {

  bfd_vma d_tag;
  union {

    bfd_vma d_val;
    bfd_vma d_ptr;
  } d_un;
} Elf_Internal_Dyn;



typedef struct elf_internal_verdef {
  unsigned short vd_version;
  unsigned short vd_flags;
  unsigned short vd_ndx;
  unsigned short vd_cnt;
  unsigned long vd_hash;
  unsigned long vd_aux;
  unsigned long vd_next;



  bfd *vd_bfd;
  const char *vd_nodename;
  struct elf_internal_verdef *vd_nextdef;
  struct elf_internal_verdaux *vd_auxptr;
  unsigned int vd_exp_refno;
} Elf_Internal_Verdef;



typedef struct elf_internal_verdaux {
  unsigned long vda_name;
  unsigned long vda_next;



  const char *vda_nodename;
  struct elf_internal_verdaux *vda_nextptr;
} Elf_Internal_Verdaux;



typedef struct elf_internal_verneed {
  unsigned short vn_version;
  unsigned short vn_cnt;
  unsigned long vn_file;
  unsigned long vn_aux;
  unsigned long vn_next;



  bfd *vn_bfd;
  const char *vn_filename;
  struct elf_internal_vernaux *vn_auxptr;
  struct elf_internal_verneed *vn_nextref;
} Elf_Internal_Verneed;



typedef struct elf_internal_vernaux {
  unsigned long vna_hash;
  unsigned short vna_flags;
  unsigned short vna_other;
  unsigned long vna_name;
  unsigned long vna_next;



  const char *vna_nodename;
  struct elf_internal_vernaux *vna_nextptr;
} Elf_Internal_Vernaux;




typedef struct elf_internal_versym {
  unsigned short vs_vers;
} Elf_Internal_Versym;


typedef struct
{
  unsigned short int si_boundto;
  unsigned short int si_flags;
} Elf_Internal_Syminfo;


typedef struct
{
  bfd_vma a_type;
  bfd_vma a_val;
} Elf_Internal_Auxv;





struct elf_segment_map
{

  struct elf_segment_map *next;

  unsigned long p_type;

  unsigned long p_flags;

  bfd_vma p_paddr;

  bfd_vma p_vaddr_offset;

  bfd_vma p_align;

  bfd_vma p_size;

  bfd_vma header_size;


  unsigned int p_flags_valid : 1;


  unsigned int p_paddr_valid : 1;


  unsigned int p_align_valid : 1;


  unsigned int p_size_valid : 1;

  unsigned int includes_filehdr : 1;

  unsigned int includes_phdrs : 1;

  unsigned int count;

  asection *sections[1];
};
# 67 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2







# 1 "./../include/elf/h8.h" 1
# 23 "./../include/elf/h8.h"
# 1 "./../include/elf/reloc-macros.h" 1
# 24 "./../include/elf/h8.h" 2



enum elf_h8_reloc_type {
  R_H8_NONE = 0,
  R_H8_DIR32 = 1,
  R_H8_DIR32_28 = 2,
  R_H8_DIR32_24 = 3,
  R_H8_DIR32_16 = 4,
  R_H8_DIR32U = 6,
  R_H8_DIR32U_28 = 7,
  R_H8_DIR32U_24 = 8,
  R_H8_DIR32U_20 = 9,
  R_H8_DIR32U_16 = 10,
  R_H8_DIR24 = 11,
  R_H8_DIR24_20 = 12,
  R_H8_DIR24_16 = 13,
  R_H8_DIR24U = 14,
  R_H8_DIR24U_20 = 15,
  R_H8_DIR24U_16 = 16,
  R_H8_DIR16 = 17,
  R_H8_DIR16U = 18,
  R_H8_DIR16S_32 = 19,
  R_H8_DIR16S_28 = 20,
  R_H8_DIR16S_24 = 21,
  R_H8_DIR16S_20 = 22,
  R_H8_DIR16S = 23,
  R_H8_DIR8 = 24,
  R_H8_DIR8U = 25,
  R_H8_DIR8Z_32 = 26,
  R_H8_DIR8Z_28 = 27,
  R_H8_DIR8Z_24 = 28,
  R_H8_DIR8Z_20 = 29,
  R_H8_DIR8Z_16 = 30,
  R_H8_PCREL16 = 31,
  R_H8_PCREL8 = 32,
  R_H8_BPOS = 33,
  R_H8_FIRST_INVALID_DIR_RELOC = 34,
  R_H8_LAST_INVALID_DIR_RELOC = 58,
  R_H8_DIR16A8 = 59,
  R_H8_DIR16R8 = 60,
  R_H8_DIR24A8 = 61,
  R_H8_DIR24R8 = 62,
  R_H8_DIR32A16 = 63,
  R_H8_DISP32A16 = 64,
  R_H8_ABS32 = 65,
  R_H8_ABS32A16 = 127,
  R_H8_SYM = 128,
  R_H8_OPneg = 129,
  R_H8_OPadd = 130,
  R_H8_OPsub = 131,
  R_H8_OPmul = 132,
  R_H8_OPdiv = 133,
  R_H8_OPshla = 134,
  R_H8_OPshra = 135,
  R_H8_OPsctsize = 136,
  R_H8_OPhword = 137,
  R_H8_OPlword = 138,
  R_H8_OPhigh = 139,
  R_H8_OPlow = 140,
  R_H8_OPscttop = 141,
R_H8_max };
# 75 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 92 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
# 1 "./../include/elf/aarch64.h" 1
# 25 "./../include/elf/aarch64.h"
# 1 "./../include/elf/reloc-macros.h" 1
# 26 "./../include/elf/aarch64.h" 2
# 41 "./../include/elf/aarch64.h"
static const char *elf_aarch64_reloc_type (unsigned long rtype); static const char * elf_aarch64_reloc_type (unsigned long rtype) { switch (rtype) {


case 0: return "R_AARCH64_NONE";




case 1: return "R_AARCH64_P32_ABS32";


case 2: return "R_AARCH64_P32_ABS16";


case 3: return "R_AARCH64_P32_PREL32";


case 4: return "R_AARCH64_P32_PREL16";





case 5: return "R_AARCH64_P32_MOVW_UABS_G0";


case 6: return "R_AARCH64_P32_MOVW_UABS_G0_NC";


case 7: return "R_AARCH64_P32_MOVW_UABS_G1";






case 8: return "R_AARCH64_P32_MOVW_SABS_G0";





case 9: return "R_AARCH64_P32_LD_PREL_LO19";


case 10: return "R_AARCH64_P32_ADR_PREL_LO21";


case 11: return "R_AARCH64_P32_ADR_PREL_PG_HI21";


case 12: return "R_AARCH64_P32_ADD_ABS_LO12_NC";


case 13: return "R_AARCH64_P32_LDST8_ABS_LO12_NC";


case 14: return "R_AARCH64_P32_LDST16_ABS_LO12_NC";


case 15: return "R_AARCH64_P32_LDST32_ABS_LO12_NC";


case 16: return "R_AARCH64_P32_LDST64_ABS_LO12_NC";


case 17: return "R_AARCH64_P32_LDST128_ABS_LO12_NC";




case 18: return "R_AARCH64_P32_TSTBR14";


case 19: return "R_AARCH64_P32_CONDBR19";


case 20: return "R_AARCH64_P32_JUMP26";


case 21: return "R_AARCH64_P32_CALL26";


case 25: return "R_AARCH64_P32_GOT_LD_PREL19";
case 26: return "R_AARCH64_P32_ADR_GOT_PAGE";
case 27: return "R_AARCH64_P32_LD32_GOT_LO12_NC";
case 28: return "R_AARCH64_P32_LD32_GOTPAGE_LO14";

case 80: return "R_AARCH64_P32_TLSGD_ADR_PREL21";
case 81: return "R_AARCH64_P32_TLSGD_ADR_PAGE21";
case 82: return "R_AARCH64_P32_TLSGD_ADD_LO12_NC";
case 83: return "R_AARCH64_P32_TLSLD_ADR_PREL21";
case 84: return "R_AARCH64_P32_TLSLD_ADR_PAGE21";
case 85: return "R_AARCH64_P32_TLSLD_ADD_LO12_NC";
case 87: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G1";
case 88: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0";
case 89: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0_NC";
case 90: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_HI12";
case 91: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12";
case 92: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12_NC";
case 103: return "R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21";
case 104: return "R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC";
case 105: return "R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19";
case 106: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G1";
case 107: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0";
case 108: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC";
case 109: return "R_AARCH64_P32_TLSLE_ADD_TPREL_HI12";
case 110: return "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12";
case 111: return "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC";

case 122: return "R_AARCH64_P32_TLSDESC_LD_PREL19";
case 123: return "R_AARCH64_P32_TLSDESC_ADR_PREL21";
case 124: return "R_AARCH64_P32_TLSDESC_ADR_PAGE21";
case 125: return "R_AARCH64_P32_TLSDESC_LD32_LO12_NC";
case 126: return "R_AARCH64_P32_TLSDESC_ADD_LO12_NC";
case 127: return "R_AARCH64_P32_TLSDESC_CALL";




case 180: return "R_AARCH64_P32_COPY";


case 181: return "R_AARCH64_P32_GLOB_DAT";


case 182: return "R_AARCH64_P32_JUMP_SLOT";


case 183: return "R_AARCH64_P32_RELATIVE";
case 184: return "R_AARCH64_P32_TLS_DTPMOD";
case 185: return "R_AARCH64_P32_TLS_DTPREL";
case 186: return "R_AARCH64_P32_TLS_TPREL";
case 187: return "R_AARCH64_P32_TLSDESC";
case 188: return "R_AARCH64_P32_IRELATIVE";

case 256: return "R_AARCH64_NULL";




case 257: return "R_AARCH64_ABS64";


case 258: return "R_AARCH64_ABS32";


case 259: return "R_AARCH64_ABS16";


case 260: return "R_AARCH64_PREL64";


case 261: return "R_AARCH64_PREL32";


case 262: return "R_AARCH64_PREL16";





case 263: return "R_AARCH64_MOVW_UABS_G0";


case 264: return "R_AARCH64_MOVW_UABS_G0_NC";


case 265: return "R_AARCH64_MOVW_UABS_G1";


case 266: return "R_AARCH64_MOVW_UABS_G1_NC";


case 267: return "R_AARCH64_MOVW_UABS_G2";


case 268: return "R_AARCH64_MOVW_UABS_G2_NC";


case 269: return "R_AARCH64_MOVW_UABS_G3";






case 270: return "R_AARCH64_MOVW_SABS_G0";


case 271: return "R_AARCH64_MOVW_SABS_G1";


case 272: return "R_AARCH64_MOVW_SABS_G2";





case 273: return "R_AARCH64_LD_PREL_LO19";


case 274: return "R_AARCH64_ADR_PREL_LO21";


case 275: return "R_AARCH64_ADR_PREL_PG_HI21";


case 276: return "R_AARCH64_ADR_PREL_PG_HI21_NC";


case 277: return "R_AARCH64_ADD_ABS_LO12_NC";


case 278: return "R_AARCH64_LDST8_ABS_LO12_NC";




case 279: return "R_AARCH64_TSTBR14";


case 280: return "R_AARCH64_CONDBR19";




case 282: return "R_AARCH64_JUMP26";


case 283: return "R_AARCH64_CALL26";


case 284: return "R_AARCH64_LDST16_ABS_LO12_NC";


case 285: return "R_AARCH64_LDST32_ABS_LO12_NC";


case 286: return "R_AARCH64_LDST64_ABS_LO12_NC";




case 287: return "R_AARCH64_MOVW_PREL_G0";
case 288: return "R_AARCH64_MOVW_PREL_G0_NC";
case 289: return "R_AARCH64_MOVW_PREL_G1";
case 290: return "R_AARCH64_MOVW_PREL_G1_NC";
case 291: return "R_AARCH64_MOVW_PREL_G2";
case 292: return "R_AARCH64_MOVW_PREL_G2_NC";
case 293: return "R_AARCH64_MOVW_PREL_G3";


case 299: return "R_AARCH64_LDST128_ABS_LO12_NC";




case 300: return "R_AARCH64_MOVW_GOTOFF_G0";
case 301: return "R_AARCH64_MOVW_GOTOFF_G0_NC";
case 302: return "R_AARCH64_MOVW_GOTOFF_G1";
case 303: return "R_AARCH64_MOVW_GOTOFF_G1_NC";
case 304: return "R_AARCH64_MOVW_GOTOFF_G2";
case 305: return "R_AARCH64_MOVW_GOTOFF_G2_NC";
case 306: return "R_AARCH64_MOVW_GOTOFF_G3";



case 307: return "R_AARCH64_GOTREL64";
case 308: return "R_AARCH64_GOTREL32";



case 309: return "R_AARCH64_GOT_LD_PREL19";
case 310: return "R_AARCH64_LD64_GOTOFF_LO15";
case 311: return "R_AARCH64_ADR_GOT_PAGE";
case 312: return "R_AARCH64_LD64_GOT_LO12_NC";
case 313: return "R_AARCH64_LD64_GOTPAGE_LO15";



case 512: return "R_AARCH64_TLSGD_ADR_PREL21";
case 513: return "R_AARCH64_TLSGD_ADR_PAGE21";
case 514: return "R_AARCH64_TLSGD_ADD_LO12_NC";
case 515: return "R_AARCH64_TLSGD_MOVW_G1";
case 516: return "R_AARCH64_TLSGD_MOVW_G0_NC";



case 517: return "R_AARCH64_TLSLD_ADR_PREL21";
case 518: return "R_AARCH64_TLSLD_ADR_PAGE21";
case 519: return "R_AARCH64_TLSLD_ADD_LO12_NC";
case 520: return "R_AARCH64_TLSLD_MOVW_G1";
case 521: return "R_AARCH64_TLSLD_MOVW_G0_NC";
case 522: return "R_AARCH64_TLSLD_LD_PREL19";
case 523: return "R_AARCH64_TLSLD_MOVW_DTPREL_G2";
case 524: return "R_AARCH64_TLSLD_MOVW_DTPREL_G1";
case 525: return "R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC";
case 526: return "R_AARCH64_TLSLD_MOVW_DTPREL_G0";
case 527: return "R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC";
case 528: return "R_AARCH64_TLSLD_ADD_DTPREL_HI12";
case 529: return "R_AARCH64_TLSLD_ADD_DTPREL_LO12";
case 530: return "R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC";
case 531: return "R_AARCH64_TLSLD_LDST8_DTPREL_LO12";
case 532: return "R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC";
case 533: return "R_AARCH64_TLSLD_LDST16_DTPREL_LO12";
case 534: return "R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC";
case 535: return "R_AARCH64_TLSLD_LDST32_DTPREL_LO12";
case 536: return "R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC";
case 537: return "R_AARCH64_TLSLD_LDST64_DTPREL_LO12";
case 538: return "R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC";



case 539: return "R_AARCH64_TLSIE_MOVW_GOTTPREL_G1";
case 540: return "R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC";
case 541: return "R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21";
case 542: return "R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC";
case 543: return "R_AARCH64_TLSIE_LD_GOTTPREL_PREL19";



case 544: return "R_AARCH64_TLSLE_MOVW_TPREL_G2";
case 545: return "R_AARCH64_TLSLE_MOVW_TPREL_G1";
case 546: return "R_AARCH64_TLSLE_MOVW_TPREL_G1_NC";
case 547: return "R_AARCH64_TLSLE_MOVW_TPREL_G0";
case 548: return "R_AARCH64_TLSLE_MOVW_TPREL_G0_NC";
case 549: return "R_AARCH64_TLSLE_ADD_TPREL_HI12";
case 550: return "R_AARCH64_TLSLE_ADD_TPREL_LO12";
case 551: return "R_AARCH64_TLSLE_ADD_TPREL_LO12_NC";
case 552: return "R_AARCH64_TLSLE_LDST8_TPREL_LO12";
case 553: return "R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC";
case 554: return "R_AARCH64_TLSLE_LDST16_TPREL_LO12";
case 555: return "R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC";
case 556: return "R_AARCH64_TLSLE_LDST32_TPREL_LO12";
case 557: return "R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC";
case 558: return "R_AARCH64_TLSLE_LDST64_TPREL_LO12";
case 559: return "R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC";



case 560: return "R_AARCH64_TLSDESC_LD_PREL19";
case 561: return "R_AARCH64_TLSDESC_ADR_PREL21";
case 562: return "R_AARCH64_TLSDESC_ADR_PAGE21";
case 563: return "R_AARCH64_TLSDESC_LD64_LO12";
case 564: return "R_AARCH64_TLSDESC_ADD_LO12";
case 565: return "R_AARCH64_TLSDESC_OFF_G1";
case 566: return "R_AARCH64_TLSDESC_OFF_G0_NC";
case 567: return "R_AARCH64_TLSDESC_LDR";
case 568: return "R_AARCH64_TLSDESC_ADD";
case 569: return "R_AARCH64_TLSDESC_CALL";

case 570: return "R_AARCH64_TLSLE_LDST128_TPREL_LO12";
case 571: return "R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC";
case 572: return "R_AARCH64_TLSLD_LDST128_DTPREL_LO12";
case 573: return "R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC";




case 1024: return "R_AARCH64_COPY";


case 1025: return "R_AARCH64_GLOB_DAT";


case 1026: return "R_AARCH64_JUMP_SLOT";


case 1027: return "R_AARCH64_RELATIVE";
case 1028: return "R_AARCH64_TLS_DTPMOD64";
case 1029: return "R_AARCH64_TLS_DTPREL64";
case 1030: return "R_AARCH64_TLS_TPREL64";
# 422 "./../include/elf/aarch64.h"
case 1031: return "R_AARCH64_TLSDESC";
case 1032: return "R_AARCH64_IRELATIVE";

default: return 
# 425 "./../include/elf/aarch64.h" 3 4
((void *)0)
# 425 "./../include/elf/aarch64.h"
; } }
# 93 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/alpha.h" 1
# 52 "./../include/elf/alpha.h"
typedef struct
{

  unsigned long ri_gprmask;

  unsigned long ri_cprmask[4];

  long ri_gp_value;
} Elf64_RegInfo;
# 73 "./../include/elf/alpha.h"
static const char *elf_alpha_reloc_type (unsigned long rtype); static const char * elf_alpha_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_ALPHA_NONE";
  case 1: return "R_ALPHA_REFLONG";
  case 2: return "R_ALPHA_REFQUAD";
  case 3: return "R_ALPHA_GPREL32";
  case 4: return "R_ALPHA_LITERAL";
  case 5: return "R_ALPHA_LITUSE";
  case 6: return "R_ALPHA_GPDISP";
  case 7: return "R_ALPHA_BRADDR";
  case 8: return "R_ALPHA_HINT";
  case 9: return "R_ALPHA_SREL16";
  case 10: return "R_ALPHA_SREL32";
  case 11: return "R_ALPHA_SREL64";



  case 17: return "R_ALPHA_GPRELHIGH";
  case 18: return "R_ALPHA_GPRELLOW";
  case 19: return "R_ALPHA_GPREL16";




  case 24: return "R_ALPHA_COPY";
  case 25: return "R_ALPHA_GLOB_DAT";
  case 26: return "R_ALPHA_JMP_SLOT";
  case 27: return "R_ALPHA_RELATIVE";




  case 28: return "R_ALPHA_BRSGP";


  case 29: return "R_ALPHA_TLSGD";
  case 30: return "R_ALPHA_TLSLDM";
  case 31: return "R_ALPHA_DTPMOD64";
  case 32: return "R_ALPHA_GOTDTPREL";
  case 33: return "R_ALPHA_DTPREL64";
  case 34: return "R_ALPHA_DTPRELHI";
  case 35: return "R_ALPHA_DTPRELLO";
  case 36: return "R_ALPHA_DTPREL16";
  case 37: return "R_ALPHA_GOTTPREL";
  case 38: return "R_ALPHA_TPREL64";
  case 39: return "R_ALPHA_TPRELHI";
  case 40: return "R_ALPHA_TPRELLO";
  case 41: return "R_ALPHA_TPREL16";

default: return 
# 121 "./../include/elf/alpha.h" 3 4
((void *)0)
# 121 "./../include/elf/alpha.h"
; } }
# 94 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/arc.h" 1
# 34 "./../include/elf/arc.h"
static const char *elf_arc_reloc_type (unsigned long rtype); static const char * elf_arc_reloc_type (unsigned long rtype) { switch (rtype) {
# 1 "./../include/elf/arc-reloc.def" 1
# 32 "./../include/elf/arc-reloc.def"
case 0: return "R_ARC_NONE";






case 1: return "R_ARC_8";






case 2: return "R_ARC_16";






case 3: return "R_ARC_24";






case 4: return "R_ARC_32";






case 8: return "R_ARC_N8";






case 9: return "R_ARC_N16";






case 10: return "R_ARC_N24";






case 11: return "R_ARC_N32";






case 12: return "R_ARC_SDA";






case 13: return "R_ARC_SECTOFF";






case 14: return "R_ARC_S21H_PCREL";






case 15: return "R_ARC_S21W_PCREL";






case 16: return "R_ARC_S25H_PCREL";






case 17: return "R_ARC_S25W_PCREL";






case 18: return "R_ARC_SDA32";






case 19: return "R_ARC_SDA_LDST";






case 20: return "R_ARC_SDA_LDST1";






case 21: return "R_ARC_SDA_LDST2";






case 22: return "R_ARC_SDA16_LD";






case 23: return "R_ARC_SDA16_LD1";






case 24: return "R_ARC_SDA16_LD2";






case 25: return "R_ARC_S13_PCREL";






case 26: return "R_ARC_W";






case 27: return "R_ARC_32_ME";






case 105: return "R_ARC_32_ME_S";






case 28: return "R_ARC_N32_ME";






case 29: return "R_ARC_SECTOFF_ME";






case 30: return "R_ARC_SDA32_ME";






case 31: return "R_ARC_W_ME";






case 35: return "R_AC_SECTOFF_U8";






case 36: return "R_AC_SECTOFF_U8_1";






case 37: return "R_AC_SECTOFF_U8_2";






case 38: return "R_AC_SECTOFF_S9";






case 39: return "R_AC_SECTOFF_S9_1";






case 40: return "R_AC_SECTOFF_S9_2";






case 41: return "R_ARC_SECTOFF_ME_1";






case 42: return "R_ARC_SECTOFF_ME_2";






case 43: return "R_ARC_SECTOFF_1";






case 44: return "R_ARC_SECTOFF_2";






case 45: return "R_ARC_SDA_12";






case 48: return "R_ARC_SDA16_ST2";






case 49: return "R_ARC_32_PCREL";






case 50: return "R_ARC_PC32";






case 59: return "R_ARC_GOT32";






case 51: return "R_ARC_GOTPC32";






case 52: return "R_ARC_PLT32";






case 53: return "R_ARC_COPY";






case 54: return "R_ARC_GLOB_DAT";






case 55: return "R_ARC_JMP_SLOT";






case 56: return "R_ARC_RELATIVE";






case 57: return "R_ARC_GOTOFF";






case 58: return "R_ARC_GOTPC";






case 60: return "R_ARC_S21W_PCREL_PLT";






case 61: return "R_ARC_S25H_PCREL_PLT";






case 66: return "R_ARC_TLS_DTPMOD";






case 68: return "R_ARC_TLS_TPOFF";






case 69: return "R_ARC_TLS_GD_GOT";






case 70: return "R_ARC_TLS_GD_LD";






case 71: return "R_ARC_TLS_GD_CALL";






case 72: return "R_ARC_TLS_IE_GOT";






case 67: return "R_ARC_TLS_DTPOFF";






case 73: return "R_ARC_TLS_DTPOFF_S9";






case 74: return "R_ARC_TLS_LE_S9";






case 75: return "R_ARC_TLS_LE_32";






case 76: return "R_ARC_S25W_PCREL_PLT";






case 77: return "R_ARC_S21H_PCREL_PLT";






case 78: return "R_ARC_NPS_CMEM16";
# 36 "./../include/elf/arc.h" 2
default: return 
# 36 "./../include/elf/arc.h" 3 4
((void *)0)
# 36 "./../include/elf/arc.h"
; } }
# 70 "./../include/elf/arc.h"
enum {

  Tag_ARC_PCS_config = 4,
  Tag_ARC_CPU_base,
  Tag_ARC_CPU_variation,
  Tag_ARC_CPU_name,
  Tag_ARC_ABI_rf16,
  Tag_ARC_ABI_osver,
  Tag_ARC_ABI_sda,
  Tag_ARC_ABI_pic,
  Tag_ARC_ABI_tls,
  Tag_ARC_ABI_enumsize,
  Tag_ARC_ABI_exceptions,
  Tag_ARC_ABI_double_size,
  Tag_ARC_ISA_config,
  Tag_ARC_ISA_apex,
  Tag_ARC_ISA_mpy_option
};
# 95 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/arm.h" 1
# 119 "./../include/elf/arm.h"
static const char *elf_arm_reloc_type (unsigned long rtype); static const char * elf_arm_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0: return "R_ARM_NONE";
  case 1: return "R_ARM_PC24";
  case 2: return "R_ARM_ABS32";
  case 3: return "R_ARM_REL32";
  case 4: return "R_ARM_LDR_PC_G0";
  case 5: return "R_ARM_ABS16";
  case 6: return "R_ARM_ABS12";
  case 7: return "R_ARM_THM_ABS5";
  case 8: return "R_ARM_ABS8";
  case 9: return "R_ARM_SBREL32";
  case 10: return "R_ARM_THM_CALL";
  case 11: return "R_ARM_THM_PC8";
  case 12: return "R_ARM_BREL_ADJ";
  case 13: return "R_ARM_TLS_DESC";
  case 14: return "R_ARM_THM_SWI8";
  case 15: return "R_ARM_XPC25";
  case 16: return "R_ARM_THM_XPC22";
  case 17: return "R_ARM_TLS_DTPMOD32";
  case 18: return "R_ARM_TLS_DTPOFF32";
  case 19: return "R_ARM_TLS_TPOFF32";
  case 20: return "R_ARM_COPY";
  case 21: return "R_ARM_GLOB_DAT";
  case 22: return "R_ARM_JUMP_SLOT";
  case 23: return "R_ARM_RELATIVE";
  case 24: return "R_ARM_GOTOFF32";
  case 25: return "R_ARM_BASE_PREL";
  case 26: return "R_ARM_GOT_BREL";
  case 27: return "R_ARM_PLT32";
  case 28: return "R_ARM_CALL";
  case 29: return "R_ARM_JUMP24";
  case 30: return "R_ARM_THM_JUMP24";
  case 31: return "R_ARM_BASE_ABS";
  case 32: return "R_ARM_ALU_PCREL7_0";
  case 33: return "R_ARM_ALU_PCREL15_8";
  case 34: return "R_ARM_ALU_PCREL23_15";
  case 35: return "R_ARM_LDR_SBREL_11_0";
  case 36: return "R_ARM_ALU_SBREL_19_12";
  case 37: return "R_ARM_ALU_SBREL_27_20";
  case 38: return "R_ARM_TARGET1";
  case 39: return "R_ARM_SBREL31";
  case 40: return "R_ARM_V4BX";
  case 41: return "R_ARM_TARGET2";
  case 42: return "R_ARM_PREL31";
  case 43: return "R_ARM_MOVW_ABS_NC";
  case 44: return "R_ARM_MOVT_ABS";
  case 45: return "R_ARM_MOVW_PREL_NC";
  case 46: return "R_ARM_MOVT_PREL";
  case 47: return "R_ARM_THM_MOVW_ABS_NC";
  case 48: return "R_ARM_THM_MOVT_ABS";
  case 49: return "R_ARM_THM_MOVW_PREL_NC";
  case 50: return "R_ARM_THM_MOVT_PREL";
  case 51: return "R_ARM_THM_JUMP19";
  case 52: return "R_ARM_THM_JUMP6";
  case 53: return "R_ARM_THM_ALU_PREL_11_0";
  case 54: return "R_ARM_THM_PC12";
  case 55: return "R_ARM_ABS32_NOI";
  case 56: return "R_ARM_REL32_NOI";
  case 57: return "R_ARM_ALU_PC_G0_NC";
  case 58: return "R_ARM_ALU_PC_G0";
  case 59: return "R_ARM_ALU_PC_G1_NC";
  case 60: return "R_ARM_ALU_PC_G1";
  case 61: return "R_ARM_ALU_PC_G2";
  case 62: return "R_ARM_LDR_PC_G1";
  case 63: return "R_ARM_LDR_PC_G2";
  case 64: return "R_ARM_LDRS_PC_G0";
  case 65: return "R_ARM_LDRS_PC_G1";
  case 66: return "R_ARM_LDRS_PC_G2";
  case 67: return "R_ARM_LDC_PC_G0";
  case 68: return "R_ARM_LDC_PC_G1";
  case 69: return "R_ARM_LDC_PC_G2";
  case 70: return "R_ARM_ALU_SB_G0_NC";
  case 71: return "R_ARM_ALU_SB_G0";
  case 72: return "R_ARM_ALU_SB_G1_NC";
  case 73: return "R_ARM_ALU_SB_G1";
  case 74: return "R_ARM_ALU_SB_G2";
  case 75: return "R_ARM_LDR_SB_G0";
  case 76: return "R_ARM_LDR_SB_G1";
  case 77: return "R_ARM_LDR_SB_G2";
  case 78: return "R_ARM_LDRS_SB_G0";
  case 79: return "R_ARM_LDRS_SB_G1";
  case 80: return "R_ARM_LDRS_SB_G2";
  case 81: return "R_ARM_LDC_SB_G0";
  case 82: return "R_ARM_LDC_SB_G1";
  case 83: return "R_ARM_LDC_SB_G2";
  case 84: return "R_ARM_MOVW_BREL_NC";
  case 85: return "R_ARM_MOVT_BREL";
  case 86: return "R_ARM_MOVW_BREL";
  case 87: return "R_ARM_THM_MOVW_BREL_NC";
  case 88: return "R_ARM_THM_MOVT_BREL";
  case 89: return "R_ARM_THM_MOVW_BREL";
  case 90: return "R_ARM_TLS_GOTDESC";
  case 91: return "R_ARM_TLS_CALL";
  case 92: return "R_ARM_TLS_DESCSEQ";
  case 93: return "R_ARM_THM_TLS_CALL";
  case 94: return "R_ARM_PLT32_ABS";
  case 95: return "R_ARM_GOT_ABS";
  case 96: return "R_ARM_GOT_PREL";
  case 97: return "R_ARM_GOT_BREL12";
  case 98: return "R_ARM_GOTOFF12";
  case 99: return "R_ARM_GOTRELAX";
  case 100: return "R_ARM_GNU_VTENTRY";
  case 101: return "R_ARM_GNU_VTINHERIT";
  case 102: return "R_ARM_THM_JUMP11";
  case 103: return "R_ARM_THM_JUMP8";
  case 104: return "R_ARM_TLS_GD32";
  case 105: return "R_ARM_TLS_LDM32";
  case 106: return "R_ARM_TLS_LDO32";
  case 107: return "R_ARM_TLS_IE32";
  case 108: return "R_ARM_TLS_LE32";
  case 109: return "R_ARM_TLS_LDO12";
  case 110: return "R_ARM_TLS_LE12";
  case 111: return "R_ARM_TLS_IE12GP";

  case 128: return "R_ARM_ME_TOO";
  case 129: return "R_ARM_THM_TLS_DESCSEQ";

  case 132: return "R_ARM_THM_ALU_ABS_G0_NC";
  case 133: return "R_ARM_THM_ALU_ABS_G1_NC";
  case 134: return "R_ARM_THM_ALU_ABS_G2_NC";
  case 135: return "R_ARM_THM_ALU_ABS_G3_NC";

  case 160: return "R_ARM_IRELATIVE";


  case 249: return "R_ARM_RXPC25";
  case 250: return "R_ARM_RSBREL32";
  case 251: return "R_ARM_THM_RPC22";
  case 252: return "R_ARM_RREL32";
  case 253: return "R_ARM_RABS32";
  case 254: return "R_ARM_RPC24";
  case 255: return "R_ARM_RBASE";


 
 
 
 



 
 
 
 

default: return 
# 266 "./../include/elf/arm.h" 3 4
((void *)0)
# 266 "./../include/elf/arm.h"
; } }




enum
{

  Tag_CPU_raw_name = 4,
  Tag_CPU_name,
  Tag_CPU_arch,
  Tag_CPU_arch_profile,
  Tag_ARM_ISA_use,
  Tag_THUMB_ISA_use,
  Tag_FP_arch,
  Tag_WMMX_arch,
  Tag_Advanced_SIMD_arch,
  Tag_PCS_config,
  Tag_ABI_PCS_R9_use,
  Tag_ABI_PCS_RW_data,
  Tag_ABI_PCS_RO_data,
  Tag_ABI_PCS_GOT_use,
  Tag_ABI_PCS_wchar_t,
  Tag_ABI_FP_rounding,
  Tag_ABI_FP_denormal,
  Tag_ABI_FP_exceptions,
  Tag_ABI_FP_user_exceptions,
  Tag_ABI_FP_number_model,
  Tag_ABI_align_needed,
  Tag_ABI_align_preserved,
  Tag_ABI_enum_size,
  Tag_ABI_HardFP_use,
  Tag_ABI_VFP_args,
  Tag_ABI_WMMX_args,
  Tag_ABI_optimization_goals,
  Tag_ABI_FP_optimization_goals,

  Tag_undefined33 = 33,
  Tag_CPU_unaligned_access,
  Tag_undefined35,
  Tag_FP_HP_extension,
  Tag_undefined37,
  Tag_ABI_FP_16bit_format,
  Tag_undefined39,
  Tag_undefined40,
  Tag_undefined41,
  Tag_MPextension_use,
  Tag_undefined_43,
  Tag_DIV_use,
  Tag_DSP_extension = 46,
  Tag_nodefaults = 64,
  Tag_also_compatible_with,
  Tag_T2EE_use,
  Tag_conformance,
  Tag_Virtualization_use,
  Tag_undefined69,
  Tag_MPextension_use_legacy,


  Tag_VFP_arch = Tag_FP_arch,
  Tag_ABI_align8_needed = Tag_ABI_align_needed,
  Tag_ABI_align8_preserved = Tag_ABI_align_preserved,
  Tag_VFP_HP_extension = Tag_FP_HP_extension
};


enum
{
  AEABI_FP_number_model_none = 0,
  AEABI_FP_number_model_ieee754_number = 1,
  AEABI_FP_number_model_rtabi = 2,
  AEABI_FP_number_model_ieee754_all = 3
};


enum
{
  AEABI_VFP_args_base = 0,
  AEABI_VFP_args_vfp = 1,
  AEABI_VFP_args_toolchain = 2,
  AEABI_VFP_args_compatible = 3
};
# 359 "./../include/elf/arm.h"
enum arm_st_branch_type {
  ST_BRANCH_TO_ARM,
  ST_BRANCH_TO_THUMB,
  ST_BRANCH_LONG,
  ST_BRANCH_UNKNOWN,
  ST_BRANCH_ENUM_SIZE
};
# 96 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/avr.h" 1
# 53 "./../include/elf/avr.h"
static const char *elf_avr_reloc_type (unsigned long rtype); static const char * elf_avr_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_AVR_NONE";
     case 1: return "R_AVR_32";
     case 2: return "R_AVR_7_PCREL";
     case 3: return "R_AVR_13_PCREL";
     case 4: return "R_AVR_16";
     case 5: return "R_AVR_16_PM";
     case 6: return "R_AVR_LO8_LDI";
     case 7: return "R_AVR_HI8_LDI";
     case 8: return "R_AVR_HH8_LDI";
     case 9: return "R_AVR_LO8_LDI_NEG";
     case 10: return "R_AVR_HI8_LDI_NEG";
     case 11: return "R_AVR_HH8_LDI_NEG";
     case 12: return "R_AVR_LO8_LDI_PM";
     case 13: return "R_AVR_HI8_LDI_PM";
     case 14: return "R_AVR_HH8_LDI_PM";
     case 15: return "R_AVR_LO8_LDI_PM_NEG";
     case 16: return "R_AVR_HI8_LDI_PM_NEG";
     case 17: return "R_AVR_HH8_LDI_PM_NEG";
     case 18: return "R_AVR_CALL";
     case 19: return "R_AVR_LDI";
     case 20: return "R_AVR_6";
     case 21: return "R_AVR_6_ADIW";
     case 22: return "R_AVR_MS8_LDI";
     case 23: return "R_AVR_MS8_LDI_NEG";
     case 24: return "R_AVR_LO8_LDI_GS";
     case 25: return "R_AVR_HI8_LDI_GS";
     case 26: return "R_AVR_8";
     case 27: return "R_AVR_8_LO8";
     case 28: return "R_AVR_8_HI8";
     case 29: return "R_AVR_8_HLO8";
     case 30: return "R_AVR_DIFF8";
     case 31: return "R_AVR_DIFF16";
     case 32: return "R_AVR_DIFF32";
     case 33: return "R_AVR_LDS_STS_16";
     case 34: return "R_AVR_PORT6";
     case 35: return "R_AVR_PORT5";
     case 36: return "R_AVR_32_PCREL";
default: return 
# 91 "./../include/elf/avr.h" 3 4
((void *)0)
# 91 "./../include/elf/avr.h"
; } }
# 97 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/bfin.h" 1
# 25 "./../include/elf/bfin.h"
static const char *elf_bfin_reloc_type (unsigned long rtype); static const char * elf_bfin_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0x00: return "R_BFIN_UNUSED0";
  case 0x01: return "R_BFIN_PCREL5M2";
  case 0x02: return "R_BFIN_UNUSED1";
  case 0x03: return "R_BFIN_PCREL10";
  case 0x04: return "R_BFIN_PCREL12_JUMP";
  case 0x05: return "R_BFIN_RIMM16";
  case 0x06: return "R_BFIN_LUIMM16";
  case 0x07: return "R_BFIN_HUIMM16";
  case 0x08: return "R_BFIN_PCREL12_JUMP_S";
  case 0x09: return "R_BFIN_PCREL24_JUMP_X";
  case 0x0a: return "R_BFIN_PCREL24";
  case 0x0b: return "R_BFIN_UNUSEDB";
  case 0x0c: return "R_BFIN_UNUSEDC";
  case 0x0d: return "R_BFIN_PCREL24_JUMP_L";
  case 0x0e: return "R_BFIN_PCREL24_CALL_X";
  case 0x0f: return "R_BFIN_VAR_EQ_SYMB";
  case 0x10: return "R_BFIN_BYTE_DATA";
  case 0x11: return "R_BFIN_BYTE2_DATA";
  case 0x12: return "R_BFIN_BYTE4_DATA";
  case 0x13: return "R_BFIN_PCREL11";
  case 0x14: return "R_BFIN_GOT17M4";
  case 0x15: return "R_BFIN_GOTHI";
  case 0x16: return "R_BFIN_GOTLO";
  case 0x17: return "R_BFIN_FUNCDESC";
  case 0x18: return "R_BFIN_FUNCDESC_GOT17M4";
  case 0x19: return "R_BFIN_FUNCDESC_GOTHI";
  case 0x1a: return "R_BFIN_FUNCDESC_GOTLO";
  case 0x1b: return "R_BFIN_FUNCDESC_VALUE";
  case 0x1c: return "R_BFIN_FUNCDESC_GOTOFF17M4";
  case 0x1d: return "R_BFIN_FUNCDESC_GOTOFFHI";
  case 0x1e: return "R_BFIN_FUNCDESC_GOTOFFLO";
  case 0x1f: return "R_BFIN_GOTOFF17M4";
  case 0x20: return "R_BFIN_GOTOFFHI";
  case 0x21: return "R_BFIN_GOTOFFLO";

  case 0xE0: return "R_BFIN_PUSH";
  case 0xE1: return "R_BFIN_CONST";
  case 0xE2: return "R_BFIN_ADD";
  case 0xE3: return "R_BFIN_SUB";
  case 0xE4: return "R_BFIN_MULT";
  case 0xE5: return "R_BFIN_DIV";
  case 0xE6: return "R_BFIN_MOD";
  case 0xE7: return "R_BFIN_LSHIFT";
  case 0xE8: return "R_BFIN_RSHIFT";
  case 0xE9: return "R_BFIN_AND";
  case 0xEA: return "R_BFIN_OR";
  case 0xEB: return "R_BFIN_XOR";
  case 0xEC: return "R_BFIN_LAND";
  case 0xED: return "R_BFIN_LOR";
  case 0xEE: return "R_BFIN_LEN";
  case 0xEF: return "R_BFIN_NEG";
  case 0xF0: return "R_BFIN_COMP";
  case 0xF1: return "R_BFIN_PAGE";
  case 0xF2: return "R_BFIN_HWPAGE";
  case 0xF3: return "R_BFIN_ADDR";
  case 0x40: return "R_BFIN_PLTPC";
  case 0x41: return "R_BFIN_GOT";
  case 0x42: return "R_BFIN_GNU_VTINHERIT";
  case 0x43: return "R_BFIN_GNU_VTENTRY";
default: return 
# 85 "./../include/elf/bfin.h" 3 4
((void *)0)
# 85 "./../include/elf/bfin.h"
; } }
# 98 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/cr16.h" 1
# 27 "./../include/elf/cr16.h"
static const char *elf_cr16_reloc_type (unsigned long rtype); static const char * elf_cr16_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CR16_NONE";
  case 1: return "R_CR16_NUM8";
  case 2: return "R_CR16_NUM16";
  case 3: return "R_CR16_NUM32";
  case 4: return "R_CR16_NUM32a";
  case 5: return "R_CR16_REGREL4";
  case 6: return "R_CR16_REGREL4a";
  case 7: return "R_CR16_REGREL14";
  case 8: return "R_CR16_REGREL14a";
  case 9: return "R_CR16_REGREL16";
  case 10: return "R_CR16_REGREL20";
  case 11: return "R_CR16_REGREL20a";
  case 12: return "R_CR16_ABS20";
  case 13: return "R_CR16_ABS24";
  case 14: return "R_CR16_IMM4";
  case 15: return "R_CR16_IMM8";
  case 16: return "R_CR16_IMM16";
  case 17: return "R_CR16_IMM20";
  case 18: return "R_CR16_IMM24";
  case 19: return "R_CR16_IMM32";
  case 20: return "R_CR16_IMM32a";
  case 21: return "R_CR16_DISP4";
  case 22: return "R_CR16_DISP8";
  case 23: return "R_CR16_DISP16";
  case 24: return "R_CR16_DISP24";
  case 25: return "R_CR16_DISP24a";
  case 26: return "R_CR16_SWITCH8";
  case 27: return "R_CR16_SWITCH16";
  case 28: return "R_CR16_SWITCH32";
  case 29: return "R_CR16_GOT_REGREL20";
  case 30: return "R_CR16_GOTC_REGREL20";
  case 31: return "R_CR16_GLOB_DAT";
default: return 
# 60 "./../include/elf/cr16.h" 3 4
((void *)0)
# 60 "./../include/elf/cr16.h"
; } }
# 99 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/cris.h" 1
# 28 "./../include/elf/cris.h"
static const char *elf_cris_reloc_type (unsigned long rtype); static const char * elf_cris_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CRIS_NONE";
  case 1: return "R_CRIS_8";
  case 2: return "R_CRIS_16";
  case 3: return "R_CRIS_32";


  case 4: return "R_CRIS_8_PCREL";
  case 5: return "R_CRIS_16_PCREL";
  case 6: return "R_CRIS_32_PCREL";

  case 7: return "R_CRIS_GNU_VTINHERIT";
  case 8: return "R_CRIS_GNU_VTENTRY";



  case 9: return "R_CRIS_COPY";



  case 10: return "R_CRIS_GLOB_DAT";



  case 11: return "R_CRIS_JUMP_SLOT";



  case 12: return "R_CRIS_RELATIVE";




  case 13: return "R_CRIS_16_GOT";




  case 14: return "R_CRIS_32_GOT";




  case 15: return "R_CRIS_16_GOTPLT";




  case 16: return "R_CRIS_32_GOTPLT";




  case 17: return "R_CRIS_32_GOTREL";




  case 18: return "R_CRIS_32_PLT_GOTREL";





  case 19: return "R_CRIS_32_PLT_PCREL";






  case 20: return "R_CRIS_32_GOT_GD";







  case 21: return "R_CRIS_16_GOT_GD";




  case 22: return "R_CRIS_32_GD";





  case 23: return "R_CRIS_DTP";
# 127 "./../include/elf/cris.h"
  case 24: return "R_CRIS_32_DTPREL";






  case 25: return "R_CRIS_16_DTPREL";






  case 26: return "R_CRIS_32_GOT_TPREL";




  case 27: return "R_CRIS_16_GOT_TPREL";






  case 28: return "R_CRIS_32_TPREL";
# 162 "./../include/elf/cris.h"
  case 29: return "R_CRIS_16_TPREL";




  case 30: return "R_CRIS_DTPMOD";




  case 31: return "R_CRIS_32_IE";



default: return 
# 176 "./../include/elf/cris.h" 3 4
((void *)0)
# 176 "./../include/elf/cris.h"
; } }
# 100 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/crx.h" 1
# 29 "./../include/elf/crx.h"
static const char *elf_crx_reloc_type (unsigned long rtype); static const char * elf_crx_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CRX_NONE";
  case 1: return "R_CRX_REL4";
  case 2: return "R_CRX_REL8";
  case 3: return "R_CRX_REL8_CMP";
  case 4: return "R_CRX_REL16";
  case 5: return "R_CRX_REL24";
  case 6: return "R_CRX_REL32";
  case 7: return "R_CRX_REGREL12";
  case 8: return "R_CRX_REGREL22";
  case 9: return "R_CRX_REGREL28";
  case 10: return "R_CRX_REGREL32";
  case 11: return "R_CRX_ABS16";
  case 12: return "R_CRX_ABS32";
  case 13: return "R_CRX_NUM8";
  case 14: return "R_CRX_NUM16";
  case 15: return "R_CRX_NUM32";
  case 16: return "R_CRX_IMM16";
  case 17: return "R_CRX_IMM32";
  case 18: return "R_CRX_SWITCH8";
  case 19: return "R_CRX_SWITCH16";
  case 20: return "R_CRX_SWITCH32";
default: return 
# 51 "./../include/elf/crx.h" 3 4
((void *)0)
# 51 "./../include/elf/crx.h"
; } }
# 101 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/d10v.h" 1
# 26 "./../include/elf/d10v.h"
static const char *elf_d10v_reloc_type (unsigned long rtype); static const char * elf_d10v_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_D10V_NONE";
  case 1: return "R_D10V_10_PCREL_R";
  case 2: return "R_D10V_10_PCREL_L";
  case 3: return "R_D10V_16";
  case 4: return "R_D10V_18";
  case 5: return "R_D10V_18_PCREL";
  case 6: return "R_D10V_32";
  case 7: return "R_D10V_GNU_VTINHERIT";
  case 8: return "R_D10V_GNU_VTENTRY";
default: return 
# 36 "./../include/elf/d10v.h" 3 4
((void *)0)
# 36 "./../include/elf/d10v.h"
; } }
# 102 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/d30v.h" 1
# 26 "./../include/elf/d30v.h"
static const char *elf_d30v_reloc_type (unsigned long rtype); static const char * elf_d30v_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_D30V_NONE";
  case 1: return "R_D30V_6";
  case 2: return "R_D30V_9_PCREL";
  case 3: return "R_D30V_9_PCREL_R";
  case 4: return "R_D30V_15";
  case 5: return "R_D30V_15_PCREL";
  case 6: return "R_D30V_15_PCREL_R";
  case 7: return "R_D30V_21";
  case 8: return "R_D30V_21_PCREL";
  case 9: return "R_D30V_21_PCREL_R";
  case 10: return "R_D30V_32";
  case 11: return "R_D30V_32_PCREL";
  case 12: return "R_D30V_32_NORMAL";
default: return 
# 40 "./../include/elf/d30v.h" 3 4
((void *)0)
# 40 "./../include/elf/d30v.h"
; } }
# 103 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/dlx.h" 1
# 43 "./../include/elf/dlx.h"
static const char *elf_dlx_reloc_type (unsigned long rtype); static const char * elf_dlx_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_DLX_NONE";
     case 1: return "R_DLX_RELOC_8";
     case 2: return "R_DLX_RELOC_16";
     case 3: return "R_DLX_RELOC_32";
     case 4: return "R_DLX_GNU_VTINHERIT";
     case 5: return "R_DLX_GNU_VTENTRY";
     case 6: return "R_DLX_RELOC_16_HI";
     case 7: return "R_DLX_RELOC_16_LO";
     case 8: return "R_DLX_RELOC_16_PCREL";
     case 9: return "R_DLX_RELOC_26_PCREL";
default: return 
# 54 "./../include/elf/dlx.h" 3 4
((void *)0)
# 54 "./../include/elf/dlx.h"
; } }
# 104 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/epiphany.h" 1
# 27 "./../include/elf/epiphany.h"
static const char *elf_epiphany_reloc_type (unsigned long rtype); static const char * elf_epiphany_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_EPIPHANY_NONE";


  case 1: return "R_EPIPHANY_8";
  case 2: return "R_EPIPHANY_16";
  case 3: return "R_EPIPHANY_32";


  case 4: return "R_EPIPHANY_8_PCREL";
  case 5: return "R_EPIPHANY_16_PCREL";
  case 6: return "R_EPIPHANY_32_PCREL";


  case 7: return "R_EPIPHANY_SIMM8";
  case 8: return "R_EPIPHANY_SIMM24";



  case 9: return "R_EPIPHANY_HIGH";
  case 10: return "R_EPIPHANY_LOW";


  case 11: return "R_EPIPHANY_SIMM11";

  case 12: return "R_EPIPHANY_IMM11";


  case 13: return "R_EPIPHANY_IMM8";

default: return 
# 57 "./../include/elf/epiphany.h" 3 4
((void *)0)
# 57 "./../include/elf/epiphany.h"
; } }
# 105 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/fr30.h" 1
# 26 "./../include/elf/fr30.h"
static const char *elf_fr30_reloc_type (unsigned long rtype); static const char * elf_fr30_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FR30_NONE";
  case 1: return "R_FR30_8";
  case 2: return "R_FR30_20";
  case 3: return "R_FR30_32";
  case 4: return "R_FR30_48";
  case 5: return "R_FR30_6_IN_4";
  case 6: return "R_FR30_8_IN_8";
  case 7: return "R_FR30_9_IN_8";
  case 8: return "R_FR30_10_IN_8";
  case 9: return "R_FR30_9_PCREL";
  case 10: return "R_FR30_12_PCREL";
  case 11: return "R_FR30_GNU_VTINHERIT";
  case 12: return "R_FR30_GNU_VTENTRY";
default: return 
# 40 "./../include/elf/fr30.h" 3 4
((void *)0)
# 40 "./../include/elf/fr30.h"
; } }
# 106 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/frv.h" 1
# 26 "./../include/elf/frv.h"
static const char *elf_frv_reloc_type (unsigned long rtype); static const char * elf_frv_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FRV_NONE";
  case 1: return "R_FRV_32";
  case 2: return "R_FRV_LABEL16";
  case 3: return "R_FRV_LABEL24";
  case 4: return "R_FRV_LO16";
  case 5: return "R_FRV_HI16";
  case 6: return "R_FRV_GPREL12";
  case 7: return "R_FRV_GPRELU12";
  case 8: return "R_FRV_GPREL32";
  case 9: return "R_FRV_GPRELHI";
  case 10: return "R_FRV_GPRELLO";
  case 11: return "R_FRV_GOT12";
  case 12: return "R_FRV_GOTHI";
  case 13: return "R_FRV_GOTLO";
  case 14: return "R_FRV_FUNCDESC";
  case 15: return "R_FRV_FUNCDESC_GOT12";
  case 16: return "R_FRV_FUNCDESC_GOTHI";
  case 17: return "R_FRV_FUNCDESC_GOTLO";
  case 18: return "R_FRV_FUNCDESC_VALUE";
  case 19: return "R_FRV_FUNCDESC_GOTOFF12";
  case 20: return "R_FRV_FUNCDESC_GOTOFFHI";
  case 21: return "R_FRV_FUNCDESC_GOTOFFLO";
  case 22: return "R_FRV_GOTOFF12";
  case 23: return "R_FRV_GOTOFFHI";
  case 24: return "R_FRV_GOTOFFLO";
  case 25: return "R_FRV_GETTLSOFF";
  case 26: return "R_FRV_TLSDESC_VALUE";
  case 27: return "R_FRV_GOTTLSDESC12";
  case 28: return "R_FRV_GOTTLSDESCHI";
  case 29: return "R_FRV_GOTTLSDESCLO";
  case 30: return "R_FRV_TLSMOFF12";
  case 31: return "R_FRV_TLSMOFFHI";
  case 32: return "R_FRV_TLSMOFFLO";
  case 33: return "R_FRV_GOTTLSOFF12";
  case 34: return "R_FRV_GOTTLSOFFHI";
  case 35: return "R_FRV_GOTTLSOFFLO";
  case 36: return "R_FRV_TLSOFF";
  case 37: return "R_FRV_TLSDESC_RELAX";
  case 38: return "R_FRV_GETTLSOFF_RELAX";
  case 39: return "R_FRV_TLSOFF_RELAX";
  case 40: return "R_FRV_TLSMOFF";
  case 200: return "R_FRV_GNU_VTINHERIT";
  case 201: return "R_FRV_GNU_VTENTRY";
default: return 
# 70 "./../include/elf/frv.h" 3 4
((void *)0)
# 70 "./../include/elf/frv.h"
; } }
# 107 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/ft32.h" 1
# 26 "./../include/elf/ft32.h"
static const char *elf_ft32_reloc_type (unsigned long rtype); static const char * elf_ft32_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FT32_NONE";
  case 1: return "R_FT32_32";
  case 2: return "R_FT32_16";
  case 3: return "R_FT32_8";
  case 4: return "R_FT32_10";
  case 5: return "R_FT32_20";
  case 6: return "R_FT32_17";
  case 7: return "R_FT32_18";
default: return 
# 35 "./../include/elf/ft32.h" 3 4
((void *)0)
# 35 "./../include/elf/ft32.h"
; } }
# 108 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/h8.h" 1
# 27 "./../include/elf/h8.h"
static const char *elf_h8_reloc_type (unsigned long rtype); static const char * elf_h8_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_H8_NONE";
  case 1: return "R_H8_DIR32";
  case 2: return "R_H8_DIR32_28";
  case 3: return "R_H8_DIR32_24";
  case 4: return "R_H8_DIR32_16";
  case 6: return "R_H8_DIR32U";
  case 7: return "R_H8_DIR32U_28";
  case 8: return "R_H8_DIR32U_24";
  case 9: return "R_H8_DIR32U_20";
  case 10: return "R_H8_DIR32U_16";
  case 11: return "R_H8_DIR24";
  case 12: return "R_H8_DIR24_20";
  case 13: return "R_H8_DIR24_16";
  case 14: return "R_H8_DIR24U";
  case 15: return "R_H8_DIR24U_20";
  case 16: return "R_H8_DIR24U_16";
  case 17: return "R_H8_DIR16";
  case 18: return "R_H8_DIR16U";
  case 19: return "R_H8_DIR16S_32";
  case 20: return "R_H8_DIR16S_28";
  case 21: return "R_H8_DIR16S_24";
  case 22: return "R_H8_DIR16S_20";
  case 23: return "R_H8_DIR16S";
  case 24: return "R_H8_DIR8";
  case 25: return "R_H8_DIR8U";
  case 26: return "R_H8_DIR8Z_32";
  case 27: return "R_H8_DIR8Z_28";
  case 28: return "R_H8_DIR8Z_24";
  case 29: return "R_H8_DIR8Z_20";
  case 30: return "R_H8_DIR8Z_16";
  case 31: return "R_H8_PCREL16";
  case 32: return "R_H8_PCREL8";
  case 33: return "R_H8_BPOS";
 
 
  case 59: return "R_H8_DIR16A8";
  case 60: return "R_H8_DIR16R8";
  case 61: return "R_H8_DIR24A8";
  case 62: return "R_H8_DIR24R8";
  case 63: return "R_H8_DIR32A16";
  case 64: return "R_H8_DISP32A16";
  case 65: return "R_H8_ABS32";
  case 127: return "R_H8_ABS32A16";
  case 128: return "R_H8_SYM";
  case 129: return "R_H8_OPneg";
  case 130: return "R_H8_OPadd";
  case 131: return "R_H8_OPsub";
  case 132: return "R_H8_OPmul";
  case 133: return "R_H8_OPdiv";
  case 134: return "R_H8_OPshla";
  case 135: return "R_H8_OPshra";
  case 136: return "R_H8_OPsctsize";
  case 137: return "R_H8_OPhword";
  case 138: return "R_H8_OPlword";
  case 139: return "R_H8_OPhigh";
  case 140: return "R_H8_OPlow";
  case 141: return "R_H8_OPscttop";
default: return 
# 85 "./../include/elf/h8.h" 3 4
((void *)0)
# 85 "./../include/elf/h8.h"
; } }
# 109 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/hppa.h" 1
# 110 "./../include/elf/hppa.h"
static const char *elf_hppa_reloc_type (unsigned long rtype); static const char * elf_hppa_reloc_type (unsigned long rtype) { switch (rtype) {
case 0: return "R_PARISC_NONE";



case 1: return "R_PARISC_DIR32";


case 2: return "R_PARISC_DIR21L";


case 3: return "R_PARISC_DIR17R";


case 4: return "R_PARISC_DIR17F";


case 6: return "R_PARISC_DIR14R";


case 7: return "R_PARISC_DIR14F";
# 147 "./../include/elf/hppa.h"
case 8: return "R_PARISC_PCREL12F";


case 9: return "R_PARISC_PCREL32";


case 10: return "R_PARISC_PCREL21L";


case 11: return "R_PARISC_PCREL17R";


case 12: return "R_PARISC_PCREL17F";


case 13: return "R_PARISC_PCREL17C";


case 14: return "R_PARISC_PCREL14R";


case 15: return "R_PARISC_PCREL14F";




case 18: return "R_PARISC_DPREL21L";


case 19: return "R_PARISC_DPREL14WR";


case 20: return "R_PARISC_DPREL14DR";


case 22: return "R_PARISC_DPREL14R";


case 23: return "R_PARISC_DPREL14F";
# 195 "./../include/elf/hppa.h"
case 26: return "R_PARISC_DLTREL21L";


case 30: return "R_PARISC_DLTREL14R";


case 31: return "R_PARISC_DLTREL14F";




case 34: return "R_PARISC_DLTIND21L";


case 38: return "R_PARISC_DLTIND14R";


case 39: return "R_PARISC_DLTIND14F";




case 40: return "R_PARISC_SETBASE";


case 41: return "R_PARISC_SECREL32";


case 42: return "R_PARISC_BASEREL21L";


case 43: return "R_PARISC_BASEREL17R";


case 44: return "R_PARISC_BASEREL17F";


case 46: return "R_PARISC_BASEREL14R";


case 47: return "R_PARISC_BASEREL14F";




case 48: return "R_PARISC_SEGBASE";


case 49: return "R_PARISC_SEGREL32";




case 50: return "R_PARISC_PLTOFF21L";


case 54: return "R_PARISC_PLTOFF14R";


case 55: return "R_PARISC_PLTOFF14F";



case 57: return "R_PARISC_LTOFF_FPTR32";


case 58: return "R_PARISC_LTOFF_FPTR21L";


case 62: return "R_PARISC_LTOFF_FPTR14R";



case 64: return "R_PARISC_FPTR64";




case 65: return "R_PARISC_PLABEL32";


case 66: return "R_PARISC_PLABEL21L";


case 70: return "R_PARISC_PLABEL14R";




case 72: return "R_PARISC_PCREL64";


case 73: return "R_PARISC_PCREL22C";


case 74: return "R_PARISC_PCREL22F";


case 75: return "R_PARISC_PCREL14WR";


case 76: return "R_PARISC_PCREL14DR";


case 77: return "R_PARISC_PCREL16F";


case 78: return "R_PARISC_PCREL16WF";


case 79: return "R_PARISC_PCREL16DF";



case 80: return "R_PARISC_DIR64";


case 83: return "R_PARISC_DIR14WR";


case 84: return "R_PARISC_DIR14DR";


case 85: return "R_PARISC_DIR16F";


case 86: return "R_PARISC_DIR16WF";


case 87: return "R_PARISC_DIR16DF";


case 88: return "R_PARISC_GPREL64";


case 91: return "R_PARISC_DLTREL14WR";


case 92: return "R_PARISC_DLTREL14DR";


case 93: return "R_PARISC_GPREL16F";


case 94: return "R_PARISC_GPREL16WF";


case 95: return "R_PARISC_GPREL16DF";



case 96: return "R_PARISC_LTOFF64";


case 99: return "R_PARISC_DLTIND14WR";


case 100: return "R_PARISC_DLTIND14DR";


case 101: return "R_PARISC_LTOFF16F";


case 102: return "R_PARISC_LTOFF16WF";


case 103: return "R_PARISC_LTOFF16DF";



case 104: return "R_PARISC_SECREL64";


case 107: return "R_PARISC_BASEREL14WR";


case 108: return "R_PARISC_BASEREL14DR";



case 112: return "R_PARISC_SEGREL64";


case 115: return "R_PARISC_PLTOFF14WR";


case 116: return "R_PARISC_PLTOFF14DR";


case 117: return "R_PARISC_PLTOFF16F";


case 118: return "R_PARISC_PLTOFF16WF";


case 119: return "R_PARISC_PLTOFF16DF";



case 120: return "R_PARISC_LTOFF_FPTR64";


case 123: return "R_PARISC_LTOFF_FPTR14WR";


case 124: return "R_PARISC_LTOFF_FPTR14DR";


case 125: return "R_PARISC_LTOFF_FPTR16F";


case 126: return "R_PARISC_LTOFF_FPTR16WF";


case 127: return "R_PARISC_LTOFF_FPTR16DF";



case 128: return "R_PARISC_COPY";


case 129: return "R_PARISC_IPLT";


case 130: return "R_PARISC_EPLT";



case 153: return "R_PARISC_TPREL32";


case 154: return "R_PARISC_TPREL21L";


case 158: return "R_PARISC_TPREL14R";



case 162: return "R_PARISC_LTOFF_TP21L";


case 166: return "R_PARISC_LTOFF_TP14R";


case 167: return "R_PARISC_LTOFF_TP14F";



case 216: return "R_PARISC_TPREL64";


case 219: return "R_PARISC_TPREL14WR";


case 220: return "R_PARISC_TPREL14DR";


case 221: return "R_PARISC_TPREL16F";


case 222: return "R_PARISC_TPREL16WF";


case 223: return "R_PARISC_TPREL16DF";



case 224: return "R_PARISC_LTOFF_TP64";


case 227: return "R_PARISC_LTOFF_TP14WR";


case 228: return "R_PARISC_LTOFF_TP14DR";


case 229: return "R_PARISC_LTOFF_TP16F";


case 230: return "R_PARISC_LTOFF_TP16WF";


case 231: return "R_PARISC_LTOFF_TP16DF";


case 232: return "R_PARISC_GNU_VTENTRY";
case 233: return "R_PARISC_GNU_VTINHERIT";

case 234: return "R_PARISC_TLS_GD21L";
case 235: return "R_PARISC_TLS_GD14R";
case 236: return "R_PARISC_TLS_GDCALL";
case 237: return "R_PARISC_TLS_LDM21L";
case 238: return "R_PARISC_TLS_LDM14R";
case 239: return "R_PARISC_TLS_LDMCALL";
case 240: return "R_PARISC_TLS_LDO21L";
case 241: return "R_PARISC_TLS_LDO14R";
case 242: return "R_PARISC_TLS_DTPMOD32";
case 243: return "R_PARISC_TLS_DTPMOD64";
case 244: return "R_PARISC_TLS_DTPOFF32";
case 245: return "R_PARISC_TLS_DTPOFF64";

default: return 
# 496 "./../include/elf/hppa.h" 3 4
((void *)0)
# 496 "./../include/elf/hppa.h"
; } }
# 110 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/i386.h" 1
# 25 "./../include/elf/i386.h"
static const char *elf_i386_reloc_type (unsigned long rtype); static const char * elf_i386_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_386_NONE";
     case 1: return "R_386_32";
     case 2: return "R_386_PC32";
     case 3: return "R_386_GOT32";
     case 4: return "R_386_PLT32";
     case 5: return "R_386_COPY";
     case 6: return "R_386_GLOB_DAT";
     case 7: return "R_386_JUMP_SLOT";
     case 8: return "R_386_RELATIVE";
     case 9: return "R_386_GOTOFF";
     case 10: return "R_386_GOTPC";
     case 11: return "R_386_32PLT";
    
    
     case 14: return "R_386_TLS_TPOFF";
     case 15: return "R_386_TLS_IE";
     case 16: return "R_386_TLS_GOTIE";
     case 17: return "R_386_TLS_LE";
     case 18: return "R_386_TLS_GD";
     case 19: return "R_386_TLS_LDM";
     case 20: return "R_386_16";
     case 21: return "R_386_PC16";
     case 22: return "R_386_8";
     case 23: return "R_386_PC8";
     case 24: return "R_386_TLS_GD_32";
     case 25: return "R_386_TLS_GD_PUSH";
     case 26: return "R_386_TLS_GD_CALL";
     case 27: return "R_386_TLS_GD_POP";
     case 28: return "R_386_TLS_LDM_32";
     case 29: return "R_386_TLS_LDM_PUSH";
     case 30: return "R_386_TLS_LDM_CALL";
     case 31: return "R_386_TLS_LDM_POP";
     case 32: return "R_386_TLS_LDO_32";
     case 33: return "R_386_TLS_IE_32";
     case 34: return "R_386_TLS_LE_32";
     case 35: return "R_386_TLS_DTPMOD32";
     case 36: return "R_386_TLS_DTPOFF32";
     case 37: return "R_386_TLS_TPOFF32";
     case 38: return "R_386_SIZE32";
     case 39: return "R_386_TLS_GOTDESC";
     case 40: return "R_386_TLS_DESC_CALL";
     case 41: return "R_386_TLS_DESC";
     case 42: return "R_386_IRELATIVE";

     case 43: return "R_386_GOT32X";


     case 200: return "R_386_USED_BY_INTEL_200";


     case 250: return "R_386_GNU_VTINHERIT";
     case 251: return "R_386_GNU_VTENTRY";
default: return 
# 78 "./../include/elf/i386.h" 3 4
((void *)0)
# 78 "./../include/elf/i386.h"
; } }
# 111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/i370.h" 1
# 46 "./../include/elf/i370.h"
static const char *i370_reloc_type (unsigned long rtype); static const char * i370_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_I370_NONE";
  case 1: return "R_I370_ADDR31";
  case 2: return "R_I370_ADDR32";
  case 3: return "R_I370_ADDR16";
  case 4: return "R_I370_REL31";
  case 5: return "R_I370_REL32";
  case 6: return "R_I370_ADDR12";
  case 7: return "R_I370_REL12";
  case 8: return "R_I370_ADDR8";
  case 9: return "R_I370_REL8";
  case 10: return "R_I370_COPY";
  case 11: return "R_I370_RELATIVE";
default: return 
# 59 "./../include/elf/i370.h" 3 4
((void *)0)
# 59 "./../include/elf/i370.h"
; } }
# 112 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/i860.h" 1
# 29 "./../include/elf/i860.h"
static const char *elf_i860_reloc_type (unsigned long rtype); static const char * elf_i860_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0x00: return "R_860_NONE";
     case 0x01: return "R_860_32";
     case 0x02: return "R_860_COPY";
     case 0x03: return "R_860_GLOB_DAT";
     case 0x04: return "R_860_JUMP_SLOT";
     case 0x05: return "R_860_RELATIVE";
     case 0x30: return "R_860_PC26";
     case 0x31: return "R_860_PLT26";
     case 0x32: return "R_860_PC16";
     case 0x40: return "R_860_LOW0";
     case 0x42: return "R_860_SPLIT0";
     case 0x44: return "R_860_LOW1";
     case 0x46: return "R_860_SPLIT1";
     case 0x48: return "R_860_LOW2";
     case 0x4A: return "R_860_SPLIT2";
     case 0x4C: return "R_860_LOW3";
     case 0x50: return "R_860_LOGOT0";
     case 0x52: return "R_860_SPGOT0";
     case 0x54: return "R_860_LOGOT1";
     case 0x56: return "R_860_SPGOT1";
     case 0x60: return "R_860_LOGOTOFF0";
     case 0x62: return "R_860_SPGOTOFF0";
     case 0x64: return "R_860_LOGOTOFF1";
     case 0x66: return "R_860_SPGOTOFF1";
     case 0x68: return "R_860_LOGOTOFF2";
     case 0x6C: return "R_860_LOGOTOFF3";
     case 0x70: return "R_860_LOPC";
     case 0x80: return "R_860_HIGHADJ";
     case 0x90: return "R_860_HAGOT";
     case 0xA0: return "R_860_HAGOTOFF";
     case 0xB0: return "R_860_HAPC";
     case 0xC0: return "R_860_HIGH";
     case 0xD0: return "R_860_HIGOT";
     case 0xE0: return "R_860_HIGOTOFF";
default: return 
# 64 "./../include/elf/i860.h" 3 4
((void *)0)
# 64 "./../include/elf/i860.h"
; } }
# 113 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/i960.h" 1
# 26 "./../include/elf/i960.h"
static const char *elf_i960_reloc_type (unsigned long rtype); static const char * elf_i960_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_960_NONE";
     case 1: return "R_960_12";
     case 2: return "R_960_32";
     case 3: return "R_960_IP24";
     case 4: return "R_960_SUB";
     case 5: return "R_960_OPTCALL";
     case 6: return "R_960_OPTCALLX";
     case 7: return "R_960_OPTCALLXA";
default: return 
# 35 "./../include/elf/i960.h" 3 4
((void *)0)
# 35 "./../include/elf/i960.h"
; } }
# 114 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/ia64.h" 1
# 217 "./../include/elf/ia64.h"
typedef struct
{
  unsigned char fixup_offset[8];
  unsigned char type[4];
  unsigned char fixup_seg[4];
  unsigned char addend[8];
  unsigned char symvec_index[4];
  unsigned char data_type[4];
} Elf64_External_VMS_IMAGE_FIXUP;

typedef struct
{
  unsigned char rela_offset[8];
  unsigned char type[4];
  unsigned char rela_seg[4];
  unsigned char addend[8];
  unsigned char sym_offset[8];
  unsigned char sym_seg[4];
  unsigned char fill_1[4];
} Elf64_External_VMS_IMAGE_RELA;



typedef struct {
  unsigned char namesz[8];
  unsigned char descsz[8];
  unsigned char type[8];
  char name[1];
} Elf64_External_VMS_Note;
# 264 "./../include/elf/ia64.h"
typedef struct {
  unsigned char major_id[4];
  unsigned char minor_id[4];
  unsigned char manipulation_date[8];
  unsigned char link_flags[8];
  unsigned char elf_flags[4];
  unsigned char _pad[4];
  unsigned char imgid[1];
} Elf64_External_VMS_ORIG_DYN_Note;
# 287 "./../include/elf/ia64.h"
static const char *elf_ia64_reloc_type (unsigned long rtype); static const char * elf_ia64_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0x00: return "R_IA64_NONE";

  case 0x21: return "R_IA64_IMM14";
  case 0x22: return "R_IA64_IMM22";
  case 0x23: return "R_IA64_IMM64";
  case 0x24: return "R_IA64_DIR32MSB";
  case 0x25: return "R_IA64_DIR32LSB";
  case 0x26: return "R_IA64_DIR64MSB";
  case 0x27: return "R_IA64_DIR64LSB";

  case 0x2a: return "R_IA64_GPREL22";
  case 0x2b: return "R_IA64_GPREL64I";
  case 0x2c: return "R_IA64_GPREL32MSB";
  case 0x2d: return "R_IA64_GPREL32LSB";
  case 0x2e: return "R_IA64_GPREL64MSB";
  case 0x2f: return "R_IA64_GPREL64LSB";

  case 0x32: return "R_IA64_LTOFF22";
  case 0x33: return "R_IA64_LTOFF64I";

  case 0x3a: return "R_IA64_PLTOFF22";
  case 0x3b: return "R_IA64_PLTOFF64I";
  case 0x3e: return "R_IA64_PLTOFF64MSB";
  case 0x3f: return "R_IA64_PLTOFF64LSB";

  case 0x43: return "R_IA64_FPTR64I";
  case 0x44: return "R_IA64_FPTR32MSB";
  case 0x45: return "R_IA64_FPTR32LSB";
  case 0x46: return "R_IA64_FPTR64MSB";
  case 0x47: return "R_IA64_FPTR64LSB";

  case 0x48: return "R_IA64_PCREL60B";
  case 0x49: return "R_IA64_PCREL21B";
  case 0x4a: return "R_IA64_PCREL21M";
  case 0x4b: return "R_IA64_PCREL21F";
  case 0x4c: return "R_IA64_PCREL32MSB";
  case 0x4d: return "R_IA64_PCREL32LSB";
  case 0x4e: return "R_IA64_PCREL64MSB";
  case 0x4f: return "R_IA64_PCREL64LSB";

  case 0x52: return "R_IA64_LTOFF_FPTR22";
  case 0x53: return "R_IA64_LTOFF_FPTR64I";
  case 0x54: return "R_IA64_LTOFF_FPTR32MSB";
  case 0x55: return "R_IA64_LTOFF_FPTR32LSB";
  case 0x56: return "R_IA64_LTOFF_FPTR64MSB";
  case 0x57: return "R_IA64_LTOFF_FPTR64LSB";

  case 0x5c: return "R_IA64_SEGREL32MSB";
  case 0x5d: return "R_IA64_SEGREL32LSB";
  case 0x5e: return "R_IA64_SEGREL64MSB";
  case 0x5f: return "R_IA64_SEGREL64LSB";

  case 0x64: return "R_IA64_SECREL32MSB";
  case 0x65: return "R_IA64_SECREL32LSB";
  case 0x66: return "R_IA64_SECREL64MSB";
  case 0x67: return "R_IA64_SECREL64LSB";

  case 0x6c: return "R_IA64_REL32MSB";
  case 0x6d: return "R_IA64_REL32LSB";
  case 0x6e: return "R_IA64_REL64MSB";
  case 0x6f: return "R_IA64_REL64LSB";

  case 0x74: return "R_IA64_LTV32MSB";
  case 0x75: return "R_IA64_LTV32LSB";
  case 0x76: return "R_IA64_LTV64MSB";
  case 0x77: return "R_IA64_LTV64LSB";

  case 0x79: return "R_IA64_PCREL21BI";
  case 0x7a: return "R_IA64_PCREL22";
  case 0x7b: return "R_IA64_PCREL64I";

  case 0x80: return "R_IA64_IPLTMSB";
  case 0x81: return "R_IA64_IPLTLSB";
  case 0x84: return "R_IA64_COPY";
  case 0x86: return "R_IA64_LTOFF22X";
  case 0x87: return "R_IA64_LDXMOV";

  case 0x91: return "R_IA64_TPREL14";
  case 0x92: return "R_IA64_TPREL22";
  case 0x93: return "R_IA64_TPREL64I";
  case 0x96: return "R_IA64_TPREL64MSB";
  case 0x97: return "R_IA64_TPREL64LSB";

  case 0x9a: return "R_IA64_LTOFF_TPREL22";

  case 0xa6: return "R_IA64_DTPMOD64MSB";
  case 0xa7: return "R_IA64_DTPMOD64LSB";
  case 0xaa: return "R_IA64_LTOFF_DTPMOD22";

  case 0xb1: return "R_IA64_DTPREL14";
  case 0xb2: return "R_IA64_DTPREL22";
  case 0xb3: return "R_IA64_DTPREL64I";
  case 0xb4: return "R_IA64_DTPREL32MSB";
  case 0xb5: return "R_IA64_DTPREL32LSB";
  case 0xb6: return "R_IA64_DTPREL64MSB";
  case 0xb7: return "R_IA64_DTPREL64LSB";

  case 0xba: return "R_IA64_LTOFF_DTPREL22";

 


  case 0x70000000: return "R_IA64_VMS_DIR8";
  case 0x70000001: return "R_IA64_VMS_DIR16LSB";
  case 0x70000002: return "R_IA64_VMS_CALL_SIGNATURE";
  case 0x70000003: return "R_IA64_VMS_EXECLET_FUNC";
  case 0x70000004: return "R_IA64_VMS_EXECLET_DATA";
  case 0x70000005: return "R_IA64_VMS_FIX8";
  case 0x70000006: return "R_IA64_VMS_FIX16";
  case 0x70000007: return "R_IA64_VMS_FIX32";
  case 0x70000008: return "R_IA64_VMS_FIX64";
  case 0x70000009: return "R_IA64_VMS_FIXFD";
  case 0x7000000a: return "R_IA64_VMS_ACC_LOAD";
  case 0x7000000b: return "R_IA64_VMS_ACC_ADD";
  case 0x7000000c: return "R_IA64_VMS_ACC_SUB";
  case 0x7000000d: return "R_IA64_VMS_ACC_MUL";
  case 0x7000000e: return "R_IA64_VMS_ACC_DIV";
  case 0x7000000f: return "R_IA64_VMS_ACC_AND";
  case 0x70000010: return "R_IA64_VMS_ACC_IOR";
  case 0x70000011: return "R_IA64_VMS_ACC_EOR";
  case 0x70000012: return "R_IA64_VMS_ACC_ASH";
  case 0x70000014: return "R_IA64_VMS_ACC_STO8";
  case 0x70000015: return "R_IA64_VMS_ACC_STO16LSH";
  case 0x70000016: return "R_IA64_VMS_ACC_STO32LSH";
  case 0x70000017: return "R_IA64_VMS_ACC_STO64LSH";
default: return 
# 413 "./../include/elf/ia64.h" 3 4
((void *)0)
# 413 "./../include/elf/ia64.h"
; } }
# 115 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/ip2k.h" 1
# 26 "./../include/elf/ip2k.h"
static const char *elf_ip2k_reloc_type (unsigned long rtype); static const char * elf_ip2k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_IP2K_NONE";
  case 1: return "R_IP2K_16";
  case 2: return "R_IP2K_32";
  case 3: return "R_IP2K_FR9";
  case 4: return "R_IP2K_BANK";
  case 5: return "R_IP2K_ADDR16CJP";
  case 6: return "R_IP2K_PAGE3";
  case 7: return "R_IP2K_LO8DATA";
  case 8: return "R_IP2K_HI8DATA";
  case 9: return "R_IP2K_LO8INSN";
  case 10: return "R_IP2K_HI8INSN";
  case 11: return "R_IP2K_PC_SKIP";
  case 12: return "R_IP2K_TEXT";
  case 13: return "R_IP2K_FR_OFFSET";
  case 14: return "R_IP2K_EX8DATA";
default: return 
# 42 "./../include/elf/ip2k.h" 3 4
((void *)0)
# 42 "./../include/elf/ip2k.h"
; } }
# 116 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/lm32.h" 1
# 27 "./../include/elf/lm32.h"
static const char *elf_lm32_reloc_type (unsigned long rtype); static const char * elf_lm32_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_LM32_NONE";
     case 1: return "R_LM32_8";
     case 2: return "R_LM32_16";
     case 3: return "R_LM32_32";
     case 4: return "R_LM32_HI16";
     case 5: return "R_LM32_LO16";
     case 6: return "R_LM32_GPREL16";
     case 7: return "R_LM32_CALL";
     case 8: return "R_LM32_BRANCH";
     case 9: return "R_LM32_GNU_VTINHERIT";
     case 10: return "R_LM32_GNU_VTENTRY";
     case 11: return "R_LM32_16_GOT";
     case 12: return "R_LM32_GOTOFF_HI16";
     case 13: return "R_LM32_GOTOFF_LO16";
     case 14: return "R_LM32_COPY";
     case 15: return "R_LM32_GLOB_DAT";
     case 16: return "R_LM32_JMP_SLOT";
     case 17: return "R_LM32_RELATIVE";
default: return 
# 46 "./../include/elf/lm32.h" 3 4
((void *)0)
# 46 "./../include/elf/lm32.h"
; } }
# 117 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/iq2000.h" 1
# 26 "./../include/elf/iq2000.h"
static const char *elf_iq2000_reloc_type (unsigned long rtype); static const char * elf_iq2000_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_IQ2000_NONE";
  case 1: return "R_IQ2000_16";
  case 2: return "R_IQ2000_32";
  case 3: return "R_IQ2000_26";
  case 4: return "R_IQ2000_PC16";
  case 5: return "R_IQ2000_HI16";
  case 6: return "R_IQ2000_LO16";
  case 7: return "R_IQ2000_OFFSET_16";
  case 8: return "R_IQ2000_OFFSET_21";
  case 9: return "R_IQ2000_UHI16";
  case 10: return "R_IQ2000_32_DEBUG";
  case 200: return "R_IQ2000_GNU_VTINHERIT";
  case 201: return "R_IQ2000_GNU_VTENTRY";
default: return 
# 40 "./../include/elf/iq2000.h" 3 4
((void *)0)
# 40 "./../include/elf/iq2000.h"
; } }
# 118 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/m32c.h" 1
# 26 "./../include/elf/m32c.h"
  static const char *elf_m32c_reloc_type (unsigned long rtype); static const char * elf_m32c_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_M32C_NONE";
     case 1: return "R_M32C_16";
     case 2: return "R_M32C_24";
     case 3: return "R_M32C_32";
     case 4: return "R_M32C_8_PCREL";
     case 5: return "R_M32C_16_PCREL";


     case 6: return "R_M32C_8";

     case 7: return "R_M32C_LO16";

     case 8: return "R_M32C_HI8";

     case 9: return "R_M32C_HI16";



     case 10: return "R_M32C_RL_JUMP";

     case 11: return "R_M32C_RL_1ADDR";

     case 12: return "R_M32C_RL_2ADDR";

     default: return 
# 51 "./../include/elf/m32c.h" 3 4
    ((void *)0)
# 51 "./../include/elf/m32c.h"
    ; } }
# 119 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/m32r.h" 1
# 26 "./../include/elf/m32r.h"
static const char *elf_m32r_reloc_type (unsigned long rtype); static const char * elf_m32r_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_M32R_NONE";

  case 1: return "R_M32R_16";
  case 2: return "R_M32R_32";
  case 3: return "R_M32R_24";
  case 4: return "R_M32R_10_PCREL";
  case 5: return "R_M32R_18_PCREL";
  case 6: return "R_M32R_26_PCREL";
  case 7: return "R_M32R_HI16_ULO";
  case 8: return "R_M32R_HI16_SLO";
  case 9: return "R_M32R_LO16";
  case 10: return "R_M32R_SDA16";
  case 11: return "R_M32R_GNU_VTINHERIT";
  case 12: return "R_M32R_GNU_VTENTRY";


  case 33: return "R_M32R_16_RELA";
  case 34: return "R_M32R_32_RELA";
  case 35: return "R_M32R_24_RELA";
  case 36: return "R_M32R_10_PCREL_RELA";
  case 37: return "R_M32R_18_PCREL_RELA";
  case 38: return "R_M32R_26_PCREL_RELA";
  case 39: return "R_M32R_HI16_ULO_RELA";
  case 40: return "R_M32R_HI16_SLO_RELA";
  case 41: return "R_M32R_LO16_RELA";
  case 42: return "R_M32R_SDA16_RELA";
  case 43: return "R_M32R_RELA_GNU_VTINHERIT";
  case 44: return "R_M32R_RELA_GNU_VTENTRY";

  case 45: return "R_M32R_REL32";

  case 48: return "R_M32R_GOT24";
  case 49: return "R_M32R_26_PLTREL";
  case 50: return "R_M32R_COPY";
  case 51: return "R_M32R_GLOB_DAT";
  case 52: return "R_M32R_JMP_SLOT";
  case 53: return "R_M32R_RELATIVE";
  case 54: return "R_M32R_GOTOFF";
  case 55: return "R_M32R_GOTPC24";
  case 56: return "R_M32R_GOT16_HI_ULO";
  case 57: return "R_M32R_GOT16_HI_SLO";
  case 58: return "R_M32R_GOT16_LO";
  case 59: return "R_M32R_GOTPC_HI_ULO";
  case 60: return "R_M32R_GOTPC_HI_SLO";
  case 61: return "R_M32R_GOTPC_LO";
  case 62: return "R_M32R_GOTOFF_HI_ULO";
  case 63: return "R_M32R_GOTOFF_HI_SLO";
  case 64: return "R_M32R_GOTOFF_LO";

default: return 
# 76 "./../include/elf/m32r.h" 3 4
((void *)0)
# 76 "./../include/elf/m32r.h"
; } }
# 120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/m68k.h" 1
# 26 "./../include/elf/m68k.h"
static const char *elf_m68k_reloc_type (unsigned long rtype); static const char * elf_m68k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_68K_NONE";
  case 1: return "R_68K_32";
  case 2: return "R_68K_16";
  case 3: return "R_68K_8";
  case 4: return "R_68K_PC32";
  case 5: return "R_68K_PC16";
  case 6: return "R_68K_PC8";
  case 7: return "R_68K_GOT32";
  case 8: return "R_68K_GOT16";
  case 9: return "R_68K_GOT8";
  case 10: return "R_68K_GOT32O";
  case 11: return "R_68K_GOT16O";
  case 12: return "R_68K_GOT8O";
  case 13: return "R_68K_PLT32";
  case 14: return "R_68K_PLT16";
  case 15: return "R_68K_PLT8";
  case 16: return "R_68K_PLT32O";
  case 17: return "R_68K_PLT16O";
  case 18: return "R_68K_PLT8O";
  case 19: return "R_68K_COPY";
  case 20: return "R_68K_GLOB_DAT";
  case 21: return "R_68K_JMP_SLOT";
  case 22: return "R_68K_RELATIVE";

  case 23: return "R_68K_GNU_VTINHERIT";
  case 24: return "R_68K_GNU_VTENTRY";

  case 25: return "R_68K_TLS_GD32";
  case 26: return "R_68K_TLS_GD16";
  case 27: return "R_68K_TLS_GD8";
  case 28: return "R_68K_TLS_LDM32";
  case 29: return "R_68K_TLS_LDM16";
  case 30: return "R_68K_TLS_LDM8";
  case 31: return "R_68K_TLS_LDO32";
  case 32: return "R_68K_TLS_LDO16";
  case 33: return "R_68K_TLS_LDO8";
  case 34: return "R_68K_TLS_IE32";
  case 35: return "R_68K_TLS_IE16";
  case 36: return "R_68K_TLS_IE8";
  case 37: return "R_68K_TLS_LE32";
  case 38: return "R_68K_TLS_LE16";
  case 39: return "R_68K_TLS_LE8";
  case 40: return "R_68K_TLS_DTPMOD32";
  case 41: return "R_68K_TLS_DTPREL32";
  case 42: return "R_68K_TLS_TPREL32";
default: return 
# 72 "./../include/elf/m68k.h" 3 4
((void *)0)
# 72 "./../include/elf/m68k.h"
; } }
# 121 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/m68hc11.h" 1
# 26 "./../include/elf/m68hc11.h"
static const char *elf_m68hc11_reloc_type (unsigned long rtype); static const char * elf_m68hc11_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_M68HC11_NONE";
  case 1: return "R_M68HC11_8";
  case 2: return "R_M68HC11_HI8";
  case 3: return "R_M68HC11_LO8";
  case 4: return "R_M68HC11_PCREL_8";
  case 5: return "R_M68HC11_16";
  case 6: return "R_M68HC11_32";
  case 7: return "R_M68HC11_3B";
  case 8: return "R_M68HC11_PCREL_16";


  case 9: return "R_M68HC11_GNU_VTINHERIT";
  case 10: return "R_M68HC11_GNU_VTENTRY";

  case 11: return "R_M68HC11_24";
  case 12: return "R_M68HC11_LO16";
  case 13: return "R_M68HC11_PAGE";

  case 15: return "R_M68HC12_16B";
  case 16: return "R_M68HC12_PCREL_9";
  case 17: return "R_M68HC12_PCREL_10";
  case 18: return "R_M68HC12_HI8XG";
  case 19: return "R_M68HC12_LO8XG";



  case 20: return "R_M68HC11_RL_JUMP";


  case 21: return "R_M68HC11_RL_GROUP";
default: return 
# 57 "./../include/elf/m68hc11.h" 3 4
((void *)0)
# 57 "./../include/elf/m68hc11.h"
; } }
# 122 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mcore.h" 1
# 28 "./../include/elf/mcore.h"
static const char *elf_mcore_reloc_type (unsigned long rtype); static const char * elf_mcore_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MCORE_NONE";
  case 1: return "R_MCORE_ADDR32";
  case 2: return "R_MCORE_PCRELIMM8BY4";
  case 3: return "R_MCORE_PCRELIMM11BY2";
  case 4: return "R_MCORE_PCRELIMM4BY2";
  case 5: return "R_MCORE_PCREL32";
  case 6: return "R_MCORE_PCRELJSR_IMM11BY2";
  case 7: return "R_MCORE_GNU_VTINHERIT";
  case 8: return "R_MCORE_GNU_VTENTRY";
  case 9: return "R_MCORE_RELATIVE";
  case 10: return "R_MCORE_COPY";
  case 11: return "R_MCORE_GLOB_DAT";
  case 12: return "R_MCORE_JUMP_SLOT";
default: return 
# 42 "./../include/elf/mcore.h" 3 4
((void *)0)
# 42 "./../include/elf/mcore.h"
; } }
# 123 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mep.h" 1
# 33 "./../include/elf/mep.h"
static const char *elf_mep_reloc_type (unsigned long rtype); static const char * elf_mep_reloc_type (unsigned long rtype) { switch (rtype) {


  case 0: return "R_MEP_NONE";
  case 1: return "R_RELC";

  case 2: return "R_MEP_8";
  case 3: return "R_MEP_16";
  case 4: return "R_MEP_32";

  case 5: return "R_MEP_PCREL8A2";
  case 6: return "R_MEP_PCREL12A2";
  case 7: return "R_MEP_PCREL17A2";
  case 8: return "R_MEP_PCREL24A2";
  case 9: return "R_MEP_PCABS24A2";

  case 10: return "R_MEP_LOW16";
  case 11: return "R_MEP_HI16U";
  case 12: return "R_MEP_HI16S";
  case 13: return "R_MEP_GPREL";
  case 14: return "R_MEP_TPREL";

  case 15: return "R_MEP_TPREL7";
  case 16: return "R_MEP_TPREL7A2";
  case 17: return "R_MEP_TPREL7A4";

  case 18: return "R_MEP_UIMM24";
  case 19: return "R_MEP_ADDR24A4";

  case 20: return "R_MEP_GNU_VTINHERIT";
  case 21: return "R_MEP_GNU_VTENTRY";

default: return 
# 65 "./../include/elf/mep.h" 3 4
((void *)0)
# 65 "./../include/elf/mep.h"
; } }
# 124 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/metag.h" 1
# 28 "./../include/elf/metag.h"
static const char *elf_metag_reloc_type (unsigned long rtype); static const char * elf_metag_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_METAG_HIADDR16";
     case 1: return "R_METAG_LOADDR16";
     case 2: return "R_METAG_ADDR32";
     case 3: return "R_METAG_NONE";
     case 4: return "R_METAG_RELBRANCH";
     case 5: return "R_METAG_GETSETOFF";


     case 6: return "R_METAG_REG32OP1";
     case 7: return "R_METAG_REG32OP2";
     case 8: return "R_METAG_REG32OP3";
     case 9: return "R_METAG_REG16OP1";
     case 10: return "R_METAG_REG16OP2";
     case 11: return "R_METAG_REG16OP3";
     case 12: return "R_METAG_REG32OP4";

     case 13: return "R_METAG_HIOG";
     case 14: return "R_METAG_LOOG";

     case 15: return "R_METAG_REL8";
     case 16: return "R_METAG_REL16";


     case 30: return "R_METAG_GNU_VTINHERIT";
     case 31: return "R_METAG_GNU_VTENTRY";


     case 32: return "R_METAG_HI16_GOTOFF";
     case 33: return "R_METAG_LO16_GOTOFF";
     case 34: return "R_METAG_GETSET_GOTOFF";
     case 35: return "R_METAG_GETSET_GOT";
     case 36: return "R_METAG_HI16_GOTPC";
     case 37: return "R_METAG_LO16_GOTPC";
     case 38: return "R_METAG_HI16_PLT";
     case 39: return "R_METAG_LO16_PLT";
     case 40: return "R_METAG_RELBRANCH_PLT";
     case 41: return "R_METAG_GOTOFF";
     case 42: return "R_METAG_PLT";
     case 43: return "R_METAG_COPY";
     case 44: return "R_METAG_JMP_SLOT";
     case 45: return "R_METAG_RELATIVE";
     case 46: return "R_METAG_GLOB_DAT";


     case 47: return "R_METAG_TLS_GD";
     case 48: return "R_METAG_TLS_LDM";
     case 49: return "R_METAG_TLS_LDO_HI16";
     case 50: return "R_METAG_TLS_LDO_LO16";
     case 51: return "R_METAG_TLS_LDO";
     case 52: return "R_METAG_TLS_IE";
     case 53: return "R_METAG_TLS_IENONPIC";
     case 54: return "R_METAG_TLS_IENONPIC_HI16";
     case 55: return "R_METAG_TLS_IENONPIC_LO16";
     case 56: return "R_METAG_TLS_TPOFF";
     case 57: return "R_METAG_TLS_DTPMOD";
     case 58: return "R_METAG_TLS_DTPOFF";
     case 59: return "R_METAG_TLS_LE";
     case 60: return "R_METAG_TLS_LE_HI16";
     case 61: return "R_METAG_TLS_LE_LO16";

default: return 
# 89 "./../include/elf/metag.h" 3 4
((void *)0)
# 89 "./../include/elf/metag.h"
; } }
# 125 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/microblaze.h" 1
# 30 "./../include/elf/microblaze.h"
static const char *elf_microblaze_reloc_type (unsigned long rtype); static const char * elf_microblaze_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MICROBLAZE_NONE";
  case 1: return "R_MICROBLAZE_32";
  case 2: return "R_MICROBLAZE_32_PCREL";
  case 3: return "R_MICROBLAZE_64_PCREL";
  case 4: return "R_MICROBLAZE_32_PCREL_LO";
  case 5: return "R_MICROBLAZE_64";
  case 6: return "R_MICROBLAZE_32_LO";
  case 7: return "R_MICROBLAZE_SRO32";
  case 8: return "R_MICROBLAZE_SRW32";
  case 9: return "R_MICROBLAZE_64_NONE";
  case 10: return "R_MICROBLAZE_32_SYM_OP_SYM";
  case 11: return "R_MICROBLAZE_GNU_VTINHERIT";
  case 12: return "R_MICROBLAZE_GNU_VTENTRY";
  case 13: return "R_MICROBLAZE_GOTPC_64";
  case 14: return "R_MICROBLAZE_GOT_64";
  case 15: return "R_MICROBLAZE_PLT_64";
  case 16: return "R_MICROBLAZE_REL";
  case 17: return "R_MICROBLAZE_JUMP_SLOT";
  case 18: return "R_MICROBLAZE_GLOB_DAT";
  case 19: return "R_MICROBLAZE_GOTOFF_64";
  case 20: return "R_MICROBLAZE_GOTOFF_32";
  case 21: return "R_MICROBLAZE_COPY";
  case 22: return "R_MICROBLAZE_TLS";
  case 23: return "R_MICROBLAZE_TLSGD";
  case 24: return "R_MICROBLAZE_TLSLD";
  case 25: return "R_MICROBLAZE_TLSDTPMOD32";
  case 26: return "R_MICROBLAZE_TLSDTPREL32";
  case 27: return "R_MICROBLAZE_TLSDTPREL64";
  case 28: return "R_MICROBLAZE_TLSGOTTPREL32";
  case 29: return "R_MICROBLAZE_TLSTPREL32";

default: return 
# 62 "./../include/elf/microblaze.h" 3 4
((void *)0)
# 62 "./../include/elf/microblaze.h"
; } }
# 126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mips.h" 1
# 38 "./../include/elf/mips.h"
static const char *elf_mips_reloc_type (unsigned long rtype); static const char * elf_mips_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MIPS_NONE";
  case 1: return "R_MIPS_16";
  case 2: return "R_MIPS_32";
  case 3: return "R_MIPS_REL32";
  case 4: return "R_MIPS_26";
  case 5: return "R_MIPS_HI16";
  case 6: return "R_MIPS_LO16";
  case 7: return "R_MIPS_GPREL16";
  case 8: return "R_MIPS_LITERAL";
  case 9: return "R_MIPS_GOT16";
  case 10: return "R_MIPS_PC16";
  case 11: return "R_MIPS_CALL16";
  case 12: return "R_MIPS_GPREL32";


  case 13: return "R_MIPS_UNUSED1";
  case 14: return "R_MIPS_UNUSED2";
  case 15: return "R_MIPS_UNUSED3";
  case 16: return "R_MIPS_SHIFT5";
  case 17: return "R_MIPS_SHIFT6";
  case 18: return "R_MIPS_64";
  case 19: return "R_MIPS_GOT_DISP";
  case 20: return "R_MIPS_GOT_PAGE";
  case 21: return "R_MIPS_GOT_OFST";
  case 22: return "R_MIPS_GOT_HI16";
  case 23: return "R_MIPS_GOT_LO16";
  case 24: return "R_MIPS_SUB";
  case 25: return "R_MIPS_INSERT_A";
  case 26: return "R_MIPS_INSERT_B";
  case 27: return "R_MIPS_DELETE";
  case 28: return "R_MIPS_HIGHER";
  case 29: return "R_MIPS_HIGHEST";
  case 30: return "R_MIPS_CALL_HI16";
  case 31: return "R_MIPS_CALL_LO16";
  case 32: return "R_MIPS_SCN_DISP";
  case 33: return "R_MIPS_REL16";
  case 34: return "R_MIPS_ADD_IMMEDIATE";
  case 35: return "R_MIPS_PJUMP";
  case 36: return "R_MIPS_RELGOT";
  case 37: return "R_MIPS_JALR";

  case 38: return "R_MIPS_TLS_DTPMOD32";
  case 39: return "R_MIPS_TLS_DTPREL32";
  case 40: return "R_MIPS_TLS_DTPMOD64";
  case 41: return "R_MIPS_TLS_DTPREL64";
  case 42: return "R_MIPS_TLS_GD";
  case 43: return "R_MIPS_TLS_LDM";
  case 44: return "R_MIPS_TLS_DTPREL_HI16";
  case 45: return "R_MIPS_TLS_DTPREL_LO16";
  case 46: return "R_MIPS_TLS_GOTTPREL";
  case 47: return "R_MIPS_TLS_TPREL32";
  case 48: return "R_MIPS_TLS_TPREL64";
  case 49: return "R_MIPS_TLS_TPREL_HI16";
  case 50: return "R_MIPS_TLS_TPREL_LO16";
  case 51: return "R_MIPS_GLOB_DAT";

  case 60: return "R_MIPS_PC21_S2";
  case 61: return "R_MIPS_PC26_S2";
  case 62: return "R_MIPS_PC18_S3";
  case 63: return "R_MIPS_PC19_S2";
  case 64: return "R_MIPS_PCHI16";
  case 65: return "R_MIPS_PCLO16";
 

 
  case 100: return "R_MIPS16_26";
  case 101: return "R_MIPS16_GPREL";
  case 102: return "R_MIPS16_GOT16";
  case 103: return "R_MIPS16_CALL16";
  case 104: return "R_MIPS16_HI16";
  case 105: return "R_MIPS16_LO16";
  case 106: return "R_MIPS16_TLS_GD";
  case 107: return "R_MIPS16_TLS_LDM";
  case 108: return "R_MIPS16_TLS_DTPREL_HI16";
  case 109: return "R_MIPS16_TLS_DTPREL_LO16";
  case 110: return "R_MIPS16_TLS_GOTTPREL";
  case 111: return "R_MIPS16_TLS_TPREL_HI16";
  case 112: return "R_MIPS16_TLS_TPREL_LO16";
  case 113: return "R_MIPS16_PC16_S1";
 

  case 126: return "R_MIPS_COPY";
  case 127: return "R_MIPS_JUMP_SLOT";


 
  case 133: return "R_MICROMIPS_26_S1";
  case 134: return "R_MICROMIPS_HI16";
  case 135: return "R_MICROMIPS_LO16";
  case 136: return "R_MICROMIPS_GPREL16";

  case 137: return "R_MICROMIPS_LITERAL";
  case 138: return "R_MICROMIPS_GOT16";

  case 139: return "R_MICROMIPS_PC7_S1";
  case 140: return "R_MICROMIPS_PC10_S1";
  case 141: return "R_MICROMIPS_PC16_S1";
  case 142: return "R_MICROMIPS_CALL16";

  case 145: return "R_MICROMIPS_GOT_DISP";
  case 146: return "R_MICROMIPS_GOT_PAGE";
  case 147: return "R_MICROMIPS_GOT_OFST";
  case 148: return "R_MICROMIPS_GOT_HI16";
  case 149: return "R_MICROMIPS_GOT_LO16";
  case 150: return "R_MICROMIPS_SUB";
  case 151: return "R_MICROMIPS_HIGHER";
  case 152: return "R_MICROMIPS_HIGHEST";
  case 153: return "R_MICROMIPS_CALL_HI16";
  case 154: return "R_MICROMIPS_CALL_LO16";
  case 155: return "R_MICROMIPS_SCN_DISP";
  case 156: return "R_MICROMIPS_JALR";
  case 157: return "R_MICROMIPS_HI0_LO16";

  case 162: return "R_MICROMIPS_TLS_GD";
  case 163: return "R_MICROMIPS_TLS_LDM";
  case 164: return "R_MICROMIPS_TLS_DTPREL_HI16";
  case 165: return "R_MICROMIPS_TLS_DTPREL_LO16";
  case 166: return "R_MICROMIPS_TLS_GOTTPREL";
  case 169: return "R_MICROMIPS_TLS_TPREL_HI16";
  case 170: return "R_MICROMIPS_TLS_TPREL_LO16";

  case 172: return "R_MICROMIPS_GPREL7_S2";
  case 173: return "R_MICROMIPS_PC23_S2";
 




  case 248: return "R_MIPS_PC32";
  case 249: return "R_MIPS_EH";

  case 250: return "R_MIPS_GNU_REL16_S2";

  case 253: return "R_MIPS_GNU_VTINHERIT";
  case 254: return "R_MIPS_GNU_VTENTRY";
default: return 
# 174 "./../include/elf/mips.h" 3 4
((void *)0)
# 174 "./../include/elf/mips.h"
; } }
# 457 "./../include/elf/mips.h"
typedef struct
{

  unsigned long l_name;

  unsigned long l_time_stamp;

  unsigned long l_checksum;

  unsigned long l_version;

  unsigned long l_flags;
} Elf32_Lib;


typedef struct
{
  unsigned char l_name[4];
  unsigned char l_time_stamp[4];
  unsigned char l_checksum[4];
  unsigned char l_version[4];
  unsigned char l_flags[4];
} Elf32_External_Lib;
# 505 "./../include/elf/mips.h"
typedef unsigned long Elf32_Conflict;
typedef unsigned char Elf32_External_Conflict[4];

typedef unsigned long Elf64_Conflict;
typedef unsigned char Elf64_External_Conflict[8];
# 519 "./../include/elf/mips.h"
typedef union
{
  struct
    {

      unsigned long gt_current_g_value;

      unsigned long gt_unused;
    } gt_header;
  struct
    {

      unsigned long gt_g_value;

      unsigned long gt_bytes;
    } gt_entry;
} Elf32_gptab;



typedef union
{
  struct
    {
      unsigned char gt_current_g_value[4];
      unsigned char gt_unused[4];
    } gt_header;
  struct
    {
      unsigned char gt_g_value[4];
      unsigned char gt_bytes[4];
    } gt_entry;
} Elf32_External_gptab;



typedef struct
{

  unsigned long ri_gprmask;

  unsigned long ri_cprmask[4];

  long ri_gp_value;
} Elf32_RegInfo;


typedef struct
{
  unsigned char ri_gprmask[4];
  unsigned char ri_cprmask[4][4];
  unsigned char ri_gp_value[4];
} Elf32_External_RegInfo;


extern void bfd_mips_elf32_swap_reginfo_in
  (bfd *, const Elf32_External_RegInfo *, Elf32_RegInfo *);
extern void bfd_mips_elf32_swap_reginfo_out
  (bfd *, const Elf32_RegInfo *, Elf32_External_RegInfo *);
# 891 "./../include/elf/mips.h"
typedef struct
{

  unsigned char r_offset[8];

  unsigned char r_sym[4];

  unsigned char r_ssym[1];

  unsigned char r_type3[1];

  unsigned char r_type2[1];

  unsigned char r_type[1];
} Elf64_Mips_External_Rel;

typedef struct
{

  bfd_vma r_offset;

  unsigned long r_sym;

  unsigned char r_ssym;

  unsigned char r_type3;

  unsigned char r_type2;

  unsigned char r_type;
} Elf64_Mips_Internal_Rel;



typedef struct
{

  unsigned char r_offset[8];

  unsigned char r_sym[4];

  unsigned char r_ssym[1];

  unsigned char r_type3[1];

  unsigned char r_type2[1];

  unsigned char r_type[1];

  unsigned char r_addend[8];
} Elf64_Mips_External_Rela;

typedef struct
{

  bfd_vma r_offset;

  unsigned long r_sym;

  unsigned char r_ssym;

  unsigned char r_type3;

  unsigned char r_type2;

  unsigned char r_type;

  bfd_signed_vma r_addend;
} Elf64_Mips_Internal_Rela;
# 984 "./../include/elf/mips.h"
typedef struct
{

  unsigned char kind[1];

  unsigned char size[1];

  unsigned char section[2];

  unsigned char info[4];
} Elf_External_Options;

typedef struct
{

  unsigned char kind;

  unsigned char size;

  unsigned short section;

  unsigned long info;
} Elf_Internal_Options;


extern void bfd_mips_elf_swap_options_in
  (bfd *, const Elf_External_Options *, Elf_Internal_Options *);
extern void bfd_mips_elf_swap_options_out
  (bfd *, const Elf_Internal_Options *, Elf_External_Options *);
# 1054 "./../include/elf/mips.h"
typedef struct
{

  unsigned char ri_gprmask[4];

  unsigned char ri_pad[4];

  unsigned char ri_cprmask[4][4];

  unsigned char ri_gp_value[8];
} Elf64_External_RegInfo;

typedef struct
{

  unsigned long ri_gprmask;

  unsigned long ri_pad;

  unsigned long ri_cprmask[4];

  bfd_vma ri_gp_value;
} Elf64_Internal_RegInfo;



typedef struct
{

  unsigned char version[2];

  unsigned char isa_level[1];

  unsigned char isa_rev[1];

  unsigned char gpr_size[1];

  unsigned char cpr1_size[1];

  unsigned char cpr2_size[1];

  unsigned char fp_abi[1];

  unsigned char isa_ext[4];

  unsigned char ases[4];

  unsigned char flags1[4];
  unsigned char flags2[4];
} Elf_External_ABIFlags_v0;

typedef struct elf_internal_abiflags_v0
{

  unsigned short version;

  unsigned char isa_level;

  unsigned char isa_rev;

  unsigned char gpr_size;

  unsigned char cpr1_size;

  unsigned char cpr2_size;

  unsigned char fp_abi;

  unsigned long isa_ext;

  unsigned long ases;

  unsigned long flags1;
  unsigned long flags2;
} Elf_Internal_ABIFlags_v0;

typedef struct
{


  unsigned char ms_hash_value[4];







  unsigned char ms_info[4];
} Elf32_External_Msym;

typedef struct
{


  unsigned long ms_hash_value;







  unsigned long ms_info;
} Elf32_Internal_Msym;






extern void bfd_mips_elf64_swap_reginfo_in
  (bfd *, const Elf64_External_RegInfo *, Elf64_Internal_RegInfo *);
extern void bfd_mips_elf64_swap_reginfo_out
  (bfd *, const Elf64_Internal_RegInfo *, Elf64_External_RegInfo *);


extern void bfd_mips_elf_swap_abiflags_v0_in
  (bfd *, const Elf_External_ABIFlags_v0 *, Elf_Internal_ABIFlags_v0 *);
extern void bfd_mips_elf_swap_abiflags_v0_out
  (bfd *, const Elf_Internal_ABIFlags_v0 *, Elf_External_ABIFlags_v0 *);
# 1266 "./../include/elf/mips.h"
extern unsigned int bfd_mips_isa_ext (bfd *);



enum
{



  Tag_GNU_MIPS_ABI_FP = 4,


  Tag_GNU_MIPS_ABI_MSA = 8,
};


enum
{



  Val_GNU_MIPS_ABI_FP_ANY = 0,


  Val_GNU_MIPS_ABI_FP_DOUBLE = 1,


  Val_GNU_MIPS_ABI_FP_SINGLE = 2,


  Val_GNU_MIPS_ABI_FP_SOFT = 3,


  Val_GNU_MIPS_ABI_FP_OLD_64 = 4,


  Val_GNU_MIPS_ABI_FP_XX = 5,


  Val_GNU_MIPS_ABI_FP_64 = 6,


  Val_GNU_MIPS_ABI_FP_64A = 7,



  Val_GNU_MIPS_ABI_FP_NAN2008 = 8,




  Val_GNU_MIPS_ABI_MSA_ANY = 0,


  Val_GNU_MIPS_ABI_MSA_128 = 1,
};
# 127 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/riscv.h" 1
# 30 "./../include/elf/riscv.h"
# 1 "./../include/libiberty.h" 1
# 42 "./../include/libiberty.h"
# 1 "./../include/ansidecl.h" 1
# 43 "./../include/libiberty.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 112 "./../include/libiberty.h"
extern char *basename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 153 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 189 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 201 "./../include/libiberty.h"
extern char * getpwd (void);
# 214 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 283 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 382 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 419 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 519 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 534 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 609 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 628 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);
# 645 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));





extern int vasprintf (char **, const char *, va_list) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__nonnull__ (2)));





extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 706 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 719 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 31 "./../include/elf/riscv.h" 2


static const char *elf_riscv_reloc_type (unsigned long rtype); static const char * elf_riscv_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0: return "R_RISCV_NONE";
  case 1: return "R_RISCV_32";
  case 2: return "R_RISCV_64";
  case 3: return "R_RISCV_RELATIVE";
  case 4: return "R_RISCV_COPY";
  case 5: return "R_RISCV_JUMP_SLOT";
  case 6: return "R_RISCV_TLS_DTPMOD32";
  case 7: return "R_RISCV_TLS_DTPMOD64";
  case 8: return "R_RISCV_TLS_DTPREL32";
  case 9: return "R_RISCV_TLS_DTPREL64";
  case 10: return "R_RISCV_TLS_TPREL32";
  case 11: return "R_RISCV_TLS_TPREL64";


  case 16: return "R_RISCV_BRANCH";
  case 17: return "R_RISCV_JAL";
  case 18: return "R_RISCV_CALL";
  case 19: return "R_RISCV_CALL_PLT";
  case 20: return "R_RISCV_GOT_HI20";
  case 21: return "R_RISCV_TLS_GOT_HI20";
  case 22: return "R_RISCV_TLS_GD_HI20";
  case 23: return "R_RISCV_PCREL_HI20";
  case 24: return "R_RISCV_PCREL_LO12_I";
  case 25: return "R_RISCV_PCREL_LO12_S";
  case 26: return "R_RISCV_HI20";
  case 27: return "R_RISCV_LO12_I";
  case 28: return "R_RISCV_LO12_S";
  case 29: return "R_RISCV_TPREL_HI20";
  case 30: return "R_RISCV_TPREL_LO12_I";
  case 31: return "R_RISCV_TPREL_LO12_S";
  case 32: return "R_RISCV_TPREL_ADD";
  case 33: return "R_RISCV_ADD8";
  case 34: return "R_RISCV_ADD16";
  case 35: return "R_RISCV_ADD32";
  case 36: return "R_RISCV_ADD64";
  case 37: return "R_RISCV_SUB8";
  case 38: return "R_RISCV_SUB16";
  case 39: return "R_RISCV_SUB32";
  case 40: return "R_RISCV_SUB64";
  case 41: return "R_RISCV_GNU_VTINHERIT";
  case 42: return "R_RISCV_GNU_VTENTRY";
  case 43: return "R_RISCV_ALIGN";
  case 44: return "R_RISCV_RVC_BRANCH";
  case 45: return "R_RISCV_RVC_JUMP";
  case 46: return "R_RISCV_RVC_LUI";
  case 47: return "R_RISCV_GPREL_I";
  case 48: return "R_RISCV_GPREL_S";
  case 49: return "R_RISCV_TPREL_I";
  case 50: return "R_RISCV_TPREL_S";
  case 51: return "R_RISCV_RELAX";
  case 52: return "R_RISCV_SUB6";
  case 53: return "R_RISCV_SET6";
  case 54: return "R_RISCV_SET8";
  case 55: return "R_RISCV_SET16";
  case 56: return "R_RISCV_SET32";
  case 57: return "R_RISCV_32_PCREL";
default: return 
# 91 "./../include/elf/riscv.h" 3 4
((void *)0)
# 91 "./../include/elf/riscv.h"
; } }
# 128 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mmix.h" 1
# 29 "./../include/elf/mmix.h"
static const char *elf_mmix_reloc_type (unsigned long rtype); static const char * elf_mmix_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MMIX_NONE";


  case 1: return "R_MMIX_8";
  case 2: return "R_MMIX_16";
  case 3: return "R_MMIX_24";
  case 4: return "R_MMIX_32";
  case 5: return "R_MMIX_64";


  case 6: return "R_MMIX_PC_8";
  case 7: return "R_MMIX_PC_16";
  case 8: return "R_MMIX_PC_24";
  case 9: return "R_MMIX_PC_32";
  case 10: return "R_MMIX_PC_64";


  case 11: return "R_MMIX_GNU_VTINHERIT";
  case 12: return "R_MMIX_GNU_VTENTRY";


  case 13: return "R_MMIX_GETA";
  case 14: return "R_MMIX_GETA_1";
  case 15: return "R_MMIX_GETA_2";
  case 16: return "R_MMIX_GETA_3";


  case 17: return "R_MMIX_CBRANCH";
  case 18: return "R_MMIX_CBRANCH_J";
  case 19: return "R_MMIX_CBRANCH_1";
  case 20: return "R_MMIX_CBRANCH_2";
  case 21: return "R_MMIX_CBRANCH_3";


  case 22: return "R_MMIX_PUSHJ";
  case 23: return "R_MMIX_PUSHJ_1";
  case 24: return "R_MMIX_PUSHJ_2";
  case 25: return "R_MMIX_PUSHJ_3";


  case 26: return "R_MMIX_JMP";
  case 27: return "R_MMIX_JMP_1";
  case 28: return "R_MMIX_JMP_2";
  case 29: return "R_MMIX_JMP_3";


  case 30: return "R_MMIX_ADDR19";


  case 31: return "R_MMIX_ADDR27";


  case 32: return "R_MMIX_REG_OR_BYTE";


  case 33: return "R_MMIX_REG";





  case 34: return "R_MMIX_BASE_PLUS_OFFSET";


  case 35: return "R_MMIX_LOCAL";


  case 36: return "R_MMIX_PUSHJ_STUBBABLE";
default: return 
# 98 "./../include/elf/mmix.h" 3 4
((void *)0)
# 98 "./../include/elf/mmix.h"
; } }
# 165 "./../include/elf/mmix.h"
extern bfd_boolean _bfd_mmix_before_linker_allocation
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_mmix_after_linker_allocation
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_mmix_check_all_relocs
  (bfd *, struct bfd_link_info *);
# 129 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mn10200.h" 1
# 29 "./../include/elf/mn10200.h"
static const char *elf_mn10200_reloc_type (unsigned long rtype); static const char * elf_mn10200_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MN10200_NONE";
  case 1: return "R_MN10200_32";
  case 2: return "R_MN10200_16";
  case 3: return "R_MN10200_8";
  case 4: return "R_MN10200_24";
  case 5: return "R_MN10200_PCREL8";
  case 6: return "R_MN10200_PCREL16";
  case 7: return "R_MN10200_PCREL24";
default: return 
# 38 "./../include/elf/mn10200.h" 3 4
((void *)0)
# 38 "./../include/elf/mn10200.h"
; } }
# 130 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mn10300.h" 1
# 29 "./../include/elf/mn10300.h"
static const char *elf_mn10300_reloc_type (unsigned long rtype); static const char * elf_mn10300_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MN10300_NONE";
  case 1: return "R_MN10300_32";
  case 2: return "R_MN10300_16";
  case 3: return "R_MN10300_8";
  case 4: return "R_MN10300_PCREL32";
  case 5: return "R_MN10300_PCREL16";
  case 6: return "R_MN10300_PCREL8";
  case 7: return "R_MN10300_GNU_VTINHERIT";
  case 8: return "R_MN10300_GNU_VTENTRY";
  case 9: return "R_MN10300_24";
  case 10: return "R_MN10300_GOTPC32";
  case 11: return "R_MN10300_GOTPC16";
  case 12: return "R_MN10300_GOTOFF32";
  case 13: return "R_MN10300_GOTOFF24";
  case 14: return "R_MN10300_GOTOFF16";
  case 15: return "R_MN10300_PLT32";
  case 16: return "R_MN10300_PLT16";
  case 17: return "R_MN10300_GOT32";
  case 18: return "R_MN10300_GOT24";
  case 19: return "R_MN10300_GOT16";
  case 20: return "R_MN10300_COPY";
  case 21: return "R_MN10300_GLOB_DAT";
  case 22: return "R_MN10300_JMP_SLOT";
  case 23: return "R_MN10300_RELATIVE";
  case 24: return "R_MN10300_TLS_GD";
  case 25: return "R_MN10300_TLS_LD";
  case 26: return "R_MN10300_TLS_LDO";
  case 27: return "R_MN10300_TLS_GOTIE";
  case 28: return "R_MN10300_TLS_IE";
  case 29: return "R_MN10300_TLS_LE";
  case 30: return "R_MN10300_TLS_DTPMOD";
  case 31: return "R_MN10300_TLS_DTPOFF";
  case 32: return "R_MN10300_TLS_TPOFF";
  case 33: return "R_MN10300_SYM_DIFF";
  case 34: return "R_MN10300_ALIGN";
default: return 
# 65 "./../include/elf/mn10300.h" 3 4
((void *)0)
# 65 "./../include/elf/mn10300.h"
; } }
# 131 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/moxie.h" 1
# 26 "./../include/elf/moxie.h"
static const char *elf_moxie_reloc_type (unsigned long rtype); static const char * elf_moxie_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MOXIE_NONE";
  case 1: return "R_MOXIE_32";
  case 2: return "R_MOXIE_PCREL10";
default: return 
# 30 "./../include/elf/moxie.h" 3 4
((void *)0)
# 30 "./../include/elf/moxie.h"
; } }
# 132 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/mt.h" 1
# 26 "./../include/elf/mt.h"
static const char *elf_mt_reloc_type (unsigned long rtype); static const char * elf_mt_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MT_NONE";
  case 1: return "R_MT_16";
  case 2: return "R_MT_32";
  case 3: return "R_MT_32_PCREL";
  case 4: return "R_MT_PC16";
  case 5: return "R_MT_HI16";
  case 6: return "R_MT_LO16";
default: return 
# 34 "./../include/elf/mt.h" 3 4
((void *)0)
# 34 "./../include/elf/mt.h"
; } }
# 133 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/msp430.h" 1
# 63 "./../include/elf/msp430.h"
static const char *elf_msp430_reloc_type (unsigned long rtype); static const char * elf_msp430_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_MSP430_NONE";
     case 1: return "R_MSP430_32";
     case 2: return "R_MSP430_10_PCREL";
     case 3: return "R_MSP430_16";
     case 4: return "R_MSP430_16_PCREL";
     case 5: return "R_MSP430_16_BYTE";
     case 6: return "R_MSP430_16_PCREL_BYTE";
     case 7: return "R_MSP430_2X_PCREL";
     case 8: return "R_MSP430_RL_PCREL";
     case 9: return "R_MSP430_8";
     case 10: return "R_MSP430_SYM_DIFF";
default: return 
# 75 "./../include/elf/msp430.h" 3 4
((void *)0)
# 75 "./../include/elf/msp430.h"
; } }

static const char *elf_msp430x_reloc_type (unsigned long rtype); static const char * elf_msp430x_reloc_type (unsigned long rtype) { switch (rtype) {
     case 1: return "R_MSP430_ABS32";
     case 2: return "R_MSP430_ABS16";
     case 3: return "R_MSP430_ABS8";
     case 4: return "R_MSP430_PCR16";
     case 5: return "R_MSP430X_PCR20_EXT_SRC";
     case 6: return "R_MSP430X_PCR20_EXT_DST";
     case 7: return "R_MSP430X_PCR20_EXT_ODST";
     case 8: return "R_MSP430X_ABS20_EXT_SRC";
     case 9: return "R_MSP430X_ABS20_EXT_DST";
     case 10: return "R_MSP430X_ABS20_EXT_ODST";
     case 11: return "R_MSP430X_ABS20_ADR_SRC";
     case 12: return "R_MSP430X_ABS20_ADR_DST";
     case 13: return "R_MSP430X_PCR16";
     case 14: return "R_MSP430X_PCR20_CALL";
     case 15: return "R_MSP430X_ABS16";
     case 16: return "R_MSP430_ABS_HI16";
     case 17: return "R_MSP430_PREL31";
     case 18: return "R_MSP430_EHTYPE";
     case 19: return "R_MSP430X_10_PCREL";
     case 20: return "R_MSP430X_2X_PCREL";
     case 21: return "R_MSP430X_SYM_DIFF";
default: return 
# 99 "./../include/elf/msp430.h" 3 4
((void *)0)
# 99 "./../include/elf/msp430.h"
; } }
# 134 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/nds32.h" 1
# 28 "./../include/elf/nds32.h"
static const char *elf_nds32_reloc_type (unsigned long rtype); static const char * elf_nds32_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_NDS32_NONE";

  case 1: return "R_NDS32_16";
  case 2: return "R_NDS32_32";
  case 3: return "R_NDS32_20";
  case 4: return "R_NDS32_9_PCREL";
  case 5: return "R_NDS32_15_PCREL";
  case 6: return "R_NDS32_17_PCREL";
  case 7: return "R_NDS32_25_PCREL";
  case 8: return "R_NDS32_HI20";
  case 9: return "R_NDS32_LO12S3";
  case 10: return "R_NDS32_LO12S2";
  case 11: return "R_NDS32_LO12S1";
  case 12: return "R_NDS32_LO12S0";
  case 13: return "R_NDS32_SDA15S3";
  case 14: return "R_NDS32_SDA15S2";
  case 15: return "R_NDS32_SDA15S1";
  case 16: return "R_NDS32_SDA15S0";
  case 17: return "R_NDS32_GNU_VTINHERIT";
  case 18: return "R_NDS32_GNU_VTENTRY";


  case 19: return "R_NDS32_16_RELA";
  case 20: return "R_NDS32_32_RELA";
  case 21: return "R_NDS32_20_RELA";
  case 22: return "R_NDS32_9_PCREL_RELA";
  case 23: return "R_NDS32_15_PCREL_RELA";
  case 24: return "R_NDS32_17_PCREL_RELA";
  case 25: return "R_NDS32_25_PCREL_RELA";
  case 26: return "R_NDS32_HI20_RELA";
  case 27: return "R_NDS32_LO12S3_RELA";
  case 28: return "R_NDS32_LO12S2_RELA";
  case 29: return "R_NDS32_LO12S1_RELA";
  case 30: return "R_NDS32_LO12S0_RELA";
  case 31: return "R_NDS32_SDA15S3_RELA";
  case 32: return "R_NDS32_SDA15S2_RELA";
  case 33: return "R_NDS32_SDA15S1_RELA";
  case 34: return "R_NDS32_SDA15S0_RELA";
  case 35: return "R_NDS32_RELA_GNU_VTINHERIT";
  case 36: return "R_NDS32_RELA_GNU_VTENTRY";

  case 37: return "R_NDS32_GOT20";
  case 38: return "R_NDS32_25_PLTREL";
  case 39: return "R_NDS32_COPY";
  case 40: return "R_NDS32_GLOB_DAT";
  case 41: return "R_NDS32_JMP_SLOT";
  case 42: return "R_NDS32_RELATIVE";
  case 43: return "R_NDS32_GOTOFF";
  case 44: return "R_NDS32_GOTPC20";
  case 45: return "R_NDS32_GOT_HI20";
  case 46: return "R_NDS32_GOT_LO12";
  case 47: return "R_NDS32_GOTPC_HI20";
  case 48: return "R_NDS32_GOTPC_LO12";
  case 49: return "R_NDS32_GOTOFF_HI20";
  case 50: return "R_NDS32_GOTOFF_LO12";
  case 51: return "R_NDS32_INSN16";
  case 52: return "R_NDS32_LABEL";
  case 53: return "R_NDS32_LONGCALL1";
  case 54: return "R_NDS32_LONGCALL2";
  case 55: return "R_NDS32_LONGCALL3";
  case 56: return "R_NDS32_LONGJUMP1";
  case 57: return "R_NDS32_LONGJUMP2";
  case 58: return "R_NDS32_LONGJUMP3";
  case 59: return "R_NDS32_LOADSTORE";
  case 60: return "R_NDS32_9_FIXED_RELA";
  case 61: return "R_NDS32_15_FIXED_RELA";
  case 62: return "R_NDS32_17_FIXED_RELA";
  case 63: return "R_NDS32_25_FIXED_RELA";
  case 64: return "R_NDS32_PLTREL_HI20";
  case 65: return "R_NDS32_PLTREL_LO12";
  case 66: return "R_NDS32_PLT_GOTREL_HI20";
  case 67: return "R_NDS32_PLT_GOTREL_LO12";
  case 68: return "R_NDS32_SDA12S2_DP_RELA";
  case 69: return "R_NDS32_SDA12S2_SP_RELA";
  case 70: return "R_NDS32_LO12S2_DP_RELA";
  case 71: return "R_NDS32_LO12S2_SP_RELA";
  case 72: return "R_NDS32_LO12S0_ORI_RELA";
  case 73: return "R_NDS32_SDA16S3_RELA";
  case 74: return "R_NDS32_SDA17S2_RELA";
  case 75: return "R_NDS32_SDA18S1_RELA";
  case 76: return "R_NDS32_SDA19S0_RELA";
  case 77: return "R_NDS32_DWARF2_OP1_RELA";
  case 78: return "R_NDS32_DWARF2_OP2_RELA";
  case 79: return "R_NDS32_DWARF2_LEB_RELA";
  case 80: return "R_NDS32_UPDATE_TA_RELA";
  case 81: return "R_NDS32_9_PLTREL";
  case 82: return "R_NDS32_PLT_GOTREL_LO20";
  case 83: return "R_NDS32_PLT_GOTREL_LO15";
  case 84: return "R_NDS32_PLT_GOTREL_LO19";
  case 85: return "R_NDS32_GOT_LO15";
  case 86: return "R_NDS32_GOT_LO19";
  case 87: return "R_NDS32_GOTOFF_LO15";
  case 88: return "R_NDS32_GOTOFF_LO19";
  case 89: return "R_NDS32_GOT15S2_RELA";
  case 90: return "R_NDS32_GOT17S2_RELA";
  case 91: return "R_NDS32_5_RELA";
  case 92: return "R_NDS32_10_UPCREL_RELA";
  case 93: return "R_NDS32_SDA_FP7U2_RELA";
  case 94: return "R_NDS32_WORD_9_PCREL_RELA";
  case 95: return "R_NDS32_25_ABS_RELA";
  case 96: return "R_NDS32_17IFC_PCREL_RELA";
  case 97: return "R_NDS32_10IFCU_PCREL_RELA";
  case 98: return "R_NDS32_TLS_LE_HI20";
  case 99: return "R_NDS32_TLS_LE_LO12";
  case 100: return "R_NDS32_TLS_IE_HI20";
  case 101: return "R_NDS32_TLS_IE_LO12S2";
  case 102: return "R_NDS32_TLS_TPOFF";
  case 103: return "R_NDS32_TLS_LE_20";
  case 104: return "R_NDS32_TLS_LE_15S0";
  case 105: return "R_NDS32_TLS_LE_15S1";
  case 106: return "R_NDS32_TLS_LE_15S2";
  case 107: return "R_NDS32_LONGCALL4";
  case 108: return "R_NDS32_LONGCALL5";
  case 109: return "R_NDS32_LONGCALL6";
  case 110: return "R_NDS32_LONGJUMP4";
  case 111: return "R_NDS32_LONGJUMP5";
  case 112: return "R_NDS32_LONGJUMP6";
  case 113: return "R_NDS32_LONGJUMP7";

  case 192: return "R_NDS32_RELAX_ENTRY";
  case 193: return "R_NDS32_GOT_SUFF";
  case 194: return "R_NDS32_GOTOFF_SUFF";
  case 195: return "R_NDS32_PLT_GOT_SUFF";
  case 196: return "R_NDS32_MULCALL_SUFF";
  case 197: return "R_NDS32_PTR";
  case 198: return "R_NDS32_PTR_COUNT";
  case 199: return "R_NDS32_PTR_RESOLVED";
  case 200: return "R_NDS32_PLTBLOCK";
  case 201: return "R_NDS32_RELAX_REGION_BEGIN";
  case 202: return "R_NDS32_RELAX_REGION_END";
  case 203: return "R_NDS32_MINUEND";
  case 204: return "R_NDS32_SUBTRAHEND";
  case 205: return "R_NDS32_DIFF8";
  case 206: return "R_NDS32_DIFF16";
  case 207: return "R_NDS32_DIFF32";
  case 208: return "R_NDS32_DIFF_ULEB128";
  case 209: return "R_NDS32_DATA";
  case 210: return "R_NDS32_TRAN";
  case 211: return "R_NDS32_TLS_LE_ADD";
  case 212: return "R_NDS32_TLS_LE_LS";
  case 213: return "R_NDS32_EMPTY";

default: return 
# 171 "./../include/elf/nds32.h" 3 4
((void *)0)
# 171 "./../include/elf/nds32.h"
; } }
# 135 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/nios2.h" 1
# 36 "./../include/elf/nios2.h"
static const char *elf_nios2_reloc_type (unsigned long rtype); static const char * elf_nios2_reloc_type (unsigned long rtype) { switch (rtype) {


  case 0: return "R_NIOS2_NONE";
  case 1: return "R_NIOS2_S16";
  case 2: return "R_NIOS2_U16";
  case 3: return "R_NIOS2_PCREL16";
  case 4: return "R_NIOS2_CALL26";
  case 5: return "R_NIOS2_IMM5";
  case 6: return "R_NIOS2_CACHE_OPX";
  case 7: return "R_NIOS2_IMM6";
  case 8: return "R_NIOS2_IMM8";
  case 9: return "R_NIOS2_HI16";
  case 10: return "R_NIOS2_LO16";
  case 11: return "R_NIOS2_HIADJ16";
  case 12: return "R_NIOS2_BFD_RELOC_32";
  case 13: return "R_NIOS2_BFD_RELOC_16";
  case 14: return "R_NIOS2_BFD_RELOC_8";
  case 15: return "R_NIOS2_GPREL";
  case 16: return "R_NIOS2_GNU_VTINHERIT";
  case 17: return "R_NIOS2_GNU_VTENTRY";
  case 18: return "R_NIOS2_UJMP";
  case 19: return "R_NIOS2_CJMP";
  case 20: return "R_NIOS2_CALLR";
  case 21: return "R_NIOS2_ALIGN";
  case 22: return "R_NIOS2_GOT16";
  case 23: return "R_NIOS2_CALL16";
  case 24: return "R_NIOS2_GOTOFF_LO";
  case 25: return "R_NIOS2_GOTOFF_HA";
  case 26: return "R_NIOS2_PCREL_LO";
  case 27: return "R_NIOS2_PCREL_HA";
  case 28: return "R_NIOS2_TLS_GD16";
  case 29: return "R_NIOS2_TLS_LDM16";
  case 30: return "R_NIOS2_TLS_LDO16";
  case 31: return "R_NIOS2_TLS_IE16";
  case 32: return "R_NIOS2_TLS_LE16";
  case 33: return "R_NIOS2_TLS_DTPMOD";
  case 34: return "R_NIOS2_TLS_DTPREL";
  case 35: return "R_NIOS2_TLS_TPREL";
  case 36: return "R_NIOS2_COPY";
  case 37: return "R_NIOS2_GLOB_DAT";
  case 38: return "R_NIOS2_JUMP_SLOT";
  case 39: return "R_NIOS2_RELATIVE";
  case 40: return "R_NIOS2_GOTOFF";
  case 41: return "R_NIOS2_CALL26_NOAT";
  case 42: return "R_NIOS2_GOT_LO";
  case 43: return "R_NIOS2_GOT_HA";
  case 44: return "R_NIOS2_CALL_LO";
  case 45: return "R_NIOS2_CALL_HA";


  case 64: return "R_NIOS2_R2_S12";
  case 65: return "R_NIOS2_R2_I10_1_PCREL";
  case 66: return "R_NIOS2_R2_T1I7_1_PCREL";
  case 67: return "R_NIOS2_R2_T1I7_2";
  case 68: return "R_NIOS2_R2_T2I4";
  case 69: return "R_NIOS2_R2_T2I4_1";
  case 70: return "R_NIOS2_R2_T2I4_2";
  case 71: return "R_NIOS2_R2_X1I7_2";
  case 72: return "R_NIOS2_R2_X2L5";
  case 73: return "R_NIOS2_R2_F1I5_2";
  case 74: return "R_NIOS2_R2_L5I4X1";
  case 75: return "R_NIOS2_R2_T1X1I6";
  case 76: return "R_NIOS2_R2_T1X1I6_2";


  case 77: return "R_NIOS2_ILLEGAL";
default: return 
# 103 "./../include/elf/nios2.h" 3 4
((void *)0)
# 103 "./../include/elf/nios2.h"
; } }
# 136 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/or1k.h" 1
# 25 "./../include/elf/or1k.h"
static const char *elf_or1k_reloc_type (unsigned long rtype); static const char * elf_or1k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_OR1K_NONE";
  case 1: return "R_OR1K_32";
  case 2: return "R_OR1K_16";
  case 3: return "R_OR1K_8";
  case 4: return "R_OR1K_LO_16_IN_INSN";
  case 5: return "R_OR1K_HI_16_IN_INSN";
  case 6: return "R_OR1K_INSN_REL_26";
  case 7: return "R_OR1K_GNU_VTENTRY";
  case 8: return "R_OR1K_GNU_VTINHERIT";
  case 9: return "R_OR1K_32_PCREL";
  case 10: return "R_OR1K_16_PCREL";
  case 11: return "R_OR1K_8_PCREL";
  case 12: return "R_OR1K_GOTPC_HI16";
  case 13: return "R_OR1K_GOTPC_LO16";
  case 14: return "R_OR1K_GOT16";
  case 15: return "R_OR1K_PLT26";
  case 16: return "R_OR1K_GOTOFF_HI16";
  case 17: return "R_OR1K_GOTOFF_LO16";
  case 18: return "R_OR1K_COPY";
  case 19: return "R_OR1K_GLOB_DAT";
  case 20: return "R_OR1K_JMP_SLOT";
  case 21: return "R_OR1K_RELATIVE";
  case 22: return "R_OR1K_TLS_GD_HI16";
  case 23: return "R_OR1K_TLS_GD_LO16";
  case 24: return "R_OR1K_TLS_LDM_HI16";
  case 25: return "R_OR1K_TLS_LDM_LO16";
  case 26: return "R_OR1K_TLS_LDO_HI16";
  case 27: return "R_OR1K_TLS_LDO_LO16";
  case 28: return "R_OR1K_TLS_IE_HI16";
  case 29: return "R_OR1K_TLS_IE_LO16";
  case 30: return "R_OR1K_TLS_LE_HI16";
  case 31: return "R_OR1K_TLS_LE_LO16";
  case 32: return "R_OR1K_TLS_TPOFF";
  case 33: return "R_OR1K_TLS_DTPOFF";
  case 34: return "R_OR1K_TLS_DTPMOD";
default: return 
# 61 "./../include/elf/or1k.h" 3 4
((void *)0)
# 61 "./../include/elf/or1k.h"
; } }
# 137 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/pj.h" 1
# 27 "./../include/elf/pj.h"
static const char *elf_pj_reloc_type (unsigned long rtype); static const char * elf_pj_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PJ_NONE";
  case 1: return "R_PJ_DATA_DIR32";
  case 2: return "R_PJ_CODE_REL32";
  case 3: return "R_PJ_CODE_REL16";
  case 6: return "R_PJ_CODE_DIR32";
  case 7: return "R_PJ_CODE_DIR16";
  case 13: return "R_PJ_CODE_LO16";
  case 14: return "R_PJ_CODE_HI16";
  case 15: return "R_PJ_GNU_VTINHERIT";
  case 16: return "R_PJ_GNU_VTENTRY";
default: return 
# 38 "./../include/elf/pj.h" 3 4
((void *)0)
# 38 "./../include/elf/pj.h"
; } }
# 138 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/ppc.h" 1
# 35 "./../include/elf/ppc.h"
static const char *elf_ppc_reloc_type (unsigned long rtype); static const char * elf_ppc_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PPC_NONE";
  case 1: return "R_PPC_ADDR32";
  case 2: return "R_PPC_ADDR24";
  case 3: return "R_PPC_ADDR16";
  case 4: return "R_PPC_ADDR16_LO";
  case 5: return "R_PPC_ADDR16_HI";
  case 6: return "R_PPC_ADDR16_HA";
  case 7: return "R_PPC_ADDR14";
  case 8: return "R_PPC_ADDR14_BRTAKEN";
  case 9: return "R_PPC_ADDR14_BRNTAKEN";
  case 10: return "R_PPC_REL24";
  case 11: return "R_PPC_REL14";
  case 12: return "R_PPC_REL14_BRTAKEN";
  case 13: return "R_PPC_REL14_BRNTAKEN";
  case 14: return "R_PPC_GOT16";
  case 15: return "R_PPC_GOT16_LO";
  case 16: return "R_PPC_GOT16_HI";
  case 17: return "R_PPC_GOT16_HA";
  case 18: return "R_PPC_PLTREL24";
  case 19: return "R_PPC_COPY";
  case 20: return "R_PPC_GLOB_DAT";
  case 21: return "R_PPC_JMP_SLOT";
  case 22: return "R_PPC_RELATIVE";
  case 23: return "R_PPC_LOCAL24PC";
  case 24: return "R_PPC_UADDR32";
  case 25: return "R_PPC_UADDR16";
  case 26: return "R_PPC_REL32";
  case 27: return "R_PPC_PLT32";
  case 28: return "R_PPC_PLTREL32";
  case 29: return "R_PPC_PLT16_LO";
  case 30: return "R_PPC_PLT16_HI";
  case 31: return "R_PPC_PLT16_HA";
  case 32: return "R_PPC_SDAREL16";
  case 33: return "R_PPC_SECTOFF";
  case 34: return "R_PPC_SECTOFF_LO";
  case 35: return "R_PPC_SECTOFF_HI";
  case 36: return "R_PPC_SECTOFF_HA";
  case 37: return "R_PPC_ADDR30";
# 87 "./../include/elf/ppc.h"
  case 67: return "R_PPC_TLS";
  case 68: return "R_PPC_DTPMOD32";
  case 69: return "R_PPC_TPREL16";
  case 70: return "R_PPC_TPREL16_LO";
  case 71: return "R_PPC_TPREL16_HI";
  case 72: return "R_PPC_TPREL16_HA";
  case 73: return "R_PPC_TPREL32";
  case 74: return "R_PPC_DTPREL16";
  case 75: return "R_PPC_DTPREL16_LO";
  case 76: return "R_PPC_DTPREL16_HI";
  case 77: return "R_PPC_DTPREL16_HA";
  case 78: return "R_PPC_DTPREL32";
  case 79: return "R_PPC_GOT_TLSGD16";
  case 80: return "R_PPC_GOT_TLSGD16_LO";
  case 81: return "R_PPC_GOT_TLSGD16_HI";
  case 82: return "R_PPC_GOT_TLSGD16_HA";
  case 83: return "R_PPC_GOT_TLSLD16";
  case 84: return "R_PPC_GOT_TLSLD16_LO";
  case 85: return "R_PPC_GOT_TLSLD16_HI";
  case 86: return "R_PPC_GOT_TLSLD16_HA";
  case 87: return "R_PPC_GOT_TPREL16";
  case 88: return "R_PPC_GOT_TPREL16_LO";
  case 89: return "R_PPC_GOT_TPREL16_HI";
  case 90: return "R_PPC_GOT_TPREL16_HA";
  case 91: return "R_PPC_GOT_DTPREL16";
  case 92: return "R_PPC_GOT_DTPREL16_LO";
  case 93: return "R_PPC_GOT_DTPREL16_HI";
  case 94: return "R_PPC_GOT_DTPREL16_HA";
  case 95: return "R_PPC_TLSGD";
  case 96: return "R_PPC_TLSLD";



  case 101: return "R_PPC_EMB_NADDR32";
  case 102: return "R_PPC_EMB_NADDR16";
  case 103: return "R_PPC_EMB_NADDR16_LO";
  case 104: return "R_PPC_EMB_NADDR16_HI";
  case 105: return "R_PPC_EMB_NADDR16_HA";
  case 106: return "R_PPC_EMB_SDAI16";
  case 107: return "R_PPC_EMB_SDA2I16";
  case 108: return "R_PPC_EMB_SDA2REL";
  case 109: return "R_PPC_EMB_SDA21";
  case 110: return "R_PPC_EMB_MRKREF";
  case 111: return "R_PPC_EMB_RELSEC16";
  case 112: return "R_PPC_EMB_RELST_LO";
  case 113: return "R_PPC_EMB_RELST_HI";
  case 114: return "R_PPC_EMB_RELST_HA";
  case 115: return "R_PPC_EMB_BIT_FLD";
  case 116: return "R_PPC_EMB_RELSDA";


  case 216: return "R_PPC_VLE_REL8";
  case 217: return "R_PPC_VLE_REL15";
  case 218: return "R_PPC_VLE_REL24";
  case 219: return "R_PPC_VLE_LO16A";
  case 220: return "R_PPC_VLE_LO16D";
  case 221: return "R_PPC_VLE_HI16A";
  case 222: return "R_PPC_VLE_HI16D";
  case 223: return "R_PPC_VLE_HA16A";
  case 224: return "R_PPC_VLE_HA16D";
  case 225: return "R_PPC_VLE_SDA21";
  case 226: return "R_PPC_VLE_SDA21_LO";
  case 227: return "R_PPC_VLE_SDAREL_LO16A";
  case 228: return "R_PPC_VLE_SDAREL_LO16D";
  case 229: return "R_PPC_VLE_SDAREL_HI16A";
  case 230: return "R_PPC_VLE_SDAREL_HI16D";
  case 231: return "R_PPC_VLE_SDAREL_HA16A";
  case 232: return "R_PPC_VLE_SDAREL_HA16D";


  case 246: return "R_PPC_REL16DX_HA";


  case 248: return "R_PPC_IRELATIVE";


  case 249: return "R_PPC_REL16";
  case 250: return "R_PPC_REL16_LO";
  case 251: return "R_PPC_REL16_HI";
  case 252: return "R_PPC_REL16_HA";


  case 253: return "R_PPC_GNU_VTINHERIT";
  case 254: return "R_PPC_GNU_VTENTRY";



  case 255: return "R_PPC_TOC16";

default: return 
# 176 "./../include/elf/ppc.h" 3 4
((void *)0)
# 176 "./../include/elf/ppc.h"
; } }
# 223 "./../include/elf/ppc.h"
enum
{
# 237 "./../include/elf/ppc.h"
  Tag_GNU_Power_ABI_FP = 4,




  Tag_GNU_Power_ABI_Vector = 8,




  Tag_GNU_Power_ABI_Struct_Return = 12
};
# 139 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/ppc64.h" 1
# 27 "./../include/elf/ppc64.h"
static const char *elf_ppc64_reloc_type (unsigned long rtype); static const char * elf_ppc64_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PPC64_NONE";
  case 1: return "R_PPC64_ADDR32";
  case 2: return "R_PPC64_ADDR24";
  case 3: return "R_PPC64_ADDR16";
  case 4: return "R_PPC64_ADDR16_LO";
  case 5: return "R_PPC64_ADDR16_HI";
  case 6: return "R_PPC64_ADDR16_HA";
  case 7: return "R_PPC64_ADDR14";
  case 8: return "R_PPC64_ADDR14_BRTAKEN";
  case 9: return "R_PPC64_ADDR14_BRNTAKEN";
  case 10: return "R_PPC64_REL24";
  case 11: return "R_PPC64_REL14";
  case 12: return "R_PPC64_REL14_BRTAKEN";
  case 13: return "R_PPC64_REL14_BRNTAKEN";
  case 14: return "R_PPC64_GOT16";
  case 15: return "R_PPC64_GOT16_LO";
  case 16: return "R_PPC64_GOT16_HI";
  case 17: return "R_PPC64_GOT16_HA";

  case 19: return "R_PPC64_COPY";
  case 20: return "R_PPC64_GLOB_DAT";
  case 21: return "R_PPC64_JMP_SLOT";
  case 22: return "R_PPC64_RELATIVE";

  case 24: return "R_PPC64_UADDR32";
  case 25: return "R_PPC64_UADDR16";
  case 26: return "R_PPC64_REL32";
  case 27: return "R_PPC64_PLT32";
  case 28: return "R_PPC64_PLTREL32";
  case 29: return "R_PPC64_PLT16_LO";
  case 30: return "R_PPC64_PLT16_HI";
  case 31: return "R_PPC64_PLT16_HA";

  case 33: return "R_PPC64_SECTOFF";
  case 34: return "R_PPC64_SECTOFF_LO";
  case 35: return "R_PPC64_SECTOFF_HI";
  case 36: return "R_PPC64_SECTOFF_HA";
  case 37: return "R_PPC64_REL30";
  case 38: return "R_PPC64_ADDR64";
  case 39: return "R_PPC64_ADDR16_HIGHER";
  case 40: return "R_PPC64_ADDR16_HIGHERA";
  case 41: return "R_PPC64_ADDR16_HIGHEST";
  case 42: return "R_PPC64_ADDR16_HIGHESTA";
  case 43: return "R_PPC64_UADDR64";
  case 44: return "R_PPC64_REL64";
  case 45: return "R_PPC64_PLT64";
  case 46: return "R_PPC64_PLTREL64";
  case 47: return "R_PPC64_TOC16";
  case 48: return "R_PPC64_TOC16_LO";
  case 49: return "R_PPC64_TOC16_HI";
  case 50: return "R_PPC64_TOC16_HA";
  case 51: return "R_PPC64_TOC";
  case 52: return "R_PPC64_PLTGOT16";
  case 53: return "R_PPC64_PLTGOT16_LO";
  case 54: return "R_PPC64_PLTGOT16_HI";
  case 55: return "R_PPC64_PLTGOT16_HA";



  case 56: return "R_PPC64_ADDR16_DS";
  case 57: return "R_PPC64_ADDR16_LO_DS";
  case 58: return "R_PPC64_GOT16_DS";
  case 59: return "R_PPC64_GOT16_LO_DS";
  case 60: return "R_PPC64_PLT16_LO_DS";
  case 61: return "R_PPC64_SECTOFF_DS";
  case 62: return "R_PPC64_SECTOFF_LO_DS";
  case 63: return "R_PPC64_TOC16_DS";
  case 64: return "R_PPC64_TOC16_LO_DS";
  case 65: return "R_PPC64_PLTGOT16_DS";
  case 66: return "R_PPC64_PLTGOT16_LO_DS";


  case 67: return "R_PPC64_TLS";
  case 68: return "R_PPC64_DTPMOD64";
  case 69: return "R_PPC64_TPREL16";
  case 70: return "R_PPC64_TPREL16_LO";
  case 71: return "R_PPC64_TPREL16_HI";
  case 72: return "R_PPC64_TPREL16_HA";
  case 73: return "R_PPC64_TPREL64";
  case 74: return "R_PPC64_DTPREL16";
  case 75: return "R_PPC64_DTPREL16_LO";
  case 76: return "R_PPC64_DTPREL16_HI";
  case 77: return "R_PPC64_DTPREL16_HA";
  case 78: return "R_PPC64_DTPREL64";
  case 79: return "R_PPC64_GOT_TLSGD16";
  case 80: return "R_PPC64_GOT_TLSGD16_LO";
  case 81: return "R_PPC64_GOT_TLSGD16_HI";
  case 82: return "R_PPC64_GOT_TLSGD16_HA";
  case 83: return "R_PPC64_GOT_TLSLD16";
  case 84: return "R_PPC64_GOT_TLSLD16_LO";
  case 85: return "R_PPC64_GOT_TLSLD16_HI";
  case 86: return "R_PPC64_GOT_TLSLD16_HA";
  case 87: return "R_PPC64_GOT_TPREL16_DS";
  case 88: return "R_PPC64_GOT_TPREL16_LO_DS";
  case 89: return "R_PPC64_GOT_TPREL16_HI";
  case 90: return "R_PPC64_GOT_TPREL16_HA";
  case 91: return "R_PPC64_GOT_DTPREL16_DS";
  case 92: return "R_PPC64_GOT_DTPREL16_LO_DS";
  case 93: return "R_PPC64_GOT_DTPREL16_HI";
  case 94: return "R_PPC64_GOT_DTPREL16_HA";
  case 95: return "R_PPC64_TPREL16_DS";
  case 96: return "R_PPC64_TPREL16_LO_DS";
  case 97: return "R_PPC64_TPREL16_HIGHER";
  case 98: return "R_PPC64_TPREL16_HIGHERA";
  case 99: return "R_PPC64_TPREL16_HIGHEST";
  case 100: return "R_PPC64_TPREL16_HIGHESTA";
  case 101: return "R_PPC64_DTPREL16_DS";
  case 102: return "R_PPC64_DTPREL16_LO_DS";
  case 103: return "R_PPC64_DTPREL16_HIGHER";
  case 104: return "R_PPC64_DTPREL16_HIGHERA";
  case 105: return "R_PPC64_DTPREL16_HIGHEST";
  case 106: return "R_PPC64_DTPREL16_HIGHESTA";
  case 107: return "R_PPC64_TLSGD";
  case 108: return "R_PPC64_TLSLD";
  case 109: return "R_PPC64_TOCSAVE";


  case 110: return "R_PPC64_ADDR16_HIGH";
  case 111: return "R_PPC64_ADDR16_HIGHA";
  case 112: return "R_PPC64_TPREL16_HIGH";
  case 113: return "R_PPC64_TPREL16_HIGHA";
  case 114: return "R_PPC64_DTPREL16_HIGH";
  case 115: return "R_PPC64_DTPREL16_HIGHA";


  case 116: return "R_PPC64_REL24_NOTOC";
  case 117: return "R_PPC64_ADDR64_LOCAL";
  case 118: return "R_PPC64_ENTRY";
# 167 "./../include/elf/ppc64.h"
  case 246: return "R_PPC64_REL16DX_HA";


  case 247: return "R_PPC64_JMP_IREL";
  case 248: return "R_PPC64_IRELATIVE";


  case 249: return "R_PPC64_REL16";
  case 250: return "R_PPC64_REL16_LO";
  case 251: return "R_PPC64_REL16_HI";
  case 252: return "R_PPC64_REL16_HA";


  case 253: return "R_PPC64_GNU_VTINHERIT";
  case 254: return "R_PPC64_GNU_VTENTRY";

default: return 
# 183 "./../include/elf/ppc64.h" 3 4
((void *)0)
# 183 "./../include/elf/ppc64.h"
; } }
# 216 "./../include/elf/ppc64.h"
static inline unsigned int
ppc64_decode_local_entry(unsigned int other)
{
  return ((1 << other) >> 2) << 2;
}


static inline unsigned int
ppc64_encode_local_entry(unsigned int val)
{
  return (val >= 4 * 4
   ? (val >= 8 * 4
      ? (val >= 16 * 4 ? 6 : 5)
      : 4)
   : (val >= 2 * 4
      ? 3
      : (val >= 1 * 4 ? 2 : 0)));
}
# 140 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/pru.h" 1
# 31 "./../include/elf/pru.h"
static const char *elf_pru_reloc_type (unsigned long rtype); static const char * elf_pru_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PRU_NONE";
  case 5: return "R_PRU_16_PMEM";
  case 6: return "R_PRU_U16_PMEMIMM";
  case 8: return "R_PRU_BFD_RELOC_16";
  case 9: return "R_PRU_U16";
  case 10: return "R_PRU_32_PMEM";
  case 11: return "R_PRU_BFD_RELOC_32";
  case 14: return "R_PRU_S10_PCREL";
  case 15: return "R_PRU_U8_PCREL";
  case 18: return "R_PRU_LDI32";


  case 64: return "R_PRU_GNU_BFD_RELOC_8";
  case 65: return "R_PRU_GNU_DIFF8";
  case 66: return "R_PRU_GNU_DIFF16";
  case 67: return "R_PRU_GNU_DIFF32";
  case 68: return "R_PRU_GNU_DIFF16_PMEM";
  case 69: return "R_PRU_GNU_DIFF32_PMEM";
  case 70: return "R_PRU_ILLEGAL";
default: return 
# 51 "./../include/elf/pru.h" 3 4
((void *)0)
# 51 "./../include/elf/pru.h"
; } }
# 141 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/rl78.h" 1
# 31 "./../include/elf/rl78.h"
static const char *elf_rl78_reloc_type (unsigned long rtype); static const char * elf_rl78_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0x00: return "R_RL78_NONE";

  case 0x01: return "R_RL78_DIR32";
  case 0x02: return "R_RL78_DIR24S";
  case 0x03: return "R_RL78_DIR16";
  case 0x04: return "R_RL78_DIR16U";
  case 0x05: return "R_RL78_DIR16S";
  case 0x06: return "R_RL78_DIR8";
  case 0x07: return "R_RL78_DIR8U";
  case 0x08: return "R_RL78_DIR8S";


  case 0x09: return "R_RL78_DIR24S_PCREL";
  case 0x0a: return "R_RL78_DIR16S_PCREL";
  case 0x0b: return "R_RL78_DIR8S_PCREL";


  case 0x0c: return "R_RL78_DIR16UL";
  case 0x0d: return "R_RL78_DIR16UW";
  case 0x0e: return "R_RL78_DIR8UL";
  case 0x0f: return "R_RL78_DIR8UW";
  case 0x10: return "R_RL78_DIR32_REV";
  case 0x11: return "R_RL78_DIR16_REV";
  case 0x12: return "R_RL78_DIR3U_PCREL";


  case 0x2d: return "R_RL78_RH_RELAX";
  case 0x2e: return "R_RL78_RH_SFR";
  case 0x2f: return "R_RL78_RH_SADDR";


  case 0x41: return "R_RL78_ABS32";
  case 0x42: return "R_RL78_ABS24S";
  case 0x43: return "R_RL78_ABS16";
  case 0x44: return "R_RL78_ABS16U";
  case 0x45: return "R_RL78_ABS16S";
  case 0x46: return "R_RL78_ABS8";
  case 0x47: return "R_RL78_ABS8U";
  case 0x48: return "R_RL78_ABS8S";
  case 0x49: return "R_RL78_ABS24S_PCREL";
  case 0x4a: return "R_RL78_ABS16S_PCREL";
  case 0x4b: return "R_RL78_ABS8S_PCREL";
  case 0x4c: return "R_RL78_ABS16UL";
  case 0x4d: return "R_RL78_ABS16UW";
  case 0x4e: return "R_RL78_ABS8UL";
  case 0x4f: return "R_RL78_ABS8UW";
  case 0x50: return "R_RL78_ABS32_REV";
  case 0x51: return "R_RL78_ABS16_REV";

  case 0x80: return "R_RL78_SYM";
  case 0x81: return "R_RL78_OPneg";
  case 0x82: return "R_RL78_OPadd";
  case 0x83: return "R_RL78_OPsub";
  case 0x84: return "R_RL78_OPmul";
  case 0x85: return "R_RL78_OPdiv";
  case 0x86: return "R_RL78_OPshla";
  case 0x87: return "R_RL78_OPshra";
  case 0x88: return "R_RL78_OPsctsize";
  case 0x8d: return "R_RL78_OPscttop";
  case 0x90: return "R_RL78_OPand";
  case 0x91: return "R_RL78_OPor";
  case 0x92: return "R_RL78_OPxor";
  case 0x93: return "R_RL78_OPnot";
  case 0x94: return "R_RL78_OPmod";
  case 0x95: return "R_RL78_OPromtop";
  case 0x96: return "R_RL78_OPramtop";

default: return 
# 100 "./../include/elf/rl78.h" 3 4
((void *)0)
# 100 "./../include/elf/rl78.h"
; } }
# 142 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/rx.h" 1
# 31 "./../include/elf/rx.h"
static const char *elf_rx_reloc_type (unsigned long rtype); static const char * elf_rx_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0x00: return "R_RX_NONE";

  case 0x01: return "R_RX_DIR32";
  case 0x02: return "R_RX_DIR24S";
  case 0x03: return "R_RX_DIR16";
  case 0x04: return "R_RX_DIR16U";
  case 0x05: return "R_RX_DIR16S";
  case 0x06: return "R_RX_DIR8";
  case 0x07: return "R_RX_DIR8U";
  case 0x08: return "R_RX_DIR8S";


  case 0x09: return "R_RX_DIR24S_PCREL";
  case 0x0a: return "R_RX_DIR16S_PCREL";
  case 0x0b: return "R_RX_DIR8S_PCREL";


  case 0x0c: return "R_RX_DIR16UL";
  case 0x0d: return "R_RX_DIR16UW";
  case 0x0e: return "R_RX_DIR8UL";
  case 0x0f: return "R_RX_DIR8UW";
  case 0x10: return "R_RX_DIR32_REV";
  case 0x11: return "R_RX_DIR16_REV";
  case 0x12: return "R_RX_DIR3U_PCREL";


  case 0x20: return "R_RX_RH_3_PCREL";
  case 0x21: return "R_RX_RH_16_OP";
  case 0x22: return "R_RX_RH_24_OP";
  case 0x23: return "R_RX_RH_32_OP";
  case 0x24: return "R_RX_RH_24_UNS";
  case 0x25: return "R_RX_RH_8_NEG";
  case 0x26: return "R_RX_RH_16_NEG";
  case 0x27: return "R_RX_RH_24_NEG";
  case 0x28: return "R_RX_RH_32_NEG";
  case 0x29: return "R_RX_RH_DIFF";
  case 0x2a: return "R_RX_RH_GPRELB";
  case 0x2b: return "R_RX_RH_GPRELW";
  case 0x2c: return "R_RX_RH_GPRELL";
  case 0x2d: return "R_RX_RH_RELAX";


  case 0x41: return "R_RX_ABS32";
  case 0x42: return "R_RX_ABS24S";
  case 0x43: return "R_RX_ABS16";
  case 0x44: return "R_RX_ABS16U";
  case 0x45: return "R_RX_ABS16S";
  case 0x46: return "R_RX_ABS8";
  case 0x47: return "R_RX_ABS8U";
  case 0x48: return "R_RX_ABS8S";
  case 0x49: return "R_RX_ABS24S_PCREL";
  case 0x4a: return "R_RX_ABS16S_PCREL";
  case 0x4b: return "R_RX_ABS8S_PCREL";
  case 0x4c: return "R_RX_ABS16UL";
  case 0x4d: return "R_RX_ABS16UW";
  case 0x4e: return "R_RX_ABS8UL";
  case 0x4f: return "R_RX_ABS8UW";
  case 0x50: return "R_RX_ABS32_REV";
  case 0x51: return "R_RX_ABS16_REV";

  case 0x80: return "R_RX_SYM";
  case 0x81: return "R_RX_OPneg";
  case 0x82: return "R_RX_OPadd";
  case 0x83: return "R_RX_OPsub";
  case 0x84: return "R_RX_OPmul";
  case 0x85: return "R_RX_OPdiv";
  case 0x86: return "R_RX_OPshla";
  case 0x87: return "R_RX_OPshra";
  case 0x88: return "R_RX_OPsctsize";
  case 0x8d: return "R_RX_OPscttop";
  case 0x90: return "R_RX_OPand";
  case 0x91: return "R_RX_OPor";
  case 0x92: return "R_RX_OPxor";
  case 0x93: return "R_RX_OPnot";
  case 0x94: return "R_RX_OPmod";
  case 0x95: return "R_RX_OPromtop";
  case 0x96: return "R_RX_OPramtop";

default: return 
# 111 "./../include/elf/rx.h" 3 4
((void *)0)
# 111 "./../include/elf/rx.h"
; } }
# 143 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/s390.h" 1
# 45 "./../include/elf/s390.h"
static const char *elf_s390_reloc_type (unsigned long rtype); static const char * elf_s390_reloc_type (unsigned long rtype) { switch (rtype) {
    case 0: return "R_390_NONE";
    case 1: return "R_390_8";
    case 2: return "R_390_12";
    case 3: return "R_390_16";
    case 4: return "R_390_32";
    case 5: return "R_390_PC32";
    case 6: return "R_390_GOT12";
    case 7: return "R_390_GOT32";
    case 8: return "R_390_PLT32";
    case 9: return "R_390_COPY";
    case 10: return "R_390_GLOB_DAT";
    case 11: return "R_390_JMP_SLOT";
    case 12: return "R_390_RELATIVE";
    case 13: return "R_390_GOTOFF32";
    case 14: return "R_390_GOTPC";
    case 15: return "R_390_GOT16";
    case 16: return "R_390_PC16";
    case 62: return "R_390_PC12DBL";
    case 63: return "R_390_PLT12DBL";
    case 17: return "R_390_PC16DBL";
    case 18: return "R_390_PLT16DBL";
    case 64: return "R_390_PC24DBL";
    case 65: return "R_390_PLT24DBL";
    case 19: return "R_390_PC32DBL";
    case 20: return "R_390_PLT32DBL";
    case 21: return "R_390_GOTPCDBL";
    case 22: return "R_390_64";
    case 23: return "R_390_PC64";
    case 24: return "R_390_GOT64";
    case 25: return "R_390_PLT64";
    case 26: return "R_390_GOTENT";
    case 27: return "R_390_GOTOFF16";
    case 28: return "R_390_GOTOFF64";
    case 29: return "R_390_GOTPLT12";
    case 30: return "R_390_GOTPLT16";
    case 31: return "R_390_GOTPLT32";
    case 32: return "R_390_GOTPLT64";
    case 33: return "R_390_GOTPLTENT";
    case 34: return "R_390_PLTOFF16";
    case 35: return "R_390_PLTOFF32";
    case 36: return "R_390_PLTOFF64";
    case 37: return "R_390_TLS_LOAD";
    case 38: return "R_390_TLS_GDCALL";

    case 39: return "R_390_TLS_LDCALL";

    case 40: return "R_390_TLS_GD32";

    case 41: return "R_390_TLS_GD64";

    case 42: return "R_390_TLS_GOTIE12";

    case 43: return "R_390_TLS_GOTIE32";

    case 44: return "R_390_TLS_GOTIE64";

    case 45: return "R_390_TLS_LDM32";

    case 46: return "R_390_TLS_LDM64";

    case 47: return "R_390_TLS_IE32";

    case 48: return "R_390_TLS_IE64";

    case 49: return "R_390_TLS_IEENT";

    case 50: return "R_390_TLS_LE32";

    case 51: return "R_390_TLS_LE64";

    case 52: return "R_390_TLS_LDO32";

    case 53: return "R_390_TLS_LDO64";

    case 54: return "R_390_TLS_DTPMOD";
    case 55: return "R_390_TLS_DTPOFF";
    case 56: return "R_390_TLS_TPOFF";

    case 57: return "R_390_20";
    case 58: return "R_390_GOT20";
    case 59: return "R_390_GOTPLT20";
    case 60: return "R_390_TLS_GOTIE20";

    case 61: return "R_390_IRELATIVE";

    case 250: return "R_390_GNU_VTINHERIT";
    case 251: return "R_390_GNU_VTENTRY";
default: return 
# 133 "./../include/elf/s390.h" 3 4
((void *)0)
# 133 "./../include/elf/s390.h"
; } }


enum
{







  Tag_GNU_S390_ABI_Vector = 8,
};
# 144 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/score.h" 1
# 106 "./../include/elf/score.h"
static const char *elf_score_reloc_type (unsigned long rtype); static const char * elf_score_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SCORE_NONE";
  case 1: return "R_SCORE_HI16";
  case 2: return "R_SCORE_LO16";
  case 3: return "R_SCORE_BCMP";
  case 4: return "R_SCORE_24";
  case 5: return "R_SCORE_PC19";
  case 6: return "R_SCORE16_11";
  case 7: return "R_SCORE16_PC8";
  case 8: return "R_SCORE_ABS32";
  case 9: return "R_SCORE_ABS16";
  case 10: return "R_SCORE_DUMMY2";
  case 11: return "R_SCORE_GP15";
  case 12: return "R_SCORE_GNU_VTINHERIT";
  case 13: return "R_SCORE_GNU_VTENTRY";
  case 14: return "R_SCORE_GOT15";
  case 15: return "R_SCORE_GOT_LO16";
  case 16: return "R_SCORE_CALL15";
  case 17: return "R_SCORE_GPREL32";
  case 18: return "R_SCORE_REL32";
  case 19: return "R_SCORE_DUMMY_HI16";
  case 20: return "R_SCORE_IMM30";
  case 21: return "R_SCORE_IMM32";
default: return 
# 129 "./../include/elf/score.h" 3 4
((void *)0)
# 129 "./../include/elf/score.h"
; } }
# 145 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/sh.h" 1
# 87 "./../include/elf/sh.h"
int sh_find_elf_flags (unsigned int arch_set);


int sh_elf_get_flags_from_mach (unsigned long mach);
# 124 "./../include/elf/sh.h"
static const char *elf_sh_reloc_type (unsigned long rtype); static const char * elf_sh_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SH_NONE";
  case 1: return "R_SH_DIR32";
  case 2: return "R_SH_REL32";
  case 3: return "R_SH_DIR8WPN";
  case 4: return "R_SH_IND12W";
  case 5: return "R_SH_DIR8WPL";
  case 6: return "R_SH_DIR8WPZ";
  case 7: return "R_SH_DIR8BP";
  case 8: return "R_SH_DIR8W";
  case 9: return "R_SH_DIR8L";

  case 10: return "R_SH_LOOP_START";
  case 11: return "R_SH_LOOP_END";

 
 

  case 22: return "R_SH_GNU_VTINHERIT";
  case 23: return "R_SH_GNU_VTENTRY";
  case 24: return "R_SH_SWITCH8";
  case 25: return "R_SH_SWITCH16";
  case 26: return "R_SH_SWITCH32";
  case 27: return "R_SH_USES";
  case 28: return "R_SH_COUNT";
  case 29: return "R_SH_ALIGN";
  case 30: return "R_SH_CODE";
  case 31: return "R_SH_DATA";
  case 32: return "R_SH_LABEL";

  case 33: return "R_SH_DIR16";
  case 34: return "R_SH_DIR8";
  case 35: return "R_SH_DIR8UL";
  case 36: return "R_SH_DIR8UW";
  case 37: return "R_SH_DIR8U";
  case 38: return "R_SH_DIR8SW";
  case 39: return "R_SH_DIR8S";
  case 40: return "R_SH_DIR4UL";
  case 41: return "R_SH_DIR4UW";
  case 42: return "R_SH_DIR4U";
  case 43: return "R_SH_PSHA";
  case 44: return "R_SH_PSHL";
  case 45: return "R_SH_DIR5U";
  case 46: return "R_SH_DIR6U";
  case 47: return "R_SH_DIR6S";
  case 48: return "R_SH_DIR10S";
  case 49: return "R_SH_DIR10SW";
  case 50: return "R_SH_DIR10SL";
  case 51: return "R_SH_DIR10SQ";
 
 
  case 53: return "R_SH_DIR16S";
 
 
  case 144: return "R_SH_TLS_GD_32";
  case 145: return "R_SH_TLS_LD_32";
  case 146: return "R_SH_TLS_LDO_32";
  case 147: return "R_SH_TLS_IE_32";
  case 148: return "R_SH_TLS_LE_32";
  case 149: return "R_SH_TLS_DTPMOD32";
  case 150: return "R_SH_TLS_DTPOFF32";
  case 151: return "R_SH_TLS_TPOFF32";
 
 
  case 160: return "R_SH_GOT32";
  case 161: return "R_SH_PLT32";
  case 162: return "R_SH_COPY";
  case 163: return "R_SH_GLOB_DAT";
  case 164: return "R_SH_JMP_SLOT";
  case 165: return "R_SH_RELATIVE";
  case 166: return "R_SH_GOTOFF";
  case 167: return "R_SH_GOTPC";
  case 168: return "R_SH_GOTPLT32";
  case 169: return "R_SH_GOT_LOW16";
  case 170: return "R_SH_GOT_MEDLOW16";
  case 171: return "R_SH_GOT_MEDHI16";
  case 172: return "R_SH_GOT_HI16";
  case 173: return "R_SH_GOTPLT_LOW16";
  case 174: return "R_SH_GOTPLT_MEDLOW16";
  case 175: return "R_SH_GOTPLT_MEDHI16";
  case 176: return "R_SH_GOTPLT_HI16";
  case 177: return "R_SH_PLT_LOW16";
  case 178: return "R_SH_PLT_MEDLOW16";
  case 179: return "R_SH_PLT_MEDHI16";
  case 180: return "R_SH_PLT_HI16";
  case 181: return "R_SH_GOTOFF_LOW16";
  case 182: return "R_SH_GOTOFF_MEDLOW16";
  case 183: return "R_SH_GOTOFF_MEDHI16";
  case 184: return "R_SH_GOTOFF_HI16";
  case 185: return "R_SH_GOTPC_LOW16";
  case 186: return "R_SH_GOTPC_MEDLOW16";
  case 187: return "R_SH_GOTPC_MEDHI16";
  case 188: return "R_SH_GOTPC_HI16";
  case 189: return "R_SH_GOT10BY4";
  case 190: return "R_SH_GOTPLT10BY4";
  case 191: return "R_SH_GOT10BY8";
  case 192: return "R_SH_GOTPLT10BY8";
  case 193: return "R_SH_COPY64";
  case 194: return "R_SH_GLOB_DAT64";
  case 195: return "R_SH_JMP_SLOT64";
  case 196: return "R_SH_RELATIVE64";
 
 
  case 201: return "R_SH_GOT20";
  case 202: return "R_SH_GOTOFF20";
  case 203: return "R_SH_GOTFUNCDESC";
  case 204: return "R_SH_GOTFUNCDESC20";
  case 205: return "R_SH_GOTOFFFUNCDESC";
  case 206: return "R_SH_GOTOFFFUNCDESC20";
  case 207: return "R_SH_FUNCDESC";
  case 208: return "R_SH_FUNCDESC_VALUE";
 
 
  case 242: return "R_SH_SHMEDIA_CODE";
  case 243: return "R_SH_PT_16";
  case 244: return "R_SH_IMMS16";
  case 245: return "R_SH_IMMU16";
  case 246: return "R_SH_IMM_LOW16";
  case 247: return "R_SH_IMM_LOW16_PCREL";
  case 248: return "R_SH_IMM_MEDLOW16";
  case 249: return "R_SH_IMM_MEDLOW16_PCREL";
  case 250: return "R_SH_IMM_MEDHI16";
  case 251: return "R_SH_IMM_MEDHI16_PCREL";
  case 252: return "R_SH_IMM_HI16";
  case 253: return "R_SH_IMM_HI16_PCREL";
  case 254: return "R_SH_64";
  case 255: return "R_SH_64_PCREL";
default: return 
# 251 "./../include/elf/sh.h" 3 4
((void *)0)
# 251 "./../include/elf/sh.h"
; } }
# 146 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/sparc.h" 1
# 62 "./../include/elf/sparc.h"
static const char *elf_sparc_reloc_type (unsigned long rtype); static const char * elf_sparc_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SPARC_NONE";
  case 1: return "R_SPARC_8";
  case 2: return "R_SPARC_16";
  case 3: return "R_SPARC_32";
  case 4: return "R_SPARC_DISP8";
  case 5: return "R_SPARC_DISP16";
  case 6: return "R_SPARC_DISP32";
  case 7: return "R_SPARC_WDISP30";
  case 8: return "R_SPARC_WDISP22";
  case 9: return "R_SPARC_HI22";
  case 10: return "R_SPARC_22";
  case 11: return "R_SPARC_13";
  case 12: return "R_SPARC_LO10";
  case 13: return "R_SPARC_GOT10";
  case 14: return "R_SPARC_GOT13";
  case 15: return "R_SPARC_GOT22";
  case 16: return "R_SPARC_PC10";
  case 17: return "R_SPARC_PC22";
  case 18: return "R_SPARC_WPLT30";
  case 19: return "R_SPARC_COPY";
  case 20: return "R_SPARC_GLOB_DAT";
  case 21: return "R_SPARC_JMP_SLOT";
  case 22: return "R_SPARC_RELATIVE";
  case 23: return "R_SPARC_UA32";






  case 24: return "R_SPARC_PLT32";
  case 25: return "R_SPARC_HIPLT22";
  case 26: return "R_SPARC_LOPLT10";
  case 27: return "R_SPARC_PCPLT32";
  case 28: return "R_SPARC_PCPLT22";
  case 29: return "R_SPARC_PCPLT10";



  case 30: return "R_SPARC_10";
  case 31: return "R_SPARC_11";
  case 32: return "R_SPARC_64";
  case 33: return "R_SPARC_OLO10";
  case 34: return "R_SPARC_HH22";
  case 35: return "R_SPARC_HM10";
  case 36: return "R_SPARC_LM22";
  case 37: return "R_SPARC_PC_HH22";
  case 38: return "R_SPARC_PC_HM10";
  case 39: return "R_SPARC_PC_LM22";
  case 40: return "R_SPARC_WDISP16";
  case 41: return "R_SPARC_WDISP19";
  case 42: return "R_SPARC_UNUSED_42";
  case 43: return "R_SPARC_7";
  case 44: return "R_SPARC_5";
  case 45: return "R_SPARC_6";
  case 46: return "R_SPARC_DISP64";
  case 47: return "R_SPARC_PLT64";
  case 48: return "R_SPARC_HIX22";
  case 49: return "R_SPARC_LOX10";
  case 50: return "R_SPARC_H44";
  case 51: return "R_SPARC_M44";
  case 52: return "R_SPARC_L44";
  case 53: return "R_SPARC_REGISTER";
  case 54: return "R_SPARC_UA64";
  case 55: return "R_SPARC_UA16";

  case 56: return "R_SPARC_TLS_GD_HI22";
  case 57: return "R_SPARC_TLS_GD_LO10";
  case 58: return "R_SPARC_TLS_GD_ADD";
  case 59: return "R_SPARC_TLS_GD_CALL";
  case 60: return "R_SPARC_TLS_LDM_HI22";
  case 61: return "R_SPARC_TLS_LDM_LO10";
  case 62: return "R_SPARC_TLS_LDM_ADD";
  case 63: return "R_SPARC_TLS_LDM_CALL";
  case 64: return "R_SPARC_TLS_LDO_HIX22";
  case 65: return "R_SPARC_TLS_LDO_LOX10";
  case 66: return "R_SPARC_TLS_LDO_ADD";
  case 67: return "R_SPARC_TLS_IE_HI22";
  case 68: return "R_SPARC_TLS_IE_LO10";
  case 69: return "R_SPARC_TLS_IE_LD";
  case 70: return "R_SPARC_TLS_IE_LDX";
  case 71: return "R_SPARC_TLS_IE_ADD";
  case 72: return "R_SPARC_TLS_LE_HIX22";
  case 73: return "R_SPARC_TLS_LE_LOX10";
  case 74: return "R_SPARC_TLS_DTPMOD32";
  case 75: return "R_SPARC_TLS_DTPMOD64";
  case 76: return "R_SPARC_TLS_DTPOFF32";
  case 77: return "R_SPARC_TLS_DTPOFF64";
  case 78: return "R_SPARC_TLS_TPOFF32";
  case 79: return "R_SPARC_TLS_TPOFF64";

  case 80: return "R_SPARC_GOTDATA_HIX22";
  case 81: return "R_SPARC_GOTDATA_LOX10";
  case 82: return "R_SPARC_GOTDATA_OP_HIX22";
  case 83: return "R_SPARC_GOTDATA_OP_LOX10";
  case 84: return "R_SPARC_GOTDATA_OP";

  case 85: return "R_SPARC_H34";
  case 86: return "R_SPARC_SIZE32";
  case 87: return "R_SPARC_SIZE64";
  case 88: return "R_SPARC_WDISP10";

 

  case 248: return "R_SPARC_JMP_IREL";
  case 249: return "R_SPARC_IRELATIVE";
  case 250: return "R_SPARC_GNU_VTINHERIT";
  case 251: return "R_SPARC_GNU_VTENTRY";
  case 252: return "R_SPARC_REV32";

default: return 
# 173 "./../include/elf/sparc.h" 3 4
((void *)0)
# 173 "./../include/elf/sparc.h"
; } }
# 189 "./../include/elf/sparc.h"
enum
{

  Tag_GNU_Sparc_HWCAPS = 4,
  Tag_GNU_Sparc_HWCAPS2 = 8
};
# 147 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/spu.h" 1
# 27 "./../include/elf/spu.h"
static const char *elf_spu_reloc_type (unsigned long rtype); static const char * elf_spu_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_SPU_NONE";
     case 1: return "R_SPU_ADDR10";
     case 2: return "R_SPU_ADDR16";
     case 3: return "R_SPU_ADDR16_HI";
     case 4: return "R_SPU_ADDR16_LO";
     case 5: return "R_SPU_ADDR18";
     case 6: return "R_SPU_ADDR32";
     case 7: return "R_SPU_REL16";
     case 8: return "R_SPU_ADDR7";
     case 9: return "R_SPU_REL9";
     case 10: return "R_SPU_REL9I";
     case 11: return "R_SPU_ADDR10I";
     case 12: return "R_SPU_ADDR16I";
     case 13: return "R_SPU_REL32";
     case 14: return "R_SPU_ADDR16X";
     case 15: return "R_SPU_PPU32";
     case 16: return "R_SPU_PPU64";
     case 17: return "R_SPU_ADD_PIC";
default: return 
# 46 "./../include/elf/spu.h" 3 4
((void *)0)
# 46 "./../include/elf/spu.h"
; } }
# 148 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/tic6x.h" 1
# 27 "./../include/elf/tic6x.h"
static const char *elf_tic6x_reloc_type (unsigned long rtype); static const char * elf_tic6x_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_C6000_NONE";
  case 1: return "R_C6000_ABS32";
  case 2: return "R_C6000_ABS16";
  case 3: return "R_C6000_ABS8";
  case 4: return "R_C6000_PCR_S21";
  case 5: return "R_C6000_PCR_S12";
  case 6: return "R_C6000_PCR_S10";
  case 7: return "R_C6000_PCR_S7";
  case 8: return "R_C6000_ABS_S16";
  case 9: return "R_C6000_ABS_L16";
  case 10: return "R_C6000_ABS_H16";
  case 11: return "R_C6000_SBR_U15_B";
  case 12: return "R_C6000_SBR_U15_H";
  case 13: return "R_C6000_SBR_U15_W";
  case 14: return "R_C6000_SBR_S16";
  case 15: return "R_C6000_SBR_L16_B";
  case 16: return "R_C6000_SBR_L16_H";
  case 17: return "R_C6000_SBR_L16_W";
  case 18: return "R_C6000_SBR_H16_B";
  case 19: return "R_C6000_SBR_H16_H";
  case 20: return "R_C6000_SBR_H16_W";
  case 21: return "R_C6000_SBR_GOT_U15_W";
  case 22: return "R_C6000_SBR_GOT_L16_W";
  case 23: return "R_C6000_SBR_GOT_H16_W";
  case 24: return "R_C6000_DSBT_INDEX";
  case 25: return "R_C6000_PREL31";
  case 26: return "R_C6000_COPY";
  case 27: return "R_C6000_JUMP_SLOT";
  case 28: return "R_C6000_EHTYPE";
  case 29: return "R_C6000_PCR_H16";
  case 30: return "R_C6000_PCR_L16";
  case 253: return "R_C6000_ALIGN";
  case 254: return "R_C6000_FPHEAD";
  case 255: return "R_C6000_NOCMP";
default: return 
# 62 "./../include/elf/tic6x.h" 3 4
((void *)0)
# 62 "./../include/elf/tic6x.h"
; } }
# 139 "./../include/elf/tic6x.h"
enum
  {

# 1 "./../include/elf/tic6x-attrs.h" 1
# 24 "./../include/elf/tic6x-attrs.h"
Tag_ISA = 4,
Tag_ABI_wchar_t = 6,
Tag_ABI_stack_align_needed = 8,
Tag_ABI_stack_align_preserved = 10,
Tag_ABI_DSBT = 12,
Tag_ABI_PID = 14,
Tag_ABI_PIC = 16,
Tag_ABI_array_object_alignment = 18,
Tag_ABI_array_object_align_expected = 20,
Tag_ABI_compatibility = 32,
Tag_ABI_conformance = 67,
# 143 "./../include/elf/tic6x.h" 2

    Tag_C6XABI_last
  };



enum
  {
    C6XABI_Tag_ISA_none = 0,
    C6XABI_Tag_ISA_C62X = 1,
    C6XABI_Tag_ISA_C67X = 3,
    C6XABI_Tag_ISA_C67XP = 4,
    C6XABI_Tag_ISA_C64X = 6,
    C6XABI_Tag_ISA_C64XP = 7,
    C6XABI_Tag_ISA_C674X = 8
  };
# 149 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/tilegx.h" 1
# 27 "./../include/elf/tilegx.h"
static const char *elf_tilegx_reloc_type (unsigned long rtype); static const char * elf_tilegx_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_TILEGX_NONE";


  case 1: return "R_TILEGX_64";
  case 2: return "R_TILEGX_32";
  case 3: return "R_TILEGX_16";
  case 4: return "R_TILEGX_8";
  case 5: return "R_TILEGX_64_PCREL";
  case 6: return "R_TILEGX_32_PCREL";
  case 7: return "R_TILEGX_16_PCREL";
  case 8: return "R_TILEGX_8_PCREL";



  case 9: return "R_TILEGX_HW0";
  case 10: return "R_TILEGX_HW1";
  case 11: return "R_TILEGX_HW2";
  case 12: return "R_TILEGX_HW3";
  case 13: return "R_TILEGX_HW0_LAST";
  case 14: return "R_TILEGX_HW1_LAST";
  case 15: return "R_TILEGX_HW2_LAST";

  case 16: return "R_TILEGX_COPY";
  case 17: return "R_TILEGX_GLOB_DAT";
  case 18: return "R_TILEGX_JMP_SLOT";
  case 19: return "R_TILEGX_RELATIVE";


  case 20: return "R_TILEGX_BROFF_X1";
  case 21: return "R_TILEGX_JUMPOFF_X1";
  case 22: return "R_TILEGX_JUMPOFF_X1_PLT";


  case 23: return "R_TILEGX_IMM8_X0";
  case 24: return "R_TILEGX_IMM8_Y0";
  case 25: return "R_TILEGX_IMM8_X1";
  case 26: return "R_TILEGX_IMM8_Y1";
  case 27: return "R_TILEGX_DEST_IMM8_X1";
  case 28: return "R_TILEGX_MT_IMM14_X1";
  case 29: return "R_TILEGX_MF_IMM14_X1";
  case 30: return "R_TILEGX_MMSTART_X0";
  case 31: return "R_TILEGX_MMEND_X0";
  case 32: return "R_TILEGX_SHAMT_X0";
  case 33: return "R_TILEGX_SHAMT_X1";
  case 34: return "R_TILEGX_SHAMT_Y0";
  case 35: return "R_TILEGX_SHAMT_Y1";

  case 36: return "R_TILEGX_IMM16_X0_HW0";
  case 37: return "R_TILEGX_IMM16_X1_HW0";
  case 38: return "R_TILEGX_IMM16_X0_HW1";
  case 39: return "R_TILEGX_IMM16_X1_HW1";
  case 40: return "R_TILEGX_IMM16_X0_HW2";
  case 41: return "R_TILEGX_IMM16_X1_HW2";
  case 42: return "R_TILEGX_IMM16_X0_HW3";
  case 43: return "R_TILEGX_IMM16_X1_HW3";
  case 44: return "R_TILEGX_IMM16_X0_HW0_LAST";
  case 45: return "R_TILEGX_IMM16_X1_HW0_LAST";
  case 46: return "R_TILEGX_IMM16_X0_HW1_LAST";
  case 47: return "R_TILEGX_IMM16_X1_HW1_LAST";
  case 48: return "R_TILEGX_IMM16_X0_HW2_LAST";
  case 49: return "R_TILEGX_IMM16_X1_HW2_LAST";

  case 50: return "R_TILEGX_IMM16_X0_HW0_PCREL";
  case 51: return "R_TILEGX_IMM16_X1_HW0_PCREL";
  case 52: return "R_TILEGX_IMM16_X0_HW1_PCREL";
  case 53: return "R_TILEGX_IMM16_X1_HW1_PCREL";
  case 54: return "R_TILEGX_IMM16_X0_HW2_PCREL";
  case 55: return "R_TILEGX_IMM16_X1_HW2_PCREL";
  case 56: return "R_TILEGX_IMM16_X0_HW3_PCREL";
  case 57: return "R_TILEGX_IMM16_X1_HW3_PCREL";
  case 58: return "R_TILEGX_IMM16_X0_HW0_LAST_PCREL";
  case 59: return "R_TILEGX_IMM16_X1_HW0_LAST_PCREL";
  case 60: return "R_TILEGX_IMM16_X0_HW1_LAST_PCREL";
  case 61: return "R_TILEGX_IMM16_X1_HW1_LAST_PCREL";
  case 62: return "R_TILEGX_IMM16_X0_HW2_LAST_PCREL";
  case 63: return "R_TILEGX_IMM16_X1_HW2_LAST_PCREL";

  case 64: return "R_TILEGX_IMM16_X0_HW0_GOT";
  case 65: return "R_TILEGX_IMM16_X1_HW0_GOT";

  case 66: return "R_TILEGX_IMM16_X0_HW0_PLT_PCREL";
  case 67: return "R_TILEGX_IMM16_X1_HW0_PLT_PCREL";
  case 68: return "R_TILEGX_IMM16_X0_HW1_PLT_PCREL";
  case 69: return "R_TILEGX_IMM16_X1_HW1_PLT_PCREL";
  case 70: return "R_TILEGX_IMM16_X0_HW2_PLT_PCREL";
  case 71: return "R_TILEGX_IMM16_X1_HW2_PLT_PCREL";

  case 72: return "R_TILEGX_IMM16_X0_HW0_LAST_GOT";
  case 73: return "R_TILEGX_IMM16_X1_HW0_LAST_GOT";
  case 74: return "R_TILEGX_IMM16_X0_HW1_LAST_GOT";
  case 75: return "R_TILEGX_IMM16_X1_HW1_LAST_GOT";

  case 76: return "R_TILEGX_IMM16_X0_HW3_PLT_PCREL";
  case 77: return "R_TILEGX_IMM16_X1_HW3_PLT_PCREL";

  case 78: return "R_TILEGX_IMM16_X0_HW0_TLS_GD";
  case 79: return "R_TILEGX_IMM16_X1_HW0_TLS_GD";
  case 80: return "R_TILEGX_IMM16_X0_HW0_TLS_LE";
  case 81: return "R_TILEGX_IMM16_X1_HW0_TLS_LE";
  case 82: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE";
  case 83: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE";
  case 84: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE";
  case 85: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE";
  case 86: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD";
  case 87: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD";
  case 88: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD";
  case 89: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD";


  case 92: return "R_TILEGX_IMM16_X0_HW0_TLS_IE";
  case 93: return "R_TILEGX_IMM16_X1_HW0_TLS_IE";

  case 94: return "R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL";
  case 95: return "R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL";
  case 96: return "R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL";
  case 97: return "R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL";
  case 98: return "R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL";
  case 99: return "R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL";

  case 100: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE";
  case 101: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE";
  case 102: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE";
  case 103: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE";


  case 106: return "R_TILEGX_TLS_DTPMOD64";
  case 107: return "R_TILEGX_TLS_DTPOFF64";
  case 108: return "R_TILEGX_TLS_TPOFF64";
  case 109: return "R_TILEGX_TLS_DTPMOD32";
  case 110: return "R_TILEGX_TLS_DTPOFF32";
  case 111: return "R_TILEGX_TLS_TPOFF32";

  case 112: return "R_TILEGX_TLS_GD_CALL";
  case 113: return "R_TILEGX_IMM8_X0_TLS_GD_ADD";
  case 114: return "R_TILEGX_IMM8_X1_TLS_GD_ADD";
  case 115: return "R_TILEGX_IMM8_Y0_TLS_GD_ADD";
  case 116: return "R_TILEGX_IMM8_Y1_TLS_GD_ADD";
  case 117: return "R_TILEGX_TLS_IE_LOAD";
  case 118: return "R_TILEGX_IMM8_X0_TLS_ADD";
  case 119: return "R_TILEGX_IMM8_X1_TLS_ADD";
  case 120: return "R_TILEGX_IMM8_Y0_TLS_ADD";
  case 121: return "R_TILEGX_IMM8_Y1_TLS_ADD";


  case 128: return "R_TILEGX_GNU_VTINHERIT";
  case 129: return "R_TILEGX_GNU_VTENTRY";
default: return 
# 174 "./../include/elf/tilegx.h" 3 4
((void *)0)
# 174 "./../include/elf/tilegx.h"
; } }
# 150 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/tilepro.h" 1
# 27 "./../include/elf/tilepro.h"
static const char *elf_tilepro_reloc_type (unsigned long rtype); static const char * elf_tilepro_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_TILEPRO_NONE";


  case 1: return "R_TILEPRO_32";
  case 2: return "R_TILEPRO_16";
  case 3: return "R_TILEPRO_8";
  case 4: return "R_TILEPRO_32_PCREL";
  case 5: return "R_TILEPRO_16_PCREL";
  case 6: return "R_TILEPRO_8_PCREL";

  case 7: return "R_TILEPRO_LO16";
  case 8: return "R_TILEPRO_HI16";
  case 9: return "R_TILEPRO_HA16";

  case 10: return "R_TILEPRO_COPY";
  case 11: return "R_TILEPRO_GLOB_DAT";
  case 12: return "R_TILEPRO_JMP_SLOT";
  case 13: return "R_TILEPRO_RELATIVE";


  case 14: return "R_TILEPRO_BROFF_X1";
  case 15: return "R_TILEPRO_JOFFLONG_X1";
  case 16: return "R_TILEPRO_JOFFLONG_X1_PLT";


  case 17: return "R_TILEPRO_IMM8_X0";
  case 18: return "R_TILEPRO_IMM8_Y0";
  case 19: return "R_TILEPRO_IMM8_X1";
  case 20: return "R_TILEPRO_IMM8_Y1";
  case 21: return "R_TILEPRO_MT_IMM15_X1";
  case 22: return "R_TILEPRO_MF_IMM15_X1";

  case 23: return "R_TILEPRO_IMM16_X0";
  case 24: return "R_TILEPRO_IMM16_X1";
  case 25: return "R_TILEPRO_IMM16_X0_LO";
  case 26: return "R_TILEPRO_IMM16_X1_LO";
  case 27: return "R_TILEPRO_IMM16_X0_HI";
  case 28: return "R_TILEPRO_IMM16_X1_HI";
  case 29: return "R_TILEPRO_IMM16_X0_HA";
  case 30: return "R_TILEPRO_IMM16_X1_HA";

  case 31: return "R_TILEPRO_IMM16_X0_PCREL";
  case 32: return "R_TILEPRO_IMM16_X1_PCREL";
  case 33: return "R_TILEPRO_IMM16_X0_LO_PCREL";
  case 34: return "R_TILEPRO_IMM16_X1_LO_PCREL";
  case 35: return "R_TILEPRO_IMM16_X0_HI_PCREL";
  case 36: return "R_TILEPRO_IMM16_X1_HI_PCREL";
  case 37: return "R_TILEPRO_IMM16_X0_HA_PCREL";
  case 38: return "R_TILEPRO_IMM16_X1_HA_PCREL";

  case 39: return "R_TILEPRO_IMM16_X0_GOT";
  case 40: return "R_TILEPRO_IMM16_X1_GOT";
  case 41: return "R_TILEPRO_IMM16_X0_GOT_LO";
  case 42: return "R_TILEPRO_IMM16_X1_GOT_LO";
  case 43: return "R_TILEPRO_IMM16_X0_GOT_HI";
  case 44: return "R_TILEPRO_IMM16_X1_GOT_HI";
  case 45: return "R_TILEPRO_IMM16_X0_GOT_HA";
  case 46: return "R_TILEPRO_IMM16_X1_GOT_HA";

  case 47: return "R_TILEPRO_MMSTART_X0";
  case 48: return "R_TILEPRO_MMEND_X0";
  case 49: return "R_TILEPRO_MMSTART_X1";
  case 50: return "R_TILEPRO_MMEND_X1";

  case 51: return "R_TILEPRO_SHAMT_X0";
  case 52: return "R_TILEPRO_SHAMT_X1";
  case 53: return "R_TILEPRO_SHAMT_Y0";
  case 54: return "R_TILEPRO_SHAMT_Y1";

  case 55: return "R_TILEPRO_DEST_IMM8_X1";



  case 60: return "R_TILEPRO_TLS_GD_CALL";
  case 61: return "R_TILEPRO_IMM8_X0_TLS_GD_ADD";
  case 62: return "R_TILEPRO_IMM8_X1_TLS_GD_ADD";
  case 63: return "R_TILEPRO_IMM8_Y0_TLS_GD_ADD";
  case 64: return "R_TILEPRO_IMM8_Y1_TLS_GD_ADD";
  case 65: return "R_TILEPRO_TLS_IE_LOAD";

  case 66: return "R_TILEPRO_IMM16_X0_TLS_GD";
  case 67: return "R_TILEPRO_IMM16_X1_TLS_GD";
  case 68: return "R_TILEPRO_IMM16_X0_TLS_GD_LO";
  case 69: return "R_TILEPRO_IMM16_X1_TLS_GD_LO";
  case 70: return "R_TILEPRO_IMM16_X0_TLS_GD_HI";
  case 71: return "R_TILEPRO_IMM16_X1_TLS_GD_HI";
  case 72: return "R_TILEPRO_IMM16_X0_TLS_GD_HA";
  case 73: return "R_TILEPRO_IMM16_X1_TLS_GD_HA";

  case 74: return "R_TILEPRO_IMM16_X0_TLS_IE";
  case 75: return "R_TILEPRO_IMM16_X1_TLS_IE";
  case 76: return "R_TILEPRO_IMM16_X0_TLS_IE_LO";
  case 77: return "R_TILEPRO_IMM16_X1_TLS_IE_LO";
  case 78: return "R_TILEPRO_IMM16_X0_TLS_IE_HI";
  case 79: return "R_TILEPRO_IMM16_X1_TLS_IE_HI";
  case 80: return "R_TILEPRO_IMM16_X0_TLS_IE_HA";
  case 81: return "R_TILEPRO_IMM16_X1_TLS_IE_HA";

  case 82: return "R_TILEPRO_TLS_DTPMOD32";
  case 83: return "R_TILEPRO_TLS_DTPOFF32";
  case 84: return "R_TILEPRO_TLS_TPOFF32";

  case 85: return "R_TILEPRO_IMM16_X0_TLS_LE";
  case 86: return "R_TILEPRO_IMM16_X1_TLS_LE";
  case 87: return "R_TILEPRO_IMM16_X0_TLS_LE_LO";
  case 88: return "R_TILEPRO_IMM16_X1_TLS_LE_LO";
  case 89: return "R_TILEPRO_IMM16_X0_TLS_LE_HI";
  case 90: return "R_TILEPRO_IMM16_X1_TLS_LE_HI";
  case 91: return "R_TILEPRO_IMM16_X0_TLS_LE_HA";
  case 92: return "R_TILEPRO_IMM16_X1_TLS_LE_HA";


  case 128: return "R_TILEPRO_GNU_VTINHERIT";
  case 129: return "R_TILEPRO_GNU_VTENTRY";
default: return 
# 142 "./../include/elf/tilepro.h" 3 4
((void *)0)
# 142 "./../include/elf/tilepro.h"
; } }
# 151 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/v850.h" 1
# 60 "./../include/elf/v850.h"
static const char *v850_reloc_type (unsigned long rtype); static const char * v850_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_V850_NONE";
     case 1: return "R_V850_9_PCREL";
     case 2: return "R_V850_22_PCREL";
     case 3: return "R_V850_HI16_S";
     case 4: return "R_V850_HI16";
     case 5: return "R_V850_LO16";
     case 6: return "R_V850_ABS32";
     case 7: return "R_V850_16";
     case 8: return "R_V850_8";
     case 9: return "R_V850_SDA_16_16_OFFSET";
     case 10: return "R_V850_SDA_15_16_OFFSET";
     case 11: return "R_V850_ZDA_16_16_OFFSET";
     case 12: return "R_V850_ZDA_15_16_OFFSET";
     case 13: return "R_V850_TDA_6_8_OFFSET";
     case 14: return "R_V850_TDA_7_8_OFFSET";
     case 15: return "R_V850_TDA_7_7_OFFSET";
     case 16: return "R_V850_TDA_16_16_OFFSET";
     case 17: return "R_V850_TDA_4_5_OFFSET";
     case 18: return "R_V850_TDA_4_4_OFFSET";
     case 19: return "R_V850_SDA_16_16_SPLIT_OFFSET";
     case 20: return "R_V850_ZDA_16_16_SPLIT_OFFSET";
     case 21: return "R_V850_CALLT_6_7_OFFSET";
     case 22: return "R_V850_CALLT_16_16_OFFSET";
     case 23: return "R_V850_GNU_VTINHERIT";
     case 24: return "R_V850_GNU_VTENTRY";
     case 25: return "R_V850_LONGCALL";
     case 26: return "R_V850_LONGJUMP";
     case 27: return "R_V850_ALIGN";
     case 28: return "R_V850_REL32";
     case 29: return "R_V850_LO16_SPLIT_OFFSET";
     case 30: return "R_V850_16_PCREL";
     case 31: return "R_V850_17_PCREL";
     case 32: return "R_V850_23";
     case 33: return "R_V850_32_PCREL";
     case 34: return "R_V850_32_ABS";
     case 35: return "R_V850_16_SPLIT_OFFSET";
     case 36: return "R_V850_16_S1";
     case 37: return "R_V850_LO16_S1";
     case 38: return "R_V850_CALLT_15_16_OFFSET";
     case 39: return "R_V850_32_GOTPCREL";
     case 40: return "R_V850_16_GOT";
     case 41: return "R_V850_32_GOT";
     case 42: return "R_V850_22_PLT";
     case 43: return "R_V850_32_PLT";
     case 44: return "R_V850_COPY";
     case 45: return "R_V850_GLOB_DAT";
     case 46: return "R_V850_JMP_SLOT";
     case 47: return "R_V850_RELATIVE";
     case 48: return "R_V850_16_GOTOFF";
     case 49: return "R_V850_32_GOTOFF";
     case 50: return "R_V850_CODE";
     case 51: return "R_V850_DATA";

default: return 
# 114 "./../include/elf/v850.h" 3 4
((void *)0)
# 114 "./../include/elf/v850.h"
; } }
# 179 "./../include/elf/v850.h"
static const char *v800_reloc_type (unsigned long rtype); static const char * v800_reloc_type (unsigned long rtype) { switch (rtype) {

     case 0x00: return "R_V800_NONE";
     case 0x30: return "R_V810_NONE";
     case 0x31: return "R_V810_BYTE";
     case 0x32: return "R_V810_HWORD";
     case 0x33: return "R_V810_WORD";
     case 0x34: return "R_V810_WLO";
     case 0x35: return "R_V810_WHI";
     case 0x36: return "R_V810_WHI1";
     case 0x37: return "R_V810_GPBYTE";
     case 0x38: return "R_V810_GPHWORD";
     case 0x39: return "R_V810_GPWORD";
     case 0x3a: return "R_V810_GPWLO";
     case 0x3b: return "R_V810_GPWHI";
     case 0x3c: return "R_V810_GPWHI1";
     case 0x3d: return "R_V850_HWLO";
    
     case 0x3f: return "R_V850_EP7BIT";
     case 0x40: return "R_V850_EPHBYTE";
     case 0x41: return "R_V850_EPWBYTE";
     case 0x42: return "R_V850_REGHWLO";
    
     case 0x44: return "R_V850_GPHWLO";
    
     case 0x46: return "R_V850_PCR22";
     case 0x47: return "R_V850_BLO";
     case 0x48: return "R_V850_EP4BIT";
     case 0x49: return "R_V850_EP5BIT";
     case 0x4a: return "R_V850_REGBLO";
     case 0x4b: return "R_V850_GPBLO";
     case 0x4c: return "R_V810_WLO_1";
     case 0x4d: return "R_V810_GPWLO_1";
     case 0x4e: return "R_V850_BLO_1";
     case 0x4f: return "R_V850_HWLO_1";
    
     case 0x51: return "R_V850_GPBLO_1";
     case 0x52: return "R_V850_GPHWLO_1";
    
     case 0x54: return "R_V850_EPBLO";
     case 0x55: return "R_V850_EPHWLO";
    
     case 0x57: return "R_V850_EPWLO_N";
     case 0x58: return "R_V850_PC32";
     case 0x59: return "R_V850_W23BIT";
     case 0x5a: return "R_V850_GPW23BIT";
     case 0x5b: return "R_V850_EPW23BIT";
     case 0x5c: return "R_V850_B23BIT";
     case 0x5d: return "R_V850_GPB23BIT";
     case 0x5e: return "R_V850_EPB23BIT";
     case 0x5f: return "R_V850_PC16U";
     case 0x60: return "R_V850_PC17";
     case 0x61: return "R_V850_DW8";
     case 0x62: return "R_V850_GPDW8";
     case 0x63: return "R_V850_EPDW8";
     case 0x64: return "R_V850_PC9";
     case 0x65: return "R_V810_REGBYTE";
     case 0x66: return "R_V810_REGHWORD";
     case 0x67: return "R_V810_REGWORD";
     case 0x68: return "R_V810_REGWLO";
     case 0x69: return "R_V810_REGWHI";
     case 0x6a: return "R_V810_REGWHI1";
     case 0x6b: return "R_V850_REGW23BIT";
     case 0x6c: return "R_V850_REGB23BIT";
     case 0x6d: return "R_V850_REGDW8";
     case 0x6e: return "R_V810_EPBYTE";
     case 0x6f: return "R_V810_EPHWORD";
     case 0x70: return "R_V810_EPWORD";
     case 0x71: return "R_V850_WLO23";
     case 0x72: return "R_V850_WORD_E";
     case 0x73: return "R_V850_REGWORD_E";
     case 0x74: return "R_V850_WORD";
     case 0x75: return "R_V850_GPWORD";
     case 0x76: return "R_V850_REGWORD";
     case 0x77: return "R_V850_EPWORD";
     case 0x78: return "R_V810_TPBYTE";
     case 0x79: return "R_V810_TPHWORD";
     case 0x7a: return "R_V810_TPWORD";
     case 0x7b: return "R_V810_TPWLO";
     case 0x7c: return "R_V810_TPWHI";
     case 0x7d: return "R_V810_TPWHI1";
     case 0x7e: return "R_V850_TPHWLO";
     case 0x7f: return "R_V850_TPBLO";
     case 0x80: return "R_V810_TPWLO_1";
     case 0x81: return "R_V850_TPBLO_1";
     case 0x82: return "R_V850_TPHWLO_1";
     case 0x83: return "R_V850_TP23BIT";
     case 0x84: return "R_V850_TPW23BIT";
     case 0x85: return "R_V850_TPDW8";


     case 0xa0: return "R_V810_ABS32";
     case 0xe0: return "R_V850_SYM";
     case 0xe1: return "R_V850_OPadd";
     case 0xe2: return "R_V850_OPsub";
     case 0xe3: return "R_V850_OPsctsize";
     case 0xe4: return "R_V850_OPscttop";

default: return 
# 277 "./../include/elf/v850.h" 3 4
((void *)0)
# 277 "./../include/elf/v850.h"
; } }
# 303 "./../include/elf/v850.h"
enum v850_notes
{
  V850_NOTE_ALIGNMENT = 1,



  V850_NOTE_DATA_SIZE = 2,



  V850_NOTE_FPU_INFO = 3,



  V850_NOTE_SIMD_INFO = 4,


  V850_NOTE_CACHE_INFO = 5,


  V850_NOTE_MMU_INFO = 6

};
# 152 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/vax.h" 1
# 27 "./../include/elf/vax.h"
static const char *elf_vax_reloc_type (unsigned long rtype); static const char * elf_vax_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_VAX_NONE";
  case 1: return "R_VAX_32";
  case 2: return "R_VAX_16";
  case 3: return "R_VAX_8";
  case 4: return "R_VAX_PC32";
  case 5: return "R_VAX_PC16";
  case 6: return "R_VAX_PC8";
  case 7: return "R_VAX_GOT32";
  case 13: return "R_VAX_PLT32";
  case 19: return "R_VAX_COPY";
  case 20: return "R_VAX_GLOB_DAT";
  case 21: return "R_VAX_JMP_SLOT";
  case 22: return "R_VAX_RELATIVE";

  case 23: return "R_VAX_GNU_VTINHERIT";
  case 24: return "R_VAX_GNU_VTENTRY";
default: return 
# 44 "./../include/elf/vax.h" 3 4
((void *)0)
# 44 "./../include/elf/vax.h"
; } }
# 153 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/visium.h" 1
# 32 "./../include/elf/visium.h"
static const char *elf_visium_reloc_type (unsigned long rtype); static const char * elf_visium_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_VISIUM_NONE";
  case 1: return "R_VISIUM_8";
  case 2: return "R_VISIUM_16";
  case 3: return "R_VISIUM_32";
  case 4: return "R_VISIUM_8_PCREL";
  case 5: return "R_VISIUM_16_PCREL";
  case 6: return "R_VISIUM_32_PCREL";
  case 7: return "R_VISIUM_PC16";
  case 8: return "R_VISIUM_HI16";
  case 9: return "R_VISIUM_LO16";
  case 10: return "R_VISIUM_IM16";
  case 11: return "R_VISIUM_HI16_PCREL";
  case 12: return "R_VISIUM_LO16_PCREL";
  case 13: return "R_VISIUM_IM16_PCREL";
  case 200: return "R_VISIUM_GNU_VTINHERIT";
  case 201: return "R_VISIUM_GNU_VTENTRY";
default: return 
# 49 "./../include/elf/visium.h" 3 4
((void *)0)
# 49 "./../include/elf/visium.h"
; } }
# 154 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/wasm32.h" 1
# 25 "./../include/elf/wasm32.h"
static const char *elf_wasm32_reloc_type (unsigned long rtype); static const char * elf_wasm32_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_WASM32_NONE";
  case 1: return "R_WASM32_32";
default: return 
# 28 "./../include/elf/wasm32.h" 3 4
((void *)0)
# 28 "./../include/elf/wasm32.h"
; } }
# 155 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/x86-64.h" 1
# 26 "./../include/elf/x86-64.h"
static const char *elf_x86_64_reloc_type (unsigned long rtype); static const char * elf_x86_64_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_X86_64_NONE";
     case 1: return "R_X86_64_64";
     case 2: return "R_X86_64_PC32";
     case 3: return "R_X86_64_GOT32";
     case 4: return "R_X86_64_PLT32";
     case 5: return "R_X86_64_COPY";
     case 6: return "R_X86_64_GLOB_DAT";
     case 7: return "R_X86_64_JUMP_SLOT";
     case 8: return "R_X86_64_RELATIVE";
     case 9: return "R_X86_64_GOTPCREL";

     case 10: return "R_X86_64_32";
     case 11: return "R_X86_64_32S";
     case 12: return "R_X86_64_16";
     case 13: return "R_X86_64_PC16";
     case 14: return "R_X86_64_8";
     case 15: return "R_X86_64_PC8";
     case 16: return "R_X86_64_DTPMOD64";
     case 17: return "R_X86_64_DTPOFF64";
     case 18: return "R_X86_64_TPOFF64";
     case 19: return "R_X86_64_TLSGD";
     case 20: return "R_X86_64_TLSLD";
     case 21: return "R_X86_64_DTPOFF32";
     case 22: return "R_X86_64_GOTTPOFF";
     case 23: return "R_X86_64_TPOFF32";
     case 24: return "R_X86_64_PC64";
     case 25: return "R_X86_64_GOTOFF64";
     case 26: return "R_X86_64_GOTPC32";

     case 27: return "R_X86_64_GOT64";
     case 28: return "R_X86_64_GOTPCREL64";

     case 29: return "R_X86_64_GOTPC64";

     case 30: return "R_X86_64_GOTPLT64";
     case 31: return "R_X86_64_PLTOFF64";

     case 32: return "R_X86_64_SIZE32";
     case 33: return "R_X86_64_SIZE64";
     case 34: return "R_X86_64_GOTPC32_TLSDESC";



     case 35: return "R_X86_64_TLSDESC_CALL";

     case 36: return "R_X86_64_TLSDESC";
     case 37: return "R_X86_64_IRELATIVE";
     case 38: return "R_X86_64_RELATIVE64";
     case 39: return "R_X86_64_PC32_BND";

     case 40: return "R_X86_64_PLT32_BND";



     case 41: return "R_X86_64_GOTPCRELX";


     case 42: return "R_X86_64_REX_GOTPCRELX";
     case 250: return "R_X86_64_GNU_VTINHERIT";
     case 251: return "R_X86_64_GNU_VTENTRY";
default: return 
# 87 "./../include/elf/x86-64.h" 3 4
((void *)0)
# 87 "./../include/elf/x86-64.h"
; } }
# 156 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/xc16x.h" 1
# 27 "./../include/elf/xc16x.h"
static const char *elf_xc16x_reloc_type (unsigned long rtype); static const char * elf_xc16x_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_XC16X_NONE";
  case 1: return "R_XC16X_ABS_8";
  case 2: return "R_XC16X_ABS_16";
  case 3: return "R_XC16X_ABS_32";
  case 4: return "R_XC16X_8_PCREL";
  case 5: return "R_XC16X_PAG";
  case 6: return "R_XC16X_POF";
  case 7: return "R_XC16X_SEG";
  case 8: return "R_XC16X_SOF";

default: return 
# 38 "./../include/elf/xc16x.h" 3 4
((void *)0)
# 38 "./../include/elf/xc16x.h"
; } }
# 157 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/xgate.h" 1
# 26 "./../include/elf/xgate.h"
static const char *elf_xgate_reloc_type (unsigned long rtype); static const char * elf_xgate_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_XGATE_NONE";
  case 1: return "R_XGATE_8";
  case 2: return "R_XGATE_PCREL_8";
  case 3: return "R_XGATE_16";
  case 4: return "R_XGATE_32";
  case 5: return "R_XGATE_PCREL_16";

  case 6: return "R_XGATE_GNU_VTINHERIT";
  case 7: return "R_XGATE_GNU_VTENTRY";

  case 8: return "R_XGATE_24";
  case 9: return "R_XGATE_LO16";
  case 10: return "R_XGATE_GPAGE";
  case 11: return "R_XGATE_PCREL_9";
  case 12: return "R_XGATE_PCREL_10";
  case 13: return "R_XGATE_IMM8_LO";
  case 14: return "R_XGATE_IMM8_HI";
  case 15: return "R_XGATE_IMM3";
  case 16: return "R_XGATE_IMM4";
  case 17: return "R_XGATE_IMM5";



  case 18: return "R_XGATE_RL_JUMP";


  case 19: return "R_XGATE_RL_GROUP";
default: return 
# 54 "./../include/elf/xgate.h" 3 4
((void *)0)
# 54 "./../include/elf/xgate.h"
; } }
# 158 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/xstormy16.h" 1
# 26 "./../include/elf/xstormy16.h"
static const char *elf_xstormy16_reloc_type (unsigned long rtype); static const char * elf_xstormy16_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_XSTORMY16_NONE";

  case 1: return "R_XSTORMY16_32";
  case 2: return "R_XSTORMY16_16";
  case 3: return "R_XSTORMY16_8";
  case 4: return "R_XSTORMY16_PC32";
  case 5: return "R_XSTORMY16_PC16";
  case 6: return "R_XSTORMY16_PC8";

  case 7: return "R_XSTORMY16_REL_12";
  case 8: return "R_XSTORMY16_24";
  case 9: return "R_XSTORMY16_FPTR16";

  case 10: return "R_XSTORMY16_LO16";
  case 11: return "R_XSTORMY16_HI16";
  case 12: return "R_XSTORMY16_12";

  case 128: return "R_XSTORMY16_GNU_VTINHERIT";
  case 129: return "R_XSTORMY16_GNU_VTENTRY";
default: return 
# 46 "./../include/elf/xstormy16.h" 3 4
((void *)0)
# 46 "./../include/elf/xstormy16.h"
; } }
# 159 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/elf/xtensa.h" 1
# 34 "./../include/elf/xtensa.h"
static const char *elf_xtensa_reloc_type (unsigned long rtype); static const char * elf_xtensa_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_XTENSA_NONE";
     case 1: return "R_XTENSA_32";
     case 2: return "R_XTENSA_RTLD";
     case 3: return "R_XTENSA_GLOB_DAT";
     case 4: return "R_XTENSA_JMP_SLOT";
     case 5: return "R_XTENSA_RELATIVE";
     case 6: return "R_XTENSA_PLT";
     case 8: return "R_XTENSA_OP0";
     case 9: return "R_XTENSA_OP1";
     case 10: return "R_XTENSA_OP2";
     case 11: return "R_XTENSA_ASM_EXPAND";
     case 12: return "R_XTENSA_ASM_SIMPLIFY";
     case 14: return "R_XTENSA_32_PCREL";
     case 15: return "R_XTENSA_GNU_VTINHERIT";
     case 16: return "R_XTENSA_GNU_VTENTRY";
     case 17: return "R_XTENSA_DIFF8";
     case 18: return "R_XTENSA_DIFF16";
     case 19: return "R_XTENSA_DIFF32";
     case 20: return "R_XTENSA_SLOT0_OP";
     case 21: return "R_XTENSA_SLOT1_OP";
     case 22: return "R_XTENSA_SLOT2_OP";
     case 23: return "R_XTENSA_SLOT3_OP";
     case 24: return "R_XTENSA_SLOT4_OP";
     case 25: return "R_XTENSA_SLOT5_OP";
     case 26: return "R_XTENSA_SLOT6_OP";
     case 27: return "R_XTENSA_SLOT7_OP";
     case 28: return "R_XTENSA_SLOT8_OP";
     case 29: return "R_XTENSA_SLOT9_OP";
     case 30: return "R_XTENSA_SLOT10_OP";
     case 31: return "R_XTENSA_SLOT11_OP";
     case 32: return "R_XTENSA_SLOT12_OP";
     case 33: return "R_XTENSA_SLOT13_OP";
     case 34: return "R_XTENSA_SLOT14_OP";
     case 35: return "R_XTENSA_SLOT0_ALT";
     case 36: return "R_XTENSA_SLOT1_ALT";
     case 37: return "R_XTENSA_SLOT2_ALT";
     case 38: return "R_XTENSA_SLOT3_ALT";
     case 39: return "R_XTENSA_SLOT4_ALT";
     case 40: return "R_XTENSA_SLOT5_ALT";
     case 41: return "R_XTENSA_SLOT6_ALT";
     case 42: return "R_XTENSA_SLOT7_ALT";
     case 43: return "R_XTENSA_SLOT8_ALT";
     case 44: return "R_XTENSA_SLOT9_ALT";
     case 45: return "R_XTENSA_SLOT10_ALT";
     case 46: return "R_XTENSA_SLOT11_ALT";
     case 47: return "R_XTENSA_SLOT12_ALT";
     case 48: return "R_XTENSA_SLOT13_ALT";
     case 49: return "R_XTENSA_SLOT14_ALT";
     case 50: return "R_XTENSA_TLSDESC_FN";
     case 51: return "R_XTENSA_TLSDESC_ARG";
     case 52: return "R_XTENSA_TLS_DTPOFF";
     case 53: return "R_XTENSA_TLS_TPOFF";
     case 54: return "R_XTENSA_TLS_FUNC";
     case 55: return "R_XTENSA_TLS_ARG";
     case 56: return "R_XTENSA_TLS_CALL";
default: return 
# 90 "./../include/elf/xtensa.h" 3 4
((void *)0)
# 90 "./../include/elf/xtensa.h"
; } }
# 128 "./../include/elf/xtensa.h"
typedef struct property_table_entry_t
{
  bfd_vma address;
  bfd_vma size;
  flagword flags;
} property_table_entry;
# 212 "./../include/elf/xtensa.h"
extern asection *xtensa_make_property_section (asection *, const char *);
# 160 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2

# 1 "./../include/getopt.h" 1
# 35 "./../include/getopt.h"
extern char *optarg;
# 49 "./../include/getopt.h"
extern int optind;




extern int opterr;



extern int optopt;
# 81 "./../include/getopt.h"
struct option
{

  const char *name;





  int has_arg;
  int *flag;
  int val;
};
# 120 "./../include/getopt.h"
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
          const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind);


extern int _getopt_internal (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind,
        int long_only);
# 162 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2

# 1 "./../include/safe-ctype.h" 1
# 57 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "./../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 123 "./../include/safe-ctype.h" 2
# 164 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2
# 1 "./../include/filenames.h" 1
# 29 "./../include/filenames.h"
# 1 "./../include/hashtab.h" 1
# 42 "./../include/hashtab.h"

# 42 "./../include/hashtab.h"
typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "./../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, void *);
extern void htab_remove_elt_with_hash (htab_t, void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);
# 30 "./../include/filenames.h" 2
# 83 "./../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);
# 165 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2





typedef struct elf_section_list
{
  Elf_Internal_Shdr * hdr;
  struct elf_section_list * next;
} elf_section_list;

char * program_name = "readelf";
static unsigned long archive_file_offset;
static unsigned long archive_file_size;
static bfd_size_type current_file_size;
static unsigned long dynamic_addr;
static bfd_size_type dynamic_size;
static size_t dynamic_nent;
static char * dynamic_strings;
static unsigned long dynamic_strings_length;
static char * string_table;
static unsigned long string_table_length;
static unsigned long num_dynamic_syms;
static Elf_Internal_Sym * dynamic_symbols;
static Elf_Internal_Syminfo * dynamic_syminfo;
static unsigned long dynamic_syminfo_offset;
static unsigned int dynamic_syminfo_nent;
static char program_interpreter[
# 192 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               4096
# 192 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       ];
static bfd_vma dynamic_info[32];
static bfd_vma dynamic_info_DT_GNU_HASH;
static bfd_vma version_info[16];
static Elf_Internal_Ehdr elf_header;
static Elf_Internal_Shdr * section_headers;
static Elf_Internal_Phdr * program_headers;
static Elf_Internal_Dyn * dynamic_section;
static elf_section_list * symtab_shndx_list;
static bfd_boolean show_name = 0;
static bfd_boolean do_dynamic = 0;
static bfd_boolean do_syms = 0;
static bfd_boolean do_dyn_syms = 0;
static bfd_boolean do_reloc = 0;
static bfd_boolean do_sections = 0;
static bfd_boolean do_section_groups = 0;
static bfd_boolean do_section_details = 0;
static bfd_boolean do_segments = 0;
static bfd_boolean do_unwind = 0;
static bfd_boolean do_using_dynamic = 0;
static bfd_boolean do_header = 0;
static bfd_boolean do_dump = 0;
static bfd_boolean do_version = 0;
static bfd_boolean do_histogram = 0;
static bfd_boolean do_debugging = 0;
static bfd_boolean do_arch = 0;
static bfd_boolean do_notes = 0;
static bfd_boolean do_archive_index = 0;
static bfd_boolean is_32bit_elf = 0;
static bfd_boolean decompress_dumps = 0;

struct group_list
{
  struct group_list * next;
  unsigned int section_index;
};

struct group
{
  struct group_list * root;
  unsigned int group_index;
};

static size_t group_count;
static struct group * section_groups;
static struct group ** section_headers_groups;
# 247 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
typedef unsigned char dump_type;


struct dump_list_entry
{
  char * name;
  dump_type type;
  struct dump_list_entry * next;
};
static struct dump_list_entry * dump_sects_byname;



static dump_type * cmdline_dump_sects = 
# 260 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 260 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             ;
static unsigned int num_cmdline_dump_sects = 0;






static dump_type * dump_sects = 
# 268 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 268 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     ;
static unsigned int num_dump_sects = 0;



typedef enum print_mode
{
  HEX,
  DEC,
  DEC_5,
  UNSIGNED,
  PREFIX_HEX,
  FULL_HEX,
  LONG_HEX
}
print_mode;


enum versioned_symbol_info
{
  symbol_undefined,
  symbol_hidden,
  symbol_public
};

static const char * get_symbol_version_string
  (FILE *, bfd_boolean, const char *, unsigned long, unsigned,
   Elf_Internal_Sym *, enum versioned_symbol_info *, unsigned short *);
# 332 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static void *
get_data (void * var, FILE * file, unsigned long offset, bfd_size_type size,
   bfd_size_type nmemb, const char * reason)
{
  void * mvar;
  bfd_size_type amt = size * nmemb;

  if (size == 0 || nmemb == 0)
    return 
# 340 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 340 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;




  if (sizeof (size_t) < sizeof (bfd_size_type)
      && ( (bfd_size_type) ((size_t) size) != size
   || (bfd_size_type) ((size_t) nmemb) != nmemb))
    {
      if (reason)
 error (gettext ("Size truncation prevents reading 0x%" "l" "x" " elements of size 0x%" "l" "x for %s\n")
                                                    ,
        nmemb, size, reason);
      return 
# 353 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 353 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }


  if (amt < nmemb)
    {
      if (reason)
 error (gettext ("Size overflow prevents reading 0x%" "l" "x" " elements of size 0x%" "l" "x for %s\n")
                                                    ,
        nmemb, size, reason);
      return 
# 363 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 363 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }



  if (amt > current_file_size
      || offset + archive_file_offset + amt > current_file_size)
    {
      if (reason)
 error (gettext ("Reading 0x%" "l" "x" " bytes extends past end of file for %s\n")
                                              ,
        amt, reason);
      return 
# 375 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 375 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  if (fseek (file, archive_file_offset + offset, 
# 378 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                0
# 378 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                        ))
    {
      if (reason)
 error (gettext ("Unable to seek to 0x%lx for %s\n"),
        archive_file_offset + offset, reason);
      return 
# 383 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 383 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  mvar = var;
  if (mvar == 
# 387 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 387 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    {

      if (nmemb < (~(bfd_size_type) 0 - 1) / size)

 mvar = malloc ((size_t) amt + 1);

      if (mvar == 
# 394 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 394 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   if (reason)
     error (gettext ("Out of memory allocating 0x%" "l" "x" " bytes for %s\n")
                         ,
     amt, reason);
   return 
# 400 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 400 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ;
 }

      ((char *) mvar)[amt] = '\0';
    }

  if (fread (mvar, (size_t) size, (size_t) nmemb, file) != nmemb)
    {
      if (reason)
 error (gettext ("Unable to read in 0x%" "l" "x bytes of %s\n"),
        amt, reason);
      if (mvar != var)
 free (mvar);
      return 
# 413 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 413 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  return mvar;
}




static unsigned int
print_vma (bfd_vma vma, print_mode mode)
{
  unsigned int nc = 0;

  switch (mode)
    {
    case FULL_HEX:
      nc = printf ("0x");

    case LONG_HEX:

      if (is_32bit_elf)
 return nc + printf ("%8.8" "l" "x", vma);

      fprintf (
# 437 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     stdout
# 437 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     , "%016" "l" "x", vma);
      return nc + 16;

    case DEC_5:
      if (vma <= 99999)
 return printf ("%5" "l" "d", vma);

    case PREFIX_HEX:
      nc = printf ("0x");

    case HEX:
      return nc + printf ("%" "l" "x", vma);

    case DEC:
      return printf ("%" "l" "d", vma);

    case UNSIGNED:
      return printf ("%" "l" "u", vma);

    default:

      return 0;
    }
}
# 472 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static unsigned int
print_symbol (signed int width, const char *symbol)
{
  bfd_boolean extra_padding = 0;
  signed int num_printed = 0;

  mbstate_t state;

  unsigned int width_remaining;

  if (width < 0)
    {

      width = - width;
      extra_padding = 1;
    }
  
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ((void) sizeof ((
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 width != 0
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 width != 0
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ; else __assert_fail (
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 "width != 0"
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 488, __extension__ __PRETTY_FUNCTION__); }))
# 488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;

  if (do_wide)


    width_remaining = 0x7fffffff;
  else
    width_remaining = width;



  memset (& state, 0, sizeof (state));


  while (width_remaining)
    {
      size_t n;
      const char c = *symbol++;

      if (c == 0)
 break;




      if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_iscntrl)))
 {
   if (width_remaining < 2)
     break;

   printf ("^%c", c + 0x40);
   width_remaining -= 2;
   num_printed += 2;
 }
      else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   putchar (c);
   width_remaining --;
   num_printed ++;
 }
      else
 {

   wchar_t w;


   printf ("%.1s", symbol - 1);
   width_remaining --;
   num_printed ++;





   n = mbrtowc (& w, symbol - 1, 
# 542 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                (__ctype_get_mb_cur_max ())
# 542 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          , & state);



   if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
     symbol += (n - 1);
 }
    }

  if (extra_padding && num_printed < width)
    {

      printf ("%-*s", width - num_printed, " ");
      num_printed = width;
    }

  return num_printed;
}





static const char *
printable_section_name (const Elf_Internal_Shdr * sec)
{

  static char sec_name_buf [128 + 1];
  const char * name = ((sec) == 
# 570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0) 
# 570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     ? gettext ("<none>") : string_table == 
# 570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0) 
# 570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name));
  char * buf = sec_name_buf;
  char c;
  unsigned int remaining = 128;

  while ((c = * name ++) != 0)
    {
      if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_iscntrl)))
 {
   if (remaining < 2)
     break;

   * buf ++ = '^';
   * buf ++ = c + 0x40;
   remaining -= 2;
 }
      else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   * buf ++ = c;
   remaining -= 1;
 }
      else
 {
   static char hex[17] = "0123456789ABCDEF";

   if (remaining < 4)
     break;
   * buf ++ = '<';
   * buf ++ = hex[(c & 0xf0) >> 4];
   * buf ++ = hex[c & 0x0f];
   * buf ++ = '>';
   remaining -= 4;
 }

      if (remaining == 0)
 break;
    }

  * buf = 0;
  return sec_name_buf;
}

static const char *
printable_section_name_from_index (unsigned long ndx)
{
  if (ndx >= elf_header.e_shnum)
    return gettext ("<corrupt>");

  return printable_section_name (section_headers + ndx);
}



static Elf_Internal_Shdr *
find_section (const char * name)
{
  unsigned int i;

  for (i = 0; i < elf_header.e_shnum; i++)
    if ((strcmp ((((section_headers + i) == 
# 629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<none>") : string_table == 
# 629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<no-name>") : ((section_headers + i)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section_headers + i)->sh_name))), (name)) == 0))
      return section_headers + i;

  return 
# 632 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 632 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}




static Elf_Internal_Shdr *
find_section_by_address (bfd_vma addr)
{
  unsigned int i;

  for (i = 0; i < elf_header.e_shnum; i++)
    {
      Elf_Internal_Shdr *sec = section_headers + i;
      if (addr >= sec->sh_addr && addr < sec->sh_addr + sec->sh_size)
 return sec;
    }

  return 
# 650 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 650 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static Elf_Internal_Shdr *
find_section_by_type (unsigned int type)
{
  unsigned int i;

  for (i = 0; i < elf_header.e_shnum; i++)
    {
      Elf_Internal_Shdr *sec = section_headers + i;
      if (sec->sh_type == type)
 return sec;
    }

  return 
# 665 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 665 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}




static Elf_Internal_Shdr *
find_section_in_set (const char * name, unsigned int * set)
{
  unsigned int i;

  if (set != 
# 676 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 676 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                )
    {
      while ((i = *set++) > 0)
 {

   if (i >= elf_header.e_shnum)
     continue;

   if ((strcmp ((((section_headers + i) == 
# 684 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0) 
# 684 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      ? gettext ("<none>") : string_table == 
# 684 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0) 
# 684 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      ? gettext ("<no-name>") : ((section_headers + i)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section_headers + i)->sh_name))), (name)) == 0))
     return section_headers + i;
 }
    }

  return find_section (name);
}




static inline unsigned long
read_uleb128 (unsigned char * data,
       unsigned int * length_return,
       const unsigned char * const end)
{
  return read_leb128 (data, length_return, 0, end);
}





static inline bfd_boolean
is_ia64_vms (void)
{
  return elf_header.e_machine == 50
    && elf_header.e_ident[7] == 13;
}



static bfd_boolean
guess_is_rela (unsigned int e_machine)
{
  switch (e_machine)
    {

    case 3:
    case 6:
    case 19:
    case 40:
    case 85:
    case 0x7650:
    case 0x5aa5:
    case 8:
    case 10:
    case 0x9041:
    case 135:
    case 115:
      return 0;


    case 4:
    case 7:
    case 183:
    case 0x1223:
    case 0x9026:
    case 113:
    case 45:
    case 93:
    case 195:
    case 83:
    case 0x1057:
    case 106:
    case 177:
    case 76:
    case 114:
    case 86:
    case 0x7676:
    case 84:
    case 222:
    case 0x3330:
    case 0x5441:
    case 48:
    case 46:
    case 47:
    case 50:
    case 101:
    case 0x8217:
    case 0xFEBA:
    case 138:
    case 0xFEB0:
    case 120:
    case 88:
    case 39:
    case 0xF00D:
    case 174:
    case 80:
    case 90:
    case 0xdead:
    case 89:
    case 0xbeef:
    case 223:
    case 105:
    case 0x1059:
    case 0x2530:
    case 167:
    case 0xFEBB:
    case 92:
    case 21:
    case 20:
    case 144:
    case 243:
    case 197:
    case 173:
    case 22:
    case 0xa390:
    case 42:
    case 2:
    case 18:
    case 43:
    case 23:
    case 140:
    case 191:
    case 188:
    case 36:
    case 87:
    case 0x9080:
    case 75:
    case 221:
    case 62:
    case 180:
    case 181:
    case 0xad45:
    case 94:
    case 0xabc7:
    case 189:
    case 0xbaab:
    case 0x4157:
      return 1;

    case 72:
    case 71:
    case 70:
    case 69:
    case 66:
    case 59:
    case 54:
    case 56:
    case 57:
    case 55:
    case 60:
    case 74:
    case 68:
    case 67:
    case 58:
    case 73:
    case 61:
    default:
      warn (gettext ("Don't know about relocations on this machine architecture\n"));
      return 0;
    }
}







static bfd_boolean
slurp_rela_relocs (FILE * file,
     unsigned long rel_offset,
     unsigned long rel_size,
     Elf_Internal_Rela ** relasp,
     unsigned long * nrelasp)
{
  Elf_Internal_Rela * relas;
  size_t nrelas;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rela * erelas;

      erelas = (Elf32_External_Rela *) get_data (
# 860 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                ((void *)0)
# 860 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                    , file, rel_offset, 1,
                                                 rel_size, gettext ("32-bit relocation data"));
      if (!erelas)
 return 0;

      nrelas = rel_size / sizeof (Elf32_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == 
# 870 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 870 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
 {
   free (erelas);
   error (gettext ("out of memory parsing relocs\n"));
   return 0;
 }

      for (i = 0; i < nrelas; i++)
 {
   relas[i].r_offset = byte_get (erelas[i].r_offset, sizeof (erelas[i].r_offset));
   relas[i].r_info = byte_get (erelas[i].r_info, sizeof (erelas[i].r_info));
   relas[i].r_addend = byte_get_signed (erelas[i].r_addend, sizeof (erelas[i].r_addend));
 }

      free (erelas);
    }
  else
    {
      Elf64_External_Rela * erelas;

      erelas = (Elf64_External_Rela *) get_data (
# 890 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                ((void *)0)
# 890 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                    , file, rel_offset, 1,
                                                 rel_size, gettext ("64-bit relocation data"));
      if (!erelas)
 return 0;

      nrelas = rel_size / sizeof (Elf64_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == 
# 900 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 900 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
 {
   free (erelas);
   error (gettext ("out of memory parsing relocs\n"));
   return 0;
 }

      for (i = 0; i < nrelas; i++)
 {
   relas[i].r_offset = byte_get (erelas[i].r_offset, sizeof (erelas[i].r_offset));
   relas[i].r_info = byte_get (erelas[i].r_info, sizeof (erelas[i].r_info));
   relas[i].r_addend = byte_get_signed (erelas[i].r_addend, sizeof (erelas[i].r_addend));





   if (elf_header.e_machine == 8
       && elf_header.e_ident[5] != 2)
     {





       bfd_vma inf = relas[i].r_info;
       inf = (((inf & 0xffffffff) << 32)
        | ((inf >> 56) & 0xff)
        | ((inf >> 40) & 0xff00)
        | ((inf >> 24) & 0xff0000)
        | ((inf >> 8) & 0xff000000));
       relas[i].r_info = inf;
     }

 }

      free (erelas);
    }

  *relasp = relas;
  *nrelasp = nrelas;
  return 1;
}







static bfd_boolean
slurp_rel_relocs (FILE * file,
    unsigned long rel_offset,
    unsigned long rel_size,
    Elf_Internal_Rela ** relsp,
    unsigned long * nrelsp)
{
  Elf_Internal_Rela * rels;
  size_t nrels;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rel * erels;

      erels = (Elf32_External_Rel *) get_data (
# 965 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 965 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  , file, rel_offset, 1,
                                               rel_size, gettext ("32-bit relocation data"));
      if (!erels)
 return 0;

      nrels = rel_size / sizeof (Elf32_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == 
# 974 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 974 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   free (erels);
   error (gettext ("out of memory parsing relocs\n"));
   return 0;
 }

      for (i = 0; i < nrels; i++)
 {
   rels[i].r_offset = byte_get (erels[i].r_offset, sizeof (erels[i].r_offset));
   rels[i].r_info = byte_get (erels[i].r_info, sizeof (erels[i].r_info));
   rels[i].r_addend = 0;
 }

      free (erels);
    }
  else
    {
      Elf64_External_Rel * erels;

      erels = (Elf64_External_Rel *) get_data (
# 994 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 994 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  , file, rel_offset, 1,
                                               rel_size, gettext ("64-bit relocation data"));
      if (!erels)
 return 0;

      nrels = rel_size / sizeof (Elf64_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == 
# 1003 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 1003 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   free (erels);
   error (gettext ("out of memory parsing relocs\n"));
   return 0;
 }

      for (i = 0; i < nrels; i++)
 {
   rels[i].r_offset = byte_get (erels[i].r_offset, sizeof (erels[i].r_offset));
   rels[i].r_info = byte_get (erels[i].r_info, sizeof (erels[i].r_info));
   rels[i].r_addend = 0;





   if (elf_header.e_machine == 8
       && elf_header.e_ident[5] != 2)
     {





       bfd_vma inf = rels[i].r_info;
       inf = (((inf & 0xffffffff) << 32)
       | ((inf >> 56) & 0xff)
       | ((inf >> 40) & 0xff00)
       | ((inf >> 24) & 0xff0000)
       | ((inf >> 8) & 0xff000000));
       rels[i].r_info = inf;
     }

 }

      free (erels);
    }

  *relsp = rels;
  *nrelsp = nrels;
  return 1;
}



static unsigned int
get_reloc_type (bfd_vma reloc_info)
{
  if (is_32bit_elf)
    return ((reloc_info) & 0xff);

  switch (elf_header.e_machine)
    {
    case 8:

      return ((reloc_info) & 0xff);

    case 43:
      return ((reloc_info) & 0xff);

    default:
      return ((reloc_info) & 0xffffffff);
    }
}



static bfd_vma
get_reloc_symindex (bfd_vma reloc_info)
{
  return is_32bit_elf ? ((reloc_info) >> 8) : ((reloc_info) >> 32);
}

static inline bfd_boolean
uses_msp430x_relocs (void)
{
  return
    elf_header.e_machine == 105

    && (((elf_header.e_flags & 0xff) == 45)

 || (elf_header.e_ident[7] == 0));
}




static bfd_boolean
dump_relocations (FILE * file,
    unsigned long rel_offset,
    unsigned long rel_size,
    Elf_Internal_Sym * symtab,
    unsigned long nsyms,
    char * strtab,
    unsigned long strtablen,
    int is_rela,
    bfd_boolean is_dynsym)
{
  unsigned long i;
  Elf_Internal_Rela * rels;
  bfd_boolean res = 1;

  if (is_rela == -1)
    is_rela = guess_is_rela (elf_header.e_machine);

  if (is_rela)
    {
      if (!slurp_rela_relocs (file, rel_offset, rel_size, &rels, &rel_size))
 return 0;
    }
  else
    {
      if (!slurp_rel_relocs (file, rel_offset, rel_size, &rels, &rel_size))
 return 0;
    }

  if (is_32bit_elf)
    {
      if (is_rela)
 {
   if (do_wide)
     printf (gettext (" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
   else
     printf (gettext (" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
 }
      else
 {
   if (do_wide)
     printf (gettext (" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
   else
     printf (gettext (" Offset     Info    Type            Sym.Value  Sym. Name\n"));
 }
    }
  else
    {
      if (is_rela)
 {
   if (do_wide)
     printf (gettext ("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
   else
     printf (gettext ("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
 }
      else
 {
   if (do_wide)
     printf (gettext ("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
   else
     printf (gettext ("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
 }
    }

  for (i = 0; i < rel_size; i++)
    {
      const char * rtype;
      bfd_vma offset;
      bfd_vma inf;
      bfd_vma symtab_index;
      bfd_vma type;

      offset = rels[i].r_offset;
      inf = rels[i].r_info;

      type = get_reloc_type (inf);
      symtab_index = get_reloc_symindex (inf);

      if (is_32bit_elf)
 {
   printf ("%8.8lx  %8.8lx ",
    (unsigned long) offset & 0xffffffff,
    (unsigned long) inf & 0xffffffff);
 }
      else
 {

   printf (do_wide
    ? "%16.16lx  %16.16lx "
    : "%12.12lx  %12.12lx ",
    offset, inf);
# 1203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 }

      switch (elf_header.e_machine)
 {
 default:
   rtype = 
# 1208 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 1208 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
   break;

 case 183:
   rtype = elf_aarch64_reloc_type (type);
   break;

 case 88:
 case 0x9041:
   rtype = elf_m32r_reloc_type (type);
   break;

 case 3:
 case 6:
   rtype = elf_i386_reloc_type (type);
   break;

 case 70:
 case 53:
   rtype = elf_m68hc11_reloc_type (type);
   break;

 case 4:
   rtype = elf_m68k_reloc_type (type);
   break;

 case 19:
   rtype = elf_i960_reloc_type (type);
   break;

 case 83:
 case 0x1057:
   rtype = elf_avr_reloc_type (type);
   break;

 case 11:
 case 18:
 case 43:
 case 2:
   rtype = elf_sparc_reloc_type (type);
   break;

 case 23:
   rtype = elf_spu_reloc_type (type);
   break;

 case 36:
   rtype = v800_reloc_type (type);
   break;
 case 87:
 case 0x9080:
   rtype = v850_reloc_type (type);
   break;

 case 85:
 case 0x7650:
   rtype = elf_d10v_reloc_type (type);
   break;

 case 86:
 case 0x7676:
   rtype = elf_d30v_reloc_type (type);
   break;

 case 0x5aa5:
   rtype = elf_dlx_reloc_type (type);
   break;

 case 42:
   rtype = elf_sh_reloc_type (type);
   break;

 case 89:
 case 0xbeef:
   rtype = elf_mn10300_reloc_type (type);
   break;

 case 90:
 case 0xdead:
   rtype = elf_mn10200_reloc_type (type);
   break;

 case 84:
 case 0x3330:
   rtype = elf_fr30_reloc_type (type);
   break;

 case 0x5441:
   rtype = elf_frv_reloc_type (type);
   break;

 case 222:
   rtype = elf_ft32_reloc_type (type);
   break;

 case 39:
   rtype = elf_mcore_reloc_type (type);
   break;

 case 80:
   rtype = elf_mmix_reloc_type (type);
   break;

 case 223:
   rtype = elf_moxie_reloc_type (type);
   break;

 case 105:
   if (uses_msp430x_relocs ())
     {
       rtype = elf_msp430x_reloc_type (type);
       break;
     }

 case 0x1059:
   rtype = elf_msp430_reloc_type (type);
   break;

 case 167:
   rtype = elf_nds32_reloc_type (type);
   break;

 case 20:
   rtype = elf_ppc_reloc_type (type);
   break;

 case 21:
   rtype = elf_ppc64_reloc_type (type);
   break;

 case 8:
 case 10:
   rtype = elf_mips_reloc_type (type);
   break;

 case 243:
   rtype = elf_riscv_reloc_type (type);
   break;

 case 0x9026:
   rtype = elf_alpha_reloc_type (type);
   break;

 case 40:
   rtype = elf_arm_reloc_type (type);
   break;

 case 45:
 case 93:
 case 195:
   rtype = elf_arc_reloc_type (type);
   break;

 case 15:
   rtype = elf_hppa_reloc_type (type);
   break;

 case 46:
 case 47:
 case 48:
   rtype = elf_h8_reloc_type (type);
   break;

 case 92:
   rtype = elf_or1k_reloc_type (type);
   break;

 case 91:
 case 99:
   rtype = elf_pj_reloc_type (type);
   break;
 case 50:
   rtype = elf_ia64_reloc_type (type);
   break;

 case 76:
   rtype = elf_cris_reloc_type (type);
   break;

 case 7:
   rtype = elf_i860_reloc_type (type);
   break;

 case 62:
 case 180:
 case 181:
   rtype = elf_x86_64_reloc_type (type);
   break;

 case 9:
   rtype = i370_reloc_type (type);
   break;

 case 0xa390:
 case 22:
   rtype = elf_s390_reloc_type (type);
   break;

 case 135:
   rtype = elf_score_reloc_type (type);
   break;

 case 0xad45:
   rtype = elf_xstormy16_reloc_type (type);
   break;

 case 114:
   rtype = elf_crx_reloc_type (type);
   break;

 case 75:
   rtype = elf_vax_reloc_type (type);
   break;

 case 221:
   rtype = elf_visium_reloc_type (type);
   break;

 case 0x1223:
   rtype = elf_epiphany_reloc_type (type);
   break;

 case 101:
 case 0x8217:
   rtype = elf_ip2k_reloc_type (type);
   break;

 case 0xFEBA:
   rtype = elf_iq2000_reloc_type (type);
   break;

 case 0xabc7:
 case 94:
   rtype = elf_xtensa_reloc_type (type);
   break;

 case 138:
   rtype = elf_lm32_reloc_type (type);
   break;

 case 0xFEB0:
 case 120:
   rtype = elf_m32c_reloc_type (type);
   break;

 case 0x2530:
   rtype = elf_mt_reloc_type (type);
   break;

 case 106:
   rtype = elf_bfin_reloc_type (type);
   break;

 case 0xF00D:
   rtype = elf_mep_reloc_type (type);
   break;

 case 177:
   rtype = elf_cr16_reloc_type (type);
   break;

 case 189:
 case 0xbaab:
   rtype = elf_microblaze_reloc_type (type);
   break;

 case 197:
   rtype = elf_rl78_reloc_type (type);
   break;

 case 173:
   rtype = elf_rx_reloc_type (type);
   break;

 case 174:
   rtype = elf_metag_reloc_type (type);
   break;

 case 0x4688:
 case 116:
   rtype = elf_xc16x_reloc_type (type);
   break;

 case 140:
   rtype = elf_tic6x_reloc_type (type);
   break;

 case 191:
   rtype = elf_tilegx_reloc_type (type);
   break;

 case 188:
   rtype = elf_tilepro_reloc_type (type);
   break;

 case 0x4157:
   rtype = elf_wasm32_reloc_type (type);
   break;

 case 115:
   rtype = elf_xgate_reloc_type (type);
   break;

 case 113:
   rtype = elf_nios2_reloc_type (type);
   break;

 case 144:
   rtype = elf_pru_reloc_type (type);
   break;
 }

      if (rtype == 
# 1520 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 1520 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
 printf (gettext ("unrecognized: %-7lx"), (unsigned long) type & 0xffffffff);
      else
 printf (do_wide ? "%-22.22s" : "%-17.17s", rtype);

      if (elf_header.e_machine == 0x9026
   && rtype != 
# 1526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
   
# 1527 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  && (strcmp ((rtype), ("R_ALPHA_LITUSE")) == 0)
   && is_rela)
 {
   switch (rels[i].r_addend)
     {
     case 0: rtype = "ADDR"; break;
     case 1: rtype = "BASE"; break;
     case 2: rtype = "BYTOFF"; break;
     case 3: rtype = "JSR"; break;
     case 4: rtype = "TLSGD"; break;
     case 5: rtype = "TLSLDM"; break;
     case 6: rtype = "JSRDIRECT"; break;
     default: rtype = 
# 1539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 1539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;
     }

   if (rtype)
     printf (" (%s)", rtype);
   else
     {
       putchar (' ');
       printf (gettext ("<unknown addend: %lx>"),
        (unsigned long) rels[i].r_addend);
       res = 0;
     }
 }
      else if (symtab_index)
 {
   if (symtab == 
# 1554 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0) 
# 1554 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     || symtab_index >= nsyms)
     {
       error (gettext (" bad symbol index: %08lx in reloc"), (unsigned long) symtab_index);
       res = 0;
     }
   else
     {
       Elf_Internal_Sym * psym;
       const char * version_string;
       enum versioned_symbol_info sym_info;
       unsigned short vna_other;

       psym = symtab + symtab_index;

       version_string
  = get_symbol_version_string (file, is_dynsym,
          strtab, strtablen,
          symtab_index,
          psym,
          &sym_info,
          &vna_other);

       printf (" ");

       if (((psym->st_info) & 0xF) == 10)
  {
    const char * name;
    unsigned int len;
    unsigned int width = is_32bit_elf ? 8 : 14;
# 1594 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    if (strtab == 
# 1594 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
        
# 1595 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       || psym->st_name == 0
        || psym->st_name >= strtablen)
      name = "??";
    else
      name = strtab + psym->st_name;

    len = print_symbol (width, name);
    if (version_string)
      printf (sym_info == symbol_public ? "@@%s" : "@%s",
       version_string);
    printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
  }
       else
  {
    print_vma (psym->st_value, LONG_HEX);

    printf (is_32bit_elf ? "   " : " ");
  }

       if (psym->st_name == 0)
  {
    const char * sec_name = "<null>";
    char name_buf[40];

    if (((psym->st_info) & 0xF) == 3)
      {
        if (psym->st_shndx < elf_header.e_shnum)
   sec_name = ((section_headers + psym->st_shndx) == 
# 1622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 1622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ? gettext ("<none>") : string_table == 
# 1622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 1622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ? gettext ("<no-name>") : ((section_headers + psym->st_shndx)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section_headers + psym->st_shndx)->sh_name));
        else if (psym->st_shndx == (-0xFu))
   sec_name = "ABS";
        else if (psym->st_shndx == (-0xEu))
   sec_name = "COMMON";
        else if ((elf_header.e_machine == 8
    && psym->st_shndx == ((-0x100u) + 3))
          || (elf_header.e_machine == 140
       && psym->st_shndx == (-0x100u)))
   sec_name = "SCOMMON";
        else if (elf_header.e_machine == 8
          && psym->st_shndx == ((-0x100u) + 4))
   sec_name = "SUNDEF";
        else if ((elf_header.e_machine == 62
    || elf_header.e_machine == 180
    || elf_header.e_machine == 181)
          && psym->st_shndx == ((-0x100u) + 2))
   sec_name = "LARGE_COMMON";
        else if (elf_header.e_machine == 50
          && elf_header.e_ident[7] == 1
          && psym->st_shndx == (-0x100u))
   sec_name = "ANSI_COM";
        else if (is_ia64_vms ()
          && psym->st_shndx == (-0xE0u))
   sec_name = "VMS_SYMVEC";
        else
   {
     sprintf (name_buf, "<section 0x%x>",
       (unsigned int) psym->st_shndx);
     sec_name = name_buf;
   }
      }
    print_symbol (22, sec_name);
  }
       else if (strtab == 
# 1656 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 1656 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
  printf (gettext ("<string table index: %3ld>"), psym->st_name);
       else if (psym->st_name >= strtablen)
  {
    error (gettext ("<corrupt string table index: %3ld>"), psym->st_name);
    res = 0;
  }
       else
  {
    print_symbol (22, strtab + psym->st_name);
    if (version_string)
      printf (sym_info == symbol_public ? "@@%s" : "@%s",
       version_string);
  }

       if (is_rela)
  {
    bfd_vma off = rels[i].r_addend;

    if ((bfd_signed_vma) off < 0)
      printf (" - %" "l" "x", - off);
    else
      printf (" + %" "l" "x", off);
  }
     }
 }
      else if (is_rela)
 {
   bfd_vma off = rels[i].r_addend;

   printf ("%*c", is_32bit_elf ? 12 : 20, ' ');
   if ((bfd_signed_vma) off < 0)
     printf ("-%" "l" "x", - off);
   else
     printf ("%" "l" "x", off);
 }

      if (elf_header.e_machine == 43
   && rtype != 
# 1694 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
   
# 1695 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  && (strcmp ((rtype), ("R_SPARC_OLO10")) == 0))
 printf (" + %lx", (unsigned long) (((bfd_signed_vma)(((inf) & 0xffffffff) >> 8) ^ 0x800000) - 0x800000));

      putchar ('\n');


      if (! is_32bit_elf && elf_header.e_machine == 8)
 {
   bfd_vma type2 = (((inf) >> 8) & 0xff);
   bfd_vma type3 = (((inf) >> 16) & 0xff);
   const char * rtype2 = elf_mips_reloc_type (type2);
   const char * rtype3 = elf_mips_reloc_type (type3);

   printf ("                    Type2: ");

   if (rtype2 == 
# 1710 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 1710 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     printf (gettext ("unrecognized: %-7lx"),
      (unsigned long) type2 & 0xffffffff);
   else
     printf ("%-17.17s", rtype2);

   printf ("\n                    Type3: ");

   if (rtype3 == 
# 1718 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 1718 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     printf (gettext ("unrecognized: %-7lx"),
      (unsigned long) type3 & 0xffffffff);
   else
     printf ("%-17.17s", rtype3);

   putchar ('\n');
 }

    }

  free (rels);

  return res;
}

static const char *
get_mips_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "MIPS_RLD_VERSION";
    case 0x70000002: return "MIPS_TIME_STAMP";
    case 0x70000003: return "MIPS_ICHECKSUM";
    case 0x70000004: return "MIPS_IVERSION";
    case 0x70000005: return "MIPS_FLAGS";
    case 0x70000006: return "MIPS_BASE_ADDRESS";
    case 0x70000007: return "MIPS_MSYM";
    case 0x70000008: return "MIPS_CONFLICT";
    case 0x70000009: return "MIPS_LIBLIST";
    case 0x7000000a: return "MIPS_LOCAL_GOTNO";
    case 0x7000000b: return "MIPS_CONFLICTNO";
    case 0x70000010: return "MIPS_LIBLISTNO";
    case 0x70000011: return "MIPS_SYMTABNO";
    case 0x70000012: return "MIPS_UNREFEXTNO";
    case 0x70000013: return "MIPS_GOTSYM";
    case 0x70000014: return "MIPS_HIPAGENO";
    case 0x70000016: return "MIPS_RLD_MAP";
    case 0x70000035: return "MIPS_RLD_MAP_REL";
    case 0x70000017: return "MIPS_DELTA_CLASS";
    case 0x70000018: return "MIPS_DELTA_CLASS_NO";
    case 0x70000019: return "MIPS_DELTA_INSTANCE";
    case 0x7000001a: return "MIPS_DELTA_INSTANCE_NO";
    case 0x7000001b: return "MIPS_DELTA_RELOC";
    case 0x7000001c: return "MIPS_DELTA_RELOC_NO";
    case 0x7000001d: return "MIPS_DELTA_SYM";
    case 0x7000001e: return "MIPS_DELTA_SYM_NO";
    case 0x70000020: return "MIPS_DELTA_CLASSSYM";
    case 0x70000021: return "MIPS_DELTA_CLASSSYM_NO";
    case 0x70000022: return "MIPS_CXX_FLAGS";
    case 0x70000023: return "MIPS_PIXIE_INIT";
    case 0x70000024: return "MIPS_SYMBOL_LIB";
    case 0x70000025: return "MIPS_LOCALPAGE_GOTIDX";
    case 0x70000026: return "MIPS_LOCAL_GOTIDX";
    case 0x70000027: return "MIPS_HIDDEN_GOTIDX";
    case 0x70000028: return "MIPS_PROTECTED_GOTIDX";
    case 0x70000029: return "MIPS_OPTIONS";
    case 0x7000002a: return "MIPS_INTERFACE";
    case 0x7000002b: return "MIPS_DYNSTR_ALIGN";
    case 0x7000002c: return "MIPS_INTERFACE_SIZE";
    case 0x7000002d: return "MIPS_RLD_TEXT_RESOLVE_ADDR";
    case 0x7000002e: return "MIPS_PERF_SUFFIX";
    case 0x7000002f: return "MIPS_COMPACT_SIZE";
    case 0x70000030: return "MIPS_GP_VALUE";
    case 0x70000031: return "MIPS_AUX_DYNAMIC";
    case 0x70000032: return "MIPS_PLTGOT";
    case 0x70000034: return "MIPS_RWPLT";
    default:
      return 
# 1786 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1786 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_sparc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "SPARC_REGISTER";
    default:
      return 
# 1797 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1797 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_ppc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000): return "PPC_GOT";
    case (0x70000000 + 1): return "PPC_OPT";
    default:
      return 
# 1809 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1809 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_ppc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "PPC64_GLINK";
    case (0x70000000 + 1): return "PPC64_OPD";
    case (0x70000000 + 2): return "PPC64_OPDSZ";
    case (0x70000000 + 3): return "PPC64_OPT";
    default:
      return 
# 1823 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1823 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_parisc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x60000000 + 0x0): return "HP_LOAD_MAP";
    case (0x60000000 + 0x1): return "HP_DLD_FLAGS";
    case (0x60000000 + 0x2): return "HP_DLD_HOOK";
    case (0x60000000 + 0x3): return "HP_UX10_INIT";
    case (0x60000000 + 0x4): return "HP_UX10_INITSZ";
    case (0x60000000 + 0x5): return "HP_PREINIT";
    case (0x60000000 + 0x6): return "HP_PREINITSZ";
    case (0x60000000 + 0x7): return "HP_NEEDED";
    case (0x60000000 + 0x8): return "HP_TIME_STAMP";
    case (0x60000000 + 0x9): return "HP_CHECKSUM";
    case (0x60000000 + 0xa): return "HP_GST_SIZE";
    case (0x60000000 + 0xb): return "HP_GST_VERSION";
    case (0x60000000 + 0xc): return "HP_GST_HASHVAL";
    case (0x60000000 + 0xd): return "HP_GST_EPLTREL";
    case (0x60000000 + 0xe): return "HP_GST_EPLTRELSZ";
    case (0x60000000 + 0xf): return "HP_FILTERED";
    case (0x60000000 + 0x10): return "HP_FILTER_TLS";
    case (0x60000000 + 0x11): return "HP_COMPAT_FILTERED";
    case (0x60000000 + 0x12): return "HP_LAZYLOAD";
    case (0x60000000 + 0x13): return "HP_BIND_NOW_COUNT";
    case (0x60000000 + 0x14): return "PLT";
    case (0x60000000 + 0x15): return "PLT_SIZE";
    case (0x60000000 + 0x16): return "DLT";
    case (0x60000000 + 0x17): return "DLT_SIZE";
    default:
      return 
# 1857 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1857 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_ia64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "IA_64_PLT_RESERVE";
    case (0x6000000d + 0): return "VMS_SUBTYPE";
    case (0x6000000d + 2): return "VMS_IMGIOCNT";
    case (0x6000000d + 8): return "VMS_LNKFLAGS";
    case (0x6000000d + 10): return "VMS_VIR_MEM_BLK_SIZ";
    case (0x6000000d + 12): return "VMS_IDENT";
    case (0x6000000d + 16): return "VMS_NEEDED_IDENT";
    case (0x6000000d + 18): return "VMS_IMG_RELA_CNT";
    case (0x6000000d + 20): return "VMS_SEG_RELA_CNT";
    case (0x6000000d + 22): return "VMS_FIXUP_RELA_CNT";
    case (0x6000000d + 24): return "VMS_FIXUP_NEEDED";
    case (0x6000000d + 26): return "VMS_SYMVEC_CNT";
    case (0x6000000d + 30): return "VMS_XLATED";
    case (0x6000000d + 32): return "VMS_STACKSIZE";
    case (0x6000000d + 34): return "VMS_UNWINDSZ";
    case (0x6000000d + 36): return "VMS_UNWIND_CODSEG";
    case (0x6000000d + 38): return "VMS_UNWIND_INFOSEG";
    case (0x6000000d + 40): return "VMS_LINKTIME";
    case (0x6000000d + 42): return "VMS_SEG_NO";
    case (0x6000000d + 44): return "VMS_SYMVEC_OFFSET";
    case (0x6000000d + 46): return "VMS_SYMVEC_SEG";
    case (0x6000000d + 48): return "VMS_UNWIND_OFFSET";
    case (0x6000000d + 50): return "VMS_UNWIND_SEG";
    case (0x6000000d + 52): return "VMS_STRTAB_OFFSET";
    case (0x6000000d + 54): return "VMS_SYSVER_OFFSET";
    case (0x6000000d + 56): return "VMS_IMG_RELA_OFF";
    case (0x6000000d + 58): return "VMS_SEG_RELA_OFF";
    case (0x6000000d + 60): return "VMS_FIXUP_RELA_OFF";
    case (0x6000000d + 62): return "VMS_PLTGOT_OFFSET";
    case (0x6000000d + 64): return "VMS_PLTGOT_SEG";
    case (0x6000000d + 66): return "VMS_FPMODE";
    default:
      return 
# 1898 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 1898 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }
}

static const char *
get_solaris_section_type (unsigned long type)
{
  switch (type)
    {
    case 0x6fffffee: return "SUNW_ancillary";
    case 0x6fffffef: return "SUNW_capchain";
    case 0x6ffffff0: return "SUNW_capinfo";
    case 0x6ffffff1: return "SUNW_symsort";
    case 0x6ffffff2: return "SUNW_tlssort";
    case 0x6ffffff3: return "SUNW_LDYNSYM";
    case 0x6ffffff4: return "SUNW_dof";
    case 0x6ffffff5: return "SUNW_cap";
    case 0x6ffffff6: return "SUNW_SIGNATURE";
    case 0x6ffffff7: return "SUNW_ANNOTATE";
    case 0x6ffffff8: return "SUNW_DEBUGSTR";
    case 0x6ffffff9: return "SUNW_DEBUG";
    case 0x6ffffffa: return "SUNW_move";
    case 0x6ffffffb: return "SUNW_COMDAT";
    case 0x6ffffffc: return "SUNW_syminfo";
    case 0x6ffffffd: return "SUNW_verdef";
    case 0x6ffffffe: return "SUNW_verneed";
    case 0x6fffffff: return "SUNW_versym";
    case 0x70000000: return "SPARC_GOTDATA";
    default: return 
# 1926 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 1926 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
    }
}

static const char *
get_alpha_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "ALPHA_PLTRO";
    default: return 
# 1936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 1936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
    }
}

static const char *
get_score_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "SCORE_BASE_ADDRESS";
    case 0x70000002: return "SCORE_LOCAL_GOTNO";
    case 0x70000003: return "SCORE_SYMTABNO";
    case 0x70000004: return "SCORE_GOTSYM";
    case 0x70000005: return "SCORE_UNREFEXTNO";
    case 0x70000006: return "SCORE_HIPAGENO";
    default: return 
# 1951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 1951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;
    }
}

static const char *
get_tic6x_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x6000000D: return "C6000_GSYM_OFFSET";
    case 0x6000000F: return "C6000_GSTR_OFFSET";
    case 0x70000000: return "C6000_DSBT_BASE";
    case 0x70000001: return "C6000_DSBT_SIZE";
    case 0x70000002: return "C6000_PREEMPTMAP";
    case 0x70000003: return "C6000_DSBT_INDEX";
    default: return 
# 1966 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 1966 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         ;
    }
}

static const char *
get_nios2_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000002: return "NIOS2_GP";
    default: return 
# 1976 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 1976 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                ;
    }
}

static const char *
get_solaris_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x6000000d: return "SUNW_AUXILIARY";
    case 0x6000000e: return "SUNW_RTLDINF";
    case 0x6000000f: return "SUNW_FILTER";
    case 0x60000010: return "SUNW_CAP";
    case 0x60000011: return "SUNW_SYMTAB";
    case 0x60000012: return "SUNW_SYMSZ";
    case 0x60000013: return "SUNW_SORTENT";
    case 0x60000014: return "SUNW_SYMSORT";
    case 0x60000015: return "SUNW_SYMSORTSZ";
    case 0x60000016: return "SUNW_TLSSORT";
    case 0x60000017: return "SUNW_TLSSORTSZ";
    case 0x60000018: return "SUNW_CAPINFO";
    case 0x60000019: return "SUNW_STRPAD";
    case 0x6000001a: return "SUNW_CAPCHAIN";
    case 0x6000001b: return "SUNW_LDMACH";
    case 0x6000001d: return "SUNW_CAPCHAINENT";
    case 0x6000001f: return "SUNW_CAPCHAINSZ";
    case 0x60000021: return "SUNW_PARENT";
    case 0x60000023: return "SUNW_ASLR";
    case 0x60000025: return "SUNW_RELAX";
    case 0x60000029: return "SUNW_NXHEAP";
    case 0x6000002b: return "SUNW_NXSTACK";

    case 0x70000001: return "SPARC_REGISTER";
    case 0x7ffffffd: return "AUXILIARY";
    case 0x7ffffffe: return "USED";
    case 0x7fffffff: return "FILTER";

    default: return 
# 2013 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 2013 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
    }
}

static const char *
get_dynamic_type (unsigned long type)
{
  static char buff[64];

  switch (type)
    {
    case 0: return "NULL";
    case 1: return "NEEDED";
    case 2: return "PLTRELSZ";
    case 3: return "PLTGOT";
    case 4: return "HASH";
    case 5: return "STRTAB";
    case 6: return "SYMTAB";
    case 7: return "RELA";
    case 8: return "RELASZ";
    case 9: return "RELAENT";
    case 10: return "STRSZ";
    case 11: return "SYMENT";
    case 12: return "INIT";
    case 13: return "FINI";
    case 14: return "SONAME";
    case 15: return "RPATH";
    case 16: return "SYMBOLIC";
    case 17: return "REL";
    case 18: return "RELSZ";
    case 19: return "RELENT";
    case 20: return "PLTREL";
    case 21: return "DEBUG";
    case 22: return "TEXTREL";
    case 23: return "JMPREL";
    case 24: return "BIND_NOW";
    case 25: return "INIT_ARRAY";
    case 26: return "FINI_ARRAY";
    case 27: return "INIT_ARRAYSZ";
    case 28: return "FINI_ARRAYSZ";
    case 29: return "RUNPATH";
    case 30: return "FLAGS";

    case 32: return "PREINIT_ARRAY";
    case 33: return "PREINIT_ARRAYSZ";
    case 34: return "SYMTAB_SHNDX";

    case 0x6ffffdf8: return "CHECKSUM";
    case 0x6ffffdf9: return "PLTPADSZ";
    case 0x6ffffdfa: return "MOVEENT";
    case 0x6ffffdfb: return "MOVESZ";
    case 0x6ffffdfc: return "FEATURE";
    case 0x6ffffdfd: return "POSFLAG_1";
    case 0x6ffffdfe: return "SYMINSZ";
    case 0x6ffffdff: return "SYMINENT";

    case 0x6ffffe00: return "ADDRRNGLO";
    case 0x6ffffefa: return "CONFIG";
    case 0x6ffffefb: return "DEPAUDIT";
    case 0x6ffffefc: return "AUDIT";
    case 0x6ffffefd: return "PLTPAD";
    case 0x6ffffefe: return "MOVETAB";
    case 0x6ffffeff: return "SYMINFO";

    case 0x6ffffff0: return "VERSYM";

    case 0x6ffffef7: return "TLSDESC_GOT";
    case 0x6ffffef6: return "TLSDESC_PLT";
    case 0x6ffffff9: return "RELACOUNT";
    case 0x6ffffffa: return "RELCOUNT";
    case 0x6ffffffb: return "FLAGS_1";
    case 0x6ffffffc: return "VERDEF";
    case 0x6ffffffd: return "VERDEFNUM";
    case 0x6ffffffe: return "VERNEED";
    case 0x6fffffff: return "VERNEEDNUM";

    case 0x7ffffffd: return "AUXILIARY";
    case 0x7ffffffe: return "USED";
    case 0x7fffffff: return "FILTER";

    case 0x6ffffdf5: return "GNU_PRELINKED";
    case 0x6ffffef8: return "GNU_CONFLICT";
    case 0x6ffffdf6: return "GNU_CONFLICTSZ";
    case 0x6ffffef9: return "GNU_LIBLIST";
    case 0x6ffffdf7: return "GNU_LIBLISTSZ";
    case 0x6ffffef5: return "GNU_HASH";

    default:
      if ((type >= 0x70000000) && (type <= 0x7fffffff))
 {
   const char * result;

   switch (elf_header.e_machine)
     {
     case 8:
     case 10:
       result = get_mips_dynamic_type (type);
       break;
     case 43:
       result = get_sparc64_dynamic_type (type);
       break;
     case 20:
       result = get_ppc_dynamic_type (type);
       break;
     case 21:
       result = get_ppc64_dynamic_type (type);
       break;
     case 50:
       result = get_ia64_dynamic_type (type);
       break;
     case 0x9026:
       result = get_alpha_dynamic_type (type);
       break;
     case 135:
       result = get_score_dynamic_type (type);
       break;
     case 140:
       result = get_tic6x_dynamic_type (type);
       break;
     case 113:
       result = get_nios2_dynamic_type (type);
       break;
     default:
       if (elf_header.e_ident[7] == 6)
  result = get_solaris_dynamic_type (type);
       else
  result = 
# 2139 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 2139 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
       break;
     }

   if (result != 
# 2143 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 2143 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   snprintf (buff, sizeof (buff), gettext ("Processor Specific: %lx"), type);
 }
      else if (((type >= 0x6000000d) && (type <= 0x6ffff000))
        || (elf_header.e_machine == 15
     && (type >= 0x60000000) && (type <= 0x6fffffff)))
 {
   const char * result;

   switch (elf_header.e_machine)
     {
     case 15:
       result = get_parisc_dynamic_type (type);
       break;
     case 50:
       result = get_ia64_dynamic_type (type);
       break;
     default:
       if (elf_header.e_ident[7] == 6)
  result = get_solaris_dynamic_type (type);
       else
  result = 
# 2166 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 2166 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
       break;
     }

   if (result != 
# 2170 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 2170 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   snprintf (buff, sizeof (buff), gettext ("Operating System specific: %lx"),
      type);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %lx"), type);

      return buff;
    }
}

static char *
get_file_type (unsigned e_type)
{
  static char buff[32];

  switch (e_type)
    {
    case 0: return gettext ("NONE (None)");
    case 1: return gettext ("REL (Relocatable file)");
    case 2: return gettext ("EXEC (Executable file)");
    case 3: return gettext ("DYN (Shared object file)");
    case 4: return gettext ("CORE (Core file)");

    default:
      if ((e_type >= 0xFF00) && (e_type <= 0xFFFF))
 snprintf (buff, sizeof (buff), gettext ("Processor Specific: (%x)"), e_type);
      else if ((e_type >= 0xFE00) && (e_type <= 0xFEFF))
 snprintf (buff, sizeof (buff), gettext ("OS Specific: (%x)"), e_type);
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %x"), e_type);
      return buff;
    }
}

static char *
get_machine_name (unsigned e_machine)
{
  static char buff[64];

  switch (e_machine)
    {


    case 0: return gettext ("None");
    case 1: return "WE32100";
    case 2: return "Sparc";
    case 3: return "Intel 80386";
    case 4: return "MC68000";
    case 5: return "MC88000";
    case 6: return "Intel MCU";
    case 7: return "Intel 80860";
    case 8: return "MIPS R3000";
    case 9: return "IBM System/370";

    case 10: return "MIPS R4000 big-endian";
    case 11: return "Sparc v9 (old)";
    case 15: return "HPPA";
    case 17: return "Fujitsu VPP500";
    case 18: return "Sparc v8+" ;
    case 19: return "Intel 90860";
    case 20: return "PowerPC";

    case 21: return "PowerPC64";
    case 0xa390:
    case 22: return "IBM S/390";
    case 23: return "SPU";

    case 36: return "Renesas V850 (using RH850 ABI)";
    case 37: return "Fujitsu FR20";
    case 38: return "TRW RH32";
    case 39: return "MCORE";

    case 40: return "ARM";
    case 41: return "Digital Alpha (old)";
    case 42: return "Renesas / SuperH SH";
    case 43: return "Sparc v9";
    case 44: return "Siemens Tricore";
    case 45: return "ARC";
    case 46: return "Renesas H8/300";
    case 47: return "Renesas H8/300H";
    case 48: return "Renesas H8S";
    case 49: return "Renesas H8/500";

    case 50: return "Intel IA-64";
    case 51: return "Stanford MIPS-X";
    case 52: return "Motorola Coldfire";
    case 53: return "Motorola MC68HC12 Microcontroller";
    case 54: return "Fujitsu Multimedia Accelerator";
    case 55: return "Siemens PCP";
    case 56: return "Sony nCPU embedded RISC processor";
    case 57: return "Denso NDR1 microprocesspr";
    case 58: return "Motorola Star*Core processor";
    case 59: return "Toyota ME16 processor";

    case 60: return "STMicroelectronics ST100 processor";
    case 61: return "Advanced Logic Corp. TinyJ embedded processor";
    case 62: return "Advanced Micro Devices X86-64";
    case 63: return "Sony DSP processor";
    case 64: return "Digital Equipment Corp. PDP-10";
    case 65: return "Digital Equipment Corp. PDP-11";
    case 66: return "Siemens FX66 microcontroller";
    case 67: return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    case 68: return "STMicroelectronics ST7 8-bit microcontroller";
    case 69: return "Motorola MC68HC16 Microcontroller";

    case 70: return "Motorola MC68HC11 Microcontroller";
    case 71: return "Motorola MC68HC08 Microcontroller";
    case 72: return "Motorola MC68HC05 Microcontroller";
    case 73: return "Silicon Graphics SVx";
    case 74: return "STMicroelectronics ST19 8-bit microcontroller";
    case 75: return "Digital VAX";
    case 76: return "Axis Communications 32-bit embedded processor";
    case 77: return "Infineon Technologies 32-bit embedded cpu";
    case 78: return "Element 14 64-bit DSP processor";
    case 79: return "LSI Logic's 16-bit DSP processor";

    case 80: return "Donald Knuth's educational 64-bit processor";
    case 81: return "Harvard Universitys's machine-independent object format";
    case 82: return "Vitesse Prism";
    case 0x1057:
    case 83: return "Atmel AVR 8-bit microcontroller";
    case 0x3330:
    case 84: return "Fujitsu FR30";
    case 0x7650:
    case 85: return "d10v";
    case 0x7676:
    case 86: return "d30v";
    case 0x9080:
    case 87: return "Renesas V850";
    case 0x9041:
    case 88: return "Renesas M32R (formerly Mitsubishi M32r)";
    case 0xbeef:
    case 89: return "mn10300";

    case 0xdead:
    case 90: return "mn10200";
    case 91: return "picoJava";
    case 92: return "OpenRISC 1000";
    case 93: return "ARCompact";
    case 0xabc7:
    case 94: return "Tensilica Xtensa Processor";
    case 95: return "Alphamosaic VideoCore processor";
    case 96: return "Thompson Multimedia General Purpose Processor";
    case 97: return "National Semiconductor 32000 series";
    case 98: return "Tenor Network TPC processor";
    case 99: return "Trebia SNP 1000 processor";

    case 100: return "STMicroelectronics ST200 microcontroller";
    case 0x8217:
    case 101: return "Ubicom IP2xxx 8-bit microcontrollers";
    case 102: return "MAX Processor";
    case 103: return "National Semiconductor CompactRISC";
    case 104: return "Fujitsu F2MC16";
    case 105: return "Texas Instruments msp430 microcontroller";
    case 106: return "Analog Devices Blackfin";
    case 107: return "S1C33 Family of Seiko Epson processors";
    case 108: return "Sharp embedded microprocessor";
    case 109: return "Arca RISC microprocessor";

    case 110: return "Unicore";
    case 111: return "eXcess 16/32/64-bit configurable embedded CPU";
    case 112: return "Icera Semiconductor Inc. Deep Execution Processor";
    case 113: return "Altera Nios II";
    case 114: return "National Semiconductor CRX microprocessor";
    case 115: return "Motorola XGATE embedded processor";
    case 116:
    case 0x4688: return "Infineon Technologies xc16x";
    case 117: return "Renesas M16C series microprocessors";
    case 118: return "Microchip Technology dsPIC30F Digital Signal Controller";
    case 119: return "Freescale Communication Engine RISC core";

    case 120: return "Renesas M32c";

    case 131: return "Altium TSK3000 core";
    case 132: return "Freescale RS08 embedded processor";
    case 134: return "Cyan Technology eCOG2 microprocessor";
    case 135: return "SUNPLUS S+Core";
    case 136: return "New Japan Radio (NJR) 24-bit DSP Processor";
    case 137: return "Broadcom VideoCore III processor";
    case 138: return "Lattice Mico32";
    case 139: return "Seiko Epson C17 family";

    case 140: return "Texas Instruments TMS320C6000 DSP family";
    case 141: return "Texas Instruments TMS320C2000 DSP family";
    case 142: return "Texas Instruments TMS320C55x DSP family";
    case 144: return "TI PRU I/O processor";

    case 160: return "STMicroelectronics 64bit VLIW Data Signal Processor";
    case 161: return "Cypress M8C microprocessor";
    case 162: return "Renesas R32C series microprocessors";
    case 163: return "NXP Semiconductors TriMedia architecture family";
    case 164: return "QUALCOMM DSP6 Processor";
    case 165: return "Intel 8051 and variants";
    case 166: return "STMicroelectronics STxP7x family";
    case 167: return "Andes Technology compact code size embedded RISC processor family";
    case 168: return "Cyan Technology eCOG1X family";
    case 169: return "Dallas Semiconductor MAXQ30 Core microcontrollers";

    case 170: return "New Japan Radio (NJR) 16-bit DSP Processor";
    case 171: return "M2000 Reconfigurable RISC Microprocessor";
    case 172: return "Cray Inc. NV2 vector architecture";
    case 173: return "Renesas RX";
    case 174: return "Imagination Technologies Meta processor architecture";
    case 175: return "MCST Elbrus general purpose hardware architecture";
    case 176: return "Cyan Technology eCOG16 family";
    case 177:
    case 189:
    case 0xbaab: return "Xilinx MicroBlaze";
    case 178: return "Freescale Extended Time Processing Unit";
    case 179: return "Infineon Technologies SLE9X core";

    case 180: return "Intel L1OM";
    case 181: return "Intel K1OM";
    case 182: return "Intel (reserved)";
    case 183: return "AArch64";
    case 184: return "ARM (reserved)";
    case 185: return "Atmel Corporation 32-bit microprocessor";
    case 186: return "STMicroeletronics STM8 8-bit microcontroller";
    case 187: return "Tilera TILE64 multicore architecture family";
    case 188: return "Tilera TILEPro multicore architecture family";

    case 190: return "NVIDIA CUDA architecture";
    case 191: return "Tilera TILE-Gx multicore architecture family";
    case 192: return "CloudShield architecture family";
    case 193: return "KIPO-KAIST Core-A 1st generation processor family";
    case 194: return "KIPO-KAIST Core-A 2nd generation processor family";
    case 195: return "ARCv2";
    case 196: return "Open8 8-bit RISC soft processor core";
    case 197: return "Renesas RL78";
    case 198: return "Broadcom VideoCore V processor";
    case 199: return "Renesas 78K0R";

    case 200: return "Freescale 56800EX Digital Signal Controller (DSC)";
    case 201: return "Beyond BA1 CPU architecture";
    case 202: return "Beyond BA2 CPU architecture";
    case 203: return "XMOS xCORE processor family";
    case 204: return "Microchip 8-bit PIC(r) family";

    case 210: return "KM211 KM32 32-bit processor";
    case 211: return "KM211 KMX32 32-bit processor";
    case 212: return "KM211 KMX16 16-bit processor";
    case 213: return "KM211 KMX8 8-bit processor";
    case 214: return "KM211 KVARC processor";
    case 215: return "Paneve CDP architecture family";
    case 216: return "Cognitive Smart Memory Processor";
    case 217: return "Bluechip Systems CoolEngine";
    case 218: return "Nanoradio Optimized RISC";
    case 219: return "CSR Kalimba architecture family";

    case 220: return "Zilog Z80";
    case 221: return "CDS VISIUMcore processor";
    case 222: return "FTDI Chip FT32";
    case 223: return "Moxie";
    case 224: return "AMD GPU";
    case 243: return "RISC-V";
    case 244: return "Lanai 32-bit processor";
    case 247: return "Linux BPF";


    case 0x2530: return "Morpho Techologies MT processor";
    case 0x9026: return "Alpha";
    case 0x4157: return "Web Assembly";
    case 0x5aa5: return "OpenDLX";
    case 0xad45: return "Sanyo XStormy16 CPU core";
    case 0xFEBA: return "Vitesse IQ2000";
    case 0xFEB0:
    case 0xFEBB: return "Altera Nios";
    case 0xF00D: return "Toshiba MeP Media Engine";
    case 0x1223: return "Adapteva EPIPHANY";
    case 0x5441: return "Fujitsu FR-V";

    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown>: 0x%x"), e_machine);
      return buff;
    }
}

static void
decode_ARC_machine_flags (unsigned e_flags, unsigned e_machine, char buf[])
{
# 2466 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  switch (e_flags & 0x000000ff)
    {

    case 0x00000005:
      strcat (buf, ", ARC EM");
      break;
    case 0x00000006:
      strcat (buf, ", ARC HS");
      break;


    case 0x00000002:
      strcat (buf, ", ARC600");
      break;
    case 0x00000004:
      strcat (buf, ", ARC601");
      break;
    case 0x00000003:
      strcat (buf, ", ARC700");
      break;





    default:
      if (e_machine == 93)
        strcat (buf, ", Unknown ARCompact");
      else
        strcat (buf, ", Unknown ARC");
      break;
    }

  switch (e_flags & 0x00000f00)
    {
    case 0x00000000:
      strcat (buf, ", (ABI:legacy)");
      break;
    case 0x00000200:
      strcat (buf, ", (ABI:v2)");
      break;

    case 0x00000300:
      strcat (buf, ", v3 no-legacy-syscalls ABI");
      break;
    case 0x00000400:
      strcat (buf, ", v4 ABI");
      break;
    default:
      strcat (buf, ", unrecognised ARC OSABI flag");
      break;
    }
}

static void
decode_ARM_machine_flags (unsigned e_flags, char buf[])
{
  unsigned eabi;
  bfd_boolean unknown = 0;

  eabi = ((e_flags) & 0xFF000000);
  e_flags &= ~ 0xFF000000;


  if (e_flags & 0x01)
    {
      strcat (buf, ", relocatable executable");
      e_flags &= ~ 0x01;
    }


  switch (eabi)
    {
    default:
      strcat (buf, ", <unrecognized EABI>");
      if (e_flags)
 unknown = 1;
      break;

    case 0x01000000:
      strcat (buf, ", Version1 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", sorted symbol tables");
       break;

     default:
       unknown = 1;
       break;
     }
 }
      break;

    case 0x02000000:
      strcat (buf, ", Version2 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", sorted symbol tables");
       break;

     case 0x08:
       strcat (buf, ", dynamic symbols use segment index");
       break;

     case 0x10:
       strcat (buf, ", mapping symbols precede others");
       break;

     default:
       unknown = 1;
       break;
     }
 }
      break;

    case 0x03000000:
      strcat (buf, ", Version3 EABI");
      break;

    case 0x04000000:
      strcat (buf, ", Version4 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x00800000:
       strcat (buf, ", BE8");
       break;

     case 0x00400000:
       strcat (buf, ", LE8");
       break;

     default:
       unknown = 1;
       break;
     }
 }
      break;

    case 0x05000000:
      strcat (buf, ", Version5 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x00800000:
       strcat (buf, ", BE8");
       break;

     case 0x00400000:
       strcat (buf, ", LE8");
       break;

     case 0x200:
       strcat (buf, ", soft-float ABI");
       break;

     case 0x400:
       strcat (buf, ", hard-float ABI");
       break;

     default:
       unknown = 1;
       break;
     }
 }
      break;

    case 0x00000000:
      strcat (buf, ", GNU EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", interworking enabled");
       break;

     case 0x08:
       strcat (buf, ", uses APCS/26");
       break;

     case 0x10:
       strcat (buf, ", uses APCS/float");
       break;

     case 0x20:
       strcat (buf, ", position independent");
       break;

     case 0x40:
       strcat (buf, ", 8 bit structure alignment");
       break;

     case 0x80:
       strcat (buf, ", uses new ABI");
       break;

     case 0x100:
       strcat (buf, ", uses old ABI");
       break;

     case 0x200:
       strcat (buf, ", software FP");
       break;

     case 0x400:
       strcat (buf, ", VFP");
       break;

     case 0x800:
       strcat (buf, ", Maverick FP");
       break;

     default:
       unknown = 1;
       break;
     }
 }
    }

  if (unknown)
    strcat (buf,gettext (", <unknown>"));
}

static void
decode_AVR_machine_flags (unsigned e_flags, char buf[], size_t size)
{
  --size;

  switch (e_flags & 0x7F)
    {
    case 1:
      strncat (buf, ", avr:1", size);
      break;
    case 2:
      strncat (buf, ", avr:2", size);
      break;
    case 25:
      strncat (buf, ", avr:25", size);
      break;
    case 3:
      strncat (buf, ", avr:3", size);
      break;
    case 31:
      strncat (buf, ", avr:31", size);
      break;
    case 35:
      strncat (buf, ", avr:35", size);
      break;
    case 4:
      strncat (buf, ", avr:4", size);
      break;
    case 5:
      strncat (buf, ", avr:5", size);
      break;
    case 51:
      strncat (buf, ", avr:51", size);
      break;
    case 6:
      strncat (buf, ", avr:6", size);
      break;
    case 100:
      strncat (buf, ", avr:100", size);
      break;
    case 101:
      strncat (buf, ", avr:101", size);
      break;
    case 102:
      strncat (buf, ", avr:102", size);
      break;
    case 103:
      strncat (buf, ", avr:103", size);
      break;
    case 104:
      strncat (buf, ", avr:104", size);
      break;
    case 105:
      strncat (buf, ", avr:105", size);
      break;
    case 106:
      strncat (buf, ", avr:106", size);
      break;
    case 107:
      strncat (buf, ", avr:107", size);
      break;
    default:
      strncat (buf, ", avr:<unknown>", size);
      break;
    }

  size -= strlen (buf);
  if (e_flags & 0x80)
    strncat (buf, ", link-relax", size);
}

static void
decode_NDS32_machine_flags (unsigned e_flags, char buf[], size_t size)
{
  unsigned abi;
  unsigned arch;
  unsigned config;
  unsigned version;
  bfd_boolean has_fpu = 0;
  unsigned int r = 0;

  static const char *ABI_STRINGS[] =
  {
    "ABI v0",
    "ABI v1",
    "ABI v2",
    "ABI v2fp",
    "AABI",
    "ABI2 FP+"
  };
  static const char *VER_STRINGS[] =
  {
    "Andes ELF V1.3 or older",
    "Andes ELF V1.3.1",
    "Andes ELF V1.4"
  };
  static const char *ARCH_STRINGS[] =
  {
    "",
    "Andes Star v1.0",
    "Andes Star v2.0",
    "Andes Star v3.0",
    "Andes Star v3.0m"
  };

  abi = 0x000000F0 & e_flags;
  arch = 0xF0000000 & e_flags;
  config = 0x0FFFFF00 & e_flags;
  version = 0x0000000F & e_flags;

  memset (buf, 0, size);

  switch (abi)
    {
    case 0x00000000:
    case 0x00000010:
    case 0x00000020:
    case 0x00000030:
    case 0x00000040:
    case 0x00000050:

      r += snprintf (buf + r, size - r, ", %s", ABI_STRINGS[abi >> 4]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized ABI>");
      break;
    }

  switch (version)
    {
    case 0x0:
    case 0x1:
    case 0x2:
      r += snprintf (buf + r, size - r, ", %s", VER_STRINGS[version >> 0]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized ELF version number>");
      break;
    }

  if (0x00000000 == abi)
    {

      r += snprintf (buf + r, size - r, ", Andes Star v1.0, N1213HC, MAC, PERF1");
      if (arch == 0x10000000)
 r += snprintf (buf + r, size -r, ", 16b");
      return;
    }

  switch (arch)
    {
    case 0x10000000:
    case 0x20000000:
    case 0x30000000:
    case 0x40000000:
      r += snprintf (buf + r, size - r, ", %s", ARCH_STRINGS[arch >> 28]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized architecture>");


      return;
    }


  if (arch == 0x10000000)
    {
      if (config & 0x00000100)
 r += snprintf (buf + r, size -r, ", MFUSR_PC");

      if (!(config & 0x00100000))
 r += snprintf (buf + r, size -r, ", MAC");

      if (config & 0x00002000)
 r += snprintf (buf + r, size -r, ", DIV");

      if (config & 0x00004000)
 r += snprintf (buf + r, size -r, ", 16b");
    }
  else
    {
      if (config & 0x00000100)
 {
   if (version <= 0x1)
     r += snprintf (buf + r, size -r, ", [B8]");
   else
     r += snprintf (buf + r, size -r, ", EX9");
 }

      if (config & 0x00100000)
 r += snprintf (buf + r, size -r, ", MAC_DX");

      if (config & 0x00002000)
 r += snprintf (buf + r, size -r, ", DIV_DX");

      if (config & 0x00004000)
 {
   if (version <= 0x1)
     r += snprintf (buf + r, size -r, ", 16b");
   else
     r += snprintf (buf + r, size -r, ", IFC");
 }
    }

  if (config & 0x00000200)
    r += snprintf (buf + r, size -r, ", PERF1");

  if (config & 0x00000400)
    r += snprintf (buf + r, size -r, ", PERF2");

  if (config & 0x00000800)
    {
      has_fpu = 1;
      r += snprintf (buf + r, size -r, ", FPU_SP");
    }

  if (config & 0x00080000)
    {
      has_fpu = 1;
      r += snprintf (buf + r, size -r, ", FPU_DP");
    }

  if (config & 0x01000000)
    {
      has_fpu = 1;
      r += snprintf (buf + r, size -r, ", FPU_MAC");
    }

  if (has_fpu)
    {
      switch ((config & (0x3 << 22)) >> 22)
 {
 case 0x0:
   r += snprintf (buf + r, size -r, ", FPU_REG:8/4");
   break;
 case 0x1:
   r += snprintf (buf + r, size -r, ", FPU_REG:16/8");
   break;
 case 0x2:
   r += snprintf (buf + r, size -r, ", FPU_REG:32/16");
   break;
 case 0x3:
   r += snprintf (buf + r, size -r, ", FPU_REG:32/32");
   break;
 }
    }

  if (config & 0x00001000)
    r += snprintf (buf + r, size -r, ", AUDIO");

  if (config & 0x00008000)
    r += snprintf (buf + r, size -r, ", STR");

  if (config & 0x00010000)
    r += snprintf (buf + r, size -r, ", 16REG");

  if (config & 0x00020000)
    {
      if (version <= 0x1)
 r += snprintf (buf + r, size -r, ", VIDEO");
      else
 r += snprintf (buf + r, size -r, ", SATURATION");
    }

  if (config & 0x00040000)
    r += snprintf (buf + r, size -r, ", ENCRP");

  if (config & 0x00200000)
    r += snprintf (buf + r, size -r, ", L2C");
}

static char *
get_machine_flags (unsigned e_flags, unsigned e_machine)
{
  static char buf[1024];

  buf[0] = '\0';

  if (e_flags)
    {
      switch (e_machine)
 {
 default:
   break;

 case 195:
 case 93:
          decode_ARC_machine_flags (e_flags, e_machine, buf);
          break;

 case 40:
   decode_ARM_machine_flags (e_flags, buf);
   break;

        case 83:
          decode_AVR_machine_flags (e_flags, buf, sizeof buf);
          break;

 case 106:
   if (e_flags & 0x00000001)
     strcat (buf, ", PIC");

   if (e_flags & 0x00000002)
     strcat (buf, ", FDPIC");

   if (e_flags & 0x00000010)
     strcat (buf, ", code in L1");

   if (e_flags & 0x00000020)
     strcat (buf, ", data in L1");

   break;

 case 0x5441:
   switch (e_flags & 0xff000000)
     {
     case 0x00000000:
       break;

     default:
       strcat (buf, ", fr???");
       break;

     case 0x02000000:
       strcat (buf, ", fr300");
       break;

     case 0x05000000:
       strcat (buf, ", fr400");
       break;
     case 0x07000000:
       strcat (buf, ", fr405");
       break;

     case 0x08000000:
       strcat (buf, ", fr450");
       break;

     case 0x01000000:
       strcat (buf, ", fr500");
       break;
     case 0x06000000:
       strcat (buf, ", fr550");
       break;

     case 0x03000000:
       strcat (buf, ", simple");
       break;
     case 0x04000000:
       strcat (buf, ", tomcat");
       break;
     }
   break;

 case 4:
   if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x01000000)
     strcat (buf, ", m68000");
   else if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x00810000)
     strcat (buf, ", cpu32");
   else if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x02000000)
     strcat (buf, ", fido_a");
   else
     {
       char const * isa = gettext ("unknown");
       char const * mac = gettext ("unknown mac");
       char const * additional = 
# 3096 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 3096 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    ;

       switch (e_flags & 0x0F)
  {
  case 0x01:
    isa = "A";
    additional = ", nodiv";
    break;
  case 0x02:
    isa = "A";
    break;
  case 0x03:
    isa = "A+";
    break;
  case 0x04:
    isa = "B";
    additional = ", nousp";
    break;
  case 0x05:
    isa = "B";
    break;
  case 0x06:
    isa = "C";
    break;
  case 0x07:
    isa = "C";
    additional = ", nodiv";
    break;
  }
       strcat (buf, ", cf, isa ");
       strcat (buf, isa);
       if (additional)
  strcat (buf, additional);
       if (e_flags & 0x40)
  strcat (buf, ", float");
       switch (e_flags & 0x30)
  {
  case 0:
    mac = 
# 3134 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 3134 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ;
    break;
  case 0x10:
    mac = "mac";
    break;
  case 0x20:
    mac = "emac";
    break;
  case 0x30:
    mac = "emac_b";
    break;
  }
       if (mac)
  {
    strcat (buf, ", ");
    strcat (buf, mac);
  }
     }
   break;

 case 0xF00D:
   switch (e_flags & 0xff000000)
     {
     case 0x00000000: strcat (buf, ", generic MeP"); break;
     case 0x01000000: strcat (buf, ", MeP C2"); break;
     case 0x02000000: strcat (buf, ", MeP C3"); break;
     case 0x04000000: strcat (buf, ", MeP C4"); break;
     case 0x08000000: strcat (buf, ", MeP C5"); break;
     case 0x10000000: strcat (buf, ", MeP H1"); break;
     default: strcat (buf, gettext (", <unknown MeP cpu type>")); break;
     }

   switch (e_flags & 0x00ff0000)
     {
     case 0x00000000: break;
     case 0x00010000: strcat (buf, ", AVC coprocessor"); break;
     case 0x00020000: strcat (buf, ", AVC2 coprocessor"); break;
     case 0x00030000: strcat (buf, ", FMAX coprocessor"); break;
     case 0x00060000: strcat (buf, ", IVC2 coprocessor"); break;
     default: strcat (buf, gettext ("<unknown MeP copro type>")); break;
     }

   if (e_flags & 0x00000100)
     strcat (buf, ", Built for Library");

   if (e_flags & 0x000000ff)
     sprintf (buf + strlen (buf), ", Configuration Index: %#x",
       e_flags & 0x000000ff);

   if (e_flags & ~ 0xffff01ff)
     sprintf (buf + strlen (buf), gettext (", unknown flags bits: %#x"),
       e_flags & ~ 0xffff01ff);
   break;

 case 20:
   if (e_flags & 0x80000000)
     strcat (buf, ", emb");

   if (e_flags & 0x00010000)
     strcat (buf, gettext (", relocatable"));

   if (e_flags & 0x00008000)
     strcat (buf, gettext (", relocatable-lib"));
   break;

 case 21:
   if (e_flags & 3)
     {
       char abi[] = ", abiv0";

       abi[6] += e_flags & 3;
       strcat (buf, abi);
     }
   break;

 case 36:
   if ((e_flags & 0xF0000000) == 0xF0000000)
     strcat (buf, ", RH850 ABI");

   if (e_flags & 0x00100000)
     strcat (buf, ", V3 architecture");

   if ((e_flags & (0x00000001 | 0x00000002)) == 0)
     strcat (buf, ", FPU not used");

   if ((e_flags & (0x00000020 | 0x00000040)) == 0)
     strcat (buf, ", regmode: COMMON");

   if ((e_flags & (0x00000100 | 0x00000200)) == 0)
     strcat (buf, ", r4 not used");

   if ((e_flags & (0x00000400 | 0x00000800)) == 0)
     strcat (buf, ", r30 not used");

   if ((e_flags & (0x00001000 | 0x00002000)) == 0)
     strcat (buf, ", r5 not used");

   if ((e_flags & (0x00004000 | 0x00008000)) == 0)
     strcat (buf, ", r2 not used");

   for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
     {
       switch (e_flags & - e_flags)
  {
  case 0x00000001: strcat (buf, ", double precision FPU"); break;
  case 0x00000002: strcat (buf, ", single precision FPU"); break;
  case 0x00000020: strcat (buf, ", regmode:22"); break;
  case 0x00000040: strcat (buf, ", regmode:23"); break;
  case 0x00000100: strcat (buf, ", r4 fixed"); break;
  case 0x00000200: strcat (buf, ", r4 free"); break;
  case 0x00000400: strcat (buf, ", r30 fixed"); break;
  case 0x00000800: strcat (buf, ", r30 free"); break;
  case 0x00001000: strcat (buf, ", r5 fixed"); break;
  case 0x00002000: strcat (buf, ", r5 free"); break;
  case 0x00004000: strcat (buf, ", r2 fixed"); break;
  case 0x00008000: strcat (buf, ", r2 free"); break;
  default: break;
  }
     }
   break;

 case 87:
 case 0x9080:
   switch (e_flags & 0xf0000000)
     {
     case 0x60000000:
       strcat (buf, ", v850e3v5");
       break;
     case 0x40000000:
       strcat (buf, ", v850e2v3");
       break;
     case 0x30000000:
       strcat (buf, ", v850e2");
       break;
            case 0x20000000:
              strcat (buf, ", v850e1");
       break;
     case 0x10000000:
       strcat (buf, ", v850e");
       break;
     case 0x00000000:
       strcat (buf, ", v850");
       break;
     default:
       strcat (buf, gettext (", unknown v850 architecture variant"));
       break;
     }
   break;

 case 88:
 case 0x9041:
   if ((e_flags & 0x30000000) == 0x00000000)
     strcat (buf, ", m32r");
   break;

 case 8:
 case 10:
   if (e_flags & 0x00000001)
     strcat (buf, ", noreorder");

   if (e_flags & 0x00000002)
     strcat (buf, ", pic");

   if (e_flags & 0x00000004)
     strcat (buf, ", cpic");

   if (e_flags & 0x00000010)
     strcat (buf, ", ugen_reserved");

   if (e_flags & 0x00000020)
     strcat (buf, ", abi2");

   if (e_flags & 0x00000080)
     strcat (buf, ", odk first");

   if (e_flags & 0x00000100)
     strcat (buf, ", 32bitmode");

   if (e_flags & 0x00000400)
     strcat (buf, ", nan2008");

   if (e_flags & 0x00000200)
     strcat (buf, ", fp64");

   switch ((e_flags & 0x00FF0000))
     {
     case 0x00810000: strcat (buf, ", 3900"); break;
     case 0x00820000: strcat (buf, ", 4010"); break;
     case 0x00830000: strcat (buf, ", 4100"); break;
     case 0x00880000: strcat (buf, ", 4111"); break;
     case 0x00870000: strcat (buf, ", 4120"); break;
     case 0x00850000: strcat (buf, ", 4650"); break;
     case 0x00910000: strcat (buf, ", 5400"); break;
     case 0x00980000: strcat (buf, ", 5500"); break;
     case 0x008a0000: strcat (buf, ", sb1"); break;
     case 0x00990000: strcat (buf, ", 9000"); break;
       case 0x00A00000: strcat (buf, ", loongson-2e"); break;
       case 0x00A10000: strcat (buf, ", loongson-2f"); break;
       case 0x00A20000: strcat (buf, ", loongson-3a"); break;
     case 0x008b0000: strcat (buf, ", octeon"); break;
     case 0x008d0000: strcat (buf, ", octeon2"); break;
     case 0x008e0000: strcat (buf, ", octeon3"); break;
     case 0x008c0000: strcat (buf, ", xlr"); break;
     case 0x00930000: strcat (buf, ", interaptiv-mr2"); break;
     case 0:



       break;
     default: strcat (buf, gettext (", unknown CPU")); break;
     }

   switch ((e_flags & 0x0000F000))
     {
     case 0x00001000: strcat (buf, ", o32"); break;
     case 0x00002000: strcat (buf, ", o64"); break;
     case 0x00003000: strcat (buf, ", eabi32"); break;
     case 0x00004000: strcat (buf, ", eabi64"); break;
     case 0:




       break;
     default: strcat (buf, gettext (", unknown ABI")); break;
     }

   if (e_flags & 0x08000000)
     strcat (buf, ", mdmx");

   if (e_flags & 0x04000000)
     strcat (buf, ", mips16");

   if (e_flags & 0x02000000)
     strcat (buf, ", micromips");

   switch ((e_flags & 0xf0000000))
     {
     case 0x00000000: strcat (buf, ", mips1"); break;
     case 0x10000000: strcat (buf, ", mips2"); break;
     case 0x20000000: strcat (buf, ", mips3"); break;
     case 0x30000000: strcat (buf, ", mips4"); break;
     case 0x40000000: strcat (buf, ", mips5"); break;
     case 0x50000000: strcat (buf, ", mips32"); break;
     case 0x70000000: strcat (buf, ", mips32r2"); break;
     case 0x90000000: strcat (buf, ", mips32r6"); break;
     case 0x60000000: strcat (buf, ", mips64"); break;
     case 0x80000000: strcat (buf, ", mips64r2"); break;
     case 0xa0000000: strcat (buf, ", mips64r6"); break;
     default: strcat (buf, gettext (", unknown ISA")); break;
     }
   break;

 case 167:
   decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
   break;

 case 243:
   if (e_flags & 0x0001)
     strcat (buf, ", RVC");

   switch (e_flags & 0x0006)
     {
     case 0x0000:
       strcat (buf, ", soft-float ABI");
       break;

     case 0x0002:
       strcat (buf, ", single-float ABI");
       break;

     case 0x0004:
       strcat (buf, ", double-float ABI");
       break;

     case 0x0006:
       strcat (buf, ", quad-float ABI");
       break;
     }
   break;

 case 42:
   switch ((e_flags & 0x1f))
     {
     case 1: strcat (buf, ", sh1"); break;
     case 2: strcat (buf, ", sh2"); break;
     case 3: strcat (buf, ", sh3"); break;
     case 4: strcat (buf, ", sh-dsp"); break;
     case 5: strcat (buf, ", sh3-dsp"); break;
     case 6: strcat (buf, ", sh4al-dsp"); break;
     case 8: strcat (buf, ", sh3e"); break;
     case 9: strcat (buf, ", sh4"); break;
     case 10: strcat (buf, ", sh5"); break;
     case 11: strcat (buf, ", sh2e"); break;
     case 12: strcat (buf, ", sh4a"); break;
     case 13: strcat (buf, ", sh2a"); break;
     case 16: strcat (buf, ", sh4-nofpu"); break;
     case 17: strcat (buf, ", sh4a-nofpu"); break;
     case 19: strcat (buf, ", sh2a-nofpu"); break;
     case 20: strcat (buf, ", sh3-nommu"); break;
     case 18: strcat (buf, ", sh4-nommu-nofpu"); break;
     case 21: strcat (buf, ", sh2a-nofpu-or-sh4-nommu-nofpu"); break;
     case 22: strcat (buf, ", sh2a-nofpu-or-sh3-nommu"); break;
     case 23: strcat (buf, ", sh2a-or-sh4"); break;
     case 24: strcat (buf, ", sh2a-or-sh3e"); break;
     default: strcat (buf, gettext (", unknown ISA")); break;
     }

   if (e_flags & 0x100)
     strcat (buf, ", pic");

   if (e_flags & 0x8000)
     strcat (buf, ", fdpic");
   break;

        case 92:
          if (e_flags & (1UL << 0))
            strcat (buf, ", no delay");
          break;

 case 43:
   if (e_flags & 0x000100)
     strcat (buf, ", v8+");

   if (e_flags & 0x000200)
     strcat (buf, ", ultrasparcI");

   if (e_flags & 0x000800)
     strcat (buf, ", ultrasparcIII");

   if (e_flags & 0x000400)
     strcat (buf, ", halr1");

   if (e_flags & 0x800000)
     strcat (buf, ", ledata");

   if ((e_flags & 0x3) == 0x0)
     strcat (buf, ", tso");

   if ((e_flags & 0x3) == 0x1)
     strcat (buf, ", pso");

   if ((e_flags & 0x3) == 0x2)
     strcat (buf, ", rmo");
   break;

 case 15:
   switch (e_flags & 0x0000ffff)
     {
     case 0x020b:
       strcpy (buf, ", PA-RISC 1.0");
       break;
     case 0x0210:
       strcpy (buf, ", PA-RISC 1.1");
       break;
     case 0x0214:
       strcpy (buf, ", PA-RISC 2.0");
       break;
     default:
       break;
     }
   if (e_flags & 0x00010000)
     strcat (buf, ", trapnil");
   if (e_flags & 0x00020000)
     strcat (buf, ", ext");
   if (e_flags & 0x00040000)
     strcat (buf, ", lsb");
   if (e_flags & 0x00080000)
     strcat (buf, ", wide");
   if (e_flags & 0x00100000)
     strcat (buf, ", no kabp");
   if (e_flags & 0x00400000)
     strcat (buf, ", lazyswap");
   break;

 case 91:
 case 99:
   if ((e_flags & 0x00000010) == 0x00000010)
     strcat (buf, ", new calling convention");

   if ((e_flags & 0x00000020) == 0x00000020)
     strcat (buf, ", gnu calling convention");
   break;

 case 50:
   if ((e_flags & (1 << 4)))
     strcat (buf, ", 64-bit");
   else
     strcat (buf, ", 32-bit");
   if ((e_flags & (1 << 5)))
     strcat (buf, ", reduced fp model");
   if ((e_flags & (1 << 7)))
     strcat (buf, ", no function descriptors, constant gp");
   else if ((e_flags & (1 << 6)))
     strcat (buf, ", constant gp");
   if ((e_flags & (1 << 8)))
     strcat (buf, ", absolute");
          if (elf_header.e_ident[7] == 13)
            {
              if ((e_flags & 0x04))
                strcat (buf, ", vms_linkages");
              switch ((e_flags & 0x03))
                {
                case 0:
                  break;
                case 1:
                  strcat (buf, ", warning");
                  break;
                case 2:
                  strcat (buf, ", error");
                  break;
                case 3:
                  strcat (buf, ", abort");
                  break;
                default:
    warn (gettext ("Unrecognised IA64 VMS Command Code: %x\n"),
   e_flags & 0x03);
    strcat (buf, ", <unknown>");
                }
            }
   break;

 case 75:
   if ((e_flags & 0x0001))
     strcat (buf, ", non-PIC");
   if ((e_flags & 0x0100))
     strcat (buf, ", D-Float");
   if ((e_flags & 0x0200))
     strcat (buf, ", G-Float");
   break;

        case 221:
   if (e_flags & 0x01)
     strcat (buf, ", mcm");
   else if (e_flags & 0x02)
     strcat (buf, ", mcm24");
   if (e_flags & 0x04)
     strcat (buf, ", gr6");
   break;

 case 197:
   switch (e_flags & 0x0c)
     {
     case 0x00: break;
     case 0x04: strcat (buf, ", G10"); break;
     case 0x08: strcat (buf, ", G13"); break;
     case 0x0c: strcat (buf, ", G14"); break;
     }
   if (e_flags & (1 << 0))
     strcat (buf, ", 64-bit doubles");
   break;

 case 173:
   if (e_flags & (1 << 0))
     strcat (buf, ", 64-bit doubles");
   if (e_flags & (1 << 1))
     strcat (buf, ", dsp");
   if (e_flags & (1 << 2))
     strcat (buf, ", pid");
   if (e_flags & (1 << 3))
     strcat (buf, ", RX ABI");
   if (e_flags & (1 << 6))
     strcat (buf, e_flags & (1 << 7)
      ? ", uses String instructions" : ", bans String instructions");
   if (e_flags & (1 << 8))
     strcat (buf, ", V2");
   break;

 case 22:
   if (e_flags & 0x00000001)
     strcat (buf, ", highgprs");
   break;

 case 140:
   if ((e_flags & 0x1))
     strcat (buf, ", relocatable module");
   break;

 case 105:
   strcat (buf, gettext (": architecture variant: "));
   switch (e_flags & 0xff)
     {
     case 11: strcat (buf, "MSP430x11"); break;
     case 110 : strcat (buf, "MSP430x11x1 "); break;
     case 12: strcat (buf, "MSP430x12"); break;
     case 13: strcat (buf, "MSP430x13"); break;
     case 14: strcat (buf, "MSP430x14"); break;
     case 15: strcat (buf, "MSP430x15"); break;
     case 16: strcat (buf, "MSP430x16"); break;
     case 31: strcat (buf, "MSP430x31"); break;
     case 32: strcat (buf, "MSP430x32"); break;
     case 33: strcat (buf, "MSP430x33"); break;
     case 41: strcat (buf, "MSP430x41"); break;
     case 42: strcat (buf, "MSP430x42"); break;
     case 43: strcat (buf, "MSP430x43"); break;
     case 44: strcat (buf, "MSP430x44"); break;
     case 45 : strcat (buf, "MSP430X"); break;
     default:
       strcat (buf, gettext (": unknown")); break;
     }

   if (e_flags & ~ 0xff)
     strcat (buf, gettext (": unknown extra flag bits also present"));
 }
    }

  return buf;
}

static const char *
get_osabi_name (unsigned int osabi)
{
  static char buff[32];

  switch (osabi)
    {
    case 0: return "UNIX - System V";
    case 1: return "UNIX - HP-UX";
    case 2: return "UNIX - NetBSD";
    case 3: return "UNIX - GNU";
    case 6: return "UNIX - Solaris";
    case 7: return "UNIX - AIX";
    case 8: return "UNIX - IRIX";
    case 9: return "UNIX - FreeBSD";
    case 10: return "UNIX - TRU64";
    case 11: return "Novell - Modesto";
    case 12: return "UNIX - OpenBSD";
    case 13: return "VMS - OpenVMS";
    case 14: return "HP - Non-Stop Kernel";
    case 15: return "AROS";
    case 16: return "FenixOS";
    case 17: return "Nuxi CloudABI";
    case 18: return "Stratus Technologies OpenVOS";
    default:
      if (osabi >= 64)
 switch (elf_header.e_machine)
   {
   case 40:
     switch (osabi)
       {
       case 97: return "ARM";
       default:
  break;
       }
     break;

   case 105:
   case 0x1059:
   case 221:
     switch (osabi)
       {
       case 255: return gettext ("Standalone App");
       default:
  break;
       }
     break;

   case 140:
     switch (osabi)
       {
       case 64: return gettext ("Bare-metal C6000");
       case 65: return "Linux C6000";
       default:
  break;
       }
     break;

   default:
     break;
   }
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), osabi);
      return buff;
    }
}

static const char *
get_aarch64_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "AARCH64_ARCHEXT";
    default: return 
# 3715 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    ((void *)0)
# 3715 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        ;
    }
}

static const char *
get_arm_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 1): return "EXIDX";
    default: return 
# 3725 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0)
# 3725 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 ;
    }
}

static const char *
get_s390_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "S390_PGSTE";
    default: return 
# 3735 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 3735 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
    }
}

static const char *
get_mips_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "REGINFO";
    case 0x70000001: return "RTPROC";
    case 0x70000002: return "OPTIONS";
    case 0x70000003: return "ABIFLAGS";
    default: return 
# 3748 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 3748 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      ;
    }
}

static const char *
get_parisc_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x60000000 + 0x0): return "HP_TLS";
    case (0x60000000 + 0x1): return "HP_CORE_NONE";
    case (0x60000000 + 0x2): return "HP_CORE_VERSION";
    case (0x60000000 + 0x3): return "HP_CORE_KERNEL";
    case (0x60000000 + 0x4): return "HP_CORE_COMM";
    case (0x60000000 + 0x5): return "HP_CORE_PROC";
    case (0x60000000 + 0x6): return "HP_CORE_LOADABLE";
    case (0x60000000 + 0x7): return "HP_CORE_STACK";
    case (0x60000000 + 0x8): return "HP_CORE_SHM";
    case (0x60000000 + 0x9): return "HP_CORE_MMF";
    case (0x60000000 + 0x10): return "HP_PARALLEL";
    case (0x60000000 + 0x11): return "HP_FASTBIND";
    case (0x60000000 + 0x12): return "HP_OPT_ANNOT";
    case (0x60000000 + 0x13): return "HP_HSL_ANNOT";
    case (0x60000000 + 0x14): return "HP_STACK";
    case (0x60000000 + 0x15): return "HP_CORE_UTSNAME";
    case 0x70000000: return "PARISC_ARCHEXT";
    case 0x70000001: return "PARISC_UNWIND";
    case 0x70000002: return "PARISC_WEAKORDER";
    default: return 
# 3776 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 3776 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;
    }
}

static const char *
get_ia64_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "IA_64_ARCHEXT";
    case (0x70000000 + 1): return "IA_64_UNWIND";
    case (0x60000000 + 0x0): return "HP_TLS";
    case (0x60000000 + 0x12): return "HP_OPT_ANNOT";
    case (0x60000000 + 0x13): return "HP_HSL_ANNOT";
    case (0x60000000 + 0x14): return "HP_STACK";
    default: return 
# 3791 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 3791 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;
    }
}

static const char *
get_tic6x_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "C6000_PHATTR";
    default: return 
# 3801 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 3801 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     ;
    }
}

static const char *
get_solaris_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x6464e550: return "PT_SUNW_UNWIND";
    case 0x6474e550: return "PT_SUNW_EH_FRAME";
    case 0x6ffffff7: return "PT_LOSUNW";
    case 0x6ffffffa: return "PT_SUNWBSS";
    case 0x6ffffffb: return "PT_SUNWSTACK";
    case 0x6ffffffc: return "PT_SUNWDTRACE";
    case 0x6ffffffd: return "PT_SUNWCAP";
    case 0x6fffffff: return "PT_HISUNW";
    default: return 
# 3818 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 3818 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;
    }
}

static const char *
get_segment_type (unsigned long p_type)
{
  static char buff[32];

  switch (p_type)
    {
    case 0: return "NULL";
    case 1: return "LOAD";
    case 2: return "DYNAMIC";
    case 3: return "INTERP";
    case 4: return "NOTE";
    case 5: return "SHLIB";
    case 6: return "PHDR";
    case 7: return "TLS";
    case (0x60000000 + 0x474e550): return "GNU_EH_FRAME";
    case (0x60000000 + 0x474e551): return "GNU_STACK";
    case (0x60000000 + 0x474e552): return "GNU_RELRO";

    default:
      if (p_type >= (0x60000000 + 0x474e555) && p_type <= ((0x60000000 + 0x474e555) + 4096 - 1))
 {
   sprintf (buff, "GNU_MBIND+%#lx",
     p_type - (0x60000000 + 0x474e555));
 }
      else if ((p_type >= 0x70000000) && (p_type <= 0x7FFFFFFF))
 {
   const char * result;

   switch (elf_header.e_machine)
     {
     case 183:
       result = get_aarch64_segment_type (p_type);
       break;
     case 40:
       result = get_arm_segment_type (p_type);
       break;
     case 8:
     case 10:
       result = get_mips_segment_type (p_type);
       break;
     case 15:
       result = get_parisc_segment_type (p_type);
       break;
     case 50:
       result = get_ia64_segment_type (p_type);
       break;
     case 140:
       result = get_tic6x_segment_type (p_type);
       break;
     case 22:
     case 0xa390:
       result = get_s390_segment_type (p_type);
       break;
     default:
       result = 
# 3877 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 3877 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
       break;
     }

   if (result != 
# 3881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 3881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   sprintf (buff, "LOPROC+%#lx", p_type - 0x70000000);
 }
      else if ((p_type >= 0x60000000) && (p_type <= 0x6fffffff))
 {
   const char * result;

   switch (elf_header.e_machine)
     {
     case 15:
       result = get_parisc_segment_type (p_type);
       break;
     case 50:
       result = get_ia64_segment_type (p_type);
       break;
     default:
       if (elf_header.e_ident[7] == 6)
  result = get_solaris_segment_type (p_type);
       else
  result = 
# 3902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 3902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
       break;
     }

   if (result != 
# 3906 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 3906 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   sprintf (buff, "LOOS+%#lx", p_type - 0x60000000);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %lx"), p_type);

      return buff;
    }
}

static const char *
get_arc_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "ARC_ATTRIBUTES";
    default:
      break;
    }
  return 
# 3927 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 3927 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static const char *
get_mips_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "MIPS_LIBLIST";
    case 0x70000001: return "MIPS_MSYM";
    case 0x70000002: return "MIPS_CONFLICT";
    case 0x70000003: return "MIPS_GPTAB";
    case 0x70000004: return "MIPS_UCODE";
    case 0x70000005: return "MIPS_DEBUG";
    case 0x70000006: return "MIPS_REGINFO";
    case 0x70000007: return "MIPS_PACKAGE";
    case 0x70000008: return "MIPS_PACKSYM";
    case 0x70000009: return "MIPS_RELD";
    case 0x7000000b: return "MIPS_IFACE";
    case 0x7000000c: return "MIPS_CONTENT";
    case 0x7000000d: return "MIPS_OPTIONS";
    case 0x70000010: return "MIPS_SHDR";
    case 0x70000011: return "MIPS_FDESC";
    case 0x70000012: return "MIPS_EXTSYM";
    case 0x70000013: return "MIPS_DENSE";
    case 0x70000014: return "MIPS_PDESC";
    case 0x70000015: return "MIPS_LOCSYM";
    case 0x70000016: return "MIPS_AUXSYM";
    case 0x70000017: return "MIPS_OPTSYM";
    case 0x70000018: return "MIPS_LOCSTR";
    case 0x70000019: return "MIPS_LINE";
    case 0x7000001a: return "MIPS_RFDESC";
    case 0x7000001b: return "MIPS_DELTASYM";
    case 0x7000001c: return "MIPS_DELTAINST";
    case 0x7000001d: return "MIPS_DELTACLASS";
    case 0x7000001e: return "MIPS_DWARF";
    case 0x7000001f: return "MIPS_DELTADECL";
    case 0x70000020: return "MIPS_SYMBOL_LIB";
    case 0x70000021: return "MIPS_EVENTS";
    case 0x70000022: return "MIPS_TRANSLATE";
    case 0x70000023: return "MIPS_PIXIE";
    case 0x70000024: return "MIPS_XLATE";
    case 0x70000025: return "MIPS_XLATE_DEBUG";
    case 0x70000026: return "MIPS_WHIRL";
    case 0x70000027: return "MIPS_EH_REGION";
    case 0x70000028: return "MIPS_XLATE_OLD";
    case 0x70000029: return "MIPS_PDR_EXCEPTION";
    case 0x7000002a: return "MIPS_ABIFLAGS";
    default:
      break;
    }
  return 
# 3978 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 3978 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static const char *
get_parisc_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "PARISC_EXT";
    case 0x70000001: return "PARISC_UNWIND";
    case 0x70000002: return "PARISC_DOC";
    case 0x70000003: return "PARISC_ANNOT";
    case 0x70000000 + 8: return "PARISC_SYMEXTN";
    case 0x70000000 + 9: return "PARISC_STUBS";
    case 0x70000004: return "PARISC_DLKM";
    default: return 
# 3993 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 3993 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    ;
    }
}

static const char *
get_ia64_section_type_name (unsigned int sh_type)
{

  if ((sh_type & 0xFF000000) == (0x70000000 + 0x8000000))
    return get_osabi_name ((sh_type & 0x00FF0000) >> 16);

  switch (sh_type)
    {
    case (0x70000000 + 0): return "IA_64_EXT";
    case (0x70000000 + 1): return "IA_64_UNWIND";
    case (0x70000000 + 0x9000000): return "IA_64_PRIORITY_INIT";
    case 0x60000000: return "VMS_TRACE";
    case 0x60000001: return "VMS_TIE_SIGNATURES";
    case 0x60000002: return "VMS_DEBUG";
    case 0x60000003: return "VMS_DEBUG_STR";
    case 0x60000004: return "VMS_LINKAGES";
    case 0x60000005: return "VMS_SYMBOL_VECTOR";
    case 0x60000006: return "VMS_FIXUP";
    default:
      break;
    }
  return 
# 4019 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 4019 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static const char *
get_x86_64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "X86_64_UNWIND";
    default: return 
# 4028 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 4028 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;
    }
}

static const char *
get_aarch64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000003: return "AARCH64_ATTRIBUTES";
    default: return 
# 4038 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 4038 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          ;
    }
}

static const char *
get_arm_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "ARM_EXIDX";
    case 0x70000002: return "ARM_PREEMPTMAP";
    case 0x70000003: return "ARM_ATTRIBUTES";
    case 0x70000004: return "ARM_DEBUGOVERLAY";
    case 0x70000005: return "ARM_OVERLAYSECTION";
    default: return 
# 4052 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 4052 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }
}

static const char *
get_tic6x_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "C6000_UNWIND";
    case 0x70000002: return "C6000_PREEMPTMAP";
    case 0x70000003: return "C6000_ATTRIBUTES";
    case 0x7F000000: return "TI_ICODE";
    case 0x7F000001: return "TI_XREF";
    case 0x7F000002: return "TI_HANDLER";
    case 0x7F000003: return "TI_INITINFO";
    case 0x7F000004: return "TI_PHATTRS";
    default: return 
# 4069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 4069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;
    }
}

static const char *
get_msp430x_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x7f000005: return "MSP430_SEC_FLAGS";
    case 0x7f000006: return "MSP430_SYM_ALIASES";
    case 0x70000003: return "MSP430_ATTRIBUTES";
    default: return 
# 4081 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0)
# 4081 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            ;
    }
}

static const char *
get_v850_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "V850 Small Common";
    case 0x70000001: return "V850 Tiny Common";
    case 0x70000002: return "V850 Zero Common";
    case 0x80000000: return "RENESAS IOP";
    case 0xa0000000: return "RENESAS INFO";
    default: return 
# 4095 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 4095 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      ;
    }
}

static const char *
get_section_type_name (unsigned int sh_type)
{
  static char buff[32];
  const char * result;

  switch (sh_type)
    {
    case 0: return "NULL";
    case 1: return "PROGBITS";
    case 2: return "SYMTAB";
    case 3: return "STRTAB";
    case 4: return "RELA";
    case 5: return "HASH";
    case 6: return "DYNAMIC";
    case 7: return "NOTE";
    case 8: return "NOBITS";
    case 9: return "REL";
    case 10: return "SHLIB";
    case 11: return "DYNSYM";
    case 14: return "INIT_ARRAY";
    case 15: return "FINI_ARRAY";
    case 16: return "PREINIT_ARRAY";
    case 0x6ffffff6: return "GNU_HASH";
    case 17: return "GROUP";
    case 18: return "SYMTAB SECTION INDICIES";
    case 0x6ffffffd: return "VERDEF";
    case 0x6ffffffe: return "VERNEED";
    case 0x6fffffff: return "VERSYM";
    case 0x6ffffff0: return "VERSYM";
    case 0x6ffffffc: return "VERDEF";
    case 0x7ffffffd: return "AUXILIARY";
    case 0x7fffffff: return "FILTER";
    case 0x6ffffff7: return "GNU_LIBLIST";

    default:
      if ((sh_type >= 0x70000000) && (sh_type <= 0x7FFFFFFF))
 {
   switch (elf_header.e_machine)
     {
     case 45:
     case 93:
     case 195:
       result = get_arc_section_type_name (sh_type);
       break;
     case 8:
     case 10:
       result = get_mips_section_type_name (sh_type);
       break;
     case 15:
       result = get_parisc_section_type_name (sh_type);
       break;
     case 50:
       result = get_ia64_section_type_name (sh_type);
       break;
     case 62:
     case 180:
     case 181:
       result = get_x86_64_section_type_name (sh_type);
       break;
     case 183:
       result = get_aarch64_section_type_name (sh_type);
       break;
     case 40:
       result = get_arm_section_type_name (sh_type);
       break;
     case 140:
       result = get_tic6x_section_type_name (sh_type);
       break;
     case 105:
       result = get_msp430x_section_type_name (sh_type);
       break;
     case 36:
     case 87:
     case 0x9080:
       result = get_v850_section_type_name (sh_type);
       break;
     default:
       result = 
# 4177 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 4177 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
       break;
     }

   if (result != 
# 4181 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 4181 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   sprintf (buff, "LOPROC+%#x", sh_type - 0x70000000);
 }
      else if ((sh_type >= 0x60000000) && (sh_type <= 0x6fffffff))
 {
   switch (elf_header.e_machine)
     {
     case 50:
       result = get_ia64_section_type_name (sh_type);
       break;
     default:
       if (elf_header.e_ident[7] == 6)
  result = get_solaris_section_type (sh_type);
       else
  {
    switch (sh_type)
      {
      case 0x6fff4700: result = "GNU_INCREMENTAL_INPUTS"; break;
      case 0x6ffffff5: result = "GNU_ATTRIBUTES"; break;
      case 0x6ffffff6: result = "GNU_HASH"; break;
      case 0x6ffffff7: result = "GNU_LIBLIST"; break;
      default:
        result = 
# 4205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 4205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;
        break;
      }
  }
       break;
     }

   if (result != 
# 4212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 4212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   sprintf (buff, "LOOS+%#x", sh_type - 0x60000000);
 }
      else if ((sh_type >= 0x80000000) && (sh_type <= 0xFFFFFFFF))
 {
   switch (elf_header.e_machine)
     {
     case 36:
     case 87:
     case 0x9080:
       result = get_v850_section_type_name (sh_type);
       break;
     default:
       result = 
# 4227 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 4227 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
       break;
     }

   if (result != 
# 4231 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 4231 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     return result;

   sprintf (buff, "LOUSER+%#x", sh_type - 0x80000000);
 }
      else


 snprintf (buff, sizeof (buff), gettext ("%08x: <unknown>"), sh_type);

      return buff;
    }
}







static struct option options[] =
{
  {"all", 0, 0, 'a'},
  {"file-header", 0, 0, 'h'},
  {"program-headers", 0, 0, 'l'},
  {"headers", 0, 0, 'e'},
  {"histogram", 0, 0, 'I'},
  {"segments", 0, 0, 'l'},
  {"sections", 0, 0, 'S'},
  {"section-headers", 0, 0, 'S'},
  {"section-groups", 0, 0, 'g'},
  {"section-details", 0, 0, 't'},
  {"full-section-name",0, 0, 'N'},
  {"symbols", 0, 0, 's'},
  {"syms", 0, 0, 's'},
  {"dyn-syms", 0, 0, 513},
  {"relocs", 0, 0, 'r'},
  {"notes", 0, 0, 'n'},
  {"dynamic", 0, 0, 'd'},
  {"arch-specific", 0, 0, 'A'},
  {"version-info", 0, 0, 'V'},
  {"use-dynamic", 0, 0, 'D'},
  {"unwind", 0, 0, 'u'},
  {"archive-index", 0, 0, 'c'},
  {"hex-dump", 1, 0, 'x'},
  {"relocated-dump", 1, 0, 'R'},
  {"string-dump", 1, 0, 'p'},
  {"decompress", 0, 0, 'z'},



  {"debug-dump", 2, 0, 512},

  {"dwarf-depth", 1, 0, 514},
  {"dwarf-start", 1, 0, 515},
  {"dwarf-check", 0, 0, 516},

  {"version", 0, 0, 'v'},
  {"wide", 0, 0, 'W'},
  {"help", 0, 0, 'H'},
  {0, 0, 0, 0}
};

static void
usage (FILE * stream)
{
  fprintf (stream, gettext ("Usage: readelf <option(s)> elf-file(s)\n"));
  fprintf (stream, gettext (" Display information about the contents of ELF format files\n"));
  fprintf (stream, gettext (" Options are:\n  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n  -h --file-header       Display the ELF file header\n  -l --program-headers   Display the program headers\n     --segments          An alias for --program-headers\n  -S --section-headers   Display the sections' header\n     --sections          An alias for --section-headers\n  -g --section-groups    Display the section groups\n  -t --section-details   Display the section details\n  -e --headers           Equivalent to: -h -l -S\n  -s --syms              Display the symbol table\n     --symbols           An alias for --syms\n  --dyn-syms             Display the dynamic symbol table\n  -n --notes             Display the core notes (if present)\n  -r --relocs            Display the relocations (if present)\n  -u --unwind            Display the unwind info (if present)\n  -d --dynamic           Display the dynamic section (if present)\n  -V --version-info      Display the version sections (if present)\n  -A --arch-specific     Display architecture specific information (if any)\n  -c --archive-index     Display the symbol/file index in an archive\n  -D --use-dynamic       Use the dynamic section info when displaying symbols\n  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n  -R --relocated-dump=<number|name>\n                         Dump the contents of section <number|name> as relocated bytes\n  -z --decompress        Decompress section before dumping it\n  -w[lLiaprmfFsoRt] or\n  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n               =addr,=cu_index]\n                         Display the contents of DWARF2 debug sections\n")
# 4332 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                          );
  fprintf (stream, gettext ("  --dwarf-depth=N        Do not display DIEs at depth N or greater\n  --dwarf-start=N        Display DIEs starting with N, at the same depth\n                         or deeper\n")


                                      );





  fprintf (stream, gettext ("  -I --histogram         Display histogram of bucket list lengths\n  -W --wide              Allow output width to exceed 80 characters\n  @<file>                Read options from <file>\n  -H --help              Display this information\n  -v --version           Display the version number of readelf\n")




                                                                  );

  if ("<http://www.sourceware.org/bugzilla/>"[0] && stream == 
# 4349 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    stdout
# 4349 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          )
    fprintf (
# 4350 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            stdout
# 4350 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  , gettext ("Report bugs to %s\n"), "<http://www.sourceware.org/bugzilla/>");

  exit (stream == 
# 4352 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout 
# 4352 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ? 0 : 1);
}






static void
request_dump_bynumber (unsigned int section, dump_type type)
{
  if (section >= num_dump_sects)
    {
      dump_type * new_dump_sects;

      new_dump_sects = (dump_type *) calloc (section + 1,
                                             sizeof (* dump_sects));

      if (new_dump_sects == 
# 4370 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 4370 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
 error (gettext ("Out of memory allocating dump request table.\n"));
      else
 {
   if (dump_sects)
     {

       memcpy (new_dump_sects, dump_sects, num_dump_sects * sizeof (* dump_sects));

       free (dump_sects);
     }

   dump_sects = new_dump_sects;
   num_dump_sects = section + 1;
 }
    }

  if (dump_sects)
    dump_sects[section] |= type;

  return;
}



static void
request_dump_byname (const char * section, dump_type type)
{
  struct dump_list_entry * new_request;

  new_request = (struct dump_list_entry *)
      malloc (sizeof (struct dump_list_entry));
  if (!new_request)
    error (gettext ("Out of memory allocating dump request table.\n"));

  new_request->name = strdup (section);
  if (!new_request->name)
    error (gettext ("Out of memory allocating dump request table.\n"));

  new_request->type = type;

  new_request->next = dump_sects_byname;
  dump_sects_byname = new_request;
}

static inline void
request_dump (dump_type type)
{
  int section;
  char * cp;

  do_dump++;
  section = strtoul (optarg, & cp, 0);

  if (! *cp && section >= 0)
    request_dump_bynumber (section, type);
  else
    request_dump_byname (optarg, type);
}


static void
parse_args (int argc, char ** argv)
{
  int c;

  if (argc < 2)
    usage (
# 4437 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          stderr
# 4437 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                );

  while ((c = getopt_long
   (argc, argv, "ADHINR:SVWacdeghi:lnp:rstuvw::x:z", options, 
# 4440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                             ((void *)0)
# 4440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                 )) != 
# 4440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                       (-1)
# 4440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                          )
    {
      switch (c)
 {
 case 0:

   break;
 case 'H':
   usage (
# 4448 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         stdout
# 4448 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               );
   break;

 case 'a':
   do_syms = 1;
   do_reloc = 1;
   do_unwind = 1;
   do_dynamic = 1;
   do_header = 1;
   do_sections = 1;
   do_section_groups = 1;
   do_segments = 1;
   do_version = 1;
   do_histogram = 1;
   do_arch = 1;
   do_notes = 1;
   break;
 case 'g':
   do_section_groups = 1;
   break;
 case 't':
 case 'N':
   do_sections = 1;
   do_section_details = 1;
   break;
 case 'e':
   do_header = 1;
   do_sections = 1;
   do_segments = 1;
   break;
 case 'A':
   do_arch = 1;
   break;
 case 'D':
   do_using_dynamic = 1;
   break;
 case 'r':
   do_reloc = 1;
   break;
 case 'u':
   do_unwind = 1;
   break;
 case 'h':
   do_header = 1;
   break;
 case 'l':
   do_segments = 1;
   break;
 case 's':
   do_syms = 1;
   break;
 case 'S':
   do_sections = 1;
   break;
 case 'd':
   do_dynamic = 1;
   break;
 case 'I':
   do_histogram = 1;
   break;
 case 'n':
   do_notes = 1;
   break;
 case 'c':
   do_archive_index = 1;
   break;
 case 'x':
   request_dump ((1 << 0));
   break;
 case 'p':
   request_dump ((1 << 3));
   break;
 case 'R':
   request_dump ((1 << 4));
   break;
 case 'z':
   decompress_dumps = 1;
   break;
 case 'w':
   do_dump = 1;
   if (optarg == 0)
     {
       do_debugging = 1;
       dwarf_select_sections_all ();
     }
   else
     {
       do_debugging = 0;
       dwarf_select_sections_by_letters (optarg);
     }
   break;
 case 512:
   do_dump = 1;
   if (optarg == 0)
     do_debugging = 1;
   else
     {
       do_debugging = 0;
       dwarf_select_sections_by_names (optarg);
     }
   break;
 case 514:
   {
     char *cp;

     dwarf_cutoff_level = strtoul (optarg, & cp, 0);
   }
   break;
 case 515:
   {
     char *cp;

     dwarf_start_die = strtoul (optarg, & cp, 0);
   }
   break;
 case 516:
   dwarf_check = 1;
   break;
 case 513:
   do_dyn_syms = 1;
   break;





 case 'v':
   print_version (program_name);
   break;
 case 'V':
   do_version = 1;
   break;
 case 'W':
   do_wide = 1;
   break;
 default:

   error (gettext ("Invalid option '-%c'\n"), c);

 case '?':
   usage (
# 4588 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         stderr
# 4588 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               );
 }
    }

  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
      && !do_segments && !do_header && !do_dump && !do_version
      && !do_histogram && !do_debugging && !do_arch && !do_notes
      && !do_section_groups && !do_archive_index
      && !do_dyn_syms)
    usage (
# 4597 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          stderr
# 4597 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                );
}

static const char *
get_elf_class (unsigned int elf_class)
{
  static char buff[32];

  switch (elf_class)
    {
    case 0: return gettext ("none");
    case 1: return "ELF32";
    case 2: return "ELF64";
    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), elf_class);
      return buff;
    }
}

static const char *
get_data_encoding (unsigned int encoding)
{
  static char buff[32];

  switch (encoding)
    {
    case 0: return gettext ("none");
    case 1: return gettext ("2's complement, little endian");
    case 2: return gettext ("2's complement, big endian");
    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), encoding);
      return buff;
    }
}



static bfd_boolean
process_file_header (void)
{
  if ( elf_header.e_ident[0] != 0x7F
      || elf_header.e_ident[1] != 'E'
      || elf_header.e_ident[2] != 'L'
      || elf_header.e_ident[3] != 'F')
    {
      error
 (gettext ("Not an ELF file - it has the wrong magic bytes at the start\n"));
      return 0;
    }

  init_dwarf_regnames (elf_header.e_machine);

  if (do_header)
    {
      unsigned i;

      printf (gettext ("ELF Header:\n"));
      printf (gettext ("  Magic:   "));
      for (i = 0; i < 16; i++)
 printf ("%2.2x ", elf_header.e_ident[i]);
      printf ("\n");
      printf (gettext ("  Class:                             %s\n"),
       get_elf_class (elf_header.e_ident[4]));
      printf (gettext ("  Data:                              %s\n"),
       get_data_encoding (elf_header.e_ident[5]));
      printf (gettext ("  Version:                           %d %s\n"),
       elf_header.e_ident[6],
       (elf_header.e_ident[6] == 1
        ? "(current)"
        : (elf_header.e_ident[6] != 0
    ? gettext ("<unknown: %lx>")
    : "")));
      printf (gettext ("  OS/ABI:                            %s\n"),
       get_osabi_name (elf_header.e_ident[7]));
      printf (gettext ("  ABI Version:                       %d\n"),
       elf_header.e_ident[8]);
      printf (gettext ("  Type:                              %s\n"),
       get_file_type (elf_header.e_type));
      printf (gettext ("  Machine:                           %s\n"),
       get_machine_name (elf_header.e_machine));
      printf (gettext ("  Version:                           0x%lx\n"),
       (unsigned long) elf_header.e_version);

      printf (gettext ("  Entry point address:               "));
      print_vma ((bfd_vma) elf_header.e_entry, PREFIX_HEX);
      printf (gettext ("\n  Start of program headers:          "));
      print_vma ((bfd_vma) elf_header.e_phoff, DEC);
      printf (gettext (" (bytes into file)\n  Start of section headers:          "));
      print_vma ((bfd_vma) elf_header.e_shoff, DEC);
      printf (gettext (" (bytes into file)\n"));

      printf (gettext ("  Flags:                             0x%lx%s\n"),
       (unsigned long) elf_header.e_flags,
       get_machine_flags (elf_header.e_flags, elf_header.e_machine));
      printf (gettext ("  Size of this header:               %ld (bytes)\n"),
       (long) elf_header.e_ehsize);
      printf (gettext ("  Size of program headers:           %ld (bytes)\n"),
       (long) elf_header.e_phentsize);
      printf (gettext ("  Number of program headers:         %ld"),
       (long) elf_header.e_phnum);
      if (section_headers != 
# 4697 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
   
# 4698 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  && elf_header.e_phnum == 0xffff
   && section_headers[0].sh_info != 0)
 printf (" (%ld)", (long) section_headers[0].sh_info);
      putc ('\n', 
# 4701 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 4701 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
      printf (gettext ("  Size of section headers:           %ld (bytes)\n"),
       (long) elf_header.e_shentsize);
      printf (gettext ("  Number of section headers:         %ld"),
       (long) elf_header.e_shnum);
      if (section_headers != 
# 4706 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0) 
# 4706 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 && elf_header.e_shnum == 0)
 printf (" (%ld)", (long) section_headers[0].sh_size);
      putc ('\n', 
# 4708 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 4708 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
      printf (gettext ("  Section header string table index: %ld"),
       (long) elf_header.e_shstrndx);
      if (section_headers != 
# 4711 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
   
# 4712 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  && elf_header.e_shstrndx == ((-0x1u) & 0xffff))
 printf (" (%u)", section_headers[0].sh_link);
      else if (elf_header.e_shstrndx != 0
        && elf_header.e_shstrndx >= elf_header.e_shnum)
 printf (gettext (" <corrupt: out of range>"));
      putc ('\n', 
# 4717 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 4717 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
    }

  if (section_headers != 
# 4720 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 4720 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      if (elf_header.e_phnum == 0xffff
   && section_headers[0].sh_info != 0)
 elf_header.e_phnum = section_headers[0].sh_info;
      if (elf_header.e_shnum == 0)
 elf_header.e_shnum = section_headers[0].sh_size;
      if (elf_header.e_shstrndx == ((-0x1u) & 0xffff))
 elf_header.e_shstrndx = section_headers[0].sh_link;
      else if (elf_header.e_shstrndx >= elf_header.e_shnum)
 elf_header.e_shstrndx = 0;
      free (section_headers);
      section_headers = 
# 4732 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 4732 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }

  return 1;
}

static bfd_boolean
get_32bit_program_headers (FILE * file, Elf_Internal_Phdr * pheaders)
{
  Elf32_External_Phdr * phdrs;
  Elf32_External_Phdr * external;
  Elf_Internal_Phdr * internal;
  unsigned int i;
  unsigned int size = elf_header.e_phentsize;
  unsigned int num = elf_header.e_phnum;


  if (size == 0 || num == 0)
    return 0;
  if (size < sizeof * phdrs)
    {
      error (gettext ("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
      return 0;
    }
  if (size > sizeof * phdrs)
    warn (gettext ("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));

  phdrs = (Elf32_External_Phdr *) get_data (
# 4759 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 4759 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               , file, elf_header.e_phoff,
                                            size, num, gettext ("program headers"));
  if (phdrs == 
# 4761 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 4761 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    return 0;

  for (i = 0, internal = pheaders, external = phdrs;
       i < elf_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type = byte_get (external->p_type, sizeof (external->p_type));
      internal->p_offset = byte_get (external->p_offset, sizeof (external->p_offset));
      internal->p_vaddr = byte_get (external->p_vaddr, sizeof (external->p_vaddr));
      internal->p_paddr = byte_get (external->p_paddr, sizeof (external->p_paddr));
      internal->p_filesz = byte_get (external->p_filesz, sizeof (external->p_filesz));
      internal->p_memsz = byte_get (external->p_memsz, sizeof (external->p_memsz));
      internal->p_flags = byte_get (external->p_flags, sizeof (external->p_flags));
      internal->p_align = byte_get (external->p_align, sizeof (external->p_align));
    }

  free (phdrs);
  return 1;
}

static bfd_boolean
get_64bit_program_headers (FILE * file, Elf_Internal_Phdr * pheaders)
{
  Elf64_External_Phdr * phdrs;
  Elf64_External_Phdr * external;
  Elf_Internal_Phdr * internal;
  unsigned int i;
  unsigned int size = elf_header.e_phentsize;
  unsigned int num = elf_header.e_phnum;


  if (size == 0 || num == 0)
    return 0;
  if (size < sizeof * phdrs)
    {
      error (gettext ("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
      return 0;
    }
  if (size > sizeof * phdrs)
    warn (gettext ("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));

  phdrs = (Elf64_External_Phdr *) get_data (
# 4803 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 4803 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               , file, elf_header.e_phoff,
                                            size, num, gettext ("program headers"));
  if (!phdrs)
    return 0;

  for (i = 0, internal = pheaders, external = phdrs;
       i < elf_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type = byte_get (external->p_type, sizeof (external->p_type));
      internal->p_flags = byte_get (external->p_flags, sizeof (external->p_flags));
      internal->p_offset = byte_get (external->p_offset, sizeof (external->p_offset));
      internal->p_vaddr = byte_get (external->p_vaddr, sizeof (external->p_vaddr));
      internal->p_paddr = byte_get (external->p_paddr, sizeof (external->p_paddr));
      internal->p_filesz = byte_get (external->p_filesz, sizeof (external->p_filesz));
      internal->p_memsz = byte_get (external->p_memsz, sizeof (external->p_memsz));
      internal->p_align = byte_get (external->p_align, sizeof (external->p_align));
    }

  free (phdrs);
  return 1;
}



static bfd_boolean
get_program_headers (FILE * file)
{
  Elf_Internal_Phdr * phdrs;


  if (program_headers != 
# 4834 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 4834 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    return 1;



  if (elf_header.e_phnum
      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
      >= current_file_size)
    {
      error (gettext ("Too many program headers - %#x - the file is not that big\n"),
      elf_header.e_phnum);
      return 0;
    }

  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
      sizeof (Elf_Internal_Phdr));
  if (phdrs == 
# 4850 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 4850 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %u program headers\n"),
      elf_header.e_phnum);
      return 0;
    }

  if (is_32bit_elf
      ? get_32bit_program_headers (file, phdrs)
      : get_64bit_program_headers (file, phdrs))
    {
      program_headers = phdrs;
      return 1;
    }

  free (phdrs);
  return 0;
}



static bfd_boolean
process_program_headers (FILE * file)
{
  Elf_Internal_Phdr * segment;
  unsigned int i;
  Elf_Internal_Phdr * previous_load = 
# 4876 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 4876 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         ;

  if (elf_header.e_phnum == 0)
    {

      if (elf_header.e_phoff != 0)
 {
   warn (gettext ("possibly corrupt ELF header - it has a non-zero program" " header offset, but no program headers\n")
                                               );
   return 0;
 }
      else if (do_segments)
 printf (gettext ("\nThere are no program headers in this file.\n"));
      return 1;
    }

  if (do_segments && !do_header)
    {
      printf (gettext ("\nElf file type is %s\n"), get_file_type (elf_header.e_type));
      printf (gettext ("Entry point "));
      print_vma ((bfd_vma) elf_header.e_entry, PREFIX_HEX);
      printf (gettext ("\nThere are %d program headers, starting at offset "),
       elf_header.e_phnum);
      print_vma ((bfd_vma) elf_header.e_phoff, DEC);
      printf ("\n");
    }

  if (! get_program_headers (file))
    return 1;

  if (do_segments)
    {
      if (elf_header.e_phnum > 1)
 printf (gettext ("\nProgram Headers:\n"));
      else
 printf (gettext ("\nProgram Headers:\n"));

      if (is_32bit_elf)
 printf
   (gettext ("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
      else if (do_wide)
 printf
   (gettext ("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"));
      else
 {
   printf
     (gettext ("  Type           Offset             VirtAddr           PhysAddr\n"));
   printf
     (gettext ("                 FileSiz            MemSiz              Flags  Align\n"));
 }
    }

  dynamic_addr = 0;
  dynamic_size = 0;

  for (i = 0, segment = program_headers;
       i < elf_header.e_phnum;
       i++, segment++)
    {
      if (do_segments)
 {
   printf ("  %-14.14s ", get_segment_type (segment->p_type));

   if (is_32bit_elf)
     {
       printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
       printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
       printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
       printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
       printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
       printf ("%c%c%c ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));
       printf ("%#lx", (unsigned long) segment->p_align);
     }
   else if (do_wide)
     {
       if ((unsigned long) segment->p_offset == segment->p_offset)
  printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
       else
  {
    print_vma (segment->p_offset, FULL_HEX);
    putchar (' ');
  }

       print_vma (segment->p_vaddr, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_paddr, FULL_HEX);
       putchar (' ');

       if ((unsigned long) segment->p_filesz == segment->p_filesz)
  printf ("0x%6.6lx ", (unsigned long) segment->p_filesz);
       else
  {
    print_vma (segment->p_filesz, FULL_HEX);
    putchar (' ');
  }

       if ((unsigned long) segment->p_memsz == segment->p_memsz)
  printf ("0x%6.6lx", (unsigned long) segment->p_memsz);
       else
  {
    print_vma (segment->p_memsz, FULL_HEX);
  }

       printf (" %c%c%c ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));

       if ((unsigned long) segment->p_align == segment->p_align)
  printf ("%#lx", (unsigned long) segment->p_align);
       else
  {
    print_vma (segment->p_align, PREFIX_HEX);
  }
     }
   else
     {
       print_vma (segment->p_offset, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_vaddr, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_paddr, FULL_HEX);
       printf ("\n                 ");
       print_vma (segment->p_filesz, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_memsz, FULL_HEX);
       printf ("  %c%c%c    ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));
       print_vma (segment->p_align, PREFIX_HEX);
     }

   putc ('\n', 
# 5012 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              stdout
# 5012 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    );
 }

      switch (segment->p_type)
 {
 case 1:







   if (segment->p_memsz < segment->p_filesz)
     error (gettext ("the segment's file size is larger than its memory size\n"));
   previous_load = segment;
   break;

 case 6:

   if (i > 0 && previous_load != 
# 5032 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 5032 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    )
     error (gettext ("the PHDR segment must occur before any LOAD segment\n"));
   if (elf_header.e_machine != 15)
     {
       unsigned int j;

       for (j = 1; j < elf_header.e_phnum; j++)
  if (program_headers[j].p_vaddr <= segment->p_vaddr
      && (program_headers[j].p_vaddr + program_headers[j].p_memsz)
      >= (segment->p_vaddr + segment->p_filesz))
    break;
       if (j == elf_header.e_phnum)
  error (gettext ("the PHDR segment is not covered by a LOAD segment\n"));
     }
   break;

 case 2:
   if (dynamic_addr)
     error (gettext ("more than one dynamic segment\n"));



   dynamic_addr = segment->p_offset;
   dynamic_size = segment->p_filesz;



   if (section_headers != 
# 5059 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 5059 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
     {
       Elf_Internal_Shdr * sec;

       sec = find_section (".dynamic");
       if (sec == 
# 5064 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0) 
# 5064 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      || sec->sh_size == 0)
  {


                  if (!is_ia64_vms ())
                    error (gettext ("no .dynamic section in the dynamic segment\n"));
    break;
  }

       if (sec->sh_type == 8)
  {
    dynamic_size = 0;
    break;
  }

       dynamic_addr = sec->sh_offset;
       dynamic_size = sec->sh_size;

       if (dynamic_addr < segment->p_offset
    || dynamic_addr > segment->p_offset + segment->p_filesz)
  warn (gettext ("the .dynamic section is not contained" " within the dynamic segment\n")
                                   );
       else if (dynamic_addr > segment->p_offset)
  warn (gettext ("the .dynamic section is not the first section" " in the dynamic segment.\n")
                                );
     }





   if (dynamic_addr + dynamic_size >= current_file_size)
     {
       error (gettext ("the dynamic segment offset + size exceeds the size of the file\n"));
       dynamic_addr = dynamic_size = 0;
     }
   break;

 case 3:
   if (fseek (file, archive_file_offset + (long) segment->p_offset,
       
# 5104 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      0
# 5104 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ))
     error (gettext ("Unable to find program interpreter name\n"));
   else
     {
       char fmt [32];
       int ret = snprintf (fmt, sizeof (fmt), "%%%ds", 
# 5109 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                      4096 
# 5109 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                               - 1);

       if (ret >= (int) sizeof (fmt) || ret < 0)
  error (gettext ("Internal error: failed to create format string to display program interpreter\n"));

       program_interpreter[0] = 0;
       if (fscanf (file, fmt, program_interpreter) <= 0)
  error (gettext ("Unable to read program interpreter name\n"));

       if (do_segments)
  printf (gettext ("      [Requesting program interpreter: %s]\n"),
      program_interpreter);
     }
   break;
 }
    }

  if (do_segments && section_headers != 
# 5126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       ((void *)0) 
# 5126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            && string_table != 
# 5126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                               ((void *)0)
# 5126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                   )
    {
      printf (gettext ("\n Section to Segment mapping:\n"));
      printf (gettext ("  Segment Sections...\n"));

      for (i = 0; i < elf_header.e_phnum; i++)
 {
   unsigned int j;
   Elf_Internal_Shdr * section;

   segment = program_headers + i;
   section = section_headers + 1;

   printf ("   %2.2d     ", i);

   for (j = 1; j < elf_header.e_shnum; j++, section++)
     {
       if (!(((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7)
    && ((( ((((section)->sh_flags & (1 << 10)) != 0) && ((segment)->p_type == 7 || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == 1)) || (((section)->sh_flags & (1 << 10)) == 0 && (segment)->p_type != 7 && (segment)->p_type != 6)) && !(((section)->sh_flags & (1 << 1)) == 0 && ((segment)->p_type == 1 || (segment)->p_type == 2 || (segment)->p_type == (0x60000000 + 0x474e550) || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == (0x60000000 + 0x474e551))) && ((section)->sh_type == 8 || ((bfd_vma) (section)->sh_offset >= (segment)->p_offset && (!(1) || ((section)->sh_offset - (segment)->p_offset <= (segment)->p_filesz - 1)) && (((section)->sh_offset - (segment)->p_offset + ((((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (section)->sh_size)) <= (segment)->p_filesz))) && (!(1) || ((section)->sh_flags & (1 << 1)) == 0 || ((section)->sh_addr >= (segment)->p_vaddr && (!(1) || ((section)->sh_addr - (segment)->p_vaddr <= (segment)->p_memsz - 1)) && (((section)->sh_addr - (segment)->p_vaddr + ((((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (section)->sh_size)) <= (segment)->p_memsz))) && ((segment)->p_type != 2 || (section)->sh_size != 0 || (segment)->p_memsz == 0 || (((section)->sh_type == 8 || ((bfd_vma) (section)->sh_offset > (segment)->p_offset && ((section)->sh_offset - (segment)->p_offset < (segment)->p_filesz))) && (((section)->sh_flags & (1 << 1)) == 0 || ((section)->sh_addr > (segment)->p_vaddr && ((section)->sh_addr - (segment)->p_vaddr < (segment)->p_memsz))))))))
  printf ("%s ", printable_section_name (section));
     }

   putc ('\n',
# 5148 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             stdout
# 5148 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   );
 }
    }

  return 1;
}




static long
offset_from_vma (FILE * file, bfd_vma vma, bfd_size_type size)
{
  Elf_Internal_Phdr * seg;

  if (! get_program_headers (file))
    {
      warn (gettext ("Cannot interpret virtual addresses without program headers.\n"));
      return (long) vma;
    }

  for (seg = program_headers;
       seg < program_headers + elf_header.e_phnum;
       ++seg)
    {
      if (seg->p_type != 1)
 continue;

      if (vma >= (seg->p_vaddr & -seg->p_align)
   && vma + size <= seg->p_vaddr + seg->p_filesz)
 return vma - seg->p_vaddr + seg->p_offset;
    }

  warn (gettext ("Virtual address 0x%lx not located in any PT_LOAD segment.\n"),
 (unsigned long) vma);
  return (long) vma;
}






static bfd_boolean
get_32bit_section_headers (FILE * file, bfd_boolean probe)
{
  Elf32_External_Shdr * shdrs;
  Elf_Internal_Shdr * internal;
  unsigned int i;
  unsigned int size = elf_header.e_shentsize;
  unsigned int num = probe ? 1 : elf_header.e_shnum;


  if (size == 0 || num == 0)
    return 0;
  if (size < sizeof * shdrs)
    {
      if (! probe)
 error (gettext ("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
      return 0;
    }
  if (!probe && size > sizeof * shdrs)
    warn (gettext ("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));

  shdrs = (Elf32_External_Shdr *) get_data (
# 5212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 5212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               , file, elf_header.e_shoff,
                                            size, num,
         probe ? 
# 5214 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0) 
# 5214 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     : gettext ("section headers"));
  if (shdrs == 
# 5215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    return 0;

  if (section_headers != 
# 5218 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5218 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    free (section_headers);
  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));
  if (section_headers == 
# 5222 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5222 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      if (!probe)
 error (gettext ("Out of memory reading %u section headers\n"), num);
      return 0;
    }

  for (i = 0, internal = section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name = byte_get (shdrs[i].sh_name, sizeof (shdrs[i].sh_name));
      internal->sh_type = byte_get (shdrs[i].sh_type, sizeof (shdrs[i].sh_type));
      internal->sh_flags = byte_get (shdrs[i].sh_flags, sizeof (shdrs[i].sh_flags));
      internal->sh_addr = byte_get (shdrs[i].sh_addr, sizeof (shdrs[i].sh_addr));
      internal->sh_offset = byte_get (shdrs[i].sh_offset, sizeof (shdrs[i].sh_offset));
      internal->sh_size = byte_get (shdrs[i].sh_size, sizeof (shdrs[i].sh_size));
      internal->sh_link = byte_get (shdrs[i].sh_link, sizeof (shdrs[i].sh_link));
      internal->sh_info = byte_get (shdrs[i].sh_info, sizeof (shdrs[i].sh_info));
      internal->sh_addralign = byte_get (shdrs[i].sh_addralign, sizeof (shdrs[i].sh_addralign));
      internal->sh_entsize = byte_get (shdrs[i].sh_entsize, sizeof (shdrs[i].sh_entsize));
      if (!probe && internal->sh_link > num)
 warn (gettext ("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
      if (!probe && internal->sh_flags & (1 << 6) && internal->sh_info > num)
 warn (gettext ("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
    }

  free (shdrs);
  return 1;
}

static bfd_boolean
get_64bit_section_headers (FILE * file, bfd_boolean probe)
{
  Elf64_External_Shdr * shdrs;
  Elf_Internal_Shdr * internal;
  unsigned int i;
  unsigned int size = elf_header.e_shentsize;
  unsigned int num = probe ? 1 : elf_header.e_shnum;


  if (size == 0 || num == 0)
    return 0;
  if (size < sizeof * shdrs)
    {
      if (! probe)
 error (gettext ("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
      return 0;
    }
  if (! probe && size > sizeof * shdrs)
    warn (gettext ("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));

  shdrs = (Elf64_External_Shdr *) get_data (
# 5274 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 5274 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               , file, elf_header.e_shoff,
                                            size, num,
         probe ? 
# 5276 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0) 
# 5276 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     : gettext ("section headers"));
  if (shdrs == 
# 5277 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5277 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    return 0;

  if (section_headers != 
# 5280 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5280 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    free (section_headers);
  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));
  if (section_headers == 
# 5284 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5284 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      if (! probe)
 error (gettext ("Out of memory reading %u section headers\n"), num);
      return 0;
    }

  for (i = 0, internal = section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name = byte_get (shdrs[i].sh_name, sizeof (shdrs[i].sh_name));
      internal->sh_type = byte_get (shdrs[i].sh_type, sizeof (shdrs[i].sh_type));
      internal->sh_flags = byte_get (shdrs[i].sh_flags, sizeof (shdrs[i].sh_flags));
      internal->sh_addr = byte_get (shdrs[i].sh_addr, sizeof (shdrs[i].sh_addr));
      internal->sh_size = byte_get (shdrs[i].sh_size, sizeof (shdrs[i].sh_size));
      internal->sh_entsize = byte_get (shdrs[i].sh_entsize, sizeof (shdrs[i].sh_entsize));
      internal->sh_link = byte_get (shdrs[i].sh_link, sizeof (shdrs[i].sh_link));
      internal->sh_info = byte_get (shdrs[i].sh_info, sizeof (shdrs[i].sh_info));
      internal->sh_offset = byte_get (shdrs[i].sh_offset, sizeof (shdrs[i].sh_offset));
      internal->sh_addralign = byte_get (shdrs[i].sh_addralign, sizeof (shdrs[i].sh_addralign));
      if (!probe && internal->sh_link > num)
 warn (gettext ("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
      if (!probe && internal->sh_flags & (1 << 6) && internal->sh_info > num)
 warn (gettext ("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
    }

  free (shdrs);
  return 1;
}

static Elf_Internal_Sym *
get_32bit_elf_symbols (FILE * file,
         Elf_Internal_Shdr * section,
         unsigned long * num_syms_return)
{
  unsigned long number = 0;
  Elf32_External_Sym * esyms = 
# 5321 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 5321 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
  Elf_External_Sym_Shndx * shndx = 
# 5322 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 5322 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      ;
  Elf_Internal_Sym * isyms = 
# 5323 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 5323 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                ;
  Elf_Internal_Sym * psym;
  unsigned int j;

  if (section->sh_size == 0)
    {
      if (num_syms_return != 
# 5329 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 5329 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )
 * num_syms_return = 0;
      return 
# 5331 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 5331 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }


  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
    {
      error (gettext ("Section %s has an invalid sh_entsize of 0x%lx\n"),
      printable_section_name (section), (unsigned long) section->sh_entsize);
      goto exit_point;
    }

  if (section->sh_size > current_file_size)
    {
      error (gettext ("Section %s has an invalid sh_size of 0x%lx\n"),
      printable_section_name (section), (unsigned long) section->sh_size);
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
    {
      error (gettext ("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
      (unsigned long) section->sh_size,
      printable_section_name (section),
      (unsigned long) section->sh_entsize);
      goto exit_point;
    }

  esyms = (Elf32_External_Sym *) get_data (
# 5360 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                          ((void *)0)
# 5360 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                              , file, section->sh_offset, 1,
                                           section->sh_size, gettext ("symbols"));
  if (esyms == 
# 5362 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5362 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    goto exit_point;

  {
    elf_section_list * entry;

    shndx = 
# 5368 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0)
# 5368 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ;
    for (entry = symtab_shndx_list; entry != 
# 5369 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 5369 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                ; entry = entry->next)
      if (entry->hdr->sh_link == (unsigned long) (section - section_headers))
 {
   shndx = (Elf_External_Sym_Shndx *) get_data (
# 5372 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               ((void *)0)
# 5372 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   , file,
             entry->hdr->sh_offset,
             1, entry->hdr->sh_size,
             gettext ("symbol table section indicies"));
   if (shndx == 
# 5376 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 5376 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
     goto exit_point;

   else if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
     {
       error (gettext ("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
       printable_section_name (entry->hdr),
       (unsigned long) entry->hdr->sh_size,
       (unsigned long) section->sh_size);
       goto exit_point;
     }
 }
  }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == 
# 5392 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5392 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %lu symbols\n"),
      (unsigned long) number);
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name = byte_get (esyms[j].st_name, sizeof (esyms[j].st_name));
      psym->st_value = byte_get (esyms[j].st_value, sizeof (esyms[j].st_value));
      psym->st_size = byte_get (esyms[j].st_size, sizeof (esyms[j].st_size));
      psym->st_shndx = byte_get (esyms[j].st_shndx, sizeof (esyms[j].st_shndx));
      if (psym->st_shndx == ((-0x1u) & 0xffff) && shndx != 
# 5405 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                             ((void *)0)
# 5405 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                 )
 psym->st_shndx
   = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= ((-0x100u) & 0xffff))
 psym->st_shndx += (-0x100u) - ((-0x100u) & 0xffff);
      psym->st_info = byte_get (esyms[j].st_info, sizeof (esyms[j].st_info));
      psym->st_other = byte_get (esyms[j].st_other, sizeof (esyms[j].st_other));
    }

 exit_point:
  if (shndx != 
# 5415 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5415 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    free (shndx);
  if (esyms != 
# 5417 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5417 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    free (esyms);

  if (num_syms_return != 
# 5420 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5420 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    * num_syms_return = isyms == 
# 5421 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0) 
# 5421 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     ? 0 : number;

  return isyms;
}

static Elf_Internal_Sym *
get_64bit_elf_symbols (FILE * file,
         Elf_Internal_Shdr * section,
         unsigned long * num_syms_return)
{
  unsigned long number = 0;
  Elf64_External_Sym * esyms = 
# 5432 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 5432 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
  Elf_External_Sym_Shndx * shndx = 
# 5433 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 5433 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      ;
  Elf_Internal_Sym * isyms = 
# 5434 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 5434 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                ;
  Elf_Internal_Sym * psym;
  unsigned int j;

  if (section->sh_size == 0)
    {
      if (num_syms_return != 
# 5440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 5440 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )
 * num_syms_return = 0;
      return 
# 5442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 5442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }


  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
    {
      error (gettext ("Section %s has an invalid sh_entsize of 0x%lx\n"),
      printable_section_name (section),
      (unsigned long) section->sh_entsize);
      goto exit_point;
    }

  if (section->sh_size > current_file_size)
    {
      error (gettext ("Section %s has an invalid sh_size of 0x%lx\n"),
      printable_section_name (section),
      (unsigned long) section->sh_size);
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
    {
      error (gettext ("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
      (unsigned long) section->sh_size,
      printable_section_name (section),
      (unsigned long) section->sh_entsize);
      goto exit_point;
    }

  esyms = (Elf64_External_Sym *) get_data (
# 5473 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                          ((void *)0)
# 5473 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                              , file, section->sh_offset, 1,
                                           section->sh_size, gettext ("symbols"));
  if (!esyms)
    goto exit_point;

  {
    elf_section_list * entry;

    shndx = 
# 5481 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0)
# 5481 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ;
    for (entry = symtab_shndx_list; entry != 
# 5482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 5482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                ; entry = entry->next)
      if (entry->hdr->sh_link == (unsigned long) (section - section_headers))
 {
   shndx = (Elf_External_Sym_Shndx *) get_data (
# 5485 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               ((void *)0)
# 5485 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   , file,
             entry->hdr->sh_offset,
             1, entry->hdr->sh_size,
             gettext ("symbol table section indicies"));
   if (shndx == 
# 5489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 5489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
     goto exit_point;

   else if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
     {
       error (gettext ("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
       printable_section_name (entry->hdr),
       (unsigned long) entry->hdr->sh_size,
       (unsigned long) section->sh_size);
       goto exit_point;
     }
 }
  }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == 
# 5505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %lu symbols\n"),
      (unsigned long) number);
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name = byte_get (esyms[j].st_name, sizeof (esyms[j].st_name));
      psym->st_info = byte_get (esyms[j].st_info, sizeof (esyms[j].st_info));
      psym->st_other = byte_get (esyms[j].st_other, sizeof (esyms[j].st_other));
      psym->st_shndx = byte_get (esyms[j].st_shndx, sizeof (esyms[j].st_shndx));

      if (psym->st_shndx == ((-0x1u) & 0xffff) && shndx != 
# 5519 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                             ((void *)0)
# 5519 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                 )
 psym->st_shndx
   = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= ((-0x100u) & 0xffff))
 psym->st_shndx += (-0x100u) - ((-0x100u) & 0xffff);

      psym->st_value = byte_get (esyms[j].st_value, sizeof (esyms[j].st_value));
      psym->st_size = byte_get (esyms[j].st_size, sizeof (esyms[j].st_size));
    }

 exit_point:
  if (shndx != 
# 5530 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5530 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    free (shndx);
  if (esyms != 
# 5532 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 5532 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
    free (esyms);

  if (num_syms_return != 
# 5535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 5535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    * num_syms_return = isyms == 
# 5536 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0) 
# 5536 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     ? 0 : number;

  return isyms;
}

static const char *
get_elf_section_flags (bfd_vma sh_flags)
{
  static char buff[1024];
  char * p = buff;
  unsigned int field_size = is_32bit_elf ? 8 : 16;
  signed int sindex;
  unsigned int size = sizeof (buff) - (field_size + 4 + 1);
  bfd_vma os_flags = 0;
  bfd_vma proc_flags = 0;
  bfd_vma unknown_flags = 0;
  static const struct
    {
      const char * str;
      unsigned int len;
    }
  flags [] =
    {
               { ("WRITE"), (sizeof ("WRITE") - 1) },
               { ("ALLOC"), (sizeof ("ALLOC") - 1) },
               { ("EXEC"), (sizeof ("EXEC") - 1) },
               { ("MERGE"), (sizeof ("MERGE") - 1) },
               { ("STRINGS"), (sizeof ("STRINGS") - 1) },
               { ("INFO LINK"), (sizeof ("INFO LINK") - 1) },
               { ("LINK ORDER"), (sizeof ("LINK ORDER") - 1) },
               { ("OS NONCONF"), (sizeof ("OS NONCONF") - 1) },
               { ("GROUP"), (sizeof ("GROUP") - 1) },
               { ("TLS"), (sizeof ("TLS") - 1) },

               { ("SHORT"), (sizeof ("SHORT") - 1) },
               { ("NORECOV"), (sizeof ("NORECOV") - 1) },

               { ("VMS_GLOBAL"), (sizeof ("VMS_GLOBAL") - 1) },
               { ("VMS_OVERLAID"), (sizeof ("VMS_OVERLAID") - 1) },
               { ("VMS_SHARED"), (sizeof ("VMS_SHARED") - 1) },
               { ("VMS_VECTOR"), (sizeof ("VMS_VECTOR") - 1) },
               { ("VMS_ALLOC_64BIT"), (sizeof ("VMS_ALLOC_64BIT") - 1) },
               { ("VMS_PROTECTED"), (sizeof ("VMS_PROTECTED") - 1) },

               { ("EXCLUDE"), (sizeof ("EXCLUDE") - 1) },

               { ("ORDERED"), (sizeof ("ORDERED") - 1) },
               { ("COMPRESSED"), (sizeof ("COMPRESSED") - 1) },

               { ("ENTRYSECT"), (sizeof ("ENTRYSECT") - 1) },
               { ("ARM_PURECODE"), (sizeof ("ARM_PURECODE") - 1) },
               { ("COMDEF"), (sizeof ("COMDEF") - 1) },

               { ("GNU_MBIND"), (sizeof ("GNU_MBIND") - 1) },
    };

  if (do_section_details)
    {
      sprintf (buff, "[%*.*lx]: ",
        field_size, field_size, (unsigned long) sh_flags);
      p += field_size + 4;
    }

  while (sh_flags)
    {
      bfd_vma flag;

      flag = sh_flags & - sh_flags;
      sh_flags &= ~ flag;

      if (do_section_details)
 {
   switch (flag)
     {
     case (1 << 0): sindex = 0; break;
     case (1 << 1): sindex = 1; break;
     case (1 << 2): sindex = 2; break;
     case (1 << 4): sindex = 3; break;
     case (1 << 5): sindex = 4; break;
     case (1 << 6): sindex = 5; break;
     case (1 << 7): sindex = 6; break;
     case (1 << 8): sindex = 7; break;
     case (1 << 9): sindex = 8; break;
     case (1 << 10): sindex = 9; break;
     case 0x80000000: sindex = 18; break;
     case (1 << 11): sindex = 20; break;
     case 0x01000000: sindex = 24; break;

     default:
       sindex = -1;
       switch (elf_header.e_machine)
  {
  case 50:
    if (flag == 0x10000000)
      sindex = 10;
    else if (flag == 0x20000000)
      sindex = 11;

    else if (elf_header.e_ident[7] == 13)
      switch (flag)
        {
        case 0x0100000000ULL: sindex = 12; break;
        case 0x0200000000ULL: sindex = 13; break;
        case 0x0400000000ULL: sindex = 14; break;
        case 0x0800000000ULL: sindex = 15; break;
        case 0x1000000000ULL: sindex = 16; break;
        case 0x2000000000ULL: sindex = 17; break;
        default: break;
        }

    break;

  case 3:
  case 6:
  case 62:
  case 180:
  case 181:
  case 11:
  case 18:
  case 43:
  case 2:
    if (flag == 0x40000000)
      sindex = 19;
    break;

  case 40:
    switch (flag)
      {
      case 0x10000000: sindex = 21; break;
      case 0x20000000: sindex = 22; break;
      case 0x80000000: sindex = 23; break;
      default: break;
      }
    break;

  default:
    break;
  }
     }

   if (sindex != -1)
     {
       if (p != buff + field_size + 4)
  {
    if (size < (10 + 2))
      {
        warn (gettext ("Internal error: not enough buffer room for section flag info"));
        return gettext ("<unknown>");
      }
    size -= 2;
    *p++ = ',';
    *p++ = ' ';
  }

       size -= flags [sindex].len;
       p = stpcpy (p, flags [sindex].str);
     }
   else if (flag & 0x0FF00000)
     os_flags |= flag;
   else if (flag & 0xF0000000)
     proc_flags |= flag;
   else
     unknown_flags |= flag;
 }
      else
 {
   switch (flag)
     {
     case (1 << 0): *p = 'W'; break;
     case (1 << 1): *p = 'A'; break;
     case (1 << 2): *p = 'X'; break;
     case (1 << 4): *p = 'M'; break;
     case (1 << 5): *p = 'S'; break;
     case (1 << 6): *p = 'I'; break;
     case (1 << 7): *p = 'L'; break;
     case (1 << 8): *p = 'O'; break;
     case (1 << 9): *p = 'G'; break;
     case (1 << 10): *p = 'T'; break;
     case 0x80000000: *p = 'E'; break;
     case (1 << 11): *p = 'C'; break;
     case 0x01000000: *p = 'D'; break;

     default:
       if ((elf_header.e_machine == 62
     || elf_header.e_machine == 180
     || elf_header.e_machine == 181)
    && flag == 0x10000000)
  *p = 'l';
       else if (elf_header.e_machine == 40
         && flag == 0x20000000)
    *p = 'y';
       else if (flag & 0x0FF00000)
  {
    *p = 'o';
    sh_flags &= ~ 0x0FF00000;
  }
       else if (flag & 0xF0000000)
  {
    *p = 'p';
    sh_flags &= ~ 0xF0000000;
  }
       else
  *p = 'x';
       break;
     }
   p++;
 }
    }

  if (do_section_details)
    {
      if (os_flags)
 {
   size -= 5 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, "OS (%*.*lx)", field_size, field_size,
     (unsigned long) os_flags);
   p += 5 + field_size;
 }
      if (proc_flags)
 {
   size -= 7 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, "PROC (%*.*lx)", field_size, field_size,
     (unsigned long) proc_flags);
   p += 7 + field_size;
 }
      if (unknown_flags)
 {
   size -= 10 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, gettext ("UNKNOWN (%*.*lx)"), field_size, field_size,
     (unsigned long) unknown_flags);
   p += 10 + field_size;
 }
    }

  *p = '\0';
  return buff;
}

static unsigned int
get_compression_header (Elf_Internal_Chdr *chdr, unsigned char *buf, bfd_size_type size)
{
  if (is_32bit_elf)
    {
      Elf32_External_Chdr *echdr = (Elf32_External_Chdr *) buf;

      if (size < sizeof (* echdr))
 {
   error (gettext ("Compressed section is too small even for a compression header\n"));
   return 0;
 }

      chdr->ch_type = byte_get (echdr->ch_type, sizeof (echdr->ch_type));
      chdr->ch_size = byte_get (echdr->ch_size, sizeof (echdr->ch_size));
      chdr->ch_addralign = byte_get (echdr->ch_addralign, sizeof (echdr->ch_addralign));
      return sizeof (*echdr);
    }
  else
    {
      Elf64_External_Chdr *echdr = (Elf64_External_Chdr *) buf;

      if (size < sizeof (* echdr))
 {
   error (gettext ("Compressed section is too small even for a compression header\n"));
   return 0;
 }

      chdr->ch_type = byte_get (echdr->ch_type, sizeof (echdr->ch_type));
      chdr->ch_size = byte_get (echdr->ch_size, sizeof (echdr->ch_size));
      chdr->ch_addralign = byte_get (echdr->ch_addralign, sizeof (echdr->ch_addralign));
      return sizeof (*echdr);
    }
}

static bfd_boolean
process_section_headers (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;

  section_headers = 
# 5848 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 5848 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;

  if (elf_header.e_shnum == 0)
    {

      if (elf_header.e_shoff != 0)
 {
   warn (gettext ("possibly corrupt ELF file header - it has a non-zero" " section header offset, but no section headers\n")
                                                       );
   return 0;
 }
      else if (do_sections)
 printf (gettext ("\nThere are no sections in this file.\n"));

      return 1;
    }

  if (do_sections && !do_header)
    printf (gettext ("There are %d section headers, starting at offset 0x%lx:\n"),
     elf_header.e_shnum, (unsigned long) elf_header.e_shoff);

  if (is_32bit_elf)
    {
      if (! get_32bit_section_headers (file, 0))
 return 0;
    }
  else
    {
      if (! get_64bit_section_headers (file, 0))
 return 0;
    }


  if (elf_header.e_shstrndx != 0
       && elf_header.e_shstrndx < elf_header.e_shnum)
    {
      section = section_headers + elf_header.e_shstrndx;

      if (section->sh_size != 0)
 {
   string_table = (char *) get_data (
# 5888 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    ((void *)0)
# 5888 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        , file, section->sh_offset,
                                            1, section->sh_size,
                                            gettext ("string table"));

   string_table_length = string_table != 
# 5892 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0) 
# 5892 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             ? section->sh_size : 0;
 }
    }



  dynamic_symbols = 
# 5898 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 5898 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
  dynamic_strings = 
# 5899 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 5899 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
  dynamic_syminfo = 
# 5900 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 5900 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
  symtab_shndx_list = 
# 5901 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 5901 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;

  eh_addr_size = is_32bit_elf ? 4 : 8;
  switch (elf_header.e_machine)
    {
    case 8:
    case 10:
# 5917 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      if ((elf_header.e_flags & 0x0000F000) == 0x00004000
   && find_section (".gcc_compiled_long32") == 
# 5918 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 5918 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  )
 eh_addr_size = 8;
      break;

    case 46:
    case 47:
      switch (elf_header.e_flags & 0x00FF0000)
 {
 case 0x00800000:
 case 0x00830000:
 case 0x00840000:
 case 0x00860000:
   eh_addr_size = 2;
   break;
 case 0x00810000:
 case 0x00820000:
 case 0x00850000:
   eh_addr_size = 4;
   break;
 }
      break;

    case 0xFEB0:
    case 120:
      switch (elf_header.e_flags & 0x0000007F)
 {
 case 0x00000075:
   eh_addr_size = 2;
   break;
 }
      break;
    }
# 5973 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      char * name = ((section) == 
# 5977 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 5977 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<none>") : string_table == 
# 5977 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 5977 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<no-name>") : ((section)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section)->sh_name));

      if (section->sh_type == 11)
 {
   if (dynamic_symbols != 
# 5981 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 5981 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
     {
       error (gettext ("File contains multiple dynamic symbol tables\n"));
       continue;
     }

   do { bfd_size_type expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Sym) : sizeof (Elf64_External_Sym); if (section->sh_entsize != expected_entsize) { char buf[40]; sprintf (buf, "%016" "l" "x", section->sh_entsize); error (gettext ("Section %d has invalid sh_entsize of %s\n"), i, buf); error (gettext ("(Using the expected size of %u for the rest of this dump)\n"), (unsigned) expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   dynamic_symbols = (is_32bit_elf ? get_32bit_elf_symbols (file, section, & num_dynamic_syms) : get_64bit_elf_symbols (file, section, & num_dynamic_syms));
 }
      else if (section->sh_type == 3
        && (strcmp ((name), (".dynstr")) == 0))
 {
   if (dynamic_strings != 
# 5993 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 5993 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
     {
       error (gettext ("File contains multiple dynamic string tables\n"));
       continue;
     }

   dynamic_strings = (char *) get_data (
# 5999 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       ((void *)0)
# 5999 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           , file, section->sh_offset,
                                               1, section->sh_size,
                                               gettext ("dynamic strings"));
   dynamic_strings_length = dynamic_strings == 
# 6002 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0) 
# 6002 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   ? 0 : section->sh_size;
 }
      else if (section->sh_type == 18)
 {
   elf_section_list * entry = xmalloc (sizeof * entry);
   entry->hdr = section;
   entry->next = symtab_shndx_list;
   symtab_shndx_list = entry;
 }
      else if (section->sh_type == 2)
 do { bfd_size_type expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Sym) : sizeof (Elf64_External_Sym); if (section->sh_entsize != expected_entsize) { char buf[40]; sprintf (buf, "%016" "l" "x", section->sh_entsize); error (gettext ("Section %d has invalid sh_entsize of %s\n"), i, buf); error (gettext ("(Using the expected size of %u for the rest of this dump)\n"), (unsigned) expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
      else if (section->sh_type == 17)
 do { bfd_size_type expected_entsize = is_32bit_elf ? 4 : 4; if (section->sh_entsize != expected_entsize) { char buf[40]; sprintf (buf, "%016" "l" "x", section->sh_entsize); error (gettext ("Section %d has invalid sh_entsize of %s\n"), i, buf); error (gettext ("(Using the expected size of %u for the rest of this dump)\n"), (unsigned) expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
      else if (section->sh_type == 9)
 do { bfd_size_type expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Rel) : sizeof (Elf64_External_Rel); if (section->sh_entsize != expected_entsize) { char buf[40]; sprintf (buf, "%016" "l" "x", section->sh_entsize); error (gettext ("Section %d has invalid sh_entsize of %s\n"), i, buf); error (gettext ("(Using the expected size of %u for the rest of this dump)\n"), (unsigned) expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
      else if (section->sh_type == 4)
 do { bfd_size_type expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Rela) : sizeof (Elf64_External_Rela); if (section->sh_entsize != expected_entsize) { char buf[40]; sprintf (buf, "%016" "l" "x", section->sh_entsize); error (gettext ("Section %d has invalid sh_entsize of %s\n"), i, buf); error (gettext ("(Using the expected size of %u for the rest of this dump)\n"), (unsigned) expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
      else if ((do_debugging || do_debug_info || do_debug_abbrevs
  || do_debug_lines || do_debug_pubnames || do_debug_pubtypes
  || do_debug_aranges || do_debug_frames || do_debug_macinfo
  || do_debug_str || do_debug_loc || do_debug_ranges
  || do_debug_addr || do_debug_cu_index)
        && ((strncmp ((name), (".debug_"), sizeof (".debug_") - 1) == 0)
                   || (strncmp ((name), (".zdebug_"), sizeof (".zdebug_") - 1) == 0)))
 {
          if (name[1] == 'z')
            name += sizeof (".zdebug_") - 1;
          else
            name += sizeof (".debug_") - 1;

   if (do_debugging
       || (do_debug_info && (strncmp ((name), ("info"), sizeof ("info") - 1) == 0))
       || (do_debug_info && (strncmp ((name), ("types"), sizeof ("types") - 1) == 0))
       || (do_debug_abbrevs && (strncmp ((name), ("abbrev"), sizeof ("abbrev") - 1) == 0))
       || (do_debug_lines && strcmp (name, "line") == 0)
       || (do_debug_lines && (strncmp ((name), ("line."), sizeof ("line.") - 1) == 0))
       || (do_debug_pubnames && (strncmp ((name), ("pubnames"), sizeof ("pubnames") - 1) == 0))
       || (do_debug_pubtypes && (strncmp ((name), ("pubtypes"), sizeof ("pubtypes") - 1) == 0))
       || (do_debug_pubnames && (strncmp ((name), ("gnu_pubnames"), sizeof ("gnu_pubnames") - 1) == 0))
       || (do_debug_pubtypes && (strncmp ((name), ("gnu_pubtypes"), sizeof ("gnu_pubtypes") - 1) == 0))
       || (do_debug_aranges && (strncmp ((name), ("aranges"), sizeof ("aranges") - 1) == 0))
       || (do_debug_ranges && (strncmp ((name), ("ranges"), sizeof ("ranges") - 1) == 0))
       || (do_debug_ranges && (strncmp ((name), ("rnglists"), sizeof ("rnglists") - 1) == 0))
       || (do_debug_frames && (strncmp ((name), ("frame"), sizeof ("frame") - 1) == 0))
       || (do_debug_macinfo && (strncmp ((name), ("macinfo"), sizeof ("macinfo") - 1) == 0))
       || (do_debug_macinfo && (strncmp ((name), ("macro"), sizeof ("macro") - 1) == 0))
       || (do_debug_str && (strncmp ((name), ("str"), sizeof ("str") - 1) == 0))
       || (do_debug_loc && (strncmp ((name), ("loc"), sizeof ("loc") - 1) == 0))
       || (do_debug_loc && (strncmp ((name), ("loclists"), sizeof ("loclists") - 1) == 0))
       || (do_debug_addr && (strncmp ((name), ("addr"), sizeof ("addr") - 1) == 0))
       || (do_debug_cu_index && (strncmp ((name), ("cu_index"), sizeof ("cu_index") - 1) == 0))
       || (do_debug_cu_index && (strncmp ((name), ("tu_index"), sizeof ("tu_index") - 1) == 0))
       )
     request_dump_bynumber (i, (1 << 2));
 }

      else if ((do_debugging || do_debug_info)
        && (strncmp ((name), (".gnu.linkonce.wi."), sizeof (".gnu.linkonce.wi.") - 1) == 0))
 request_dump_bynumber (i, (1 << 2));
      else if (do_debug_frames && (strcmp ((name), (".eh_frame")) == 0))
 request_dump_bynumber (i, (1 << 2));
      else if (do_gdb_index && ((strcmp ((name), (".gdb_index")) == 0)
    || (strcmp ((name), (".debug_names")) == 0)))
 request_dump_bynumber (i, (1 << 2));

      else if ((do_debugging || do_trace_info || do_trace_abbrevs
                || do_trace_aranges)
        && (strncmp ((name), (".trace_"), sizeof (".trace_") - 1) == 0))
 {
          name += sizeof (".trace_") - 1;

   if (do_debugging
       || (do_trace_info && (strcmp ((name), ("info")) == 0))
       || (do_trace_abbrevs && (strcmp ((name), ("abbrev")) == 0))
       || (do_trace_aranges && (strcmp ((name), ("aranges")) == 0))
       )
     request_dump_bynumber (i, (1 << 2));
 }
    }

  if (! do_sections)
    return 1;

  if (elf_header.e_shnum > 1)
    printf (gettext ("\nSection Headers:\n"));
  else
    printf (gettext ("\nSection Header:\n"));

  if (is_32bit_elf)
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
 }
      else
 printf
   (gettext ("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
    }
  else if (do_wide)
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type            Address          Off    Size   ES   Lk Inf Al\n"));
 }
      else
 printf
   (gettext ("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
    }
  else
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type              Address          Offset            Link\n"));
   printf (gettext ("       Size              EntSize          Info              Align\n"));
 }
      else
 {
   printf (gettext ("  [Nr] Name              Type             Address           Offset\n"));
   printf (gettext ("       Size              EntSize          Flags  Link  Info  Align\n"));
 }
    }

  if (do_section_details)
    printf (gettext ("       Flags\n"));

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {



      switch (section->sh_type)
 {
 case 18:
 case 17:
 case 5:
 case 0x6ffffff6:
 case 0x6fffffff:
 case 9:
 case 4:
   if (section->sh_link < 1
       || section->sh_link >= elf_header.e_shnum
       || (section_headers[section->sh_link].sh_type != 2
    && section_headers[section->sh_link].sh_type != 11))
     warn (gettext ("[%2u]: Link field (%u) should index a symtab section.\n"),
    i, section->sh_link);
   break;

 case 6:
 case 2:
 case 11:
 case 0x6ffffffe:
 case 0x6ffffffd:
 case 0x6ffffff7:
   if (section->sh_link < 1
       || section->sh_link >= elf_header.e_shnum
       || section_headers[section->sh_link].sh_type != 3)
     warn (gettext ("[%2u]: Link field (%u) should index a string section.\n"),
    i, section->sh_link);
   break;

 case 14:
 case 15:
 case 16:
   if (section->sh_type < 0x60000000 && section->sh_link != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in link field.\n"),
    i, section->sh_link);
   break;

 default:
# 6185 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
   break;
 }


      switch (section->sh_type)
 {
 case 9:
 case 4:
   if (section->sh_info < 1
       || section->sh_info >= elf_header.e_shnum
       || (section_headers[section->sh_info].sh_type != 1
    && section_headers[section->sh_info].sh_type != 8
    && section_headers[section->sh_info].sh_type != 7
    && section_headers[section->sh_info].sh_type != 14

    && section_headers[section->sh_info].sh_type < 0x60000000))
     {
       if (section->sh_info == 0
    && ((strcmp ((((section) == 
# 6203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 6203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<none>") : string_table == 
# 6203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 6203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<no-name>") : ((section)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section)->sh_name))), (".rel.dyn")) == 0)
        || (strcmp ((((section) == 
# 6204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0) 
# 6204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ? gettext ("<none>") : string_table == 
# 6204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0) 
# 6204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ? gettext ("<no-name>") : ((section)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section)->sh_name))), (".rela.dyn")) == 0)))



     ;
       else
  warn (gettext ("[%2u]: Info field (%u) should index a relocatable section.\n"),
        i, section->sh_info);
     }
   break;

 case 6:
 case 5:
 case 18:
 case 14:
 case 15:
 case 16:
   if (section->sh_info != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in info field.\n"),
    i, section->sh_info);
   break;

 case 17:
 case 2:
 case 11:

   break;

 default:

   if (section->sh_type == 8)





     ;
   else if (section->sh_flags & (1 << 6))
     {
       if (section->sh_info < 1 || section->sh_info >= elf_header.e_shnum)
  warn (gettext ("[%2u]: Expected link to another section in info field"), i);
     }
   else if (section->sh_type < 0x60000000
     && (section->sh_flags & 0x01000000) == 0
     && section->sh_info != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in info field.\n"),
    i, section->sh_info);
   break;
 }


      if (section->sh_size > current_file_size
   && section->sh_type != 8
   && section->sh_type != 0
   && section->sh_type < 0x60000000)
 warn (gettext ("Size of section %u is larger than the entire file!\n"), i);

      printf ("  [%2u] ", i);
      if (do_section_details)
 printf ("%s\n      ", printable_section_name (section));
      else
 print_symbol (-17, ((section) == 
# 6265 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 6265 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<none>") : string_table == 
# 6265 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 6265 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<no-name>") : ((section)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section)->sh_name)));

      printf (do_wide ? " %-15s " : " %-15.15s ",
       get_section_type_name (section->sh_type));

      if (is_32bit_elf)
 {
   const char * link_too_big = 
# 6272 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 6272 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;

   print_vma (section->sh_addr, LONG_HEX);

   printf ( " %6.6lx %6.6lx %2.2lx",
     (unsigned long) section->sh_offset,
     (unsigned long) section->sh_size,
     (unsigned long) section->sh_entsize);

   if (do_section_details)
     fputs ("  ", 
# 6282 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 6282 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
   else
     printf (" %3s ", get_elf_section_flags (section->sh_flags));

   if (section->sh_link >= elf_header.e_shnum)
     {
       link_too_big = "";


       switch (elf_header.e_machine)
  {
  case 3:
  case 6:
  case 62:
  case 180:
  case 181:
  case 11:
  case 18:
  case 43:
  case 2:
    if (section->sh_link == ((-0x100u) & 0xffff))
      link_too_big = "BEFORE";
    else if (section->sh_link == (((-0x100u) + 1) & 0xffff))
      link_too_big = "AFTER";
    break;
  default:
    break;
  }
     }

   if (do_section_details)
     {
       if (link_too_big != 
# 6314 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          ((void *)0) 
# 6314 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               && * link_too_big)
  printf ("<%s> ", link_too_big);
       else
  printf ("%2u ", section->sh_link);
       printf ("%3u %2lu\n", section->sh_info,
        (unsigned long) section->sh_addralign);
     }
   else
     printf ("%2u %3u %2lu\n",
      section->sh_link,
      section->sh_info,
      (unsigned long) section->sh_addralign);

   if (link_too_big && ! * link_too_big)
     warn (gettext ("section %u: sh_link value of %u is larger than the number of sections\n"),
    i, section->sh_link);
 }
      else if (do_wide)
 {
   print_vma (section->sh_addr, LONG_HEX);

   if ((long) section->sh_offset == section->sh_offset)
     printf (" %6.6lx", (unsigned long) section->sh_offset);
   else
     {
       putchar (' ');
       print_vma (section->sh_offset, LONG_HEX);
     }

   if ((unsigned long) section->sh_size == section->sh_size)
     printf (" %6.6lx", (unsigned long) section->sh_size);
   else
     {
       putchar (' ');
       print_vma (section->sh_size, LONG_HEX);
     }

   if ((unsigned long) section->sh_entsize == section->sh_entsize)
     printf (" %2.2lx", (unsigned long) section->sh_entsize);
   else
     {
       putchar (' ');
       print_vma (section->sh_entsize, LONG_HEX);
     }

   if (do_section_details)
     fputs ("  ", 
# 6360 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 6360 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
   else
     printf (" %3s ", get_elf_section_flags (section->sh_flags));

   printf ("%2u %3u ", section->sh_link, section->sh_info);

   if ((unsigned long) section->sh_addralign == section->sh_addralign)
     printf ("%2lu\n", (unsigned long) section->sh_addralign);
   else
     {
       print_vma (section->sh_addralign, DEC);
       putchar ('\n');
     }
 }
      else if (do_section_details)
 {
   printf ("       %-15.15s  ",
    get_section_type_name (section->sh_type));
   print_vma (section->sh_addr, LONG_HEX);
   if ((long) section->sh_offset == section->sh_offset)
     printf ("  %16.16lx", (unsigned long) section->sh_offset);
   else
     {
       printf ("  ");
       print_vma (section->sh_offset, LONG_HEX);
     }
   printf ("  %u\n       ", section->sh_link);
   print_vma (section->sh_size, LONG_HEX);
   putchar (' ');
   print_vma (section->sh_entsize, LONG_HEX);

   printf ("  %-16u  %lu\n",
    section->sh_info,
    (unsigned long) section->sh_addralign);
 }
      else
 {
   putchar (' ');
   print_vma (section->sh_addr, LONG_HEX);
   if ((long) section->sh_offset == section->sh_offset)
     printf ("  %8.8lx", (unsigned long) section->sh_offset);
   else
     {
       printf ("  ");
       print_vma (section->sh_offset, LONG_HEX);
     }
   printf ("\n       ");
   print_vma (section->sh_size, LONG_HEX);
   printf ("  ");
   print_vma (section->sh_entsize, LONG_HEX);

   printf (" %3s ", get_elf_section_flags (section->sh_flags));

   printf ("     %2u   %3u     %lu\n",
    section->sh_link,
    section->sh_info,
    (unsigned long) section->sh_addralign);
 }

      if (do_section_details)
 {
   printf ("       %s\n", get_elf_section_flags (section->sh_flags));
   if ((section->sh_flags & (1 << 11)) != 0)
     {


       unsigned char buf[24];

       
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void) sizeof ((
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      sizeof (buf) >= sizeof (Elf64_External_Chdr)
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ) ? 1 : 0), __extension__ ({ if (
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      sizeof (buf) >= sizeof (Elf64_External_Chdr)
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ) ; else __assert_fail (
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      "sizeof (buf) >= sizeof (Elf64_External_Chdr)"
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 6428, __extension__ __PRETTY_FUNCTION__); }))
# 6428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                           ;
       if (get_data (&buf, (FILE *) file, section->sh_offset, 1,
       sizeof (buf), gettext ("compression header")))
  {
    Elf_Internal_Chdr chdr;

    (void) get_compression_header (&chdr, buf, sizeof (buf));

    if (chdr.ch_type == 1)
      printf ("       ZLIB, ");
    else
      printf (gettext ("       [<unknown>: 0x%x], "),
       chdr.ch_type);
    print_vma (chdr.ch_size, LONG_HEX);
    printf (", %lu\n", (unsigned long) chdr.ch_addralign);
  }
     }
 }
    }

  if (!do_section_details)
    {



      printf (gettext ("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  ")


                                                                  );
      if (elf_header.e_machine == 62
   || elf_header.e_machine == 180
   || elf_header.e_machine == 181)
 printf (gettext ("l (large), "));
      else if (elf_header.e_machine == 40)
 printf (gettext ("y (purecode), "));
      printf ("p (processor specific)\n");
    }

  return 1;
}

static const char *
get_group_flags (unsigned int flags)
{
  static char buff[128];

  if (flags == 0)
    return "";
  else if (flags == 0x1)
    return "COMDAT ";

  snprintf (buff, 14, gettext ("[0x%x: "), flags);

  flags &= ~ 0x1;
  if (flags & 0x0ff00000)
    {
      strcat (buff, "<OS specific>");
      flags &= ~ 0x0ff00000;
    }

  if (flags & 0xf0000000)
    {
      strcat (buff, "<PROC specific>");
      flags &= ~ 0xf0000000;
    }

  if (flags)
    strcat (buff, "<unknown>");

  strcat (buff, "]");
  return buff;
}

static bfd_boolean
process_section_groups (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  struct group * group;
  Elf_Internal_Shdr * symtab_sec;
  Elf_Internal_Shdr * strtab_sec;
  Elf_Internal_Sym * symtab;
  unsigned long num_syms;
  char * strtab;
  size_t strtab_size;


  if (!do_unwind && !do_section_groups)
    return 1;

  if (elf_header.e_shnum == 0)
    {
      if (do_section_groups)
 printf (gettext ("\nThere are no sections to group in this file.\n"));

      return 1;
    }

  if (section_headers == 
# 6526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 6526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      error (gettext ("Section headers are not available!\n"));

      return 0;
    }

  section_headers_groups = (struct group **) calloc (elf_header.e_shnum,
                                                     sizeof (struct group *));

  if (section_headers_groups == 
# 6536 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 6536 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   )
    {
      error (gettext ("Out of memory reading %u section group headers\n"),
      elf_header.e_shnum);
      return 0;
    }


  group_count = 0;
  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    if (section->sh_type == 17)
      group_count++;

  if (group_count == 0)
    {
      if (do_section_groups)
 printf (gettext ("\nThere are no section groups in this file.\n"));

      return 1;
    }

  section_groups = (struct group *) calloc (group_count, sizeof (struct group));

  if (section_groups == 
# 6561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 6561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    {
      error (gettext ("Out of memory reading %lu groups\n"),
      (unsigned long) group_count);
      return 0;
    }

  symtab_sec = 
# 6568 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 6568 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
  strtab_sec = 
# 6569 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 6569 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
  symtab = 
# 6570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 6570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
  num_syms = 0;
  strtab = 
# 6572 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 6572 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
  strtab_size = 0;
  for (i = 0, section = section_headers, group = section_groups;
       i < elf_header.e_shnum;
       i++, section++)
    {
      if (section->sh_type == 17)
 {
   const char * name = printable_section_name (section);
   const char * group_name;
   unsigned char * start;
   unsigned char * indices;
   unsigned int entry, j, size;
   Elf_Internal_Shdr * sec;
   Elf_Internal_Sym * sym;


   if (section->sh_link >= elf_header.e_shnum
       || ((sec = section_headers + section->sh_link)->sh_type
    != 2))
     {
       error (gettext ("Bad sh_link in group section `%s'\n"), name);
       continue;
     }

   if (symtab_sec != sec)
     {
       symtab_sec = sec;
       if (symtab)
  free (symtab);
       symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, symtab_sec, & num_syms) : get_64bit_elf_symbols (file, symtab_sec, & num_syms));
     }

   if (symtab == 
# 6605 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 6605 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     {
       error (gettext ("Corrupt header in group section `%s'\n"), name);
       continue;
     }

   if (section->sh_info >= num_syms)
     {
       error (gettext ("Bad sh_info in group section `%s'\n"), name);
       continue;
     }

   sym = symtab + section->sh_info;

   if (((sym->st_info) & 0xF) == 3)
     {
       if (sym->st_shndx == 0
    || sym->st_shndx >= elf_header.e_shnum)
  {
    error (gettext ("Bad sh_info in group section `%s'\n"), name);
    continue;
  }

       group_name = ((section_headers + sym->st_shndx) == 
# 6628 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 6628 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<none>") : string_table == 
# 6628 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0) 
# 6628 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ? gettext ("<no-name>") : ((section_headers + sym->st_shndx)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section_headers + sym->st_shndx)->sh_name));
       strtab_sec = 
# 6629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 6629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
       if (strtab)
  free (strtab);
       strtab = 
# 6632 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 6632 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
       strtab_size = 0;
     }
   else
     {

       if (symtab_sec->sh_link >= elf_header.e_shnum)
  {
    strtab_sec = 
# 6640 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 6640 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;
    if (strtab)
      free (strtab);
    strtab = 
# 6643 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 6643 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    strtab_size = 0;
  }
       else if (strtab_sec
         != (sec = section_headers + symtab_sec->sh_link))
  {
    strtab_sec = sec;
    if (strtab)
      free (strtab);

    strtab = (char *) get_data (
# 6653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 6653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   , file, strtab_sec->sh_offset,
           1, strtab_sec->sh_size,
           gettext ("string table"));
    strtab_size = strtab != 
# 6656 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0) 
# 6656 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                ? strtab_sec->sh_size : 0;
  }
       group_name = sym->st_name < strtab_size
  ? strtab + sym->st_name : gettext ("<corrupt>");
     }


   if (section->sh_entsize > section->sh_size)
     {
       error (gettext ("Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n"),
       printable_section_name (section),
       (unsigned long) section->sh_entsize,
       (unsigned long) section->sh_size);
       break;
     }

   start = (unsigned char *) get_data (
# 6672 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 6672 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          , file, section->sh_offset,
                                              1, section->sh_size,
                                              gettext ("section data"));
   if (start == 
# 6675 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 6675 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
     continue;

   indices = start;
   size = (section->sh_size / section->sh_entsize) - 1;
   entry = byte_get (indices, 4);
   indices += 4;

   if (do_section_groups)
     {
       printf (gettext ("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"),
        get_group_flags (entry), i, name, group_name, size);

       printf (gettext ("   [Index]    Name\n"));
     }

   group->group_index = i;

   for (j = 0; j < size; j++)
     {
       struct group_list * g;

       entry = byte_get (indices, 4);
       indices += 4;

       if (entry >= elf_header.e_shnum)
  {
    static unsigned num_group_errors = 0;

    if (num_group_errors ++ < 10)
      {
        error (gettext ("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
        entry, i, elf_header.e_shnum - 1);
        if (num_group_errors == 10)
   warn (gettext ("Futher error messages about overlarge group section indicies suppressed\n"));
      }
    continue;
  }

       if (section_headers_groups [entry] != 
# 6714 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 6714 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                )
  {
    if (entry)
      {
        static unsigned num_errs = 0;

        if (num_errs ++ < 10)
   {
     error (gettext ("section [%5u] in group section [%5u] already in group section [%5u]\n"),
     entry, i,
     section_headers_groups [entry]->group_index);
     if (num_errs == 10)
       warn (gettext ("Further error messages about already contained group sections suppressed\n"));
   }
        continue;
      }
    else
      {



        static bfd_boolean warned = 0;
        if (!warned)
   {
     error (gettext ("section 0 in group section [%5u]\n"),
     section_headers_groups [entry]->group_index);
     warned = 1;
   }
      }
  }

       section_headers_groups [entry] = group;

       if (do_section_groups)
  {
    sec = section_headers + entry;
    printf ("   [%5u]   %s\n", entry, printable_section_name (sec));
  }

       g = (struct group_list *) xmalloc (sizeof (struct group_list));
       g->section_index = entry;
       g->next = group->root;
       group->root = g;
     }

   if (start)
     free (start);

   group++;
 }
    }

  if (symtab)
    free (symtab);
  if (strtab)
    free (strtab);
  return 1;
}



struct ia64_vms_dynfixup
{
  bfd_vma needed_ident;
  bfd_vma needed;
  bfd_vma fixup_needed;
  bfd_vma fixup_rela_cnt;
  bfd_vma fixup_rela_off;
};



struct ia64_vms_dynimgrela
{
  bfd_vma img_rela_cnt;
  bfd_vma img_rela_off;
};




static bfd_boolean
dump_ia64_vms_dynamic_fixups (FILE * file,
         struct ia64_vms_dynfixup * fixup,
                              const char * strtab,
         unsigned int strtab_sz)
{
  Elf64_External_VMS_IMAGE_FIXUP * imfs;
  long i;
  const char * lib_name;

  imfs = get_data (
# 6805 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 6805 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      , file, dynamic_addr + fixup->fixup_rela_off,
     1, fixup->fixup_rela_cnt * sizeof (*imfs),
     gettext ("dynamic section image fixups"));
  if (!imfs)
    return 0;

  if (fixup->needed < strtab_sz)
    lib_name = strtab + fixup->needed;
  else
    {
      warn (gettext ("corrupt library name index of 0x%lx found in dynamic entry"),
            (unsigned long) fixup->needed);
      lib_name = "???";
    }
  printf (gettext ("\nImage fixups for needed library #%d: %s - ident: %lx\n"),
   (int) fixup->fixup_needed, lib_name, (long) fixup->needed_ident);
  printf
    (gettext ("Seg Offset           Type                             SymVec DataType\n"));

  for (i = 0; i < (long) fixup->fixup_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) byte_get (imfs [i].fixup_seg, sizeof (imfs [i].fixup_seg)));
      fprintf (
# 6830 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     stdout
# 6830 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     , "%016" "l" "x", (bfd_vma) byte_get (imfs [i].fixup_offset, sizeof (imfs [i].fixup_offset)));
      type = byte_get (imfs [i].type, sizeof (imfs [i].type));
      rtype = elf_ia64_reloc_type (type);
      if (rtype == 
# 6833 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 6833 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
        printf (" 0x%08x                       ", type);
      else
        printf (" %-32s ", rtype);
      printf ("%6u ", (unsigned) byte_get (imfs [i].symvec_index, sizeof (imfs [i].symvec_index)));
      printf ("0x%08x\n", (unsigned) byte_get (imfs [i].data_type, sizeof (imfs [i].data_type)));
    }

  free (imfs);
  return 1;
}



static bfd_boolean
dump_ia64_vms_dynamic_relocs (FILE *file, struct ia64_vms_dynimgrela *imgrela)
{
  Elf64_External_VMS_IMAGE_RELA *imrs;
  long i;

  imrs = get_data (
# 6853 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 6853 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      , file, dynamic_addr + imgrela->img_rela_off,
     1, imgrela->img_rela_cnt * sizeof (*imrs),
     gettext ("dynamic section image relocations"));
  if (!imrs)
    return 0;

  printf (gettext ("\nImage relocs\n"));
  printf
    (gettext ("Seg Offset   Type                            Addend            Seg Sym Off\n"));

  for (i = 0; i < (long) imgrela->img_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) byte_get (imrs [i].rela_seg, sizeof (imrs [i].rela_seg)));
      printf ("%08" "l" "x ",
              (bfd_vma) byte_get (imrs [i].rela_offset, sizeof (imrs [i].rela_offset)));
      type = byte_get (imrs [i].type, sizeof (imrs [i].type));
      rtype = elf_ia64_reloc_type (type);
      if (rtype == 
# 6873 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 6873 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
        printf ("0x%08x                      ", type);
      else
        printf ("%-31s ", rtype);
      print_vma (byte_get (imrs [i].addend, sizeof (imrs [i].addend)), FULL_HEX);
      printf ("%3u ", (unsigned) byte_get (imrs [i].sym_seg, sizeof (imrs [i].sym_seg)));
      printf ("%08" "l" "x\n",
              (bfd_vma) byte_get (imrs [i].sym_offset, sizeof (imrs [i].sym_offset)));
    }

  free (imrs);
  return 1;
}



static bfd_boolean
process_ia64_vms_dynamic_relocs (FILE *file)
{
  struct ia64_vms_dynfixup fixup;
  struct ia64_vms_dynimgrela imgrela;
  Elf_Internal_Dyn *entry;
  bfd_vma strtab_off = 0;
  bfd_vma strtab_sz = 0;
  char *strtab = 
# 6897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 6897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;
  bfd_boolean res = 1;

  memset (&fixup, 0, sizeof (fixup));
  memset (&imgrela, 0, sizeof (imgrela));


  for (entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       entry++)
    {
      switch (entry->d_tag)
        {
        case (0x6000000d + 52):
          strtab_off = entry->d_un.d_val;
          break;
        case 10:
          strtab_sz = entry->d_un.d_val;
          if (strtab == 
# 6915 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 6915 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
            strtab = get_data (
# 6916 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 6916 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  , file, dynamic_addr + strtab_off,
                               1, strtab_sz, gettext ("dynamic string section"));
          break;

        case (0x6000000d + 16):
          fixup.needed_ident = entry->d_un.d_val;
          break;
        case 1:
          fixup.needed = entry->d_un.d_val;
          break;
        case (0x6000000d + 24):
          fixup.fixup_needed = entry->d_un.d_val;
          break;
        case (0x6000000d + 22):
          fixup.fixup_rela_cnt = entry->d_un.d_val;
          break;
        case (0x6000000d + 60):
          fixup.fixup_rela_off = entry->d_un.d_val;
          if (! dump_ia64_vms_dynamic_fixups (file, &fixup, strtab, strtab_sz))
     res = 0;
          break;
        case (0x6000000d + 18):
   imgrela.img_rela_cnt = entry->d_un.d_val;
          break;
        case (0x6000000d + 56):
   imgrela.img_rela_off = entry->d_un.d_val;
          if (! dump_ia64_vms_dynamic_relocs (file, &imgrela))
     res = 0;
          break;

        default:
          break;
 }
    }

  if (strtab != 
# 6951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 6951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    free (strtab);

  return res;
}

static struct
{
  const char * name;
  int reloc;
  int size;
  int rela;
}
  dynamic_relocations [] =
{
  { "REL", 17, 18, 0 },
  { "RELA", 7, 8, 1 },
  { "PLT", 23, 2, -1 }
};



static bfd_boolean
process_relocs (FILE * file)
{
  unsigned long rel_size;
  unsigned long rel_offset;

  if (!do_reloc)
    return 1;

  if (do_using_dynamic)
    {
      int is_rela;
      const char * name;
      bfd_boolean has_dynamic_reloc;
      unsigned int i;

      has_dynamic_reloc = 0;

      for (i = 0; i < (sizeof (dynamic_relocations) / sizeof ((dynamic_relocations)[0])); i++)
 {
   is_rela = dynamic_relocations [i].rela;
   name = dynamic_relocations [i].name;
   rel_size = dynamic_info [dynamic_relocations [i].size];
   rel_offset = dynamic_info [dynamic_relocations [i].reloc];

   if (rel_size)
     has_dynamic_reloc = 1;

   if (is_rela == -1)
     {
       if (dynamic_relocations [i].reloc == 23)
  switch (dynamic_info[20])
    {
    case 17:
      is_rela = 0;
      break;
    case 7:
      is_rela = 1;
      break;
    }
     }

   if (rel_size)
     {
       printf
  (gettext ("\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"),
   name, rel_offset, rel_size);

       dump_relocations (file,
    offset_from_vma (file, rel_offset, rel_size),
    rel_size,
    dynamic_symbols, num_dynamic_syms,
    dynamic_strings, dynamic_strings_length,
    is_rela, 1 );
     }
 }

      if (is_ia64_vms ())
        if (process_ia64_vms_dynamic_relocs (file))
   has_dynamic_reloc = 1;

      if (! has_dynamic_reloc)
 printf (gettext ("\nThere are no dynamic relocations in this file.\n"));
    }
  else
    {
      Elf_Internal_Shdr * section;
      unsigned long i;
      bfd_boolean found = 0;

      for (i = 0, section = section_headers;
    i < elf_header.e_shnum;
    i++, section++)
 {
   if ( section->sh_type != 4
       && section->sh_type != 9)
     continue;

   rel_offset = section->sh_offset;
   rel_size = section->sh_size;

   if (rel_size)
     {
       Elf_Internal_Shdr * strsec;
       int is_rela;

       printf (gettext ("\nRelocation section "));

       if (string_table == 
# 7061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          ((void *)0)
# 7061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              )
  printf ("%d", section->sh_name);
       else
  printf ("'%s'", printable_section_name (section));

       printf (gettext (" at offset 0x%lx contains %lu entries:\n"),
   rel_offset, (unsigned long) (rel_size / section->sh_entsize));

       is_rela = section->sh_type == 4;

       if (section->sh_link != 0
    && section->sh_link < elf_header.e_shnum)
  {
    Elf_Internal_Shdr * symsec;
    Elf_Internal_Sym * symtab;
    unsigned long nsyms;
    unsigned long strtablen = 0;
    char * strtab = 
# 7078 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 7078 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;

    symsec = section_headers + section->sh_link;
    if (symsec->sh_type != 2
        && symsec->sh_type != 11)
                    continue;

    symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, symsec, & nsyms) : get_64bit_elf_symbols (file, symsec, & nsyms));

    if (symtab == 
# 7087 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 7087 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
      continue;

    if (symsec->sh_link != 0
        && symsec->sh_link < elf_header.e_shnum)
      {
        strsec = section_headers + symsec->sh_link;

        strtab = (char *) get_data (
# 7095 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                   ((void *)0)
# 7095 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       , file, strsec->sh_offset,
        1, strsec->sh_size,
        gettext ("string table"));
        strtablen = strtab == 
# 7098 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0) 
# 7098 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ? 0 : strsec->sh_size;
      }

    dump_relocations (file, rel_offset, rel_size,
        symtab, nsyms, strtab, strtablen,
        is_rela,
        symsec->sh_type == 11);
    if (strtab)
      free (strtab);
    free (symtab);
  }
       else
  dump_relocations (file, rel_offset, rel_size,
      
# 7111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 7111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         , 0, 
# 7111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 7111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  , 0, is_rela,
      0 );

       found = 1;
     }
 }

      if (! found)
 printf (gettext ("\nThere are no relocations in this file.\n"));
    }

  return 1;
}





struct absaddr
{
  unsigned short section;
  bfd_vma offset;
};
# 7143 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static void
find_symbol_for_address (Elf_Internal_Sym * symtab,
    unsigned long nsyms,
    const char * strtab,
    unsigned long strtab_size,
    struct absaddr addr,
    const char ** symname,
    bfd_vma * offset)
{
  bfd_vma dist = 0x100000;
  Elf_Internal_Sym * sym;
  Elf_Internal_Sym * beg;
  Elf_Internal_Sym * end;
  Elf_Internal_Sym * best = 
# 7156 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 7156 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;

  do { if (elf_header.e_machine == 40) (addr.offset) &= ~1; } while (0);
  beg = symtab;
  end = symtab + nsyms;

  while (beg < end)
    {
      bfd_vma value;

      sym = beg + (end - beg) / 2;

      value = sym->st_value;
      do { if (elf_header.e_machine == 40) (value) &= ~1; } while (0);

      if (sym->st_name != 0
   && (addr.section == 0 || addr.section == sym->st_shndx)
   && addr.offset >= value
   && addr.offset - value < dist)
 {
   best = sym;
   dist = addr.offset - value;
   if (!dist)
     break;
 }

      if (addr.offset < value)
 end = sym;
      else
 beg = sym + 1;
    }

  if (best)
    {
      *symname = (best->st_name >= strtab_size
    ? gettext ("<corrupt>") : strtab + best->st_name);
      *offset = dist;
      return;
    }

  *symname = 
# 7196 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 7196 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
  *offset = addr.offset;
}

static int
symcmp (const void *p, const void *q)
{
  Elf_Internal_Sym *sp = (Elf_Internal_Sym *) p;
  Elf_Internal_Sym *sq = (Elf_Internal_Sym *) q;

  return sp->st_value > sq->st_value ? 1 : (sp->st_value < sq->st_value ? -1 : 0);
}



# 1 "/doner/binutils/binutils-7a31b38/binutils/unwind-ia64.h" 1
# 32 "/doner/binutils/binutils-7a31b38/binutils/unwind-ia64.h"
extern const unsigned char *unw_decode (const unsigned char *, int, void *, const unsigned char *);
# 7212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 2

struct ia64_unw_table_entry
{
  struct absaddr start;
  struct absaddr end;
  struct absaddr info;
};

struct ia64_unw_aux_info
{
  struct ia64_unw_table_entry * table;
  unsigned long table_len;
  unsigned char * info;
  unsigned long info_size;
  bfd_vma info_addr;
  bfd_vma seg_base;
  Elf_Internal_Sym * symtab;
  unsigned long nsyms;
  Elf_Internal_Sym * funtab;
  unsigned long nfuns;
  char * strtab;
  unsigned long strtab_size;
};

static bfd_boolean
dump_ia64_unwind (struct ia64_unw_aux_info * aux)
{
  struct ia64_unw_table_entry * tp;
  unsigned long j, nfuns;
  int in_body;
  bfd_boolean res = 1;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      bfd_vma stamp;
      bfd_vma offset;
      const unsigned char * dp;
      const unsigned char * head;
      const unsigned char * end;
      const char * procname;

      find_symbol_for_address (aux->funtab, aux->nfuns, aux->strtab,
          aux->strtab_size, tp->start, &procname, &offset);

      fputs ("\n<", 
# 7263 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 7263 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );

      if (procname)
 {
   fputs (procname, 
# 7267 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 7267 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );

   if (offset)
     printf ("+%lx", (unsigned long) offset);
 }

      fputs (">: [", 
# 7273 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    stdout
# 7273 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          );
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', 
# 7275 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 7275 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("], info at +0x%lx\n",
       (unsigned long) (tp->info.offset - aux->seg_base));


      if (aux->info == 
# 7281 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 7281 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
 continue;


      if ((((tp->info).section ? section_headers [(tp->info).section].sh_addr + (tp->info).offset : (tp->info).offset) - aux->info_addr) >= aux->info_size)
 {
   warn (gettext ("Invalid offset %lx in table entry %ld\n"),
  (long) tp->info.offset, (long) (tp - aux->table));
   res = 0;
   continue;
 }

      head = aux->info + (((tp->info).section ? section_headers [(tp->info).section].sh_addr + (tp->info).offset : (tp->info).offset) - aux->info_addr);
      stamp = byte_get ((unsigned char *) head, sizeof (stamp));

      printf ("  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
       (unsigned) ((stamp) >> 48),
       (unsigned long) ((stamp & 0x0000ffff00000000LL) >> 32),
       ((stamp) & 0x0000000100000000LL) ? " ehandler" : "",
       ((stamp) & 0x0000000200000000LL) ? " uhandler" : "",
       (unsigned long) (eh_addr_size * ((stamp) & 0x00000000ffffffffLL)));

      if (((stamp) >> 48) != 1)
 {
   printf (gettext ("\tUnknown version.\n"));
   continue;
 }

      in_body = 0;
      end = head + 8 + eh_addr_size * ((stamp) & 0x00000000ffffffffLL);

      if (end > aux->info + aux->info_size)
 end = aux->info + aux->info_size;
      for (dp = head + 8; dp < end;)
 dp = unw_decode (dp, in_body, & in_body, end);
    }

  free (aux->funtab);

  return res;
}

static bfd_boolean
slurp_ia64_unwind_table (FILE * file,
    struct ia64_unw_aux_info * aux,
    Elf_Internal_Shdr * sec)
{
  unsigned long size, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct ia64_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;

  aux->table_len = 0;




  if (elf_header.e_phnum)
    {
      if (! get_program_headers (file))
   return 0;

      for (seg = program_headers;
    seg < program_headers + elf_header.e_phnum;
    ++seg)
 {
   if (seg->p_type != 1)
     continue;

   if (sec->sh_addr >= seg->p_vaddr
       && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
     {
       aux->seg_base = seg->p_vaddr;
       break;
     }
 }
    }


  size = sec->sh_size;
  table = (unsigned char *) get_data (
# 7367 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 7367 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         , file, sec->sh_offset, 1, size,
                                      gettext ("unwind table"));
  if (!table)
    return 0;

  aux->table_len = size / (3 * eh_addr_size);
  aux->table = (struct ia64_unw_table_entry *)
    xcmalloc (aux->table_len, sizeof (aux->table[0]));
  tep = aux->table;

  for (tp = table; tp <= table + size - (3 * eh_addr_size); ++tep)
    {
      tep->start.section = 0;
      tep->end.section = 0;
      tep->info.section = 0;
      tep->start.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->end.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->info.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->start.offset += aux->seg_base;
      tep->end.offset += aux->seg_base;
      tep->info.offset += aux->seg_base;
    }
  free (table);


  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != 4
   || relsec->sh_info >= elf_header.e_shnum
   || section_headers + relsec->sh_info != sec)
 continue;

      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
         & rela, & nrelas))
 {
   free (aux->table);
   aux->table = 
# 7405 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 7405 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
   aux->table_len = 0;
   return 0;
 }

      for (rp = rela; rp < rela + nrelas; ++rp)
 {
   relname = elf_ia64_reloc_type (get_reloc_type (rp->r_info));
   sym = aux->symtab + get_reloc_symindex (rp->r_info);


   if (relname == 
# 7416 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 7416 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown relocation type: %u\n"), get_reloc_type (rp->r_info));
       continue;
     }

   if (! (strncmp ((relname), ("R_IA64_SEGREL"), sizeof ("R_IA64_SEGREL") - 1) == 0))
     {
       warn (gettext ("Skipping unexpected relocation type: %s\n"), relname);
       continue;
     }

   i = rp->r_offset / (3 * eh_addr_size);


   if (i >= aux->table_len)
     {
       warn (gettext ("Skipping reloc with overlarge offset: %lx\n"), i);
       continue;
     }

   switch (rp->r_offset / eh_addr_size % 3)
     {
     case 0:
       aux->table[i].start.section = sym->st_shndx;
       aux->table[i].start.offset = rp->r_addend + sym->st_value;
       break;
     case 1:
       aux->table[i].end.section = sym->st_shndx;
       aux->table[i].end.offset = rp->r_addend + sym->st_value;
       break;
     case 2:
       aux->table[i].info.section = sym->st_shndx;
       aux->table[i].info.offset = rp->r_addend + sym->st_value;
       break;
     default:
       break;
     }
 }

      free (rela);
    }

  return 1;
}

static bfd_boolean
ia64_process_unwind (FILE * file)
{
  Elf_Internal_Shdr * sec;
  Elf_Internal_Shdr * unwsec = 
# 7466 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 7466 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
  Elf_Internal_Shdr * strsec;
  unsigned long i, unwcount = 0, unwstart = 0;
  struct ia64_unw_aux_info aux;
  bfd_boolean res = 1;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2
   && sec->sh_link < elf_header.e_shnum)
 {
   aux.symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, sec, & aux.nsyms) : get_64bit_elf_symbols (file, sec, & aux.nsyms));

   strsec = section_headers + sec->sh_link;
   if (aux.strtab != 
# 7482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 7482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
     {
       error (gettext ("Multiple auxillary string tables encountered\n"));
       free (aux.strtab);
       res = 0;
     }
   aux.strtab = (char *) get_data (
# 7488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 7488 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      , file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          gettext ("string table"));
   aux.strtab_size = aux.strtab != 
# 7491 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0) 
# 7491 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       ? strsec->sh_size : 0;
 }
      else if (sec->sh_type == (0x70000000 + 1))
 unwcount++;
    }

  if (!unwcount)
    printf (gettext ("\nThere are no unwind sections in this file.\n"));

  while (unwcount-- > 0)
    {
      char * suffix;
      size_t len, len2;

      for (i = unwstart, sec = section_headers + unwstart, unwsec = 
# 7505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                   ((void *)0)
# 7505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                       ;
    i < elf_header.e_shnum; ++i, ++sec)
 if (sec->sh_type == (0x70000000 + 1))
   {
     unwsec = sec;
     break;
   }


      
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void) sizeof ((
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     unwsec != 
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     unwsec != 
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)) ; else __assert_fail (
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     "unwsec != NULL"
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 7514, __extension__ __PRETTY_FUNCTION__); }))
# 7514 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            ;

      unwstart = i + 1;
      len = sizeof (".gnu.linkonce.ia64unw.") - 1;

      if ((unwsec->sh_flags & (1 << 9)) != 0)
 {

   struct group_list * g;

   if (section_headers_groups == 
# 7524 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
       
# 7525 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      || section_headers_groups [i] == 
# 7525 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       ((void *)0)
# 7525 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           )
     i = elf_header.e_shnum;
   else
     {
       g = section_headers_groups [i]->root;

       for (; g != 
# 7531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 7531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ; g = g->next)
  {
    sec = section_headers + g->section_index;

    if ((strcmp ((((sec) == 
# 7535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 7535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<none>") : string_table == 
# 7535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0) 
# 7535 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name))), (".IA_64.unwind_info")) == 0))
      break;
  }

       if (g == 
# 7539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 7539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
  i = elf_header.e_shnum;
     }
 }
      else if ((strncmp ((((unwsec) == 
# 7543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0) 
# 7543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ? gettext ("<none>") : string_table == 
# 7543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0) 
# 7543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ? gettext ("<no-name>") : ((unwsec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (unwsec)->sh_name))), (".gnu.linkonce.ia64unw."), (len)) == 0))
 {

   len2 = sizeof (".gnu.linkonce.ia64unwi.") - 1;
   suffix = ((unwsec) == 
# 7547 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0) 
# 7547 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
           ? gettext ("<none>") : string_table == 
# 7547 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0) 
# 7547 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
           ? gettext ("<no-name>") : ((unwsec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (unwsec)->sh_name)) + len;
   for (i = 0, sec = section_headers; i < elf_header.e_shnum;
        ++i, ++sec)
     if ((strncmp ((((sec) == 
# 7550 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0) 
# 7550 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
        ? gettext ("<none>") : string_table == 
# 7550 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0) 
# 7550 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
        ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name))), (".gnu.linkonce.ia64unwi."), (len2)) == 0)
  && (strcmp ((((sec) == 
# 7551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 7551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<none>") : string_table == 
# 7551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 7551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name)) + len2), (suffix)) == 0))
       break;
 }
      else
 {


   len = sizeof (".IA_64.unwind") - 1;
   len2 = sizeof (".IA_64.unwind_info") - 1;
   suffix = "";
   if ((strncmp ((((unwsec) == 
# 7561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0) 
# 7561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      ? gettext ("<none>") : string_table == 
# 7561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0) 
# 7561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      ? gettext ("<no-name>") : ((unwsec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (unwsec)->sh_name))), (".IA_64.unwind"), (len)) == 0))
     suffix = ((unwsec) == 
# 7562 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 7562 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ? gettext ("<none>") : string_table == 
# 7562 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 7562 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ? gettext ("<no-name>") : ((unwsec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (unwsec)->sh_name)) + len;
   for (i = 0, sec = section_headers; i < elf_header.e_shnum;
        ++i, ++sec)
     if ((strncmp ((((sec) == 
# 7565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0) 
# 7565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
        ? gettext ("<none>") : string_table == 
# 7565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0) 
# 7565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
        ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name))), (".IA_64.unwind_info"), (len2)) == 0)
  && (strcmp ((((sec) == 
# 7566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 7566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<none>") : string_table == 
# 7566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 7566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name)) + len2), (suffix)) == 0))
       break;
 }

      if (i == elf_header.e_shnum)
 {
   printf (gettext ("\nCould not find unwind info section for "));

   if (string_table == 
# 7574 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 7574 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
     printf ("%d", unwsec->sh_name);
   else
     printf ("'%s'", printable_section_name (unwsec));
 }
      else
 {
   aux.info_addr = sec->sh_addr;
   aux.info = (unsigned char *) get_data (
# 7582 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 7582 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             , file, sec->sh_offset, 1,
       sec->sh_size,
       gettext ("unwind info"));
   aux.info_size = aux.info == 
# 7585 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0) 
# 7585 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   ? 0 : sec->sh_size;

   printf (gettext ("\nUnwind section "));

   if (string_table == 
# 7589 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 7589 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
     printf ("%d", unwsec->sh_name);
   else
     printf ("'%s'", printable_section_name (unwsec));

   printf (gettext (" at offset 0x%lx contains %lu entries:\n"),
    (unsigned long) unwsec->sh_offset,
    (unsigned long) (unwsec->sh_size / (3 * eh_addr_size)));

   if (slurp_ia64_unwind_table (file, & aux, unwsec)
       && aux.table_len > 0)
     dump_ia64_unwind (& aux);

   if (aux.table)
     free ((char *) aux.table);
   if (aux.info)
     free ((char *) aux.info);
   aux.table = 
# 7606 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 7606 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
   aux.info = 
# 7607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 7607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 ;
 }
    }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);

  return res;
}

struct hppa_unw_table_entry
{
  struct absaddr start;
  struct absaddr end;
  unsigned int Cannot_unwind:1;
  unsigned int Millicode:1;
  unsigned int Millicode_save_sr0:1;
  unsigned int Region_description:2;
  unsigned int reserved1:1;
  unsigned int Entry_SR:1;
  unsigned int Entry_FR:4;
  unsigned int Entry_GR:5;
  unsigned int Args_stored:1;
  unsigned int Variable_Frame:1;
  unsigned int Separate_Package_Body:1;
  unsigned int Frame_Extension_Millicode:1;
  unsigned int Stack_Overflow_Check:1;
  unsigned int Two_Instruction_SP_Increment:1;
  unsigned int Ada_Region:1;
  unsigned int cxx_info:1;
  unsigned int cxx_try_catch:1;
  unsigned int sched_entry_seq:1;
  unsigned int reserved2:1;
  unsigned int Save_SP:1;
  unsigned int Save_RP:1;
  unsigned int Save_MRP_in_frame:1;
  unsigned int extn_ptr_defined:1;
  unsigned int Cleanup_defined:1;

  unsigned int MPE_XL_interrupt_marker:1;
  unsigned int HP_UX_interrupt_marker:1;
  unsigned int Large_frame:1;
  unsigned int Pseudo_SP_Set:1;
  unsigned int reserved4:1;
  unsigned int Total_frame_size:27;
};

struct hppa_unw_aux_info
{
  struct hppa_unw_table_entry * table;
  unsigned long table_len;
  bfd_vma seg_base;
  Elf_Internal_Sym * symtab;
  unsigned long nsyms;
  Elf_Internal_Sym * funtab;
  unsigned long nfuns;
  char * strtab;
  unsigned long strtab_size;
};

static bfd_boolean
dump_hppa_unwind (struct hppa_unw_aux_info * aux)
{
  struct hppa_unw_table_entry * tp;
  unsigned long j, nfuns;
  bfd_boolean res = 1;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      bfd_vma offset;
      const char * procname;

      find_symbol_for_address (aux->funtab, aux->nfuns, aux->strtab,
          aux->strtab_size, tp->start, &procname,
          &offset);

      fputs ("\n<", 
# 7692 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 7692 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );

      if (procname)
 {
   fputs (procname, 
# 7696 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 7696 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );

   if (offset)
     printf ("+%lx", (unsigned long) offset);
 }

      fputs (">: [", 
# 7702 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    stdout
# 7702 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          );
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', 
# 7704 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 7704 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("]\n\t");



      if (tp->Cannot_unwind) printf ("Cannot_unwind" " ");;
      if (tp->Millicode) printf ("Millicode" " ");;
      if (tp->Millicode_save_sr0) printf ("Millicode_save_sr0" " ");;

      if (tp->Entry_SR) printf ("Entry_SR" " ");;
      if (tp->Entry_FR) printf ("Entry_FR" "=%d ", tp->Entry_FR);;
      if (tp->Entry_GR) printf ("Entry_GR" "=%d ", tp->Entry_GR);;
      if (tp->Args_stored) printf ("Args_stored" " ");;
      if (tp->Variable_Frame) printf ("Variable_Frame" " ");;
      if (tp->Separate_Package_Body) printf ("Separate_Package_Body" " ");;
      if (tp->Frame_Extension_Millicode) printf ("Frame_Extension_Millicode" " ");;
      if (tp->Stack_Overflow_Check) printf ("Stack_Overflow_Check" " ");;
      if (tp->Two_Instruction_SP_Increment) printf ("Two_Instruction_SP_Increment" " ");;
      if (tp->Ada_Region) printf ("Ada_Region" " ");;
      if (tp->cxx_info) printf ("cxx_info" " ");;
      if (tp->cxx_try_catch) printf ("cxx_try_catch" " ");;
      if (tp->sched_entry_seq) printf ("sched_entry_seq" " ");;
      if (tp->Save_SP) printf ("Save_SP" " ");;
      if (tp->Save_RP) printf ("Save_RP" " ");;
      if (tp->Save_MRP_in_frame) printf ("Save_MRP_in_frame" " ");;
      if (tp->extn_ptr_defined) printf ("extn_ptr_defined" " ");;
      if (tp->Cleanup_defined) printf ("Cleanup_defined" " ");;
      if (tp->MPE_XL_interrupt_marker) printf ("MPE_XL_interrupt_marker" " ");;
      if (tp->HP_UX_interrupt_marker) printf ("HP_UX_interrupt_marker" " ");;
      if (tp->Large_frame) printf ("Large_frame" " ");;
      if (tp->Pseudo_SP_Set) printf ("Pseudo_SP_Set" " ");;
      if (tp->Total_frame_size) printf ("Total_frame_size" "=%d ", tp->Total_frame_size);;


    }

  printf ("\n");

  free (aux->funtab);

  return res;
}

static bfd_boolean
slurp_hppa_unwind_table (FILE * file,
    struct hppa_unw_aux_info * aux,
    Elf_Internal_Shdr * sec)
{
  unsigned long size, unw_ent_size, nentries, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct hppa_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;



  if (elf_header.e_phnum)
    {
      if (! get_program_headers (file))
 return 0;

      for (seg = program_headers;
    seg < program_headers + elf_header.e_phnum;
    ++seg)
 {
   if (seg->p_type != 1)
     continue;

   if (sec->sh_addr >= seg->p_vaddr
       && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
     {
       aux->seg_base = seg->p_vaddr;
       break;
     }
 }
    }



  size = sec->sh_size;
  table = (unsigned char *) get_data (
# 7790 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 7790 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         , file, sec->sh_offset, 1, size,
                                      gettext ("unwind table"));
  if (!table)
    return 0;

  unw_ent_size = 16;
  nentries = size / unw_ent_size;
  size = unw_ent_size * nentries;

  tep = aux->table = (struct hppa_unw_table_entry *)
      xcmalloc (nentries, sizeof (aux->table[0]));

  for (tp = table; tp < table + size; tp += unw_ent_size, ++tep)
    {
      unsigned int tmp1, tmp2;

      tep->start.section = 0;
      tep->end.section = 0;

      tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
      tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
      tmp1 = byte_get ((unsigned char *) tp + 8, 4);
      tmp2 = byte_get ((unsigned char *) tp + 12, 4);

      tep->start.offset += aux->seg_base;
      tep->end.offset += aux->seg_base;

      tep->Cannot_unwind = (tmp1 >> 31) & 0x1;
      tep->Millicode = (tmp1 >> 30) & 0x1;
      tep->Millicode_save_sr0 = (tmp1 >> 29) & 0x1;
      tep->Region_description = (tmp1 >> 27) & 0x3;
      tep->reserved1 = (tmp1 >> 26) & 0x1;
      tep->Entry_SR = (tmp1 >> 25) & 0x1;
      tep->Entry_FR = (tmp1 >> 21) & 0xf;
      tep->Entry_GR = (tmp1 >> 16) & 0x1f;
      tep->Args_stored = (tmp1 >> 15) & 0x1;
      tep->Variable_Frame = (tmp1 >> 14) & 0x1;
      tep->Separate_Package_Body = (tmp1 >> 13) & 0x1;
      tep->Frame_Extension_Millicode = (tmp1 >> 12) & 0x1;
      tep->Stack_Overflow_Check = (tmp1 >> 11) & 0x1;
      tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 0x1;
      tep->Ada_Region = (tmp1 >> 9) & 0x1;
      tep->cxx_info = (tmp1 >> 8) & 0x1;
      tep->cxx_try_catch = (tmp1 >> 7) & 0x1;
      tep->sched_entry_seq = (tmp1 >> 6) & 0x1;
      tep->reserved2 = (tmp1 >> 5) & 0x1;
      tep->Save_SP = (tmp1 >> 4) & 0x1;
      tep->Save_RP = (tmp1 >> 3) & 0x1;
      tep->Save_MRP_in_frame = (tmp1 >> 2) & 0x1;
      tep->extn_ptr_defined = (tmp1 >> 1) & 0x1;
      tep->Cleanup_defined = tmp1 & 0x1;

      tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 0x1;
      tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 0x1;
      tep->Large_frame = (tmp2 >> 29) & 0x1;
      tep->Pseudo_SP_Set = (tmp2 >> 28) & 0x1;
      tep->reserved4 = (tmp2 >> 27) & 0x1;
      tep->Total_frame_size = tmp2 & 0x7ffffff;
    }
  free (table);


  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != 4
   || relsec->sh_info >= elf_header.e_shnum
   || section_headers + relsec->sh_info != sec)
 continue;

      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
         & rela, & nrelas))
 return 0;

      for (rp = rela; rp < rela + nrelas; ++rp)
 {
   relname = elf_hppa_reloc_type (get_reloc_type (rp->r_info));
   sym = aux->symtab + get_reloc_symindex (rp->r_info);


   if (! (strncmp ((relname), ("R_PARISC_SEGREL"), sizeof ("R_PARISC_SEGREL") - 1) == 0))
     {
       warn (gettext ("Skipping unexpected relocation type %s\n"), relname);
       continue;
     }

   i = rp->r_offset / unw_ent_size;

   switch ((rp->r_offset % unw_ent_size) / eh_addr_size)
     {
     case 0:
       aux->table[i].start.section = sym->st_shndx;
       aux->table[i].start.offset = sym->st_value + rp->r_addend;
       break;
     case 1:
       aux->table[i].end.section = sym->st_shndx;
       aux->table[i].end.offset = sym->st_value + rp->r_addend;
       break;
     default:
       break;
     }
 }

      free (rela);
    }

  aux->table_len = nentries;

  return 1;
}

static bfd_boolean
hppa_process_unwind (FILE * file)
{
  struct hppa_unw_aux_info aux;
  Elf_Internal_Shdr * unwsec = 
# 7906 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 7906 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
  Elf_Internal_Shdr * strsec;
  Elf_Internal_Shdr * sec;
  unsigned long i;
  bfd_boolean res = 1;

  if (string_table == 
# 7912 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 7912 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
    return 0;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2
   && sec->sh_link < elf_header.e_shnum)
 {
   aux.symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, sec, & aux.nsyms) : get_64bit_elf_symbols (file, sec, & aux.nsyms));

   strsec = section_headers + sec->sh_link;
   if (aux.strtab != 
# 7925 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 7925 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
     {
       error (gettext ("Multiple auxillary string tables encountered\n"));
       free (aux.strtab);
       res = 0;
     }
   aux.strtab = (char *) get_data (
# 7931 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 7931 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      , file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          gettext ("string table"));
   aux.strtab_size = aux.strtab != 
# 7934 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0) 
# 7934 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       ? strsec->sh_size : 0;
 }
      else if ((strcmp ((((sec) == 
# 7936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0) 
# 7936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ? gettext ("<none>") : string_table == 
# 7936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0) 
# 7936 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name))), (".PARISC.unwind")) == 0))
 unwsec = sec;
    }

  if (!unwsec)
    printf (gettext ("\nThere are no unwind sections in this file.\n"));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if ((strcmp ((((sec) == 
# 7945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0) 
# 7945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ? gettext ("<none>") : string_table == 
# 7945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0) 
# 7945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ? gettext ("<no-name>") : ((sec)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (sec)->sh_name))), (".PARISC.unwind")) == 0))
 {
   printf (gettext ("\nUnwind section '%s' at offset 0x%lx contains %lu entries:\n"),
    printable_section_name (sec),
    (unsigned long) sec->sh_offset,
    (unsigned long) (sec->sh_size / (2 * eh_addr_size + 8)));

          if (! slurp_hppa_unwind_table (file, &aux, sec))
     res = 0;

   if (aux.table_len > 0)
     {
       if (! dump_hppa_unwind (&aux))
  res = 0;
     }

   if (aux.table)
     free ((char *) aux.table);
   aux.table = 
# 7963 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 7963 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
 }
    }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);

  return res;
}

struct arm_section
{
  unsigned char * data;
  Elf_Internal_Shdr * sec;
  Elf_Internal_Rela * rela;
  unsigned long nrelas;
  unsigned int rel_type;
  Elf_Internal_Rela * next_rela;
};

struct arm_unw_aux_info
{
  FILE * file;
  Elf_Internal_Sym * symtab;
  unsigned long nsyms;
  Elf_Internal_Sym * funtab;
  unsigned long nfuns;
  char * strtab;
  unsigned long strtab_size;
};

static const char *
arm_print_vma_and_name (struct arm_unw_aux_info *aux,
   bfd_vma fn, struct absaddr addr)
{
  const char *procname;
  bfd_vma sym_offset;

  if (addr.section == 0)
    addr.offset = fn;

  find_symbol_for_address (aux->funtab, aux->nfuns, aux->strtab,
      aux->strtab_size, addr, &procname,
      &sym_offset);

  print_vma (fn, PREFIX_HEX);

  if (procname)
    {
      fputs (" <", 
# 8014 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  stdout
# 8014 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        );
      fputs (procname, 
# 8015 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      stdout
# 8015 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            );

      if (sym_offset)
 printf ("+0x%lx", (unsigned long) sym_offset);
      fputc ('>', 
# 8019 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 8019 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
    }

  return procname;
}

static void
arm_free_section (struct arm_section *arm_sec)
{
  if (arm_sec->data != 
# 8028 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 8028 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
    free (arm_sec->data);

  if (arm_sec->rela != 
# 8031 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 8031 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
    free (arm_sec->rela);
}
# 8046 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static bfd_boolean
get_unwind_section_word (struct arm_unw_aux_info * aux,
    struct arm_section * arm_sec,
    Elf_Internal_Shdr * sec,
    bfd_vma word_offset,
    unsigned int * wordp,
    struct absaddr * addr,
    bfd_vma * sym_name)
{
  Elf_Internal_Rela *rp;
  Elf_Internal_Sym *sym;
  const char * relname;
  unsigned int word;
  bfd_boolean wrapped;

  if (sec == 
# 8061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0) 
# 8061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 || arm_sec == 
# 8061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 8061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   )
    return 0;

  addr->section = 0;
  addr->offset = 0;

  if (sym_name != 
# 8067 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 8067 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
    *sym_name = (bfd_vma) -1;


  if (sec != arm_sec->sec)
    {
      Elf_Internal_Shdr *relsec;

      arm_free_section (arm_sec);

      arm_sec->sec = sec;
      arm_sec->data = get_data (
# 8078 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 8078 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   , aux->file, sec->sh_offset, 1,
    sec->sh_size, gettext ("unwind data"));
      arm_sec->rela = 
# 8080 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 8080 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;
      arm_sec->nrelas = 0;

      for (relsec = section_headers;
    relsec < section_headers + elf_header.e_shnum;
    ++relsec)
 {
   if (relsec->sh_info >= elf_header.e_shnum
       || section_headers + relsec->sh_info != sec

       || (relsec->sh_type != 9
    && relsec->sh_type != 4))
     continue;

   arm_sec->rel_type = relsec->sh_type;
   if (relsec->sh_type == 9)
     {
       if (!slurp_rel_relocs (aux->file, relsec->sh_offset,
         relsec->sh_size,
         & arm_sec->rela, & arm_sec->nrelas))
  return 0;
     }
   else
     {
       if (!slurp_rela_relocs (aux->file, relsec->sh_offset,
          relsec->sh_size,
          & arm_sec->rela, & arm_sec->nrelas))
  return 0;
     }
   break;
 }

      arm_sec->next_rela = arm_sec->rela;
    }


  if (arm_sec->data == 
# 8116 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 8116 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
    return 0;


  if (
      sec->sh_size < 4
      || word_offset > (sec->sh_size - 4)
      || ((bfd_signed_vma) word_offset) < 0)
    return 0;


  word = byte_get (arm_sec->data + word_offset, 4);


  if (arm_sec->rela == 
# 8130 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 8130 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
    {
      * wordp = word;
      return 1;
    }


  wrapped = 0;
  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
    {
      bfd_vma prelval, offset;

      if (rp->r_offset > word_offset && !wrapped)
 {
   rp = arm_sec->rela;
   wrapped = 1;
 }
      if (rp->r_offset > word_offset)
 break;

      if (rp->r_offset & 3)
 {
   warn (gettext ("Skipping unexpected relocation at offset 0x%lx\n"),
  (unsigned long) rp->r_offset);
   continue;
 }

      if (rp->r_offset < word_offset)
 continue;


      if (aux->symtab == 
# 8161 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 8161 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
 continue;

      if (arm_sec->rel_type == 9)
 {
   offset = word & 0x7fffffff;
   if (offset & 0x40000000)
     offset |= ~ (bfd_vma) 0x7fffffff;
 }
      else if (arm_sec->rel_type == 4)
 offset = rp->r_addend;
      else
 {
   error (gettext ("Unknown section relocation type %d encountered\n"),
   arm_sec->rel_type);
   break;
 }


      if (((rp->r_info) >> 8) >= aux->nsyms)
 {
   error (gettext ("Bad symbol index in unwind relocation (%lu > %lu)\n"),
   (unsigned long) ((rp->r_info) >> 8), aux->nsyms);
   break;
 }

      sym = aux->symtab + ((rp->r_info) >> 8);
      offset += sym->st_value;
      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);


      if (elf_header.e_machine == 40)
 {
   relname = elf_arm_reloc_type (((rp->r_info) & 0xff));
   if (relname == 
# 8195 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 8195 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown ARM relocation type: %d\n"),
      (int) ((rp->r_info) & 0xff));
       continue;
     }

   if ((strcmp ((relname), ("R_ARM_NONE")) == 0))
       continue;

   if (! (strcmp ((relname), ("R_ARM_PREL31")) == 0))
     {
       warn (gettext ("Skipping unexpected ARM relocation type %s\n"), relname);
       continue;
     }
 }
      else if (elf_header.e_machine == 140)
 {
   relname = elf_tic6x_reloc_type (((rp->r_info) & 0xff));
   if (relname == 
# 8214 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 8214 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown C6000 relocation type: %d\n"),
      (int) ((rp->r_info) & 0xff));
       continue;
     }

   if ((strcmp ((relname), ("R_C6000_NONE")) == 0))
     continue;

   if (! (strcmp ((relname), ("R_C6000_PREL31")) == 0))
     {
       warn (gettext ("Skipping unexpected C6000 relocation type %s\n"), relname);
       continue;
     }

   prelval >>= 1;
 }
      else
 {

   warn (gettext ("Only TI and ARM unwinders are currently supported\n"));
   break;
 }

      word = (word & ~ (bfd_vma) 0x7fffffff) | (prelval & 0x7fffffff);
      addr->section = sym->st_shndx;
      addr->offset = offset;

      if (sym_name)
 * sym_name = sym->st_name;
      break;
    }

  *wordp = word;
  arm_sec->next_rela = rp;

  return 1;
}

static const char *tic6x_unwind_regnames[16] =
{
  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
  "A14", "A13", "A12", "A11", "A10",
  "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"
};

static void
decode_tic6x_unwind_regmask (unsigned int mask)
{
  int i;

  for (i = 12; mask; mask >>= 1, i--)
    {
      if (mask & 1)
 {
   fputs (tic6x_unwind_regnames[i], 
# 8270 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                   stdout
# 8270 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         );
   if (mask > 1)
     fputs (", ", 
# 8272 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 stdout
# 8272 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       );
 }
    }
}
# 8303 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static bfd_boolean
decode_arm_unwind_bytecode (struct arm_unw_aux_info * aux,
       unsigned int word,
       unsigned int remaining,
       unsigned int more_words,
       bfd_vma data_offset,
       Elf_Internal_Shdr * data_sec,
       struct arm_section * data_arm_sec)
{
  struct absaddr addr;
  bfd_boolean res = 1;


  while (1)
    {
      unsigned int op, op2;

      if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8320 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 8320 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     )) return 0; remaining = 4; more_words--; };
      if (remaining == 0)
 break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
 {
   int offset = ((op & 0x3f) << 2) + 4;

   printf ("     vsp = vsp + %d", offset);
 }
      else if ((op & 0xc0) == 0x40)
 {
   int offset = ((op & 0x3f) << 2) + 4;

   printf ("     vsp = vsp - %d", offset);
 }
      else if ((op & 0xf0) == 0x80)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8343 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8343 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   if (op == 0x80 && op2 == 0)
     printf (gettext ("Refuse to unwind"));
   else
     {
       unsigned int mask = ((op & 0x0f) << 8) | op2;
       bfd_boolean first = 1;
       int i;

       printf ("pop {");
       for (i = 0; i < 12; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 0;
      else
        printf (", ");
      printf ("r%d", 4 + i);
    }
       printf ("}");
     }
 }
      else if ((op & 0xf0) == 0x90)
 {
   if (op == 0x9d || op == 0x9f)
     printf (gettext ("     [Reserved]"));
   else
     printf ("     vsp = r%d", op & 0x0f);
 }
      else if ((op & 0xf0) == 0xa0)
 {
   int end = 4 + (op & 0x07);
   bfd_boolean first = 1;
   int i;

   printf ("     pop {");
   for (i = 4; i <= end; i++)
     {
       if (first)
  first = 0;
       else
  printf (", ");
       printf ("r%d", i);
     }
   if (op & 0x08)
     {
       if (!first)
  printf (", ");
       printf ("r14");
     }
   printf ("}");
 }
      else if (op == 0xb0)
 printf (gettext ("     finish"));
      else if (op == 0xb1)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8399 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8399 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   if (op2 == 0 || (op2 & 0xf0) != 0)
     printf (gettext ("[Spare]"));
   else
     {
       unsigned int mask = op2 & 0x0f;
       bfd_boolean first = 1;
       int i;

       printf ("pop {");
       for (i = 0; i < 12; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 0;
      else
        printf (", ");
      printf ("r%d", i);
    }
       printf ("}");
     }
 }
      else if (op == 0xb2)
 {
   unsigned char buf[9];
   unsigned int i, len;
   unsigned long offset;

   for (i = 0; i < sizeof (buf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8429 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0)
# 8429 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (buf[i]) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", buf[i]);
       if ((buf[i] & 0x80) == 0)
  break;
     }
   if (i == sizeof (buf))
     {
       error (gettext ("corrupt change to vsp"));
       res = 0;
     }
   else
     {
       offset = read_uleb128 (buf, &len, buf + i + 1);
       
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void) sizeof ((
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      len == i + 1
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ) ? 1 : 0), __extension__ ({ if (
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      len == i + 1
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ) ; else __assert_fail (
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      "len == i + 1"
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 8441, __extension__ __PRETTY_FUNCTION__); }))
# 8441 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
       offset = offset * 4 + 0x204;
       printf ("vsp = vsp + %ld", offset);
     }
 }
      else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
 {
   unsigned int first, last;

   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   first = op2 >> 4;
   last = op2 & 0x0f;
   if (op == 0xc8)
     first = first + 16;
   printf ("pop {D%d", first);
   if (last)
     printf ("-D%d", first + last);
   printf ("}");
 }
      else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
 {
   unsigned int count = op & 0x07;

   printf ("pop {D8");
   if (count)
     printf ("-D%d", 8 + count);
   printf ("}");
 }
      else if (op >= 0xc0 && op <= 0xc5)
 {
   unsigned int count = op & 0x07;

   printf ("     pop {wR10");
   if (count)
     printf ("-wR%d", 10 + count);
   printf ("}");
 }
      else if (op == 0xc6)
 {
   unsigned int first, last;

   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   first = op2 >> 4;
   last = op2 & 0x0f;
   printf ("pop {wR%d", first);
   if (last)
     printf ("-wR%d", first + last);
   printf ("}");
 }
      else if (op == 0xc7)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8492 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8492 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   if (op2 == 0 || (op2 & 0xf0) != 0)
     printf (gettext ("[Spare]"));
   else
     {
       unsigned int mask = op2 & 0x0f;
       bfd_boolean first = 1;
       int i;

       printf ("pop {");
       for (i = 0; i < 4; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 0;
      else
        printf (", ");
      printf ("wCGR%d", i);
    }
       printf ("}");
     }
 }
      else
 {
   printf (gettext ("     [unsupported opcode]"));
   res = 0;
 }

      printf ("\n");
    }

  return res;
}

static bfd_boolean
decode_tic6x_unwind_bytecode (struct arm_unw_aux_info * aux,
         unsigned int word,
         unsigned int remaining,
         unsigned int more_words,
         bfd_vma data_offset,
         Elf_Internal_Shdr * data_sec,
         struct arm_section * data_arm_sec)
{
  struct absaddr addr;


  while (1)
    {
      unsigned int op, op2;

      if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8542 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 8542 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     )) return 0; remaining = 4; more_words--; };
      if (remaining == 0)
 break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
 {
   int offset = ((op & 0x3f) << 3) + 8;
   printf ("     sp = sp + %d", offset);
 }
      else if ((op & 0xc0) == 0x80)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8558 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8558 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
   if (op == 0x80 && op2 == 0)
     printf (gettext ("Refuse to unwind"));
   else
     {
       unsigned int mask = ((op & 0x1f) << 8) | op2;
       if (op & 0x20)
  printf ("pop compact {");
       else
  printf ("pop {");

       decode_tic6x_unwind_regmask (mask);
       printf("}");
     }
 }
      else if ((op & 0xf0) == 0xc0)
 {
   unsigned int reg;
   unsigned int nregs;
   unsigned int i;
   const char *name;
   struct
   {
     unsigned int offset;
     unsigned int reg;
   } regpos[16];



   nregs = 0;
   for (i = 0; nregs < (op & 0xf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8590 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0)
# 8590 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", op2);
       reg = op2 >> 4;
       if (reg != 0xf)
  {
    regpos[nregs].offset = i * 2;
    regpos[nregs].reg = reg;
    nregs++;
  }

       reg = op2 & 0xf;
       if (reg != 0xf)
  {
    regpos[nregs].offset = i * 2 + 1;
    regpos[nregs].reg = reg;
    nregs++;
  }
     }

   printf (gettext ("pop frame {"));
   reg = nregs - 1;
   for (i = i * 2; i > 0; i--)
     {
       if (regpos[reg].offset == i - 1)
  {
    name = tic6x_unwind_regnames[regpos[reg].reg];
    if (reg > 0)
      reg--;
  }
       else
  name = gettext ("[pad]");

       fputs (name, 
# 8621 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 8621 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );
       if (i > 1)
  printf (", ");
     }

   printf ("}");
 }
      else if (op == 0xd0)
 printf ("     MOV FP, SP");
      else if (op == 0xd1)
 printf ("     __c6xabi_pop_rts");
      else if (op == 0xd2)
 {
   unsigned char buf[9];
   unsigned int i, len;
   unsigned long offset;

   for (i = 0; i < sizeof (buf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8640 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0)
# 8640 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      )) return 0; remaining = 4; more_words--; }; if (remaining) { remaining--; (buf[i]) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 0; } printf ("0x%02x ", buf[i]);
       if ((buf[i] & 0x80) == 0)
  break;
     }

   if (i == sizeof (buf))
     {
       warn (gettext ("Corrupt stack pointer adjustment detected\n"));
       return 0;
     }

   offset = read_uleb128 (buf, &len, buf + i + 1);
   
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void) sizeof ((
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  len == i + 1
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ) ? 1 : 0), __extension__ ({ if (
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  len == i + 1
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ) ; else __assert_fail (
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  "len == i + 1"
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 8652, __extension__ __PRETTY_FUNCTION__); }))
# 8652 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
   offset = offset * 8 + 0x408;
   printf (gettext ("sp = sp + %ld"), offset);
 }
      else if ((op & 0xf0) == 0xe0)
 {
   if ((op & 0x0f) == 7)
     printf ("     RETURN");
   else
     printf ("     MV %s, B3", tic6x_unwind_regnames[op & 0x0f]);
 }
      else
 {
   printf (gettext ("     [unsupported opcode]"));
 }
      putchar ('\n');
    }

  return 1;
}

static bfd_vma
arm_expand_prel31 (bfd_vma word, bfd_vma where)
{
  bfd_vma offset;

  offset = word & 0x7fffffff;
  if (offset & 0x40000000)
    offset |= ~ (bfd_vma) 0x7fffffff;

  if (elf_header.e_machine == 140)
    offset <<= 1;

  return offset + where;
}

static bfd_boolean
decode_arm_unwind (struct arm_unw_aux_info * aux,
     unsigned int word,
     unsigned int remaining,
     bfd_vma data_offset,
     Elf_Internal_Shdr * data_sec,
     struct arm_section * data_arm_sec)
{
  int per_index;
  unsigned int more_words = 0;
  struct absaddr addr;
  bfd_vma sym_name = (bfd_vma) -1;
  bfd_boolean res = 0;

  if (remaining == 0)
    {





      if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset,
         & word, & addr, & sym_name))
 return 0;

      remaining = 4;
    }

  if ((word & 0x80000000) == 0)
    {

      bfd_vma fn;
      const char *procname;

      fn = arm_expand_prel31 (word, data_sec->sh_addr + data_offset);
      printf (gettext ("  Personality routine: "));
      if (fn == 0
   && addr.section == 0 && addr.offset == 0
   && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)
 {
   procname = aux->strtab + sym_name;
   print_vma (fn, PREFIX_HEX);
   if (procname)
     {
       fputs (" <", 
# 8732 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 8732 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );
       fputs (procname, 
# 8733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 8733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
       fputc ('>', 
# 8734 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  stdout
# 8734 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        );
     }
 }
      else
 procname = arm_print_vma_and_name (aux, fn, addr);
      fputc ('\n', 
# 8739 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  stdout
# 8739 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        );




      if (procname != 
# 8744 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
   
# 8745 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  && ((strncmp ((procname), ("__gcc_personality_v0"), sizeof ("__gcc_personality_v0") - 1) == 0)
       || (strncmp ((procname), ("__gxx_personality_v0"), sizeof ("__gxx_personality_v0") - 1) == 0)
       || (strncmp ((procname), ("__gcj_personality_v0"), sizeof ("__gcj_personality_v0") - 1) == 0)
       || (strncmp ((procname), ("__gnu_objc_personality_v0"), sizeof ("__gnu_objc_personality_v0") - 1) == 0)))
 {
   remaining = 0;
   more_words = 1;
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 8752 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void *)0)
# 8752 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  )) return 0; remaining = 4; more_words--; };
   if (!remaining)
     {
       printf (gettext ("  [Truncated data]\n"));
       return 0;
     }
   more_words = word >> 24;
   word <<= 8;
   remaining--;
   per_index = -1;
 }
      else
 return 1;
    }
  else
    {
# 8776 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      if (elf_header.e_machine == 40
   && (word & 0x70000000))
 {
   warn (gettext ("Corrupt ARM compact model table entry: %x \n"), word);
   res = 0;
 }

      per_index = (word >> 24) & 0x7f;
      printf (gettext ("  Compact model index: %d\n"), per_index);
      if (per_index == 0)
 {
   more_words = 0;
   word <<= 8;
   remaining--;
 }
      else if (per_index < 3)
 {
   more_words = (word >> 16) & 0xff;
   word <<= 16;
   remaining -= 2;
 }
    }

  switch (elf_header.e_machine)
    {
    case 40:
      if (per_index < 3)
 {
   if (! decode_arm_unwind_bytecode (aux, word, remaining, more_words,
         data_offset, data_sec, data_arm_sec))
     res = 0;
 }
      else
 {
   warn (gettext ("Unknown ARM compact model index encountered\n"));
   printf (gettext ("  [reserved]\n"));
   res = 0;
 }
      break;

    case 140:
      if (per_index < 3)
 {
   if (! decode_tic6x_unwind_bytecode (aux, word, remaining, more_words,
           data_offset, data_sec, data_arm_sec))
     res = 0;
 }
      else if (per_index < 5)
 {
   if (((word >> 17) & 0x7f) == 0x7f)
     printf (gettext ("  Restore stack from frame pointer\n"));
   else
     printf (gettext ("  Stack increment %d\n"), (word >> 14) & 0x1fc);
   printf (gettext ("  Registers restored: "));
   if (per_index == 4)
     printf (" (compact) ");
   decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);
   putchar ('\n');
   printf (gettext ("  Return register: %s\n"),
    tic6x_unwind_regnames[word & 0xf]);
 }
      else
 printf (gettext ("  [reserved (%d)]\n"), per_index);
      break;

    default:
      error (gettext ("Unsupported architecture type %d encountered when decoding unwind table\n"),
      elf_header.e_machine);
      res = 0;
    }



  return res;
}

static bfd_boolean
dump_arm_unwind (struct arm_unw_aux_info *aux, Elf_Internal_Shdr *exidx_sec)
{
  struct arm_section exidx_arm_sec, extab_arm_sec;
  unsigned int i, exidx_len;
  unsigned long j, nfuns;
  bfd_boolean res = 1;

  memset (&exidx_arm_sec, 0, sizeof (exidx_arm_sec));
  memset (&extab_arm_sec, 0, sizeof (extab_arm_sec));
  exidx_len = exidx_sec->sh_size / 8;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (i = 0; i < exidx_len; i++)
    {
      unsigned int exidx_fn, exidx_entry;
      struct absaddr fn_addr, entry_addr;
      bfd_vma fn;

      fputc ('\n', 
# 8877 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  stdout
# 8877 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        );

      if (! get_unwind_section_word (aux, & exidx_arm_sec, exidx_sec,
         8 * i, & exidx_fn, & fn_addr, 
# 8880 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 8880 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          )
   || ! get_unwind_section_word (aux, & exidx_arm_sec, exidx_sec,
     8 * i + 4, & exidx_entry, & entry_addr, 
# 8882 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 8882 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                ))
 {
   free (aux->funtab);
   arm_free_section (& exidx_arm_sec);
   arm_free_section (& extab_arm_sec);
   return 0;
 }




      if (exidx_fn & 0x80000000)
 {
   warn (gettext ("corrupt index table entry: %x\n"), exidx_fn);
   res = 0;
 }

      fn = arm_expand_prel31 (exidx_fn, exidx_sec->sh_addr + 8 * i);

      arm_print_vma_and_name (aux, fn, fn_addr);
      fputs (": ", 
# 8902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  stdout
# 8902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        );

      if (exidx_entry == 1)
 {
   print_vma (exidx_entry, PREFIX_HEX);
   fputs (" [cantunwind]\n", 
# 8907 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            stdout
# 8907 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  );
 }
      else if (exidx_entry & 0x80000000)
 {
   print_vma (exidx_entry, PREFIX_HEX);
   fputc ('\n', 
# 8912 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 8912 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     );
   decode_arm_unwind (aux, exidx_entry, 4, 0, 
# 8913 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                             ((void *)0)
# 8913 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                 , 
# 8913 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                   ((void *)0)
# 8913 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                       );
 }
      else
 {
   bfd_vma table, table_offset = 0;
   Elf_Internal_Shdr *table_sec;

   fputs ("@", 
# 8920 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              stdout
# 8920 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    );
   table = arm_expand_prel31 (exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
   print_vma (table, PREFIX_HEX);
   printf ("\n");


   if (entry_addr.section != 0
       && entry_addr.section < elf_header.e_shnum)
     {
       table_sec = section_headers + entry_addr.section;
       table_offset = entry_addr.offset;

       if (table_offset > table_sec->sh_size
    || ((bfd_signed_vma) table_offset) < 0)
  {
    warn (gettext ("Unwind entry contains corrupt offset (0x%lx) into section %s\n"),
   (unsigned long) table_offset,
   printable_section_name (table_sec));
    res = 0;
    continue;
  }
     }
   else
     {
       table_sec = find_section_by_address (table);
       if (table_sec != 
# 8945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 8945 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
  table_offset = table - table_sec->sh_addr;
     }

   if (table_sec == 
# 8949 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 8949 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
     {
       warn (gettext ("Could not locate .ARM.extab section containing 0x%lx.\n"),
      (unsigned long) table);
       res = 0;
       continue;
     }

   if (! decode_arm_unwind (aux, 0, 0, table_offset, table_sec,
       &extab_arm_sec))
     res = 0;
 }
    }

  printf ("\n");

  free (aux->funtab);
  arm_free_section (&exidx_arm_sec);
  arm_free_section (&extab_arm_sec);

  return res;
}



static bfd_boolean
arm_process_unwind (FILE *file)
{
  struct arm_unw_aux_info aux;
  Elf_Internal_Shdr *unwsec = 
# 8978 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0)
# 8978 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 ;
  Elf_Internal_Shdr *strsec;
  Elf_Internal_Shdr *sec;
  unsigned long i;
  unsigned int sec_type;
  bfd_boolean res = 1;

  switch (elf_header.e_machine)
    {
    case 40:
      sec_type = 0x70000001;
      break;

    case 140:
      sec_type = 0x70000001;
      break;

    default:
      error (gettext ("Unsupported architecture type %d encountered when processing unwind table\n"),
      elf_header.e_machine);
      return 0;
    }

  if (string_table == 
# 9001 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 9001 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
    return 0;

  memset (& aux, 0, sizeof (aux));
  aux.file = file;

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2 && sec->sh_link < elf_header.e_shnum)
 {
   aux.symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, sec, & aux.nsyms) : get_64bit_elf_symbols (file, sec, & aux.nsyms));

   strsec = section_headers + sec->sh_link;


   if (aux.strtab != 
# 9016 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 9016 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
     {
       error (gettext ("Multiple string tables found in file.\n"));
       free (aux.strtab);
       res = 0;
     }
   aux.strtab = get_data (
# 9022 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 9022 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             , file, strsec->sh_offset,
     1, strsec->sh_size, gettext ("string table"));
   aux.strtab_size = aux.strtab != 
# 9024 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0) 
# 9024 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       ? strsec->sh_size : 0;
 }
      else if (sec->sh_type == sec_type)
 unwsec = sec;
    }

  if (unwsec == 
# 9030 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 9030 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    printf (gettext ("\nThere are no unwind sections in this file.\n"));
  else
    for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
      {
 if (sec->sh_type == sec_type)
   {
     printf (gettext ("\nUnwind table index '%s' at offset 0x%lx contains %lu entries:\n"),
      printable_section_name (sec),
      (unsigned long) sec->sh_offset,
      (unsigned long) (sec->sh_size / (2 * eh_addr_size)));

     if (! dump_arm_unwind (&aux, sec))
       res = 0;
   }
      }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);

  return res;
}

static bfd_boolean
process_unwind (FILE * file)
{
  struct unwind_handler
  {
    unsigned int machtype;
    bfd_boolean (* handler)(FILE *);
  } handlers[] =
  {
    { 40, arm_process_unwind },
    { 50, ia64_process_unwind },
    { 15, hppa_process_unwind },
    { 140, arm_process_unwind },
    { 0, 
# 9068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0) 
# 9068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             }
  };
  int i;

  if (!do_unwind)
    return 1;

  for (i = 0; handlers[i].handler != 
# 9075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    ((void *)0)
# 9075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        ; i++)
    if (elf_header.e_machine == handlers[i].machtype)
      return handlers[i].handler (file);

  printf (gettext ("\nThe decoding of unwind sections for machine type %s is not currently supported.\n"),
   get_machine_name (elf_header.e_machine));
  return 1;
}

static void
dynamic_section_mips_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case 0x70000005:
      if (entry->d_un.d_val == 0)
 printf (gettext ("NONE"));
      else
 {
   static const char * opts[] =
   {
     "QUICKSTART", "NOTPOT", "NO_LIBRARY_REPLACEMENT",
     "NO_MOVE", "SGI_ONLY", "GUARANTEE_INIT", "DELTA_C_PLUS_PLUS",
     "GUARANTEE_START_INIT", "PIXIE", "DEFAULT_DELAY_LOAD",
     "REQUICKSTART", "REQUICKSTARTED", "CORD", "NO_UNRES_UNDEF",
     "RLD_ORDER_SAFE"
   };
   unsigned int cnt;
   bfd_boolean first = 1;

   for (cnt = 0; cnt < (sizeof (opts) / sizeof ((opts)[0])); ++cnt)
     if (entry->d_un.d_val & (1 << cnt))
       {
  printf ("%s%s", first ? "" : " ", opts[cnt]);
  first = 0;
       }
 }
      break;

    case 0x70000004:
      if (((dynamic_strings != 
# 9115 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 9115 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ) && (entry->d_un.d_val < dynamic_strings_length)))
 printf (gettext ("Interface Version: %s"), (dynamic_strings + entry->d_un.d_val));
      else
 {
   char buf[40];
   sprintf (buf, "%016" "l" "x", entry->d_un.d_ptr);

   printf (gettext ("<corrupt: %s>"), buf);
 }
      break;

    case 0x70000002:
      {
 char timebuf[128];
 struct tm * tmp;
 time_t atime = entry->d_un.d_val;

 tmp = gmtime (&atime);

 if (tmp == 
# 9134 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0)
# 9134 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               )
   snprintf (timebuf, sizeof (timebuf), gettext ("<corrupt>"));
 else
   snprintf (timebuf, sizeof (timebuf), "%04u-%02u-%02uT%02u:%02u:%02u",
      tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
 printf (gettext ("Time Stamp: %s"), timebuf);
      }
      break;

    case 0x70000001:
    case 0x7000000a:
    case 0x7000000b:
    case 0x70000010:
    case 0x70000011:
    case 0x70000012:
    case 0x70000014:
    case 0x70000018:
    case 0x7000001a:
    case 0x7000001c:
    case 0x7000001e:
    case 0x70000021:
    case 0x7000002f:
      print_vma (entry->d_un.d_val, DEC);
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    }
    putchar ('\n');
}

static void
dynamic_section_parisc_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case (0x60000000 + 0x1):
      {
 static struct
 {
   long int bit;
   const char * str;
 }
 flags[] =
 {
   { 0x00001, "HP_DEBUG_PRIVATE" },
   { 0x00002, "HP_DEBUG_CALLBACK" },
   { 0x00004, "HP_DEBUG_CALLBACK_BOR" },
   { 0x00008, "HP_NO_ENVVAR" },
   { 0x00010, "HP_BIND_NOW" },
   { 0x00020, "HP_BIND_NONFATAL" },
   { 0x00040, "HP_BIND_VERBOSE" },
   { 0x00080, "HP_BIND_RESTRICTED" },
   { 0x00100, "HP_BIND_SYMBOLIC" },
   { 0x00200, "HP_RPATH_FIRST" },
   { 0x00400, "HP_BIND_DEPTH_FIRST" },
   { 0x00800, "HP_GST" },
   { 0x01000, "HP_SHLIB_FIXED" },
   { 0x02000, "HP_MERGE_SHLIB_SEG" },
   { 0x04000, "HP_NODELETE" },
   { 0x08000, "HP_GROUP" },
   { 0x10000, "HP_PROTECT_LINKAGE_TABLE" }
 };
 bfd_boolean first = 1;
 size_t cnt;
 bfd_vma val = entry->d_un.d_val;

 for (cnt = 0; cnt < (sizeof (flags) / sizeof ((flags)[0])); ++cnt)
   if (val & flags[cnt].bit)
     {
       if (! first)
  putchar (' ');
       fputs (flags[cnt].str, 
# 9207 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 9207 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
       first = 0;
       val ^= flags[cnt].bit;
     }

 if (val != 0 || first)
   {
     if (! first)
       putchar (' ');
     print_vma (val, HEX);
   }
      }
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}
# 9237 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static void
print_vms_time (bfd_int64_t vmstime)
{
  struct tm *tm;
  time_t unxtime;

  unxtime = (vmstime - 35067168000000000LL) / 10000000;
  tm = gmtime (&unxtime);
  printf ("%04u-%02u-%02uT%02u:%02u:%02u",
          tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
          tm->tm_hour, tm->tm_min, tm->tm_sec);
}


static void
dynamic_section_ia64_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case (0x70000000 + 0):

      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      printf (" -- ");
      print_vma (entry->d_un.d_ptr + (3 * 8), PREFIX_HEX);
      break;

    case (0x6000000d + 40):

      print_vms_time (entry->d_un.d_val);

      break;

    case (0x6000000d + 8):
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      if (entry->d_un.d_val & 0x0001)
        printf (" CALL_DEBUG");
      if (entry->d_un.d_val & 0x0002)
        printf (" NOP0BUFS");
      if (entry->d_un.d_val & 0x0004)
        printf (" P0IMAGE");
      if (entry->d_un.d_val & 0x0008)
        printf (" MKTHREADS");
      if (entry->d_un.d_val & 0x0010)
        printf (" UPCALLS");
      if (entry->d_un.d_val & 0x0020)
        printf (" IMGSTA");
      if (entry->d_un.d_val & 0x0040)
        printf (" INITIALIZE");
      if (entry->d_un.d_val & 0x0080)
        printf (" MAIN");
      if (entry->d_un.d_val & 0x0200)
        printf (" EXE_INIT");
      if (entry->d_un.d_val & 0x0400)
        printf (" TBK_IN_IMG");
      if (entry->d_un.d_val & 0x0800)
        printf (" DBG_IN_IMG");
      if (entry->d_un.d_val & 0x1000)
        printf (" TBK_IN_DSF");
      if (entry->d_un.d_val & 0x2000)
        printf (" DBG_IN_DSF");
      if (entry->d_un.d_val & 0x4000)
        printf (" SIGNATURES");
      if (entry->d_un.d_val & 0x8000)
        printf (" REL_SEG_OFF");
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}

static bfd_boolean
get_32bit_dynamic_section (FILE * file)
{
  Elf32_External_Dyn * edyn;
  Elf32_External_Dyn * ext;
  Elf_Internal_Dyn * entry;

  edyn = (Elf32_External_Dyn *) get_data (
# 9317 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 9317 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             , file, dynamic_addr, 1,
                                          dynamic_size, gettext ("dynamic section"));
  if (!edyn)
    return 0;




  for (ext = edyn, dynamic_nent = 0;
       (char *) (ext + 1) <= (char *) edyn + dynamic_size;
       ext++)
    {
      dynamic_nent++;
      if (byte_get (ext->d_tag, sizeof (ext->d_tag)) == 0)
 break;
    }

  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
  if (dynamic_section == 
# 9336 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 9336 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      error (gettext ("Out of memory allocating space for %lu dynamic entries\n"),
      (unsigned long) dynamic_nent);
      free (edyn);
      return 0;
    }

  for (ext = edyn, entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag = byte_get (ext->d_tag, sizeof (ext->d_tag));
      entry->d_un.d_val = byte_get (ext->d_un.d_val, sizeof (ext->d_un.d_val));
    }

  free (edyn);

  return 1;
}

static bfd_boolean
get_64bit_dynamic_section (FILE * file)
{
  Elf64_External_Dyn * edyn;
  Elf64_External_Dyn * ext;
  Elf_Internal_Dyn * entry;


  edyn = (Elf64_External_Dyn *) get_data (
# 9365 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 9365 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             , file, dynamic_addr, 1,
                                          dynamic_size, gettext ("dynamic section"));
  if (!edyn)
    return 0;




  for (ext = edyn, dynamic_nent = 0;

       (char *) (ext + 1) <= (char *) edyn + dynamic_size;
       ext++)
    {
      dynamic_nent++;
      if (byte_get (ext->d_tag, sizeof (ext->d_tag)) == 0)
 break;
    }

  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
  if (dynamic_section == 
# 9385 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 9385 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      error (gettext ("Out of memory allocating space for %lu dynamic entries\n"),
      (unsigned long) dynamic_nent);
      free (edyn);
      return 0;
    }


  for (ext = edyn, entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag = byte_get (ext->d_tag, sizeof (ext->d_tag));
      entry->d_un.d_val = byte_get (ext->d_un.d_val, sizeof (ext->d_un.d_val));
    }

  free (edyn);

  return 1;
}

static void
print_dynamic_flags (bfd_vma flags)
{
  bfd_boolean first = 1;

  while (flags)
    {
      bfd_vma flag;

      flag = flags & - flags;
      flags &= ~ flag;

      if (first)
 first = 0;
      else
 putc (' ', 
# 9422 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           stdout
# 9422 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 );

      switch (flag)
 {
 case (1 << 0): fputs ("ORIGIN", 
# 9426 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  stdout
# 9426 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        ); break;
 case (1 << 1): fputs ("SYMBOLIC", 
# 9427 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     stdout
# 9427 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           ); break;
 case (1 << 2): fputs ("TEXTREL", 
# 9428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                   stdout
# 9428 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         ); break;
 case (1 << 3): fputs ("BIND_NOW", 
# 9429 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     stdout
# 9429 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           ); break;
 case (1 << 4): fputs ("STATIC_TLS", 
# 9430 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         stdout
# 9430 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               ); break;
 default: fputs (gettext ("unknown"), 
# 9431 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               stdout
# 9431 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     ); break;
 }
    }
  puts ("");
}



static bfd_boolean
process_dynamic_section (FILE * file)
{
  Elf_Internal_Dyn * entry;

  if (dynamic_size == 0)
    {
      if (do_dynamic)
 printf (gettext ("\nThere is no dynamic section in this file.\n"));

      return 1;
    }

  if (is_32bit_elf)
    {
      if (! get_32bit_dynamic_section (file))
 return 0;
    }
  else
    {
      if (! get_64bit_dynamic_section (file))
 return 0;
    }


  if (dynamic_symbols == 
# 9464 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 9464 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      for (entry = dynamic_section;
    entry < dynamic_section + dynamic_nent;
    ++entry)
 {
   Elf_Internal_Shdr section;

   if (entry->d_tag != 6)
     continue;

   dynamic_info[6] = entry->d_un.d_val;





   section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);
   if ((bfd_size_type) section.sh_offset > current_file_size)
     {

       error (gettext ("Invalid DT_SYMTAB entry: %lx"), (long) section.sh_offset);
       return 0;
     }

   if (archive_file_offset != 0)
     section.sh_size = archive_file_size - section.sh_offset;
   else
     {
       if (fseek (file, 0, 
# 9493 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          2
# 9493 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ))
  error (gettext ("Unable to seek to end of file!\n"));

       section.sh_size = ftell (file) - section.sh_offset;
     }

   if (is_32bit_elf)
     section.sh_entsize = sizeof (Elf32_External_Sym);
   else
     section.sh_entsize = sizeof (Elf64_External_Sym);
   section.sh_name = string_table_length;

   dynamic_symbols = (is_32bit_elf ? get_32bit_elf_symbols (file, &section, & num_dynamic_syms) : get_64bit_elf_symbols (file, &section, & num_dynamic_syms));
   if (num_dynamic_syms < 1)
     {
       error (gettext ("Unable to determine the number of symbols to load\n"));
       continue;
     }
 }
    }


  if (dynamic_strings == 
# 9515 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 9515 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      for (entry = dynamic_section;
    entry < dynamic_section + dynamic_nent;
    ++entry)
 {
   unsigned long offset;
   long str_tab_len;

   if (entry->d_tag != 5)
     continue;

   dynamic_info[5] = entry->d_un.d_val;






   offset = offset_from_vma (file, entry->d_un.d_val, 0);

   if (archive_file_offset != 0)
     str_tab_len = archive_file_size - offset;
   else
     {
       if (fseek (file, 0, 
# 9540 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          2
# 9540 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ))
  error (gettext ("Unable to seek to end of file\n"));
       str_tab_len = ftell (file) - offset;
     }

   if (str_tab_len < 1)
     {
       error
  (gettext ("Unable to determine the length of the dynamic string table\n"));
       continue;
     }

   dynamic_strings = (char *) get_data (
# 9552 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       ((void *)0)
# 9552 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           , file, offset, 1,
                                               str_tab_len,
                                               gettext ("dynamic string table"));
   dynamic_strings_length = dynamic_strings == 
# 9555 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0) 
# 9555 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   ? 0 : str_tab_len;
   break;
 }
    }


  if (dynamic_syminfo == 
# 9561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 9561 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {
      unsigned long syminsz = 0;

      for (entry = dynamic_section;
    entry < dynamic_section + dynamic_nent;
    ++entry)
 {
   if (entry->d_tag == 0x6ffffdff)
     {




       if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)
  error (gettext ("Bad value (%d) for SYMINENT entry\n"),
         (int) entry->d_un.d_val);
     }
   else if (entry->d_tag == 0x6ffffdfe)
     syminsz = entry->d_un.d_val;
   else if (entry->d_tag == 0x6ffffeff)
     dynamic_syminfo_offset = offset_from_vma (file, entry->d_un.d_val,
            syminsz);
 }

      if (dynamic_syminfo_offset != 0 && syminsz != 0)
 {
   Elf_External_Syminfo * extsyminfo;
   Elf_External_Syminfo * extsym;
   Elf_Internal_Syminfo * syminfo;


   extsyminfo = (Elf_External_Syminfo *)
              get_data (
# 9594 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 9594 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           , file, dynamic_syminfo_offset, 1, syminsz,
                        gettext ("symbol information"));
   if (!extsyminfo)
     return 0;

   dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
   if (dynamic_syminfo == 
# 9600 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 9600 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
     {
       error (gettext ("Out of memory allocating %lu byte for dynamic symbol info\n"),
       (unsigned long) syminsz);
       return 0;
     }

   dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);
   for (syminfo = dynamic_syminfo, extsym = extsyminfo;
        syminfo < dynamic_syminfo + dynamic_syminfo_nent;
        ++syminfo, ++extsym)
     {
       syminfo->si_boundto = byte_get (extsym->si_boundto, sizeof (extsym->si_boundto));
       syminfo->si_flags = byte_get (extsym->si_flags, sizeof (extsym->si_flags));
     }

   free (extsyminfo);
 }
    }

  if (do_dynamic && dynamic_addr)
    printf (gettext ("\nDynamic section at offset 0x%lx contains %lu entries:\n"),
     dynamic_addr, (unsigned long) dynamic_nent);
  if (do_dynamic)
    printf (gettext ("  Tag        Type                         Name/Value\n"));

  for (entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       entry++)
    {
      if (do_dynamic)
 {
   const char * dtype;

   putchar (' ');
   print_vma (entry->d_tag, FULL_HEX);
   dtype = get_dynamic_type (entry->d_tag);
   printf (" (%s)%*s", dtype,
    ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), " ");
 }

      switch (entry->d_tag)
 {
 case 30:
   if (do_dynamic)
     print_dynamic_flags (entry->d_un.d_val);
   break;

 case 0x7ffffffd:
 case 0x7fffffff:
 case 0x6ffffefa:
 case 0x6ffffefb:
 case 0x6ffffefc:
   if (do_dynamic)
     {
       switch (entry->d_tag)
  {
  case 0x7ffffffd:
    printf (gettext ("Auxiliary library"));
    break;

  case 0x7fffffff:
    printf (gettext ("Filter library"));
    break;

  case 0x6ffffefa:
    printf (gettext ("Configuration file"));
    break;

  case 0x6ffffefb:
    printf (gettext ("Dependency audit library"));
    break;

  case 0x6ffffefc:
    printf (gettext ("Audit library"));
    break;
  }

       if (((dynamic_strings != 
# 9678 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 9678 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ) && (entry->d_un.d_val < dynamic_strings_length)))
  printf (": [%s]\n", (dynamic_strings + entry->d_un.d_val));
       else
  {
    printf (": ");
    print_vma (entry->d_un.d_val, PREFIX_HEX);
    putchar ('\n');
  }
     }
   break;

 case 0x6ffffdfc:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));

       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    unsigned long int val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" PARINIT");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" CONFEXP");
        val ^= 0x00000002;
      }
    if (val != 0)
      printf (" %lx", val);
    puts ("");
  }
     }
   break;

 case 0x6ffffdfd:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));

       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    unsigned long int val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" LAZYLOAD");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" GROUPPERM");
        val ^= 0x00000002;
      }
    if (val != 0)
      printf (" %lx", val);
    puts ("");
  }
     }
   break;

 case 0x6ffffffb:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));
       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    unsigned long int val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" NOW");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" GLOBAL");
        val ^= 0x00000002;
      }
    if (val & 0x00000004)
      {
        printf (" GROUP");
        val ^= 0x00000004;
      }
    if (val & 0x00000008)
      {
        printf (" NODELETE");
        val ^= 0x00000008;
      }
    if (val & 0x00000010)
      {
        printf (" LOADFLTR");
        val ^= 0x00000010;
      }
    if (val & 0x00000020)
      {
        printf (" INITFIRST");
        val ^= 0x00000020;
      }
    if (val & 0x00000040)
      {
        printf (" NOOPEN");
        val ^= 0x00000040;
      }
    if (val & 0x00000080)
      {
        printf (" ORIGIN");
        val ^= 0x00000080;
      }
    if (val & 0x00000100)
      {
        printf (" DIRECT");
        val ^= 0x00000100;
      }
    if (val & 0x00000200)
      {
        printf (" TRANS");
        val ^= 0x00000200;
      }
    if (val & 0x00000400)
      {
        printf (" INTERPOSE");
        val ^= 0x00000400;
      }
    if (val & 0x00000800)
      {
        printf (" NODEFLIB");
        val ^= 0x00000800;
      }
    if (val & 0x00001000)
      {
        printf (" NODUMP");
        val ^= 0x00001000;
      }
    if (val & 0x00002000)
      {
        printf (" CONFALT");
        val ^= 0x00002000;
      }
    if (val & 0x00004000)
      {
        printf (" ENDFILTEE");
        val ^= 0x00004000;
      }
    if (val & 0x00008000)
      {
        printf (" DISPRELDNE");
        val ^= 0x00008000;
      }
    if (val & 0x00010000)
      {
        printf (" DISPRELPND");
        val ^= 0x00010000;
      }
    if (val & 0x00020000)
      {
        printf (" NODIRECT");
        val ^= 0x00020000;
      }
    if (val & 0x00040000)
      {
        printf (" IGNMULDEF");
        val ^= 0x00040000;
      }
    if (val & 0x00080000)
      {
        printf (" NOKSYMS");
        val ^= 0x00080000;
      }
    if (val & 0x00100000)
      {
        printf (" NOHDR");
        val ^= 0x00100000;
      }
    if (val & 0x00200000)
      {
        printf (" EDITED");
        val ^= 0x00200000;
      }
    if (val & 0x00400000)
      {
        printf (" NORELOC");
        val ^= 0x00400000;
      }
    if (val & 0x00800000)
      {
        printf (" SYMINTPOSE");
        val ^= 0x00800000;
      }
    if (val & 0x01000000)
      {
        printf (" GLOBAUDIT");
        val ^= 0x01000000;
      }
    if (val & 0x02000000)
      {
        printf (" SINGLETON");
        val ^= 0x02000000;
      }
    if (val & 0x04000000)
      {
        printf (" STUB");
        val ^= 0x04000000;
      }
    if (val & 0x08000000)
      {
        printf (" PIE");
        val ^= 0x08000000;
      }
    if (val != 0)
      printf (" %lx", val);
    puts ("");
  }
     }
   break;

 case 20:
   dynamic_info[entry->d_tag] = entry->d_un.d_val;
   if (do_dynamic)
     puts (get_dynamic_type (entry->d_un.d_val));
   break;

 case 0 :
 case 1 :
 case 3 :
 case 4 :
 case 5 :
 case 6 :
 case 7 :
 case 12 :
 case 13 :
 case 14 :
 case 15 :
 case 16:
 case 17 :
 case 21 :
 case 22 :
 case 23 :
 case 29 :
   dynamic_info[entry->d_tag] = entry->d_un.d_val;

   if (do_dynamic)
     {
       char * name;

       if (((dynamic_strings != 
# 9931 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 9931 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ) && (entry->d_un.d_val < dynamic_strings_length)))
  name = (dynamic_strings + entry->d_un.d_val);
       else
  name = 
# 9934 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 9934 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;

       if (name)
  {
    switch (entry->d_tag)
      {
      case 1:
        printf (gettext ("Shared library: [%s]"), name);

        if ((strcmp ((name), (program_interpreter)) == 0))
   printf (gettext (" program interpreter"));
        break;

      case 14:
        printf (gettext ("Library soname: [%s]"), name);
        break;

      case 15:
        printf (gettext ("Library rpath: [%s]"), name);
        break;

      case 29:
        printf (gettext ("Library runpath: [%s]"), name);
        break;

      default:
        print_vma (entry->d_un.d_val, PREFIX_HEX);
        break;
      }
  }
       else
  print_vma (entry->d_un.d_val, PREFIX_HEX);

       putchar ('\n');
     }
   break;

 case 2:
 case 8 :
 case 10 :
 case 18 :
 case 9 :
 case 11 :
 case 19 :
   dynamic_info[entry->d_tag] = entry->d_un.d_val;

 case 0x6ffffdf9:
 case 0x6ffffdfa :
 case 0x6ffffdfb :
 case 27:
 case 28:
 case 0x6ffffdf6:
 case 0x6ffffdf7:
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, UNSIGNED);
       printf (gettext (" (bytes)\n"));
     }
   break;

 case 0x6ffffffd:
 case 0x6fffffff:
 case 0x6ffffff9:
 case 0x6ffffffa:
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, UNSIGNED);
       putchar ('\n');
     }
   break;

 case 0x6ffffdfe:
 case 0x6ffffdff:
 case 0x6ffffeff:
 case 0x7ffffffe:
 case 25:
 case 26:
   if (do_dynamic)
     {
       if (entry->d_tag == 0x7ffffffe
    && ((dynamic_strings != 
# 10014 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
      ((void *)0)
# 10014 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      ) && (entry->d_un.d_val < dynamic_strings_length)))
  {
    char * name = (dynamic_strings + entry->d_un.d_val);

    if (*name)
      {
        printf (gettext ("Not needed object: [%s]\n"), name);
        break;
      }
  }

       print_vma (entry->d_un.d_val, PREFIX_HEX);
       putchar ('\n');
     }
   break;

 case 24:

   if (do_dynamic)
     putchar ('\n');
   break;

 case 0x6ffffdf5:
   if (do_dynamic)
     {
       struct tm * tmp;
       time_t atime = entry->d_un.d_val;

       tmp = gmtime (&atime);

       if (tmp == 
# 10044 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 10044 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
  printf (gettext ("<corrupt time val: %lx"),
   (unsigned long) atime);
       else
  printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

     }
   break;

 case 0x6ffffef5:
   dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, PREFIX_HEX);
       putchar ('\n');
     }
   break;

 default:
   if ((entry->d_tag >= 0x6ffffff0) && (entry->d_tag <= 0x6fffffff))
     version_info[(0x6fffffff - (entry->d_tag))] =
       entry->d_un.d_val;

   if (do_dynamic)
     {
       switch (elf_header.e_machine)
  {
  case 8:
  case 10:
    dynamic_section_mips_val (entry);
    break;
  case 15:
    dynamic_section_parisc_val (entry);
    break;
  case 50:
    dynamic_section_ia64_val (entry);
    break;
  default:
    print_vma (entry->d_un.d_val, PREFIX_HEX);
    putchar ('\n');
  }
     }
   break;
 }
    }

  return 1;
}

static char *
get_ver_flags (unsigned int flags)
{
  static char buff[32];

  buff[0] = 0;

  if (flags == 0)
    return gettext ("none");

  if (flags & 0x1)
    strcat (buff, "BASE");

  if (flags & 0x2)
    {
      if (flags & 0x1)
 strcat (buff, " | ");

      strcat (buff, "WEAK");
    }

  if (flags & 0x4)
    {
      if (flags & (0x1|0x2))
 strcat (buff, " | ");

      strcat (buff, "INFO");
    }

  if (flags & ~(0x1 | 0x2 | 0x4))
    {
      if (flags & (0x1 | 0x2 | 0x4))
 strcat (buff, " | ");

      strcat (buff, gettext ("<unknown>"));
    }

  return buff;
}



static bfd_boolean
process_version_sections (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned i;
  bfd_boolean found = 0;

  if (! do_version)
    return 1;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
 {
 case 0x6ffffffd:
   {
     Elf_External_Verdef * edefs;
     unsigned long idx;
     unsigned long cnt;
     char * endbuf;

     found = 1;

     printf (gettext ("\nVersion definition section '%s' contains %u entries:\n"),
      printable_section_name (section),
      section->sh_info);

     printf (gettext ("  Addr: 0x"));
     fprintf (
# 10167 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    stdout
# 10167 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    , "%016" "l" "x", section->sh_addr);
     printf (gettext ("  Offset: %#08lx  Link: %u (%s)\n"),
      (unsigned long) section->sh_offset, section->sh_link,
      printable_section_name_from_index (section->sh_link));

     edefs = (Elf_External_Verdef *)
                get_data (
# 10173 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 10173 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             , file, section->sh_offset, 1,section->sh_size,
                          gettext ("version definition section"));
     if (!edefs)
       break;
     endbuf = (char *) edefs + section->sh_size;

     for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
       {
  char * vstart;
  Elf_External_Verdef * edef;
  Elf_Internal_Verdef ent;
  Elf_External_Verdaux * eaux;
  Elf_Internal_Verdaux aux;
  unsigned long isum;
  int j;

  vstart = ((char *) edefs) + idx;
  if (vstart + sizeof (*edef) > endbuf)
    break;

  edef = (Elf_External_Verdef *) vstart;

  ent.vd_version = byte_get (edef->vd_version, sizeof (edef->vd_version));
  ent.vd_flags = byte_get (edef->vd_flags, sizeof (edef->vd_flags));
  ent.vd_ndx = byte_get (edef->vd_ndx, sizeof (edef->vd_ndx));
  ent.vd_cnt = byte_get (edef->vd_cnt, sizeof (edef->vd_cnt));
  ent.vd_hash = byte_get (edef->vd_hash, sizeof (edef->vd_hash));
  ent.vd_aux = byte_get (edef->vd_aux, sizeof (edef->vd_aux));
  ent.vd_next = byte_get (edef->vd_next, sizeof (edef->vd_next));

  printf (gettext ("  %#06lx: Rev: %d  Flags: %s"),
   idx, ent.vd_version, get_ver_flags (ent.vd_flags));

  printf (gettext ("  Index: %d  Cnt: %d  "),
   ent.vd_ndx, ent.vd_cnt);


  if (ent.vd_aux > (size_t) (endbuf - vstart))
    break;

  vstart += ent.vd_aux;

  if (vstart + sizeof (*eaux) > endbuf)
    break;
  eaux = (Elf_External_Verdaux *) vstart;

  aux.vda_name = byte_get (eaux->vda_name, sizeof (eaux->vda_name));
  aux.vda_next = byte_get (eaux->vda_next, sizeof (eaux->vda_next));

  if (((dynamic_strings != 
# 10222 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 10222 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     ) && (aux.vda_name < dynamic_strings_length)))
    printf (gettext ("Name: %s\n"), (dynamic_strings + aux.vda_name));
  else
    printf (gettext ("Name index: %ld\n"), aux.vda_name);

  isum = idx + ent.vd_aux;

  for (j = 1; j < ent.vd_cnt; j++)
    {
      if (aux.vda_next < sizeof (*eaux)
   && !(j == ent.vd_cnt - 1 && aux.vda_next == 0))
        {
   warn (gettext ("Invalid vda_next field of %lx\n"),
         aux.vda_next);
   j = ent.vd_cnt;
   break;
        }

      if (aux.vda_next > (size_t) (endbuf - vstart))
        break;

      isum += aux.vda_next;
      vstart += aux.vda_next;

      if (vstart + sizeof (*eaux) > endbuf)
        break;
      eaux = (Elf_External_Verdaux *) vstart;

      aux.vda_name = byte_get (eaux->vda_name, sizeof (eaux->vda_name));
      aux.vda_next = byte_get (eaux->vda_next, sizeof (eaux->vda_next));

      if (((dynamic_strings != 
# 10253 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 10253 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ) && (aux.vda_name < dynamic_strings_length)))
        printf (gettext ("  %#06lx: Parent %d: %s\n"),
         isum, j, (dynamic_strings + aux.vda_name));
      else
        printf (gettext ("  %#06lx: Parent %d, name index: %ld\n"),
         isum, j, aux.vda_name);
    }

  if (j < ent.vd_cnt)
    printf (gettext ("  Version def aux past end of section\n"));



  if (ent.vd_next < sizeof (*edef)
      && !(cnt == section->sh_info - 1 && ent.vd_next == 0))
    {
      warn (gettext ("Invalid vd_next field of %lx\n"), ent.vd_next);
      cnt = section->sh_info;
      break;
    }
  if (ent.vd_next > (size_t) (endbuf - ((char *) edefs + idx)))
    break;

  idx += ent.vd_next;
       }

     if (cnt < section->sh_info)
       printf (gettext ("  Version definition past end of section\n"));

     free (edefs);
   }
   break;

 case 0x6ffffffe:
   {
     Elf_External_Verneed * eneed;
     unsigned long idx;
     unsigned long cnt;
     char * endbuf;

     found = 1;

     printf (gettext ("\nVersion needs section '%s' contains %u entries:\n"),
      printable_section_name (section), section->sh_info);

     printf (gettext (" Addr: 0x"));
     fprintf (
# 10299 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    stdout
# 10299 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    , "%016" "l" "x", section->sh_addr);
     printf (gettext ("  Offset: %#08lx  Link: %u (%s)\n"),
      (unsigned long) section->sh_offset, section->sh_link,
      printable_section_name_from_index (section->sh_link));

     eneed = (Elf_External_Verneed *) get_data (
# 10304 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               ((void *)0)
# 10304 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   , file,
                                                       section->sh_offset, 1,
                                                       section->sh_size,
                                                       gettext ("Version Needs section"));
     if (!eneed)
       break;
     endbuf = (char *) eneed + section->sh_size;

     for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
       {
  Elf_External_Verneed * entry;
  Elf_Internal_Verneed ent;
  unsigned long isum;
  int j;
  char * vstart;

  vstart = ((char *) eneed) + idx;
  if (vstart + sizeof (*entry) > endbuf)
    break;

  entry = (Elf_External_Verneed *) vstart;

  ent.vn_version = byte_get (entry->vn_version, sizeof (entry->vn_version));
  ent.vn_cnt = byte_get (entry->vn_cnt, sizeof (entry->vn_cnt));
  ent.vn_file = byte_get (entry->vn_file, sizeof (entry->vn_file));
  ent.vn_aux = byte_get (entry->vn_aux, sizeof (entry->vn_aux));
  ent.vn_next = byte_get (entry->vn_next, sizeof (entry->vn_next));

  printf (gettext ("  %#06lx: Version: %d"), idx, ent.vn_version);

  if (((dynamic_strings != 
# 10334 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 10334 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     ) && (ent.vn_file < dynamic_strings_length)))
    printf (gettext ("  File: %s"), (dynamic_strings + ent.vn_file));
  else
    printf (gettext ("  File: %lx"), ent.vn_file);

  printf (gettext ("  Cnt: %d\n"), ent.vn_cnt);


  if (ent.vn_aux > (size_t) (endbuf - vstart))
    break;
  vstart += ent.vn_aux;

  for (j = 0, isum = idx + ent.vn_aux; j < ent.vn_cnt; ++j)
    {
      Elf_External_Vernaux * eaux;
      Elf_Internal_Vernaux aux;

      if (vstart + sizeof (*eaux) > endbuf)
        break;
      eaux = (Elf_External_Vernaux *) vstart;

      aux.vna_hash = byte_get (eaux->vna_hash, sizeof (eaux->vna_hash));
      aux.vna_flags = byte_get (eaux->vna_flags, sizeof (eaux->vna_flags));
      aux.vna_other = byte_get (eaux->vna_other, sizeof (eaux->vna_other));
      aux.vna_name = byte_get (eaux->vna_name, sizeof (eaux->vna_name));
      aux.vna_next = byte_get (eaux->vna_next, sizeof (eaux->vna_next));

      if (((dynamic_strings != 
# 10361 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 10361 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ) && (aux.vna_name < dynamic_strings_length)))
        printf (gettext ("  %#06lx:   Name: %s"),
         isum, (dynamic_strings + aux.vna_name));
      else
        printf (gettext ("  %#06lx:   Name index: %lx"),
         isum, aux.vna_name);

      printf (gettext ("  Flags: %s  Version: %d\n"),
       get_ver_flags (aux.vna_flags), aux.vna_other);

      if (aux.vna_next < sizeof (*eaux)
   && !(j == ent.vn_cnt - 1 && aux.vna_next == 0))
        {
   warn (gettext ("Invalid vna_next field of %lx\n"),
         aux.vna_next);
   j = ent.vn_cnt;
   break;
        }

      if (aux.vna_next > (size_t) (endbuf - vstart))
        break;
      isum += aux.vna_next;
      vstart += aux.vna_next;
    }

  if (j < ent.vn_cnt)
    warn (gettext ("Missing Version Needs auxillary information\n"));

  if (ent.vn_next < sizeof (*entry)
      && !(cnt == section->sh_info - 1 && ent.vn_next == 0))
    {
      warn (gettext ("Invalid vn_next field of %lx\n"), ent.vn_next);
      cnt = section->sh_info;
      break;
    }
  if (ent.vn_next > (size_t) (endbuf - ((char *) eneed + idx)))
    break;
  idx += ent.vn_next;
       }

     if (cnt < section->sh_info)
       warn (gettext ("Missing Version Needs information\n"));

     free (eneed);
   }
   break;

 case 0x6fffffff:
   {
     Elf_Internal_Shdr * link_section;
     size_t total;
     unsigned int cnt;
     unsigned char * edata;
     unsigned short * data;
     char * strtab;
     Elf_Internal_Sym * symbols;
     Elf_Internal_Shdr * string_sec;
     unsigned long num_syms;
     long off;

     if (section->sh_link >= elf_header.e_shnum)
       break;

     link_section = section_headers + section->sh_link;
     total = section->sh_size / sizeof (Elf_External_Versym);

     if (link_section->sh_link >= elf_header.e_shnum)
       break;

     found = 1;

     symbols = (is_32bit_elf ? get_32bit_elf_symbols (file, link_section, & num_syms) : get_64bit_elf_symbols (file, link_section, & num_syms));
     if (symbols == 
# 10433 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 10433 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
       break;

     string_sec = section_headers + link_section->sh_link;

     strtab = (char *) get_data (
# 10438 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 10438 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    , file, string_sec->sh_offset, 1,
                                        string_sec->sh_size,
                                        gettext ("version string table"));
     if (!strtab)
       {
  free (symbols);
  break;
       }

     printf (gettext ("\nVersion symbols section '%s' contains %lu entries:\n"),
      printable_section_name (section), (unsigned long) total);

     printf (gettext (" Addr: "));
     fprintf (
# 10451 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    stdout
# 10451 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    , "%016" "l" "x", section->sh_addr);
     printf (gettext ("  Offset: %#08lx  Link: %u (%s)\n"),
      (unsigned long) section->sh_offset, section->sh_link,
      printable_section_name (link_section));

     off = offset_from_vma (file,
       version_info[(0x6fffffff - (0x6ffffff0))],
       total * sizeof (short));
     edata = (unsigned char *) get_data (
# 10459 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0)
# 10459 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            , file, off, total,
                                                sizeof (short),
                                                gettext ("version symbol data"));
     if (!edata)
       {
  free (strtab);
  free (symbols);
  break;
       }

     data = (short unsigned int *) cmalloc (total, sizeof (short));

     for (cnt = total; cnt --;)
       data[cnt] = byte_get (edata + cnt * sizeof (short),
        sizeof (short));

     free (edata);

     for (cnt = 0; cnt < total; cnt += 4)
       {
  int j, nn;
  char *name;
  char *invalid = gettext ("*invalid*");

  printf ("  %03x:", cnt);

  for (j = 0; (j < 4) && (cnt + j) < total; ++j)
    switch (data[cnt + j])
      {
      case 0:
        fputs (gettext ("   0 (*local*)    "), 
# 10489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       stdout
# 10489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             );
        break;

      case 1:
        fputs (gettext ("   1 (*global*)   "), 
# 10493 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       stdout
# 10493 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             );
        break;

      default:
        nn = printf ("%4x%c", data[cnt + j] & 0x7fff,
       data[cnt + j] & 0x8000 ? 'h' : ' ');



        if ((unsigned long)(cnt + j) >= num_syms)
          {
            warn (gettext ("invalid index into symbol array\n"));
            break;
   }

        name = 
# 10508 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 10508 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
        if (version_info[(0x6fffffff - (0x6ffffffe))])
   {
     Elf_Internal_Verneed ivn;
     unsigned long offset;

     offset = offset_from_vma
       (file, version_info[(0x6fffffff - (0x6ffffffe))],
        sizeof (Elf_External_Verneed));

     do
       {
         Elf_Internal_Vernaux ivna;
         Elf_External_Verneed evn;
         Elf_External_Vernaux evna;
         unsigned long a_off;

         if (get_data (&evn, file, offset, sizeof (evn), 1,
         gettext ("version need")) == 
# 10526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 10526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  )
    break;

         ivn.vn_aux = byte_get (evn.vn_aux, sizeof (evn.vn_aux));
         ivn.vn_next = byte_get (evn.vn_next, sizeof (evn.vn_next));

         a_off = offset + ivn.vn_aux;

         do
    {
      if (get_data (&evna, file, a_off, sizeof (evna),
      1, gettext ("version need aux (2)")) == 
# 10537 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 10537 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          )
        {
          ivna.vna_next = 0;
          ivna.vna_other = 0;
        }
      else
        {
          ivna.vna_next = byte_get (evna.vna_next, sizeof (evna.vna_next));
          ivna.vna_other = byte_get (evna.vna_other, sizeof (evna.vna_other));
        }

      a_off += ivna.vna_next;
    }
         while (ivna.vna_other != data[cnt + j]
         && ivna.vna_next != 0);

         if (ivna.vna_other == data[cnt + j])
    {
      ivna.vna_name = byte_get (evna.vna_name, sizeof (evna.vna_name));

      if (ivna.vna_name >= string_sec->sh_size)
        name = invalid;
      else
        name = strtab + ivna.vna_name;
      break;
    }

         offset += ivn.vn_next;
       }
     while (ivn.vn_next);
   }

        if (data[cnt + j] != 0x8001
     && version_info[(0x6fffffff - (0x6ffffffc))])
   {
     Elf_Internal_Verdef ivd;
     Elf_External_Verdef evd;
     unsigned long offset;

     offset = offset_from_vma
       (file, version_info[(0x6fffffff - (0x6ffffffc))],
        sizeof evd);

     do
       {
         if (get_data (&evd, file, offset, sizeof (evd), 1,
         gettext ("version def")) == 
# 10583 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0)
# 10583 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 )
    {
      ivd.vd_next = 0;

      ivd.vd_ndx = (data[cnt + j] & 0x7fff) + 1;
      break;
    }
         else
    {
      ivd.vd_next = byte_get (evd.vd_next, sizeof (evd.vd_next));
      ivd.vd_ndx = byte_get (evd.vd_ndx, sizeof (evd.vd_ndx));
    }

         offset += ivd.vd_next;
       }
     while (ivd.vd_ndx != (data[cnt + j] & 0x7fff)
     && ivd.vd_next != 0);

     if (ivd.vd_ndx == (data[cnt + j] & 0x7fff))
       {
         Elf_External_Verdaux evda;
         Elf_Internal_Verdaux ivda;

         ivd.vd_aux = byte_get (evd.vd_aux, sizeof (evd.vd_aux));

         if (get_data (&evda, file,
         offset - ivd.vd_next + ivd.vd_aux,
         sizeof (evda), 1,
         gettext ("version def aux")) == 
# 10611 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 10611 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     )
    break;

         ivda.vda_name = byte_get (evda.vda_name, sizeof (evda.vda_name));

         if (ivda.vda_name >= string_sec->sh_size)
    name = invalid;
         else if (name != 
# 10618 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0) 
# 10618 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              && name != invalid)
    name = gettext ("*both*");
         else
    name = strtab + ivda.vda_name;
       }
   }
        if (name != 
# 10624 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 10624 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
   nn += printf ("(%s%-*s",
          name,
          12 - (int) strlen (name),
          ")");

        if (nn < 18)
   printf ("%*c", 18 - nn, ' ');
      }

  putchar ('\n');
       }

     free (data);
     free (strtab);
     free (symbols);
   }
   break;

 default:
   break;
 }
    }

  if (! found)
    printf (gettext ("\nNo version information found in this file.\n"));

  return 1;
}

static const char *
get_symbol_binding (unsigned int binding)
{
  static char buff[32];

  switch (binding)
    {
    case 0: return "LOCAL";
    case 1: return "GLOBAL";
    case 2: return "WEAK";
    default:
      if (binding >= 13 && binding <= 15)
 snprintf (buff, sizeof (buff), gettext ("<processor specific>: %d"),
    binding);
      else if (binding >= 10 && binding <= 12)
 {
   if (binding == 10
       && (elf_header.e_ident[7] == 3

    || elf_header.e_ident[7] == 0))
     return "UNIQUE";
   snprintf (buff, sizeof (buff), gettext ("<OS specific>: %d"), binding);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %d"), binding);
      return buff;
    }
}

static const char *
get_symbol_type (unsigned int type)
{
  static char buff[32];

  switch (type)
    {
    case 0: return "NOTYPE";
    case 1: return "OBJECT";
    case 2: return "FUNC";
    case 3: return "SECTION";
    case 4: return "FILE";
    case 5: return "COMMON";
    case 6: return "TLS";
    case 8: return "RELC";
    case 9: return "SRELC";
    default:
      if (type >= 13 && type <= 15)
 {
   if (elf_header.e_machine == 40 && type == 13)
     return "THUMB_FUNC";

   if (elf_header.e_machine == 43 && type == 13)
     return "REGISTER";

   if (elf_header.e_machine == 15 && type == 13)
     return "PARISC_MILLI";

   snprintf (buff, sizeof (buff), gettext ("<processor specific>: %d"), type);
 }
      else if (type >= 10 && type <= 12)
 {
   if (elf_header.e_machine == 15)
     {
       if (type == (10 + 0x1))
  return "HP_OPAQUE";
       if (type == (10 + 0x2))
  return "HP_STUB";
     }

   if (type == 10
       && (elf_header.e_ident[7] == 3
    || elf_header.e_ident[7] == 9

    || elf_header.e_ident[7] == 0))
     return "IFUNC";

   snprintf (buff, sizeof (buff), gettext ("<OS specific>: %d"), type);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %d"), type);
      return buff;
    }
}

static const char *
get_symbol_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case 0: return "DEFAULT";
    case 1: return "INTERNAL";
    case 2: return "HIDDEN";
    case 3: return "PROTECTED";
    default:
      error (gettext ("Unrecognized visibility value: %u"), visibility);
      return gettext ("<unknown>");
    }
}

static const char *
get_solaris_symbol_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case 4: return "EXPORTED";
    case 5: return "SINGLETON";
    case 6: return "ELIMINATE";
    default: return get_symbol_visibility (visibility);
    }
}

static const char *
get_mips_symbol_other (unsigned int other)
{
  switch (other)
    {
    case (1 << 2): return "OPTIONAL";
    case 0x8: return "MIPS PLT";
    case 0x20: return "MIPS PIC";
    case (2 << 6): return "MICROMIPS";
    case (2 << 6) | 0x20: return "MICROMIPS, MIPS PIC";
    case 0xf0: return "MIPS16";
    default: return 
# 10776 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 10776 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   ;
    }
}

static const char *
get_ia64_symbol_other (unsigned int other)
{
  if (is_ia64_vms ())
    {
      static char res[32];

      res[0] = 0;


      switch (elf_header.e_type)
        {
        case 3:
        case 2:
          switch ((((other) & 0x30) >> 4))
            {
            case 0:
              strcat (res, " CA");
              break;
            case 1:
              strcat (res, " VEC");
              break;
            case 2:
              strcat (res, " FD");
              break;
            case 3:
              strcat (res, " RSV");
              break;
            default:
       warn (gettext ("Unrecognized IA64 VMS ST Function type: %d\n"),
      (((other) & 0x30) >> 4));
       strcat (res, " <unknown>");
       break;
            }
          break;
        default:
          break;
        }
      switch ((((other) & 0xc0) >> 6))
        {
        case 0:
          strcat (res, " IGN");
          break;
        case 1:
          strcat (res, " RSV");
          break;
        case 2:
          strcat (res, " STD");
          break;
        case 3:
          strcat (res, " LNK");
          break;
        default:
   warn (gettext ("Unrecognized IA64 VMS ST Linkage: %d\n"),
  (((other) & 0xc0) >> 6));
   strcat (res, " <unknown>");
   break;
        }

      if (res[0] != 0)
        return res + 1;
      else
        return res;
    }
  return 
# 10844 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 10844 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static const char *
get_ppc64_symbol_other (unsigned int other)
{
  if (ppc64_decode_local_entry (((other) & (7 << 5)) >> 5) != 0)
    {
      static char buf[32];
      snprintf (buf, sizeof buf, gettext ("<localentry>: %d"),
  ppc64_decode_local_entry (((other) & (7 << 5)) >> 5));
      return buf;
    }
  return 
# 10857 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 10857 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}

static const char *
get_symbol_other (unsigned int other)
{
  const char * result = 
# 10863 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 10863 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
  static char buff [32];

  if (other == 0)
    return "";

  switch (elf_header.e_machine)
    {
    case 8:
      result = get_mips_symbol_other (other);
      break;
    case 50:
      result = get_ia64_symbol_other (other);
      break;
    case 21:
      result = get_ppc64_symbol_other (other);
      break;
    default:
      result = 
# 10881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 10881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
      break;
    }

  if (result)
    return result;

  snprintf (buff, sizeof buff, gettext ("<other>: %x"), other);
  return buff;
}

static const char *
get_symbol_index_type (unsigned int type)
{
  static char buff[32];

  switch (type)
    {
    case 0: return "UND";
    case (-0xFu): return "ABS";
    case (-0xEu): return "COM";
    default:
      if (type == (-0x100u)
   && elf_header.e_machine == 50
   && elf_header.e_ident[7] == 1)
 return "ANSI_COM";
      else if ((elf_header.e_machine == 62
  || elf_header.e_machine == 180
  || elf_header.e_machine == 181)
        && type == ((-0x100u) + 2))
 return "LARGE_COM";
      else if ((type == ((-0x100u) + 3)
  && elf_header.e_machine == 8)
        || (type == (-0x100u)
     && elf_header.e_machine == 140))
 return "SCOM";
      else if (type == ((-0x100u) + 4)
        && elf_header.e_machine == 8)
 return "SUND";
      else if (type >= (-0x100u) && type <= (-0xE1u))
 sprintf (buff, "PRC[0x%04x]", type & 0xffff);
      else if (type >= (-0xE0u) && type <= (-0xC1u))
 sprintf (buff, "OS [0x%04x]", type & 0xffff);
      else if (type >= (-0x100u))
 sprintf (buff, "RSV[0x%04x]", type & 0xffff);
      else if (type >= elf_header.e_shnum)
 sprintf (buff, gettext ("bad section index[%3d]"), type);
      else
 sprintf (buff, "%3d", type);
      break;
    }

  return buff;
}

static bfd_vma *
get_dynamic_data (FILE * file, bfd_size_type number, unsigned int ent_size)
{
  unsigned char * e_data;
  bfd_vma * i_data;




  if (sizeof (size_t) < sizeof (bfd_size_type)
      && (bfd_size_type) ((size_t) number) != number)
    {
      error (gettext ("Size truncation prevents reading %" "l" "u" " elements of size %u\n")
                                 ,
      number, ent_size);
      return 
# 10951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 10951 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }



  if (ent_size * number > current_file_size)
    {
      error (gettext ("Invalid number of dynamic entries: %" "l" "u\n"),
      number);
      return 
# 10960 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 10960 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  e_data = (unsigned char *) cmalloc ((size_t) number, ent_size);
  if (e_data == 
# 10964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 10964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    {
      error (gettext ("Out of memory reading %" "l" "u dynamic entries\n"),
      number);
      return 
# 10968 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 10968 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  if (fread (e_data, ent_size, (size_t) number, file) != number)
    {
      error (gettext ("Unable to read in %" "l" "u bytes of dynamic data\n"),
      number * ent_size);
      free (e_data);
      return 
# 10976 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 10976 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  i_data = (bfd_vma *) cmalloc ((size_t) number, sizeof (*i_data));
  if (i_data == 
# 10980 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 10980 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    {
      error (gettext ("Out of memory allocating space for %" "l" "u" " dynamic entries\n")
                             ,
      number);
      free (e_data);
      return 
# 10986 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 10986 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  while (number--)
    i_data[number] = byte_get (e_data + number * ent_size, ent_size);

  free (e_data);

  return i_data;
}

static void
print_dynamic_symbol (bfd_vma si, unsigned long hn)
{
  Elf_Internal_Sym * psym;
  int n;

  n = print_vma (si, DEC_5);
  if (n < 5)
    fputs (&"     "[n], 
# 11005 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 11005 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
  printf (" %3lu: ", hn);

  if (dynamic_symbols == 
# 11008 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0) 
# 11008 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             || si >= num_dynamic_syms)
    {
      printf (gettext ("<No info available for dynamic symbol number %lu>\n"),
       (unsigned long) si);
      return;
    }

  psym = dynamic_symbols + si;
  print_vma (psym->st_value, LONG_HEX);
  putchar (' ');
  print_vma (psym->st_size, DEC_5);

  printf (" %-7s", get_symbol_type (((psym->st_info) & 0xF)));
  printf (" %-6s", get_symbol_binding ((((unsigned int)(psym->st_info)) >> 4)));

  if (elf_header.e_ident[7] == 6)
    printf (" %-7s", get_solaris_symbol_visibility (psym->st_other));
  else
    {
      unsigned int vis = ((psym->st_other) & 0x3);

      printf (" %-7s", get_symbol_visibility (vis));




      if (psym->st_other ^ vis)
 printf (" [%s] ", get_symbol_other (psym->st_other ^ vis));
    }

  printf (" %3.3s ", get_symbol_index_type (psym->st_shndx));
  if (((dynamic_strings != 
# 11039 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void *)0)
# 11039 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     ) && (psym->st_name < dynamic_strings_length)))
    print_symbol (25, (dynamic_strings + psym->st_name));
  else
    printf (gettext (" <corrupt: %14ld>"), psym->st_name);
  putchar ('\n');
}

static const char *
get_symbol_version_string (FILE * file,
      bfd_boolean is_dynsym,
      const char * strtab,
      unsigned long int strtab_size,
      unsigned int si,
      Elf_Internal_Sym * psym,
      enum versioned_symbol_info * sym_info,
      unsigned short * vna_other)
{
  unsigned char data[2];
  unsigned short vers_data;
  unsigned long offset;

  if (!is_dynsym
      || version_info[(0x6fffffff - (0x6ffffff0))] == 0)
    return 
# 11062 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 11062 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;

  offset = offset_from_vma (file, version_info[(0x6fffffff - (0x6ffffff0))],
       sizeof data + si * sizeof (vers_data));

  if (get_data (&data, file, offset + si * sizeof (vers_data),
  sizeof (data), 1, gettext ("version data")) == 
# 11068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 11068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             )
    return 
# 11069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 11069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;

  vers_data = byte_get (data, 2);

  if ((vers_data & 0x8000) == 0 && vers_data <= 1)
    return 
# 11074 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 11074 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ;
# 11085 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  if (psym->st_shndx != 0
      && vers_data != 0x8001
      && version_info[(0x6fffffff - (0x6ffffffc))])
    {
      Elf_Internal_Verdef ivd;
      Elf_Internal_Verdaux ivda;
      Elf_External_Verdaux evda;
      unsigned long off;

      off = offset_from_vma (file,
        version_info[(0x6fffffff - (0x6ffffffc))],
        sizeof (Elf_External_Verdef));

      do
 {
   Elf_External_Verdef evd;

   if (get_data (&evd, file, off, sizeof (evd), 1,
   gettext ("version def")) == 
# 11103 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 11103 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
     {
       ivd.vd_ndx = 0;
       ivd.vd_aux = 0;
       ivd.vd_next = 0;
     }
   else
     {
       ivd.vd_ndx = byte_get (evd.vd_ndx, sizeof (evd.vd_ndx));
       ivd.vd_aux = byte_get (evd.vd_aux, sizeof (evd.vd_aux));
       ivd.vd_next = byte_get (evd.vd_next, sizeof (evd.vd_next));
     }

   off += ivd.vd_next;
 }
      while (ivd.vd_ndx != (vers_data & 0x7fff) && ivd.vd_next != 0);

      if (ivd.vd_ndx == (vers_data & 0x7fff))
 {
   off -= ivd.vd_next;
   off += ivd.vd_aux;

   if (get_data (&evda, file, off, sizeof (evda), 1,
   gettext ("version def aux")) != 
# 11126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 11126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
     {
       ivda.vda_name = byte_get (evda.vda_name, sizeof (evda.vda_name));

       if (psym->st_name != ivda.vda_name)
  {
    *sym_info = ((vers_data & 0x8000) != 0
          ? symbol_hidden : symbol_public);
    return (ivda.vda_name < strtab_size
     ? strtab + ivda.vda_name : gettext ("<corrupt>"));
  }
     }
 }
    }

  if (version_info[(0x6fffffff - (0x6ffffffe))])
    {
      Elf_External_Verneed evn;
      Elf_Internal_Verneed ivn;
      Elf_Internal_Vernaux ivna;

      offset = offset_from_vma (file,
    version_info[(0x6fffffff - (0x6ffffffe))],
    sizeof evn);
      do
 {
   unsigned long vna_off;

   if (get_data (&evn, file, offset, sizeof (evn), 1,
   gettext ("version need")) == 
# 11155 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 11155 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
     {
       ivna.vna_next = 0;
       ivna.vna_other = 0;
       ivna.vna_name = 0;
       break;
     }

   ivn.vn_aux = byte_get (evn.vn_aux, sizeof (evn.vn_aux));
   ivn.vn_next = byte_get (evn.vn_next, sizeof (evn.vn_next));

   vna_off = offset + ivn.vn_aux;

   do
     {
       Elf_External_Vernaux evna;

       if (get_data (&evna, file, vna_off, sizeof (evna), 1,
       gettext ("version need aux (3)")) == 
# 11173 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    ((void *)0)
# 11173 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        )
  {
    ivna.vna_next = 0;
    ivna.vna_other = 0;
    ivna.vna_name = 0;
  }
       else
  {
    ivna.vna_other = byte_get (evna.vna_other, sizeof (evna.vna_other));
    ivna.vna_next = byte_get (evna.vna_next, sizeof (evna.vna_next));
    ivna.vna_name = byte_get (evna.vna_name, sizeof (evna.vna_name));
  }

       vna_off += ivna.vna_next;
     }
   while (ivna.vna_other != vers_data && ivna.vna_next != 0);

   if (ivna.vna_other == vers_data)
     break;

   offset += ivn.vn_next;
 }
      while (ivn.vn_next != 0);

      if (ivna.vna_other == vers_data)
 {
   *sym_info = symbol_undefined;
   *vna_other = ivna.vna_other;
   return (ivna.vna_name < strtab_size
    ? strtab + ivna.vna_name : gettext ("<corrupt>"));
 }
    }
  return 
# 11205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 11205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
}


static bfd_boolean
process_symbol_table (FILE * file)
{
  Elf_Internal_Shdr * section;
  bfd_size_type nbuckets = 0;
  bfd_size_type nchains = 0;
  bfd_vma * buckets = 
# 11215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 11215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;
  bfd_vma * chains = 
# 11216 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 11216 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
  bfd_vma ngnubuckets = 0;
  bfd_vma * gnubuckets = 
# 11218 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 11218 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            ;
  bfd_vma * gnuchains = 
# 11219 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 11219 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
  bfd_vma gnusymidx = 0;
  bfd_size_type ngnuchains = 0;

  if (!do_syms && !do_dyn_syms && !do_histogram)
    return 1;

  if (dynamic_info[4]
      && (do_histogram
   || (do_using_dynamic
       && !do_dyn_syms
       && dynamic_strings != 
# 11230 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 11230 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )))
    {
      unsigned char nb[8];
      unsigned char nc[8];
      unsigned int hash_ent_size = 4;

      if ((elf_header.e_machine == 0x9026
    || elf_header.e_machine == 22
    || elf_header.e_machine == 0xa390)
   && elf_header.e_ident[4] == 2)
 hash_ent_size = 8;

      if (fseek (file,
   (archive_file_offset
    + offset_from_vma (file, dynamic_info[4],
         sizeof nb + sizeof nc)),
   
# 11246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  0
# 11246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_hash;
 }

      if (fread (nb, hash_ent_size, 1, file) != 1)
 {
   error (gettext ("Failed to read in number of buckets\n"));
   goto no_hash;
 }

      if (fread (nc, hash_ent_size, 1, file) != 1)
 {
   error (gettext ("Failed to read in number of chains\n"));
   goto no_hash;
 }

      nbuckets = byte_get (nb, hash_ent_size);
      nchains = byte_get (nc, hash_ent_size);

      buckets = get_dynamic_data (file, nbuckets, hash_ent_size);
      chains = get_dynamic_data (file, nchains, hash_ent_size);

    no_hash:
      if (buckets == 
# 11271 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0) 
# 11271 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         || chains == 
# 11271 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 11271 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          )
 {
   if (do_using_dynamic)
     return 0;
   free (buckets);
   free (chains);
   buckets = 
# 11277 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 11277 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
   chains = 
# 11278 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0)
# 11278 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ;
   nbuckets = 0;
   nchains = 0;
 }
    }

  if (dynamic_info_DT_GNU_HASH
      && (do_histogram
   || (do_using_dynamic
       && !do_dyn_syms
       && dynamic_strings != 
# 11288 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 11288 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )))
    {
      unsigned char nb[16];
      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
      bfd_vma buckets_vma;

      if (fseek (file,
   (archive_file_offset
    + offset_from_vma (file, dynamic_info_DT_GNU_HASH,
         sizeof nb)),
   
# 11298 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  0
# 11298 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      if (fread (nb, 16, 1, file) != 1)
 {
   error (gettext ("Failed to read in number of buckets\n"));
   goto no_gnu_hash;
 }

      ngnubuckets = byte_get (nb, 4);
      gnusymidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
 buckets_vma += bitmaskwords * 4;
      else
 buckets_vma += bitmaskwords * 8;

      if (fseek (file,
   (archive_file_offset
    + offset_from_vma (file, buckets_vma, 4)),
   
# 11322 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  0
# 11322 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      gnubuckets = get_dynamic_data (file, ngnubuckets, 4);

      if (gnubuckets == 
# 11330 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 11330 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
 goto no_gnu_hash;

      for (i = 0; i < ngnubuckets; i++)
 if (gnubuckets[i] != 0)
   {
     if (gnubuckets[i] < gnusymidx)
       return 0;

     if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
       maxchain = gnubuckets[i];
   }

      if (maxchain == 0xffffffff)
 goto no_gnu_hash;

      maxchain -= gnusymidx;

      if (fseek (file,
   (archive_file_offset
    + offset_from_vma (file, buckets_vma
        + 4 * (ngnubuckets + maxchain), 4)),
   
# 11352 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  0
# 11352 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      do
 {
   if (fread (nb, 4, 1, file) != 1)
     {
       error (gettext ("Failed to determine last chain length\n"));
       goto no_gnu_hash;
     }

   if (maxchain + 1 == 0)
     goto no_gnu_hash;

   ++maxchain;
 }
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek (file,
   (archive_file_offset
    + offset_from_vma (file, buckets_vma + 4 * ngnubuckets, 4)),
   
# 11376 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  0
# 11376 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      gnuchains = get_dynamic_data (file, maxchain, 4);
      ngnuchains = maxchain;

    no_gnu_hash:
      if (gnuchains == 
# 11386 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 11386 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
 {
   free (gnubuckets);
   gnubuckets = 
# 11389 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 11389 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
   ngnubuckets = 0;
   if (do_using_dynamic)
     return 0;
 }
    }

  if ((dynamic_info[4] || dynamic_info_DT_GNU_HASH)
      && do_syms
      && do_using_dynamic
      && dynamic_strings != 
# 11399 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
      
# 11400 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     && dynamic_symbols != 
# 11400 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 11400 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
    {
      unsigned long hn;

      if (dynamic_info[4])
 {
   bfd_vma si;

   printf (gettext ("\nSymbol table for image:\n"));
   if (is_32bit_elf)
     printf (gettext ("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"));
   else
     printf (gettext ("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"));

   for (hn = 0; hn < nbuckets; hn++)
     {
       if (! buckets[hn])
  continue;

       for (si = buckets[hn]; si < nchains && si > 0; si = chains[si])
  print_dynamic_symbol (si, hn);
     }
 }

      if (dynamic_info_DT_GNU_HASH)
 {
   printf (gettext ("\nSymbol table of `.gnu.hash' for image:\n"));
   if (is_32bit_elf)
     printf (gettext ("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"));
   else
     printf (gettext ("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"));

   for (hn = 0; hn < ngnubuckets; ++hn)
     if (gnubuckets[hn] != 0)
       {
  bfd_vma si = gnubuckets[hn];
  bfd_vma off = si - gnusymidx;

  do
    {
      print_dynamic_symbol (si, hn);
      si++;
    }
  while (off < ngnuchains && (gnuchains[off++] & 1) == 0);
       }
 }
    }
  else if ((do_dyn_syms || (do_syms && !do_using_dynamic))
    && section_headers != 
# 11448 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 11448 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
    {
      unsigned int i;

      for (i = 0, section = section_headers;
    i < elf_header.e_shnum;
    i++, section++)
 {
   unsigned int si;
   char * strtab = 
# 11457 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 11457 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ;
   unsigned long int strtab_size = 0;
   Elf_Internal_Sym * symtab;
   Elf_Internal_Sym * psym;
   unsigned long num_syms;

   if ((section->sh_type != 2
        && section->sh_type != 11)
       || (!do_syms
    && section->sh_type == 2))
     continue;

   if (section->sh_entsize == 0)
     {
       printf (gettext ("\nSymbol table '%s' has a sh_entsize of zero!\n"),
        printable_section_name (section));
       continue;
     }

   printf (gettext ("\nSymbol table '%s' contains %lu entries:\n"),
    printable_section_name (section),
    (unsigned long) (section->sh_size / section->sh_entsize));

   if (is_32bit_elf)
     printf (gettext ("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
   else
     printf (gettext ("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));

   symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, section, & num_syms) : get_64bit_elf_symbols (file, section, & num_syms));
   if (symtab == 
# 11486 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 11486 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
     continue;

   if (section->sh_link == elf_header.e_shstrndx)
     {
       strtab = string_table;
       strtab_size = string_table_length;
     }
   else if (section->sh_link < elf_header.e_shnum)
     {
       Elf_Internal_Shdr * string_sec;

       string_sec = section_headers + section->sh_link;

       strtab = (char *) get_data (
# 11500 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  ((void *)0)
# 11500 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      , file, string_sec->sh_offset,
                                          1, string_sec->sh_size,
                                          gettext ("string table"));
       strtab_size = strtab != 
# 11503 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0) 
# 11503 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   ? string_sec->sh_size : 0;
     }

   for (si = 0, psym = symtab; si < num_syms; si++, psym++)
     {
       const char *version_string;
       enum versioned_symbol_info sym_info;
       unsigned short vna_other;

       printf ("%6d: ", si);
       print_vma (psym->st_value, LONG_HEX);
       putchar (' ');
       print_vma (psym->st_size, DEC_5);
       printf (" %-7s", get_symbol_type (((psym->st_info) & 0xF)));
       printf (" %-6s", get_symbol_binding ((((unsigned int)(psym->st_info)) >> 4)));
       if (elf_header.e_ident[7] == 6)
  printf (" %-7s", get_solaris_symbol_visibility (psym->st_other));
       else
  {
    unsigned int vis = ((psym->st_other) & 0x3);

    printf (" %-7s", get_symbol_visibility (vis));



    if (psym->st_other ^ vis)
      printf (" [%s] ", get_symbol_other (psym->st_other ^ vis));
  }
       printf (" %4s ", get_symbol_index_type (psym->st_shndx));
       print_symbol (25, psym->st_name < strtab_size
       ? strtab + psym->st_name : gettext ("<corrupt>"));

       version_string
  = get_symbol_version_string (file,
          section->sh_type == 11,
          strtab, strtab_size, si,
          psym, &sym_info, &vna_other);
       if (version_string)
  {
    if (sym_info == symbol_undefined)
      printf ("@%s (%d)", version_string, vna_other);
    else
      printf (sym_info == symbol_hidden ? "@%s" : "@@%s",
       version_string);
  }

       putchar ('\n');

       if ((((unsigned int)(psym->st_info)) >> 4) == 0
    && si >= section->sh_info

    && elf_header.e_machine != 8


    && elf_header.e_ident[7] != 6)
  warn (gettext ("local symbol %u found at index >= %s's sh_info value of %u\n"),
        si, printable_section_name (section), section->sh_info);
     }

   free (symtab);
   if (strtab != string_table)
     free (strtab);
 }
    }
  else if (do_syms)
    printf
      (gettext ("\nDynamic symbol information is not available for displaying symbols.\n"));

  if (do_histogram && buckets != 
# 11571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 11571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    )
    {
      unsigned long * lengths;
      unsigned long * counts;
      unsigned long hn;
      bfd_vma si;
      unsigned long maxlength = 0;
      unsigned long nzero_counts = 0;
      unsigned long nsyms = 0;
      unsigned long chained;

      printf (gettext ("\nHistogram for bucket list length (total of %lu buckets):\n"),
       (unsigned long) nbuckets);

      lengths = (unsigned long *) calloc (nbuckets, sizeof (*lengths));
      if (lengths == 
# 11586 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 11586 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
 {
   error (gettext ("Out of memory allocating space for histogram buckets\n"));
   return 0;
 }

      printf (gettext (" Length  Number     %% of total  Coverage\n"));
      for (hn = 0; hn < nbuckets; ++hn)
 {
   for (si = buckets[hn], chained = 0;
        si > 0 && si < nchains && si < nbuckets && chained <= nchains;
        si = chains[si], ++chained)
     {
       ++nsyms;
       if (maxlength < ++lengths[hn])
  ++maxlength;
     }




     if (chained > nchains)
       {
  error (gettext ("histogram chain is corrupt\n"));
  break;
       }
 }

      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
      if (counts == 
# 11615 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 11615 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
 {
   free (lengths);
   error (gettext ("Out of memory allocating space for histogram counts\n"));
   return 0;
 }

      for (hn = 0; hn < nbuckets; ++hn)
 ++counts[lengths[hn]];

      if (nbuckets > 0)
 {
   unsigned long i;
   printf ("      0  %-10lu (%5.1f%%)\n",
    counts[0], (counts[0] * 100.0) / nbuckets);
   for (i = 1; i <= maxlength; ++i)
     {
       nzero_counts += counts[i] * i;
       printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
        i, counts[i], (counts[i] * 100.0) / nbuckets,
        (nzero_counts * 100.0) / nsyms);
     }
 }

      free (counts);
      free (lengths);
    }

  if (buckets != 
# 11643 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 11643 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
    {
      free (buckets);
      free (chains);
    }

  if (do_histogram && gnubuckets != 
# 11649 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                   ((void *)0)
# 11649 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       )
    {
      unsigned long * lengths;
      unsigned long * counts;
      unsigned long hn;
      unsigned long maxlength = 0;
      unsigned long nzero_counts = 0;
      unsigned long nsyms = 0;

      printf (gettext ("\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"),
       (unsigned long) ngnubuckets);

      lengths = (unsigned long *) calloc (ngnubuckets, sizeof (*lengths));
      if (lengths == 
# 11662 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 11662 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
 {
   error (gettext ("Out of memory allocating space for gnu histogram buckets\n"));
   return 0;
 }

      printf (gettext (" Length  Number     %% of total  Coverage\n"));

      for (hn = 0; hn < ngnubuckets; ++hn)
 if (gnubuckets[hn] != 0)
   {
     bfd_vma off, length = 1;

     for (off = gnubuckets[hn] - gnusymidx;

   off < ngnuchains && (gnuchains[off] & 1) == 0;
   ++off)
       ++length;
     lengths[hn] = length;
     if (length > maxlength)
       maxlength = length;
     nsyms += length;
   }

      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
      if (counts == 
# 11687 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 11687 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
 {
   free (lengths);
   error (gettext ("Out of memory allocating space for gnu histogram counts\n"));
   return 0;
 }

      for (hn = 0; hn < ngnubuckets; ++hn)
 ++counts[lengths[hn]];

      if (ngnubuckets > 0)
 {
   unsigned long j;
   printf ("      0  %-10lu (%5.1f%%)\n",
    counts[0], (counts[0] * 100.0) / ngnubuckets);
   for (j = 1; j <= maxlength; ++j)
     {
       nzero_counts += counts[j] * j;
       printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
        j, counts[j], (counts[j] * 100.0) / ngnubuckets,
        (nzero_counts * 100.0) / nsyms);
     }
 }

      free (counts);
      free (lengths);
      free (gnubuckets);
      free (gnuchains);
    }

  return 1;
}

static bfd_boolean
process_syminfo (FILE * file __attribute__ ((__unused__)))
{
  unsigned int i;

  if (dynamic_syminfo == 
# 11725 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
      
# 11726 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     || !do_dynamic)

    return 1;


  if (dynamic_symbols == 
# 11731 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0) 
# 11731 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             || dynamic_strings == 
# 11731 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                   ((void *)0)
# 11731 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                       )
    return 0;

  if (dynamic_addr)
    printf (gettext ("\nDynamic info segment at offset 0x%lx contains %d entries:\n"),
     dynamic_syminfo_offset, dynamic_syminfo_nent);

  printf (gettext (" Num: Name                           BoundTo     Flags\n"));
  for (i = 0; i < dynamic_syminfo_nent; ++i)
    {
      unsigned short int flags = dynamic_syminfo[i].si_flags;

      printf ("%4d: ", i);
      if (i >= num_dynamic_syms)
 printf (gettext ("<corrupt index>"));
      else if (((dynamic_strings != 
# 11746 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 11746 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
              ) && (dynamic_symbols[i].st_name < dynamic_strings_length)))
 print_symbol (30, (dynamic_strings + dynamic_symbols[i].st_name));
      else
 printf (gettext ("<corrupt: %19ld>"), dynamic_symbols[i].st_name);
      putchar (' ');

      switch (dynamic_syminfo[i].si_boundto)
 {
 case 0xffff:
   fputs ("SELF       ", 
# 11755 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 11755 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
   break;
 case 0xfffe:
   fputs ("PARENT     ", 
# 11758 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 11758 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
   break;
 default:
   if (dynamic_syminfo[i].si_boundto > 0
       && dynamic_syminfo[i].si_boundto < dynamic_nent
       && ((dynamic_strings != 
# 11763 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 11763 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
         ) && (dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val < dynamic_strings_length)))
     {
       print_symbol (10, (dynamic_strings + dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val));
       putchar (' ' );
     }
   else
     printf ("%-10d ", dynamic_syminfo[i].si_boundto);
   break;
 }

      if (flags & 0x0001)
 printf (" DIRECT");
      if (flags & 0x0002)
 printf (" PASSTHRU");
      if (flags & 0x0004)
 printf (" COPY");
      if (flags & 0x0008)
 printf (" LAZYLOAD");

      puts ("");
    }

  return 1;
}
# 11799 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static bfd_boolean
target_specific_reloc_handling (Elf_Internal_Rela * reloc,
    unsigned char * start,
    unsigned char * end,
    Elf_Internal_Sym * symtab,
    unsigned long num_syms)
{
  unsigned int reloc_type = 0;
  unsigned long sym_index = 0;

  if (reloc)
    {
      reloc_type = get_reloc_type (reloc->r_info);
      sym_index = get_reloc_symindex (reloc->r_info);
    }

  switch (elf_header.e_machine)
    {
    case 105:
    case 0x1059:
      {
 static Elf_Internal_Sym * saved_sym = 
# 11820 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 11820 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;

 if (reloc == 
# 11822 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 11822 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
   {
     saved_sym = 
# 11824 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 11824 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;
     return 1;
   }

 switch (reloc_type)
   {
   case 10:
     if (uses_msp430x_relocs ())
       break;

   case 21:

     if (sym_index >= num_syms)
       error (gettext ("MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"),
       sym_index);
     else
       saved_sym = symtab + sym_index;
     return 1;

   case 1:
   case 3:
     goto handle_sym_diff;

   case 5:
   case 9:
     if (uses_msp430x_relocs ())
       break;
     goto handle_sym_diff;

   case 2:
   case 15:
     if (! uses_msp430x_relocs ())
       break;
     goto handle_sym_diff;

   handle_sym_diff:
     if (saved_sym != 
# 11860 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 11860 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
       {
  int reloc_size = reloc_type == 1 ? 4 : 2;
  bfd_vma value;

  if (sym_index >= num_syms)
    error (gettext ("MSP430 reloc contains invalid symbol index %lu\n"),
    sym_index);
  else
    {
      value = reloc->r_addend + (symtab[sym_index].st_value
            - saved_sym->st_value);

      if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) + (reloc_size) < (end))))
        byte_put (start + reloc->r_offset, value, reloc_size);
      else

        error (gettext ("MSP430 sym diff reloc contains invalid offset: 0x%lx\n"),
        (long) reloc->r_offset);
    }

  saved_sym = 
# 11881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 11881 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 ;
  return 1;
       }
     break;

   default:
     if (saved_sym != 
# 11887 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 11887 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
       error (gettext ("Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"));
     break;
   }
 break;
      }

    case 89:
    case 0xbeef:
      {
 static Elf_Internal_Sym * saved_sym = 
# 11897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 11897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;

 if (reloc == 
# 11899 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 11899 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
   {
     saved_sym = 
# 11901 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 11901 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    ;
     return 1;
   }

 switch (reloc_type)
   {
   case 34:
     return 1;
   case 33:
     if (sym_index >= num_syms)
       error (gettext ("MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"),
       sym_index);
     else
       saved_sym = symtab + sym_index;
     return 1;

   case 1:
   case 2:
     if (saved_sym != 
# 11919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 11919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
       {
  int reloc_size = reloc_type == 1 ? 4 : 2;
  bfd_vma value;

  if (sym_index >= num_syms)
    error (gettext ("MN10300 reloc contains invalid symbol index %lu\n"),
    sym_index);
  else
    {
      value = reloc->r_addend + (symtab[sym_index].st_value
            - saved_sym->st_value);

      if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) + (reloc_size) < (end))))
        byte_put (start + reloc->r_offset, value, reloc_size);
      else
        error (gettext ("MN10300 sym diff reloc contains invalid offset: 0x%lx\n"),
        (long) reloc->r_offset);
    }

  saved_sym = 
# 11939 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 11939 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 ;
  return 1;
       }
     break;
   default:
     if (saved_sym != 
# 11944 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 11944 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
       error (gettext ("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
     break;
   }
 break;
      }

    case 197:
      {
 static bfd_vma saved_sym1 = 0;
 static bfd_vma saved_sym2 = 0;
 static bfd_vma value;

 if (reloc == 
# 11957 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 11957 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
   {
     saved_sym1 = saved_sym2 = 0;
     return 1;
   }

 switch (reloc_type)
   {
   case 0x80:
     saved_sym1 = saved_sym2;
     if (sym_index >= num_syms)
       error (gettext ("RL78_SYM reloc contains invalid symbol index %lu\n"),
       sym_index);
     else
       {
  saved_sym2 = symtab[sym_index].st_value;
  saved_sym2 += reloc->r_addend;
       }
     return 1;

   case 0x83:
     value = saved_sym1 - saved_sym2;
     saved_sym2 = saved_sym1 = 0;
     return 1;
     break;

   case 0x41:
     if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) + (4) < (end))))
       byte_put (start + reloc->r_offset, value, 4);
     else
       error (gettext ("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
       (long) reloc->r_offset);
     value = 0;
     return 1;

   case 0x43:
     if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) + (2) < (end))))
       byte_put (start + reloc->r_offset, value, 2);
     else
       error (gettext ("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
       (long) reloc->r_offset);
     value = 0;
     return 1;

   default:
     break;
   }
 break;
      }
    }

  return 0;
}
# 12022 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static bfd_boolean
is_32bit_abs_reloc (unsigned int reloc_type)
{

  switch (elf_header.e_machine)
    {
    case 3:
    case 6:
      return reloc_type == 1;
    case 4:
      return reloc_type == 1;
    case 7:
      return reloc_type == 1;
    case 19:
      return reloc_type == 2;
    case 183:
      return (reloc_type == 258
       || reloc_type == 1);
    case 0x1223:
      return reloc_type == 3;
    case 0x9026:
      return reloc_type == 1;
    case 45:
      return reloc_type == 1;
    case 93:
    case 195:
      return reloc_type == 4;
    case 40:
      return reloc_type == 2;
    case 0x1057:
    case 83:
      return reloc_type == 1;
    case 106:
      return reloc_type == 0x12;
    case 76:
      return reloc_type == 3;
    case 177:
      return reloc_type == 3;
    case 114:
      return reloc_type == 15;
    case 0x5441:
      return reloc_type == 1;
    case 0x7650:
    case 85:
      return reloc_type == 6;
    case 0x7676:
    case 86:
      return reloc_type == 12;
    case 0x5aa5:
      return reloc_type == 3;
    case 0x3330:
    case 84:
      return reloc_type == 3;
    case 222:
      return reloc_type == 1;
    case 48:
    case 46:
    case 47:
      return reloc_type == 1;
    case 50:
      return reloc_type == 0x65
 || reloc_type == 0x25;
    case 0x8217:
    case 101:
      return reloc_type == 2;
    case 0xFEBA:
      return reloc_type == 2;
    case 138:
      return reloc_type == 3;
    case 0xFEB0:
    case 120:
      return reloc_type == 3;
    case 88:
      return reloc_type == 34;
    case 70:
    case 53:
      return reloc_type == 6;
    case 39:
      return reloc_type == 1;
    case 0xF00D:
      return reloc_type == 4;
    case 174:
      return reloc_type == 2;
    case 189:
      return reloc_type == 1;
    case 8:
      return reloc_type == 2;
    case 80:
      return reloc_type == 4;
    case 0xdead:
    case 90:
      return reloc_type == 1;
    case 0xbeef:
    case 89:
      return reloc_type == 1;
    case 223:
      return reloc_type == 1;
    case 0x1059:
    case 105:
      return reloc_type == 1;
    case 0x2530:
      return reloc_type == 2;
    case 167:
      return reloc_type == 20;
    case 113:
      return reloc_type == 12;
    case 0xFEBB:
      return reloc_type == 1;
    case 92:
      return reloc_type == 1;
    case 15:
      return (reloc_type == 1
       || reloc_type == 41);
    case 91:
    case 99:
      return reloc_type == 1;
    case 21:
      return reloc_type == 1;
    case 20:
      return reloc_type == 1;
    case 144:
      return reloc_type == 11;
    case 243:
      return reloc_type == 1;
    case 197:
      return reloc_type == 1;
    case 173:
      return reloc_type == 1;
    case 9:
      return reloc_type == 1;
    case 0xa390:
    case 22:
      return reloc_type == 4;
    case 135:
      return reloc_type == 8;
    case 42:
      return reloc_type == 1;
    case 18:
    case 43:
    case 2:
      return reloc_type == 3
 || reloc_type == 23;
    case 23:
      return reloc_type == 6;
    case 140:
      return reloc_type == 1;
    case 191:
      return reloc_type == 2;
    case 188:
      return reloc_type == 1;
    case 0x9080:
    case 87:
      return reloc_type == 6;
    case 36:
      return reloc_type == 0x33;
    case 75:
      return reloc_type == 1;
    case 221:
      return reloc_type == 3;
    case 0x4157:
      return reloc_type == 1;
    case 62:
    case 180:
    case 181:
      return reloc_type == 10;
    case 0x4688:
    case 116:
      return reloc_type == 3;
    case 115:
      return reloc_type == 4;
    case 0xad45:
      return reloc_type == 1;
    case 0xabc7:
    case 94:
      return reloc_type == 1;
    default:
      {
 static unsigned int prev_warn = 0;


 if (prev_warn != elf_header.e_machine)
   error (gettext ("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
   elf_header.e_machine);
 prev_warn = elf_header.e_machine;
 return 0;
      }
    }
}




static bfd_boolean
is_32bit_pcrel_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)

    {
    case 3:
    case 6:
      return reloc_type == 2;
    case 4:
      return reloc_type == 4;
    case 183:
      return reloc_type == 261;
    case 0x1223:
      return reloc_type == 6;
    case 0x9026:
      return reloc_type == 10;
    case 93:
    case 195:
      return reloc_type == 49;
    case 40:
      return reloc_type == 3;
    case 0x1057:
    case 83:
      return reloc_type == 36;
    case 189:
      return reloc_type == 2;
    case 92:
      return reloc_type == 9;
    case 15:
      return reloc_type == 9;
    case 20:
      return reloc_type == 26;
    case 21:
      return reloc_type == 26;
    case 0xa390:
    case 22:
      return reloc_type == 5;
    case 42:
      return reloc_type == 2;
    case 18:
    case 43:
    case 2:
      return reloc_type == 6;
    case 23:
      return reloc_type == 13;
    case 191:
      return reloc_type == 6;
    case 188:
      return reloc_type == 4;
    case 221:
      return reloc_type == 6;
    case 62:
    case 180:
    case 181:
      return reloc_type == 2;
    case 0xabc7:
    case 94:
      return reloc_type == 14;
    default:





      return 0;
    }
}




static bfd_boolean
is_64bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case 183:
      return reloc_type == 257;
    case 0x9026:
      return reloc_type == 2;
    case 50:
      return reloc_type == 0x27;
    case 15:
      return reloc_type == 80;
    case 21:
      return reloc_type == 38;
    case 243:
      return reloc_type == 2;
    case 18:
    case 43:
    case 2:
      return reloc_type == 54;
    case 62:
    case 180:
    case 181:
      return reloc_type == 1;
    case 0xa390:
    case 22:
      return reloc_type == 22;
    case 191:
      return reloc_type == 1;
    case 8:
      return reloc_type == 18;
    default:
      return 0;
    }
}




static bfd_boolean
is_64bit_pcrel_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case 183:
      return reloc_type == 260;
    case 0x9026:
      return reloc_type == 11;
    case 50:
      return reloc_type == 0x4f;
    case 15:
      return reloc_type == 72;
    case 21:
      return reloc_type == 44;
    case 18:
    case 43:
    case 2:
      return reloc_type == 46;
    case 62:
    case 180:
    case 181:
      return reloc_type == 24;
    case 0xa390:
    case 22:
      return reloc_type == 23;
    case 191:
      return reloc_type == 5;
    default:
      return 0;
    }
}




static bfd_boolean
is_24bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case 0xdead:
    case 90:
      return reloc_type == 4;
    case 222:
      return reloc_type == 5;
    default:
      return 0;
    }
}




static bfd_boolean
is_16bit_abs_reloc (unsigned int reloc_type)
{

  switch (elf_header.e_machine)
    {
    case 45:
    case 93:
    case 195:
      return reloc_type == 2;
    case 0x1223:
      return reloc_type == 5;
    case 0x1057:
    case 83:
      return reloc_type == 4;
    case 0x7650:
    case 85:
      return reloc_type == 3;
    case 48:
    case 46:
    case 47:
      return reloc_type == R_H8_DIR16;
    case 0x8217:
    case 101:
      return reloc_type == 1;
    case 0xFEB0:
    case 120:
      return reloc_type == 1;
    case 0xdead:
    case 90:
      return reloc_type == 2;
    case 0xbeef:
    case 89:
      return reloc_type == 2;
    case 105:
      if (uses_msp430x_relocs ())
 return reloc_type == 2;

    case 0x1059:
      return reloc_type == 5;
    case 167:
      return reloc_type == 19;
    case 113:
      return reloc_type == 13;
    case 0xFEBB:
      return reloc_type == 9;
    case 92:
      return reloc_type == 2;
    case 144:
      return reloc_type == 8;
    case 140:
      return reloc_type == 2;
    case 221:
      return reloc_type == 2;
    case 0x4688:
    case 116:
      return reloc_type == 2;
    case 115:
      return reloc_type == 3;
    default:
      return 0;
    }
}




static bfd_boolean
is_none_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case 3:
    case 4:
    case 0x1223:
    case 0x9026:
    case 113:
    case 45:
    case 195:
    case 93:
    case 40:
    case 116:
    case 76:
    case 222:
    case 50:
    case 181:
    case 180:
    case 88:
    case 8:
    case 89:
    case 223:
    case 0xFEBB:
    case 92:
    case 15:
    case 21:
    case 20:
    case 243:
    case 22:
    case 0xa390:
    case 42:
    case 18:
    case 2:
    case 43:
    case 191:
    case 188:
    case 140:
    case 62:
    case 0x4688:
    case 0x4157:
      return reloc_type == 0;

    case 183:
      return reloc_type == 0 || reloc_type == 256;
    case 0x1057:
    case 83:
      return (reloc_type == 0
       || reloc_type == 30
       || reloc_type == 31
       || reloc_type == 32 );
    case 174:
      return reloc_type == 3;
    case 167:
      return (reloc_type == 0
       || reloc_type == 204
       || reloc_type == 205
       || reloc_type == 206
       || reloc_type == 207 );
    case 144:
      return (reloc_type == 0
       || reloc_type == 65
       || reloc_type == 66
       || reloc_type == 67 );
    case 0xabc7:
    case 94:
      return (reloc_type == 0
       || reloc_type == 17
       || reloc_type == 18
       || reloc_type == 19 );
    }
  return 0;
}




bfd_boolean
reloc_at (struct dwarf_section * dsec, dwarf_vma offset)
{
  Elf_Internal_Rela * relocs;
  Elf_Internal_Rela * rp;

  if (dsec == 
# 12531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 12531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  || dsec->reloc_info == 
# 12531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 12531 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             )
    return 0;

  relocs = (Elf_Internal_Rela *) dsec->reloc_info;

  for (rp = relocs; rp < relocs + dsec->num_relocs; ++rp)
    if (rp->r_offset == offset)
      return 1;

   return 0;
}
# 12553 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static bfd_boolean
apply_relocations (void * file,
     const Elf_Internal_Shdr * section,
     unsigned char * start,
     bfd_size_type size,
     void ** relocs_return,
     unsigned long * num_relocs_return)
{
  Elf_Internal_Shdr * relsec;
  unsigned char * end = start + size;
  bfd_boolean res = 1;

  if (relocs_return != 
# 12565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 12565 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          )
    {
      * (Elf_Internal_Rela **) relocs_return = 
# 12567 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 12567 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  ;
      * num_relocs_return = 0;
    }

  if (elf_header.e_type != 1)

    return 1;


  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      bfd_boolean is_rela;
      unsigned long num_relocs;
      Elf_Internal_Rela * relocs;
      Elf_Internal_Rela * rp;
      Elf_Internal_Shdr * symsec;
      Elf_Internal_Sym * symtab;
      unsigned long num_syms;
      Elf_Internal_Sym * sym;

      if ((relsec->sh_type != 4 && relsec->sh_type != 9)
   || relsec->sh_info >= elf_header.e_shnum
   || section_headers + relsec->sh_info != section
   || relsec->sh_size == 0
   || relsec->sh_link >= elf_header.e_shnum)
 continue;

      is_rela = relsec->sh_type == 4;

      if (is_rela)
 {
   if (!slurp_rela_relocs ((FILE *) file, relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs))
     return 0;
 }
      else
 {
   if (!slurp_rel_relocs ((FILE *) file, relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs))
     return 0;
 }


      if (elf_header.e_machine == 42)
 is_rela = 0;

      symsec = section_headers + relsec->sh_link;
      if (symsec->sh_type != 2
   && symsec->sh_type != 11)
 return 0;
      symtab = (is_32bit_elf ? get_32bit_elf_symbols ((FILE *) file, symsec, & num_syms) : get_64bit_elf_symbols ((FILE *) file, symsec, & num_syms));

      for (rp = relocs; rp < relocs + num_relocs; ++rp)
 {
   bfd_vma addend;
   unsigned int reloc_type;
   unsigned int reloc_size;
   unsigned char * rloc;
   unsigned long sym_index;

   reloc_type = get_reloc_type (rp->r_info);

   if (target_specific_reloc_handling (rp, start, end, symtab, num_syms))
     continue;
   else if (is_none_reloc (reloc_type))
     continue;
   else if (is_32bit_abs_reloc (reloc_type)
     || is_32bit_pcrel_reloc (reloc_type))
     reloc_size = 4;
   else if (is_64bit_abs_reloc (reloc_type)
     || is_64bit_pcrel_reloc (reloc_type))
     reloc_size = 8;
   else if (is_24bit_abs_reloc (reloc_type))
     reloc_size = 3;
   else if (is_16bit_abs_reloc (reloc_type))
     reloc_size = 2;
   else
     {
       static unsigned int prev_reloc = 0;
       if (reloc_type != prev_reloc)
  warn (gettext ("unable to apply unsupported reloc type %d to section %s\n"),
        reloc_type, printable_section_name (section));
       prev_reloc = reloc_type;
       res = 0;
       continue;
     }

   rloc = start + rp->r_offset;
   if ((rloc + reloc_size) > end || (rloc < start))
     {
       warn (gettext ("skipping invalid relocation offset 0x%lx in section %s\n"),
      (unsigned long) rp->r_offset,
      printable_section_name (section));
       res = 0;
       continue;
     }

   sym_index = (unsigned long) get_reloc_symindex (rp->r_info);
   if (sym_index >= num_syms)
     {
       warn (gettext ("skipping invalid relocation symbol index 0x%lx in section %s\n"),
      sym_index, printable_section_name (section));
       res = 0;
       continue;
     }
   sym = symtab + sym_index;
# 12689 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
   if (sym != symtab
       && ((sym->st_info) & 0xF) != 5
       && ((sym->st_info) & 0xF) > 3)
     {
       warn (gettext ("skipping unexpected symbol type %s in %ld'th relocation in section %s\n"),
      get_symbol_type (((sym->st_info) & 0xF)),
      (long int)(rp - relocs),
      printable_section_name (relsec));
       res = 0;
       continue;
     }

   addend = 0;
   if (is_rela)
     addend += rp->r_addend;


   if (!is_rela
       || (elf_header.e_machine == 94
    && reloc_type == 1)
       || ((elf_header.e_machine == 91
     || elf_header.e_machine == 99)
    && reloc_type == 1)
       || ((elf_header.e_machine == 86
     || elf_header.e_machine == 0x7676)
    && reloc_type == 12))
     addend += byte_get (rloc, reloc_size);

   if (is_32bit_pcrel_reloc (reloc_type)
       || is_64bit_pcrel_reloc (reloc_type))
     {

       if (elf_header.e_machine == 15)
  addend -= 8;
       byte_put (rloc, (addend + sym->st_value) - rp->r_offset,
          reloc_size);
     }
   else
     byte_put (rloc, addend + sym->st_value, reloc_size);
 }

      free (symtab);


      target_specific_reloc_handling (
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         , 
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               , 
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                 ((void *)0)
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                     , 
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                       ((void *)0)
# 12733 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                           , 0);

      if (relocs_return)
 {
   * (Elf_Internal_Rela **) relocs_return = relocs;
   * num_relocs_return = num_relocs;
 }
      else
 free (relocs);

      break;
    }

  return res;
}
# 12764 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static char *
get_section_contents (Elf_Internal_Shdr * section, FILE * file)
{
  bfd_size_type num_bytes;

  num_bytes = section->sh_size;

  if (num_bytes == 0 || section->sh_type == 8)
    {
      printf (gettext ("\nSection '%s' has no data to dump.\n"),
       printable_section_name (section));
      return 
# 12775 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 12775 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                ;
    }

  return (char *) get_data (
# 12778 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 12778 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                , file, section->sh_offset, 1, num_bytes,
                             gettext ("section contents"));
}



static bfd_boolean
uncompress_section_contents (unsigned char **buffer,
        dwarf_size_type uncompressed_size,
        dwarf_size_type *size)
{
  dwarf_size_type compressed_size = *size;
  unsigned char * compressed_buffer = *buffer;
  unsigned char * uncompressed_buffer;
  z_stream strm;
  int rc;
# 12802 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  memset (& strm, 0, sizeof strm);
  strm.avail_in = compressed_size;
  strm.next_in = (Bytef *) compressed_buffer;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = (unsigned char *) xmalloc (uncompressed_size);

  rc = inflateInit_((& strm), "1.2.11", (int)sizeof(z_stream));
  while (strm.avail_in > 0)
    {
      if (rc != 0)
        goto fail;
      strm.next_out = ((Bytef *) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, 4);
      if (rc != 1)
        goto fail;
      rc = inflateReset (& strm);
    }
  rc = inflateEnd (& strm);
  if (rc != 0
      || strm.avail_out != 0)
    goto fail;

  *buffer = uncompressed_buffer;
  *size = uncompressed_size;
  return 1;

 fail:
  free (uncompressed_buffer);

  *buffer = 
# 12832 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
           ((void *)0)
# 12832 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ;
  return 0;
}

static bfd_boolean
dump_section_as_strings (Elf_Internal_Shdr * section, FILE * file)
{
  Elf_Internal_Shdr * relsec;
  bfd_size_type num_bytes;
  unsigned char * data;
  unsigned char * end;
  unsigned char * real_start;
  unsigned char * start;
  bfd_boolean some_strings_shown;

  real_start = start = (unsigned char *) get_section_contents (section,
              file);
  if (start == 
# 12849 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 12849 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )

    return (section->sh_size == 0 || section->sh_type == 8) ? 1 : 0;

  num_bytes = section->sh_size;

  printf (gettext ("\nString dump of section '%s':\n"), printable_section_name (section));

  if (decompress_dumps)
    {
      dwarf_size_type new_size = num_bytes;
      dwarf_size_type uncompressed_size = 0;

      if ((section->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size
     = get_compression_header (& chdr, (unsigned char *) start,
          num_bytes);

   if (chdr.ch_type != 1)
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      printable_section_name (section), chdr.ch_type);
       return 0;
     }
   else if (chdr.ch_addralign != section->sh_addralign)
     {
       warn (gettext ("compressed section '%s' is corrupted\n"),
      printable_section_name (section));
       return 0;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   new_size -= compression_header_size;
 }
      else if (new_size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   new_size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (& start,
        uncompressed_size, & new_size))
     num_bytes = new_size;
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (section));
       return 0;
     }
 }
      else
 start = real_start;
    }






  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if ((relsec->sh_type != 4 && relsec->sh_type != 9)
   || relsec->sh_info >= elf_header.e_shnum
   || section_headers + relsec->sh_info != section
   || relsec->sh_size == 0
   || relsec->sh_link >= elf_header.e_shnum)
 continue;

      printf (gettext ("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
      break;
    }

  data = start;
  end = start + num_bytes;
  some_strings_shown = 0;

  while (data < end)
    {
      while (!(_sch_istable[(* data) & 0xff] & (unsigned short)(_sch_isprint)))
 if (++ data >= end)
   break;

      if (data < end)
 {
   size_t maxlen = end - data;




   printf ("  [%6tx]  ", data - start);



   if (maxlen > 0)
     {
       print_symbol ((int) maxlen, (const char *) data);
       putchar ('\n');
       data += strnlen ((const char *) data, maxlen);
     }
   else
     {
       printf (gettext ("<corrupt>\n"));
       data = end;
     }
   some_strings_shown = 1;
 }
    }

  if (! some_strings_shown)
    printf (gettext ("  No strings found in this section."));

  free (real_start);

  putchar ('\n');
  return 1;
}

static bfd_boolean
dump_section_as_bytes (Elf_Internal_Shdr * section,
         FILE * file,
         bfd_boolean relocate)
{
  Elf_Internal_Shdr * relsec;
  bfd_size_type bytes;
  bfd_size_type section_size;
  bfd_vma addr;
  unsigned char * data;
  unsigned char * real_start;
  unsigned char * start;

  real_start = start = (unsigned char *) get_section_contents (section, file);
  if (start == 
# 12997 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 12997 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )

    return (section->sh_size == 0 || section->sh_type == 8) ? 1 : 0;

  section_size = section->sh_size;

  printf (gettext ("\nHex dump of section '%s':\n"), printable_section_name (section));

  if (decompress_dumps)
    {
      dwarf_size_type new_size = section_size;
      dwarf_size_type uncompressed_size = 0;

      if ((section->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size
     = get_compression_header (& chdr, start, section_size);

   if (chdr.ch_type != 1)
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      printable_section_name (section), chdr.ch_type);
       return 0;
     }
   else if (chdr.ch_addralign != section->sh_addralign)
     {
       warn (gettext ("compressed section '%s' is corrupted\n"),
      printable_section_name (section));
       return 0;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   new_size -= compression_header_size;
 }
      else if (new_size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   new_size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (& start, uncompressed_size,
        & new_size))
     {
       section_size = new_size;
     }
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (section));

       return 0;
     }
 }
      else
 start = real_start;
    }

  if (relocate)
    {
      if (! apply_relocations (file, section, start, section_size, 
# 13070 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                  ((void *)0)
# 13070 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                      , 
# 13070 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                        ((void *)0)
# 13070 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                            ))
 return 0;
    }
  else
    {





      for (relsec = section_headers;
    relsec < section_headers + elf_header.e_shnum;
    ++relsec)
 {
   if ((relsec->sh_type != 4 && relsec->sh_type != 9)
       || relsec->sh_info >= elf_header.e_shnum
       || section_headers + relsec->sh_info != section
       || relsec->sh_size == 0
       || relsec->sh_link >= elf_header.e_shnum)
     continue;

   printf (gettext (" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
   break;
 }
    }

  addr = section->sh_addr;
  bytes = section_size;
  data = start;

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
 {
   if (j < lbytes)
     printf ("%2.2x", data[j]);
   else
     printf ("  ");

   if ((j & 3) == 3)
     printf (" ");
 }

      for (j = 0; j < lbytes; j++)
 {
   k = data[j];
   if (k >= ' ' && k < 0x7f)
     printf ("%c", k);
   else
     printf (".");
 }

      putchar ('\n');

      data += lbytes;
      addr += lbytes;
      bytes -= lbytes;
    }

  free (real_start);

  putchar ('\n');
  return 1;
}

static bfd_boolean
load_specific_debug_section (enum dwarf_section_display_enum debug,
        const Elf_Internal_Shdr * sec, void * file)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  char buf [64];


  if (section->start != 
# 13151 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13151 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    return 1;

  snprintf (buf, sizeof (buf), gettext ("%s section data"), section->name);
  section->address = sec->sh_addr;
  section->user_data = 
# 13156 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 13156 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          ;
  section->start = (unsigned char *) get_data (
# 13157 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 13157 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  , (FILE *) file,
                                               sec->sh_offset, 1,
                                               sec->sh_size, buf);
  if (section->start == 
# 13160 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13160 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    section->size = 0;
  else
    {
      unsigned char *start = section->start;
      dwarf_size_type size = sec->sh_size;
      dwarf_size_type uncompressed_size = 0;

      if ((sec->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size;

   if (size < (is_32bit_elf
        ? sizeof (Elf32_External_Chdr)
        : sizeof (Elf64_External_Chdr)))
     {
       warn (gettext ("compressed section %s is too small to contain a compression header"),
      section->name);
       return 0;
     }

   compression_header_size = get_compression_header (&chdr, start, size);

   if (chdr.ch_type != 1)
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      section->name, chdr.ch_type);
       return 0;
     }
   else if (chdr.ch_addralign != sec->sh_addralign)
     {
       warn (gettext ("compressed section '%s' is corrupted\n"),
      section->name);
       return 0;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   size -= compression_header_size;
 }
      else if (size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (&start, uncompressed_size,
        &size))
     {


       free (section->start);
       section->start = start;
     }
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (sec));
       return 0;
     }
 }

      section->size = size;
    }

  if (section->start == 
# 13238 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13238 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    return 0;

  if (debug_displays [debug].relocate)
    {
      if (! apply_relocations ((FILE *) file, sec, section->start, section->size,
          & section->reloc_info, & section->num_relocs))
 return 0;
    }
  else
    {
      section->reloc_info = 
# 13249 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 13249 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;
      section->num_relocs = 0;
    }

  return 1;
}



static unsigned int * section_subset = 
# 13258 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 13258 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          ;

bfd_boolean
load_debug_section (enum dwarf_section_display_enum debug, void * file)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  Elf_Internal_Shdr * sec;


  sec = find_section_in_set (section->uncompressed_name, section_subset);
  if (sec != 
# 13268 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 13268 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                )
    section->name = section->uncompressed_name;
  else
    {
      sec = find_section_in_set (section->compressed_name, section_subset);
      if (sec != 
# 13273 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
# 13273 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    )
 section->name = section->compressed_name;
    }
  if (sec == 
# 13276 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            ((void *)0)
# 13276 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                )
    return 0;




  if (section_subset != 
# 13282 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13282 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    free_debug_section (debug);

  return load_specific_debug_section (debug, sec, (FILE *) file);
}

void
free_debug_section (enum dwarf_section_display_enum debug)
{
  struct dwarf_section * section = &debug_displays [debug].section;

  if (section->start == 
# 13293 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13293 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
    return;

  free ((char *) section->start);
  section->start = 
# 13297 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 13297 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ;
  section->address = 0;
  section->size = 0;
}

static bfd_boolean
display_debug_section (int shndx, Elf_Internal_Shdr * section, FILE * file)
{
  char * name = ((section) == 
# 13305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0) 
# 13305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ? gettext ("<none>") : string_table == 
# 13305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0) 
# 13305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               ? gettext ("<no-name>") : ((section)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section)->sh_name));
  const char * print_name = printable_section_name (section);
  bfd_size_type length;
  bfd_boolean result = 1;
  int i;

  length = section->sh_size;
  if (length == 0)
    {
      printf (gettext ("\nSection '%s' has no debugging data.\n"), print_name);
      return 1;
    }
  if (section->sh_type == 8)
    {




      printf (gettext ("section '%s' has the NOBITS type - its contents are unreliable.\n"),
       print_name);
      return 0;
    }

  if ((strncmp ((name), (".gnu.linkonce.wi."), sizeof (".gnu.linkonce.wi.") - 1) == 0))
    name = ".debug_info";


  for (i = 0; i < max; i++)
    if ((strcmp ((debug_displays[i].section.uncompressed_name), (name)) == 0)
 || (i == line && (strncmp ((name), (".debug_line."), sizeof (".debug_line.") - 1) == 0))
        || (strcmp ((debug_displays[i].section.compressed_name), (name)) == 0))
      {
 struct dwarf_section * sec = &debug_displays [i].section;
 int secondary = (section != find_section (name));

 if (secondary)
   free_debug_section ((enum dwarf_section_display_enum) i);

 if (i == line && (strncmp ((name), (".debug_line."), sizeof (".debug_line.") - 1) == 0))
   sec->name = name;
 else if ((strcmp ((sec->uncompressed_name), (name)) == 0))
   sec->name = sec->uncompressed_name;
 else
   sec->name = sec->compressed_name;
 if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
                                         section, file))
   {


     section_subset = find_cu_tu_set (file, shndx);

     result &= debug_displays[i].display (sec, file);

     section_subset = 
# 13358 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 13358 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         ;

     if (secondary || (i != info && i != abbrev))
       free_debug_section ((enum dwarf_section_display_enum) i);
   }

 break;
      }

  if (i == max)
    {
      printf (gettext ("Unrecognized debug section: %s\n"), print_name);
      result = 0;
    }

  return result;
}




static void
initialise_dumps_byname (void)
{
  struct dump_list_entry * cur;

  for (cur = dump_sects_byname; cur; cur = cur->next)
    {
      unsigned int i;
      bfd_boolean any = 0;

      for (i = 0; i < elf_header.e_shnum; i++)
 if ((strcmp ((((section_headers + i) == 
# 13390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 13390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<none>") : string_table == 
# 13390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
    ((void *)0) 
# 13390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
    ? gettext ("<no-name>") : ((section_headers + i)->sh_name >= string_table_length ? gettext ("<corrupt>") : string_table + (section_headers + i)->sh_name))), (cur->name)) == 0))
   {
     request_dump_bynumber (i, cur->type);
     any = 1;
   }

      if (!any)
 warn (gettext ("Section '%s' was not dumped because it does not exist!\n"),
       cur->name);
    }
}

static bfd_boolean
process_section_contents (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  bfd_boolean res = 1;

  if (! do_dump)
    return 1;

  initialise_dumps_byname ();

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && i < num_dump_sects;
       i++, section++)
    {




      if (dump_sects[i] & (1 << 0))
 {
   if (! dump_section_as_bytes (section, file, 0))
     res = 0;
 }

      if (dump_sects[i] & (1 << 4))
 {
   if (! dump_section_as_bytes (section, file, 1))
     res = 0;
 }

      if (dump_sects[i] & (1 << 3))
 {
   if (! dump_section_as_strings (section, file))
     res = 0;
 }

      if (dump_sects[i] & (1 << 2))
 {
   if (! display_debug_section (i, section, file))
     res = 0;
 }
    }



  while (i < num_dump_sects)
    {
      if (dump_sects[i])
 {
   warn (gettext ("Section %d was not dumped because it does not exist!\n"), i);
   res = 0;
 }
      i++;
    }

  return res;
}

static void
process_mips_fpe_exception (int mask)
{
  if (mask)
    {
      bfd_boolean first = 1;

      if (mask & 0x01)
 fputs ("INEX", 
# 13470 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 13470 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     ), first = 0;
      if (mask & 0x02)
 printf ("%sUFLO", first ? "" : "|"), first = 0;
      if (mask & 0x04)
 printf ("%sOFLO", first ? "" : "|"), first = 0;
      if (mask & 0x08)
 printf ("%sDIV0", first ? "" : "|"), first = 0;
      if (mask & 0x10)
 printf ("%sINVAL", first ? "" : "|");
    }
  else
    fputs ("0", 
# 13481 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 13481 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     );
}
# 13498 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
static unsigned char *
display_tag_value (signed int tag,
     unsigned char * p,
     const unsigned char * const end)
{
  unsigned long val;

  if (tag > 0)
    printf ("  Tag_unknown_%d: ", tag);

  if (p >= end)
    {
      warn (gettext ("<corrupt tag>\n"));
    }
  else if (tag & 1)
    {

      size_t maxlen = (end - p) - 1;

      putchar ('"');
      if (maxlen > 0)
 {
   print_symbol ((int) maxlen, (const char *) p);
   p += strnlen ((char *) p, maxlen) + 1;
 }
      else
 {
   printf (gettext ("<corrupt string tag>"));
   p = (unsigned char *) end;
 }
      printf ("\"\n");
    }
  else
    {
      unsigned int len;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("%ld (0x%lx)\n", val, val);
    }

  
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ((void) sizeof ((
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 p <= end
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 p <= end
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ; else __assert_fail (
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 "p <= end"
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 13539, __extension__ __PRETTY_FUNCTION__); }))
# 13539 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
  return p;
}



static unsigned char *
display_arc_attribute (unsigned char * p,
         const unsigned char * const end)
{
  unsigned int tag;
  unsigned int len;
  unsigned int val;

  tag = read_uleb128 (p, &len, end);
  p += len;

  switch (tag)
    {
    case Tag_ARC_PCS_config:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_PCS_config: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Absent/Non standard\n"));
   break;
 case 1:
   printf (gettext ("Bare metal/mwdt\n"));
   break;
 case 2:
   printf (gettext ("Bare metal/newlib\n"));
   break;
 case 3:
   printf (gettext ("Linux/uclibc\n"));
   break;
 case 4:
   printf (gettext ("Linux/glibc\n"));
   break;
 default:
   printf (gettext ("Unknown\n"));
   break;
 }
      break;

    case Tag_ARC_CPU_base:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_CPU_base: ");
      switch (val)
 {
 default:
 case 0:
   printf (gettext ("Absent\n"));
   break;
 case 1:
   printf ("ARC6xx\n");
   break;
 case 2:
   printf ("ARC7xx\n");
   break;
 case 3:
   printf ("ARCEM\n");
   break;
 case 4:
   printf ("ARCHS\n");
   break;
 }
      break;

    case Tag_ARC_CPU_variation:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_CPU_variation: ");
      switch (val)
 {
 default:
   if (val > 0 && val < 16)
       printf ("Core%d\n", val);
   else
       printf ("Unknown\n");
   break;

 case 0:
   printf (gettext ("Absent\n"));
   break;
 }
      break;

    case Tag_ARC_CPU_name:
      printf ("  Tag_ARC_CPU_name: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ABI_rf16:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_rf16: %s\n", val ? gettext ("yes") : gettext ("no"));
      break;

    case Tag_ARC_ABI_osver:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_osver: v%d\n", val);
      break;

    case Tag_ARC_ABI_pic:
    case Tag_ARC_ABI_sda:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf (tag == Tag_ARC_ABI_sda ? "  Tag_ARC_ABI_sda: "
       : "  Tag_ARC_ABI_pic: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Absent\n"));
   break;
 case 1:
   printf ("MWDT\n");
   break;
 case 2:
   printf ("GNU\n");
   break;
 default:
   printf (gettext ("Unknown\n"));
   break;
 }
      break;

    case Tag_ARC_ABI_tls:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_tls: %s\n", val ? "r25": "none");
      break;

    case Tag_ARC_ABI_enumsize:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_enumsize: %s\n", val ? gettext ("default") :
       gettext ("smallest"));
      break;

    case Tag_ARC_ABI_exceptions:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_exceptions: %s\n", val ? gettext ("OPTFP")
       : gettext ("default"));
      break;

    case Tag_ARC_ABI_double_size:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ABI_double_size: %d\n", val);
      break;

    case Tag_ARC_ISA_config:
      printf ("  Tag_ARC_ISA_config: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ISA_apex:
      printf ("  Tag_ARC_ISA_apex: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ISA_mpy_option:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ARC_ISA_mpy_option: %d\n", val);
      break;

    default:
      return display_tag_value (tag & 1, p, end);
    }

  return p;
}


typedef struct
{
  unsigned int tag;
  const char * name;

  unsigned int type;
  const char ** table;
} arm_attr_public_tag;

static const char * arm_attr_tag_CPU_arch[] =
  {"Pre-v4", "v4", "v4T", "v5T", "v5TE", "v5TEJ", "v6", "v6KZ", "v6T2",
   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8", "v8-R", "v8-M.baseline",
   "v8-M.mainline"};
static const char * arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
static const char * arm_attr_tag_THUMB_ISA_use[] =
  {"No", "Thumb-1", "Thumb-2", "Yes"};
static const char * arm_attr_tag_FP_arch[] =
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
   "FP for ARMv8", "FPv5/FP-D16 for ARMv8"};
static const char * arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
static const char * arm_attr_tag_Advanced_SIMD_arch[] =
  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8",
   "NEON for ARMv8.1"};
static const char * arm_attr_tag_PCS_config[] =
  {"None", "Bare platform", "Linux application", "Linux DSO", "PalmOS 2004",
   "PalmOS (reserved)", "SymbianOS 2004", "SymbianOS (reserved)"};
static const char * arm_attr_tag_ABI_PCS_R9_use[] =
  {"V6", "SB", "TLS", "Unused"};
static const char * arm_attr_tag_ABI_PCS_RW_data[] =
  {"Absolute", "PC-relative", "SB-relative", "None"};
static const char * arm_attr_tag_ABI_PCS_RO_data[] =
  {"Absolute", "PC-relative", "None"};
static const char * arm_attr_tag_ABI_PCS_GOT_use[] =
  {"None", "direct", "GOT-indirect"};
static const char * arm_attr_tag_ABI_PCS_wchar_t[] =
  {"None", "??? 1", "2", "??? 3", "4"};
static const char * arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_denormal[] =
  {"Unused", "Needed", "Sign only"};
static const char * arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_number_model[] =
  {"Unused", "Finite", "RTABI", "IEEE 754"};
static const char * arm_attr_tag_ABI_enum_size[] =
  {"Unused", "small", "int", "forced to int"};
static const char * arm_attr_tag_ABI_HardFP_use[] =
  {"As Tag_FP_arch", "SP only", "Reserved", "Deprecated"};
static const char * arm_attr_tag_ABI_VFP_args[] =
  {"AAPCS", "VFP registers", "custom", "compatible"};
static const char * arm_attr_tag_ABI_WMMX_args[] =
  {"AAPCS", "WMMX registers", "custom"};
static const char * arm_attr_tag_ABI_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Debug", "Aggressive Debug"};
static const char * arm_attr_tag_ABI_FP_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Accuracy", "Aggressive Accuracy"};
static const char * arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
static const char * arm_attr_tag_FP_HP_extension[] =
  {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_ABI_FP_16bit_format[] =
  {"None", "IEEE 754", "Alternative Format"};
static const char * arm_attr_tag_DSP_extension[] =
  {"Follow architecture", "Allowed"};
static const char * arm_attr_tag_MPextension_use[] =
  {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_DIV_use[] =
  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed",
    "Allowed in v7-A with integer division extension"};
static const char * arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_Virtualization_use[] =
  {"Not Allowed", "TrustZone", "Virtualization Extensions",
    "TrustZone and Virtualization Extensions"};
static const char * arm_attr_tag_MPextension_use_legacy[] =
  {"Not Allowed", "Allowed"};



static arm_attr_public_tag arm_attr_public_tags[] =
{
  {4, "CPU_raw_name", 1, 
# 13799 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 13799 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            },
  {5, "CPU_name", 1, 
# 13800 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 13800 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        },
  {6, "CPU_arch", 0x80 | (sizeof (arm_attr_tag_CPU_arch) / sizeof ((arm_attr_tag_CPU_arch)[0])), arm_attr_tag_CPU_arch},
  {7, "CPU_arch_profile", 0, 
# 13802 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 13802 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                },
  {8, "ARM_ISA_use", 0x80 | (sizeof (arm_attr_tag_ARM_ISA_use) / sizeof ((arm_attr_tag_ARM_ISA_use)[0])), arm_attr_tag_ARM_ISA_use},
  {9, "THUMB_ISA_use", 0x80 | (sizeof (arm_attr_tag_THUMB_ISA_use) / sizeof ((arm_attr_tag_THUMB_ISA_use)[0])), arm_attr_tag_THUMB_ISA_use},
  {10, "FP_arch", 0x80 | (sizeof (arm_attr_tag_FP_arch) / sizeof ((arm_attr_tag_FP_arch)[0])), arm_attr_tag_FP_arch},
  {11, "WMMX_arch", 0x80 | (sizeof (arm_attr_tag_WMMX_arch) / sizeof ((arm_attr_tag_WMMX_arch)[0])), arm_attr_tag_WMMX_arch},
  {12, "Advanced_SIMD_arch", 0x80 | (sizeof (arm_attr_tag_Advanced_SIMD_arch) / sizeof ((arm_attr_tag_Advanced_SIMD_arch)[0])), arm_attr_tag_Advanced_SIMD_arch},
  {13, "PCS_config", 0x80 | (sizeof (arm_attr_tag_PCS_config) / sizeof ((arm_attr_tag_PCS_config)[0])), arm_attr_tag_PCS_config},
  {14, "ABI_PCS_R9_use", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_R9_use) / sizeof ((arm_attr_tag_ABI_PCS_R9_use)[0])), arm_attr_tag_ABI_PCS_R9_use},
  {15, "ABI_PCS_RW_data", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_RW_data) / sizeof ((arm_attr_tag_ABI_PCS_RW_data)[0])), arm_attr_tag_ABI_PCS_RW_data},
  {16, "ABI_PCS_RO_data", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_RO_data) / sizeof ((arm_attr_tag_ABI_PCS_RO_data)[0])), arm_attr_tag_ABI_PCS_RO_data},
  {17, "ABI_PCS_GOT_use", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_GOT_use) / sizeof ((arm_attr_tag_ABI_PCS_GOT_use)[0])), arm_attr_tag_ABI_PCS_GOT_use},
  {18, "ABI_PCS_wchar_t", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_wchar_t) / sizeof ((arm_attr_tag_ABI_PCS_wchar_t)[0])), arm_attr_tag_ABI_PCS_wchar_t},
  {19, "ABI_FP_rounding", 0x80 | (sizeof (arm_attr_tag_ABI_FP_rounding) / sizeof ((arm_attr_tag_ABI_FP_rounding)[0])), arm_attr_tag_ABI_FP_rounding},
  {20, "ABI_FP_denormal", 0x80 | (sizeof (arm_attr_tag_ABI_FP_denormal) / sizeof ((arm_attr_tag_ABI_FP_denormal)[0])), arm_attr_tag_ABI_FP_denormal},
  {21, "ABI_FP_exceptions", 0x80 | (sizeof (arm_attr_tag_ABI_FP_exceptions) / sizeof ((arm_attr_tag_ABI_FP_exceptions)[0])), arm_attr_tag_ABI_FP_exceptions},
  {22, "ABI_FP_user_exceptions", 0x80 | (sizeof (arm_attr_tag_ABI_FP_user_exceptions) / sizeof ((arm_attr_tag_ABI_FP_user_exceptions)[0])), arm_attr_tag_ABI_FP_user_exceptions},
  {23, "ABI_FP_number_model", 0x80 | (sizeof (arm_attr_tag_ABI_FP_number_model) / sizeof ((arm_attr_tag_ABI_FP_number_model)[0])), arm_attr_tag_ABI_FP_number_model},
  {24, "ABI_align_needed", 0, 
# 13819 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0)
# 13819 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 },
  {25, "ABI_align_preserved", 0, 
# 13820 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                ((void *)0)
# 13820 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    },
  {26, "ABI_enum_size", 0x80 | (sizeof (arm_attr_tag_ABI_enum_size) / sizeof ((arm_attr_tag_ABI_enum_size)[0])), arm_attr_tag_ABI_enum_size},
  {27, "ABI_HardFP_use", 0x80 | (sizeof (arm_attr_tag_ABI_HardFP_use) / sizeof ((arm_attr_tag_ABI_HardFP_use)[0])), arm_attr_tag_ABI_HardFP_use},
  {28, "ABI_VFP_args", 0x80 | (sizeof (arm_attr_tag_ABI_VFP_args) / sizeof ((arm_attr_tag_ABI_VFP_args)[0])), arm_attr_tag_ABI_VFP_args},
  {29, "ABI_WMMX_args", 0x80 | (sizeof (arm_attr_tag_ABI_WMMX_args) / sizeof ((arm_attr_tag_ABI_WMMX_args)[0])), arm_attr_tag_ABI_WMMX_args},
  {30, "ABI_optimization_goals", 0x80 | (sizeof (arm_attr_tag_ABI_optimization_goals) / sizeof ((arm_attr_tag_ABI_optimization_goals)[0])), arm_attr_tag_ABI_optimization_goals},
  {31, "ABI_FP_optimization_goals", 0x80 | (sizeof (arm_attr_tag_ABI_FP_optimization_goals) / sizeof ((arm_attr_tag_ABI_FP_optimization_goals)[0])), arm_attr_tag_ABI_FP_optimization_goals},
  {32, "compatibility", 0, 
# 13827 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          ((void *)0)
# 13827 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              },
  {34, "CPU_unaligned_access", 0x80 | (sizeof (arm_attr_tag_CPU_unaligned_access) / sizeof ((arm_attr_tag_CPU_unaligned_access)[0])), arm_attr_tag_CPU_unaligned_access},
  {36, "FP_HP_extension", 0x80 | (sizeof (arm_attr_tag_FP_HP_extension) / sizeof ((arm_attr_tag_FP_HP_extension)[0])), arm_attr_tag_FP_HP_extension},
  {38, "ABI_FP_16bit_format", 0x80 | (sizeof (arm_attr_tag_ABI_FP_16bit_format) / sizeof ((arm_attr_tag_ABI_FP_16bit_format)[0])), arm_attr_tag_ABI_FP_16bit_format},
  {42, "MPextension_use", 0x80 | (sizeof (arm_attr_tag_MPextension_use) / sizeof ((arm_attr_tag_MPextension_use)[0])), arm_attr_tag_MPextension_use},
  {44, "DIV_use", 0x80 | (sizeof (arm_attr_tag_DIV_use) / sizeof ((arm_attr_tag_DIV_use)[0])), arm_attr_tag_DIV_use},
  {46, "DSP_extension", 0x80 | (sizeof (arm_attr_tag_DSP_extension) / sizeof ((arm_attr_tag_DSP_extension)[0])), arm_attr_tag_DSP_extension},
  {64, "nodefaults", 0, 
# 13834 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 13834 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           },
  {65, "also_compatible_with", 0, 
# 13835 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 13835 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     },
  {66, "T2EE_use", 0x80 | (sizeof (arm_attr_tag_T2EE_use) / sizeof ((arm_attr_tag_T2EE_use)[0])), arm_attr_tag_T2EE_use},
  {67, "conformance", 1, 
# 13837 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 13837 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            },
  {68, "Virtualization_use", 0x80 | (sizeof (arm_attr_tag_Virtualization_use) / sizeof ((arm_attr_tag_Virtualization_use)[0])), arm_attr_tag_Virtualization_use},
  {70, "MPextension_use_legacy", 0x80 | (sizeof (arm_attr_tag_MPextension_use_legacy) / sizeof ((arm_attr_tag_MPextension_use_legacy)[0])), arm_attr_tag_MPextension_use_legacy}
};


static unsigned char *
display_arm_attribute (unsigned char * p,
         const unsigned char * const end)
{
  unsigned int tag;
  unsigned int len;
  unsigned int val;
  arm_attr_public_tag * attr;
  unsigned i;
  unsigned int type;

  tag = read_uleb128 (p, &len, end);
  p += len;
  attr = 
# 13856 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 13856 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;
  for (i = 0; i < (sizeof (arm_attr_public_tags) / sizeof ((arm_attr_public_tags)[0])); i++)
    {
      if (arm_attr_public_tags[i].tag == tag)
 {
   attr = &arm_attr_public_tags[i];
   break;
 }
    }

  if (attr)
    {
      printf ("  Tag_%s: ", attr->name);
      switch (attr->type)
 {
 case 0:
   switch (tag)
     {
     case 7:
       val = read_uleb128 (p, &len, end);
       p += len;
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 'A': printf (gettext ("Application\n")); break;
  case 'R': printf (gettext ("Realtime\n")); break;
  case 'M': printf (gettext ("Microcontroller\n")); break;
  case 'S': printf (gettext ("Application or Realtime\n")); break;
  default: printf ("??? (%d)\n", val); break;
  }
       break;

     case 24:
       val = read_uleb128 (p, &len, end);
       p += len;
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 1: printf (gettext ("8-byte\n")); break;
  case 2: printf (gettext ("4-byte\n")); break;
  case 3: printf ("??? 3\n"); break;
  default:
    if (val <= 12)
      printf (gettext ("8-byte and up to %d-byte extended\n"),
       1 << val);
    else
      printf ("??? (%d)\n", val);
    break;
  }
       break;

     case 25:
       val = read_uleb128 (p, &len, end);
       p += len;
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 1: printf (gettext ("8-byte, except leaf SP\n")); break;
  case 2: printf (gettext ("8-byte\n")); break;
  case 3: printf ("??? 3\n"); break;
  default:
    if (val <= 12)
      printf (gettext ("8-byte and up to %d-byte extended\n"),
       1 << val);
    else
      printf ("??? (%d)\n", val);
    break;
  }
       break;

     case 32:
       {
  val = read_uleb128 (p, &len, end);
  p += len;
  printf (gettext ("flag = %d, vendor = "), val);
  if (p < end - 1)
    {
      size_t maxlen = (end - p) - 1;

      print_symbol ((int) maxlen, (const char *) p);
      p += strnlen ((char *) p, maxlen) + 1;
    }
  else
    {
      printf (gettext ("<corrupt>"));
      p = (unsigned char *) end;
    }
  putchar ('\n');
       }
       break;

     case 64:

       if (p < end)
  p++;
       printf (gettext ("True\n"));
       break;

     case 65:
       val = read_uleb128 (p, &len, end);
       p += len;
       if (val == 6 )
  {
    val = read_uleb128 (p, &len, end);
    p += len;
    if ((unsigned int) val >= (sizeof (arm_attr_tag_CPU_arch) / sizeof ((arm_attr_tag_CPU_arch)[0])))
      printf ("??? (%d)\n", val);
    else
      printf ("%s\n", arm_attr_tag_CPU_arch[val]);
  }
       else
  printf ("???\n");
       while (p < end && *(p++) != '\0' )
  ;
       break;

     default:
       printf (gettext ("<unknown: %d>\n"), tag);
       break;
     }
   return p;

 case 1:
   return display_tag_value (-1, p, end);
 case 2:
   return display_tag_value (0, p, end);

 default:
   
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ((void) sizeof ((
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  attr->type & 0x80
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ) ? 1 : 0), __extension__ ({ if (
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  attr->type & 0x80
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  ) ; else __assert_fail (
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  "attr->type & 0x80"
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 13984, __extension__ __PRETTY_FUNCTION__); }))
# 13984 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            ;
   val = read_uleb128 (p, &len, end);
   p += len;
   type = attr->type & 0x7f;
   if (val >= type)
     printf ("??? (%d)\n", val);
   else
     printf ("%s\n", attr->table[val]);
   return p;
 }
    }

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_gnu_attribute (unsigned char * p,
         unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const),
         const unsigned char * const end)
{
  int tag;
  unsigned int len;
  unsigned int val;

  tag = read_uleb128 (p, &len, end);
  p += len;



  if (tag == 32)
    {
      val = read_uleb128 (p, &len, end);
      p += len;

      printf (gettext ("flag = %d, vendor = "), val);
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   warn (gettext ("corrupt vendor attribute\n"));
 }
      else
 {
   if (p < end - 1)
     {
       size_t maxlen = (end - p) - 1;

       print_symbol ((int) maxlen, (const char *) p);
       p += strnlen ((char *) p, maxlen) + 1;
     }
   else
     {
       printf (gettext ("<corrupt>"));
       p = (unsigned char *) end;
     }
   putchar ('\n');
 }
      return p;
    }

  if ((tag & 2) == 0 && display_proc_gnu_attribute)
    return display_proc_gnu_attribute (p, tag, end);

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_power_gnu_attribute (unsigned char * p,
        unsigned int tag,
        const unsigned char * const end)
{
  unsigned int len;
  unsigned int val;

  if (tag == Tag_GNU_Power_ABI_FP)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_FP: ");
      if (len == 0)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }

      if (val > 15)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified hard/soft float, "));
   break;
 case 1:
   printf (gettext ("hard float, "));
   break;
 case 2:
   printf (gettext ("soft float, "));
   break;
 case 3:
   printf (gettext ("single-precision hard float, "));
   break;
 }

      switch (val & 0xC)
 {
 case 0:
   printf (gettext ("unspecified long double\n"));
   break;
 case 4:
   printf (gettext ("128-bit IBM long double\n"));
   break;
 case 8:
   printf (gettext ("64-bit long double\n"));
   break;
 case 12:
   printf (gettext ("128-bit IEEE long double\n"));
   break;
 }
      return p;
    }

  if (tag == Tag_GNU_Power_ABI_Vector)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_Vector: ");
      if (len == 0)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }

      if (val > 3)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified\n"));
   break;
 case 1:
   printf (gettext ("generic\n"));
   break;
 case 2:
   printf ("AltiVec\n");
   break;
 case 3:
   printf ("SPE\n");
   break;
 }
      return p;
    }

  if (tag == Tag_GNU_Power_ABI_Struct_Return)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
      if (len == 0)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }

      if (val > 2)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified\n"));
   break;
 case 1:
   printf ("r3/r4\n");
   break;
 case 2:
   printf (gettext ("memory\n"));
   break;
 case 3:
   printf ("???\n");
   break;
 }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_s390_gnu_attribute (unsigned char * p,
       unsigned int tag,
       const unsigned char * const end)
{
  unsigned int len;
  int val;

  if (tag == Tag_GNU_S390_ABI_Vector)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_S390_ABI_Vector: ");

      switch (val)
 {
 case 0:
   printf (gettext ("any\n"));
   break;
 case 1:
   printf (gettext ("software\n"));
   break;
 case 2:
   printf (gettext ("hardware\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;
   }

  return display_tag_value (tag & 1, p, end);
}

static void
display_sparc_hwcaps (unsigned int mask)
{
  if (mask)
    {
      bfd_boolean first = 1;

      if (mask & 0x00000001)
 fputs ("mul32", 
# 14215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                stdout
# 14215 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ), first = 0;
      if (mask & 0x00000002)
 printf ("%sdiv32", first ? "" : "|"), first = 0;
      if (mask & 0x00000004)
 printf ("%sfsmuld", first ? "" : "|"), first = 0;
      if (mask & 0x00000008)
 printf ("%sv8plus", first ? "" : "|"), first = 0;
      if (mask & 0x00000010)
 printf ("%spopc", first ? "" : "|"), first = 0;
      if (mask & 0x00000020)
 printf ("%svis", first ? "" : "|"), first = 0;
      if (mask & 0x00000040)
 printf ("%svis2", first ? "" : "|"), first = 0;
      if (mask & 0x00000080)
 printf ("%sASIBlkInit", first ? "" : "|"), first = 0;
      if (mask & 0x00000100)
 printf ("%sfmaf", first ? "" : "|"), first = 0;
      if (mask & 0x00000400)
 printf ("%svis3", first ? "" : "|"), first = 0;
      if (mask & 0x00000800)
 printf ("%shpc", first ? "" : "|"), first = 0;
      if (mask & 0x00001000)
 printf ("%srandom", first ? "" : "|"), first = 0;
      if (mask & 0x00002000)
 printf ("%strans", first ? "" : "|"), first = 0;
      if (mask & 0x00004000)
 printf ("%sfjfmau", first ? "" : "|"), first = 0;
      if (mask & 0x00008000)
 printf ("%sima", first ? "" : "|"), first = 0;
      if (mask & 0x00010000)
 printf ("%scspare", first ? "" : "|"), first = 0;
    }
  else
    fputc ('0', 
# 14248 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 14248 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     );
  fputc ('\n', 
# 14249 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              stdout
# 14249 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    );
}

static void
display_sparc_hwcaps2 (unsigned int mask)
{
  if (mask)
    {
      bfd_boolean first = 1;

      if (mask & 0x00000001)
 fputs ("fjathplus", 
# 14260 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    stdout
# 14260 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          ), first = 0;
      if (mask & 0x00000002)
 printf ("%svis3b", first ? "" : "|"), first = 0;
      if (mask & 0x00000004)
 printf ("%sadp", first ? "" : "|"), first = 0;
      if (mask & 0x00000008)
 printf ("%ssparc5", first ? "" : "|"), first = 0;
      if (mask & 0x00000010)
 printf ("%smwait", first ? "" : "|"), first = 0;
      if (mask & 0x00000020)
 printf ("%sxmpmul", first ? "" : "|"), first = 0;
      if (mask & 0x00000040)
 printf ("%sxmont2", first ? "" : "|"), first = 0;
      if (mask & 0x00000080)
 printf ("%snsec", first ? "" : "|"), first = 0;
      if (mask & 0x00001000)
 printf ("%sfjathhpc", first ? "" : "|"), first = 0;
      if (mask & 0x00002000)
 printf ("%sfjdes", first ? "" : "|"), first = 0;
      if (mask & 0x00010000)
 printf ("%sfjaes", first ? "" : "|"), first = 0;
    }
  else
    fputc ('0', 
# 14283 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 14283 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     );
  fputc ('\n', 
# 14284 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              stdout
# 14284 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    );
}

static unsigned char *
display_sparc_gnu_attribute (unsigned char * p,
        unsigned int tag,
        const unsigned char * const end)
{
  unsigned int len;
  int val;

  if (tag == Tag_GNU_Sparc_HWCAPS)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Sparc_HWCAPS: ");
      display_sparc_hwcaps (val);
      return p;
    }
  if (tag == Tag_GNU_Sparc_HWCAPS2)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Sparc_HWCAPS2: ");
      display_sparc_hwcaps2 (val);
      return p;
    }

  return display_tag_value (tag, p, end);
}

static void
print_mips_fp_abi_value (unsigned int val)
{
  switch (val)
    {
    case Val_GNU_MIPS_ABI_FP_ANY:
      printf (gettext ("Hard or soft float\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_DOUBLE:
      printf (gettext ("Hard float (double precision)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_SINGLE:
      printf (gettext ("Hard float (single precision)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_SOFT:
      printf (gettext ("Soft float\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_OLD_64:
      printf (gettext ("Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_XX:
      printf (gettext ("Hard float (32-bit CPU, Any FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_64:
      printf (gettext ("Hard float (32-bit CPU, 64-bit FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_64A:
      printf (gettext ("Hard float compat (32-bit CPU, 64-bit FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_NAN2008:
      printf (gettext ("NaN 2008 compatibility\n"));
      break;
    default:
      printf ("??? (%d)\n", val);
      break;
    }
}

static unsigned char *
display_mips_gnu_attribute (unsigned char * p,
       unsigned int tag,
       const unsigned char * const end)
{
  if (tag == Tag_GNU_MIPS_ABI_FP)
    {
      unsigned int len;
      unsigned int val;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_MIPS_ABI_FP: ");

      print_mips_fp_abi_value (val);

      return p;
   }

  if (tag == Tag_GNU_MIPS_ABI_MSA)
    {
      unsigned int len;
      unsigned int val;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_MIPS_ABI_MSA: ");

      switch (val)
 {
 case Val_GNU_MIPS_ABI_MSA_ANY:
   printf (gettext ("Any MSA or not\n"));
   break;
 case Val_GNU_MIPS_ABI_MSA_128:
   printf (gettext ("128-bit MSA\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_tic6x_attribute (unsigned char * p,
    const unsigned char * const end)
{
  unsigned int tag;
  unsigned int len;
  int val;

  tag = read_uleb128 (p, &len, end);
  p += len;

  switch (tag)
    {
    case Tag_ISA:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ISA: ");

      switch (val)
 {
 case C6XABI_Tag_ISA_none:
   printf (gettext ("None\n"));
   break;
 case C6XABI_Tag_ISA_C62X:
   printf ("C62x\n");
   break;
 case C6XABI_Tag_ISA_C67X:
   printf ("C67x\n");
   break;
 case C6XABI_Tag_ISA_C67XP:
   printf ("C67x+\n");
   break;
 case C6XABI_Tag_ISA_C64X:
   printf ("C64x\n");
   break;
 case C6XABI_Tag_ISA_C64XP:
   printf ("C64x+\n");
   break;
 case C6XABI_Tag_ISA_C674X:
   printf ("C674x\n");
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_wchar_t:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_wchar_t: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Not used\n"));
   break;
 case 1:
   printf (gettext ("2 bytes\n"));
   break;
 case 2:
   printf (gettext ("4 bytes\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_stack_align_needed:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_stack_align_needed: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_stack_align_preserved:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_stack_align_preserved: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_DSBT:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_DSBT: ");
      switch (val)
 {
 case 0:
   printf (gettext ("DSBT addressing not used\n"));
   break;
 case 1:
   printf (gettext ("DSBT addressing used\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_PID:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_PID: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Data addressing position-dependent\n"));
   break;
 case 1:
   printf (gettext ("Data addressing position-independent, GOT near DP\n"));
   break;
 case 2:
   printf (gettext ("Data addressing position-independent, GOT far from DP\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_PIC:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_PIC: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Code addressing position-dependent\n"));
   break;
 case 1:
   printf (gettext ("Code addressing position-independent\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_array_object_alignment:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_array_object_alignment: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("4-byte\n"));
   break;
 case 2:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_array_object_align_expected:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_array_object_align_expected: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("4-byte\n"));
   break;
 case 2:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_compatibility:
      {
 val = read_uleb128 (p, &len, end);
 p += len;
 printf ("  Tag_ABI_compatibility: ");
 printf (gettext ("flag = %d, vendor = "), val);
 if (p < end - 1)
   {
     size_t maxlen = (end - p) - 1;

     print_symbol ((int) maxlen, (const char *) p);
     p += strnlen ((char *) p, maxlen) + 1;
   }
 else
   {
     printf (gettext ("<corrupt>"));
     p = (unsigned char *) end;
   }
 putchar ('\n');
 return p;
      }

    case Tag_ABI_conformance:
      {
 printf ("  Tag_ABI_conformance: \"");
 if (p < end - 1)
   {
     size_t maxlen = (end - p) - 1;

     print_symbol ((int) maxlen, (const char *) p);
     p += strnlen ((char *) p, maxlen) + 1;
   }
 else
   {
     printf (gettext ("<corrupt>"));
     p = (unsigned char *) end;
   }
 printf ("\"\n");
 return p;
      }
    }

  return display_tag_value (tag, p, end);
}

static void
display_raw_attribute (unsigned char * p, unsigned char const * const end)
{
  unsigned long addr = 0;
  size_t bytes = end - p;

  
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ((void) sizeof ((
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 end > p
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 end > p
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ; else __assert_fail (
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 "end > p"
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 14653, __extension__ __PRETTY_FUNCTION__); }))
# 14653 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 ;
  while (bytes)
    {
      int j;
      int k;
      int lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", addr);

      for (j = 0; j < 16; j++)
 {
   if (j < lbytes)
     printf ("%2.2x", p[j]);
   else
     printf ("  ");

   if ((j & 3) == 3)
     printf (" ");
 }

      for (j = 0; j < lbytes; j++)
 {
   k = p[j];
   if (k >= ' ' && k < 0x7f)
     printf ("%c", k);
   else
     printf (".");
 }

      putchar ('\n');

      p += lbytes;
      bytes -= lbytes;
      addr += lbytes;
    }

  putchar ('\n');
}

static unsigned char *
display_msp430x_attribute (unsigned char * p,
      const unsigned char * const end)
{
  unsigned int len;
  unsigned int val;
  unsigned int tag;

  tag = read_uleb128 (p, & len, end);
  p += len;

  switch (tag)
    {
    case 4:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ISA: ");
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("MSP430\n")); break;
 case 2: printf (gettext ("MSP430X\n")); break;
 default: printf ("??? (%d)\n", val); break;
 }
      break;

    case 6:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_Code_Model: ");
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("Small\n")); break;
 case 2: printf (gettext ("Large\n")); break;
 default: printf ("??? (%d)\n", val); break;
 }
      break;

    case 8:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_Data_Model: ");
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("Small\n")); break;
 case 2: printf (gettext ("Large\n")); break;
 case 3: printf (gettext ("Restricted Large\n")); break;
 default: printf ("??? (%d)\n", val); break;
 }
      break;

    default:
      printf (gettext ("  <unknown tag %d>: "), tag);

      if (tag & 1)
 {
   putchar ('"');
   if (p < end - 1)
     {
       size_t maxlen = (end - p) - 1;

       print_symbol ((int) maxlen, (const char *) p);
       p += strnlen ((char *) p, maxlen) + 1;
     }
   else
     {
       printf (gettext ("<corrupt>"));
       p = (unsigned char *) end;
     }
   printf ("\"\n");
 }
      else
 {
   val = read_uleb128 (p, &len, end);
   p += len;
   printf ("%d (0x%x)\n", val, val);
 }
      break;
   }

  
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ((void) sizeof ((
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 p <= end
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 p <= end
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 ) ; else __assert_fail (
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
 "p <= end"
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
 , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 14774, __extension__ __PRETTY_FUNCTION__); }))
# 14774 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  ;
  return p;
}

static bfd_boolean
process_attributes (FILE * file,
      const char * public_name,
      unsigned int proc_type,
      unsigned char * (* display_pub_attribute) (unsigned char *, const unsigned char * const),
      unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const))
{
  Elf_Internal_Shdr * sect;
  unsigned i;
  bfd_boolean res = 1;


  for (i = 0, sect = section_headers;
       i < elf_header.e_shnum;
       i++, sect++)
    {
      unsigned char * contents;
      unsigned char * p;

      if (sect->sh_type != proc_type && sect->sh_type != 0x6ffffff5)
 continue;

      contents = (unsigned char *) get_data (
# 14800 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 14800 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                , file, sect->sh_offset, 1,
                                             sect->sh_size, gettext ("attributes"));
      if (contents == 
# 14802 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                     ((void *)0)
# 14802 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         )
 {
   res = 0;
   continue;
 }

      p = contents;


      if (*p != 'A')
 {
   printf (gettext ("Unknown attributes version '%c'(%d) - expecting 'A'\n"), *p, *p);
   res = 0;
 }
      else
 {
   bfd_vma section_len;

   section_len = sect->sh_size - 1;
   p++;

   while (section_len > 0)
     {
       bfd_vma attr_len;
       unsigned int namelen;
       bfd_boolean public_section;
       bfd_boolean gnu_section;

       if (section_len <= 4)
  {
    error (gettext ("Tag section ends prematurely\n"));
    res = 0;
    break;
  }
       attr_len = byte_get (p, 4);
       p += 4;

       if (attr_len > section_len)
  {
    error (gettext ("Bad attribute length (%u > %u)\n"),
     (unsigned) attr_len, (unsigned) section_len);
    attr_len = section_len;
    res = 0;
  }

       else if (attr_len < 5)
  {
    error (gettext ("Attribute length of %u is too small\n"), (unsigned) attr_len);
    res = 0;
    break;
  }

       section_len -= attr_len;
       attr_len -= 4;

       namelen = strnlen ((char *) p, attr_len) + 1;
       if (namelen == 0 || namelen >= attr_len)
  {
    error (gettext ("Corrupt attribute section name\n"));
    res = 0;
    break;
  }

       printf (gettext ("Attribute Section: "));
       print_symbol (0x7fffffff, (const char *) p);
       putchar ('\n');

       if (public_name && (strcmp (((char *) p), (public_name)) == 0))
  public_section = 1;
       else
  public_section = 0;

       if ((strcmp (((char *) p), ("gnu")) == 0))
  gnu_section = 1;
       else
  gnu_section = 0;

       p += namelen;
       attr_len -= namelen;

       while (attr_len > 0 && p < contents + sect->sh_size)
  {
    int tag;
    int val;
    bfd_vma size;
    unsigned char * end;


    if (attr_len < 6)
      {
        error (gettext ("Unused bytes at end of section\n"));
        res = 0;
        section_len = 0;
        break;
      }

    tag = *(p++);
    size = byte_get (p, 4);
    if (size > attr_len)
      {
        error (gettext ("Bad subsection length (%u > %u)\n"),
         (unsigned) size, (unsigned) attr_len);
        res = 0;
        size = attr_len;
      }

    if (size < 6)
      {
        error (gettext ("Bad subsection length (%u < 6)\n"),
         (unsigned) size);
        res = 0;
        section_len = 0;
        break;
      }

    attr_len -= size;
    end = p + size - 1;
    
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
   ((void) sizeof ((
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
   end <= contents + sect->sh_size
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
   end <= contents + sect->sh_size
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
   ) ; else __assert_fail (
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
   "end <= contents + sect->sh_size"
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
   , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 14919, __extension__ __PRETTY_FUNCTION__); }))
# 14919 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           ;
    p += 4;

    switch (tag)
      {
      case 1:
        printf (gettext ("File Attributes\n"));
        break;
      case 2:
        printf (gettext ("Section Attributes:"));
        goto do_numlist;
      case 3:
        printf (gettext ("Symbol Attributes:"));

      do_numlist:
        for (;;)
   {
     unsigned int j;

     val = read_uleb128 (p, &j, end);
     p += j;
     if (val == 0)
       break;
     printf (" %d", val);
   }
        printf ("\n");
        break;
      default:
        printf (gettext ("Unknown tag: %d\n"), tag);
        public_section = 0;
        break;
      }

    if (public_section && display_pub_attribute != 
# 14952 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                  ((void *)0)
# 14952 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                      )
      {
        while (p < end)
   p = display_pub_attribute (p, end);
        
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void) sizeof ((
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       p == end
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       p == end
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ) ; else __assert_fail (
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       "p == end"
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 14956, __extension__ __PRETTY_FUNCTION__); }))
# 14956 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
      }
    else if (gnu_section && display_proc_gnu_attribute != 
# 14958 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                         ((void *)0)
# 14958 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                             )
      {
        while (p < end)
   p = display_gnu_attribute (p,
         display_proc_gnu_attribute,
         end);
        
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void) sizeof ((
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       p == end
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       p == end
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ) ; else __assert_fail (
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       "p == end"
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 14964, __extension__ __PRETTY_FUNCTION__); }))
# 14964 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
      }
    else if (p < end)
      {
        printf (gettext ("  Unknown attribute:\n"));
        display_raw_attribute (p, end);
        p = end;
      }
    else
      attr_len = 0;
  }
     }
 }

      free (contents);
    }

  return res;
}






static bfd_vma
print_mips_got_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr,
        unsigned char * data_end)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (addr < pltgot + 0xfff0)
    printf ("%6d(gp)", (int) (addr - pltgot - 0x7ff0));
  else
    printf ("%10s", "");
  printf (" ");
  if (data == 
# 15001 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 15001 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<unknown>"));
  else
    {
      bfd_vma entry;
      unsigned char * from = data + addr - pltgot;

      if (from + (is_32bit_elf ? 4 : 8) > data_end)
 {
   warn (gettext ("MIPS GOT entry extends beyond the end of available data\n"));
   printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<corrupt>"));
   return (bfd_vma) -1;
 }
      else
 {
   entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
   print_vma (entry, LONG_HEX);
 }
    }
  return addr + (is_32bit_elf ? 4 : 8);
}





static bfd_vma
print_mips_pltgot_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (data == 
# 15033 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 15033 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<unknown>"));
  else
    {
      bfd_vma entry;

      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
      print_vma (entry, LONG_HEX);
    }
  return addr + (is_32bit_elf ? 4 : 8);
}

static void
print_mips_ases (unsigned int mask)
{
  if (mask & 0x00000001)
    fputs ("\n\tDSP ASE", 
# 15049 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15049 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
  if (mask & 0x00000002)
    fputs ("\n\tDSP R2 ASE", 
# 15051 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            stdout
# 15051 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  );
  if (mask & 0x00002000)
    fputs ("\n\tDSP R3 ASE", 
# 15053 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            stdout
# 15053 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  );
  if (mask & 0x00000004)
    fputs ("\n\tEnhanced VA Scheme", 
# 15055 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    stdout
# 15055 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          );
  if (mask & 0x00000008)
    fputs ("\n\tMCU (MicroController) ASE", 
# 15057 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           stdout
# 15057 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                 );
  if (mask & 0x00000010)
    fputs ("\n\tMDMX ASE", 
# 15059 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15059 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
  if (mask & 0x00000020)
    fputs ("\n\tMIPS-3D ASE", 
# 15061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15061 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
  if (mask & 0x00000040)
    fputs ("\n\tMT ASE", 
# 15063 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15063 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
  if (mask & 0x00000080)
    fputs ("\n\tSmartMIPS ASE", 
# 15065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               stdout
# 15065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     );
  if (mask & 0x00000100)
    fputs ("\n\tVZ ASE", 
# 15067 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15067 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
  if (mask & 0x00000200)
    fputs ("\n\tMSA ASE", 
# 15069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
  if (mask & 0x00000400)
    fputs ("\n\tMIPS16 ASE", 
# 15071 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            stdout
# 15071 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  );
  if (mask & 0x00000800)
    fputs ("\n\tMICROMIPS ASE", 
# 15073 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               stdout
# 15073 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     );
  if (mask & 0x00001000)
    fputs ("\n\tXPA ASE", 
# 15075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
  if (mask & 0x00004000)
    fputs ("\n\tMIPS16e2 ASE", 
# 15077 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              stdout
# 15077 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                    );
  if (mask == 0)
    fprintf (
# 15079 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            stdout
# 15079 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  , "\n\t%s", gettext ("None"));
  else if ((mask & ~0x00007fff) != 0)
    fprintf (
# 15081 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            stdout
# 15081 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  , "\n\t%s (%x)", gettext ("Unknown"), mask & ~0x00007fff);
}

static void
print_mips_isa_ext (unsigned int isa_ext)
{
  switch (isa_ext)
    {
    case 0:
      fputs (gettext ("None"), 
# 15090 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15090 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
      break;
    case 1:
      fputs ("RMI XLR", 
# 15093 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15093 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
      break;
    case 19:
      fputs ("Cavium Networks Octeon3", 
# 15096 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       stdout
# 15096 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             );
      break;
    case 2:
      fputs ("Cavium Networks Octeon2", 
# 15099 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       stdout
# 15099 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             );
      break;
    case 3:
      fputs ("Cavium Networks OcteonP", 
# 15102 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       stdout
# 15102 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             );
      break;
    case 4:
      fputs ("Loongson 3A", 
# 15105 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           stdout
# 15105 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 );
      break;
    case 5:
      fputs ("Cavium Networks Octeon", 
# 15108 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      stdout
# 15108 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            );
      break;
    case 6:
      fputs ("Toshiba R5900", 
# 15111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15111 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
      break;
    case 7:
      fputs ("MIPS R4650", 
# 15114 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15114 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
      break;
    case 8:
      fputs ("LSI R4010", 
# 15117 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15117 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
      break;
    case 9:
      fputs ("NEC VR4100", 
# 15120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
      break;
    case 10:
      fputs ("Toshiba R3900", 
# 15123 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15123 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
      break;
    case 11:
      fputs ("MIPS R10000", 
# 15126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           stdout
# 15126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 );
      break;
    case 12:
      fputs ("Broadcom SB-1", 
# 15129 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15129 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
      break;
    case 13:
      fputs ("NEC VR4111/VR4181", 
# 15132 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 stdout
# 15132 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                       );
      break;
    case 14:
      fputs ("NEC VR4120", 
# 15135 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15135 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
      break;
    case 15:
      fputs ("NEC VR5400", 
# 15138 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15138 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
      break;
    case 16:
      fputs ("NEC VR5500", 
# 15141 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15141 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
      break;
    case 17:
      fputs ("ST Microelectronics Loongson 2E", 
# 15144 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               stdout
# 15144 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                     );
      break;
    case 18:
      fputs ("ST Microelectronics Loongson 2F", 
# 15147 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               stdout
# 15147 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                     );
      break;
    case 20:
      fputs ("Imagination interAptiv MR2", 
# 15150 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                          stdout
# 15150 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                );
      break;
    default:
      fprintf (
# 15153 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              stdout
# 15153 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    , "%s (%d)", gettext ("Unknown"), isa_ext);
    }
}

static signed int
get_mips_reg_size (int reg_size)
{
  return (reg_size == 0x00) ? 0
  : (reg_size == 0x01) ? 32
  : (reg_size == 0x02) ? 64
  : (reg_size == 0x03) ? 128
  : -1;
}

static bfd_boolean
process_mips_specific (FILE * file)
{
  Elf_Internal_Dyn * entry;
  Elf_Internal_Shdr *sect = 
# 15171 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 15171 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;
  size_t liblist_offset = 0;
  size_t liblistno = 0;
  size_t conflictsno = 0;
  size_t options_offset = 0;
  size_t conflicts_offset = 0;
  size_t pltrelsz = 0;
  size_t pltrel = 0;
  bfd_vma pltgot = 0;
  bfd_vma mips_pltgot = 0;
  bfd_vma jmprel = 0;
  bfd_vma local_gotno = 0;
  bfd_vma gotsym = 0;
  bfd_vma symtabno = 0;
  bfd_boolean res = 1;

  if (! process_attributes (file, 
# 15187 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 15187 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     , 0x6ffffff5, 
# 15187 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                           ((void *)0)
# 15187 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                               ,
       display_mips_gnu_attribute))
    res = 0;

  sect = find_section (".MIPS.abiflags");

  if (sect != 
# 15193 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 15193 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    {
      Elf_External_ABIFlags_v0 *abiflags_ext;
      Elf_Internal_ABIFlags_v0 abiflags_in;

      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)
 {
   error (gettext ("Corrupt MIPS ABI Flags section.\n"));
   res = 0;
 }
      else
 {
   abiflags_ext = get_data (
# 15205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 15205 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               , file, sect->sh_offset, 1,
       sect->sh_size, gettext ("MIPS ABI Flags section"));
   if (abiflags_ext)
     {
       abiflags_in.version = byte_get (abiflags_ext->version, sizeof (abiflags_ext->version));
       abiflags_in.isa_level = byte_get (abiflags_ext->isa_level, sizeof (abiflags_ext->isa_level));
       abiflags_in.isa_rev = byte_get (abiflags_ext->isa_rev, sizeof (abiflags_ext->isa_rev));
       abiflags_in.gpr_size = byte_get (abiflags_ext->gpr_size, sizeof (abiflags_ext->gpr_size));
       abiflags_in.cpr1_size = byte_get (abiflags_ext->cpr1_size, sizeof (abiflags_ext->cpr1_size));
       abiflags_in.cpr2_size = byte_get (abiflags_ext->cpr2_size, sizeof (abiflags_ext->cpr2_size));
       abiflags_in.fp_abi = byte_get (abiflags_ext->fp_abi, sizeof (abiflags_ext->fp_abi));
       abiflags_in.isa_ext = byte_get (abiflags_ext->isa_ext, sizeof (abiflags_ext->isa_ext));
       abiflags_in.ases = byte_get (abiflags_ext->ases, sizeof (abiflags_ext->ases));
       abiflags_in.flags1 = byte_get (abiflags_ext->flags1, sizeof (abiflags_ext->flags1));
       abiflags_in.flags2 = byte_get (abiflags_ext->flags2, sizeof (abiflags_ext->flags2));

       printf ("\nMIPS ABI Flags Version: %d\n", abiflags_in.version);
       printf ("\nISA: MIPS%d", abiflags_in.isa_level);
       if (abiflags_in.isa_rev > 1)
  printf ("r%d", abiflags_in.isa_rev);
       printf ("\nGPR size: %d",
        get_mips_reg_size (abiflags_in.gpr_size));
       printf ("\nCPR1 size: %d",
        get_mips_reg_size (abiflags_in.cpr1_size));
       printf ("\nCPR2 size: %d",
        get_mips_reg_size (abiflags_in.cpr2_size));
       fputs ("\nFP ABI: ", 
# 15231 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           stdout
# 15231 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 );
       print_mips_fp_abi_value (abiflags_in.fp_abi);
       fputs ("ISA Extension: ", 
# 15233 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                stdout
# 15233 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                      );
       print_mips_isa_ext (abiflags_in.isa_ext);
       fputs ("\nASEs:", 
# 15235 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15235 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
       print_mips_ases (abiflags_in.ases);
       printf ("\nFLAGS 1: %8.8lx", abiflags_in.flags1);
       printf ("\nFLAGS 2: %8.8lx", abiflags_in.flags2);
       fputc ('\n', 
# 15239 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 15239 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );
       free (abiflags_ext);
     }
 }
    }


  if (dynamic_section == 
# 15246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
# 15246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            )
    {

      sect = find_section (".got");
      if (sect != 
# 15250 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 15250 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   unsigned char *data_end;
   unsigned char *data;
   bfd_vma ent, end;
   int addr_size;

   pltgot = sect->sh_addr;

   ent = pltgot;
   addr_size = (is_32bit_elf ? 4 : 8);
   end = pltgot + sect->sh_size;

   data = (unsigned char *) get_data (
# 15263 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                     ((void *)0)
# 15263 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         , file, sect->sh_offset,
          end - pltgot, 1,
          gettext ("Global Offset Table data"));

   data_end = data + (end - pltgot);

   printf (gettext ("\nStatic GOT:\n"));
   printf (gettext (" Canonical gp value: "));
   print_vma (ent + 0x7ff0, LONG_HEX);
   printf ("\n\n");







   if (data
       && data + ent - pltgot + addr_size <= data_end
       && byte_get (data + ent - pltgot, addr_size) == 0)
     {
       printf (gettext (" Reserved entries:\n"));
       printf (gettext ("  %*s %10s %*s\n"),
        addr_size * 2, gettext ("Address"), gettext ("Access"),
        addr_size * 2, gettext ("Value"));
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf ("\n");
       if (ent == (bfd_vma) -1)
  goto sgot_print_fail;







       if (data
    && data + ent - pltgot + addr_size <= data_end
    && (byte_get (data + ent - pltgot, addr_size)
        >> (addr_size * 8 - 1)) != 0)
  {
    ent = print_mips_got_entry (data, pltgot, ent, data_end);
    printf ("\n");
    if (ent == (bfd_vma) -1)
      goto sgot_print_fail;
  }
       printf ("\n");
     }

   if (data != 
# 15312 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0) 
# 15312 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   && ent < end)
     {
       printf (gettext (" Local entries:\n"));
       printf ("  %*s %10s %*s\n",
        addr_size * 2, gettext ("Address"), gettext ("Access"),
        addr_size * 2, gettext ("Value"));
       while (ent < end)
  {
    ent = print_mips_got_entry (data, pltgot, ent, data_end);
    printf ("\n");
    if (ent == (bfd_vma) -1)
      goto sgot_print_fail;
  }
       printf ("\n");
     }

 sgot_print_fail:
   if (data)
     free (data);
 }
      return res;
    }

  for (entry = dynamic_section;

       entry < dynamic_section + dynamic_nent && entry->d_tag != 0;
       ++entry)
    switch (entry->d_tag)
      {
      case 0x70000009:
 liblist_offset
   = offset_from_vma (file, entry->d_un.d_val,
        liblistno * sizeof (Elf32_External_Lib));
 break;
      case 0x70000010:
 liblistno = entry->d_un.d_val;
 break;
      case 0x70000029:
 options_offset = offset_from_vma (file, entry->d_un.d_val, 0);
 break;
      case 0x70000008:
 conflicts_offset
   = offset_from_vma (file, entry->d_un.d_val,
        conflictsno * sizeof (Elf32_External_Conflict));
 break;
      case 0x7000000b:
 conflictsno = entry->d_un.d_val;
 break;
      case 3:
 pltgot = entry->d_un.d_ptr;
 break;
      case 0x7000000a:
 local_gotno = entry->d_un.d_val;
 break;
      case 0x70000013:
 gotsym = entry->d_un.d_val;
 break;
      case 0x70000011:
 symtabno = entry->d_un.d_val;
 break;
      case 0x70000032:
 mips_pltgot = entry->d_un.d_ptr;
 break;
      case 20:
 pltrel = entry->d_un.d_val;
 break;
      case 2:
 pltrelsz = entry->d_un.d_val;
 break;
      case 23:
 jmprel = entry->d_un.d_ptr;
 break;
      default:
 break;
      }

  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)
    {
      Elf32_External_Lib * elib;
      size_t cnt;

      elib = (Elf32_External_Lib *) get_data (
# 15393 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                             ((void *)0)
# 15393 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                 , file, liblist_offset,
                                              liblistno,
                                              sizeof (Elf32_External_Lib),
                                              gettext ("liblist section data"));
      if (elib)
 {
   printf (gettext ("\nSection '.liblist' contains %lu entries:\n"),
    (unsigned long) liblistno);
   fputs (gettext ("     Library              Time Stamp          Checksum   Version Flags\n"),
   
# 15402 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
  stdout
# 15402 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
        );

   for (cnt = 0; cnt < liblistno; ++cnt)
     {
       Elf32_Lib liblist;
       time_t atime;
       char timebuf[128];
       struct tm * tmp;

       liblist.l_name = byte_get (elib[cnt].l_name, sizeof (elib[cnt].l_name));
       atime = byte_get (elib[cnt].l_time_stamp, sizeof (elib[cnt].l_time_stamp));
       liblist.l_checksum = byte_get (elib[cnt].l_checksum, sizeof (elib[cnt].l_checksum));
       liblist.l_version = byte_get (elib[cnt].l_version, sizeof (elib[cnt].l_version));
       liblist.l_flags = byte_get (elib[cnt].l_flags, sizeof (elib[cnt].l_flags));

       tmp = gmtime (&atime);
       snprintf (timebuf, sizeof (timebuf),
   "%04u-%02u-%02uT%02u:%02u:%02u",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

       printf ("%3lu: ", (unsigned long) cnt);
       if (((dynamic_strings != 
# 15424 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 15424 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ) && (liblist.l_name < dynamic_strings_length)))
  print_symbol (20, (dynamic_strings + liblist.l_name));
       else
  printf (gettext ("<corrupt: %9ld>"), liblist.l_name);
       printf (" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
        liblist.l_version);

       if (liblist.l_flags == 0)
  puts (gettext (" NONE"));
       else
  {
    static const struct
    {
      const char * name;
      int bit;
    }
    l_flags_vals[] =
    {
      { " EXACT_MATCH", 0x00000001 },
      { " IGNORE_INT_VER", 0x00000002 },
      { " REQUIRE_MINOR", 0x00000004 },
      { " EXPORTS", 0x00000008 },
      { " DELAY_LOAD", 0x00000010 },
      { " DELTA", 0x00000020 }
    };
    int flags = liblist.l_flags;
    size_t fcnt;

    for (fcnt = 0; fcnt < (sizeof (l_flags_vals) / sizeof ((l_flags_vals)[0])); ++fcnt)
      if ((flags & l_flags_vals[fcnt].bit) != 0)
        {
   fputs (l_flags_vals[fcnt].name, 
# 15455 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  stdout
# 15455 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        );
   flags ^= l_flags_vals[fcnt].bit;
        }
    if (flags != 0)
      printf (" %#x", (unsigned int) flags);

    puts ("");
  }
     }

   free (elib);
 }
      else
 res = 0;
    }

  if (options_offset != 0)
    {
      Elf_External_Options * eopt;
      Elf_Internal_Options * iopt;
      Elf_Internal_Options * option;
      size_t offset;
      int cnt;
      sect = section_headers;


      sect = find_section_by_type (0x7000000d);

      if (sect == 
# 15483 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 15483 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   error (gettext ("No MIPS_OPTIONS header found\n"));
   return 0;
 }

      eopt = (Elf_External_Options *) get_data (
# 15489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               ((void *)0)
# 15489 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   , file, options_offset, 1,
                                                sect->sh_size, gettext ("options"));
      if (eopt)
 {
   iopt = (Elf_Internal_Options *)
              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));
   if (iopt == 
# 15495 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 15495 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
     {
       error (gettext ("Out of memory allocating space for MIPS options\n"));
       return 0;
     }

   offset = cnt = 0;
   option = iopt;

   while (offset <= sect->sh_size - sizeof (* eopt))
     {
       Elf_External_Options * eoption;

       eoption = (Elf_External_Options *) ((char *) eopt + offset);

       option->kind = byte_get (eoption->kind, sizeof (eoption->kind));
       option->size = byte_get (eoption->size, sizeof (eoption->size));
       option->section = byte_get (eoption->section, sizeof (eoption->section));
       option->info = byte_get (eoption->info, sizeof (eoption->info));


       if (option->size < sizeof (* eopt)
    || offset + option->size > sect->sh_size)
  {
    error (gettext ("Invalid size (%u) for MIPS option\n"), option->size);
    return 0;
  }
       offset += option->size;

       ++option;
       ++cnt;
     }

   printf (gettext ("\nSection '%s' contains %d entries:\n"),
    printable_section_name (sect), cnt);

   option = iopt;
   offset = 0;

   while (cnt-- > 0)
     {
       size_t len;

       switch (option->kind)
  {
  case 0:

    printf (" NULL       %d %lx", option->section, option->info);
    break;
  case 1:
    printf (" REGINFO    ");
    if (elf_header.e_machine == 8)
      {

        Elf32_External_RegInfo * ereg;
        Elf32_RegInfo reginfo;

        ereg = (Elf32_External_RegInfo *) (option + 1);
        reginfo.ri_gprmask = byte_get (ereg->ri_gprmask, sizeof (ereg->ri_gprmask));
        reginfo.ri_cprmask[0] = byte_get (ereg->ri_cprmask[0], sizeof (ereg->ri_cprmask[0]));
        reginfo.ri_cprmask[1] = byte_get (ereg->ri_cprmask[1], sizeof (ereg->ri_cprmask[1]));
        reginfo.ri_cprmask[2] = byte_get (ereg->ri_cprmask[2], sizeof (ereg->ri_cprmask[2]));
        reginfo.ri_cprmask[3] = byte_get (ereg->ri_cprmask[3], sizeof (ereg->ri_cprmask[3]));
        reginfo.ri_gp_value = byte_get (ereg->ri_gp_value, sizeof (ereg->ri_gp_value));

        printf ("GPR %08lx  GP 0x%lx\n",
         reginfo.ri_gprmask,
         (unsigned long) reginfo.ri_gp_value);
        printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
         reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
         reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
      }
    else
      {

        Elf64_External_RegInfo * ereg;
        Elf64_Internal_RegInfo reginfo;

        ereg = (Elf64_External_RegInfo *) (option + 1);
        reginfo.ri_gprmask = byte_get (ereg->ri_gprmask, sizeof (ereg->ri_gprmask));
        reginfo.ri_cprmask[0] = byte_get (ereg->ri_cprmask[0], sizeof (ereg->ri_cprmask[0]));
        reginfo.ri_cprmask[1] = byte_get (ereg->ri_cprmask[1], sizeof (ereg->ri_cprmask[1]));
        reginfo.ri_cprmask[2] = byte_get (ereg->ri_cprmask[2], sizeof (ereg->ri_cprmask[2]));
        reginfo.ri_cprmask[3] = byte_get (ereg->ri_cprmask[3], sizeof (ereg->ri_cprmask[3]));
        reginfo.ri_gp_value = byte_get (ereg->ri_gp_value, sizeof (ereg->ri_gp_value));

        printf ("GPR %08lx  GP 0x",
         reginfo.ri_gprmask);
        fprintf (
# 15583 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       stdout
# 15583 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       , "%016" "l" "x", reginfo.ri_gp_value);
        printf ("\n");

        printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
         reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
         reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
      }
    ++option;
    continue;
  case 2:
    fputs (" EXCEPTIONS fpe_min(", 
# 15593 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                  stdout
# 15593 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        );
    process_mips_fpe_exception (option->info & 0x1f);
    fputs (") fpe_max(", 
# 15595 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15595 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
    process_mips_fpe_exception ((option->info & 0x1f00) >> 8);
    fputs (")", 
# 15597 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               stdout
# 15597 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     );

    if (option->info & 0x10000)
      fputs (" PAGE0", 
# 15600 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      stdout
# 15600 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            );
    if (option->info & 0x20000)
      fputs (" SMM", 
# 15602 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    stdout
# 15602 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          );
    if (option->info & 0x40000)
      fputs (" FPDBUG", 
# 15604 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15604 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
    if (option->info & 0x80000)
      fputs (" DISMISS", 
# 15606 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15606 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
    break;
  case 3:
    fputs (" PAD       ", 
# 15609 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15609 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
    if (option->info & 0x01)
      fputs (" PREFIX", 
# 15611 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15611 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
    if (option->info & 0x02)
      fputs (" POSTFIX", 
# 15613 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15613 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
    if (option->info & 0x04)
      fputs (" SYMBOL", 
# 15615 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15615 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
    break;
  case 4:
    fputs (" HWPATCH   ", 
# 15618 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15618 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
    if (option->info & 0x00000001)
      fputs (" R4KEOP", 
# 15620 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15620 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
    if (option->info & 0x00000002)
      fputs (" R8KPFETCH", 
# 15622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15622 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );
    if (option->info & 0x00000004)
      fputs (" R5KEOP", 
# 15624 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       stdout
# 15624 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             );
    if (option->info & 0x00000008)
      fputs (" R5KCVTL", 
# 15626 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        stdout
# 15626 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              );
    break;
  case 5:
    fputs (" FILL       ", 
# 15629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15629 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );

    break;
  case 6:
    fputs (" TAGS       ", 
# 15633 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          stdout
# 15633 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                );

    break;
  case 7:
    fputs (" HWAND     ", 
# 15637 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15637 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
    if (option->info & 0x00000001)
      fputs (" R4KEOP_CHECKED", 
# 15639 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               stdout
# 15639 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     );
    if (option->info & 0x00000002)
      fputs (" R4KEOP_CLEAN", 
# 15641 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15641 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
    break;
  case 8:
    fputs (" HWOR      ", 
# 15644 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         stdout
# 15644 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               );
    if (option->info & 0x00000001)
      fputs (" R4KEOP_CHECKED", 
# 15646 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               stdout
# 15646 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     );
    if (option->info & 0x00000002)
      fputs (" R4KEOP_CLEAN", 
# 15648 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             stdout
# 15648 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   );
    break;
  case 9:
    printf (" GP_GROUP  %#06lx  self-contained %#06lx",
     option->info & 0x0000ffff,
     (option->info & 0xffff0000) >> 16);
    break;
  case 10:
    printf (" IDENT     %#06lx  self-contained %#06lx",
     option->info & 0x0000ffff,
     (option->info & 0xffff0000) >> 16);
    break;
  default:

    printf (" %3d ???     %d %lx",
     option->kind, option->section, option->info);
    break;
  }

       len = sizeof (* eopt);
       while (len < option->size)
  {
    unsigned char datum = * ((unsigned char *) eopt + offset + len);

    if ((_sch_istable[(datum) & 0xff] & (unsigned short)(_sch_isprint)))
      printf ("%c", datum);
    else
      printf ("\\%03o", datum);
    len ++;
  }
       fputs ("\n", 
# 15678 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   stdout
# 15678 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                         );

       offset += option->size;
       ++option;
     }

   free (eopt);
 }
      else
 res = 0;
    }

  if (conflicts_offset != 0 && conflictsno != 0)
    {
      Elf32_Conflict * iconf;
      size_t cnt;

      if (dynamic_symbols == 
# 15695 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 15695 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )
 {
   error (gettext ("conflict list found without a dynamic symbol table\n"));
   return 0;
 }



      if (conflictsno * sizeof (* iconf) > current_file_size)
 {
   error (gettext ("Overlarge number of conflicts detected: %lx\n"),
   (long) conflictsno);
   return 0;
 }

      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
      if (iconf == 
# 15711 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 15711 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
 {
   error (gettext ("Out of memory allocating space for dynamic conflicts\n"));
   return 0;
 }

      if (is_32bit_elf)
 {
   Elf32_External_Conflict * econf32;

   econf32 = (Elf32_External_Conflict *)
              get_data (
# 15722 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 15722 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           , file, conflicts_offset, conflictsno,
                        sizeof (* econf32), gettext ("conflict"));
   if (!econf32)
     return 0;

   for (cnt = 0; cnt < conflictsno; ++cnt)
     iconf[cnt] = byte_get (econf32[cnt], sizeof (econf32[cnt]));

   free (econf32);
 }
      else
 {
   Elf64_External_Conflict * econf64;

   econf64 = (Elf64_External_Conflict *)
              get_data (
# 15737 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 15737 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           , file, conflicts_offset, conflictsno,
                        sizeof (* econf64), gettext ("conflict"));
   if (!econf64)
     return 0;

   for (cnt = 0; cnt < conflictsno; ++cnt)
     iconf[cnt] = byte_get (econf64[cnt], sizeof (econf64[cnt]));

   free (econf64);
 }

      printf (gettext ("\nSection '.conflict' contains %lu entries:\n"),
       (unsigned long) conflictsno);
      puts (gettext ("  Num:    Index       Value  Name"));

      for (cnt = 0; cnt < conflictsno; ++cnt)
 {
   printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);

   if (iconf[cnt] >= num_dynamic_syms)
     printf (gettext ("<corrupt symbol index>"));
   else
     {
       Elf_Internal_Sym * psym;

       psym = & dynamic_symbols[iconf[cnt]];
       print_vma (psym->st_value, FULL_HEX);
       putchar (' ');
       if (((dynamic_strings != 
# 15765 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 15765 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ) && (psym->st_name < dynamic_strings_length)))
  print_symbol (25, (dynamic_strings + psym->st_name));
       else
  printf (gettext ("<corrupt: %14ld>"), psym->st_name);
     }
   putchar ('\n');
 }

      free (iconf);
    }

  if (pltgot != 0 && local_gotno != 0)
    {
      bfd_vma ent, local_end, global_end;
      size_t i, offset;
      unsigned char * data;
      unsigned char * data_end;
      int addr_size;

      ent = pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      local_end = pltgot + local_gotno * addr_size;


      if (symtabno < gotsym)
 {
   error (gettext ("The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"),
   (unsigned long) gotsym, (unsigned long) symtabno);
   return 0;
 }

      global_end = local_end + (symtabno - gotsym) * addr_size;

      if (global_end < local_end)
 {
   error (gettext ("Too many GOT symbols: %lu\n"), (unsigned long) symtabno);
   return 0;
 }

      offset = offset_from_vma (file, pltgot, global_end - pltgot);
      data = (unsigned char *) get_data (
# 15805 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0)
# 15805 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            , file, offset,
                                         global_end - pltgot, 1,
      gettext ("Global Offset Table data"));

      data_end = data + (global_end - pltgot);

      printf (gettext ("\nPrimary GOT:\n"));
      printf (gettext (" Canonical gp value: "));
      print_vma (pltgot + 0x7ff0, LONG_HEX);
      printf ("\n\n");

      printf (gettext (" Reserved entries:\n"));
      printf (gettext ("  %*s %10s %*s Purpose\n"),
       addr_size * 2, gettext ("Address"), gettext ("Access"),
       addr_size * 2, gettext ("Initial"));
      ent = print_mips_got_entry (data, pltgot, ent, data_end);
      printf (gettext (" Lazy resolver\n"));
      if (ent == (bfd_vma) -1)
 goto got_print_fail;






      if (data
   && data + ent - pltgot + addr_size <= data_end
   && (byte_get (data + ent - pltgot, addr_size)
       >> (addr_size * 8 - 1)) != 0)
 {
   ent = print_mips_got_entry (data, pltgot, ent, data_end);
   printf (gettext (" Module pointer (GNU extension)\n"));
   if (ent == (bfd_vma) -1)
     goto got_print_fail;
 }
      printf ("\n");

      if (data != 
# 15842 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0) 
# 15842 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      && ent < local_end)
 {
   printf (gettext (" Local entries:\n"));
   printf ("  %*s %10s %*s\n",
    addr_size * 2, gettext ("Address"), gettext ("Access"),
    addr_size * 2, gettext ("Initial"));
   while (ent < local_end)
     {
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf ("\n");
       if (ent == (bfd_vma) -1)
  goto got_print_fail;
     }
   printf ("\n");
 }

      if (data != 
# 15858 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0) 
# 15858 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      && gotsym < symtabno)
 {
   int sym_width;

   printf (gettext (" Global entries:\n"));
   printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
    addr_size * 2, gettext ("Address"),
    gettext ("Access"),
    addr_size * 2, gettext ("Initial"),
    addr_size * 2, gettext ("Sym.Val."),
    gettext ("Type"),

    gettext ("Ndx"), gettext ("Name"));

   sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;

   for (i = gotsym; i < symtabno; i++)
     {
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf (" ");

       if (dynamic_symbols == 
# 15879 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             ((void *)0)
# 15879 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 )
  printf (gettext ("<no dynamic symbols>"));
       else if (i < num_dynamic_syms)
  {
    Elf_Internal_Sym * psym = dynamic_symbols + i;

    print_vma (psym->st_value, LONG_HEX);
    printf (" %-7s %3s ",
     get_symbol_type (((psym->st_info) & 0xF)),
     get_symbol_index_type (psym->st_shndx));

    if (((dynamic_strings != 
# 15890 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((void *)0)
# 15890 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       ) && (psym->st_name < dynamic_strings_length)))
      print_symbol (sym_width, (dynamic_strings + psym->st_name));
    else
      printf (gettext ("<corrupt: %14ld>"), psym->st_name);
  }
       else
  printf (gettext ("<symbol index %lu exceeds number of dynamic symbols>"),
   (unsigned long) i);

       printf ("\n");
       if (ent == (bfd_vma) -1)
  break;
     }
   printf ("\n");
 }

    got_print_fail:
      if (data)
 free (data);
    }

  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)
    {
      bfd_vma ent, end;
      size_t offset, rel_offset;
      unsigned long count, i;
      unsigned char * data;
      int addr_size, sym_width;
      Elf_Internal_Rela * rels;

      rel_offset = offset_from_vma (file, jmprel, pltrelsz);
      if (pltrel == 7)
 {
   if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))
     return 0;
 }
      else
 {
   if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))
     return 0;
 }

      ent = mips_pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      end = mips_pltgot + (2 + count) * addr_size;

      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);
      data = (unsigned char *) get_data (
# 15937 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0)
# 15937 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            , file, offset, end - mips_pltgot,
                                         1, gettext ("Procedure Linkage Table data"));
      if (data == 
# 15939 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 15939 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 return 0;

      printf ("\nPLT GOT:\n\n");
      printf (gettext (" Reserved entries:\n"));
      printf (gettext ("  %*s %*s Purpose\n"),
       addr_size * 2, gettext ("Address"), addr_size * 2, gettext ("Initial"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (gettext (" PLT lazy resolver\n"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (gettext (" Module pointer\n"));
      printf ("\n");

      printf (gettext (" Entries:\n"));
      printf ("  %*s %*s %*s %-7s %3s %s\n",
       addr_size * 2, gettext ("Address"),
       addr_size * 2, gettext ("Initial"),
       addr_size * 2, gettext ("Sym.Val."), gettext ("Type"), gettext ("Ndx"), gettext ("Name"));
      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
      for (i = 0; i < count; i++)
 {
   unsigned long idx = get_reloc_symindex (rels[i].r_info);

   ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
   printf (" ");

   if (idx >= num_dynamic_syms)
     printf (gettext ("<corrupt symbol index: %lu>"), idx);
   else
     {
       Elf_Internal_Sym * psym = dynamic_symbols + idx;

       print_vma (psym->st_value, LONG_HEX);
       printf (" %-7s %3s ",
        get_symbol_type (((psym->st_info) & 0xF)),
        get_symbol_index_type (psym->st_shndx));
       if (((dynamic_strings != 
# 15975 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
          ((void *)0)
# 15975 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
          ) && (psym->st_name < dynamic_strings_length)))
  print_symbol (sym_width, (dynamic_strings + psym->st_name));
       else
  printf (gettext ("<corrupt: %14ld>"), psym->st_name);
     }
   printf ("\n");
 }
      printf ("\n");

      if (data)
 free (data);
      free (rels);
    }

  return res;
}

static bfd_boolean
process_nds32_specific (FILE * file)
{
  Elf_Internal_Shdr *sect = 
# 15995 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 15995 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;

  sect = find_section (".nds32_e_flags");
  if (sect != 
# 15998 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 15998 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    {
      unsigned int *flag;

      printf ("\nNDS32 elf flags section:\n");
      flag = get_data (
# 16003 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 16003 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          , file, sect->sh_offset, 1,
         sect->sh_size, gettext ("NDS32 elf flags section"));

      if (! flag)
 return 0;

      switch ((*flag) & 0x3)
 {
 case 0:
   printf ("(VEC_SIZE):\tNo entry.\n");
   break;
 case 1:
   printf ("(VEC_SIZE):\t4 bytes\n");
   break;
 case 2:
   printf ("(VEC_SIZE):\t16 bytes\n");
   break;
 case 3:
   printf ("(VEC_SIZE):\treserved\n");
   break;
 }
    }

  return 1;
}

static bfd_boolean
process_gnu_liblist (FILE * file)
{
  Elf_Internal_Shdr * section;
  Elf_Internal_Shdr * string_sec;
  Elf32_External_Lib * elib;
  char * strtab;
  size_t strtab_size;
  size_t cnt;
  unsigned i;
  bfd_boolean res = 1;

  if (! do_arch)
    return 1;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
 {
 case 0x6ffffff7:
   if (section->sh_link >= elf_header.e_shnum)
     break;

   elib = (Elf32_External_Lib *)
              get_data (
# 16055 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 16055 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           , file, section->sh_offset, 1, section->sh_size,
                        gettext ("liblist section data"));

   if (elib == 
# 16058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 16058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
     {
       res = 0;
       break;
     }

   string_sec = section_headers + section->sh_link;
   strtab = (char *) get_data (
# 16065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 16065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  , file, string_sec->sh_offset, 1,
                                      string_sec->sh_size,
                                      gettext ("liblist string table"));
   if (strtab == 
# 16068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                ((void *)0)
       
# 16069 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
      || section->sh_entsize != sizeof (Elf32_External_Lib))
     {
       free (elib);
       free (strtab);
       res = 0;
       break;
     }
   strtab_size = string_sec->sh_size;

   printf (gettext ("\nLibrary list section '%s' contains %lu entries:\n"),
    printable_section_name (section),
    (unsigned long) (section->sh_size / sizeof (Elf32_External_Lib)));

   puts (gettext ("     Library              Time Stamp          Checksum   Version Flags"));

   for (cnt = 0; cnt < section->sh_size / sizeof (Elf32_External_Lib);
        ++cnt)
     {
       Elf32_Lib liblist;
       time_t atime;
       char timebuf[128];
       struct tm * tmp;

       liblist.l_name = byte_get (elib[cnt].l_name, sizeof (elib[cnt].l_name));
       atime = byte_get (elib[cnt].l_time_stamp, sizeof (elib[cnt].l_time_stamp));
       liblist.l_checksum = byte_get (elib[cnt].l_checksum, sizeof (elib[cnt].l_checksum));
       liblist.l_version = byte_get (elib[cnt].l_version, sizeof (elib[cnt].l_version));
       liblist.l_flags = byte_get (elib[cnt].l_flags, sizeof (elib[cnt].l_flags));

       tmp = gmtime (&atime);
       snprintf (timebuf, sizeof (timebuf),
   "%04u-%02u-%02uT%02u:%02u:%02u",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

       printf ("%3lu: ", (unsigned long) cnt);
       if (do_wide)
  printf ("%-20s", liblist.l_name < strtab_size
   ? strtab + liblist.l_name : gettext ("<corrupt>"));
       else
  printf ("%-20.20s", liblist.l_name < strtab_size
   ? strtab + liblist.l_name : gettext ("<corrupt>"));
       printf (" %s %#010lx %-7ld %-7ld\n", timebuf, liblist.l_checksum,
        liblist.l_version, liblist.l_flags);
     }

   free (elib);
   free (strtab);
 }
    }

  return res;
}

static const char *
get_note_type (unsigned e_type)
{
  static char buff[64];

  if (elf_header.e_type == 4)
    switch (e_type)
      {
      case 6:
 return gettext ("NT_AUXV (auxiliary vector)");
      case 1:
 return gettext ("NT_PRSTATUS (prstatus structure)");
      case 2:
 return gettext ("NT_FPREGSET (floating point registers)");
      case 3:
 return gettext ("NT_PRPSINFO (prpsinfo structure)");
      case 4:
 return gettext ("NT_TASKSTRUCT (task structure)");
      case 0x46e62b7f:
 return gettext ("NT_PRXFPREG (user_xfpregs structure)");
      case 0x100:
 return gettext ("NT_PPC_VMX (ppc Altivec registers)");
      case 0x102:
 return gettext ("NT_PPC_VSX (ppc VSX registers)");
      case 0x200:
 return gettext ("NT_386_TLS (x86 TLS information)");
      case 0x201:
 return gettext ("NT_386_IOPERM (x86 I/O permissions)");
      case 0x202:
 return gettext ("NT_X86_XSTATE (x86 XSAVE extended state)");
      case 0x300:
 return gettext ("NT_S390_HIGH_GPRS (s390 upper register halves)");
      case 0x301:
 return gettext ("NT_S390_TIMER (s390 timer register)");
      case 0x302:
 return gettext ("NT_S390_TODCMP (s390 TOD comparator register)");
      case 0x303:
 return gettext ("NT_S390_TODPREG (s390 TOD programmable register)");
      case 0x304:
 return gettext ("NT_S390_CTRS (s390 control registers)");
      case 0x305:
 return gettext ("NT_S390_PREFIX (s390 prefix register)");
      case 0x306:
 return gettext ("NT_S390_LAST_BREAK (s390 last breaking event address)");
      case 0x307:
 return gettext ("NT_S390_SYSTEM_CALL (s390 system call restart data)");
      case 0x308:
 return gettext ("NT_S390_TDB (s390 transaction diagnostic block)");
      case 0x309:
 return gettext ("NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)");
      case 0x30a:
 return gettext ("NT_S390_VXRS_HIGH (s390 vector registers 16-31)");
      case 0x30b:
 return gettext ("NT_S390_GS_CB (s390 guarded-storage registers)");
      case 0x30c:
 return gettext ("NT_S390_GS_BC (s390 guarded-storage broadcast control)");
      case 0x400:
 return gettext ("NT_ARM_VFP (arm VFP registers)");
      case 0x401:
 return gettext ("NT_ARM_TLS (AArch TLS registers)");
      case 0x402:
 return gettext ("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
      case 0x403:
 return gettext ("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
      case 10:
 return gettext ("NT_PSTATUS (pstatus structure)");
      case 12:
 return gettext ("NT_FPREGS (floating point registers)");
      case 13:
 return gettext ("NT_PSINFO (psinfo structure)");
      case 16:
 return gettext ("NT_LWPSTATUS (lwpstatus_t structure)");
      case 17:
 return gettext ("NT_LWPSINFO (lwpsinfo_t structure)");
      case 18:
 return gettext ("NT_WIN32PSTATUS (win32_pstatus structure)");
      case 0x53494749:
 return gettext ("NT_SIGINFO (siginfo_t data)");
      case 0x46494c45:
 return gettext ("NT_FILE (mapped files)");
      default:
 break;
      }
  else
    switch (e_type)
      {
      case 1:
 return gettext ("NT_VERSION (version)");
      case 2:
 return gettext ("NT_ARCH (architecture)");
      case 0x100:
 return gettext ("NT_GNU_BUILD_ATTRIBUTE_OPEN");
      case 0x101:
 return gettext ("NT_GNU_BUILD_ATTRIBUTE_FUNC");
      default:
 break;
      }

  snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static bfd_boolean
print_core_note (Elf_Internal_Note *pnote)
{
  unsigned int addr_size = is_32bit_elf ? 4 : 8;
  bfd_vma count, page_size;
  unsigned char *descdata, *filenames, *descend;

  if (pnote->type != 0x46494c45)
    return 1;
# 16244 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
  if (pnote->descsz < 2 * addr_size)
    {
      error (gettext ("    Malformed note - too short for header\n"));
      return 0;
    }

  descdata = (unsigned char *) pnote->descdata;
  descend = descdata + pnote->descsz;

  if (descdata[pnote->descsz - 1] != '\0')
    {
      error (gettext ("    Malformed note - does not end with \\0\n"));
      return 0;
    }

  count = byte_get (descdata, addr_size);
  descdata += addr_size;

  page_size = byte_get (descdata, addr_size);
  descdata += addr_size;

  if (pnote->descsz < 2 * addr_size + count * 3 * addr_size)
    {
      error (gettext ("    Malformed note - too short for supplied file count\n"));
      return 0;
    }

  printf (gettext ("    Page size: "));
  print_vma (page_size, DEC);
  printf ("\n");

  printf (gettext ("    %*s%*s%*s\n"),
   (int) (2 + 2 * addr_size), gettext ("Start"),
   (int) (4 + 2 * addr_size), gettext ("End"),
   (int) (4 + 2 * addr_size), gettext ("Page Offset"));
  filenames = descdata + count * 3 * addr_size;
  while (count-- > 0)
    {
      bfd_vma start, end, file_ofs;

      if (filenames == descend)
 {
   error (gettext ("    Malformed note - filenames end too early\n"));
   return 0;
 }

      start = byte_get (descdata, addr_size);
      descdata += addr_size;
      end = byte_get (descdata, addr_size);
      descdata += addr_size;
      file_ofs = byte_get (descdata, addr_size);
      descdata += addr_size;

      printf ("    ");
      print_vma (start, FULL_HEX);
      printf ("  ");
      print_vma (end, FULL_HEX);
      printf ("  ");
      print_vma (file_ofs, FULL_HEX);
      printf ("\n        %s\n", filenames);

      filenames += 1 + strlen ((char *) filenames);
    }

  return 1;
}

static const char *
get_gnu_elf_note_type (unsigned e_type)
{

  switch (e_type)
    {
    case 1:
      return gettext ("NT_GNU_ABI_TAG (ABI version tag)");
    case 2:
      return gettext ("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
    case 3:
      return gettext ("NT_GNU_BUILD_ID (unique build ID bitstring)");
    case 4:
      return gettext ("NT_GNU_GOLD_VERSION (gold version)");
    case 5:
      return gettext ("NT_GNU_PROPERTY_TYPE_0");
    case 0x100:
      return gettext ("NT_GNU_BUILD_ATTRIBUTE_OPEN");
    case 0x101:
      return gettext ("NT_GNU_BUILD_ATTRIBUTE_FUNC");
    default:
      {
 static char buff[64];

 snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
 return buff;
      }
    }
}

static void
decode_x86_isa (unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0): printf ("i486"); break;
 case (1U << 1): printf ("586"); break;
 case (1U << 2): printf ("686"); break;
 case (1U << 3): printf ("SSE"); break;
 case (1U << 4): printf ("SSE2"); break;
 case (1U << 5): printf ("SSE3"); break;
 case (1U << 6): printf ("SSSE3"); break;
 case (1U << 7): printf ("SSE4_1"); break;
 case (1U << 8): printf ("SSE4_2"); break;
 case (1U << 9): printf ("AVX"); break;
 case (1U << 10): printf ("AVX2"); break;
 case (1U << 11): printf ("AVX512F"); break;
 case (1U << 12): printf ("AVX512CD"); break;
 case (1U << 13): printf ("AVX512ER"); break;
 case (1U << 14): printf ("AVX512PF"); break;
 case (1U << 15): printf ("AVX512VL"); break;
 case (1U << 16): printf ("AVX512DQ"); break;
 case (1U << 17): printf ("AVX512BW"); break;
 default: printf (gettext ("<unknown: %x>"), bit); break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_x86_feature (unsigned int type, unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   switch (type)
     {
     case 0xc0000002:
       printf ("IBT");
       break;
     default:

       abort ();
     }
   break;
 case (1U << 1):
   switch (type)
     {
     case 0xc0000002:
       printf ("SHSTK");
       break;
     default:

       abort ();
     }
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
print_gnu_property_note (Elf_Internal_Note * pnote)
{
  unsigned char * ptr = (unsigned char *) pnote->descdata;
  unsigned char * ptr_end = ptr + pnote->descsz;
  unsigned int size = is_32bit_elf ? 4 : 8;

  printf (gettext ("      Properties: "));

  if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
    {
      printf (gettext ("<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"), pnote->descsz);
      return;
    }

  while (1)
    {
      unsigned int j;
      unsigned int type = byte_get (ptr, 4);
      unsigned int datasz = byte_get (ptr + 4, 4);

      ptr += 8;

      if ((ptr + datasz) > ptr_end)
 {
   printf (gettext ("<corrupt type (%#x) datasz: %#x>\n"),
    type, datasz);
   break;
 }

      if (type >= 0xc0000000 && type <= 0xdfffffff)
 {
   if (elf_header.e_machine == 62
       || elf_header.e_machine == 6
       || elf_header.e_machine == 3)
     {
       switch (type)
  {
  case 0xc0000000:
    printf ("x86 ISA used: ");
    if (datasz != 4)
      printf (gettext ("<corrupt length: %#x> "), datasz);
    else
      decode_x86_isa (byte_get (ptr, 4));
    goto next;

  case 0xc0000001:
    printf ("x86 ISA needed: ");
    if (datasz != 4)
      printf (gettext ("<corrupt length: %#x> "), datasz);
    else
      decode_x86_isa (byte_get (ptr, 4));
    goto next;

  case 0xc0000002:
    printf ("x86 feature: ");
    if (datasz != 4)
      printf (gettext ("<corrupt length: %#x> "), datasz);
    else
      decode_x86_feature (type, byte_get (ptr, 4));
    goto next;

  default:
    break;
  }
     }
 }
      else
 {
   switch (type)
     {
     case 1:
       printf (gettext ("stack size: "));
       if (datasz != size)
  printf (gettext ("<corrupt length: %#x> "), datasz);
       else
  printf ("%#lx", (unsigned long) byte_get (ptr, size));
       goto next;

     case 2:
       printf ("no copy on protected ");
       if (datasz)
  printf (gettext ("<corrupt length: %#x> "), datasz);
       goto next;

     default:
       break;
     }
 }

      if (type < 0xc0000000)
 printf (gettext ("<unknown type %#x data: "), type);
      else if (type < 0xe0000000)
 printf (gettext ("<procesor-specific type %#x data: "), type);
      else
 printf (gettext ("<application-specific type %#x data: "), type);
      for (j = 0; j < datasz; ++j)
 printf ("%02x ", ptr[j] & 0xff);
      printf (">");

next:
      ptr += ((datasz + (size - 1)) & ~ (size - 1));
      if (ptr == ptr_end)
 break;
      else
 {
   if (do_wide)
     printf (", ");
   else
     printf ("\n\t");
 }

      if (ptr > (ptr_end - 8))
 {
   printf (gettext ("<corrupt descsz: %#lx>\n"), pnote->descsz);
   break;
 }
    }

  printf ("\n");
}

static bfd_boolean
print_gnu_note (Elf_Internal_Note *pnote)
{

  switch (pnote->type)
    {
    case 3:
      {
 unsigned long i;

 printf (gettext ("    Build ID: "));
 for (i = 0; i < pnote->descsz; ++i)
   printf ("%02x", pnote->descdata[i] & 0xff);
 printf ("\n");
      }
      break;

    case 1:
      {
 unsigned long os, major, minor, subminor;
 const char *osname;


 if (pnote->descsz < 16)
   {
     printf (gettext ("    <corrupt GNU_ABI_TAG>\n"));
     break;
   }

 os = byte_get ((unsigned char *) pnote->descdata, 4);
 major = byte_get ((unsigned char *) pnote->descdata + 4, 4);
 minor = byte_get ((unsigned char *) pnote->descdata + 8, 4);
 subminor = byte_get ((unsigned char *) pnote->descdata + 12, 4);

 switch (os)
   {
   case 0:
     osname = "Linux";
     break;
   case 1:
     osname = "Hurd";
     break;
   case 2:
     osname = "Solaris";
     break;
   case 3:
     osname = "FreeBSD";
     break;
   case 4:
     osname = "NetBSD";
     break;
   case 5:
     osname = "Syllable";
     break;
   case 6:
     osname = "NaCl";
     break;
   default:
     osname = "Unknown";
     break;
   }

 printf (gettext ("    OS: %s, ABI: %ld.%ld.%ld\n"), osname,
  major, minor, subminor);
      }
      break;

    case 4:
      {
 unsigned long i;

 printf (gettext ("    Version: "));
 for (i = 0; i < pnote->descsz && pnote->descdata[i] != '\0'; ++i)
   printf ("%c", pnote->descdata[i]);
 printf ("\n");
      }
      break;

    case 2:
      {
 unsigned long num_entries, mask;






 printf (gettext ("      Hardware Capabilities: "));
 if (pnote->descsz < 8)
   {
     error (gettext ("<corrupt GNU_HWCAP>\n"));
     return 0;
   }
 num_entries = byte_get ((unsigned char *) pnote->descdata, 4);
 mask = byte_get ((unsigned char *) pnote->descdata + 4, 4);
 printf (gettext ("num entries: %ld, enabled mask: %lx\n"), num_entries, mask);

      }
      break;

    case 5:
      print_gnu_property_note (pnote);
      break;

    default:



      {
 unsigned long i;

 printf (gettext ("    Description data: "));
 for (i = 0; i < pnote->descsz; ++i)
   printf ("%02x ", pnote->descdata[i] & 0xff);
 printf ("\n");
      }
      break;
    }

  return 1;
}

static const char *
get_v850_elf_note_type (enum v850_notes n_type)
{
  static char buff[64];

  switch (n_type)
    {
    case V850_NOTE_ALIGNMENT: return gettext ("Alignment of 8-byte objects");
    case V850_NOTE_DATA_SIZE: return gettext ("Sizeof double and long double");
    case V850_NOTE_FPU_INFO: return gettext ("Type of FPU support needed");
    case V850_NOTE_SIMD_INFO: return gettext ("Use of SIMD instructions");
    case V850_NOTE_CACHE_INFO: return gettext ("Use of cache");
    case V850_NOTE_MMU_INFO: return gettext ("Use of MMU");
    default:
      snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), n_type);
      return buff;
    }
}

static bfd_boolean
print_v850_note (Elf_Internal_Note * pnote)
{
  unsigned int val;

  if (pnote->descsz != 4)
    return 0;

  val = byte_get ((unsigned char *) pnote->descdata, pnote->descsz);

  if (val == 0)
    {
      printf (gettext ("not set\n"));
      return 1;
    }

  switch (pnote->type)
    {
    case V850_NOTE_ALIGNMENT:
      switch (val)
 {
 case 0x0001: printf (gettext ("4-byte\n")); return 1;
 case 0x0002: printf (gettext ("8-byte\n")); return 1;
 }
      break;

    case V850_NOTE_DATA_SIZE:
      switch (val)
 {
 case 0x0001: printf (gettext ("4-bytes\n")); return 1;
 case 0x0002: printf (gettext ("8-bytes\n")); return 1;
 }
      break;

    case V850_NOTE_FPU_INFO:
      switch (val)
 {
 case 0x0001: printf (gettext ("FPU-2.0\n")); return 1;
 case 0x0002: printf (gettext ("FPU-3.0\n")); return 1;
 }
      break;

    case V850_NOTE_MMU_INFO:
    case V850_NOTE_CACHE_INFO:
    case V850_NOTE_SIMD_INFO:
      if (val == 0x0001)
 {
   printf (gettext ("yes\n"));
   return 1;
 }
      break;

    default:

      break;
    }

  printf (gettext ("unknown value: %x\n"), val);
  return 0;
}

static bfd_boolean
process_netbsd_elf_note (Elf_Internal_Note * pnote)
{
  unsigned int version;

  switch (pnote->type)
    {
    case 1:
      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
      if ((version / 10000) % 100)
        printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n", pnote->descsz,
  version, version / 100000000, (version / 1000000) % 100,
  (version / 10000) % 100 > 26 ? "Z" : "",
  'A' + (version / 10000) % 26);
      else
 printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n", pnote->descsz,
         version, version / 100000000, (version / 1000000) % 100,
  (version / 100) % 100);
      return 1;

    case 5:
      printf ("  NetBSD\t0x%08lx\tMARCH <%s>\n", pnote->descsz,
       pnote->descdata);
      return 1;

    default:
      printf ("  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n", pnote->descsz,
       pnote->type);
      return 0;
    }
}

static const char *
get_freebsd_elfcore_note_type (unsigned e_type)
{
  switch (e_type)
    {
    case 7:
      return gettext ("NT_THRMISC (thrmisc structure)");
    case 8:
      return gettext ("NT_PROCSTAT_PROC (proc data)");
    case 9:
      return gettext ("NT_PROCSTAT_FILES (files data)");
    case 10:
      return gettext ("NT_PROCSTAT_VMMAP (vmmap data)");
    case 11:
      return gettext ("NT_PROCSTAT_GROUPS (groups data)");
    case 12:
      return gettext ("NT_PROCSTAT_UMASK (umask data)");
    case 13:
      return gettext ("NT_PROCSTAT_RLIMIT (rlimit data)");
    case 14:
      return gettext ("NT_PROCSTAT_OSREL (osreldate data)");
    case 15:
      return gettext ("NT_PROCSTAT_PSSTRINGS (ps_strings data)");
    case 16:
      return gettext ("NT_PROCSTAT_AUXV (auxv data)");
    }
  return get_note_type (e_type);
}

static const char *
get_netbsd_elfcore_note_type (unsigned e_type)
{
  static char buff[64];

  if (e_type == 1)
    {

      return gettext ("NetBSD procinfo structure");
    }






  if (e_type < 32)
    {
      snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }

  switch (elf_header.e_machine)
    {



    case 41:
    case 0x9026:
    case 2:
    case 18:
    case 43:
      switch (e_type)
 {
 case 32 + 0:
   return gettext ("PT_GETREGS (reg structure)");
 case 32 + 2:
   return gettext ("PT_GETFPREGS (fpreg structure)");
 default:
   break;
 }
      break;



    default:
      switch (e_type)
 {
 case 32 + 1:
   return gettext ("PT_GETREGS (reg structure)");
 case 32 + 3:
   return gettext ("PT_GETFPREGS (fpreg structure)");
 default:
   break;
 }
    }

  snprintf (buff, sizeof (buff), "PT_FIRSTMACH+%d",
     e_type - 32);
  return buff;
}

static const char *
get_stapsdt_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case 3:
      return gettext ("NT_STAPSDT (SystemTap probe descriptors)");

    default:
      break;
    }

  snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static bfd_boolean
print_stapsdt_note (Elf_Internal_Note *pnote)
{
  int addr_size = is_32bit_elf ? 4 : 8;
  char *data = pnote->descdata;
  char *data_end = pnote->descdata + pnote->descsz;
  bfd_vma pc, base_addr, semaphore;
  char *provider, *probe, *arg_fmt;

  pc = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;
  base_addr = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;
  semaphore = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;

  provider = data;
  data += strlen (data) + 1;
  probe = data;
  data += strlen (data) + 1;
  arg_fmt = data;
  data += strlen (data) + 1;

  printf (gettext ("    Provider: %s\n"), provider);
  printf (gettext ("    Name: %s\n"), probe);
  printf (gettext ("    Location: "));
  print_vma (pc, FULL_HEX);
  printf (gettext (", Base: "));
  print_vma (base_addr, FULL_HEX);
  printf (gettext (", Semaphore: "));
  print_vma (semaphore, FULL_HEX);
  printf ("\n");
  printf (gettext ("    Arguments: %s\n"), arg_fmt);

  return data == data_end;
}

static const char *
get_ia64_vms_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case 1:
      return gettext ("NT_VMS_MHD (module header)");
    case 2:
      return gettext ("NT_VMS_LNM (language name)");
    case 3:
      return gettext ("NT_VMS_SRC (source files)");
    case 4:
      return "NT_VMS_TITLE";
    case 5:
      return gettext ("NT_VMS_EIDC (consistency check)");
    case 6:
      return gettext ("NT_VMS_FPMODE (FP mode)");
    case 101:
      return "NT_VMS_LINKTIME";
    case 102:
      return gettext ("NT_VMS_IMGNAM (image name)");
    case 103:
      return gettext ("NT_VMS_IMGID (image id)");
    case 104:
      return gettext ("NT_VMS_LINKID (link id)");
    case 105:
      return gettext ("NT_VMS_IMGBID (build id)");
    case 106:
      return gettext ("NT_VMS_GSTNAM (sym table name)");
    case 107:
      return "NT_VMS_ORIG_DYN";
    case 108:
      return "NT_VMS_PATCHTIME";
    default:
      snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }
}

static bfd_boolean
print_ia64_vms_note (Elf_Internal_Note * pnote)
{
  switch (pnote->type)
    {
    case 1:
      if (pnote->descsz > 36)
        {
          size_t l = strlen (pnote->descdata + 34);
          printf (gettext ("    Creation date  : %.17s\n"), pnote->descdata);
          printf (gettext ("    Last patch date: %.17s\n"), pnote->descdata + 17);
          printf (gettext ("    Module name    : %s\n"), pnote->descdata + 34);
          printf (gettext ("    Module version : %s\n"), pnote->descdata + 34 + l + 1);
        }
      else
        printf (gettext ("    Invalid size\n"));
      break;
    case 2:
      printf (gettext ("   Language: %s\n"), pnote->descdata);
      break;

    case 6:
      printf (gettext ("   Floating Point mode: "));
      printf ("0x%016" "l" "x\n",
              (bfd_vma) byte_get ((unsigned char *)pnote->descdata, 8));
      break;
    case 101:
      printf (gettext ("   Link time: "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
      printf ("\n");
      break;
    case 108:
      printf (gettext ("   Patch time: "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
      printf ("\n");
      break;
    case 107:
      printf (gettext ("   Major id: %u,  minor id: %u\n"),
              (unsigned) byte_get ((unsigned char *)pnote->descdata, 4),
              (unsigned) byte_get ((unsigned char *)pnote->descdata + 4, 4));
      printf (gettext ("   Last modified  : "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata + 8, 8));
      printf (gettext ("\n   Link flags  : "));
      printf ("0x%016" "l" "x\n",
              (bfd_vma) byte_get ((unsigned char *)pnote->descdata + 16, 8));
      printf (gettext ("   Header flags: 0x%08x\n"),
              (unsigned) byte_get ((unsigned char *)pnote->descdata + 24, 4));
      printf (gettext ("   Image id    : %s\n"), pnote->descdata + 32);
      break;

    case 102:
      printf (gettext ("    Image name: %s\n"), pnote->descdata);
      break;
    case 106:
      printf (gettext ("    Global symbol table name: %s\n"), pnote->descdata);
      break;
    case 103:
      printf (gettext ("    Image id: %s\n"), pnote->descdata);
      break;
    case 104:
      printf (gettext ("    Linker id: %s\n"), pnote->descdata);
      break;
    default:
      return 0;
    }
  return 1;
}




static bfd_boolean
print_symbol_for_build_attribute (FILE * file,
      unsigned long offset,
      bfd_boolean is_open_attr)
{
  static FILE * saved_file = 
# 17039 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                        ((void *)0)
# 17039 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                            ;
  static char * strtab;
  static unsigned long strtablen;
  static Elf_Internal_Sym * symtab;
  static unsigned long nsyms;
  Elf_Internal_Sym * saved_sym = 
# 17044 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                       ((void *)0)
# 17044 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                           ;
  Elf_Internal_Sym * sym;

  if (section_headers != 
# 17047 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                        ((void *)0)
      
# 17048 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     && (saved_file == 
# 17048 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0) 
# 17048 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                            || file != saved_file))
    {
      Elf_Internal_Shdr * symsec;


      for (symsec = section_headers;
    symsec < section_headers + elf_header.e_shnum;
    symsec ++)
 {
   if (symsec->sh_type == 2)
     {
       symtab = (is_32bit_elf ? get_32bit_elf_symbols (file, symsec, & nsyms) : get_64bit_elf_symbols (file, symsec, & nsyms));

       if (symsec->sh_link < elf_header.e_shnum)
  {
    Elf_Internal_Shdr * strtab_sec = section_headers + symsec->sh_link;

    strtab = (char *) get_data (
# 17065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 17065 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   , file, strtab_sec->sh_offset,
           1, strtab_sec->sh_size,
           gettext ("string table"));
    strtablen = strtab != 
# 17068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0) 
# 17068 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              ? strtab_sec->sh_size : 0;
  }
     }
 }
      saved_file = file;
    }

  if (symtab == 
# 17075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0) 
# 17075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    || strtab == 
# 17075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 17075 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     )
    {
      printf ("\n");
      return 0;
    }


  for (sym = symtab; sym < symtab + nsyms; sym ++)
    if (sym->st_value == offset)
      {
 if (sym->st_name >= strtablen)

   continue;

 if (strtab[sym->st_name] == 0)
   continue;

 if (is_open_attr)
   {



     switch (((sym->st_info) & 0xF))
       {
       case 4:
  saved_sym = sym;

  sym = symtab + nsyms;
  continue;

       case 1:
  saved_sym = sym;
  continue;

       case 2:

  continue;

       default:
  break;
       }

     switch ((((unsigned int)(sym->st_info)) >> 4))
       {
       case 1:
  if (saved_sym == 
# 17120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
      
# 17121 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     || ((saved_sym->st_info) & 0xF) != 1)
    saved_sym = sym;
  break;

       case 0:
  if (saved_sym == 
# 17126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 17126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      )
    saved_sym = sym;
  break;

       default:
  break;
       }
   }
 else
   {
     if (((sym->st_info) & 0xF) != 2)
       continue;

     saved_sym = sym;
     break;
   }
      }

  printf (" (%s: %s)\n",
   is_open_attr ? gettext ("file") : gettext ("func"),
   saved_sym ? strtab + saved_sym->st_name : gettext ("<no symbol found>)"));
  return 1;
}

static bfd_boolean
print_gnu_build_attribute_description (Elf_Internal_Note * pnote,
           FILE * file)
{
  static unsigned long global_offset = 0;
  unsigned long offset;
  unsigned int desc_size = is_32bit_elf ? 4 : 8;
  bfd_boolean is_open_attr = pnote->type == 0x100;

  if (pnote->descsz == 0)
    {
      if (is_open_attr)
 {
   printf (gettext ("    Applies from offset %#lx\n"), global_offset);
   return 1;
 }
      else
 {
   printf (gettext ("    Applies to func at %#lx"), global_offset);
   return print_symbol_for_build_attribute (file, global_offset, is_open_attr);
 }
    }

  if (pnote->descsz != desc_size)
    {
      error (gettext ("    <invalid description size: %lx>\n"), pnote->descsz);
      printf (gettext ("    <invalid descsz>"));
      return 0;
    }

  offset = byte_get ((unsigned char *) pnote->descdata, desc_size);

  if (is_open_attr)
    {
      printf (gettext ("    Applies from offset %#lx"), offset);
      global_offset = offset;
    }
  else
    {
      printf (gettext ("    Applies to func at %#lx"), offset);
    }

  return print_symbol_for_build_attribute (file, offset, is_open_attr);
}

static bfd_boolean
print_gnu_build_attribute_name (Elf_Internal_Note * pnote)
{
  static const char string_expected [2] = { '$', 0 };
  static const char number_expected [2] = { '*', 0 };
  static const char bool_expected [3] = { '+', '!', 0 };
  char name_type;
  char name_attribute;
  const char * expected_types;
  const char * name = pnote->namedata;
  const char * text;
  signed int left;

  if (name == 
# 17208 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0) 
# 17208 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  || pnote->namesz < 2)
    {
      error (gettext ("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
      print_symbol (-20, gettext ("  <corrupt name>"));
      return 0;
    }

  left = 20;


  if (name[0] == 'G' && name[1] == 'A')
    {
      printf ("GA");
      name += 2;
      left -= 2;
    }

  switch ((name_type = * name))
    {
    case '*':
    case '$':
    case '+':
    case '!':
      printf ("%c", * name);
      left --;
      break;
    default:
      error (gettext ("unrecognised attribute type in name field: %d\n"), name_type);
      print_symbol (-20, gettext ("<unknown name type>"));
      return 0;
    }

  ++ name;
  text = 
# 17241 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
        ((void *)0)
# 17241 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
            ;

  switch ((name_attribute = * name))
    {
    case 1:
      text = gettext ("<version>");
      expected_types = string_expected;
      ++ name;
      break;
    case 2:
      text = gettext ("<stack prot>");
      expected_types = "!+*";
      ++ name;
      break;
    case 3:
      text = gettext ("<relro>");
      expected_types = bool_expected;
      ++ name;
      break;
    case 4:
      text = gettext ("<stack size>");
      expected_types = number_expected;
      ++ name;
      break;
    case 5:
      text = gettext ("<tool>");
      expected_types = string_expected;
      ++ name;
      break;
    case 6:
      text = gettext ("<ABI>");
      expected_types = "$*";
      ++ name;
      break;
    case 7:
      text = gettext ("<PIC>");
      expected_types = number_expected;
      ++ name;
      break;
    case 8:
      text = gettext ("<short enum>");
      expected_types = bool_expected;
      ++ name;
      break;
    default:
      if ((_sch_istable[(* name) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;

   if (len > left && ! do_wide)
     len = left;
   printf ("%.*s:", len, name);
   left -= len;
   name += len;
 }
      else
 {
   static char tmpbuf [128];

   error (gettext ("unrecognised byte in name field: %d\n"), * name);
   sprintf (tmpbuf, gettext ("<unknown:_%d>"), * name);
   text = tmpbuf;
   name ++;
 }
      expected_types = "*$!+";
      break;
    }

  if (text)
    left -= printf ("%s", text);

  if (strchr (expected_types, name_type) == 
# 17312 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 17312 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               )
    warn (gettext ("attribute does not have an expected type (%c)\n"), name_type);

  if ((unsigned long)(name - pnote->namedata) > pnote->namesz)
    {
      error (gettext ("corrupt name field: namesz: %lu but parsing gets to %ld\n"),
      (unsigned long) pnote->namesz,
      (long) (name - pnote->namedata));
      return 0;
    }

  if (left < 1 && ! do_wide)
    return 1;

  switch (name_type)
    {
    case '*':
      {
 unsigned int bytes;
 unsigned long long val = 0;
 unsigned int shift = 0;
 char * decoded = 
# 17333 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 17333 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;

 bytes = pnote->namesz - (name - pnote->namedata);
 if (bytes > 0)



   -- bytes;

 if (bytes > sizeof (val))
   {
     fprintf (
# 17344 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             stderr
# 17344 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   , "namesz %lx name %p namedata %p\n",
       pnote->namesz, name, pnote->namedata);
     error (gettext ("corrupt numeric name field: too many bytes in the value: %x\n"),
     bytes);
     bytes = sizeof (val);
   }



 while (bytes --)
   {
     unsigned long byte = (* name ++) & 0xff;

     val |= byte << shift;
     shift += 8;
   }

 switch (name_attribute)
   {
   case 7:
     switch (val)
       {
       case 0: decoded = "static"; break;
       case 1: decoded = "pic"; break;
       case 2: decoded = "PIC"; break;
       case 3: decoded = "pie"; break;
       case 4: decoded = "PIE"; break;
       default: break;
       }
     break;
   case 2:
     switch (val)
       {

       case 0: decoded = "off"; break;
       case 1: decoded = "on"; break;
       case 2: decoded = "all"; break;
       case 3: decoded = "strong"; break;
       case 4: decoded = "explicit"; break;
       default: break;
       }
     break;
   default:
     break;
   }

 if (decoded != 
# 17390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 17390 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
   {
     print_symbol (-left, decoded);
     left = 0;
   }
 else if (val == 0)
   {
     printf ("0x0");
     left -= 3;
   }
 else
   {
     if (do_wide)
       left -= printf ("0x%llx", val);
     else
       left -= printf ("0x%-.*llx", left, val);
   }
      }
      break;
    case '$':
      left -= print_symbol (- left, name);
      break;
    case '+':
      left -= print_symbol (- left, "true");
      break;
    case '!':
      left -= print_symbol (- left, "false");
      break;
    }

  if (do_wide && left > 0)
    printf ("%-*s", left, " ");

  return 1;
}







static bfd_boolean
process_note (Elf_Internal_Note * pnote,
       FILE * file)
{
  const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
  const char * nt;

  if (pnote->namesz == 0)


    nt = get_note_type (pnote->type);

  else if ((strncmp ((pnote->namedata), ("GNU"), sizeof ("GNU") - 1) == 0))

    nt = get_gnu_elf_note_type (pnote->type);

  else if ((strncmp ((pnote->namedata), ("FreeBSD"), sizeof ("FreeBSD") - 1) == 0))

    nt = get_freebsd_elfcore_note_type (pnote->type);

  else if ((strncmp ((pnote->namedata), ("NetBSD-CORE"), sizeof ("NetBSD-CORE") - 1) == 0))

    nt = get_netbsd_elfcore_note_type (pnote->type);

  else if ((strncmp ((pnote->namedata), ("NetBSD"), sizeof ("NetBSD") - 1) == 0))

    return process_netbsd_elf_note (pnote);

  else if ((strncmp ((pnote->namedata), ("SPU/"), (4)) == 0))
    {

      nt = pnote->namedata + 4;
      name = "SPU";
    }

  else if ((strncmp ((pnote->namedata), ("IPF/VMS"), sizeof ("IPF/VMS") - 1) == 0))

    nt = get_ia64_vms_note_type (pnote->type);

  else if ((strncmp ((pnote->namedata), ("stapsdt"), sizeof ("stapsdt") - 1) == 0))
    nt = get_stapsdt_note_type (pnote->type);

  else


    nt = get_note_type (pnote->type);

  printf ("  ");

  if ((((strncmp ((pnote->namedata), ("GA"), sizeof ("GA") - 1) == 0)
 && strchr ("*$!+", pnote->namedata[2]) != 
# 17482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                          ((void *)0)
# 17482 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                              )
       || strchr ("*$!+", pnote->namedata[0]) != 
# 17483 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                ((void *)0)
# 17483 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                    )
      && (pnote->type == 0x100
   || pnote->type == 0x101))
    print_gnu_build_attribute_name (pnote);
  else
    print_symbol (-20, name);

  if (do_wide)
    printf (" 0x%08lx\t%s\t", pnote->descsz, nt);
  else
    printf (" 0x%08lx\t%s\n", pnote->descsz, nt);

  if ((strncmp ((pnote->namedata), ("IPF/VMS"), sizeof ("IPF/VMS") - 1) == 0))
    return print_ia64_vms_note (pnote);
  else if ((strncmp ((pnote->namedata), ("GNU"), sizeof ("GNU") - 1) == 0))
    return print_gnu_note (pnote);
  else if ((strncmp ((pnote->namedata), ("stapsdt"), sizeof ("stapsdt") - 1) == 0))
    return print_stapsdt_note (pnote);
  else if ((strncmp ((pnote->namedata), ("CORE"), sizeof ("CORE") - 1) == 0))
    return print_core_note (pnote);
  else if ((((strncmp ((pnote->namedata), ("GA"), sizeof ("GA") - 1) == 0)
      && strchr ("*$!+", pnote->namedata[2]) != 
# 17504 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                               ((void *)0)
# 17504 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                   )
     || strchr ("*$!+", pnote->namedata[0]) != 
# 17505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              ((void *)0)
# 17505 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                  )
    && (pnote->type == 0x100
        || pnote->type == 0x101))
    return print_gnu_build_attribute_description (pnote, file);

  if (pnote->descsz)
    {
      unsigned long i;

      printf (gettext ("   description data: "));
      for (i = 0; i < pnote->descsz; i++)
 printf ("%02x ", pnote->descdata[i]);
    }

  if (do_wide)
    printf ("\n");

  return 1;
}

static bfd_boolean
process_notes_at (FILE * file,
    Elf_Internal_Shdr * section,
    bfd_vma offset,
    bfd_vma length)
{
  Elf_External_Note * pnotes;
  Elf_External_Note * external;
  char * end;
  bfd_boolean res = 1;

  if (length <= 0)
    return 0;

  if (section)
    {
      pnotes = (Elf_External_Note *) get_section_contents (section, file);
      if (pnotes)
 {
   if (! apply_relocations (file, section, (unsigned char *) pnotes, length, 
# 17544 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                            ((void *)0)
# 17544 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                                , 
# 17544 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                                  ((void *)0)
# 17544 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                                      ))
     return 0;
 }
    }
  else
    pnotes = (Elf_External_Note *) get_data (
# 17549 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                            ((void *)0)
# 17549 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                , file, offset, 1, length,
          gettext ("notes"));
  if (pnotes == 
# 17551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 17551 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    return 0;

  external = pnotes;

  if (section)
    printf (gettext ("\nDisplaying notes found in: %s\n"), printable_section_name (section));
  else
    printf (gettext ("\nDisplaying notes found at file offset 0x%08lx with length 0x%08lx:\n"),
     (unsigned long) offset, (unsigned long) length);

  printf (gettext ("  %-20s %10s\tDescription\n"), gettext ("Owner"), gettext ("Data size"));

  end = (char *) pnotes + length;
  while ((char *) external < end)
    {
      Elf_Internal_Note inote;
      size_t min_notesz;
      char *next;
      char * temp = 
# 17570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 17570 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       ;
      size_t data_remaining = end - (char *) external;

      if (!is_ia64_vms ())
 {


   min_notesz = 
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               __builtin_offsetof (
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               Elf_External_Note
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               , 
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               name
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               )
# 17577 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                 ;
   if (data_remaining < min_notesz)
     {
       warn (gettext ("Corrupt note: only %d bytes remain, not enough for a full note\n"),
      (int) data_remaining);
       break;
     }
   inote.type = byte_get (external->type, sizeof (external->type));
   inote.namesz = byte_get (external->namesz, sizeof (external->namesz));
   inote.namedata = external->name;
   inote.descsz = byte_get (external->descsz, sizeof (external->descsz));
   inote.descdata = inote.namedata + (((inote.namesz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2))));

   if (inote.descdata < (char *) pnotes || inote.descdata > end)
     {
       warn (gettext ("Corrupt note: name size is too big: (got: %lx, expected no more than: %lx)\n"),
      inote.namesz, (long)(end - inote.namedata));
       inote.descdata = inote.namedata;
       inote.namesz = 0;
     }

   inote.descpos = offset + (inote.descdata - (char *) pnotes);
   next = inote.descdata + (((inote.descsz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2))));
 }
      else
 {
   Elf64_External_VMS_Note *vms_external;



   min_notesz = 
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               __builtin_offsetof (
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               Elf64_External_VMS_Note
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               , 
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               name
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               )
# 17607 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                       ;
   if (data_remaining < min_notesz)
     {
       warn (gettext ("Corrupt note: only %d bytes remain, not enough for a full note\n"),
      (int) data_remaining);
       break;
     }

   vms_external = (Elf64_External_VMS_Note *) external;
   inote.type = byte_get (vms_external->type, sizeof (vms_external->type));
   inote.namesz = byte_get (vms_external->namesz, sizeof (vms_external->namesz));
   inote.namedata = vms_external->name;
   inote.descsz = byte_get (vms_external->descsz, sizeof (vms_external->descsz));
   inote.descdata = inote.namedata + (((inote.namesz) + ((bfd_vma) 1 << (3)) - 1) & (-((bfd_vma) 1 << (3))));
   inote.descpos = offset + (inote.descdata - (char *) pnotes);
   next = inote.descdata + (((inote.descsz) + ((bfd_vma) 1 << (3)) - 1) & (-((bfd_vma) 1 << (3))));
 }

      if (inote.descdata < (char *) external + min_notesz
   || next < (char *) external + min_notesz

   || inote.namedata + inote.namesz < inote.namedata
   || inote.descdata + inote.descsz < inote.descdata
   || data_remaining < (size_t)(next - (char *) external))
 {
   warn (gettext ("note with invalid namesz and/or descsz found at offset 0x%lx\n"),
  (unsigned long) ((char *) external - (char *) pnotes));
   warn (gettext (" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n"),
  inote.type, inote.namesz, inote.descsz);
   break;
 }

      external = (Elf_External_Note *) next;





      if (inote.namedata[inote.namesz - 1] != '\0')
 {
   temp = (char *) malloc (inote.namesz + 1);
   if (temp == 
# 17648 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              ((void *)0)
# 17648 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  )
     {
       error (gettext ("Out of memory allocating space for inote name\n"));
       res = 0;
       break;
     }

   memcpy (temp, inote.namedata, inote.namesz);
   temp[inote.namesz] = 0;


   inote.namedata = temp;
 }

      if (! process_note (& inote, file))
 res = 0;

      if (temp != 
# 17665 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 17665 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   free (temp);
   temp = 
# 17668 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         ((void *)0)
# 17668 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
             ;
 }
    }

  free (pnotes);

  return res;
}

static bfd_boolean
process_corefile_note_segments (FILE * file)
{
  Elf_Internal_Phdr * segment;
  unsigned int i;
  bfd_boolean res = 1;

  if (! get_program_headers (file))
    return 1;

  for (i = 0, segment = program_headers;
       i < elf_header.e_phnum;
       i++, segment++)
    {
      if (segment->p_type == 4)
 if (! process_notes_at (file, 
# 17692 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 17692 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ,
    (bfd_vma) segment->p_offset,
    (bfd_vma) segment->p_filesz))
   res = 0;
    }

  return res;
}

static bfd_boolean
process_v850_notes (FILE * file, bfd_vma offset, bfd_vma length)
{
  Elf_External_Note * pnotes;
  Elf_External_Note * external;
  char * end;
  bfd_boolean res = 1;

  if (length <= 0)
    return 0;

  pnotes = (Elf_External_Note *) get_data (
# 17712 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                          ((void *)0)
# 17712 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                              , file, offset, 1, length,
                                           gettext ("v850 notes"));
  if (pnotes == 
# 17714 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 17714 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   )
    return 0;

  external = pnotes;
  end = (char*) pnotes + length;

  printf (gettext ("\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n"),
   (unsigned long) offset, (unsigned long) length);

  while ((char *) external + sizeof (Elf_External_Note) < end)
    {
      Elf_External_Note * next;
      Elf_Internal_Note inote;

      inote.type = byte_get (external->type, sizeof (external->type));
      inote.namesz = byte_get (external->namesz, sizeof (external->namesz));
      inote.namedata = external->name;
      inote.descsz = byte_get (external->descsz, sizeof (external->descsz));
      inote.descdata = inote.namedata + (((inote.namesz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2))));
      inote.descpos = offset + (inote.descdata - (char *) pnotes);

      if (inote.descdata < (char *) pnotes || inote.descdata >= end)
 {
   warn (gettext ("Corrupt note: name size is too big: %lx\n"), inote.namesz);
   inote.descdata = inote.namedata;
   inote.namesz = 0;
 }

      next = (Elf_External_Note *) (inote.descdata + (((inote.descsz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2)))));

      if ( ((char *) next > end)
   || ((char *) next < (char *) pnotes))
 {
   warn (gettext ("corrupt descsz found in note at offset 0x%lx\n"),
  (unsigned long) ((char *) external - (char *) pnotes));
   warn (gettext (" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
  inote.type, inote.namesz, inote.descsz);
   break;
 }

      external = next;


      if ( inote.namedata + inote.namesz > end
   || inote.namedata + inote.namesz < inote.namedata)
        {
          warn (gettext ("corrupt namesz found in note at offset 0x%lx\n"),
                (unsigned long) ((char *) external - (char *) pnotes));
          warn (gettext (" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
                inote.type, inote.namesz, inote.descsz);
          break;
        }

      printf ("  %s: ", get_v850_elf_note_type (inote.type));

      if (! print_v850_note (& inote))
 {
   res = 0;
   printf ("<corrupt sizes: namesz: %lx, descsz: %lx>\n",
    inote.namesz, inote.descsz);
 }
    }

  free (pnotes);

  return res;
}

static bfd_boolean
process_note_sections (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned long i;
  unsigned int n = 0;
  bfd_boolean res = 1;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && section != 
# 17791 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 17791 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               ;
       i++, section++)
    {
      if (section->sh_type == 7)
 {
   if (! process_notes_at (file, section,
      (bfd_vma) section->sh_offset,
      (bfd_vma) section->sh_size))
     res = 0;
   n++;
 }

      if (( elf_header.e_machine == 36
    || elf_header.e_machine == 87
    || elf_header.e_machine == 0x9080)
   && section->sh_type == 0xa0000000)
 {
   if (! process_v850_notes (file,
        (bfd_vma) section->sh_offset,
        (bfd_vma) section->sh_size))
     res = 0;
   n++;
 }
    }

  if (n == 0)

    return process_corefile_note_segments (file);

  return res;
}

static bfd_boolean
process_notes (FILE * file)
{

  if (! do_notes)
    return 1;

  if (elf_header.e_type != 4)
    return process_note_sections (file);


  if (elf_header.e_phnum > 0)
    return process_corefile_note_segments (file);

  printf (gettext ("No note segments present in the core file.\n"));
  return 1;
}

static unsigned char *
display_public_gnu_attributes (unsigned char * start,
          const unsigned char * const end)
{
  printf (gettext ("  Unknown GNU attribute: %s\n"), start);

  start += strnlen ((char *) start, end - start);
  display_raw_attribute (start, end);

  return (unsigned char *) end;
}

static unsigned char *
display_generic_attribute (unsigned char * start,
      unsigned int tag,
      const unsigned char * const end)
{
  if (tag == 0)
    return (unsigned char *) end;

  return display_tag_value (tag, start, end);
}

static bfd_boolean
process_arch_specific (FILE * file)
{
  if (! do_arch)
    return 1;

  switch (elf_header.e_machine)
    {
    case 45:
    case 93:
    case 195:
      return process_attributes (file, "ARC", 0x70000001,
     display_arc_attribute,
     display_generic_attribute);
    case 40:
      return process_attributes (file, "aeabi", 0x70000003,
     display_arm_attribute,
     display_generic_attribute);

    case 8:
    case 10:
      return process_mips_specific (file);

    case 105:
     return process_attributes (file, "mspabi", 0x70000003,
     display_msp430x_attribute,
     display_generic_attribute);

    case 167:
      return process_nds32_specific (file);

    case 20:
    case 21:
      return process_attributes (file, 
# 17897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 17897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          , 0x6ffffff5, 
# 17897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                ((void *)0)
# 17897 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                    ,
     display_power_gnu_attribute);

    case 22:
    case 0xa390:
      return process_attributes (file, 
# 17902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 17902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          , 0x6ffffff5, 
# 17902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                ((void *)0)
# 17902 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                    ,
     display_s390_gnu_attribute);

    case 2:
    case 18:
    case 43:
      return process_attributes (file, 
# 17908 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                      ((void *)0)
# 17908 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                          , 0x6ffffff5, 
# 17908 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                                ((void *)0)
# 17908 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                    ,
     display_sparc_gnu_attribute);

    case 140:
      return process_attributes (file, "c6xabi", 0x70000003,
     display_tic6x_attribute,
     display_generic_attribute);

    default:
      return process_attributes (file, "gnu", 0x6ffffff5,
     display_public_gnu_attributes,
     display_generic_attribute);
    }
}

static bfd_boolean
get_file_header (FILE * file)
{

  if (fread (elf_header.e_ident, 16, 1, file) != 1)
    return 0;


  switch (elf_header.e_ident[5])
    {
    default:
    case 0:
    case 1:
      byte_get = byte_get_little_endian;
      byte_put = byte_put_little_endian;
      break;
    case 2:
      byte_get = byte_get_big_endian;
      byte_put = byte_put_big_endian;
      break;
    }


  is_32bit_elf = (elf_header.e_ident[4] != 2);


  if (is_32bit_elf)
    {
      Elf32_External_Ehdr ehdr32;

      if (fread (ehdr32.e_type, sizeof (ehdr32) - 16, 1, file) != 1)
 return 0;

      elf_header.e_type = byte_get (ehdr32.e_type, sizeof (ehdr32.e_type));
      elf_header.e_machine = byte_get (ehdr32.e_machine, sizeof (ehdr32.e_machine));
      elf_header.e_version = byte_get (ehdr32.e_version, sizeof (ehdr32.e_version));
      elf_header.e_entry = byte_get (ehdr32.e_entry, sizeof (ehdr32.e_entry));
      elf_header.e_phoff = byte_get (ehdr32.e_phoff, sizeof (ehdr32.e_phoff));
      elf_header.e_shoff = byte_get (ehdr32.e_shoff, sizeof (ehdr32.e_shoff));
      elf_header.e_flags = byte_get (ehdr32.e_flags, sizeof (ehdr32.e_flags));
      elf_header.e_ehsize = byte_get (ehdr32.e_ehsize, sizeof (ehdr32.e_ehsize));
      elf_header.e_phentsize = byte_get (ehdr32.e_phentsize, sizeof (ehdr32.e_phentsize));
      elf_header.e_phnum = byte_get (ehdr32.e_phnum, sizeof (ehdr32.e_phnum));
      elf_header.e_shentsize = byte_get (ehdr32.e_shentsize, sizeof (ehdr32.e_shentsize));
      elf_header.e_shnum = byte_get (ehdr32.e_shnum, sizeof (ehdr32.e_shnum));
      elf_header.e_shstrndx = byte_get (ehdr32.e_shstrndx, sizeof (ehdr32.e_shstrndx));
    }
  else
    {
      Elf64_External_Ehdr ehdr64;





      if (sizeof (bfd_vma) < 8)
 {
   error (gettext ("This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n")
                                                            );
   return 0;
 }

      if (fread (ehdr64.e_type, sizeof (ehdr64) - 16, 1, file) != 1)
 return 0;

      elf_header.e_type = byte_get (ehdr64.e_type, sizeof (ehdr64.e_type));
      elf_header.e_machine = byte_get (ehdr64.e_machine, sizeof (ehdr64.e_machine));
      elf_header.e_version = byte_get (ehdr64.e_version, sizeof (ehdr64.e_version));
      elf_header.e_entry = byte_get (ehdr64.e_entry, sizeof (ehdr64.e_entry));
      elf_header.e_phoff = byte_get (ehdr64.e_phoff, sizeof (ehdr64.e_phoff));
      elf_header.e_shoff = byte_get (ehdr64.e_shoff, sizeof (ehdr64.e_shoff));
      elf_header.e_flags = byte_get (ehdr64.e_flags, sizeof (ehdr64.e_flags));
      elf_header.e_ehsize = byte_get (ehdr64.e_ehsize, sizeof (ehdr64.e_ehsize));
      elf_header.e_phentsize = byte_get (ehdr64.e_phentsize, sizeof (ehdr64.e_phentsize));
      elf_header.e_phnum = byte_get (ehdr64.e_phnum, sizeof (ehdr64.e_phnum));
      elf_header.e_shentsize = byte_get (ehdr64.e_shentsize, sizeof (ehdr64.e_shentsize));
      elf_header.e_shnum = byte_get (ehdr64.e_shnum, sizeof (ehdr64.e_shnum));
      elf_header.e_shstrndx = byte_get (ehdr64.e_shstrndx, sizeof (ehdr64.e_shstrndx));
    }

  if (elf_header.e_shoff)
    {


      if (is_32bit_elf)
 get_32bit_section_headers (file, 1);
      else
 get_64bit_section_headers (file, 1);
    }

  return 1;
}






static bfd_boolean
process_object (char * file_name, FILE * file)
{
  unsigned int i;
  bfd_boolean res = 1;

  if (! get_file_header (file))
    {
      error (gettext ("%s: Failed to read file header\n"), file_name);
      return 0;
    }


  for (i = (sizeof (version_info) / sizeof ((version_info)[0])); i--;)
    version_info[i] = 0;

  for (i = (sizeof (dynamic_info) / sizeof ((dynamic_info)[0])); i--;)
    dynamic_info[i] = 0;
  dynamic_info_DT_GNU_HASH = 0;


  if (show_name)
    printf (gettext ("\nFile: %s\n"), file_name);





  if (num_dump_sects > num_cmdline_dump_sects)
    memset (dump_sects, 0, num_dump_sects * sizeof (* dump_sects));

  if (num_cmdline_dump_sects > 0)
    {
      if (num_dump_sects == 0)

 request_dump_bynumber (num_cmdline_dump_sects, 0);

      
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ((void) sizeof ((
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     num_dump_sects >= num_cmdline_dump_sects
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ) ? 1 : 0), __extension__ ({ if (
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     num_dump_sects >= num_cmdline_dump_sects
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     ) ; else __assert_fail (
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
     "num_dump_sects >= num_cmdline_dump_sects"
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
     , "/doner/binutils/binutils-7a31b38/binutils/readelf.c", 18058, __extension__ __PRETTY_FUNCTION__); }))
# 18058 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                      ;
      memcpy (dump_sects, cmdline_dump_sects,
       num_cmdline_dump_sects * sizeof (* dump_sects));
    }

  if (! process_file_header ())
    return 0;

  if (! process_section_headers (file))
    {

      do_unwind = do_version = do_dump = do_arch = 0;

      if (! do_using_dynamic)
 do_syms = do_dyn_syms = do_reloc = 0;
    }

  if (! process_section_groups (file))

    do_unwind = 0;

  if (process_program_headers (file))
    process_dynamic_section (file);
  else
    res = 0;

  if (! process_relocs (file))
    res = 0;

  if (! process_unwind (file))
    res = 0;

  if (! process_symbol_table (file))
    res = 0;

  if (! process_syminfo (file))
    res = 0;

  if (! process_version_sections (file))
    res = 0;

  if (! process_section_contents (file))
    res = 0;

  if (! process_notes (file))
    res = 0;

  if (! process_gnu_liblist (file))
    res = 0;

  if (! process_arch_specific (file))
    res = 0;

  if (program_headers)
    {
      free (program_headers);
      program_headers = 
# 18114 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18114 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }

  if (section_headers)
    {
      free (section_headers);
      section_headers = 
# 18120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18120 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }

  if (string_table)
    {
      free (string_table);
      string_table = 
# 18126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 18126 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
      string_table_length = 0;
    }

  if (dynamic_strings)
    {
      free (dynamic_strings);
      dynamic_strings = 
# 18133 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18133 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
      dynamic_strings_length = 0;
    }

  if (dynamic_symbols)
    {
      free (dynamic_symbols);
      dynamic_symbols = 
# 18140 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18140 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
      num_dynamic_syms = 0;
    }

  if (dynamic_syminfo)
    {
      free (dynamic_syminfo);
      dynamic_syminfo = 
# 18147 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18147 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }

  if (dynamic_section)
    {
      free (dynamic_section);
      dynamic_section = 
# 18153 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18153 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           ;
    }

  if (section_headers_groups)
    {
      free (section_headers_groups);
      section_headers_groups = 
# 18159 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                              ((void *)0)
# 18159 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                  ;
    }

  if (section_groups)
    {
      struct group_list * g;
      struct group_list * next;

      for (i = 0; i < group_count; i++)
 {
   for (g = section_groups [i].root; g != 
# 18169 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                         ((void *)0)
# 18169 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                             ; g = next)
     {
       next = g->next;
       free (g);
     }
 }

      free (section_groups);
      section_groups = 
# 18177 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                      ((void *)0)
# 18177 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                          ;
    }

  free_debug_memory ();

  return res;
}





static bfd_boolean
process_archive (char * file_name, FILE * file, bfd_boolean is_thin_archive)
{
  struct archive_info arch;
  struct archive_info nested_arch;
  size_t got;
  bfd_boolean ret = 1;

  show_name = 1;


  arch.file_name = 
# 18200 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 18200 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ;
  arch.file = 
# 18201 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 18201 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 ;
  arch.index_array = 
# 18202 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 18202 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
  arch.sym_table = 
# 18203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 18203 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ;
  arch.longnames = 
# 18204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  ((void *)0)
# 18204 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                      ;




  nested_arch.file_name = 
# 18209 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 18209 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             ;
  nested_arch.file = 
# 18210 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                    ((void *)0)
# 18210 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        ;
  nested_arch.index_array = 
# 18211 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 18211 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               ;
  nested_arch.sym_table = 
# 18212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 18212 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             ;
  nested_arch.longnames = 
# 18213 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 18213 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             ;

  if (setup_archive (&arch, file_name, file, is_thin_archive, do_archive_index) != 0)
    {
      ret = 0;
      goto out;
    }

  if (do_archive_index)
    {
      if (arch.sym_table == 
# 18223 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 18223 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
 error (gettext ("%s: unable to dump the index as none was found\n"), file_name);
      else
 {
   unsigned long i, l;
   unsigned long current_pos;

   printf (gettext ("Index of archive %s: (%lu entries, 0x%lx bytes in the symbol table)\n"),
    file_name, (unsigned long) arch.index_num, arch.sym_size);
   current_pos = ftell (file);

   for (i = l = 0; i < arch.index_num; i++)
     {
       if ((i == 0) || ((i > 0) && (arch.index_array[i] != arch.index_array[i - 1])))
         {
           char * member_name;

    member_name = get_archive_member_name_at (&arch, arch.index_array[i], &nested_arch);

                  if (member_name != 
# 18242 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                    ((void *)0)
# 18242 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        )
                    {
               char * qualified_name = make_qualified_name (&arch, &nested_arch, member_name);

                      if (qualified_name != 
# 18246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                           ((void *)0)
# 18246 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                               )
                        {
            printf (gettext ("Contents of binary %s at offset "), qualified_name);
     (void) print_vma (arch.index_array[i], PREFIX_HEX);
     putchar ('\n');
            free (qualified_name);
          }
      }
  }

       if (l >= arch.sym_size)
  {
    error (gettext ("%s: end of the symbol table reached before the end of the index\n"),
    file_name);
    ret = 0;
    break;
  }

       printf ("\t%.*s\n", (int) (arch.sym_size - l), arch.sym_table + l);
       l += strnlen (arch.sym_table + l, arch.sym_size - l) + 1;
     }

   if (arch.uses_64bit_indicies)
     l = (l + 7) & ~ 7;
   else
     l += l & 1;

   if (l < arch.sym_size)
     {
       error (gettext ("%s: %ld bytes remain in the symbol table, but without corresponding entries in the index table\n"),
       file_name, arch.sym_size - l);
       ret = 0;
     }

   if (fseek (file, current_pos, 
# 18280 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                0
# 18280 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                        ) != 0)
     {
       error (gettext ("%s: failed to seek back to start of object files in the archive\n"), file_name);
       ret = 0;
       goto out;
     }
 }

      if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
   && !do_segments && !do_header && !do_dump && !do_version
   && !do_histogram && !do_debugging && !do_arch && !do_notes
   && !do_section_groups && !do_dyn_syms)
 {
   ret = 1;
   goto out;
 }
    }

  while (1)
    {
      char * name;
      size_t namelen;
      char * qualified_name;


      if (fseek (file, arch.next_arhdr_offset, 
# 18305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                              0
# 18305 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                      ) != 0)
        {
          error (gettext ("%s: failed to seek to next archive header\n"), file_name);
          return 0;
        }
      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, file);
      if (got != sizeof arch.arhdr)
        {
          if (got == 0)
     break;
          error (gettext ("%s: failed to read archive header\n"), file_name);
          ret = 0;
          break;
        }
      if (memcmp (arch.arhdr.ar_fmag, "`\012", 2) != 0)
        {
          error (gettext ("%s: did not find a valid archive header\n"), arch.file_name);
          ret = 0;
          break;
        }

      arch.next_arhdr_offset += sizeof arch.arhdr;

      archive_file_size = strtoul (arch.arhdr.ar_size, 
# 18328 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                      ((void *)0)
# 18328 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                          , 10);
      if (archive_file_size & 01)
        ++archive_file_size;

      name = get_archive_member_name (&arch, &nested_arch);
      if (name == 
# 18333 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                 ((void *)0)
# 18333 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                     )
 {
   error (gettext ("%s: bad archive file name\n"), file_name);
   ret = 0;
   break;
 }
      namelen = strlen (name);

      qualified_name = make_qualified_name (&arch, &nested_arch, name);
      if (qualified_name == 
# 18342 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 18342 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
 {
   error (gettext ("%s: bad archive file name\n"), file_name);
   ret = 0;
   break;
 }

      if (is_thin_archive && arch.nested_member_origin == 0)
        {

          FILE * member_file;
          char * member_file_name = adjust_relative_path (file_name, name, namelen);

          if (member_file_name == 
# 18355 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                 ((void *)0)
# 18355 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                     )
            {
              ret = 0;
              break;
            }

          member_file = fopen (member_file_name, "rb");
          if (member_file == 
# 18362 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            ((void *)0)
# 18362 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )
            {
              error (gettext ("Input file '%s' is not readable.\n"), member_file_name);
              free (member_file_name);
              ret = 0;
              break;
            }

          archive_file_offset = arch.nested_member_origin;

          if (! process_object (qualified_name, member_file))
     ret = 0;

          fclose (member_file);
          free (member_file_name);
        }
      else if (is_thin_archive)
        {

   if (nested_arch.file == 
# 18381 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                          ((void *)0)
# 18381 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                              )
     {
       error (gettext ("%s: contains corrupt thin archive: %s\n"),
       file_name, name);
       ret = 0;
       break;
     }


          archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;



          if (fseek (nested_arch.file, archive_file_offset, 
# 18394 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                                                           0
# 18394 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                                                   ) != 0)
            {
              error (gettext ("%s: failed to seek to archive member.\n"), nested_arch.file_name);
              ret = 0;
              break;
            }

          if (! process_object (qualified_name, nested_arch.file))
     ret = 0;
        }
      else
        {
          archive_file_offset = arch.next_arhdr_offset;
          arch.next_arhdr_offset += archive_file_size;

          if (! process_object (qualified_name, file))
     ret = 0;
        }

      if (dump_sects != 
# 18413 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                       ((void *)0)
# 18413 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           )
 {
   free (dump_sects);
   dump_sects = 
# 18416 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
               ((void *)0)
# 18416 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                   ;
   num_dump_sects = 0;
 }

      free (qualified_name);
    }

 out:
  if (nested_arch.file != 
# 18424 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                         ((void *)0)
# 18424 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                             )
    fclose (nested_arch.file);
  release_archive (&nested_arch);
  release_archive (&arch);

  return ret;
}

static bfd_boolean
process_file (char * file_name)
{
  FILE * file;
  struct stat statbuf;
  char armag[8];
  bfd_boolean ret = 1;

  if (stat (file_name, &statbuf) < 0)
    {
      if (
# 18442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
         (*__errno_location ()) 
# 18442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
               == 
# 18442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                  2
# 18442 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                        )
 error (gettext ("'%s': No such file\n"), file_name);
      else
 error (gettext ("Could not locate '%s'.  System error message: %s\n"),
        file_name, strerror (
# 18446 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                            (*__errno_location ())
# 18446 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                 ));
      return 0;
    }

  if (! 
# 18450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       ((((
# 18450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
       statbuf.st_mode
# 18450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
       )) & 0170000) == (0100000))
# 18450 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                )
    {
      error (gettext ("'%s' is not an ordinary file\n"), file_name);
      return 0;
    }

  file = fopen (file_name, "rb");
  if (file == 
# 18457 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
             ((void *)0)
# 18457 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                 )
    {
      error (gettext ("Input file '%s' is not readable.\n"), file_name);
      return 0;
    }

  if (fread (armag, 8, 1, file) != 1)
    {
      error (gettext ("%s: Failed to read file's magic number\n"), file_name);
      fclose (file);
      return 0;
    }

  current_file_size = (bfd_size_type) statbuf.st_size;

  if (memcmp (armag, "!<arch>\012", 8) == 0)
    {
      if (! process_archive (file_name, file, 0))
 ret = 0;
    }
  else if (memcmp (armag, "!<thin>\012", 8) == 0)
    {
      if ( ! process_archive (file_name, file, 1))
 ret = 0;
    }
  else
    {
      if (do_archive_index)
 error (gettext ("File %s is not an archive so its index cannot be displayed.\n"),
        file_name);

      rewind (file);
      archive_file_size = archive_file_offset = 0;

      if (! process_object (file_name, file))
 ret = 0;
    }

  fclose (file);
  current_file_size = 0;

  return ret;
}
# 18520 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
int
main (int argc, char ** argv)
{
  int err;


  setlocale (
# 18526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            5
# 18526 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       , "");


  setlocale (
# 18529 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            0
# 18529 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                    , "");

  bindtextdomain ("binutils", "/usr/local/share/locale");
  textdomain ("binutils");

  expandargv (&argc, &argv);

  parse_args (argc, argv);

  if (num_dump_sects > 0)
    {

      cmdline_dump_sects = (dump_type *)
          malloc (num_dump_sects * sizeof (* dump_sects));
      if (cmdline_dump_sects == 
# 18543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                               ((void *)0)
# 18543 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                   )
 error (gettext ("Out of memory allocating dump request table.\n"));
      else
 {
   memcpy (cmdline_dump_sects, dump_sects,
    num_dump_sects * sizeof (* dump_sects));
   num_cmdline_dump_sects = num_dump_sects;
 }
    }

  if (optind < (argc - 1))
    show_name = 1;
  else if (optind >= argc)
    {
      warn (gettext ("Nothing to do.\n"));
      usage (
# 18558 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
            stderr
# 18558 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                  );
    }

  err = 0;
  while (optind < argc)
    if (! process_file (argv[optind++]))
      err = 1;

  if (dump_sects != 
# 18566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                   ((void *)0)
# 18566 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                       )
    free (dump_sects);
  if (cmdline_dump_sects != 
# 18568 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                           ((void *)0)
# 18568 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                               )
    free (cmdline_dump_sects);

  return err ? 
# 18571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
              1 
# 18571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                           : 
# 18571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c" 3 4
                             0
# 18571 "/doner/binutils/binutils-7a31b38/binutils/readelf.c"
                                         ;
}
