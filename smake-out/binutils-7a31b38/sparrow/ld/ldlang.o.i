# 1 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
# 1 "/doner/binutils/binutils-7a31b38/ld//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
# 21 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
# 1 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 1
# 28 "/doner/binutils/binutils-7a31b38/ld/sysdep.h"
# 1 "/doner/binutils/binutils-7a31b38/ld/config.h" 1
# 29 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2

# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 31 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 32 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 33 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 34 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2


# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 37 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 52 "/doner/binutils/binutils-7a31b38/ld/sysdep.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 53 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2



# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 57 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 68 "/doner/binutils/binutils-7a31b38/ld/sysdep.h"
# 1 "./../include/fopen-same.h" 1
# 69 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2



# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 73 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2







# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4



extern void _dl_mcount_wrapper_check (void *__selfpc) __attribute__ ((__nothrow__ , __leaf__));


# 28 "/usr/include/dlfcn.h" 2 3 4
# 44 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;











extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __attribute__ ((__nothrow__));



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) __attribute__ ((__nothrow__ , __leaf__));





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;





  __extension__ union
  {
    Dl_serpath dls_serpath[0];
    Dl_serpath __dls_serpath_pad[1];
  };



} Dl_serinfo;




# 81 "/doner/binutils/binutils-7a31b38/ld/sysdep.h" 2
# 22 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "../bfd/bfd.h" 1
# 42 "../bfd/bfd.h"
# 1 "./../include/ansidecl.h" 1
# 43 "../bfd/bfd.h" 2
# 1 "./../include/symcat.h" 1
# 44 "../bfd/bfd.h" 2
# 97 "../bfd/bfd.h"

# 97 "../bfd/bfd.h"
typedef long bfd_int64_t;
typedef unsigned long bfd_uint64_t;
# 115 "../bfd/bfd.h"
typedef unsigned long bfd_hostptr_t;


typedef struct bfd bfd;
# 129 "../bfd/bfd.h"
typedef int bfd_boolean;
# 141 "../bfd/bfd.h"
typedef unsigned long bfd_vma;
typedef long bfd_signed_vma;
typedef unsigned long bfd_size_type;
typedef unsigned long symvalue;
# 196 "../bfd/bfd.h"
typedef long file_ptr;
typedef unsigned long ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);




typedef unsigned int flagword;
typedef unsigned char bfd_byte;



typedef enum bfd_format
{
  bfd_unknown = 0,
  bfd_object,
  bfd_archive,
  bfd_core,
  bfd_type_end
}
bfd_format;




typedef unsigned long symindex;


typedef const struct reloc_howto_struct reloc_howto_type;
# 248 "../bfd/bfd.h"
typedef struct carsym
{
  char *name;
  file_ptr file_offset;
}
carsym;



struct orl
{
  char **name;
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;
  int namidx;
};


typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;


typedef struct bfd_section *sec_ptr;
# 326 "../bfd/bfd.h"
typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;



extern const char *bfd_get_stab_name (int);






struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int);


extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int, unsigned int);


extern void bfd_hash_table_free
  (struct bfd_hash_table *);





extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);


extern struct bfd_hash_entry *bfd_hash_insert
  (struct bfd_hash_table *, const char *, unsigned long);


extern void bfd_hash_rename
  (struct bfd_hash_table *, const char *, struct bfd_hash_entry *);


extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);


extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);




extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);




extern unsigned long bfd_hash_set_default_size (unsigned long);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG = 1 << 0,
  COMPRESS_DEBUG_GNU_ZLIB = COMPRESS_DEBUG | 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = COMPRESS_DEBUG | 1 << 2
};




struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 486 "../bfd/bfd.h"
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
# 509 "../bfd/bfd.h"
extern void _bfd_warn_deprecated (const char *, const char *, int, const char *);
# 545 "../bfd/bfd.h"
extern bfd_boolean bfd_cache_close
  (bfd *abfd);


extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);



bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);



bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);


struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_section_already_linked;
struct bfd_elf_version_tree;


extern bfd_boolean bfd_section_already_linked_table_init (void);
extern void bfd_section_already_linked_table_free (void);
extern bfd_boolean _bfd_handle_already_linked
  (struct bfd_section *, struct bfd_section_already_linked *,
   struct bfd_link_info *);



extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);



struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2,
  DYN_NO_ADD_NEEDED = 4,
  DYN_NO_NEEDED = 8
};

enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_stack_segment_size (bfd *, struct bfd_link_info *,
            const char *, bfd_vma);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char *, const char *,
   const char * const *, struct bfd_link_info *, struct bfd_section **);
extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
  (bfd *, struct bfd_link_info *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, enum dynamic_lib_link_class);
extern int bfd_elf_get_dyn_lib_class
  (bfd *);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern int bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
extern unsigned int _bfd_elf_default_action_discarded
  (struct bfd_section *);




extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);
# 707 "../bfd/bfd.h"
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);
# 724 "../bfd/bfd.h"
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
         bfd_size_type len));

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern struct bfd_section *
_bfd_nearby_section (bfd *, struct bfd_section *, bfd_vma);

extern void _bfd_fix_excluded_sec_syms
  (bfd *, struct bfd_link_info *);

extern unsigned bfd_m68k_mach_to_features (int);

extern int bfd_m68k_features_to_mach (unsigned);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern void bfd_elf_m68k_set_target_options (struct bfd_link_info *, int);

extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern bfd_boolean bfd_cr16_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);



extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **,
   struct bfd_section **, struct bfd_section **);



extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);



struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);



extern bfd_boolean bfd_xcoff_split_import_path
  (bfd *, const char *, const char **, const char **);
extern bfd_boolean bfd_xcoff_set_archive_import_path
  (struct bfd_link_info *, bfd *, const char *);
extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);


extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);




struct internal_syment;
union internal_auxent;


extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);


typedef enum
{
  BFD_ARM_VFP11_FIX_DEFAULT,
  BFD_ARM_VFP11_FIX_NONE,
  BFD_ARM_VFP11_FIX_SCALAR,
  BFD_ARM_VFP11_FIX_VECTOR
} bfd_arm_vfp11_fix;

extern void bfd_elf32_arm_init_maps
  (bfd *);

extern void bfd_elf32_arm_set_vfp11_fix
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_set_cortex_a8_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_vfp11_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


typedef enum
{
  BFD_ARM_STM32L4XX_FIX_NONE,
  BFD_ARM_STM32L4XX_FIX_DEFAULT,
  BFD_ARM_STM32L4XX_FIX_ALL
} bfd_arm_stm32l4xx_fix;

extern void bfd_elf32_arm_set_stm32l4xx_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_stm32l4xx_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_stm32l4xx_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *);

struct elf32_arm_params {
  char *thumb_entry_symbol;
  int byteswap_code;
  int target1_is_rel;
  char * target2_type;
  int fix_v4bx;
  int use_blx;
  bfd_arm_vfp11_fix vfp11_denorm_fix;
  bfd_arm_stm32l4xx_fix stm32l4xx_fix;
  int no_enum_size_warning;
  int no_wchar_size_warning;
  int pic_veneer;
  int fix_cortex_a8;
  int fix_arm1176;
  int merge_exidx_entries;
  int cmse_implib;
  bfd *in_implib_bfd;
};

void bfd_elf32_arm_set_target_params
  (bfd *, struct bfd_link_info *, struct elf32_arm_params *);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_keep_private_stub_output_sections
  (struct bfd_link_info *);







extern bfd_boolean bfd_is_arm_special_symbol_name
  (const char *, int);

extern void bfd_elf32_arm_set_byteswap_code
  (struct bfd_link_info *, int);

extern void bfd_elf32_arm_use_long_plt (void);


extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);


extern int elf32_arm_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_arm_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_arm_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *,
        struct bfd_section *, unsigned int),
   void (*) (void));
extern bfd_boolean elf32_arm_build_stubs
  (struct bfd_link_info *);


extern bfd_boolean elf32_arm_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);


extern bfd_boolean elf32_tic6x_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);

extern void bfd_elf64_aarch64_init_maps
  (bfd *);

extern void bfd_elf32_aarch64_init_maps
  (bfd *);

extern void bfd_elf64_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);

extern void bfd_elf32_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);






extern bfd_boolean bfd_is_aarch64_special_symbol_name
  (const char * name, int type);


extern int elf64_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf64_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf64_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf64_aarch64_build_stubs
  (struct bfd_link_info *);

extern int elf32_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf32_aarch64_build_stubs
  (struct bfd_link_info *);



extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);


extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);


extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);


extern bfd_boolean v850_elf_create_sections
  (struct bfd_link_info *);

extern bfd_boolean v850_elf_set_note
  (bfd *, unsigned int, unsigned int);


struct elf_internal_abiflags_v0;
extern struct elf_internal_abiflags_v0 *bfd_mips_elf_get_abiflags (bfd *);

void bfd_init (void);



extern unsigned int bfd_use_reserved_id;
bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target,
    void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
    void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
    void *stream,
    void *buf,
    file_ptr nbytes,
    file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
    void *stream),
    int (*stat_func) (struct bfd *abfd,
    void *stream,
    struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd_boolean bfd_close (bfd *abfd);

bfd_boolean bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);

bfd_boolean bfd_make_writable (bfd *abfd);

bfd_boolean bfd_make_readable (bfd *abfd);

void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
# 1241 "../bfd/bfd.h"
long bfd_get_mtime (bfd *abfd);

ufile_ptr bfd_get_size (bfd *abfd);

ufile_ptr bfd_get_file_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);




typedef struct bfd_section
{


  const char *name;


  unsigned int id;


  unsigned int index;


  struct bfd_section *next;


  struct bfd_section *prev;




  flagword flags;
# 1475 "../bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;







  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 1509 "../bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 1529 "../bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 1549 "../bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;


  struct relax_table *relax;


  int relax_count;
# 1568 "../bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  unsigned int alignment_power;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  unsigned char *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;





  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
  } map_head, map_tail;
} asection;




struct relax_table {

  bfd_vma addr;


  int size;
};





static inline bfd_boolean
bfd_set_section_userdata (bfd * abfd __attribute__ ((__unused__)), asection * ptr, void * val)
{
  ptr->userdata = val;
  return 1;
}

static inline bfd_boolean
bfd_set_section_vma (bfd * abfd __attribute__ ((__unused__)), asection * ptr, bfd_vma val)
{
  ptr->vma = ptr->lma = val;
  ptr->user_set_vma = 1;
  return 1;
}

static inline bfd_boolean
bfd_set_section_alignment (bfd * abfd __attribute__ ((__unused__)), asection * ptr, unsigned int val)
{
  ptr->alignment_power = val;
  return 1;
}




extern asection _bfd_std_section[4];
# 1856 "../bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);

int bfd_get_next_section_id (void);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_rename_section
   (bfd *abfd, asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);




bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);

bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1964 "../bfd/bfd.h"
  bfd_arch_vax,
  bfd_arch_i960,
# 1983 "../bfd/bfd.h"
  bfd_arch_or1k,



  bfd_arch_sparc,
# 2025 "../bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 2074 "../bfd/bfd.h"
  bfd_arch_i386,
# 2083 "../bfd/bfd.h"
  bfd_arch_l1om,


  bfd_arch_k1om,






  bfd_arch_iamcu,



  bfd_arch_we32k,
  bfd_arch_tahoe,
  bfd_arch_i860,
  bfd_arch_i370,
  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m88k,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_plugin,
  bfd_arch_powerpc,
# 2143 "../bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_z8k,


  bfd_arch_h8500,
  bfd_arch_sh,
# 2192 "../bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 2211 "../bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_w65,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_tic80,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 2264 "../bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,

  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 2311 "../bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_cr16c,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,

  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 2364 "../bfd/bfd.h"
  bfd_arch_xc16x,



  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,




  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,


  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_wasm32,

  bfd_arch_pru,

  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  bfd_boolean the_default;
  const struct bfd_arch_info * (*compatible)
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);

  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,
                 bfd_boolean code);

  const struct bfd_arch_info *next;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);

bfd_boolean bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (bfd *abfd);

unsigned long bfd_get_mach (bfd *abfd);

unsigned int bfd_arch_bits_per_byte (bfd *abfd);

unsigned int bfd_arch_bits_per_address (bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (bfd *abfd);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);



typedef enum bfd_reloc_status
{

  bfd_reloc_ok,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,





  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;


typedef struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

}
arelent;


enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};
struct bfd_symbol;

struct reloc_howto_struct
{






  unsigned int type;



  unsigned int rightshift;




  int size;



  unsigned int bitsize;


  bfd_boolean pc_relative;



  unsigned int bitpos;



  enum complain_overflow complain_on_overflow;





  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  char *name;
# 2597 "../bfd/bfd.h"
  bfd_boolean partial_inplace;
# 2607 "../bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;







  bfd_boolean pcrel_offset;
};
# 2647 "../bfd/bfd.h"
unsigned int bfd_get_reloc_size (reloc_howto_type *);

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,






  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,


  BFD_RELOC_I960_CALLJ,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 2939 "../bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_16DX_HA,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,
  BFD_RELOC_RISCV_32_PCREL,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5046 "../bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,


  BFD_RELOC_16C_NUM08,
  BFD_RELOC_16C_NUM08_C,
  BFD_RELOC_16C_NUM16,
  BFD_RELOC_16C_NUM16_C,
  BFD_RELOC_16C_NUM32,
  BFD_RELOC_16C_NUM32_C,
  BFD_RELOC_16C_DISP04,
  BFD_RELOC_16C_DISP04_C,
  BFD_RELOC_16C_DISP08,
  BFD_RELOC_16C_DISP08_C,
  BFD_RELOC_16C_DISP16,
  BFD_RELOC_16C_DISP16_C,
  BFD_RELOC_16C_DISP24,
  BFD_RELOC_16C_DISP24_C,
  BFD_RELOC_16C_DISP24a,
  BFD_RELOC_16C_DISP24a_C,
  BFD_RELOC_16C_REG04,
  BFD_RELOC_16C_REG04_C,
  BFD_RELOC_16C_REG04a,
  BFD_RELOC_16C_REG04a_C,
  BFD_RELOC_16C_REG14,
  BFD_RELOC_16C_REG14_C,
  BFD_RELOC_16C_REG16,
  BFD_RELOC_16C_REG16_C,
  BFD_RELOC_16C_REG20,
  BFD_RELOC_16C_REG20_C,
  BFD_RELOC_16C_ABS20,
  BFD_RELOC_16C_ABS20_C,
  BFD_RELOC_16C_ABS24,
  BFD_RELOC_16C_ABS24_C,
  BFD_RELOC_16C_IMM04,
  BFD_RELOC_16C_IMM04_C,
  BFD_RELOC_16C_IMM16,
  BFD_RELOC_16C_IMM16_C,
  BFD_RELOC_16C_IMM20,
  BFD_RELOC_16C_IMM20_C,
  BFD_RELOC_16C_IMM24,
  BFD_RELOC_16C_IMM24_C,
  BFD_RELOC_16C_IMM32,
  BFD_RELOC_16C_IMM32_C,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_GOTOFF_HI16,
  BFD_RELOC_OR1K_GOTOFF_LO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_XC16X_PAG,
  BFD_RELOC_XC16X_POF,
  BFD_RELOC_XC16X_SEG,
  BFD_RELOC_XC16X_SOF,


  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 5621 "../bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,







  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,


  BFD_RELOC_WASM32_LEB128,
  BFD_RELOC_WASM32_LEB128_GOT,
  BFD_RELOC_WASM32_LEB128_GOT_CODE,
  BFD_RELOC_WASM32_LEB128_PLT,
  BFD_RELOC_WASM32_PLT_INDEX,
  BFD_RELOC_WASM32_ABS32_CODE,
  BFD_RELOC_WASM32_COPY,
  BFD_RELOC_WASM32_CODE_POINTER,
  BFD_RELOC_WASM32_INDEX,
  BFD_RELOC_WASM32_PLT_SIG,
  BFD_RELOC_UNUSED };

typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);



typedef struct bfd_symbol
{
# 6522 "../bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 6637 "../bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;




bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);




bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);







bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);

bfd_boolean bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);







enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;



  ufile_ptr where;


  long mtime;


  unsigned int id;


  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;


  flagword flags : 20;
# 6856 "../bfd/bfd.h"
  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;



  bfd *plugin_dummy_bfd;




  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;



  int archive_pass;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct _oasys_data *oasys_obj_data;
      struct _oasys_ar_data *oasys_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct ieee_data_struct *ieee_data;
      struct ieee_ar_data_struct *ieee_ar_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct nlm_obj_tdata *nlm_obj_data;
      struct bout_data_struct *bout_data;
      struct mmo_data_struct *mmo_data;
      struct sun_core_struct *sun_core_data;
      struct sco5_core_struct *sco5_core_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct versados_data_struct *versados_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};


static inline bfd_boolean
bfd_set_cacheable (bfd * abfd, bfd_boolean val)
{
  abfd->cacheable = val;
  return 1;
}


typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag, ...);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);


typedef void (*bfd_error_handler_type) (const char *, va_list);

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);


typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
                                         const char *bfd_version,
                                         const char *bfd_file,
                                         int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);



bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);

bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
# 7205 "../bfd/bfd.h"
extern bfd_byte *bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);

bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

void bfd_emul_set_maxpagesize (const char *, bfd_vma);

bfd_vma bfd_emul_get_commonpagesize (const char *);

void bfd_emul_set_commonpagesize (const char *, bfd_vma);

char *bfd_demangle (bfd *, const char *, int);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

bfd_boolean bfd_check_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec,
    bfd_size_type *uncompressed_size);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);

bfd_size_type bfd_convert_section_size
   (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);

bfd_boolean bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);

bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);

bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);

bfd_boolean generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);
# 7280 "../bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


typedef struct bfd_link_info _bfd_link_info;


typedef struct flag_info flag_info;

typedef struct bfd_target
{

  char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;




  bfd_uint64_t (*bfd_getx64) (const void *);
  bfd_int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  bfd_uint64_t (*bfd_h_getx64) (const void *);
  bfd_int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);





  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7400 "../bfd/bfd.h"
  bfd_boolean (*_close_and_cleanup) (bfd *);

  bfd_boolean (*_bfd_free_cached_info) (bfd *);

  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);

  bfd_boolean (*_bfd_get_section_contents)
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
  bfd_boolean (*_bfd_get_section_contents_in_window)
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
# 7424 "../bfd/bfd.h"
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);




  bfd_boolean (*_bfd_init_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);


  bfd_boolean (*_bfd_copy_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr);


  bfd_boolean (*_bfd_copy_private_symbol_data)
    (bfd *, asymbol *, bfd *, asymbol *);


  bfd_boolean (*_bfd_copy_private_header_data)
    (bfd *, bfd *);

  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);


  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7459 "../bfd/bfd.h"
  char * (*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7478 "../bfd/bfd.h"
  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
  bfd_boolean (*_bfd_construct_extended_name_table)
    (bfd *, char **, bfd_size_type *, const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  bfd_boolean (*write_armap)
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void * (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd * (*openr_next_archived_file) (bfd *, bfd *);

  bfd * (*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
# 7511 "../bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol)
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);

  void (*_bfd_get_symbol_info)
    (bfd *, struct bfd_symbol *, symbol_info *);

  const char *(*_bfd_get_symbol_version_string)
    (bfd *, struct bfd_symbol *, bfd_boolean *);

  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent * (*_get_lineno) (bfd *, struct bfd_symbol *);
  bfd_boolean (*_bfd_find_nearest_line)
    (bfd *, struct bfd_symbol **, struct bfd_section *, bfd_vma,
     const char **, const char **, unsigned int *, unsigned int *);
  bfd_boolean (*_bfd_find_line)
    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
     const char **, unsigned int *);
  bfd_boolean (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol * (*_bfd_make_debug_symbol)
    (bfd *, void *, unsigned long size);


  long (*_read_minisymbols)
    (bfd *, bfd_boolean, void **, unsigned int *);


  asymbol * (*_minisymbol_to_symbol)
    (bfd *, bfd_boolean, const void *, asymbol *);
# 7558 "../bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc)
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
  void (*_bfd_set_reloc)
    (bfd *, sec_ptr, arelent **, unsigned int);

  reloc_howto_type *
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
              (*reloc_name_lookup) (bfd *, const char *);







  bfd_boolean (*_bfd_set_arch_mach)
    (bfd *, enum bfd_architecture, unsigned long);
  bfd_boolean (*_bfd_set_section_contents)
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
# 7601 "../bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte * (*_bfd_get_relocated_section_contents)
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);

  bfd_boolean (*_bfd_relax_section)
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);



  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) (bfd *);


  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type)
    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);



  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
                                            struct flag_info *,
                                            asection *);


  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);



  bfd_boolean (*_section_already_linked) (bfd *, asection *,
                                          struct bfd_link_info *);


  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
                                            struct bfd_link_hash_entry *);


  struct bfd_link_hash_entry *(*_bfd_define_start_stop) (struct bfd_link_info *,
                                                         const char *,
                                                         asection *);
# 7677 "../bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab)
    (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab)
    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
     struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc)
    (bfd *, arelent **, struct bfd_symbol **);


  const struct bfd_target * alternative_target;



  const void *backend_data;

} bfd_target;

bfd_boolean bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    bfd_boolean *is_bigendian,
    int *underscoring,
    const char **def_target_arch);
const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);


bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);

bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);


bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);




bfd_boolean bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);




bfd_boolean bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_link_hash_entry *bfd_generic_define_start_stop
   (struct bfd_link_info *info,
    const char *symbol, asection *sec);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, bfd_boolean *hide);

bfd_boolean bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);

bfd_boolean bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);





bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


bfd_boolean bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);

void bfd_cache_section_contents
   (asection *sec, void *contents);

bfd_boolean bfd_is_section_compressed_with_header
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p);

bfd_boolean bfd_is_section_compressed
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_decompress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_compress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);
# 23 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/libiberty.h" 1
# 42 "./../include/libiberty.h"
# 1 "./../include/ansidecl.h" 1
# 43 "./../include/libiberty.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"

# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 112 "./../include/libiberty.h"
extern char *basename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 153 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 189 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 201 "./../include/libiberty.h"
extern char * getpwd (void);
# 214 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 283 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 382 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 419 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 519 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 534 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 609 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 628 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);
# 645 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));





extern int vasprintf (char **, const char *, va_list) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__nonnull__ (2)));





extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 706 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 719 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 24 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/filenames.h" 1
# 29 "./../include/filenames.h"
# 1 "./../include/hashtab.h" 1
# 42 "./../include/hashtab.h"
typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "./../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, void *);
extern void htab_remove_elt_with_hash (htab_t, void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);
# 30 "./../include/filenames.h" 2
# 83 "./../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);
# 25 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/safe-ctype.h" 1
# 57 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "./../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 123 "./../include/safe-ctype.h" 2
# 26 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/obstack.h" 1
# 111 "./../include/obstack.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 112 "./../include/obstack.h" 2
# 156 "./../include/obstack.h"

# 156 "./../include/obstack.h"
struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};

struct obstack
{
  size_t chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  union
  {
    size_t i;
    void *p;
  } temp;
  size_t alignment_mask;


  union
  {
    void *(*plain) (size_t);
    void *(*extra) (void *, size_t);
  } chunkfun;
  union
  {
    void (*plain) (void *);
    void (*extra) (void *, void *);
  } freefun;

  void *extra_arg;
  unsigned use_extra_arg : 1;
  unsigned maybe_empty_object : 1;



  unsigned alloc_failed : 1;


};



extern void _obstack_newchunk (struct obstack *, size_t);
extern void _obstack_free (struct obstack *, void *);
extern int _obstack_begin (struct obstack *,
                           size_t, size_t,
                           void *(*) (size_t), void (*) (void *));
extern int _obstack_begin_1 (struct obstack *,
                             size_t, size_t,
                             void *(*) (void *, size_t),
                             void (*) (void *, void *), void *);
extern size_t _obstack_memory_used (struct obstack *)
  
# 212 "./../include/obstack.h" 3 4
 __attribute__ ((__pure__))
# 212 "./../include/obstack.h"
                   ;






extern void (*obstack_alloc_failed_handler) (void);


extern int obstack_exit_failure;
# 27 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/bfdlink.h" 1
# 26 "./../include/bfdlink.h"
enum bfd_link_strip
{
  strip_none,
  strip_debugger,
  strip_some,
  strip_all
};



enum bfd_link_discard
{
  discard_sec_merge,

  discard_none,
  discard_l,
  discard_all
};



enum bfd_link_elf_stt_common
{
  unchanged,
  elf_stt_common,
  no_elf_stt_common
};




enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };




enum bfd_link_hash_type
{
  bfd_link_hash_new,
  bfd_link_hash_undefined,
  bfd_link_hash_undefweak,
  bfd_link_hash_defined,
  bfd_link_hash_defweak,
  bfd_link_hash_common,
  bfd_link_hash_indirect,
  bfd_link_hash_warning
};

enum bfd_link_common_skip_ar_symbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

struct bfd_link_hash_common_entry
  {
    unsigned int alignment_power;
    asection *section;
  };




struct bfd_link_hash_entry
{

  struct bfd_hash_entry root;


  __extension__ enum bfd_link_hash_type type : 8;



  unsigned int non_ir_ref_regular : 1;



  unsigned int non_ir_ref_dynamic : 1;



  unsigned int linker_def : 1;


  unsigned int ldscript_def : 1;


  union
    {


      struct
 {
# 144 "./../include/bfdlink.h"
   struct bfd_link_hash_entry *next;

   bfd *abfd;
 } undef;

      struct
 {
   struct bfd_link_hash_entry *next;

   asection *section;

   bfd_vma value;
 } def;

      struct
 {
   struct bfd_link_hash_entry *next;

   struct bfd_link_hash_entry *link;

   const char *warning;
 } i;

      struct
 {
   struct bfd_link_hash_entry *next;
# 179 "./../include/bfdlink.h"
   struct bfd_link_hash_common_entry *p;

   bfd_size_type size;
 } c;
    } u;
};




struct bfd_link_hash_table
{

  struct bfd_hash_table table;


  struct bfd_link_hash_entry *undefs;

  struct bfd_link_hash_entry *undefs_tail;

  void (*hash_table_free) (bfd *);

  enum bfd_link_hash_table_type type;
};




extern struct bfd_link_hash_entry *bfd_link_hash_lookup
  (struct bfd_link_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy, bfd_boolean follow);





extern struct bfd_link_hash_entry *bfd_wrapped_link_hash_lookup
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean, bfd_boolean);




extern struct bfd_link_hash_entry *unwrap_hash_lookup
  (struct bfd_link_info *, bfd *, struct bfd_link_hash_entry *);


extern void bfd_link_hash_traverse
  (struct bfd_link_hash_table *,
    bfd_boolean (*) (struct bfd_link_hash_entry *, void *),
    void *);


extern void bfd_link_add_undef
  (struct bfd_link_hash_table *, struct bfd_link_hash_entry *);


extern void bfd_link_repair_undef_list
  (struct bfd_link_hash_table *table);


extern bfd_boolean bfd_generic_link_read_symbols (bfd *);




extern bfd_boolean bfd_link_check_relocs (bfd *,struct bfd_link_info *);

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};



enum report_method
{



  RM_NOT_YET_SET = 0,
  RM_IGNORE,
  RM_GENERATE_WARNING,
  RM_GENERATE_ERROR
};

typedef enum {with_flags, without_flags} flag_type;


struct flag_info_list
{
  flag_type with;
  const char *name;
  bfd_boolean valid;
  struct flag_info_list *next;
};


struct flag_info
{
  flagword only_with_flags;
  flagword not_with_flags;
  struct flag_info_list *flag_list;
  bfd_boolean flags_initialized;
};

struct bfd_elf_dynamic_list;
struct bfd_elf_version_tree;



enum output_type
{
  type_pde,
  type_pie,
  type_relocatable,
  type_dll,
};
# 309 "./../include/bfdlink.h"
struct bfd_link_info
{

  __extension__ enum output_type type : 2;


  unsigned int symbolic: 1;



  unsigned int nocopyreloc: 1;



  unsigned int export_dynamic: 1;



  unsigned int create_default_symver: 1;


  unsigned int gc_sections: 1;


  unsigned int gc_keep_exported: 1;



  unsigned int notice_all: 1;


  unsigned int lto_plugin_active: 1;


  unsigned int strip_discarded: 1;


  unsigned int dynamic_data: 1;


  unsigned int resolve_section_groups: 1;


  __extension__ enum bfd_link_strip strip : 2;


  __extension__ enum bfd_link_discard discard : 2;


  __extension__ enum bfd_link_elf_stt_common elf_stt_common : 2;



  __extension__ enum bfd_link_common_skip_ar_symbols common_skip_ar_symbols : 2;






  __extension__ enum report_method unresolved_syms_in_objects : 2;



  __extension__ enum report_method unresolved_syms_in_shared_libs : 2;


  unsigned int static_link: 1;



  unsigned int keep_memory: 1;



  unsigned int emitrelocations: 1;


  unsigned int relro: 1;



  unsigned int eh_frame_hdr_type: 2;


  unsigned int warn_shared_textrel: 1;


  unsigned int error_textrel: 1;


  unsigned int emit_hash: 1;


  unsigned int emit_gnu_hash: 1;




  unsigned int reduce_memory_overheads: 1;





  unsigned int traditional_format: 1;



  unsigned int combreloc: 1;



  unsigned int default_imported_symver: 1;


  unsigned int new_dtags: 1;



  unsigned int no_ld_generated_unwind_info: 1;




  unsigned int task_link: 1;


  unsigned int allow_multiple_definition: 1;


  unsigned int allow_undefined_version: 1;



  unsigned int dynamic: 1;



  unsigned int execstack: 1;



  unsigned int noexecstack: 1;



  unsigned int optimize: 1;


  unsigned int print_gc_sections: 1;


  unsigned int warn_alternate_em: 1;


  unsigned int user_phdrs: 1;



  unsigned int check_relocs_after_open_input: 1;


  unsigned int bndplt: 1;


  unsigned int ibtplt: 1;


  unsigned int ibt: 1;


  unsigned int shstk: 1;


  unsigned int nointerp: 1;


  unsigned int no_reloc_overflow_check: 1;


  unsigned int call_nop_as_suffix : 1;


  char call_nop_byte;




  char wrap_char;


  char path_separator;


  enum compressed_debug_section_type compress_debug;



  bfd_signed_vma stacksize;
# 526 "./../include/bfdlink.h"
  signed int disable_target_specific_optimizations;


  const struct bfd_link_callbacks *callbacks;


  struct bfd_link_hash_table *hash;



  struct bfd_hash_table *keep_hash;




  struct bfd_hash_table *notice_hash;



  struct bfd_hash_table *wrap_hash;



  struct bfd_hash_table *ignore_hash;


  bfd *output_bfd;


  bfd *out_implib_bfd;



  bfd *input_bfds;
  bfd **input_bfds_tail;






  asection *create_object_symbols_section;



  struct bfd_sym_chain *gc_sym_list;


  void *base_file;



  const char *init_function;



  const char *fini_function;





  int relax_pass;




  int relax_trip;




  int extern_protected_data;




  int dynamic_undefined_weak;




  int pei386_auto_import;




  int pei386_runtime_pseudo_reloc;


  unsigned int spare_dynamic_tags;


  bfd_vma flags;


  bfd_vma flags_1;


  bfd_vma relro_start, relro_end;


  struct bfd_elf_dynamic_list *dynamic_list;


  struct bfd_elf_version_tree *version_info;
};




struct bfd_link_callbacks
{







  bfd_boolean (*add_archive_element)
    (struct bfd_link_info *, bfd *abfd, const char *name, bfd **subsbfd);




  void (*multiple_definition)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, asection *nsec, bfd_vma nval);






  void (*multiple_common)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize);






  void (*add_to_set)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec, bfd_vma value);






  void (*constructor)
    (struct bfd_link_info *, bfd_boolean constructor, const char *name,
     bfd *abfd, asection *sec, bfd_vma value);







  void (*warning)
    (struct bfd_link_info *, const char *warning, const char *symbol,
     bfd *abfd, asection *section, bfd_vma address);





  void (*undefined_symbol)
    (struct bfd_link_info *, const char *name, bfd *abfd,
     asection *section, bfd_vma address, bfd_boolean is_fatal);
# 708 "./../include/bfdlink.h"
  void (*reloc_overflow)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     const char *name, const char *reloc_name, bfd_vma addend,
     bfd *abfd, asection *section, bfd_vma address);






  void (*reloc_dangerous)
    (struct bfd_link_info *, const char *message,
     bfd *abfd, asection *section, bfd_vma address);






  void (*unattached_reloc)
    (struct bfd_link_info *, const char *name,
     bfd *abfd, asection *section, bfd_vma address);





  bfd_boolean (*notice)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     struct bfd_link_hash_entry *inh,
     bfd *abfd, asection *section, bfd_vma address, flagword flags);

  void (*einfo)
    (const char *fmt, ...);

  void (*info)
    (const char *fmt, ...);

  void (*minfo)
    (const char *fmt, ...);



  bfd_boolean (*override_segment_assignment)
    (struct bfd_link_info *, bfd * abfd,
     asection * current_section, asection * previous_section,
     bfd_boolean new_segment);
};






enum bfd_link_order_type
{
  bfd_undefined_link_order,
  bfd_indirect_link_order,
  bfd_data_link_order,
  bfd_section_reloc_link_order,
  bfd_symbol_reloc_link_order
};




struct bfd_link_order
{

  struct bfd_link_order *next;

  enum bfd_link_order_type type;

  bfd_vma offset;

  bfd_size_type size;

  union
    {
      struct
 {






   asection *section;
 } indirect;
      struct
 {




   unsigned int size;

   bfd_byte *contents;
 } data;
      struct
 {



   struct bfd_link_order_reloc *p;
 } reloc;
    } u;
};
# 829 "./../include/bfdlink.h"
struct bfd_link_order_reloc
{

  bfd_reloc_code_real_type reloc;

  union
    {



      asection *section;


      const char *name;
    } u;






  bfd_vma addend;
};


extern struct bfd_link_order *bfd_new_link_order (bfd *, asection *);
# 863 "./../include/bfdlink.h"
struct bfd_elf_version_expr
{

  struct bfd_elf_version_expr *next;

  const char *pattern;

  unsigned int literal : 1;

  unsigned int symver : 1;

  unsigned int script : 1;




  unsigned int mask : 3;
};

struct bfd_elf_version_expr_head
{

  struct bfd_elf_version_expr *list;

  void *htab;

  struct bfd_elf_version_expr *remaining;

  unsigned int mask;
};



struct bfd_elf_version_deps
{

  struct bfd_elf_version_deps *next;

  struct bfd_elf_version_tree *version_needed;
};



struct bfd_elf_version_tree
{

  struct bfd_elf_version_tree *next;

  const char *name;

  unsigned int vernum;

  struct bfd_elf_version_expr_head globals;

  struct bfd_elf_version_expr_head locals;

  struct bfd_elf_version_deps *deps;

  unsigned int name_indx;

  int used;

  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};

struct bfd_elf_dynamic_list
{
  struct bfd_elf_version_expr_head head;
  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};
# 28 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2

# 1 "/doner/binutils/binutils-7a31b38/ld/ld.h" 1
# 43 "/doner/binutils/binutils-7a31b38/ld/ld.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4

# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 44 "/doner/binutils/binutils-7a31b38/ld/ld.h" 2



# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 48 "/doner/binutils/binutils-7a31b38/ld/ld.h" 2
# 76 "/doner/binutils/binutils-7a31b38/ld/ld.h"

# 76 "/doner/binutils/binutils-7a31b38/ld/ld.h"
typedef struct name_list
{
  const char *name;
  struct name_list *next;
}
name_list;

typedef enum {sort_none, sort_ascending, sort_descending} sort_order;



typedef enum
{
  none, by_name, by_alignment, by_name_alignment, by_alignment_name,
  by_none, by_init_priority
} sort_type;

extern sort_type sort_section;

struct wildcard_spec
{
  const char *name;
  struct name_list *exclude_name_list;
  sort_type sorted;
  struct flag_info *section_flag_list;
};

struct wildcard_list
{
  struct wildcard_list *next;
  struct wildcard_spec spec;
};






enum endian_enum { ENDIAN_UNSET = 0, ENDIAN_BIG, ENDIAN_LITTLE };

enum symbolic_enum
{
  symbolic_unset = 0,
  symbolic,
  symbolic_functions,
};

enum dynamic_list_enum
{
  dynamic_list_unset = 0,
  dynamic_list_data,
  dynamic_list
};

typedef struct
{

  bfd_boolean force_common_definition;


  bfd_boolean inhibit_common_definition;



  bfd_boolean embedded_relocs;


  bfd_boolean force_exe_suffix;


  bfd_boolean cref;



  bfd_boolean warn_mismatch;



  bfd_boolean warn_search_mismatch;



  signed char check_section_addresses;





  bfd_boolean accept_unknown_input_arch;


  char *out_implib_filename;


  bfd_boolean print_output_format;


  bfd_boolean print_memory_usage;




  bfd_boolean force_group_allocation;


  enum endian_enum endian;


  enum symbolic_enum symbolic;



  enum dynamic_list_enum dynamic_list;


  char *interpreter;


  char *soname;


  char *rpath;



  char *rpath_link;



  char *filter_shlib;



  char **auxiliary_filters;



  char *version_exports_section;


  char *default_script;
} args_type;

extern args_type command_line;

typedef int token_code_type;



enum orphan_handling_enum
{


  orphan_handling_place = 0,



  orphan_handling_discard,



  orphan_handling_warn,


  orphan_handling_error,
};

typedef struct
{
  bfd_boolean magic_demand_paged;
  bfd_boolean make_executable;





  bfd_boolean has_shared;


  bfd_boolean build_constructors;


  bfd_boolean warn_constructors;


  bfd_boolean warn_common;


  bfd_boolean warn_once;


  enum orphan_handling_enum orphan_handling;



  bfd_boolean warn_multiple_gp;



  bfd_boolean warn_section_align;


  bfd_boolean fatal_warnings;

  sort_order sort_common;

  bfd_boolean text_read_only;

  bfd_boolean stats;



  bfd_boolean unique_orphan_sections;



  bfd_boolean only_cmd_line_lib_dirs;



  bfd_boolean sane_expr;


  bfd_boolean separate_code;


  char rpath_separator;

  char *map_filename;
  FILE *map_file;

  unsigned int split_by_reloc;
  bfd_size_type split_by_file;


  unsigned long hash_table_size;


  bfd_vma maxpagesize;


  bfd_vma commonpagesize;
} ld_config_type;

extern ld_config_type config;

extern FILE * saved_script_handle;
extern bfd_boolean force_make_executable;

extern int yyparse (void);
extern void add_cref (const char *, bfd *, asection *, bfd_vma);
extern bfd_boolean handle_asneeded_cref (bfd *, enum notice_asneeded_action);
extern void output_cref (FILE *);
extern void check_nocrossrefs (void);
extern void ld_abort (const char *, int, const char *) __attribute__ ((__noreturn__));
# 30 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldmain.h" 1
# 24 "/doner/binutils/binutils-7a31b38/ld/ldmain.h"
extern char *program_name;
extern const char *ld_sysroot;
extern char *ld_canon_sysroot;
extern int ld_canon_sysroot_len;
extern FILE *saved_script_handle;
extern FILE *previous_script_handle;
extern bfd_boolean force_make_executable;
extern char *default_target;
extern bfd_boolean trace_files;
extern bfd_boolean verbose;
extern bfd_boolean version_printed;
extern bfd_boolean demangling;
extern int g_switch_value;
extern const char *output_filename;
extern struct bfd_link_info link_info;
extern int overflow_cutoff_limit;
# 57 "/doner/binutils/binutils-7a31b38/ld/ldmain.h"
extern void add_ysym (const char *);
extern void add_wrap (const char *);
extern void add_ignoresym (struct bfd_link_info *, const char *);
extern void add_keepsyms_file (const char *);
# 31 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldexp.h" 1
# 25 "/doner/binutils/binutils-7a31b38/ld/ldexp.h"
typedef struct {
  bfd_vma value;
  char *str;
  asection *section;
  bfd_boolean valid_p;
} etree_value_type;

enum node_tree_enum {
  etree_binary,
  etree_trinary,
  etree_unary,
  etree_name,
  etree_assign,
  etree_provide,
  etree_provided,
  etree_value,
  etree_assert,
  etree_rel
};

typedef struct {
  int node_code;
  unsigned int lineno;
  const char *filename;
  enum node_tree_enum node_class;
} node_type;

typedef union etree_union {
  node_type type;
  struct {
    node_type type;
    union etree_union *lhs;
    union etree_union *rhs;
  } binary;
  struct {
    node_type type;
    union etree_union *cond;
    union etree_union *lhs;
    union etree_union *rhs;
  } trinary;
  struct {
    node_type type;
    const char *dst;
    union etree_union *src;
    bfd_boolean defsym;
    bfd_boolean hidden;
  } assign;
  struct {
    node_type type;
    union etree_union *child;
  } unary;
  struct {
    node_type type;
    const char *name;
  } name;
  struct {
    node_type type;
    bfd_vma value;
    char *str;
  } value;
  struct {
    node_type type;
    asection *section;
    bfd_vma value;
  } rel;
  struct {
    node_type type;
    union etree_union *child;
    const char *message;
  } assert_s;
} etree_type;


typedef enum
{


  lang_first_phase_enum,

  lang_mark_phase_enum,

  lang_allocating_phase_enum,

  lang_assigning_phase_enum,

  lang_final_phase_enum
} lang_phase_type;

union lang_statement_union;

enum phase_enum {


  exp_dataseg_none,
  exp_dataseg_align_seen,
  exp_dataseg_relro_seen,
  exp_dataseg_end_seen,


  exp_dataseg_relro_adjust,
  exp_dataseg_adjust,
  exp_dataseg_done
};

enum relro_enum {
  exp_dataseg_relro_none,
  exp_dataseg_relro_start,
  exp_dataseg_relro_end,
};

struct ldexp_control {

  lang_phase_type phase;


  bfd_boolean assigning_to_dot;






  bfd_boolean rel_from_abs;





  const char *assign_name;


  etree_value_type result;
  bfd_vma dot;


  bfd_vma *dotp;
  asection *section;


  struct {
    enum phase_enum phase;

    bfd_vma base, relro_offset, relro_end, end, pagesize, maxpagesize;

    enum relro_enum relro;

    union lang_statement_union *relro_start_stat;
    union lang_statement_union *relro_end_stat;
  } dataseg;
};

extern struct ldexp_control expld;


typedef struct segment_struct {

  struct segment_struct *next;

  const char *name;

  bfd_vma value;


  bfd_boolean used;
} segment_type;


extern segment_type *segments;

typedef struct _fill_type fill_type;

etree_type *exp_intop
  (bfd_vma);
etree_type *exp_bigintop
  (bfd_vma, char *);
etree_type *exp_relop
  (asection *, bfd_vma);
void exp_fold_tree
  (etree_type *, asection *, bfd_vma *);
void exp_fold_tree_no_dot
  (etree_type *);
etree_type *exp_binop
  (int, etree_type *, etree_type *);
etree_type *exp_trinop
  (int,etree_type *, etree_type *, etree_type *);
etree_type *exp_unop
  (int, etree_type *);
etree_type *exp_nameop
  (int, const char *);
etree_type *exp_assign
  (const char *, etree_type *, bfd_boolean);
etree_type *exp_defsym
  (const char *, etree_type *);
etree_type *exp_provide
  (const char *, etree_type *, bfd_boolean);
etree_type *exp_assert
  (etree_type *, const char *);
void exp_print_tree
  (etree_type *);
bfd_vma exp_get_vma
  (etree_type *, bfd_vma, char *);
int exp_get_value_int
  (etree_type *, int, char *);
fill_type *exp_get_fill
  (etree_type *, fill_type *, char *);
bfd_vma exp_get_abs_int
  (etree_type *, int, char *);
void ldexp_init (void);
void ldexp_finalize_syms (void);
void ldexp_finish (void);
# 32 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldlang.h" 1
# 26 "/doner/binutils/binutils-7a31b38/ld/ldlang.h"
typedef enum
{
  lang_input_file_is_l_enum,
  lang_input_file_is_symbols_only_enum,
  lang_input_file_is_marker_enum,
  lang_input_file_is_fake_enum,
  lang_input_file_is_search_file_enum,
  lang_input_file_is_file_enum
} lang_input_file_enum_type;

struct _fill_type
{
  size_t size;
  unsigned char data[1];
};

typedef struct statement_list
{
  union lang_statement_union * head;
  union lang_statement_union ** tail;
} lang_statement_list_type;

typedef struct memory_region_name_struct
{
  const char * name;
  struct memory_region_name_struct * next;
} lang_memory_region_name;

typedef struct memory_region_struct
{
  lang_memory_region_name name_list;
  struct memory_region_struct *next;
  union etree_union *origin_exp;
  bfd_vma origin;
  bfd_size_type length;
  union etree_union *length_exp;
  bfd_vma current;
  union lang_statement_union *last_os;
  flagword flags;
  flagword not_flags;
  bfd_boolean had_full_message;
} lang_memory_region_type;

enum statement_enum
{
  lang_output_section_statement_enum,
  lang_assignment_statement_enum,
  lang_input_statement_enum,
  lang_address_statement_enum,
  lang_wild_statement_enum,
  lang_input_section_enum,
  lang_object_symbols_statement_enum,
  lang_fill_statement_enum,
  lang_data_statement_enum,
  lang_reloc_statement_enum,
  lang_target_statement_enum,
  lang_output_statement_enum,
  lang_padding_statement_enum,
  lang_group_statement_enum,
  lang_insert_statement_enum,
  lang_constructors_statement_enum
};

typedef struct lang_statement_header_struct
{
  union lang_statement_union *next;
  enum statement_enum type;
} lang_statement_header_type;

typedef struct
{
  lang_statement_header_type header;
  union etree_union *exp;
} lang_assignment_statement_type;

typedef struct lang_target_statement_struct
{
  lang_statement_header_type header;
  const char *target;
} lang_target_statement_type;

typedef struct lang_output_statement_struct
{
  lang_statement_header_type header;
  const char *name;
} lang_output_statement_type;



enum section_type
{
  normal_section,
  overlay_section,
  noload_section,
  noalloc_section
};




typedef struct lang_output_section_phdr_list
{
  struct lang_output_section_phdr_list *next;
  const char *name;
  bfd_boolean used;
} lang_output_section_phdr_list;

typedef struct lang_output_section_statement_struct
{
  lang_statement_header_type header;
  lang_statement_list_type children;
  struct lang_output_section_statement_struct *next;
  struct lang_output_section_statement_struct *prev;
  const char *name;
  asection *bfd_section;
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
  fill_type *fill;
  union etree_union *addr_tree;
  union etree_union *load_base;





  union etree_union *update_dot_tree;

  lang_output_section_phdr_list *phdrs;

  unsigned int block_value;
  int subsection_alignment;
  int section_alignment;
  int constraint;
  flagword flags;
  enum section_type sectype;
  unsigned int processed_vma : 1;
  unsigned int processed_lma : 1;
  unsigned int all_input_readonly : 1;

  unsigned int ignored : 1;

  unsigned int update_dot : 1;

  unsigned int after_end : 1;

  unsigned int align_lma_with_input : 1;
} lang_output_section_statement_type;

typedef struct
{
  lang_statement_header_type header;
} lang_common_statement_type;

typedef struct
{
  lang_statement_header_type header;
} lang_object_symbols_statement_type;

typedef struct
{
  lang_statement_header_type header;
  fill_type *fill;
  int size;
  asection *output_section;
} lang_fill_statement_type;

typedef struct
{
  lang_statement_header_type header;
  unsigned int type;
  union etree_union *exp;
  bfd_vma value;
  asection *output_section;
  bfd_vma output_offset;
} lang_data_statement_type;



typedef struct
{
  lang_statement_header_type header;


  bfd_reloc_code_real_type reloc;


  reloc_howto_type *howto;



  asection *section;



  const char *name;


  union etree_union *addend_exp;


  bfd_vma addend_value;


  asection *output_section;


  bfd_vma output_offset;
} lang_reloc_statement_type;

struct lang_input_statement_flags
{

  unsigned int maybe_archive : 1;


  unsigned int full_name_provided : 1;


  unsigned int search_dirs : 1;


  unsigned int sysrooted : 1;




  unsigned int just_syms : 1;


  unsigned int dynamic : 1;




  unsigned int add_DT_NEEDED_for_dynamic : 1;



  unsigned int add_DT_NEEDED_for_regular : 1;


  unsigned int whole_archive : 1;


  unsigned int loaded : 1;

  unsigned int real : 1;


  unsigned int missing_file : 1;


  unsigned int reload : 1;



  unsigned int claimed : 1;


  unsigned int claim_archive : 1;


  unsigned int lto_output : 1;



  struct lang_input_statement_flags *pushed;
};

typedef struct lang_input_statement_struct
{
  lang_statement_header_type header;

  const char *filename;



  const char *local_sym_name;

  bfd *the_bfd;

  struct flag_info *section_flag_list;



  union lang_statement_union *next;


  union lang_statement_union *next_real_file;

  const char *target;

  struct lang_input_statement_flags flags;
} lang_input_statement_type;

typedef struct
{
  lang_statement_header_type header;
  asection *section;
} lang_input_section_type;

struct map_symbol_def {
  struct bfd_link_hash_entry *entry;
  struct map_symbol_def *next;
};



typedef struct input_section_userdata_struct
{
  struct map_symbol_def *map_symbol_def_head;
  struct map_symbol_def **map_symbol_def_tail;
  unsigned long map_symbol_def_count;
} input_section_userdata_type;




typedef struct lang_wild_statement_struct lang_wild_statement_type;

typedef void (*callback_t) (lang_wild_statement_type *, struct wildcard_list *,
       asection *, struct flag_info *,
       lang_input_statement_type *, void *);

typedef void (*walk_wild_section_handler_t) (lang_wild_statement_type *,
          lang_input_statement_type *,
          callback_t callback,
          void *data);

typedef bfd_boolean (*lang_match_sec_type_func) (bfd *, const asection *,
       bfd *, const asection *);



typedef struct lang_section_bst
{
  asection *section;
  struct lang_section_bst *left;
  struct lang_section_bst *right;
} lang_section_bst_type;

struct lang_wild_statement_struct
{
  lang_statement_header_type header;
  const char *filename;
  bfd_boolean filenames_sorted;
  struct wildcard_list *section_list;
  bfd_boolean keep_sections;
  lang_statement_list_type children;
  struct name_list *exclude_name_list;

  walk_wild_section_handler_t walk_wild_section_handler;
  struct wildcard_list *handler_data[4];
  lang_section_bst_type *tree;
  struct flag_info *section_flag_list;
};

typedef struct lang_address_statement_struct
{
  lang_statement_header_type header;
  const char *section_name;
  union etree_union *address;
  const segment_type *segment;
} lang_address_statement_type;

typedef struct
{
  lang_statement_header_type header;
  bfd_vma output_offset;
  bfd_size_type size;
  asection *output_section;
  fill_type *fill;
} lang_padding_statement_type;






typedef struct
{
  lang_statement_header_type header;
  lang_statement_list_type children;
} lang_group_statement_type;

typedef struct
{
  lang_statement_header_type header;
  const char *where;
  bfd_boolean is_before;
} lang_insert_statement_type;

typedef union lang_statement_union
{
  lang_statement_header_type header;
  lang_wild_statement_type wild_statement;
  lang_data_statement_type data_statement;
  lang_reloc_statement_type reloc_statement;
  lang_address_statement_type address_statement;
  lang_output_section_statement_type output_section_statement;
  lang_assignment_statement_type assignment_statement;
  lang_input_statement_type input_statement;
  lang_target_statement_type target_statement;
  lang_output_statement_type output_statement;
  lang_input_section_type input_section;
  lang_common_statement_type common_statement;
  lang_object_symbols_statement_type object_symbols_statement;
  lang_fill_statement_type fill_statement;
  lang_padding_statement_type padding_statement;
  lang_group_statement_type group_statement;
  lang_insert_statement_type insert_statement;
} lang_statement_union_type;




struct lang_phdr
{
  struct lang_phdr *next;
  const char *name;
  unsigned long type;
  bfd_boolean filehdr;
  bfd_boolean phdrs;
  etree_type *at;
  etree_type *flags;
};




typedef struct lang_nocrossref
{
  struct lang_nocrossref *next;
  const char *name;
} lang_nocrossref_type;



struct lang_nocrossrefs
{
  struct lang_nocrossrefs *next;
  lang_nocrossref_type *list;
  bfd_boolean onlyfirst;
};




struct unique_sections
{
  struct unique_sections *next;
  const char *name;
};



struct orphan_save
{
  const char *name;
  flagword flags;
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
  lang_output_section_statement_type **os_tail;
};

struct asneeded_minfo
{
  struct asneeded_minfo *next;
  const char *soname;
  bfd *ref;
  const char *name;
};

extern struct lang_phdr *lang_phdr_list;
extern struct lang_nocrossrefs *nocrossref_list;
extern const char *output_target;
extern lang_output_section_statement_type *abs_output_section;
extern lang_statement_list_type lang_output_section_statement;
extern struct lang_input_statement_flags input_flags;
extern bfd_boolean lang_has_input_file;
extern lang_statement_list_type *stat_ptr;
extern bfd_boolean delete_output_file_on_failure;

extern struct bfd_sym_chain entry_symbol;
extern const char *entry_section;
extern bfd_boolean entry_from_cmdline;
extern lang_statement_list_type file_chain;
extern lang_statement_list_type input_file_chain;

extern int lang_statement_iteration;
extern struct asneeded_minfo **asneeded_list_tail;

extern void (*output_bfd_hash_table_free_fn) (struct bfd_link_hash_table *);

extern void lang_init
  (void);
extern void lang_finish
  (void);
extern lang_memory_region_type * lang_memory_region_lookup
  (const char * const, bfd_boolean);
extern void lang_memory_region_alias
  (const char *, const char *);
extern void lang_map
  (void);
extern void lang_set_flags
  (lang_memory_region_type *, const char *, int);
extern void lang_add_output
  (const char *, int from_script);
extern lang_output_section_statement_type *lang_enter_output_section_statement
  (const char *, etree_type *, enum section_type, etree_type *, etree_type *,
   etree_type *, int, int);
extern void lang_final
  (void);
extern void lang_relax_sections
  (bfd_boolean);
extern void lang_process
  (void);
extern void lang_section_start
  (const char *, union etree_union *, const segment_type *);
extern void lang_add_entry
  (const char *, bfd_boolean);
extern void lang_default_entry
  (const char *);
extern void lang_add_target
  (const char *);
extern void lang_add_wild
  (struct wildcard_spec *, struct wildcard_list *, bfd_boolean);
extern void lang_add_map
  (const char *);
extern void lang_add_fill
  (fill_type *);
extern lang_assignment_statement_type *lang_add_assignment
  (union etree_union *);
extern void lang_add_attribute
  (enum statement_enum);
extern void lang_startup
  (const char *);
extern void lang_float
  (bfd_boolean);
extern void lang_leave_output_section_statement
  (fill_type *, const char *, lang_output_section_phdr_list *,
   const char *);
extern void lang_statement_append
  (lang_statement_list_type *, lang_statement_union_type *,
   lang_statement_union_type **);
extern void lang_for_each_input_file
  (void (*dothis) (lang_input_statement_type *));
extern void lang_for_each_file
  (void (*dothis) (lang_input_statement_type *));
extern void lang_reset_memory_regions
  (void);
extern void lang_do_assignments
  (lang_phase_type);
extern asection *section_for_dot
  (void);
# 592 "/doner/binutils/binutils-7a31b38/ld/ldlang.h"
extern void lang_process
  (void);
extern void ldlang_add_file
  (lang_input_statement_type *);
extern lang_output_section_statement_type *lang_output_section_find_by_flags
  (const asection *, flagword, lang_output_section_statement_type **,
   lang_match_sec_type_func);
extern lang_output_section_statement_type *lang_insert_orphan
  (asection *, const char *, int, lang_output_section_statement_type *,
   struct orphan_save *, etree_type *, lang_statement_list_type *);
extern lang_input_statement_type *lang_add_input_file
  (const char *, lang_input_file_enum_type, const char *);
extern void lang_add_keepsyms_file
  (const char *);
extern lang_output_section_statement_type *lang_output_section_get
  (const asection *);
extern lang_output_section_statement_type *lang_output_section_statement_lookup
  (const char *, int, bfd_boolean);
extern lang_output_section_statement_type *next_matching_output_section_statement
  (lang_output_section_statement_type *, int);
extern void ldlang_add_undef
  (const char *const, bfd_boolean);
extern void ldlang_add_require_defined
  (const char *const);
extern void lang_add_output_format
  (const char *, const char *, const char *, int);
extern void lang_list_init
  (lang_statement_list_type *);
extern void push_stat_ptr
  (lang_statement_list_type *);
extern void pop_stat_ptr
  (void);
extern void lang_add_data
  (int type, union etree_union *);
extern void lang_add_reloc
  (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
   union etree_union *);
extern void lang_for_each_statement
  (void (*) (lang_statement_union_type *));
extern void lang_for_each_statement_worker
  (void (*) (lang_statement_union_type *), lang_statement_union_type *);
extern void *stat_alloc
  (size_t);
extern void strip_excluded_output_sections
  (void);
extern void lang_clear_os_map
  (void);
extern void dprint_statement
  (lang_statement_union_type *, int);
extern void lang_size_sections
  (bfd_boolean *, bfd_boolean);
extern void one_lang_size_sections_pass
  (bfd_boolean *, bfd_boolean);
extern void lang_add_insert
  (const char *, int);
extern void lang_enter_group
  (void);
extern void lang_leave_group
  (void);
extern void lang_add_section
  (lang_statement_list_type *, asection *,
   struct flag_info *, lang_output_section_statement_type *);
extern void lang_new_phdr
  (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,
   etree_type *);
extern void lang_add_nocrossref
  (lang_nocrossref_type *);
extern void lang_add_nocrossref_to
  (lang_nocrossref_type *);
extern void lang_enter_overlay
  (etree_type *, etree_type *);
extern void lang_enter_overlay_section
  (const char *);
extern void lang_leave_overlay_section
  (fill_type *, lang_output_section_phdr_list *);
extern void lang_leave_overlay
  (etree_type *, int, fill_type *, const char *,
   lang_output_section_phdr_list *, const char *);

extern struct bfd_elf_version_expr *lang_new_vers_pattern
  (struct bfd_elf_version_expr *, const char *, const char *, bfd_boolean);
extern struct bfd_elf_version_tree *lang_new_vers_node
  (struct bfd_elf_version_expr *, struct bfd_elf_version_expr *);
extern struct bfd_elf_version_deps *lang_add_vers_depend
  (struct bfd_elf_version_deps *, const char *);
extern void lang_register_vers_node
  (const char *, struct bfd_elf_version_tree *, struct bfd_elf_version_deps *);
extern void lang_append_dynamic_list (struct bfd_elf_version_expr *);
extern void lang_append_dynamic_list_cpp_typeinfo (void);
extern void lang_append_dynamic_list_cpp_new (void);
extern void lang_add_unique
  (const char *);
extern const char *lang_get_output_target
  (void);
extern void add_excluded_libs (const char *);
extern bfd_boolean load_symbols
  (lang_input_statement_type *, lang_statement_list_type *);

extern bfd_boolean
ldlang_override_segment_assignment
  (struct bfd_link_info *, bfd *, asection *, asection *, bfd_boolean);

extern void
lang_ld_feature (char *);

extern void
lang_print_memory_usage (void);

extern void
lang_add_gc_name (const char *);
# 33 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./ldgram.h" 1
# 50 "./ldgram.h"
  enum yytokentype
  {
    INT = 258,
    NAME = 259,
    LNAME = 260,
    PLUSEQ = 261,
    MINUSEQ = 262,
    MULTEQ = 263,
    DIVEQ = 264,
    LSHIFTEQ = 265,
    RSHIFTEQ = 266,
    ANDEQ = 267,
    OREQ = 268,
    OROR = 269,
    ANDAND = 270,
    EQ = 271,
    NE = 272,
    LE = 273,
    GE = 274,
    LSHIFT = 275,
    RSHIFT = 276,
    UNARY = 277,
    END = 278,
    ALIGN_K = 279,
    BLOCK = 280,
    BIND = 281,
    QUAD = 282,
    SQUAD = 283,
    LONG = 284,
    SHORT = 285,
    BYTE = 286,
    SECTIONS = 287,
    PHDRS = 288,
    INSERT_K = 289,
    AFTER = 290,
    BEFORE = 291,
    DATA_SEGMENT_ALIGN = 292,
    DATA_SEGMENT_RELRO_END = 293,
    DATA_SEGMENT_END = 294,
    SORT_BY_NAME = 295,
    SORT_BY_ALIGNMENT = 296,
    SORT_NONE = 297,
    SORT_BY_INIT_PRIORITY = 298,
    SIZEOF_HEADERS = 299,
    OUTPUT_FORMAT = 300,
    FORCE_COMMON_ALLOCATION = 301,
    OUTPUT_ARCH = 302,
    INHIBIT_COMMON_ALLOCATION = 303,
    FORCE_GROUP_ALLOCATION = 304,
    SEGMENT_START = 305,
    INCLUDE = 306,
    MEMORY = 307,
    REGION_ALIAS = 308,
    LD_FEATURE = 309,
    NOLOAD = 310,
    DSECT = 311,
    COPY = 312,
    INFO = 313,
    OVERLAY = 314,
    DEFINED = 315,
    TARGET_K = 316,
    SEARCH_DIR = 317,
    MAP = 318,
    ENTRY = 319,
    NEXT = 320,
    SIZEOF = 321,
    ALIGNOF = 322,
    ADDR = 323,
    LOADADDR = 324,
    MAX_K = 325,
    MIN_K = 326,
    STARTUP = 327,
    HLL = 328,
    SYSLIB = 329,
    FLOAT = 330,
    NOFLOAT = 331,
    NOCROSSREFS = 332,
    NOCROSSREFS_TO = 333,
    ORIGIN = 334,
    FILL = 335,
    LENGTH = 336,
    CREATE_OBJECT_SYMBOLS = 337,
    INPUT = 338,
    GROUP = 339,
    OUTPUT = 340,
    CONSTRUCTORS = 341,
    ALIGNMOD = 342,
    AT = 343,
    SUBALIGN = 344,
    HIDDEN = 345,
    PROVIDE = 346,
    PROVIDE_HIDDEN = 347,
    AS_NEEDED = 348,
    CHIP = 349,
    LIST = 350,
    SECT = 351,
    ABSOLUTE = 352,
    LOAD = 353,
    NEWLINE = 354,
    ENDWORD = 355,
    ORDER = 356,
    NAMEWORD = 357,
    ASSERT_K = 358,
    LOG2CEIL = 359,
    FORMAT = 360,
    PUBLIC = 361,
    DEFSYMEND = 362,
    BASE = 363,
    ALIAS = 364,
    TRUNCATE = 365,
    REL = 366,
    INPUT_SCRIPT = 367,
    INPUT_MRI_SCRIPT = 368,
    INPUT_DEFSYM = 369,
    CASE = 370,
    EXTERN = 371,
    START = 372,
    VERS_TAG = 373,
    VERS_IDENTIFIER = 374,
    GLOBAL = 375,
    LOCAL = 376,
    VERSIONK = 377,
    INPUT_VERSION_SCRIPT = 378,
    KEEP = 379,
    ONLY_IF_RO = 380,
    ONLY_IF_RW = 381,
    SPECIAL = 382,
    INPUT_SECTION_FLAGS = 383,
    ALIGN_WITH_INPUT = 384,
    EXCLUDE_FILE = 385,
    CONSTANT = 386,
    INPUT_DYNAMIC_LIST = 387
  };
# 318 "./ldgram.h"
union YYSTYPE
{
# 60 "ldgram.y"

  bfd_vma integer;
  struct big_int
    {
      bfd_vma integer;
      char *str;
    } bigint;
  fill_type *fill;
  char *name;
  const char *cname;
  struct wildcard_spec wildcard;
  struct wildcard_list *wildcard_list;
  struct name_list *name_list;
  struct flag_info_list *flag_info_list;
  struct flag_info *flag_info;
  int token;
  union etree_union *etree;
  struct phdr_info
    {
      bfd_boolean filehdr;
      bfd_boolean phdrs;
      union etree_union *at;
      union etree_union *flags;
    } phdr;
  struct lang_nocrossref *nocrossref;
  struct lang_output_section_phdr_list *section_phdr;
  struct bfd_elf_version_deps *deflist;
  struct bfd_elf_version_expr *versyms;
  struct bfd_elf_version_tree *versnode;
# 352 "ldgram.h"

};
typedef union YYSTYPE YYSTYPE;





extern YYSTYPE yylval;

int yyparse (void);
# 34 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldlex.h" 1
# 28 "/doner/binutils/binutils-7a31b38/ld/ldlex.h"
enum option_values
{
  OPTION_ASSERT = 150,
  OPTION_CALL_SHARED,
  OPTION_CREF,
  OPTION_DEFSYM,
  OPTION_DEMANGLE,
  OPTION_DYNAMIC_LINKER,
  OPTION_NO_DYNAMIC_LINKER,
  OPTION_SYSROOT,
  OPTION_OUT_IMPLIB,
  OPTION_EB,
  OPTION_EL,
  OPTION_EMBEDDED_RELOCS,
  OPTION_EXPORT_DYNAMIC,
  OPTION_NO_EXPORT_DYNAMIC,
  OPTION_HELP,
  OPTION_IGNORE,
  OPTION_MAP,
  OPTION_NO_DEMANGLE,
  OPTION_NO_KEEP_MEMORY,
  OPTION_NO_WARN_MISMATCH,
  OPTION_NO_WARN_SEARCH_MISMATCH,
  OPTION_NOINHIBIT_EXEC,
  OPTION_NON_SHARED,
  OPTION_NO_WHOLE_ARCHIVE,
  OPTION_OFORMAT,
  OPTION_RELAX,
  OPTION_NO_RELAX,
  OPTION_RETAIN_SYMBOLS_FILE,
  OPTION_RPATH,
  OPTION_RPATH_LINK,
  OPTION_SHARED,
  OPTION_SONAME,
  OPTION_SORT_COMMON,
  OPTION_SORT_SECTION,
  OPTION_STATS,
  OPTION_SYMBOLIC,
  OPTION_SYMBOLIC_FUNCTIONS,
  OPTION_TASK_LINK,
  OPTION_TBSS,
  OPTION_TDATA,
  OPTION_TTEXT,
  OPTION_TTEXT_SEGMENT,
  OPTION_TRODATA_SEGMENT,
  OPTION_TLDATA_SEGMENT,
  OPTION_TRADITIONAL_FORMAT,
  OPTION_UR,
  OPTION_VERBOSE,
  OPTION_VERSION,
  OPTION_VERSION_SCRIPT,
  OPTION_VERSION_EXPORTS_SECTION,
  OPTION_DYNAMIC_LIST,
  OPTION_DYNAMIC_LIST_CPP_NEW,
  OPTION_DYNAMIC_LIST_CPP_TYPEINFO,
  OPTION_DYNAMIC_LIST_DATA,
  OPTION_WARN_COMMON,
  OPTION_WARN_CONSTRUCTORS,
  OPTION_WARN_FATAL,
  OPTION_NO_WARN_FATAL,
  OPTION_WARN_MULTIPLE_GP,
  OPTION_WARN_ONCE,
  OPTION_WARN_SECTION_ALIGN,
  OPTION_SPLIT_BY_RELOC,
  OPTION_SPLIT_BY_FILE ,
  OPTION_WHOLE_ARCHIVE,
  OPTION_ADD_DT_NEEDED_FOR_DYNAMIC,
  OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC,
  OPTION_ADD_DT_NEEDED_FOR_REGULAR,
  OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR,
  OPTION_WRAP,
  OPTION_FORCE_EXE_SUFFIX,
  OPTION_GC_SECTIONS,
  OPTION_NO_GC_SECTIONS,
  OPTION_PRINT_GC_SECTIONS,
  OPTION_NO_PRINT_GC_SECTIONS,
  OPTION_GC_KEEP_EXPORTED,
  OPTION_HASH_SIZE,
  OPTION_CHECK_SECTIONS,
  OPTION_NO_CHECK_SECTIONS,
  OPTION_NO_UNDEFINED,
  OPTION_INIT,
  OPTION_FINI,
  OPTION_SECTION_START,
  OPTION_UNIQUE,
  OPTION_TARGET_HELP,
  OPTION_ALLOW_SHLIB_UNDEFINED,
  OPTION_NO_ALLOW_SHLIB_UNDEFINED,
  OPTION_ALLOW_MULTIPLE_DEFINITION,
  OPTION_NO_UNDEFINED_VERSION,
  OPTION_DEFAULT_SYMVER,
  OPTION_DEFAULT_IMPORTED_SYMVER,
  OPTION_DISCARD_NONE,
  OPTION_SPARE_DYNAMIC_TAGS,
  OPTION_NO_DEFINE_COMMON,
  OPTION_NOSTDLIB,
  OPTION_NO_OMAGIC,
  OPTION_STRIP_DISCARDED,
  OPTION_NO_STRIP_DISCARDED,
  OPTION_ACCEPT_UNKNOWN_INPUT_ARCH,
  OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH,
  OPTION_PIE,
  OPTION_UNRESOLVED_SYMBOLS,
  OPTION_WARN_UNRESOLVED_SYMBOLS,
  OPTION_ERROR_UNRESOLVED_SYMBOLS,
  OPTION_WARN_SHARED_TEXTREL,
  OPTION_WARN_ALTERNATE_EM,
  OPTION_REDUCE_MEMORY_OVERHEADS,

  OPTION_PLUGIN,
  OPTION_PLUGIN_OPT,

  OPTION_DEFAULT_SCRIPT,
  OPTION_PRINT_OUTPUT_FORMAT,
  OPTION_PRINT_SYSROOT,
  OPTION_IGNORE_UNRESOLVED_SYMBOL,
  OPTION_PUSH_STATE,
  OPTION_POP_STATE,
  OPTION_PRINT_MEMORY_USAGE,
  OPTION_REQUIRE_DEFINED_SYMBOL,
  OPTION_ORPHAN_HANDLING,
  OPTION_FORCE_GROUP_ALLOCATION,
};


typedef enum input_enum {
  input_selected,
  input_script,
  input_mri_script,
  input_version_script,
  input_dynamic_list,
  input_defsym
} input_type;

extern input_type parser_input;

extern unsigned int lineno;
extern const char *lex_string;


extern int yylex (void);
extern void lex_push_file (FILE *, const char *, unsigned int);
extern void lex_redirect (const char *, const char *, unsigned int);
extern void ldlex_script (void);
extern void ldlex_inputlist (void);
extern void ldlex_mri_script (void);
extern void ldlex_version_script (void);
extern void ldlex_version_file (void);
extern void ldlex_defsym (void);
extern void ldlex_expression (void);
extern void ldlex_both (void);
extern void ldlex_command (void);
extern void ldlex_popstate (void);
extern const char* ldlex_filename (void);


extern int lex_input (void);
extern void lex_unput (int);
extern void parse_args (unsigned, char **);
# 35 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldmisc.h" 1
# 24 "/doner/binutils/binutils-7a31b38/ld/ldmisc.h"
extern void vfinfo (FILE *fp, const char *fmt, va_list arg, bfd_boolean is_warning);
extern void einfo (const char *, ...);
extern void minfo (const char *, ...);
extern void info_msg (const char *, ...);
extern void lfinfo (FILE *, const char *, ...);
extern void info_assert (const char *, unsigned int);
extern void yyerror (const char *);
extern void *xmalloc (size_t);
extern void *xrealloc (void *, size_t);
extern void xexit (int);







extern void print_space (void);
extern void print_nl (void);
# 36 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldctor.h" 1
# 25 "/doner/binutils/binutils-7a31b38/ld/ldctor.h"
extern lang_statement_list_type constructor_list;




extern bfd_boolean constructors_sorted;



struct set_info {
  struct set_info *next;
  struct bfd_link_hash_entry *h;
  bfd_reloc_code_real_type reloc;
  size_t count;
  struct set_element *elements;
};

struct set_element {
  struct set_element *next;
  const char *name;
  asection *section;
  bfd_vma value;
};



extern struct set_info *sets;

extern void ldctor_add_set_entry
  (struct bfd_link_hash_entry *, bfd_reloc_code_real_type, const char *,
   asection *, bfd_vma);
extern void ldctor_build_sets
  (void);
# 37 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldfile.h" 1
# 24 "/doner/binutils/binutils-7a31b38/ld/ldfile.h"
extern bfd_boolean ldfile_assumed_script;
extern unsigned long ldfile_output_machine;
extern enum bfd_architecture ldfile_output_architecture;
extern const char *ldfile_output_machine_name;




typedef struct search_dirs {

  struct search_dirs *next;

  const char *name;

  bfd_boolean cmdline;
} search_dirs_type;

extern search_dirs_type *search_head;

extern void ldfile_add_arch
  (const char *);
extern void ldfile_add_library_path
  (const char *, bfd_boolean cmdline);
extern void ldfile_open_command_file
  (const char *name);
extern void ldfile_open_default_command_file
  (const char *name);
extern void ldfile_open_file
  (struct lang_input_statement_struct *);
extern bfd_boolean ldfile_try_open_bfd
  (const char *, struct lang_input_statement_struct *);
extern void ldfile_set_output_arch
  (const char *, enum bfd_architecture);
extern bfd_boolean ldfile_open_file_search
  (const char *arch, struct lang_input_statement_struct *,
   const char *lib, const char *suffix);
# 38 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "/doner/binutils/binutils-7a31b38/ld/ldemul.h" 1
# 25 "/doner/binutils/binutils-7a31b38/ld/ldemul.h"
struct option;

extern void ldemul_hll
  (char *);
extern void ldemul_syslib
  (char *);
extern void ldemul_after_parse
  (void);
extern void ldemul_before_parse
  (void);
extern void ldemul_after_open
  (void);
extern void ldemul_after_allocation
  (void);
extern void ldemul_before_allocation
  (void);
extern void ldemul_set_output_arch
  (void);
extern char *ldemul_choose_target
  (int, char**);
extern void ldemul_choose_mode
  (char *);
extern void ldemul_list_emulations
  (FILE *);
extern void ldemul_list_emulation_options
  (FILE *);
extern char *ldemul_get_script
  (int *isfile);
extern void ldemul_finish
  (void);
extern void ldemul_set_symbols
  (void);
extern void ldemul_create_output_section_statements
  (void);
extern lang_output_section_statement_type *ldemul_place_orphan
  (asection *, const char *, int);
extern bfd_boolean ldemul_parse_args
  (int, char **);
extern void ldemul_add_options
  (int, char **, int, struct option **, int, struct option **);
extern bfd_boolean ldemul_handle_option
  (int);
extern bfd_boolean ldemul_unrecognized_file
  (struct lang_input_statement_struct *);
extern bfd_boolean ldemul_recognized_file
  (struct lang_input_statement_struct *);
extern bfd_boolean ldemul_open_dynamic_archive
  (const char *, struct search_dirs *, struct lang_input_statement_struct *);
extern char *ldemul_default_target
  (int, char**);
extern void after_parse_default
  (void);
extern void after_open_default
  (void);
extern void after_allocation_default
  (void);
extern void before_allocation_default
  (void);
extern void finish_default
  (void);
extern void finish_default
  (void);
extern void set_output_arch_default
  (void);
extern void syslib_default
  (char*);
extern void hll_default
  (char*);
extern int ldemul_find_potential_libraries
  (char *, struct lang_input_statement_struct *);
extern struct bfd_elf_version_expr *ldemul_new_vers_pattern
  (struct bfd_elf_version_expr *);
extern void ldemul_extra_map_file_text
  (bfd *, struct bfd_link_info *, FILE *);

typedef struct ld_emulation_xfer_struct {


  void (*before_parse) (void);


  void (*syslib) (char *);


  void (*hll) (char *);


  void (*after_parse) (void);


  void (*after_open) (void);


  void (*after_allocation) (void);


  void (*set_output_arch) (void);


  char * (*choose_target) (int, char**);


  void (*before_allocation) (void);


  char * (*get_script) (int *isfile);


  char *emulation_name;


  char *target_name;


  void (*finish) (void);


  void (*create_output_section_statements) (void);




  bfd_boolean (*open_dynamic_archive)
    (const char *arch, struct search_dirs *,
     struct lang_input_statement_struct *entry);




  lang_output_section_statement_type *(*place_orphan)
    (asection *, const char *, int);



  void (*set_symbols) (void);



  bfd_boolean (*parse_args) (int, char **);



  void (*add_options)
    (int, char **, int, struct option **, int, struct option **);



  bfd_boolean (*handle_option) (int);



  bfd_boolean (*unrecognized_file)
    (struct lang_input_statement_struct *);


  void (* list_options) (FILE *);



  bfd_boolean (*recognized_file)
    (struct lang_input_statement_struct *);





  int (* find_potential_libraries)
    (char *, struct lang_input_statement_struct *);



  struct bfd_elf_version_expr * (*new_vers_pattern)
    (struct bfd_elf_version_expr *);



  void (*extra_map_file_text)
    (bfd *, struct bfd_link_info *, FILE *);

} ld_emulation_xfer_type;

typedef enum {
  intel_ic960_ld_mode_enum,
  default_mode_enum,
  intel_gld960_ld_mode_enum
} lang_emulation_mode_enum_type;

extern ld_emulation_xfer_type *ld_emulations[];
# 39 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/fnmatch.h" 1
# 63 "./../include/fnmatch.h"
extern int fnmatch (const char *__pattern, const char *__string, int __flags)
                 ;
# 40 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/demangle.h" 1
# 32 "./../include/demangle.h"
# 1 "./../include/libiberty.h" 1
# 33 "./../include/demangle.h" 2
# 79 "./../include/demangle.h"
extern enum demangling_styles
{
  no_demangling = -1,
  unknown_demangling = 0,
  auto_demangling = (1 << 8),
  gnu_demangling = (1 << 9),
  lucid_demangling = (1 << 10),
  arm_demangling = (1 << 11),
  hp_demangling = (1 << 12),
  edg_demangling = (1 << 13),
  gnu_v3_demangling = (1 << 14),
  java_demangling = (1 << 2),
  gnat_demangling = (1 << 15),
  dlang_demangling = (1 << 16),
  rust_demangling = (1 << 17)
} current_demangling_style;
# 129 "./../include/demangle.h"
extern const struct demangler_engine
{
  const char *const demangling_style_name;
  const enum demangling_styles demangling_style;
  const char *const demangling_style_doc;
} libiberty_demanglers[];

extern char *
cplus_demangle (const char *mangled, int options);

extern int
cplus_demangle_opname (const char *opname, char *result, int options);

extern const char *
cplus_mangle_opname (const char *opname, int options);



extern void
set_cplus_marker_for_demangling (int ch);

extern enum demangling_styles
cplus_demangle_set_style (enum demangling_styles style);

extern enum demangling_styles
cplus_demangle_name_to_style (const char *name);


typedef void (*demangle_callbackref) (const char *, size_t, void *);




extern int
cplus_demangle_v3_callback (const char *mangled, int options,
                            demangle_callbackref callback, void *opaque);

extern char*
cplus_demangle_v3 (const char *mangled, int options);

extern int
java_demangle_v3_callback (const char *mangled,
                           demangle_callbackref callback, void *opaque);

extern char*
java_demangle_v3 (const char *mangled);

char *
ada_demangle (const char *mangled, int options);

extern char *
dlang_demangle (const char *mangled, int options);





extern int
rust_is_mangled (const char *mangled);






extern void
rust_demangle_sym (char *sym);




extern char *
rust_demangle (const char *mangled, int options);

enum gnu_v3_ctor_kinds {
  gnu_v3_complete_object_ctor = 1,
  gnu_v3_base_object_ctor,
  gnu_v3_complete_object_allocating_ctor,



  gnu_v3_unified_ctor,
  gnu_v3_object_ctor_group
};





extern enum gnu_v3_ctor_kinds
 is_gnu_v3_mangled_ctor (const char *name);


enum gnu_v3_dtor_kinds {
  gnu_v3_deleting_dtor = 1,
  gnu_v3_complete_object_dtor,
  gnu_v3_base_object_dtor,



  gnu_v3_unified_dtor,
  gnu_v3_object_dtor_group
};





extern enum gnu_v3_dtor_kinds
 is_gnu_v3_mangled_dtor (const char *name);
# 254 "./../include/demangle.h"
enum demangle_component_type
{

  DEMANGLE_COMPONENT_NAME,



  DEMANGLE_COMPONENT_QUAL_NAME,


  DEMANGLE_COMPONENT_LOCAL_NAME,


  DEMANGLE_COMPONENT_TYPED_NAME,


  DEMANGLE_COMPONENT_TEMPLATE,


  DEMANGLE_COMPONENT_TEMPLATE_PARAM,

  DEMANGLE_COMPONENT_FUNCTION_PARAM,


  DEMANGLE_COMPONENT_CTOR,

  DEMANGLE_COMPONENT_DTOR,


  DEMANGLE_COMPONENT_VTABLE,


  DEMANGLE_COMPONENT_VTT,



  DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,


  DEMANGLE_COMPONENT_TYPEINFO,


  DEMANGLE_COMPONENT_TYPEINFO_NAME,


  DEMANGLE_COMPONENT_TYPEINFO_FN,


  DEMANGLE_COMPONENT_THUNK,


  DEMANGLE_COMPONENT_VIRTUAL_THUNK,


  DEMANGLE_COMPONENT_COVARIANT_THUNK,

  DEMANGLE_COMPONENT_JAVA_CLASS,


  DEMANGLE_COMPONENT_GUARD,

  DEMANGLE_COMPONENT_TLS_INIT,
  DEMANGLE_COMPONENT_TLS_WRAPPER,


  DEMANGLE_COMPONENT_REFTEMP,


  DEMANGLE_COMPONENT_HIDDEN_ALIAS,


  DEMANGLE_COMPONENT_SUB_STD,


  DEMANGLE_COMPONENT_RESTRICT,


  DEMANGLE_COMPONENT_VOLATILE,


  DEMANGLE_COMPONENT_CONST,


  DEMANGLE_COMPONENT_RESTRICT_THIS,


  DEMANGLE_COMPONENT_VOLATILE_THIS,


  DEMANGLE_COMPONENT_CONST_THIS,


  DEMANGLE_COMPONENT_REFERENCE_THIS,


  DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS,



  DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,


  DEMANGLE_COMPONENT_POINTER,


  DEMANGLE_COMPONENT_REFERENCE,


  DEMANGLE_COMPONENT_RVALUE_REFERENCE,

  DEMANGLE_COMPONENT_COMPLEX,

  DEMANGLE_COMPONENT_IMAGINARY,

  DEMANGLE_COMPONENT_BUILTIN_TYPE,

  DEMANGLE_COMPONENT_VENDOR_TYPE,



  DEMANGLE_COMPONENT_FUNCTION_TYPE,



  DEMANGLE_COMPONENT_ARRAY_TYPE,



  DEMANGLE_COMPONENT_PTRMEM_TYPE,

  DEMANGLE_COMPONENT_FIXED_TYPE,


  DEMANGLE_COMPONENT_VECTOR_TYPE,


  DEMANGLE_COMPONENT_ARGLIST,



  DEMANGLE_COMPONENT_TEMPLATE_ARGLIST,


  DEMANGLE_COMPONENT_INITIALIZER_LIST,


  DEMANGLE_COMPONENT_OPERATOR,


  DEMANGLE_COMPONENT_EXTENDED_OPERATOR,


  DEMANGLE_COMPONENT_CAST,



  DEMANGLE_COMPONENT_CONVERSION,

  DEMANGLE_COMPONENT_NULLARY,


  DEMANGLE_COMPONENT_UNARY,


  DEMANGLE_COMPONENT_BINARY,


  DEMANGLE_COMPONENT_BINARY_ARGS,


  DEMANGLE_COMPONENT_TRINARY,


  DEMANGLE_COMPONENT_TRINARY_ARG1,


  DEMANGLE_COMPONENT_TRINARY_ARG2,


  DEMANGLE_COMPONENT_LITERAL,






  DEMANGLE_COMPONENT_LITERAL_NEG,


  DEMANGLE_COMPONENT_JAVA_RESOURCE,


  DEMANGLE_COMPONENT_COMPOUND_NAME,

  DEMANGLE_COMPONENT_CHARACTER,

  DEMANGLE_COMPONENT_NUMBER,

  DEMANGLE_COMPONENT_DECLTYPE,

  DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS,

  DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS,

  DEMANGLE_COMPONENT_LAMBDA,

  DEMANGLE_COMPONENT_DEFAULT_ARG,

  DEMANGLE_COMPONENT_UNNAMED_TYPE,


  DEMANGLE_COMPONENT_TRANSACTION_CLONE,



  DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,

  DEMANGLE_COMPONENT_PACK_EXPANSION,

  DEMANGLE_COMPONENT_TAGGED_NAME,

  DEMANGLE_COMPONENT_TRANSACTION_SAFE,

  DEMANGLE_COMPONENT_CLONE,
  DEMANGLE_COMPONENT_NOEXCEPT,
  DEMANGLE_COMPONENT_THROW_SPEC
};



struct demangle_operator_info;
struct demangle_builtin_type_info;






struct demangle_component
{

  enum demangle_component_type type;




  int d_printing;

  union
  {

    struct
    {


      const char *s;
      int len;
    } s_name;


    struct
    {

      const struct demangle_operator_info *op;
    } s_operator;


    struct
    {

      int args;

      struct demangle_component *name;
    } s_extended_operator;


    struct
    {

      struct demangle_component *length;

      short accum;

      short sat;
    } s_fixed;


    struct
    {

      enum gnu_v3_ctor_kinds kind;

      struct demangle_component *name;
    } s_ctor;


    struct
    {

      enum gnu_v3_dtor_kinds kind;

      struct demangle_component *name;
    } s_dtor;


    struct
    {

      const struct demangle_builtin_type_info *type;
    } s_builtin;


    struct
    {

      const char* string;

      int len;
    } s_string;


    struct
    {

      long number;
    } s_number;


    struct
    {
      int character;
    } s_character;


    struct
    {

      struct demangle_component *left;

      struct demangle_component *right;
    } s_binary;

    struct
    {

      struct demangle_component *sub;

      int num;
    } s_unary_num;

  } u;
};
# 615 "./../include/demangle.h"
extern int
cplus_demangle_fill_component (struct demangle_component *fill,
                               enum demangle_component_type,
                               struct demangle_component *left,
                               struct demangle_component *right);




extern int
cplus_demangle_fill_name (struct demangle_component *fill,
                          const char *, int);





extern int
cplus_demangle_fill_builtin_type (struct demangle_component *fill,
                                  const char *type_name);







extern int
cplus_demangle_fill_operator (struct demangle_component *fill,
                              const char *opname, int args);





extern int
cplus_demangle_fill_extended_operator (struct demangle_component *fill,
                                       int numargs,
                                       struct demangle_component *nm);




extern int
cplus_demangle_fill_ctor (struct demangle_component *fill,
                          enum gnu_v3_ctor_kinds kind,
                          struct demangle_component *name);




extern int
cplus_demangle_fill_dtor (struct demangle_component *fill,
                          enum gnu_v3_dtor_kinds kind,
                          struct demangle_component *name);
# 679 "./../include/demangle.h"
extern struct demangle_component *
cplus_demangle_v3_components (const char *mangled, int options, void **mem);
# 694 "./../include/demangle.h"
extern char *
cplus_demangle_print (int options,
                      struct demangle_component *tree,
                      int estimated_length,
                      size_t *p_allocated_size);
# 714 "./../include/demangle.h"
extern int
cplus_demangle_print_callback (int options,
                               struct demangle_component *tree,
                               demangle_callbackref callback, void *opaque);
# 41 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "./../include/hashtab.h" 1
# 42 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 1 "../bfd/elf-bfd.h" 1
# 25 "../bfd/elf-bfd.h"
# 1 "./../include/elf/common.h" 1
# 26 "../bfd/elf-bfd.h" 2
# 1 "./../include/elf/external.h" 1
# 52 "./../include/elf/external.h"
typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[4];
  unsigned char e_phoff[4];
  unsigned char e_shoff[4];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf32_External_Ehdr;

typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[8];
  unsigned char e_phoff[8];
  unsigned char e_shoff[8];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf64_External_Ehdr;



typedef struct {
  unsigned char p_type[4];
  unsigned char p_offset[4];
  unsigned char p_vaddr[4];
  unsigned char p_paddr[4];
  unsigned char p_filesz[4];
  unsigned char p_memsz[4];
  unsigned char p_flags[4];
  unsigned char p_align[4];
} Elf32_External_Phdr;

typedef struct {
  unsigned char p_type[4];
  unsigned char p_flags[4];
  unsigned char p_offset[8];
  unsigned char p_vaddr[8];
  unsigned char p_paddr[8];
  unsigned char p_filesz[8];
  unsigned char p_memsz[8];
  unsigned char p_align[8];
} Elf64_External_Phdr;



typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[4];
  unsigned char sh_addr[4];
  unsigned char sh_offset[4];
  unsigned char sh_size[4];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[4];
  unsigned char sh_entsize[4];
} Elf32_External_Shdr;

typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[8];
  unsigned char sh_addr[8];
  unsigned char sh_offset[8];
  unsigned char sh_size[8];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[8];
  unsigned char sh_entsize[8];
} Elf64_External_Shdr;



typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_size[4];
  unsigned char ch_addralign[4];
} Elf32_External_Chdr;

typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_reserved[4];
  unsigned char ch_size[8];
  unsigned char ch_addralign[8];
} Elf64_External_Chdr;



typedef struct {
  unsigned char st_name[4];
  unsigned char st_value[4];
  unsigned char st_size[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
} Elf32_External_Sym;

typedef struct {
  unsigned char st_name[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
  unsigned char st_value[8];
  unsigned char st_size[8];
} Elf64_External_Sym;

typedef struct {
  unsigned char est_shndx[4];
} Elf_External_Sym_Shndx;



typedef struct {
  unsigned char namesz[4];
  unsigned char descsz[4];
  unsigned char type[4];
  char name[1];
} Elf_External_Note;


typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
} Elf32_External_Rel;

typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
  unsigned char r_addend[4];
} Elf32_External_Rela;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
} Elf64_External_Rel;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
  unsigned char r_addend[8];
} Elf64_External_Rela;



typedef struct {
  unsigned char d_tag[4];
  union {
    unsigned char d_val[4];
    unsigned char d_ptr[4];
  } d_un;
} Elf32_External_Dyn;

typedef struct {
  unsigned char d_tag[8];
  union {
    unsigned char d_val[8];
    unsigned char d_ptr[8];
  } d_un;
} Elf64_External_Dyn;







typedef struct {
  unsigned char vd_version[2];
  unsigned char vd_flags[2];
  unsigned char vd_ndx[2];
  unsigned char vd_cnt[2];
  unsigned char vd_hash[4];
  unsigned char vd_aux[4];
  unsigned char vd_next[4];
} Elf_External_Verdef;



typedef struct {
  unsigned char vda_name[4];
  unsigned char vda_next[4];
} Elf_External_Verdaux;



typedef struct {
  unsigned char vn_version[2];
  unsigned char vn_cnt[2];
  unsigned char vn_file[4];
  unsigned char vn_aux[4];
  unsigned char vn_next[4];
} Elf_External_Verneed;



typedef struct {
  unsigned char vna_hash[4];
  unsigned char vna_flags[2];
  unsigned char vna_other[2];
  unsigned char vna_name[4];
  unsigned char vna_next[4];
} Elf_External_Vernaux;




typedef struct {
  unsigned char vs_vers[2];
} __attribute__ ((packed)) Elf_External_Versym;


typedef struct
{
  unsigned char si_boundto[2];
  unsigned char si_flags[2];
} Elf_External_Syminfo;



typedef struct
{
  unsigned char a_type[4];
  unsigned char a_val[4];
} Elf32_External_Auxv;

typedef struct
{
  unsigned char a_type[8];
  unsigned char a_val[8];
} Elf64_External_Auxv;
# 27 "../bfd/elf-bfd.h" 2
# 1 "./../include/elf/internal.h" 1
# 67 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr {
  unsigned char e_ident[16];
  bfd_vma e_entry;
  bfd_size_type e_phoff;
  bfd_size_type e_shoff;
  unsigned long e_version;
  unsigned long e_flags;
  unsigned short e_type;
  unsigned short e_machine;
  unsigned int e_ehsize;
  unsigned int e_phentsize;
  unsigned int e_phnum;
  unsigned int e_shentsize;
  unsigned int e_shnum;
  unsigned int e_shstrndx;
} Elf_Internal_Ehdr;



struct elf_internal_phdr {
  unsigned long p_type;
  unsigned long p_flags;
  bfd_vma p_offset;
  bfd_vma p_vaddr;
  bfd_vma p_paddr;
  bfd_vma p_filesz;
  bfd_vma p_memsz;
  bfd_vma p_align;
};

typedef struct elf_internal_phdr Elf_Internal_Phdr;



typedef struct elf_internal_shdr {
  unsigned int sh_name;
  unsigned int sh_type;
  bfd_vma sh_flags;
  bfd_vma sh_addr;
  file_ptr sh_offset;
  bfd_size_type sh_size;
  unsigned int sh_link;
  unsigned int sh_info;
  bfd_vma sh_addralign;
  bfd_size_type sh_entsize;


  asection * bfd_section;
  unsigned char *contents;
} Elf_Internal_Shdr;



typedef struct elf_internal_chdr {
  unsigned int ch_type;
  bfd_size_type ch_size;
  bfd_vma ch_addralign;
} Elf_Internal_Chdr;



struct elf_internal_sym {
  bfd_vma st_value;
  bfd_vma st_size;
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
  unsigned char st_target_internal;
  unsigned int st_shndx;
};

typedef struct elf_internal_sym Elf_Internal_Sym;



typedef struct elf_internal_note {
  unsigned long namesz;
  unsigned long descsz;
  unsigned long type;
  char * namedata;
  char * descdata;
  bfd_vma descpos;
} Elf_Internal_Note;



typedef struct elf_internal_rela {
  bfd_vma r_offset;
  bfd_vma r_info;
  bfd_vma r_addend;
} Elf_Internal_Rela;



typedef struct elf_internal_dyn {

  bfd_vma d_tag;
  union {

    bfd_vma d_val;
    bfd_vma d_ptr;
  } d_un;
} Elf_Internal_Dyn;



typedef struct elf_internal_verdef {
  unsigned short vd_version;
  unsigned short vd_flags;
  unsigned short vd_ndx;
  unsigned short vd_cnt;
  unsigned long vd_hash;
  unsigned long vd_aux;
  unsigned long vd_next;



  bfd *vd_bfd;
  const char *vd_nodename;
  struct elf_internal_verdef *vd_nextdef;
  struct elf_internal_verdaux *vd_auxptr;
  unsigned int vd_exp_refno;
} Elf_Internal_Verdef;



typedef struct elf_internal_verdaux {
  unsigned long vda_name;
  unsigned long vda_next;



  const char *vda_nodename;
  struct elf_internal_verdaux *vda_nextptr;
} Elf_Internal_Verdaux;



typedef struct elf_internal_verneed {
  unsigned short vn_version;
  unsigned short vn_cnt;
  unsigned long vn_file;
  unsigned long vn_aux;
  unsigned long vn_next;



  bfd *vn_bfd;
  const char *vn_filename;
  struct elf_internal_vernaux *vn_auxptr;
  struct elf_internal_verneed *vn_nextref;
} Elf_Internal_Verneed;



typedef struct elf_internal_vernaux {
  unsigned long vna_hash;
  unsigned short vna_flags;
  unsigned short vna_other;
  unsigned long vna_name;
  unsigned long vna_next;



  const char *vna_nodename;
  struct elf_internal_vernaux *vna_nextptr;
} Elf_Internal_Vernaux;




typedef struct elf_internal_versym {
  unsigned short vs_vers;
} Elf_Internal_Versym;


typedef struct
{
  unsigned short int si_boundto;
  unsigned short int si_flags;
} Elf_Internal_Syminfo;


typedef struct
{
  bfd_vma a_type;
  bfd_vma a_val;
} Elf_Internal_Auxv;





struct elf_segment_map
{

  struct elf_segment_map *next;

  unsigned long p_type;

  unsigned long p_flags;

  bfd_vma p_paddr;

  bfd_vma p_vaddr_offset;

  bfd_vma p_align;

  bfd_vma p_size;

  bfd_vma header_size;


  unsigned int p_flags_valid : 1;


  unsigned int p_paddr_valid : 1;


  unsigned int p_align_valid : 1;


  unsigned int p_size_valid : 1;

  unsigned int includes_filehdr : 1;

  unsigned int includes_phdrs : 1;

  unsigned int count;

  asection *sections[1];
};
# 28 "../bfd/elf-bfd.h" 2
# 64 "../bfd/elf-bfd.h"
typedef struct
{

  asymbol symbol;

  Elf_Internal_Sym internal_elf_sym;

  union
    {
      unsigned int hppa_arg_reloc;
      void *mips_extr;
      void *any;
    }
  tc_data;




  unsigned short version;

} elf_symbol_type;

struct elf_strtab_hash;
struct got_entry;
struct plt_entry;

union gotplt_union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
    struct got_entry *glist;
    struct plt_entry *plist;
  };

struct elf_link_virtual_table_entry
  {




    size_t size;
    bfd_boolean *used;


    struct elf_link_hash_entry *parent;
  };


enum elf_symbol_version
  {
    unknown = 0,
    unversioned,
    versioned,
    versioned_hidden
  };



struct elf_link_hash_entry
{
  struct bfd_link_hash_entry root;




  long indx;
# 143 "../bfd/elf-bfd.h"
  long dynindx;
# 154 "../bfd/elf-bfd.h"
  union gotplt_union got;


  union gotplt_union plt;


  bfd_size_type size;


  unsigned int type : 8;


  unsigned int other : 8;


  unsigned int target_internal : 8;



  unsigned int ref_regular : 1;

  unsigned int def_regular : 1;

  unsigned int ref_dynamic : 1;

  unsigned int def_dynamic : 1;


  unsigned int ref_regular_nonweak : 1;

  unsigned int dynamic_adjusted : 1;

  unsigned int needs_copy : 1;

  unsigned int needs_plt : 1;

  unsigned int non_elf : 1;

  __extension__ enum elf_symbol_version versioned : 2;

  unsigned int forced_local : 1;

  unsigned int dynamic : 1;

  unsigned int mark : 1;


  unsigned int non_got_ref : 1;



  unsigned int dynamic_def : 1;

  unsigned int ref_dynamic_nonweak : 1;


  unsigned int pointer_equality_needed : 1;

  unsigned int unique_global : 1;


  unsigned int protected_def : 1;


  unsigned int start_stop : 1;


  unsigned long dynstr_index;

  union
  {



    struct elf_link_hash_entry *weakdef;




    unsigned long elf_hash_value;
  } u;


  union
  {



    Elf_Internal_Verdef *verdef;



    struct bfd_elf_version_tree *vertree;
  } verinfo;

  union
  {


    asection *start_stop_section;


    struct elf_link_virtual_table_entry *vtable;
  } u2;
};
# 279 "../bfd/elf-bfd.h"
struct elf_link_local_dynamic_entry
{
  struct elf_link_local_dynamic_entry *next;


  bfd *input_bfd;


  long input_indx;


  long dynindx;


  Elf_Internal_Sym isym;
};

struct elf_link_loaded_list
{
  struct elf_link_loaded_list *next;
  bfd *abfd;
};


struct eh_cie_fde
{
  union {
    struct {
# 315 "../bfd/elf-bfd.h"
      struct eh_cie_fde *cie_inf;
      struct eh_cie_fde *next_for_section;
    } fde;
    struct {
# 330 "../bfd/elf-bfd.h"
      union {
 struct cie *full_cie;
  struct eh_cie_fde *merged_with;
  asection *sec;
      } u;



      unsigned int personality_offset : 8;




      unsigned int aug_str_len : 3;
      unsigned int aug_data_len : 5;


      unsigned int gc_mark : 1;



      unsigned int make_lsda_relative : 1;



      unsigned int make_per_encoding_relative : 1;




      unsigned int per_encoding_relative : 1;



      unsigned int per_encoding_aligned8 : 1;



      unsigned int add_fde_encoding : 1;


      unsigned int merged : 1;


      unsigned int pad1 : 9;
    } cie;
  } u;
  unsigned int reloc_index;
  unsigned int size;
  unsigned int offset;
  unsigned int new_offset;
  unsigned int fde_encoding : 8;
  unsigned int lsda_encoding : 8;
  unsigned int lsda_offset : 8;


  unsigned int cie : 1;


  unsigned int removed : 1;



  unsigned int add_augmentation_size : 1;




  unsigned int make_relative : 1;


  unsigned int pad1 : 4;

  unsigned int *set_loc;
};

struct eh_frame_sec_info
{
  unsigned int count;
  struct cie *cies;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_size_type range;
  bfd_vma fde;
};

struct htab;







struct dwarf_eh_frame_hdr_info
{
  struct htab *cies;
  unsigned int fde_count;



  bfd_boolean table;
  struct eh_frame_array_ent *array;
};

struct compact_eh_frame_hdr_info
{
  unsigned int allocated_entries;

  asection **entries;
};

struct eh_frame_hdr_info
{
  asection *hdr_sec;
  unsigned int array_count;
  bfd_boolean frame_hdr_is_compact;
  union
    {
      struct dwarf_eh_frame_hdr_info dwarf;
      struct compact_eh_frame_hdr_info compact;
    }
  u;
};






enum elf_target_id
{
  AARCH64_ELF_DATA = 1,
  ALPHA_ELF_DATA,
  ARC_ELF_DATA,
  ARM_ELF_DATA,
  AVR_ELF_DATA,
  BFIN_ELF_DATA,
  CRIS_ELF_DATA,
  FRV_ELF_DATA,
  HPPA32_ELF_DATA,
  HPPA64_ELF_DATA,
  I386_ELF_DATA,
  IA64_ELF_DATA,
  LM32_ELF_DATA,
  M32R_ELF_DATA,
  M68HC11_ELF_DATA,
  M68K_ELF_DATA,
  METAG_ELF_DATA,
  MICROBLAZE_ELF_DATA,
  MIPS_ELF_DATA,
  MN10300_ELF_DATA,
  NDS32_ELF_DATA,
  NIOS2_ELF_DATA,
  OR1K_ELF_DATA,
  PPC32_ELF_DATA,
  PPC64_ELF_DATA,
  PRU_ELF_DATA,
  S390_ELF_DATA,
  SH_ELF_DATA,
  SPARC_ELF_DATA,
  SPU_ELF_DATA,
  TIC6X_ELF_DATA,
  X86_64_ELF_DATA,
  XTENSA_ELF_DATA,
  XGATE_ELF_DATA,
  TILEGX_ELF_DATA,
  TILEPRO_ELF_DATA,
  RISCV_ELF_DATA,
  GENERIC_ELF_DATA
};

struct elf_sym_strtab
{
  Elf_Internal_Sym sym;
  unsigned long dest_index;
  unsigned long destshndx_index;
};



struct elf_link_hash_table
{
  struct bfd_link_hash_table root;



  enum elf_target_id hash_table_id;



  bfd_boolean dynamic_sections_created;



  bfd_boolean is_relocatable_executable;




  bfd *dynobj;





  union gotplt_union init_got_refcount;
  union gotplt_union init_plt_refcount;



  union gotplt_union init_got_offset;
  union gotplt_union init_plt_offset;



  bfd_size_type dynsymcount;
  bfd_size_type local_dynsymcount;



  struct elf_strtab_hash *dynstr;



  bfd_size_type strtabcount;



  bfd_size_type strtabsize;


  struct elf_sym_strtab *strtab;



  bfd_size_type bucketcount;



  struct bfd_link_needed_list *needed;




  asection *text_index_section;
  asection *data_index_section;


  struct elf_link_hash_entry *hgot;


  struct elf_link_hash_entry *hplt;


  struct elf_link_hash_entry *hdynamic;


  void *merge_info;


  struct stab_info stab_info;


  struct eh_frame_hdr_info eh_info;


  struct elf_link_local_dynamic_entry *dynlocal;



  struct bfd_link_needed_list *runpath;


  asection *tls_sec;
  bfd_size_type tls_size;


  struct elf_link_loaded_list *loaded;


  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
  asection *sdynrelro;
  asection *sreldynrelro;
  asection *igotplt;
  asection *iplt;
  asection *irelplt;
  asection *irelifunc;
  asection *dynsym;
};
# 659 "../bfd/elf-bfd.h"
struct sym_cache
{
  bfd *abfd;
  unsigned long indx[32];
  Elf_Internal_Sym sym[32];
};



struct elf_size_info {
  unsigned char sizeof_ehdr, sizeof_phdr, sizeof_shdr;
  unsigned char sizeof_rel, sizeof_rela, sizeof_sym, sizeof_dyn, sizeof_note;


  unsigned char sizeof_hash_entry;



  unsigned char int_rels_per_ext_rel;




  unsigned char arch_size, log_file_align;
  unsigned char elfclass, ev_current;
  int (*write_out_phdrs)
    (bfd *, const Elf_Internal_Phdr *, unsigned int);
  bfd_boolean
    (*write_shdrs_and_ehdr) (bfd *);
  bfd_boolean (*checksum_contents)
    (bfd * , void (*) (const void *, size_t, void *), void *);
  void (*write_relocs)
    (bfd *, asection *, void *);
  bfd_boolean (*swap_symbol_in)
    (bfd *, const void *, const void *, Elf_Internal_Sym *);
  void (*swap_symbol_out)
    (bfd *, const Elf_Internal_Sym *, void *, void *);
  bfd_boolean (*slurp_reloc_table)
    (bfd *, asection *, asymbol **, bfd_boolean);
  long (*slurp_symbol_table)
    (bfd *, asymbol **, bfd_boolean);
  void (*swap_dyn_in)
    (bfd *, const void *, Elf_Internal_Dyn *);
  void (*swap_dyn_out)
    (bfd *, const Elf_Internal_Dyn *, void *);




  void (*swap_reloc_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloc_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);




  void (*swap_reloca_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloca_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
};







enum elf_reloc_type_class {
  reloc_class_normal,
  reloc_class_relative,
  reloc_class_copy,
  reloc_class_ifunc,
  reloc_class_plt
};

struct elf_reloc_cookie
{
  Elf_Internal_Rela *rels, *rel, *relend;
  Elf_Internal_Sym *locsyms;
  bfd *abfd;
  size_t locsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hashes;
  int r_sym_shift;
  bfd_boolean bad_symtab;
};



typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;


struct bfd_elf_special_section
{
  const char *prefix;
  unsigned int prefix_length;






  signed int suffix_length;
  unsigned int type;
  bfd_vma attr;
};

enum action_discarded
  {
    COMPLAIN = 1,
    PRETEND = 2
  };

typedef asection * (*elf_gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

enum elf_property_kind
 {

    property_unknown = 0,

    property_ignored,

    property_corrupt,

    property_remove,

    property_number
 };

typedef struct elf_property
{
  unsigned int pr_type;
  unsigned int pr_datasz;
  union
    {

      bfd_vma number;

    } u;
  enum elf_property_kind pr_kind;
} elf_property;

typedef struct elf_property_list
{
  struct elf_property_list *next;
  struct elf_property property;
} elf_property_list;

struct bfd_elf_section_reloc_data;

struct elf_backend_data
{

  enum bfd_architecture arch;



  enum elf_target_id target_id;


  int elf_machine_code;


  int elf_osabi;


  bfd_vma maxpagesize;




  bfd_vma minpagesize;


  bfd_vma commonpagesize;


  flagword dynamic_sec_flags;



  const void *arch_data;



  void (*elf_info_to_howto)
    (bfd *, arelent *, Elf_Internal_Rela *);



  void (*elf_info_to_howto_rel)
    (bfd *, arelent *, Elf_Internal_Rela *);






  bfd_boolean (*elf_backend_sym_is_global)
    (bfd *, asymbol *);
# 881 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_object_p)
    (bfd *);




  void (*elf_backend_symbol_processing)
    (bfd *, asymbol *);



  bfd_boolean (*elf_backend_symbol_table_processing)
    (bfd *, elf_symbol_type *, unsigned int);



  int (*elf_backend_get_symbol_type)
    (Elf_Internal_Sym *, int);



  struct elf_link_hash_entry * (*elf_backend_archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);



  bfd_boolean (*elf_backend_name_local_section_symbols)
    (bfd *);





  bfd_boolean (*elf_backend_section_processing)
    (bfd *, Elf_Internal_Shdr *);



  bfd_boolean (*elf_backend_section_from_shdr)
    (bfd *, Elf_Internal_Shdr *, const char *, int);



  bfd_boolean (*elf_backend_section_flags)
    (flagword *, const Elf_Internal_Shdr *);



  const struct bfd_elf_special_section * (*get_sec_type_attr)
    (bfd *, asection *);



  bfd_boolean (*elf_backend_section_from_phdr)
    (bfd *, Elf_Internal_Phdr *, int, const char *);




  bfd_boolean (*elf_backend_fake_sections)
    (bfd *, Elf_Internal_Shdr *, asection *);





  bfd_boolean (*elf_backend_section_from_bfd_section)
    (bfd *, asection *, int *retval);
# 958 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_add_symbol_hook)
    (bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *,
     const char **name, flagword *flags, asection **sec, bfd_vma *value);





  int (*elf_backend_link_output_symbol_hook)
    (struct bfd_link_info *info, const char *, Elf_Internal_Sym *,
     asection *, struct elf_link_hash_entry *);
# 978 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_create_dynamic_sections)
    (bfd *abfd, struct bfd_link_info *info);



  bfd_boolean (*elf_backend_omit_section_dynsym)
    (bfd *output_bfd, struct bfd_link_info *info, asection *osec);



  bfd_boolean (*relocs_compatible) (const bfd_target *, const bfd_target *);
# 1000 "../bfd/elf-bfd.h"
  bfd_boolean (*check_relocs)
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);





  bfd_boolean (*check_directives)
    (bfd *abfd, struct bfd_link_info *info);





  bfd_boolean (*notice_as_needed)
    (bfd *abfd, struct bfd_link_info *info, enum notice_asneeded_action act);
# 1030 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_adjust_dynamic_symbol)
    (struct bfd_link_info *info, struct elf_link_hash_entry *h);





  bfd_boolean (*elf_backend_always_size_sections)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1050 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_size_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);



  void (*elf_backend_init_index_section)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1089 "../bfd/elf-bfd.h"
  int (*elf_backend_relocate_section)
    (bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
     asection *input_section, bfd_byte *contents, Elf_Internal_Rela *relocs,
     Elf_Internal_Sym *local_syms, asection **local_sections);
# 1101 "../bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_finish_dynamic_symbol)
    (bfd *output_bfd, struct bfd_link_info *info,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym);





  bfd_boolean (*elf_backend_finish_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);



  void (*elf_backend_begin_write_processing)
    (bfd *, struct bfd_link_info *);




  void (*elf_backend_final_write_processing)
    (bfd *, bfd_boolean linker);




  int (*elf_backend_additional_program_headers)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_modify_segment_map)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_modify_program_headers)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_allow_non_load_phdr)
    (bfd *, const Elf_Internal_Phdr *, unsigned);



  void (*gc_keep)
    (struct bfd_link_info *);



  bfd_boolean (*gc_mark_dynamic_ref)
    (struct elf_link_hash_entry *, void *);



  elf_gc_mark_hook_fn gc_mark_hook;



  bfd_boolean (*gc_mark_extra_sections)
    (struct bfd_link_info *, elf_gc_mark_hook_fn);




  bfd_boolean (*gc_sweep_hook)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);




  void (*elf_backend_post_process_headers)
    (bfd *, struct bfd_link_info *);




  const char *(*elf_backend_print_symbol_all)
    (bfd *, void *, asymbol *);





  bfd_boolean (*elf_backend_output_arch_local_syms)
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
        struct elf_link_hash_entry *));




  bfd_boolean (*elf_backend_output_arch_syms)
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
        struct elf_link_hash_entry *));



  unsigned int (*elf_backend_filter_implib_symbols)
    (bfd *, struct bfd_link_info *, asymbol **, long);






  void (*elf_backend_copy_indirect_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *,
     struct elf_link_hash_entry *);



  void (*elf_backend_hide_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);



  bfd_boolean (*elf_backend_fixup_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *);


  void (*elf_backend_merge_symbol_attribute)
    (struct elf_link_hash_entry *, const Elf_Internal_Sym *, bfd_boolean,
     bfd_boolean);



  char *(*elf_backend_get_target_dtag)
    (bfd_vma);



  bfd_boolean (*elf_backend_ignore_undef_symbol)
    (struct elf_link_hash_entry *);



  bfd_boolean (*elf_backend_emit_relocs)
    (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
     struct elf_link_hash_entry **);



  void (*elf_backend_update_relocs)
    (asection *, struct bfd_elf_section_reloc_data *);



  unsigned int (*elf_backend_count_relocs)
    (struct bfd_link_info *, asection *);



  unsigned int (*elf_backend_count_additional_relocs)
    (asection *);



  bfd_boolean (*sort_relocs_p)
    (asection *);



  bfd_boolean (*elf_backend_grok_prstatus)
    (bfd *, Elf_Internal_Note *);



  bfd_boolean (*elf_backend_grok_psinfo)
    (bfd *, Elf_Internal_Note *);


  char *(*elf_backend_write_core_note)
    (bfd *abfd, char *buf, int *bufsiz, int note_type, ...);



  flagword (*elf_backend_lookup_section_flags_hook)
    (char *);


  enum elf_reloc_type_class (*elf_backend_reloc_type_class)
  (const struct bfd_link_info *, const asection *, const Elf_Internal_Rela *);



  bfd_boolean (*elf_backend_discard_info)
    (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_ignore_discarded_relocs)
    (asection *);



  unsigned int (*action_discarded)
    (asection *);




  unsigned int (*elf_backend_eh_frame_address_size)
    (bfd *, const asection *);




  bfd_boolean (*elf_backend_can_make_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);
  bfd_boolean (*elf_backend_can_make_lsda_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);





  bfd_byte (*elf_backend_encode_eh_address)
     (bfd *abfd, struct bfd_link_info *info,
      asection *osec, bfd_vma offset,
      asection *loc_sec, bfd_vma loc_offset,
      bfd_vma *encoded);



  bfd_boolean (*elf_backend_write_section)
    (bfd *, struct bfd_link_info *, asection *, bfd_byte *);



  irix_compat_t (*elf_backend_mips_irix_compat)
    (bfd *);

  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
    (unsigned int, bfd_boolean);



  const struct ecoff_debug_swap *elf_backend_ecoff_debug_swap;



  bfd *(*elf_backend_bfd_from_remote_memory)
    (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
     int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
    bfd_size_type len));



  bfd_vma (*plt_sym_val) (bfd_vma, const asection *, const arelent *);


  bfd_boolean (*common_definition) (Elf_Internal_Sym *);


  unsigned int (*common_section_index) (asection *);


  asection *(*common_section) (asection *);


  bfd_boolean (*merge_symbol) (struct elf_link_hash_entry *,
          const Elf_Internal_Sym *, asection **,
          bfd_boolean, bfd_boolean,
          bfd *, const asection *);


  bfd_boolean (*elf_hash_symbol) (struct elf_link_hash_entry *);


  bfd_boolean (*is_function_type) (unsigned int type);




  bfd_size_type (*maybe_function_sym) (const asymbol *sym, asection *sec,
           bfd_vma *code_off);




  asection *(*get_reloc_section) (bfd *abfd, const char *name);







  bfd_boolean (*elf_backend_copy_special_section_fields)
    (const bfd *ibfd, bfd *obfd, const Elf_Internal_Shdr *isection,
     Elf_Internal_Shdr *osection);


  void (*link_order_error_handler) (const char *, ...);


  const char *relplt_name;


  int elf_machine_alt1;
  int elf_machine_alt2;

  const struct elf_size_info *s;


  const struct bfd_elf_special_section *special_sections;



  bfd_vma got_header_size;



  bfd_vma (*got_elt_size) (bfd *, struct bfd_link_info *,
      struct elf_link_hash_entry *h,
      bfd *ibfd, unsigned long symndx);


  const char *obj_attrs_vendor;


  const char *obj_attrs_section;



  int (*obj_attrs_arg_type) (int);


  unsigned int obj_attrs_section_type;






  int (*obj_attrs_order) (int);



  bfd_boolean (*obj_attrs_handle_unknown) (bfd *, int);



  enum elf_property_kind (*parse_gnu_properties) (bfd *, unsigned int,
        bfd_byte *,
        unsigned int);


  bfd_boolean (*merge_gnu_properties) (struct bfd_link_info *, bfd *,
           elf_property *, elf_property *);


  bfd *(*setup_gnu_properties) (struct bfd_link_info *);


  int (*compact_eh_encoding) (struct bfd_link_info *);


  int (*cant_unwind_opcode) (struct bfd_link_info *);


  unsigned static_tls_alignment;


  unsigned stack_align;


  unsigned long elf_strtab_flags;





  unsigned collect : 1;





  unsigned type_change_ok : 1;




  unsigned may_use_rel_p : 1;




  unsigned may_use_rela_p : 1;






  unsigned default_use_rela_p : 1;


  unsigned rela_plts_and_copies_p : 1;




  unsigned rela_normal : 1;



  unsigned dtrel_excludes_plt : 1;



  unsigned sign_extend_vma : 1;

  unsigned want_got_plt : 1;
  unsigned plt_readonly : 1;
  unsigned want_plt_sym : 1;
  unsigned plt_not_loaded : 1;
  unsigned plt_alignment : 4;
  unsigned can_gc_sections : 1;
  unsigned can_refcount : 1;
  unsigned want_got_sym : 1;
  unsigned want_dynbss : 1;
  unsigned want_dynrelro : 1;




  unsigned want_p_paddr_set_to_zero : 1;



  unsigned no_page_alias : 1;





  unsigned default_execstack : 1;




  unsigned caches_rawsize : 1;



  unsigned extern_protected_data : 1;



  unsigned always_renumber_dynsyms : 1;
};



struct bfd_elf_section_reloc_data
{


  Elf_Internal_Shdr *hdr;

  unsigned int count;


  int idx;


  struct elf_link_hash_entry **hashes;
};




struct bfd_elf_section_data
{

  Elf_Internal_Shdr this_hdr;


  struct flag_info *section_flag_info;



  struct bfd_elf_section_reloc_data rel, rela;


  int this_idx;





  int dynindx;


  asection *linked_to;




  Elf_Internal_Rela *relocs;



  void *local_dynrel;


  asection *sreloc;

  union {

    const char *name;


    struct bfd_symbol *id;
  } group;



  asection *sec_group;



  asection *next_in_group;



  struct eh_cie_fde *fde_list;


  asection *eh_frame_entry;


  void *sec_info;
};
# 1670 "../bfd/elf-bfd.h"
typedef struct obj_attribute
{
# 1680 "../bfd/elf-bfd.h"
  int type;
  unsigned int i;
  char *s;
} obj_attribute;

typedef struct obj_attribute_list
{
  struct obj_attribute_list *next;
  unsigned int tag;
  obj_attribute attr;
} obj_attribute_list;
# 1702 "../bfd/elf-bfd.h"
enum
{
  Tag_NULL = 0,
  Tag_File = 1,
  Tag_Section = 2,
  Tag_Symbol = 3,
  Tag_compatibility = 32
};



struct sdt_note
{
  struct sdt_note *next;
  bfd_size_type size;
  bfd_byte data[1];
};


struct core_elf_obj_tdata
{
  int signal;
  int pid;
  int lwpid;
  char* program;
  char* command;
};


struct output_elf_obj_tdata
{
  struct elf_segment_map *seg_map;
  struct elf_strtab_hash *strtab_ptr;


  asymbol **section_syms;



  asection *eh_frame_hdr;


  struct
  {
    bfd_boolean (*after_write_object_contents) (bfd *);
    const char *style;
    asection *sec;
  } build_id;


  bfd_size_type program_header_size;


  file_ptr next_file_pos;

  int num_section_syms;
  unsigned int shstrtab_section, strtab_section;


  unsigned int stack_flags;



  bfd_boolean linker;


  bfd_boolean flags_init;
};




enum elf_gnu_symbols
{
  elf_gnu_symbol_none = 0,
  elf_gnu_symbol_any = 1 << 0,
  elf_gnu_symbol_ifunc = (elf_gnu_symbol_any | 1 << 1),
  elf_gnu_symbol_unique = (elf_gnu_symbol_any | 1 << 2),
  elf_gnu_symbol_all = (elf_gnu_symbol_ifunc | elf_gnu_symbol_unique)
};

typedef struct elf_section_list
{
  Elf_Internal_Shdr hdr;
  unsigned int ndx;
  struct elf_section_list * next;
} elf_section_list;




struct elf_obj_tdata
{
  Elf_Internal_Ehdr elf_header[1];
  Elf_Internal_Shdr **elf_sect_ptr;
  Elf_Internal_Phdr *phdr;
  Elf_Internal_Shdr symtab_hdr;
  Elf_Internal_Shdr shstrtab_hdr;
  Elf_Internal_Shdr strtab_hdr;
  Elf_Internal_Shdr dynsymtab_hdr;
  Elf_Internal_Shdr dynstrtab_hdr;
  Elf_Internal_Shdr dynversym_hdr;
  Elf_Internal_Shdr dynverref_hdr;
  Elf_Internal_Shdr dynverdef_hdr;
  elf_section_list * symtab_shndx_list;
  bfd_vma gp;
  unsigned int gp_size;
  unsigned int num_elf_sections;




  struct elf_link_hash_entry **sym_hashes;




  union
    {
      bfd_signed_vma *refcounts;
      bfd_vma *offsets;
      struct got_entry **ents;
    } local_got;
# 1834 "../bfd/elf-bfd.h"
  const char *dt_name;



  const char *dt_audit;


  void *line_info;


  struct dwarf1_debug *dwarf1_find_line_info;


  void *dwarf2_find_line_info;


  void *elf_find_function_cache;


  unsigned int cverdefs;


  unsigned int cverrefs;


  Elf_Internal_Verdef *verdef;


  Elf_Internal_Verneed *verref;


  asection *eh_frame_section;


  void *symbuf;



  elf_property_list *properties;

  obj_attribute known_obj_attributes[2][71];
  obj_attribute_list *other_obj_attributes[2];




  struct sdt_note *sdt_note_head;

  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;

  unsigned int symtab_section, dynsymtab_section;
  unsigned int dynversym_section, dynverdef_section, dynverref_section;



  enum elf_target_id object_id;




  enum dynamic_lib_link_class dyn_lib_class;






  bfd_boolean bad_symtab;

  enum elf_gnu_symbols has_gnu_symbols;


  struct core_elf_obj_tdata *core;


  struct output_elf_obj_tdata *o;
};
# 1960 "../bfd/elf-bfd.h"
extern void _bfd_elf_swap_verdef_in
  (bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *);
extern void _bfd_elf_swap_verdef_out
  (bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *);
extern void _bfd_elf_swap_verdaux_in
  (bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *);
extern void _bfd_elf_swap_verdaux_out
  (bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *);
extern void _bfd_elf_swap_verneed_in
  (bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *);
extern void _bfd_elf_swap_verneed_out
  (bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *);
extern void _bfd_elf_swap_vernaux_in
  (bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *);
extern void _bfd_elf_swap_vernaux_out
  (bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *);
extern void _bfd_elf_swap_versym_in
  (bfd *, const Elf_External_Versym *, Elf_Internal_Versym *);
extern void _bfd_elf_swap_versym_out
  (bfd *, const Elf_Internal_Versym *, Elf_External_Versym *);

extern unsigned int _bfd_elf_section_from_bfd_section
  (bfd *, asection *);
extern char *bfd_elf_string_from_elf_section
  (bfd *, unsigned, unsigned);
extern Elf_Internal_Sym *bfd_elf_get_elf_syms
  (bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *,
   Elf_External_Sym_Shndx *);
extern const char *bfd_elf_sym_name
  (bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *, asection *);

extern bfd_boolean _bfd_elf_copy_private_bfd_data
  (bfd *, bfd *);
extern bfd_boolean _bfd_elf_print_private_bfd_data
  (bfd *, void *);
const char * _bfd_elf_get_symbol_version_string
  (bfd *, asymbol *, bfd_boolean *);
extern void bfd_elf_print_symbol
  (bfd *, void *, asymbol *, bfd_print_symbol_type);

extern unsigned int _bfd_elf_eh_frame_address_size
  (bfd *, const asection *);
extern bfd_byte _bfd_elf_encode_eh_address
  (bfd *abfd, struct bfd_link_info *info, asection *osec, bfd_vma offset,
   asection *loc_sec, bfd_vma loc_offset, bfd_vma *encoded);
extern bfd_boolean _bfd_elf_can_make_relative
  (bfd *input_bfd, struct bfd_link_info *info, asection *eh_frame_section);

extern enum elf_reloc_type_class _bfd_elf_reloc_type_class
  (const struct bfd_link_info *, const asection *,
   const Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rela_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rel_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, bfd_vma);
extern bfd_vma _bfd_elf_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);

extern unsigned long bfd_elf_hash
  (const char *);
extern unsigned long bfd_elf_gnu_hash
  (const char *);

extern bfd_reloc_status_type bfd_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
extern bfd_boolean bfd_elf_allocate_object
  (bfd *, size_t, enum elf_target_id);
extern bfd_boolean bfd_elf_make_object
  (bfd *);
extern bfd_boolean bfd_elf_mkcorefile
  (bfd *);
extern bfd_boolean _bfd_elf_make_section_from_shdr
  (bfd *, Elf_Internal_Shdr *, const char *, int);
extern bfd_boolean _bfd_elf_make_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int, const char *);
extern struct bfd_hash_entry *_bfd_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
extern struct bfd_link_hash_table *_bfd_elf_link_hash_table_create
  (bfd *);
extern void _bfd_elf_link_hash_table_free
  (bfd *);
extern void _bfd_elf_link_hash_copy_indirect
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
extern void _bfd_elf_link_hash_hide_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);
extern bfd_boolean _bfd_elf_link_hash_fixup_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);
extern bfd_boolean _bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*)
     (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
   unsigned int, enum elf_target_id);
extern bfd_boolean _bfd_elf_slurp_version_tables
  (bfd *, bfd_boolean);
extern bfd_boolean _bfd_elf_merge_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_match_sections_by_type
  (bfd *, const asection *, bfd *, const asection *);
extern bfd_boolean bfd_elf_is_group_section
  (bfd *, const struct bfd_section *);
extern bfd_boolean _bfd_elf_section_already_linked
  (bfd *, asection *, struct bfd_link_info *);
extern void bfd_elf_set_group_contents
  (bfd *, asection *, void *);
extern unsigned int _bfd_elf_filter_global_symbols
  (bfd *, struct bfd_link_info *, asymbol **, long);
extern asection *_bfd_elf_check_kept_section
  (asection *, struct bfd_link_info *);

extern void _bfd_elf_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
extern bfd_boolean _bfd_elf_size_group_sections
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_fixup_group_sections
(bfd *, asection *);
extern bfd_boolean _bfd_elf_copy_private_header_data
  (bfd *, bfd *);
extern bfd_boolean _bfd_elf_copy_private_symbol_data
  (bfd *, asymbol *, bfd *, asymbol *);


extern bfd_boolean _bfd_elf_init_private_section_data
  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_copy_private_section_data
  (bfd *, asection *, bfd *, asection *);
extern bfd_boolean _bfd_elf_write_object_contents
  (bfd *);
extern bfd_boolean _bfd_elf_write_corefile_contents
  (bfd *);
extern bfd_boolean _bfd_elf_set_section_contents
  (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
extern long _bfd_elf_get_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_dynamic_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **);
extern long _bfd_elf_get_reloc_upper_bound
  (bfd *, sec_ptr);
extern long _bfd_elf_canonicalize_reloc
  (bfd *, sec_ptr, arelent **, asymbol **);
extern asection * _bfd_elf_get_dynamic_reloc_section
  (bfd *, asection *, bfd_boolean);
extern asection * _bfd_elf_make_dynamic_reloc_section
  (asection *, bfd *, unsigned int, bfd *, bfd_boolean);
extern long _bfd_elf_get_dynamic_reloc_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
extern asymbol *_bfd_elf_make_empty_symbol
  (bfd *);
extern void _bfd_elf_get_symbol_info
  (bfd *, asymbol *, symbol_info *);
extern bfd_boolean _bfd_elf_is_local_label_name
  (bfd *, const char *);
extern alent *_bfd_elf_get_lineno
  (bfd *, asymbol *);
extern bfd_boolean _bfd_elf_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long);
extern bfd_boolean _bfd_elf_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *);
extern bfd_boolean _bfd_elf_find_line
  (bfd *, asymbol **, asymbol *, const char **, unsigned int *);
extern bfd_boolean _bfd_elf_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *);
extern asymbol *_bfd_elf_find_function
  (bfd *, asymbol **, asection *, bfd_vma, const char **, const char **);


extern int _bfd_elf_sizeof_headers
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_new_section_hook
  (bfd *, asection *);
extern const struct bfd_elf_special_section *_bfd_elf_get_special_section
  (const char *, const struct bfd_elf_special_section *, unsigned int);
extern const struct bfd_elf_special_section *_bfd_elf_get_sec_type_attr
  (bfd *, asection *);


extern void _bfd_elf_no_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);

extern bfd_boolean bfd_section_from_shdr
  (bfd *, unsigned int shindex);
extern bfd_boolean bfd_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int);

extern int _bfd_elf_symbol_from_bfd_symbol
  (bfd *, asymbol **);

extern Elf_Internal_Sym *bfd_sym_from_r_symndx
  (struct sym_cache *, bfd *, unsigned long);
extern asection *bfd_section_from_elf_index
  (bfd *, unsigned int);

extern struct elf_strtab_hash * _bfd_elf_strtab_init
  (void);
extern void _bfd_elf_strtab_free
  (struct elf_strtab_hash *);
extern size_t _bfd_elf_strtab_add
  (struct elf_strtab_hash *, const char *, bfd_boolean);
extern void _bfd_elf_strtab_addref
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_delref
  (struct elf_strtab_hash *, size_t);
extern unsigned int _bfd_elf_strtab_refcount
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_clear_all_refs
  (struct elf_strtab_hash *);
extern void *_bfd_elf_strtab_save
  (struct elf_strtab_hash *);
extern void _bfd_elf_strtab_restore
  (struct elf_strtab_hash *, void *);
extern bfd_size_type _bfd_elf_strtab_size
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_offset
  (struct elf_strtab_hash *, size_t);
extern bfd_boolean _bfd_elf_strtab_emit
  (bfd *, struct elf_strtab_hash *);
extern void _bfd_elf_strtab_finalize
  (struct elf_strtab_hash *);

extern bfd_boolean bfd_elf_parse_eh_frame_entries
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_parse_eh_frame_entry
  (struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern void _bfd_elf_parse_eh_frame
  (bfd *, struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern bfd_boolean _bfd_elf_end_eh_frame_parsing
  (struct bfd_link_info *info);

extern bfd_boolean _bfd_elf_discard_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *,
   bfd_boolean (*) (bfd_vma, void *), struct elf_reloc_cookie *);
extern bfd_boolean _bfd_elf_adjust_eh_frame_global_symbol
  (struct elf_link_hash_entry *, void *);
extern bfd_boolean _bfd_elf_discard_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_vma _bfd_elf_eh_frame_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);
extern bfd_boolean _bfd_elf_write_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
bfd_boolean _bfd_elf_write_section_eh_frame_entry
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
extern bfd_boolean _bfd_elf_fixup_eh_frame_hdr (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_write_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_eh_frame_present
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_eh_frame_entry_present
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_maybe_strip_eh_frame_hdr
  (struct bfd_link_info *);

extern bfd_boolean _bfd_elf_hash_symbol (struct elf_link_hash_entry *);

extern long _bfd_elf_link_lookup_local_dynindx
  (struct bfd_link_info *, bfd *, long);
extern bfd_boolean _bfd_elf_compute_section_file_positions
  (bfd *, struct bfd_link_info *);
extern file_ptr _bfd_elf_assign_file_position_for_section
  (Elf_Internal_Shdr *, file_ptr, bfd_boolean);

extern bfd_boolean _bfd_elf_validate_reloc
  (bfd *, arelent *);

extern bfd_boolean _bfd_elf_link_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_link_omit_section_dynsym
  (bfd *, struct bfd_link_info *, asection *);
extern bfd_boolean _bfd_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_create_got_section
  (bfd *, struct bfd_link_info *);
extern asection *_bfd_elf_section_for_symbol
  (struct elf_reloc_cookie *, unsigned long, bfd_boolean);
extern struct elf_link_hash_entry *_bfd_elf_define_linkage_sym
  (bfd *, struct bfd_link_info *, asection *, const char *);
extern void _bfd_elf_init_1_index_section
  (bfd *, struct bfd_link_info *);
extern void _bfd_elf_init_2_index_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_elfcore_make_pseudosection
  (bfd *, char *, size_t, ufile_ptr);
extern char *_bfd_elfcore_strndup
  (bfd *, char *, size_t);

extern Elf_Internal_Rela *_bfd_elf_link_read_relocs
  (bfd *, asection *, void *, Elf_Internal_Rela *, bfd_boolean);

extern bfd_boolean _bfd_elf_link_output_relocs
  (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
   struct elf_link_hash_entry **);

extern bfd_boolean _bfd_elf_adjust_dynamic_copy
  (struct bfd_link_info *, struct elf_link_hash_entry *, asection *);

extern bfd_boolean _bfd_elf_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_boolean _bfd_elf_symbol_refs_local_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_reloc_status_type bfd_elf_perform_complex_relocation
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma);

extern bfd_boolean _bfd_elf_setup_sections
  (bfd *);

extern struct bfd_link_hash_entry *bfd_elf_define_start_stop
  (struct bfd_link_info *, const char *, asection *);

extern void _bfd_elf_post_process_headers (bfd * , struct bfd_link_info *);

extern const bfd_target *bfd_elf32_object_p
  (bfd *);
extern const bfd_target *bfd_elf32_core_file_p
  (bfd *);
extern char *bfd_elf32_core_file_failing_command
  (bfd *);
extern int bfd_elf32_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf32_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf32_core_file_pid
  (bfd *);

extern bfd_boolean bfd_elf32_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf32_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf32_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_phdr_in
  (bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf32_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *);
extern void bfd_elf32_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf32_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf32_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf32_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf32_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern bfd_boolean bfd_elf32_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf32_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf32_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern const bfd_target *bfd_elf64_object_p
  (bfd *);
extern const bfd_target *bfd_elf64_core_file_p
  (bfd *);
extern char *bfd_elf64_core_file_failing_command
  (bfd *);
extern int bfd_elf64_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf64_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf64_core_file_pid
  (bfd *);

extern bfd_boolean bfd_elf64_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf64_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf64_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_phdr_in
  (bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf64_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *);
extern void bfd_elf64_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf64_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf64_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf64_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf64_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern bfd_boolean bfd_elf64_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf64_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern bfd_boolean _bfd_elf_default_relocs_compatible
  (const bfd_target *, const bfd_target *);

extern bfd_boolean _bfd_elf_relocs_compatible
  (const bfd_target *, const bfd_target *);
extern bfd_boolean _bfd_elf_notice_as_needed
  (bfd *, struct bfd_link_info *, enum notice_asneeded_action);

extern struct elf_link_hash_entry *_bfd_elf_archive_symbol_lookup
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_elf_link_add_symbols
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_add_dynamic_entry
  (struct bfd_link_info *, bfd_vma, bfd_vma);
extern bfd_boolean _bfd_elf_link_check_relocs
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_link_record_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

extern int bfd_elf_link_record_local_dynamic_symbol
  (struct bfd_link_info *, bfd *, long);

extern bfd_boolean _bfd_elf_close_and_cleanup
  (bfd *);

extern bfd_boolean _bfd_elf_common_definition
  (Elf_Internal_Sym *);

extern unsigned int _bfd_elf_common_section_index
  (asection *);

extern asection *_bfd_elf_common_section
  (asection *);

extern bfd_vma _bfd_elf_default_got_elt_size
(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, bfd *,
 unsigned long);

extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
  (bfd *, arelent *, struct bfd_symbol *, void *,
   asection *, bfd *, char **);

extern bfd_boolean bfd_elf_final_link
  (bfd *, struct bfd_link_info *);

extern void _bfd_elf_gc_keep
  (struct bfd_link_info *info);

extern bfd_boolean bfd_elf_gc_mark_dynamic_ref_symbol
  (struct elf_link_hash_entry *h, void *inf);

extern bfd_boolean bfd_elf_gc_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_record_vtinherit
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern bfd_boolean bfd_elf_gc_record_vtentry
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern asection *_bfd_elf_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

extern asection *_bfd_elf_gc_mark_rsec
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *, bfd_boolean *);

extern bfd_boolean _bfd_elf_gc_mark_reloc
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern bfd_boolean _bfd_elf_gc_mark_fdes
  (struct bfd_link_info *, asection *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern bfd_boolean _bfd_elf_gc_mark
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn);

extern bfd_boolean _bfd_elf_gc_mark_extra_sections
  (struct bfd_link_info *, elf_gc_mark_hook_fn);

extern bfd_boolean bfd_elf_gc_common_finalize_got_offsets
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_common_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_reloc_symbol_deleted_p
  (bfd_vma, void *);

extern struct elf_segment_map * _bfd_elf_make_dynamic_segment
  (bfd *, asection *);

extern bfd_boolean _bfd_elf_map_sections_to_segments
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_elf_is_function_type (unsigned int);

extern bfd_size_type _bfd_elf_maybe_function_sym (const asymbol *, asection *,
        bfd_vma *);

extern asection *_bfd_elf_plt_get_reloc_section (bfd *, const char *);

extern int bfd_elf_get_default_section_type (flagword);

extern bfd_boolean bfd_elf_lookup_section_flags
  (struct bfd_link_info *, struct flag_info *, asection *);

extern Elf_Internal_Phdr * _bfd_elf_find_segment_containing_section
  (bfd * abfd, asection * section);


extern unsigned int _bfd_elf_ppc_at_tls_transform
  (unsigned int, unsigned int);

extern unsigned int _bfd_elf_ppc_at_tprel_transform
  (unsigned int, unsigned int);

extern bfd_boolean _bfd_elf_ppc_set_arch (bfd *);

extern void _bfd_elf_ppc_merge_fp_attributes (bfd *, struct bfd_link_info *);


extern char *elfcore_write_note
  (bfd *, char *, int *, const char *, int, const void *, int);
extern char *elfcore_write_prpsinfo
  (bfd *, char *, int *, const char *, const char *);
extern char *elfcore_write_prstatus
  (bfd *, char *, int *, long, int, const void *);
extern char * elfcore_write_pstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_prfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_prxfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_xstatereg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vmx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vsx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_timer
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todcmp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_ctrs
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_prefix
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_last_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_system_call
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_tdb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_low
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_high
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_cb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_bc
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_arm_vfp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_tls
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_watch
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_lwpstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_register_note
  (bfd *, char *, int *, const char *, const void *, int);
# 2563 "../bfd/elf-bfd.h"
struct elf_internal_linux_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long pr_flag;
    unsigned int pr_uid;
    unsigned int pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
    char pr_fname[16 + 1];
    char pr_psargs[80 + 1];
  };


extern char *elfcore_write_linux_prpsinfo32
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);


extern char *elfcore_write_linux_prpsinfo64
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);


extern char *elfcore_write_ppc_linux_prpsinfo32
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);

extern bfd *_bfd_elf32_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));
extern bfd *_bfd_elf64_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));

extern bfd_vma bfd_elf_obj_attr_size (bfd *);
extern void bfd_elf_set_obj_attr_contents (bfd *, bfd_byte *, bfd_vma);
extern int bfd_elf_get_obj_attr_int (bfd *, int, unsigned int);
extern void bfd_elf_add_obj_attr_int (bfd *, int, unsigned int, unsigned int);


extern void bfd_elf_add_obj_attr_string (bfd *, int, unsigned int, const char *);


extern void bfd_elf_add_obj_attr_int_string (bfd *, int, unsigned int,
          unsigned int, const char *);




extern char *_bfd_elf_attr_strdup (bfd *, const char *);
extern void _bfd_elf_copy_obj_attributes (bfd *, bfd *);
extern int _bfd_elf_obj_attrs_arg_type (bfd *, int, unsigned int);
extern void _bfd_elf_parse_attributes (bfd *, Elf_Internal_Shdr *);
extern bfd_boolean _bfd_elf_merge_object_attributes
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_merge_unknown_attribute_low (bfd *, bfd *, int);
extern bfd_boolean _bfd_elf_merge_unknown_attribute_list (bfd *, bfd *);
extern Elf_Internal_Shdr *_bfd_elf_single_rel_hdr (asection *sec);

extern bfd_boolean _bfd_elf_parse_gnu_properties
  (bfd *, Elf_Internal_Note *);
extern elf_property * _bfd_elf_get_property
  (bfd *, unsigned int, unsigned int);
extern bfd *_bfd_elf_link_setup_gnu_properties
  (struct bfd_link_info *);







struct elf_dyn_relocs
{
  struct elf_dyn_relocs *next;


  asection *sec;


  bfd_size_type count;


  bfd_size_type pc_count;
};

extern bfd_boolean _bfd_elf_create_ifunc_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_allocate_ifunc_dyn_relocs
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_dyn_relocs **, bfd_boolean *, unsigned int,
   unsigned int, unsigned int, bfd_boolean);
extern long _bfd_elf_ifunc_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **, asection *,
   bfd_vma *(*) (bfd *, asymbol **, asection *, asection *));

extern void elf_append_rela (bfd *, asection *, Elf_Internal_Rela *);
extern void elf_append_rel (bfd *, asection *, Elf_Internal_Rela *);

extern bfd_vma elf64_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf64_r_sym (bfd_vma);
extern bfd_vma elf32_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf32_r_sym (bfd_vma);


extern asection _bfd_elf_large_com_section;
# 43 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2

# 1 "/doner/binutils/binutils-7a31b38/ld/plugin.h" 1
# 25 "/doner/binutils/binutils-7a31b38/ld/plugin.h"
extern bfd_boolean report_plugin_symbols;



extern bfd_boolean no_more_claiming;



struct ld_plugin_input_file;


extern void plugin_opt_plugin (const char *plugin);



extern int plugin_opt_plugin_arg (const char *arg);


extern void plugin_load_plugins (void);


extern const char *plugin_error_plugin (void);


extern void plugin_maybe_claim (lang_input_statement_type *);


extern int plugin_call_all_symbols_read (void);


extern void plugin_call_cleanup (void);
# 45 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 2
# 58 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static struct obstack stat_obstack;
static struct obstack map_obstack;



static const char *entry_symbol_default = "start";
static bfd_boolean placed_commons = 0;
static bfd_boolean map_head_is_link_order = 0;
static lang_output_section_statement_type *default_common_section;
static bfd_boolean map_option_f;
static bfd_vma print_dot;
static lang_input_statement_type *first_file;
static const char *current_target;
static lang_statement_list_type statement_list;
static lang_statement_list_type *stat_save[10];
static lang_statement_list_type **stat_save_ptr = &stat_save[0];
static struct unique_sections *unique_section_list;
static struct asneeded_minfo *asneeded_list_head;
static unsigned int opb_shift = 0;


static void exp_init_os (etree_type *);
static lang_input_statement_type *lookup_name (const char *);
static void insert_undefined (const char *);
static bfd_boolean sort_def_symbol (struct bfd_link_hash_entry *, void *);
static void print_statement (lang_statement_union_type *,
        lang_output_section_statement_type *);
static void print_statement_list (lang_statement_union_type *,
      lang_output_section_statement_type *);
static void print_statements (void);
static void print_input_section (asection *, bfd_boolean);
static bfd_boolean lang_one_common (struct bfd_link_hash_entry *, void *);
static void lang_record_phdrs (void);
static void lang_do_version_exports_section (void);
static void lang_finalize_version_expr_head
  (struct bfd_elf_version_expr_head *);
static void lang_do_memory_regions (void);


const char *output_target;
lang_output_section_statement_type *abs_output_section;
lang_statement_list_type lang_output_section_statement;
lang_statement_list_type *stat_ptr = &statement_list;
lang_statement_list_type file_chain = { 
# 101 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 101 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           , 
# 101 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                             ((void *)0) 
# 101 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                  };
lang_statement_list_type input_file_chain;
struct bfd_sym_chain entry_symbol = { 
# 103 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 103 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         , 
# 103 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0) 
# 103 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                };
const char *entry_section = ".text";
struct lang_input_statement_flags input_flags;
bfd_boolean entry_from_cmdline;
bfd_boolean undef_from_cmdline;
bfd_boolean lang_has_input_file = 0;
bfd_boolean had_output_filename = 0;
bfd_boolean lang_float_flag = 0;
bfd_boolean delete_output_file_on_failure = 0;
struct lang_phdr *lang_phdr_list;
struct lang_nocrossrefs *nocrossref_list;
struct asneeded_minfo **asneeded_list_tail;



int lang_statement_iteration = 0;
# 138 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
void *
stat_alloc (size_t size)
{
  return __extension__ ({ struct obstack *__h = (&stat_obstack); __extension__ ({ struct obstack *__o = (__h); size_t __len = ((size)); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < __len) _obstack_newchunk (__o, __len); ((void) ((__o)->next_free += (__len))); }); __extension__ ({ struct obstack *__o1 = (__h); void *__value = (void *) __o1->object_base; if (__o1->next_free == __value) __o1->maybe_empty_object = 1; __o1->next_free = ((sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (((__o1->next_free) - (sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (__o1->alignment_mask)) & ~(__o1->alignment_mask))); if ((size_t) (__o1->next_free - (char *) __o1->chunk) > (size_t) (__o1->chunk_limit - (char *) __o1->chunk)) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; __value; }); });
}

static int
name_match (const char *pattern, const char *name)
{
  if ((strpbrk ((pattern), "?*[") != 
# 147 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 147 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ))
    return fnmatch (pattern, name, 0);
  return strcmp (pattern, name);
}




static char *
archive_path (const char *pattern)
{
  char *p = 
# 158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;

  if (link_info.path_separator == 0)
    return p;

  p = strchr (pattern, link_info.path_separator);
# 173 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  return p;
}




static bfd_boolean
input_statement_is_archive_path (const char *file_spec, char *sep,
     lang_input_statement_type *f)
{
  bfd_boolean match = 0;

  if ((*(sep + 1) == 0
       || name_match (sep + 1, f->filename) == 0)
      && ((sep != file_spec)
   == (f->the_bfd != 
# 188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0) 
# 188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         && f->the_bfd->my_archive != 
# 188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                      ((void *)0)
# 188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                          )))
    {
      match = 1;

      if (sep != file_spec)
 {
   const char *aname = f->the_bfd->my_archive->filename;
   *sep = 0;
   match = name_match (file_spec, aname) == 0;
   *sep = link_info.path_separator;
 }
    }
  return match;
}

static bfd_boolean
unique_section_p (const asection *sec,
    const lang_output_section_statement_type *os)
{
  struct unique_sections *unam;
  const char *secnam;

  if (!link_info.resolve_section_groups
      && sec->owner != 
# 211 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
      
# 212 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && ((*((sec->owner)->xvec->_bfd_is_group_section)) (sec->owner, sec)))
    return !(os != 
# 213 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
      
# 214 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && strcmp (os->name, "/DISCARD/") == 0);

  secnam = sec->name;
  for (unam = unique_section_list; unam; unam = unam->next)
    if (name_match (unam->name, secnam) == 0)
      return 1;

  return 0;
}






static bfd_boolean
walk_wild_file_in_exclude_list (struct name_list *exclude_list,
                                lang_input_statement_type *file)
{
  struct name_list *list_tmp;

  for (list_tmp = exclude_list;
       list_tmp;
       list_tmp = list_tmp->next)
    {
      char *p = archive_path (list_tmp->name);

      if (p != 
# 241 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 241 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
 {
   if (input_statement_is_archive_path (list_tmp->name, p, file))
     return 1;
 }

      else if (name_match (list_tmp->name, file->filename) == 0)
 return 1;




      else if (file->the_bfd != 
# 253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
        
# 254 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       && file->the_bfd->my_archive != 
# 254 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
        
# 255 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       && name_match (list_tmp->name,
         file->the_bfd->my_archive->filename) == 0)
 return 1;
    }

  return 0;
}






static void
walk_wild_consider_section (lang_wild_statement_type *ptr,
       lang_input_statement_type *file,
       asection *s,
       struct wildcard_list *sec,
       callback_t callback,
       void *data)
{

  if (walk_wild_file_in_exclude_list (sec->spec.exclude_name_list, file))
    return;

  (*callback) (ptr, sec, s, ptr->section_flag_list, file, data);
}




static void
walk_wild_section_general (lang_wild_statement_type *ptr,
      lang_input_statement_type *file,
      callback_t callback,
      void *data)
{
  asection *s;
  struct wildcard_list *sec;

  for (s = file->the_bfd->sections; s != 
# 295 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 295 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; s = s->next)
    {
      sec = ptr->section_list;
      if (sec == 
# 298 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 298 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    )
 (*callback) (ptr, sec, s, ptr->section_flag_list, file, data);

      while (sec != 
# 301 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 301 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       )
 {
   bfd_boolean skip = 0;

   if (sec->spec.name != 
# 305 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 305 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
     {
       const char *sname = ((void) file->the_bfd, (s)->name);

       skip = name_match (sec->spec.name, sname) != 0;
     }

   if (!skip)
     walk_wild_consider_section (ptr, file, s, sec, callback, data);

   sec = sec->next;
 }
    }
}




typedef struct
{
  asection *found_section;
  bfd_boolean multiple_sections_found;
} section_iterator_callback_data;

static bfd_boolean
section_iterator_callback (bfd *abfd __attribute__ ((__unused__)), asection *s, void *data)
{
  section_iterator_callback_data *d = (section_iterator_callback_data *) data;

  if (d->found_section != 
# 334 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 334 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
    {
      d->multiple_sections_found = 1;
      return 1;
    }

  d->found_section = s;
  return 0;
}

static asection *
find_section (lang_input_statement_type *file,
       struct wildcard_list *sec,
       bfd_boolean *multiple_sections_found)
{
  section_iterator_callback_data cb_data = { 
# 349 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 349 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                , 0 };

  bfd_get_section_by_name_if (file->the_bfd, sec->spec.name,
         section_iterator_callback, &cb_data);
  *multiple_sections_found = cb_data.multiple_sections_found;
  return cb_data.found_section;
}







static bfd_boolean
is_simple_wild (const char *name)
{
  size_t len = strcspn (name, "*?[");
  return len >= 4 && name[len] == '*' && name[len + 1] == '\0';
}

static bfd_boolean
match_simple_wild (const char *pattern, const char *name)
{


  if (pattern[0] != name[0] || pattern[1] != name[1]
      || pattern[2] != name[2] || pattern[3] != name[3])
    return 0;

  pattern += 4;
  name += 4;
  while (*pattern != '*')
    if (*name++ != *pattern++)
      return 0;

  return 1;
}




static unsigned long
get_init_priority (const char *name)
{
  char *end;
  unsigned long init_priority;
# 410 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  if (strncmp (name, ".init_array.", 12) == 0
      || strncmp (name, ".fini_array.", 12) == 0)
    {
      init_priority = strtoul (name + 12, &end, 10);
      return *end ? 0 : init_priority;
    }
  else if (strncmp (name, ".ctors.", 7) == 0
    || strncmp (name, ".dtors.", 7) == 0)
    {
      init_priority = strtoul (name + 7, &end, 10);
      return *end ? 0 : 65535 - init_priority;
    }

  return 0;
}



static int
compare_section (sort_type sort, asection *asec, asection *bsec)
{
  int ret;
  unsigned long ainit_priority, binit_priority;

  switch (sort)
    {
    default:
      ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 437, __PRETTY_FUNCTION__);

    case by_init_priority:
      ainit_priority
 = get_init_priority (((void) asec->owner, (asec)->name));
      binit_priority
 = get_init_priority (((void) bsec->owner, (bsec)->name));
      if (ainit_priority == 0 || binit_priority == 0)
 goto sort_by_name;
      ret = ainit_priority - binit_priority;
      if (ret)
 break;
      else
 goto sort_by_name;

    case by_alignment_name:
      ret = (((bsec)->alignment_power)
      - ((asec)->alignment_power));
      if (ret)
 break;


    case by_name:
sort_by_name:
      ret = strcmp (((void) asec->owner, (asec)->name),
      ((void) bsec->owner, (bsec)->name));
      break;

    case by_name_alignment:
      ret = strcmp (((void) asec->owner, (asec)->name),
      ((void) bsec->owner, (bsec)->name));
      if (ret)
 break;


    case by_alignment:
      ret = (((bsec)->alignment_power)
      - ((asec)->alignment_power));
      break;
    }

  return ret;
}





static lang_section_bst_type **
wild_sort_fast (lang_wild_statement_type *wild,
  struct wildcard_list *sec,
  lang_input_statement_type *file __attribute__ ((__unused__)),
  asection *section)
{
  lang_section_bst_type **tree;

  tree = &wild->tree;
  if (!wild->filenames_sorted
      && (sec == 
# 495 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0) 
# 495 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     || sec->spec.sorted == none))
    {

      while (*tree)
 tree = &((*tree)->right);
      return tree;
    }

  while (*tree)
    {

      if (compare_section (sec->spec.sorted, section, (*tree)->section) < 0)
 tree = &((*tree)->left);
      else
 tree = &((*tree)->right);
    }

  return tree;
}



static void
output_section_callback_fast (lang_wild_statement_type *ptr,
         struct wildcard_list *sec,
         asection *section,
         struct flag_info *sflag_list __attribute__ ((__unused__)),
         lang_input_statement_type *file,
         void *output)
{
  lang_section_bst_type *node;
  lang_section_bst_type **tree;
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;

  if (unique_section_p (section, os))
    return;

  node = (lang_section_bst_type *) xmalloc (sizeof (lang_section_bst_type));
  node->left = 0;
  node->right = 0;
  node->section = section;

  tree = wild_sort_fast (ptr, sec, file, section);
  if (tree != 
# 540 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 540 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    *tree = node;
}



static void
output_section_callback_tree_to_list (lang_wild_statement_type *ptr,
          lang_section_bst_type *tree,
          void *output)
{
  if (tree->left)
    output_section_callback_tree_to_list (ptr, tree->left, output);

  lang_add_section (&ptr->children, tree->section, 
# 554 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                  ((void *)0)
# 554 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                      ,
      (lang_output_section_statement_type *) output);

  if (tree->right)
    output_section_callback_tree_to_list (ptr, tree->right, output);

  free (tree);
}




static void
walk_wild_section_specs1_wild0 (lang_wild_statement_type *ptr,
    lang_input_statement_type *file,
    callback_t callback,
    void *data)
{





  bfd_boolean multiple_sections_found;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    walk_wild_section_general (ptr, file, callback, data);
  else if (s0)
    walk_wild_consider_section (ptr, file, s0, sec0, callback, data);
}

static void
walk_wild_section_specs1_wild1 (lang_wild_statement_type *ptr,
    lang_input_statement_type *file,
    callback_t callback,
    void *data)
{
  asection *s;
  struct wildcard_list *wildsec0 = ptr->handler_data[0];

  for (s = file->the_bfd->sections; s != 
# 596 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 596 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; s = s->next)
    {
      const char *sname = ((void) file->the_bfd, (s)->name);
      bfd_boolean skip = !match_simple_wild (wildsec0->spec.name, sname);

      if (!skip)
 walk_wild_consider_section (ptr, file, s, wildsec0, callback, data);
    }
}

static void
walk_wild_section_specs2_wild1 (lang_wild_statement_type *ptr,
    lang_input_statement_type *file,
    callback_t callback,
    void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *wildsec1 = ptr->handler_data[1];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }



  for (s = file->the_bfd->sections; s != 
# 626 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 626 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; s = s->next)
    {



      if (s == s0)
 walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
 {
   const char *sname = ((void) file->the_bfd, (s)->name);
   bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);

   if (!skip)
     walk_wild_consider_section (ptr, file, s, wildsec1, callback,
     data);
 }
    }
}

static void
walk_wild_section_specs3_wild2 (lang_wild_statement_type *ptr,
    lang_input_statement_type *file,
    callback_t callback,
    void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *wildsec1 = ptr->handler_data[1];
  struct wildcard_list *wildsec2 = ptr->handler_data[2];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  for (s = file->the_bfd->sections; s != 
# 664 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 664 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; s = s->next)
    {
      if (s == s0)
 walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
 {
   const char *sname = ((void) file->the_bfd, (s)->name);
   bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);

   if (!skip)
     walk_wild_consider_section (ptr, file, s, wildsec1, callback, data);
   else
     {
       skip = !match_simple_wild (wildsec2->spec.name, sname);
       if (!skip)
  walk_wild_consider_section (ptr, file, s, wildsec2, callback,
         data);
     }
 }
    }
}

static void
walk_wild_section_specs4_wild2 (lang_wild_statement_type *ptr,
    lang_input_statement_type *file,
    callback_t callback,
    void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *sec1 = ptr->handler_data[1];
  struct wildcard_list *wildsec2 = ptr->handler_data[2];
  struct wildcard_list *wildsec3 = ptr->handler_data[3];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found), *s1;

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  s1 = find_section (file, sec1, &multiple_sections_found);
  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  for (s = file->the_bfd->sections; s != 
# 713 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 713 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; s = s->next)
    {
      if (s == s0)
 walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
 if (s == s1)
   walk_wild_consider_section (ptr, file, s, sec1, callback, data);
 else
   {
     const char *sname = ((void) file->the_bfd, (s)->name);
     bfd_boolean skip = !match_simple_wild (wildsec2->spec.name,
         sname);

     if (!skip)
       walk_wild_consider_section (ptr, file, s, wildsec2, callback,
       data);
     else
       {
  skip = !match_simple_wild (wildsec3->spec.name, sname);
  if (!skip)
    walk_wild_consider_section (ptr, file, s, wildsec3,
           callback, data);
       }
   }
    }
}

static void
walk_wild_section (lang_wild_statement_type *ptr,
     lang_input_statement_type *file,
     callback_t callback,
     void *data)
{
  if (file->flags.just_syms)
    return;

  (*ptr->walk_wild_section_handler) (ptr, file, callback, data);
}






static bfd_boolean
wild_spec_can_overlap (const char *name1, const char *name2)
{
  size_t prefix1_len = strcspn (name1, "?*[");
  size_t prefix2_len = strcspn (name2, "?*[");
  size_t min_prefix_len;




  if (name1[prefix1_len] == '\0')
    prefix1_len++;
  if (name2[prefix2_len] == '\0')
    prefix2_len++;

  min_prefix_len = prefix1_len < prefix2_len ? prefix1_len : prefix2_len;

  return memcmp (name1, name2, min_prefix_len) == 0;
}




static void
analyze_walk_wild_section_handler (lang_wild_statement_type *ptr)
{
  int sec_count = 0;
  int wild_name_count = 0;
  struct wildcard_list *sec;
  int signature;
  int data_counter;

  ptr->walk_wild_section_handler = walk_wild_section_general;
  ptr->handler_data[0] = 
# 790 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 790 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            ;
  ptr->handler_data[1] = 
# 791 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 791 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            ;
  ptr->handler_data[2] = 
# 792 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 792 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            ;
  ptr->handler_data[3] = 
# 793 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 793 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            ;
  ptr->tree = 
# 794 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 794 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ;







  for (sec = ptr->section_list; sec != 
# 802 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 802 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; sec = sec->next)
    {
      ++sec_count;
      if (sec->spec.name == 
# 805 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 805 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
 return;
      if ((strpbrk ((sec->spec.name), "?*[") != 
# 807 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
         ((void *)0)
# 807 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
         ))
 {
   ++wild_name_count;
   if (!is_simple_wild (sec->spec.name))
     return;
 }
    }




  if (sec_count == 0 || sec_count > 4)
    return;


  for (sec = ptr->section_list; sec != 
# 822 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 822 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; sec = sec->next)
    {
      struct wildcard_list *sec2;
      for (sec2 = sec->next; sec2 != 
# 825 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                    ((void *)0)
# 825 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                        ; sec2 = sec2->next)
 {
   if (wild_spec_can_overlap (sec->spec.name, sec2->spec.name))
     return;
 }
    }

  signature = (sec_count << 8) + wild_name_count;
  switch (signature)
    {
    case 0x0100:
      ptr->walk_wild_section_handler = walk_wild_section_specs1_wild0;
      break;
    case 0x0101:
      ptr->walk_wild_section_handler = walk_wild_section_specs1_wild1;
      break;
    case 0x0201:
      ptr->walk_wild_section_handler = walk_wild_section_specs2_wild1;
      break;
    case 0x0302:
      ptr->walk_wild_section_handler = walk_wild_section_specs3_wild2;
      break;
    case 0x0402:
      ptr->walk_wild_section_handler = walk_wild_section_specs4_wild2;
      break;
    default:
      return;
    }






  data_counter = 0;
  for (sec = ptr->section_list; sec != 
# 860 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 860 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; sec = sec->next)
    if (!(strpbrk ((sec->spec.name), "?*[") != 
# 861 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
        ((void *)0)
# 861 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
        ))
      ptr->handler_data[data_counter++] = sec;
  for (sec = ptr->section_list; sec != 
# 863 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 863 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; sec = sec->next)
    if ((strpbrk ((sec->spec.name), "?*[") != 
# 864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       ((void *)0)
# 864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       ))
      ptr->handler_data[data_counter++] = sec;
}



static void
walk_wild_file (lang_wild_statement_type *s,
  lang_input_statement_type *f,
  callback_t callback,
  void *data)
{
  if (walk_wild_file_in_exclude_list (s->exclude_name_list, f))
    return;

  if (f->the_bfd == 
# 879 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
      
# 880 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || !bfd_check_format (f->the_bfd, bfd_archive))
    walk_wild_section (s, f, callback, data);
  else
    {
      bfd *member;



      member = bfd_openr_next_archived_file (f->the_bfd, 
# 888 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                        ((void *)0)
# 888 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                            );
      while (member != 
# 889 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 889 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
 {





   if (member->usrdata != 
# 896 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 896 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
     {
       walk_wild_section (s,
     (lang_input_statement_type *) member->usrdata,
     callback, data);
     }

   member = bfd_openr_next_archived_file (f->the_bfd, member);
 }
    }
}

static void
walk_wild (lang_wild_statement_type *s, callback_t callback, void *data)
{
  const char *file_spec = s->filename;
  char *p;

  if (file_spec == 
# 914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
    {

      lang_input_statement_type *f; for (f = (lang_input_statement_type *) file_chain.head; f != (lang_input_statement_type *) 
# 917 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 917 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ; f = (lang_input_statement_type *) f->next)
 {
   walk_wild_file (s, f, callback, data);
 }
    }
  else if ((p = archive_path (file_spec)) != 
# 922 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 922 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                )
    {
      lang_input_statement_type *f; for (f = (lang_input_statement_type *) file_chain.head; f != (lang_input_statement_type *) 
# 924 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 924 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ; f = (lang_input_statement_type *) f->next)
 {
   if (input_statement_is_archive_path (file_spec, p, f))
     walk_wild_file (s, f, callback, data);
 }
    }
  else if ((strpbrk ((file_spec), "?*[") != 
# 930 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 930 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
          ))
    {
      lang_input_statement_type *f; for (f = (lang_input_statement_type *) file_chain.head; f != (lang_input_statement_type *) 
# 932 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 932 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ; f = (lang_input_statement_type *) f->next)
 {
   if (fnmatch (file_spec, f->filename, 0) == 0)
     walk_wild_file (s, f, callback, data);
 }
    }
  else
    {
      lang_input_statement_type *f;


      f = lookup_name (file_spec);
      if (f)
 walk_wild_file (s, f, callback, data);
    }
}





void
lang_for_each_statement_worker (void (*func) (lang_statement_union_type *),
    lang_statement_union_type *s)
{
  for (; s != 
# 957 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 957 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      func (s);

      switch (s->header.type)
 {
 case lang_constructors_statement_enum:
   lang_for_each_statement_worker (func, constructor_list.head);
   break;
 case lang_output_section_statement_enum:
   if (s->output_section_statement.constraint != -1)
     lang_for_each_statement_worker
       (func, s->output_section_statement.children.head);
   break;
 case lang_wild_statement_enum:
   lang_for_each_statement_worker (func,
       s->wild_statement.children.head);
   break;
 case lang_group_statement_enum:
   lang_for_each_statement_worker (func,
       s->group_statement.children.head);
   break;
 case lang_data_statement_enum:
 case lang_reloc_statement_enum:
 case lang_object_symbols_statement_enum:
 case lang_output_statement_enum:
 case lang_target_statement_enum:
 case lang_input_section_enum:
 case lang_input_statement_enum:
 case lang_assignment_statement_enum:
 case lang_padding_statement_enum:
 case lang_address_statement_enum:
 case lang_fill_statement_enum:
 case lang_insert_statement_enum:
   break;
 default:
   do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",993); } while (0);
   break;
 }
    }
}

void
lang_for_each_statement (void (*func) (lang_statement_union_type *))
{
  lang_for_each_statement_worker (func, statement_list.head);
}



void
lang_list_init (lang_statement_list_type *list)
{
  list->head = 
# 1010 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1010 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  ;
  list->tail = &list->head;
}

void
push_stat_ptr (lang_statement_list_type *new_ptr)
{
  if (stat_save_ptr >= stat_save + sizeof (stat_save) / sizeof (stat_save[0]))
    ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 1018, __PRETTY_FUNCTION__);
  *stat_save_ptr++ = stat_ptr;
  stat_ptr = new_ptr;
}

void
pop_stat_ptr (void)
{
  if (stat_save_ptr <= stat_save)
    ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 1027, __PRETTY_FUNCTION__);
  stat_ptr = *--stat_save_ptr;
}



static lang_statement_union_type *
new_statement (enum statement_enum type,
        size_t size,
        lang_statement_list_type *list)
{
  lang_statement_union_type *new_stmt;

  new_stmt = (lang_statement_union_type *) stat_alloc (size);
  new_stmt->header.type = type;
  new_stmt->header.next = 
# 1042 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 1042 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             ;
  lang_statement_append (list, new_stmt, &new_stmt->header.next);
  return new_stmt;
}
# 1056 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static lang_input_statement_type *
new_afile (const char *name,
    lang_input_file_enum_type file_type,
    const char *target,
    bfd_boolean add_to_list)
{
  lang_input_statement_type *p;

  lang_has_input_file = 1;

  if (add_to_list)
    p = (lang_input_statement_type *) (lang_input_statement_type *) new_statement (lang_input_statement_enum, sizeof (lang_input_statement_type), stat_ptr);
  else
    {
      p = (lang_input_statement_type *)
   stat_alloc (sizeof (lang_input_statement_type));
      p->header.type = lang_input_statement_enum;
      p->header.next = 
# 1073 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 1073 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ;
    }

  memset (&p->the_bfd, 0,
   sizeof (*p) - 
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                __builtin_offsetof (
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                lang_input_statement_type
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                , 
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                the_bfd
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                )
# 1077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                             );
  p->target = target;
  p->flags.dynamic = input_flags.dynamic;
  p->flags.add_DT_NEEDED_for_dynamic = input_flags.add_DT_NEEDED_for_dynamic;
  p->flags.add_DT_NEEDED_for_regular = input_flags.add_DT_NEEDED_for_regular;
  p->flags.whole_archive = input_flags.whole_archive;
  p->flags.sysrooted = input_flags.sysrooted;

  switch (file_type)
    {
    case lang_input_file_is_symbols_only_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = 1;
      p->flags.just_syms = 1;
      break;
    case lang_input_file_is_fake_enum:
      p->filename = name;
      p->local_sym_name = name;
      break;
    case lang_input_file_is_l_enum:
      if (name[0] == ':' && name[1] != '\0')
 {
   p->filename = name + 1;
   p->flags.full_name_provided = 1;
 }
      else
 p->filename = name;
      p->local_sym_name = concat ("-l", name, (const char *) 
# 1105 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                            ((void *)0)
# 1105 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                );
      p->flags.maybe_archive = 1;
      p->flags.real = 1;
      p->flags.search_dirs = 1;
      break;
    case lang_input_file_is_marker_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.search_dirs = 1;
      break;
    case lang_input_file_is_search_file_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = 1;
      p->flags.search_dirs = 1;
      break;
    case lang_input_file_is_file_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = 1;
      break;
    default:
      do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",1127); } while (0);
    }

  lang_statement_append (&input_file_chain,
    (lang_statement_union_type *) p,
    &p->next_real_file);
  return p;
}

lang_input_statement_type *
lang_add_input_file (const char *name,
       lang_input_file_enum_type file_type,
       const char *target)
{
  if (name != 
# 1141 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
      
# 1142 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && (*name == '=' || (strncmp ((name), ("$SYSROOT"), sizeof ("$SYSROOT") - 1) == 0)))
    {
      lang_input_statement_type *ret;
      char *sysrooted_name
 = concat (ld_sysroot,
    name + (*name == '=' ? 1 : strlen ("$SYSROOT")),
    (const char *) 
# 1148 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1148 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      );
# 1157 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      unsigned int outer_sysrooted = input_flags.sysrooted;
      input_flags.sysrooted = 0;
      ret = new_afile (sysrooted_name, file_type, target, 1);
      input_flags.sysrooted = outer_sysrooted;
      return ret;
    }

  return new_afile (name, file_type, target, 1);
}

struct out_section_hash_entry
{
  struct bfd_hash_entry root;
  lang_statement_union_type s;
};



static struct bfd_hash_table output_section_statement_table;




static struct bfd_hash_entry *
output_section_statement_newfunc (struct bfd_hash_entry *entry,
      struct bfd_hash_table *table,
      const char *string)
{
  lang_output_section_statement_type **nextp;
  struct out_section_hash_entry *ret;

  if (entry == 
# 1188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1188 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    {
      entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
          sizeof (*ret));
      if (entry == 
# 1192 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1192 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
 return entry;
    }

  entry = bfd_hash_newfunc (entry, table, string);
  if (entry == 
# 1197 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1197 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    return entry;

  ret = (struct out_section_hash_entry *) entry;
  memset (&ret->s, 0, sizeof (ret->s));
  ret->s.header.type = lang_output_section_statement_enum;
  ret->s.output_section_statement.subsection_alignment = -1;
  ret->s.output_section_statement.section_alignment = -1;
  ret->s.output_section_statement.block_value = 1;
  lang_list_init (&ret->s.output_section_statement.children);
  lang_statement_append (stat_ptr, &ret->s, &ret->s.header.next);




  if (lang_output_section_statement.head != 
# 1212 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 1212 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               )
    ret->s.output_section_statement.prev
      = ((lang_output_section_statement_type *)
  ((char *) lang_output_section_statement.tail
   - 
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    __builtin_offsetof (
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
    lang_output_section_statement_type
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    , 
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
    next
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    )
# 1216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                       ));




  nextp = &ret->s.output_section_statement.next;
  lang_statement_append (&lang_output_section_statement,
    &ret->s,
    (lang_statement_union_type **) nextp);
  return &ret->root;
}

static void
output_section_statement_table_init (void)
{
  if (!bfd_hash_table_init_n (&output_section_statement_table,
         output_section_statement_newfunc,
         sizeof (struct out_section_hash_entry),
         61))
    einfo (gettext ("%P%F: can not create hash table: %E\n"));
}

static void
output_section_statement_table_free (void)
{
  bfd_hash_table_free (&output_section_statement_table);
}



void
lang_init (void)
{
  _obstack_begin ((&stat_obstack), (1000), 0, (xmalloc), (free));

  stat_ptr = &statement_list;

  output_section_statement_table_init ();

  lang_list_init (stat_ptr);

  lang_list_init (&input_file_chain);
  lang_list_init (&lang_output_section_statement);
  lang_list_init (&file_chain);
  first_file = lang_add_input_file (
# 1260 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 1260 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       , lang_input_file_is_marker_enum,
        
# 1261 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       ((void *)0)
# 1261 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
           );
  abs_output_section =
    lang_output_section_statement_lookup ("*ABS*", 0, 1);

  abs_output_section->bfd_section = (&_bfd_std_section[2]);

  asneeded_list_head = 
# 1267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 1267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ;
  asneeded_list_tail = &asneeded_list_head;
}

void
lang_finish (void)
{
  output_section_statement_table_free ();
}
# 1299 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static lang_memory_region_type *lang_memory_region_list;
static lang_memory_region_type **lang_memory_region_list_tail
  = &lang_memory_region_list;

lang_memory_region_type *
lang_memory_region_lookup (const char *const name, bfd_boolean create)
{
  lang_memory_region_name *n;
  lang_memory_region_type *r;
  lang_memory_region_type *new_region;


  if (name == 
# 1311 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 1311 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    return 
# 1312 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 1312 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              ;

  for (r = lang_memory_region_list; r != 
# 1314 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 1314 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; r = r->next)
    for (n = &r->name_list; n != 
# 1315 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
# 1315 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                    ; n = n->next)
      if (strcmp (n->name, name) == 0)
 {
   if (create)
     einfo (gettext ("%P:%S: warning: redeclaration of memory region `%s'\n"),
     
# 1320 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    ((void *)0)
# 1320 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
        , name);
   return r;
 }

  if (!create && strcmp (name, "*default*"))
    einfo (gettext ("%P:%S: warning: memory region `%s' not declared\n"),
    
# 1326 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
   ((void *)0)
# 1326 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       , name);

  new_region = (lang_memory_region_type *)
      stat_alloc (sizeof (lang_memory_region_type));

  new_region->name_list.name = xstrdup (name);
  new_region->name_list.next = 
# 1332 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 1332 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  ;
  new_region->next = 
# 1333 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 1333 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        ;
  new_region->origin_exp = 
# 1334 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 1334 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              ;
  new_region->origin = 0;
  new_region->length_exp = 
# 1336 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 1336 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              ;
  new_region->length = ~(bfd_size_type) 0;
  new_region->current = 0;
  new_region->last_os = 
# 1339 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 1339 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           ;
  new_region->flags = 0;
  new_region->not_flags = 0;
  new_region->had_full_message = 0;

  *lang_memory_region_list_tail = new_region;
  lang_memory_region_list_tail = &new_region->next;

  return new_region;
}

void
lang_memory_region_alias (const char *alias, const char *region_name)
{
  lang_memory_region_name *n;
  lang_memory_region_type *r;
  lang_memory_region_type *region;




  if (strcmp (region_name, "*default*") == 0
      || strcmp (alias, "*default*") == 0)
    einfo (gettext ("%F%P:%S: error: alias for default memory region\n"), 
# 1362 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                                  ((void *)0)
# 1362 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                      );



  region = 
# 1366 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 1366 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              ;
  for (r = lang_memory_region_list; r != 
# 1367 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 1367 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; r = r->next)
    for (n = &r->name_list; n != 
# 1368 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
# 1368 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                    ; n = n->next)
      {
 if (region == 
# 1370 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0) 
# 1370 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   && strcmp (n->name, region_name) == 0)
   region = r;
 if (strcmp (n->name, alias) == 0)
   einfo (gettext ("%F%P:%S: error: redefinition of memory region " "alias `%s'\n")
                    ,
   
# 1375 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0)
# 1375 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      , alias);
      }


  if (region == 
# 1379 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 1379 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
    einfo (gettext ("%F%P:%S: error: memory region `%s' " "for alias `%s' does not exist\n")
                                        ,
    
# 1382 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
   ((void *)0)
# 1382 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       , region_name, alias);


  n = (lang_memory_region_name *) stat_alloc (sizeof (lang_memory_region_name));
  n->name = xstrdup (alias);
  n->next = region->name_list.next;
  region->name_list.next = n;
}

static lang_memory_region_type *
lang_memory_default (asection *section)
{
  lang_memory_region_type *p;

  flagword sec_flags = section->flags;


  if ((sec_flags & (0x001 | 0x008 | 0x010)) == 0x001)
    sec_flags |= 0x020;

  for (p = lang_memory_region_list; p != 
# 1402 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 1402 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; p = p->next)
    {
      if ((p->flags & sec_flags) != 0
   && (p->not_flags & sec_flags) == 0)
 {
   return p;
 }
    }
  return lang_memory_region_lookup ("*default*", 0);
}



lang_output_section_statement_type *
lang_output_section_get (const asection *output_section)
{
  return ((output_section)->userdata);
}






lang_output_section_statement_type *
lang_output_section_statement_lookup (const char *name,
          int constraint,
          bfd_boolean create)
{
  struct out_section_hash_entry *entry;

  entry = ((struct out_section_hash_entry *)
    bfd_hash_lookup (&output_section_statement_table, name,
       create, 0));
  if (entry == 
# 1436 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1436 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    {
      if (create)
 einfo (gettext ("%P%F: failed creating section `%s': %E\n"), name);
      return 
# 1440 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 1440 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
    }

  if (entry->s.output_section_statement.name != 
# 1443 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 1443 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   )
    {


      struct out_section_hash_entry *last_ent;

      name = entry->s.output_section_statement.name;
      if (create && constraint == 382)



 last_ent = entry;
      else
 do
   {
     if (constraint == entry->s.output_section_statement.constraint
  || (constraint == 0
      && entry->s.output_section_statement.constraint >= 0))
       return &entry->s.output_section_statement;
     last_ent = entry;
     entry = (struct out_section_hash_entry *) entry->root.next;
   }
 while (entry != 
# 1465 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
        
# 1466 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       && name == entry->s.output_section_statement.name);

      if (!create)
 return 
# 1469 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       ((void *)0)
# 1469 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
           ;

      entry
 = ((struct out_section_hash_entry *)
    output_section_statement_newfunc (
# 1473 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 1473 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         ,
          &output_section_statement_table,
          name));
      if (entry == 
# 1476 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1476 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
 {
   einfo (gettext ("%P%F: failed creating section `%s': %E\n"), name);
   return 
# 1479 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
         ((void *)0)
# 1479 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
             ;
 }
      entry->root = last_ent->root;
      last_ent->root.next = &entry->root;
    }

  entry->s.output_section_statement.name = name;
  entry->s.output_section_statement.constraint = constraint;
  return &entry->s.output_section_statement;
}





lang_output_section_statement_type *
next_matching_output_section_statement (lang_output_section_statement_type *os,
     int constraint)
{


  struct out_section_hash_entry *entry = (struct out_section_hash_entry *)
    ((char *) os
     - 
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
      __builtin_offsetof (
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      struct out_section_hash_entry
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
      , 
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      s.output_section_statement
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
      )
# 1502 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                          );
  const char *name = os->name;

  do { if (!(name == entry->root.string)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",1505); } while (0);
  do
    {
      entry = (struct out_section_hash_entry *) entry->root.next;
      if (entry == 
# 1509 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
   
# 1510 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || name != entry->s.output_section_statement.name)
 return 
# 1511 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       ((void *)0)
# 1511 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
           ;
    }
  while (constraint != entry->s.output_section_statement.constraint
  && (constraint != 0
      || entry->s.output_section_statement.constraint < 0));

  return &entry->s.output_section_statement;
}






lang_output_section_statement_type *
lang_output_section_find_by_flags (const asection *sec,
       flagword sec_flags,
       lang_output_section_statement_type **exact,
       lang_match_sec_type_func match_type)
{
  lang_output_section_statement_type *first, *look, *found;
  flagword look_flags, differ;



  first = &lang_output_section_statement.head->output_section_statement;
  first = first->next;


  found = 
# 1540 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
         ((void *)0)
# 1540 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
             ;
  for (look = first; look; look = look->next)
    {
      look_flags = look->flags;
      if (look->bfd_section != 
# 1544 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 1544 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
 {
   look_flags = look->bfd_section->flags;
   if (match_type && !match_type (link_info.output_bfd,
      look->bfd_section,
      sec->owner, sec))
     continue;
 }
      differ = look_flags ^ sec_flags;
      if (!(differ & (0x100 | 0x001 | 0x002 | 0x008
        | 0x010 | 0x400000 | 0x400)))
 found = look;
    }
  if (found != 
# 1557 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1557 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    {
      if (exact != 
# 1559 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1559 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
 *exact = found;
      return found;
    }

  if ((sec_flags & 0x010) != 0
      && (sec_flags & 0x001) != 0)
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1571 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1571 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {
       look_flags = look->bfd_section->flags;
       if (match_type && !match_type (link_info.output_bfd,
          look->bfd_section,
          sec->owner, sec))
  continue;
     }
   differ = look_flags ^ sec_flags;
   if (!(differ & (0x100 | 0x001 | 0x002
     | 0x010 | 0x400000 | 0x400)))
     found = look;
 }
    }
  else if ((sec_flags & 0x008) != 0
    && (sec_flags & 0x001) != 0)
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1592 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1592 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {
       look_flags = look->bfd_section->flags;
       if (match_type && !match_type (link_info.output_bfd,
          look->bfd_section,
          sec->owner, sec))
  continue;
     }
   differ = look_flags ^ sec_flags;
   if (!(differ & (0x100 | 0x001 | 0x002
     | 0x008 | 0x400000))
       || (!(differ & (0x100 | 0x001 | 0x002
         | 0x008))
    && !(look_flags & 0x400000)))
     found = look;
 }
    }
  else if ((sec_flags & 0x400) != 0
    && (sec_flags & 0x001) != 0)
    {


      bfd_boolean seen_thread_local = 0;

      match_type = 
# 1616 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1616 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      ;
      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1620 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1620 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     look_flags = look->bfd_section->flags;

   differ = look_flags ^ (sec_flags | 0x002 | 0x100);
   if (!(differ & (0x400 | 0x001)))
     {

       if (!(look_flags & 0x002)
    && (sec_flags & 0x002))



  break;
       found = look;
       seen_thread_local = 1;
     }
   else if (seen_thread_local)
     break;
   else if (!(differ & (0x100 | 0x001 | 0x002)))
     found = look;
 }
    }
  else if ((sec_flags & 0x400000) != 0
    && (sec_flags & 0x001) != 0)
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1649 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1649 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {
       look_flags = look->bfd_section->flags;
       if (match_type && !match_type (link_info.output_bfd,
          look->bfd_section,
          sec->owner, sec))
  continue;
     }
   differ = look_flags ^ sec_flags;
   if (!(differ & (0x100 | 0x001 | 0x002
     | 0x400))
       || ((look_flags & 0x400000)
    && !(sec_flags & 0x100)))
     found = look;
 }
    }
  else if ((sec_flags & 0x100) != 0
    && (sec_flags & 0x001) != 0)
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1672 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1672 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {
       look_flags = look->bfd_section->flags;
       if (match_type && !match_type (link_info.output_bfd,
          look->bfd_section,
          sec->owner, sec))
  continue;
     }
   differ = look_flags ^ sec_flags;
   if (!(differ & (0x100 | 0x001 | 0x002
     | 0x400000 | 0x400)))
     found = look;
 }
    }
  else if ((sec_flags & 0x001) != 0)
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1692 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1692 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {
       look_flags = look->bfd_section->flags;
       if (match_type && !match_type (link_info.output_bfd,
          look->bfd_section,
          sec->owner, sec))
  continue;
     }
   differ = look_flags ^ sec_flags;
   if (!(differ & 0x001))
     found = look;
 }
    }
  else
    {

      for (look = first; look; look = look->next)
 {
   look_flags = look->flags;
   if (look->bfd_section != 
# 1711 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1711 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     look_flags = look->bfd_section->flags;
   differ = look_flags ^ sec_flags;
   if (!(differ & 0x2000))
     found = look;
 }
      return found;
    }

  if (found || !match_type)
    return found;

  return lang_output_section_find_by_flags (sec, sec_flags, 
# 1723 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                           ((void *)0)
# 1723 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                               , 
# 1723 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                                 ((void *)0)
# 1723 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                     );
}




static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  lang_output_section_statement_type *lookup;

  for (lookup = os->prev; lookup != 
# 1734 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 1734 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       ; lookup = lookup->prev)
    {
      if (lookup->constraint < 0)
 continue;

      if (lookup->bfd_section != 
# 1739 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0) 
# 1739 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                     && lookup->bfd_section->owner != 
# 1739 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                                      ((void *)0)
# 1739 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                          )
 return lookup->bfd_section;
    }

  return 
# 1743 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
        ((void *)0)
# 1743 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
            ;
}
# 1757 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static lang_statement_union_type **
insert_os_after (lang_output_section_statement_type *after)
{
  lang_statement_union_type **where;
  lang_statement_union_type **assign = 
# 1761 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 1761 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ;
  bfd_boolean ignore_first;

  ignore_first
    = after == &lang_output_section_statement.head->output_section_statement;

  for (where = &after->header.next;
       *where != 
# 1768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 1768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
       where = &(*where)->header.next)
    {
      switch ((*where)->header.type)
 {
 case lang_assignment_statement_enum:
   if (assign == 
# 1774 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 1774 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    )
     {
       lang_assignment_statement_type *ass;

       ass = &(*where)->assignment_statement;
       if (ass->exp->type.node_class != etree_assert
    && ass->exp->assign.dst[0] == '.'
    && ass->exp->assign.dst[1] == 0
    && !ignore_first)
  assign = where;
     }
   ignore_first = 0;
   continue;
 case lang_wild_statement_enum:
 case lang_input_section_enum:
 case lang_object_symbols_statement_enum:
 case lang_fill_statement_enum:
 case lang_data_statement_enum:
 case lang_reloc_statement_enum:
 case lang_padding_statement_enum:
 case lang_constructors_statement_enum:
   assign = 
# 1795 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 1795 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;
   continue;
 case lang_output_section_statement_enum:
   if (assign != 
# 1798 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 1798 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    )
     {
       asection *s = (*where)->output_section_statement.bfd_section;

       if (s == 
# 1802 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
    
# 1803 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   || s->map_head.s == 
# 1803 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
    
# 1804 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   || (s->flags & 0x001) != 0)
  where = assign;
     }
   break;
 case lang_input_statement_enum:
 case lang_address_statement_enum:
 case lang_target_statement_enum:
 case lang_output_statement_enum:
 case lang_group_statement_enum:
 case lang_insert_statement_enum:
   continue;
 }
      break;
    }

  return where;
}

lang_output_section_statement_type *
lang_insert_orphan (asection *s,
      const char *secname,
      int constraint,
      lang_output_section_statement_type *after,
      struct orphan_save *place,
      etree_type *address,
      lang_statement_list_type *add_child)
{
  lang_statement_list_type add;
  lang_output_section_statement_type *os;
  lang_output_section_statement_type **os_tail;




  if (after != 
# 1838 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1838 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    {
      lang_list_init (&add);
      push_stat_ptr (&add);
    }

  if (((&link_info)->type == type_relocatable)
      || (s->flags & (0x002 | 0x001)) == 0)
    address = exp_intop (0);

  os_tail = ((lang_output_section_statement_type **)
      lang_output_section_statement.tail);
  os = lang_enter_output_section_statement (secname, address, normal_section,
         
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
        ((void *)0)
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
            , 
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  , 
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 1851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        , constraint, 0);

  if (add_child == 
# 1853 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1853 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
    add_child = &os->children;
  lang_add_section (add_child, s, 
# 1855 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                 ((void *)0)
# 1855 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                     , os);

  if (after && (s->flags & (0x002 | 0x001)) != 0)
    {
      const char *region = (after->region
       ? after->region->name_list.name
       : "*default*");
      const char *lma_region = (after->lma_region
    ? after->lma_region->name_list.name
    : 
# 1864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 1864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
         );
      lang_leave_output_section_statement (
# 1865 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 1865 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              , region, after->phdrs,
        lma_region);
    }
  else
    lang_leave_output_section_statement (
# 1869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 1869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            , "*default*", 
# 1869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                                     ((void *)0)
# 1869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                         ,
      
# 1870 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 1870 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
         );


  if (after != 
# 1873 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 1873 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
    pop_stat_ptr ();

  if (after != 
# 1876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0) 
# 1876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   && os->bfd_section != 
# 1876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
# 1876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                             )
    {
      asection *snew, *as;

      snew = os->bfd_section;



      if (place->section == 
# 1884 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
   
# 1885 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && after != (&lang_output_section_statement.head
         ->output_section_statement))
 {
   asection *bfd_section = after->bfd_section;





   if (bfd_section == 
# 1894 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 1894 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
     bfd_section = output_prev_sec_find (after);

   if (bfd_section != 
# 1897 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0) 
# 1897 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          && bfd_section != snew)
     place->section = &bfd_section->next;
 }

      if (place->section == 
# 1901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
 place->section = &link_info.output_bfd->sections;

      as = *place->section;

      if (!as)
 {



   do { asection *_s = snew; asection *_next = _s->next; asection *_prev = _s->prev; if (_prev) _prev->next = _next; else (link_info.output_bfd)->sections = _next; if (_next) _next->prev = _prev; else (link_info.output_bfd)->section_last = _prev; } while (0);


   do { asection *_s = snew; bfd *_abfd = link_info.output_bfd; _s->next = 
# 1914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0)
# 1914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  ; if (_abfd->section_last) { _s->prev = _abfd->section_last; _abfd->section_last->next = _s; } else { _s->prev = 
# 1914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0)
# 1914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  ; _abfd->sections = _s; } _abfd->section_last = _s; } while (0);
 }
      else if (as != snew && as->prev != snew)
 {

   do { asection *_s = snew; asection *_next = _s->next; asection *_prev = _s->prev; if (_prev) _prev->next = _next; else (link_info.output_bfd)->sections = _next; if (_next) _next->prev = _prev; else (link_info.output_bfd)->section_last = _prev; } while (0);


   do { asection *_b = as; asection *_s = snew; asection *_prev = _b->prev; _s->prev = _prev; _s->next = _b; _b->prev = _s; if (_prev) _prev->next = _s; else (link_info.output_bfd)->sections = _s; } while (0);
 }



      place->section = &snew->next;
# 1938 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      if (add.head != 
# 1938 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 1938 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
 {
   lang_output_section_statement_type *newly_added_os;

   if (place->stmt == 
# 1942 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 1942 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
     {
       lang_statement_union_type **where = insert_os_after (after);

       *add.tail = *where;
       *where = add.head;

       place->os_tail = &after->next;
     }
   else
     {

       *add.tail = *place->stmt;
       *place->stmt = add.head;
     }



   if (*stat_ptr->tail == add.head)
     stat_ptr->tail = add.tail;


   place->stmt = add.tail;


   newly_added_os = *os_tail;
   *os_tail = 
# 1968 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 1968 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ;
   newly_added_os->prev = (lang_output_section_statement_type *)
     ((char *) place->os_tail
      - 
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       __builtin_offsetof (
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       lang_output_section_statement_type
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       , 
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       next
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
       )
# 1971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                          );
   newly_added_os->next = *place->os_tail;
   if (newly_added_os->next != 
# 1973 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 1973 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
     newly_added_os->next->prev = newly_added_os;
   *place->os_tail = newly_added_os;
   place->os_tail = &newly_added_os->next;






   if (*os_tail == 
# 1983 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 1983 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
     lang_output_section_statement.tail
       = (lang_statement_union_type **) os_tail;
 }
    }
  return os;
}

static void
lang_print_asneeded (void)
{
  struct asneeded_minfo *m;

  if (asneeded_list_head == 
# 1996 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 1996 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
    return;

  minfo (gettext ("\nAs-needed library included to satisfy reference by file (symbol)\n\n"));

  for (m = asneeded_list_head; m != 
# 2001 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 2001 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       ; m = m->next)
    {
      size_t len;

      minfo ("%s", m->soname);
      len = strlen (m->soname);

      if (len >= 29)
 {
   print_nl ();
   len = 0;
 }
      while (len < 30)
 {
   print_space ();
   ++len;
 }

      if (m->ref != 
# 2019 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 2019 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       )
 minfo ("%B ", m->ref);
      minfo ("(%T)\n", m->name);
    }
}

static void
lang_map_flags (flagword flag)
{
  if (flag & 0x001)
    minfo ("a");

  if (flag & 0x010)
    minfo ("x");

  if (flag & 0x008)
    minfo ("r");

  if (flag & 0x020)
    minfo ("w");

  if (flag & 0x002)
    minfo ("l");
}

void
lang_map (void)
{
  lang_memory_region_type *m;
  bfd_boolean dis_header_printed = 0;

  lang_input_statement_type *file; for (file = (lang_input_statement_type *) file_chain.head; file != (lang_input_statement_type *) 
# 2050 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 2050 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 ; file = (lang_input_statement_type *) file->next)
    {
      asection *s;

      if ((file->the_bfd->flags & (0x1000 | 0x40)) != 0
   || file->flags.just_syms)
 continue;

      for (s = file->the_bfd->sections; s != 
# 2058 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 2058 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                ; s = s->next)
 if ((s->output_section == 
# 2059 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
      
# 2060 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || s->output_section->owner != link_info.output_bfd)
     && (s->flags & (0x100000 | 0x200000)) == 0)
   {
     if (!dis_header_printed)
       {
  fprintf (config.map_file, gettext ("\nDiscarded input sections\n\n"));
  dis_header_printed = 1;
       }

     print_input_section (s, 1);
   }
    }

  minfo (gettext ("\nMemory Configuration\n\n"));
  fprintf (config.map_file, "%-16s %-18s %-18s %s\n",
    gettext ("Name"), gettext ("Origin"), gettext ("Length"), gettext ("Attributes"));

  for (m = lang_memory_region_list; m != 
# 2077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 2077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; m = m->next)
    {
      char buf[100];
      int len;

      fprintf (config.map_file, "%-16s ", m->name_list.name);

      sprintf (buf, "%016" "l" "x", m->origin);
      minfo ("0x%s ", buf);
      len = strlen (buf);
      while (len < 16)
 {
   print_space ();
   ++len;
 }

      minfo ("0x%V", m->length);
      if (m->flags || m->not_flags)
 {



   if (m->flags)
     {
       print_space ();
       lang_map_flags (m->flags);
     }

   if (m->not_flags)
     {
       minfo (" !");
       lang_map_flags (m->not_flags);
     }
 }

      print_nl ();
    }

  fprintf (config.map_file, gettext ("\nLinker script and memory map\n\n"));

  if (!link_info.reduce_memory_overheads)
    {
      _obstack_begin ((&map_obstack), (1000), 0, (xmalloc), (free));
      bfd_link_hash_traverse (link_info.hash, sort_def_symbol, 0);
    }
  lang_statement_iteration++;
  print_statements ();

  ldemul_extra_map_file_text (link_info.output_bfd, &link_info,
         config.map_file);
}

static bfd_boolean
sort_def_symbol (struct bfd_link_hash_entry *hash_entry,
   void *info __attribute__ ((__unused__)))
{
  if ((hash_entry->type == bfd_link_hash_defined
       || hash_entry->type == bfd_link_hash_defweak)
      && hash_entry->u.def.section->owner != link_info.output_bfd
      && hash_entry->u.def.section->owner != 
# 2136 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 2136 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                )
    {
      input_section_userdata_type *ud;
      struct map_symbol_def *def;

      ud = ((input_section_userdata_type *)
     ((hash_entry->u.def.section)->userdata));
      if (!ud)
 {
   ud = (input_section_userdata_type *) stat_alloc (sizeof (*ud));
   ((hash_entry->u.def.section)->userdata) = ud;
   ud->map_symbol_def_tail = &ud->map_symbol_def_head;
   ud->map_symbol_def_count = 0;
 }
      else if (!ud->map_symbol_def_tail)
 ud->map_symbol_def_tail = &ud->map_symbol_def_head;

      def = (struct map_symbol_def *) __extension__ ({ struct obstack *__h = (&map_obstack); __extension__ ({ struct obstack *__o = (__h); size_t __len = ((sizeof *def)); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < __len) _obstack_newchunk (__o, __len); ((void) ((__o)->next_free += (__len))); }); __extension__ ({ struct obstack *__o1 = (__h); void *__value = (void *) __o1->object_base; if (__o1->next_free == __value) __o1->maybe_empty_object = 1; __o1->next_free = ((sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (((__o1->next_free) - (sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (__o1->alignment_mask)) & ~(__o1->alignment_mask))); if ((size_t) (__o1->next_free - (char *) __o1->chunk) > (size_t) (__o1->chunk_limit - (char *) __o1->chunk)) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; __value; }); });
      def->entry = hash_entry;
      *(ud->map_symbol_def_tail) = def;
      ud->map_symbol_def_tail = &def->next;
      ud->map_symbol_def_count++;
    }
  return 1;
}



static void
init_os (lang_output_section_statement_type *s, flagword flags)
{
  if (strcmp (s->name, "/DISCARD/") == 0)
    einfo (gettext ("%P%F: Illegal use of `%s' section\n"), "/DISCARD/");

  if (s->constraint != 382)
    s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
  if (s->bfd_section == 
# 2172 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 2172 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           )
    s->bfd_section = bfd_make_section_anyway_with_flags (link_info.output_bfd,
        s->name, flags);
  if (s->bfd_section == 
# 2175 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 2175 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           )
    {
      einfo (gettext ("%P%F: output format %s cannot represent section" " called %s: %E\n")
                           ,
      link_info.output_bfd->xvec->name, s->name);
    }
  s->bfd_section->output_section = s->bfd_section;
  s->bfd_section->output_offset = 0;



  ((s->bfd_section)->userdata) = s;



  if (s->addr_tree != 
# 2190 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 2190 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
    exp_init_os (s->addr_tree);

  if (s->load_base != 
# 2193 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 2193 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
    exp_init_os (s->load_base);


  if (s->section_alignment != -1)
    s->bfd_section->alignment_power = s->section_alignment;
}




static void
exp_init_os (etree_type *exp)
{
  switch (exp->type.node_class)
    {
    case etree_assign:
    case etree_provide:
      exp_init_os (exp->assign.src);
      break;

    case etree_binary:
      exp_init_os (exp->binary.lhs);
      exp_init_os (exp->binary.rhs);
      break;

    case etree_trinary:
      exp_init_os (exp->trinary.cond);
      exp_init_os (exp->trinary.lhs);
      exp_init_os (exp->trinary.rhs);
      break;

    case etree_assert:
      exp_init_os (exp->assert_s.child);
      break;

    case etree_unary:
      exp_init_os (exp->unary.child);
      break;

    case etree_name:
      switch (exp->type.node_code)
 {
 case 323:
 case 324:
 case 321:
   {
     lang_output_section_statement_type *os;

     os = lang_output_section_statement_lookup (exp->name.name, 0, 0);
     if (os != 
# 2243 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0) 
# 2243 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   && os->bfd_section == 
# 2243 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
# 2243 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                             )
       init_os (os, 0);
   }
 }
      break;

    default:
      break;
    }
}

static void
section_already_linked (bfd *abfd, asection *sec, void *data)
{
  lang_input_statement_type *entry = (lang_input_statement_type *) data;



  if (entry->flags.just_syms)
    {
      ((*((abfd)->xvec->_bfd_link_just_syms)) (sec, &link_info));
      return;
    }


  if (!((&link_info)->type == type_relocatable)
      && (abfd->flags & 0x10000) == 0
      && (sec->flags & (0x2000000 | 0x200000 | 0x8000)) == 0x8000)
    sec->output_section = (&_bfd_std_section[2]);

  if (!(abfd->flags & 0x40))
    ((*((abfd)->xvec->_section_already_linked)) (abfd, sec, &link_info));
}





static bfd_boolean
lang_discard_section_p (asection *section)
{
  bfd_boolean discard;
  flagword flags = section->flags;


  discard = (flags & 0x8000) != 0;



  if ((flags & 0x2000000) != 0
      && link_info.resolve_section_groups)
    discard = 1;



  if ((link_info.strip == strip_debugger || link_info.strip == strip_all)
      && (flags & 0x2000) != 0)
    discard = 1;

  return discard;
}
# 2314 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
void
lang_add_section (lang_statement_list_type *ptr,
    asection *section,
    struct flag_info *sflag_info,
    lang_output_section_statement_type *output)
{
  flagword flags = section->flags;

  bfd_boolean discard;
  lang_input_section_type *new_section;
  bfd *abfd = link_info.output_bfd;


  discard = lang_discard_section_p (section);



  if (strcmp (output->name, "/DISCARD/") == 0)
    discard = 1;

  if (discard)
    {
      if (section->output_section == 
# 2336 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                    ((void *)0)
# 2336 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                        )
 {

   section->output_section = (&_bfd_std_section[2]);
 }
      return;
    }

  if (sflag_info)
    {
      bfd_boolean keep;

      keep = ((*((abfd)->xvec->_bfd_lookup_section_flags)) (&link_info, sflag_info, section));
      if (!keep)
 return;
    }

  if (section->output_section != 
# 2353 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
# 2353 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                    )
    return;







  flags &= ~ 0x200;





  if ((flags & (0x20000 | 0x2000000)) == (0x20000 | 0x2000000))
    {
      if (link_info.resolve_section_groups)
        flags &= ~(0x20000 | 0xc0000 | 0x004);
      else
        flags &= ~(0xc0000 | 0x004);
    }
  else if (!((&link_info)->type == type_relocatable))
    flags &= ~(0x20000 | 0xc0000 | 0x004);

  switch (output->sectype)
    {
    case normal_section:
    case overlay_section:
      break;
    case noalloc_section:
      flags &= ~0x001;
      break;
    case noload_section:
      flags &= ~0x002;
      flags |= 0x200;




      if (((link_info.output_bfd)->xvec->flavour) == bfd_target_elf_flavour)
 flags &= ~0x100;
      else
 flags &= ~0x001;
      break;
    }

  if (output->bfd_section == 
# 2400 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0)
# 2400 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                )
    init_os (output, flags);



  output->bfd_section->flags &= flags | ~0x008;

  if (output->bfd_section->linker_has_input)
    {

      flags &= ~ 0x008;


      if ((output->bfd_section->flags & (0x800000 | 0x1000000))
   != (flags & (0x800000 | 0x1000000))
   || ((flags & 0x800000) != 0
       && output->bfd_section->entsize != section->entsize))
 {
   output->bfd_section->flags &= ~ (0x800000 | 0x1000000);
   flags &= ~ (0x800000 | 0x1000000);
 }
    }
  output->bfd_section->flags |= flags;

  if (!output->bfd_section->linker_has_input)
    {
      output->bfd_section->linker_has_input = 1;



      ((*((link_info.output_bfd)->xvec->_bfd_init_private_section_data)) (section->owner, section, link_info.output_bfd, output->bfd_section, &link_info))


                    ;
      if ((flags & 0x800000) != 0)
 output->bfd_section->entsize = section->entsize;
    }

  if ((flags & 0x10000000) != 0
      && bfd_get_arch (section->owner) == bfd_arch_tic54x)
    {

      output->block_value = 128;
    }

  if (section->alignment_power > output->bfd_section->alignment_power)
    output->bfd_section->alignment_power = section->alignment_power;

  section->output_section = output->bfd_section;

  if (!map_head_is_link_order)
    {
      asection *s = output->bfd_section->map_tail.s;
      output->bfd_section->map_tail.s = section;
      section->map_head.s = 
# 2454 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 2454 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               ;
      section->map_tail.s = s;
      if (s != 
# 2456 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 2456 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
 s->map_head.s = section;
      else
 output->bfd_section->map_head.s = section;
    }


  new_section = (lang_input_section_type *) new_statement (lang_input_section_enum, sizeof (lang_input_section_type), ptr);
  new_section->section = section;
}






static lang_statement_union_type *
wild_sort (lang_wild_statement_type *wild,
    struct wildcard_list *sec,
    lang_input_statement_type *file,
    asection *section)
{
  lang_statement_union_type *l;

  if (!wild->filenames_sorted
      && (sec == 
# 2481 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0) 
# 2481 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     || sec->spec.sorted == none))
    return 
# 2482 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 2482 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              ;

  for (l = wild->children.head; l != 
# 2484 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                    ((void *)0)
# 2484 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                        ; l = l->header.next)
    {
      lang_input_section_type *ls;

      if (l->header.type != lang_input_section_enum)
 continue;
      ls = &l->input_section;




      if (wild->filenames_sorted)
 {
   const char *fn, *ln;
   bfd_boolean fa, la;
   int i;






   if (file->the_bfd != 
# 2506 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
       
# 2507 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && file->the_bfd->my_archive != 
# 2507 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 2507 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          )
     {
       fn = ((char *) (file->the_bfd->my_archive)->filename);
       fa = 1;
     }
   else
     {
       fn = file->filename;
       fa = 0;
     }

   if (ls->section->owner->my_archive != 
# 2518 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 2518 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            )
     {
       ln = ((char *) (ls->section->owner->my_archive)->filename);
       la = 1;
     }
   else
     {
       ln = ls->section->owner->filename;
       la = 0;
     }

   i = filename_cmp (fn, ln);
   if (i > 0)
     continue;
   else if (i < 0)
     break;

   if (fa || la)
     {
       if (fa)
  fn = file->filename;
       if (la)
  ln = ls->section->owner->filename;

       i = filename_cmp (fn, ln);
       if (i > 0)
  continue;
       else if (i < 0)
  break;
     }
 }




      if (sec != 
# 2553 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
   
# 2554 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && sec->spec.sorted != none
   && sec->spec.sorted != by_none)
 if (compare_section (sec->spec.sorted, section, ls->section) < 0)
   break;
    }

  return l;
}




static void
output_section_callback (lang_wild_statement_type *ptr,
    struct wildcard_list *sec,
    asection *section,
    struct flag_info *sflag_info,
    lang_input_statement_type *file,
    void *output)
{
  lang_statement_union_type *before;
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;


  if (unique_section_p (section, os))
    return;

  before = wild_sort (ptr, sec, file, section);






  if (before == 
# 2590 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 2590 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
    lang_add_section (&ptr->children, section, sflag_info, os);
  else
    {
      lang_statement_list_type list;
      lang_statement_union_type **pp;

      lang_list_init (&list);
      lang_add_section (&list, section, sflag_info, os);



      if (list.head != 
# 2602 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 2602 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
 {
   do { if (!(list.head->header.next == 
# 2604 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0)
# 2604 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",2604); } while (0);

   for (pp = &ptr->children.head;
        *pp != before;
        pp = &(*pp)->header.next)
     do { if (!(*pp != 
# 2609 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    ((void *)0)
# 2609 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
    )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",2609); } while (0);

   list.head->header.next = *pp;
   *pp = list.head;
 }
    }
}




static void
check_section_callback (lang_wild_statement_type *ptr __attribute__ ((__unused__)),
   struct wildcard_list *sec __attribute__ ((__unused__)),
   asection *section,
   struct flag_info *sflag_info __attribute__ ((__unused__)),
   lang_input_statement_type *file __attribute__ ((__unused__)),
   void *output)
{
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;


  if (unique_section_p (section, os))
    return;

  if (section->output_section == 
# 2636 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0) 
# 2636 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                     && (section->flags & 0x008) == 0)
    os->all_input_readonly = 0;
}





static lang_input_statement_type *
lookup_name (const char *name)
{
  lang_input_statement_type *search;

  for (search = (lang_input_statement_type *) input_file_chain.head;
       search != 
# 2650 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 2650 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
       search = (lang_input_statement_type *) search->next_real_file)
    {



      const char *filename = search->local_sym_name;

      if (filename != 
# 2658 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
   
# 2659 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && filename_cmp (filename, name) == 0)
 break;
    }

  if (search == 
# 2663 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 2663 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
    search = new_afile (name, lang_input_file_is_search_file_enum,
   default_target, 0);



  if (search->flags.loaded || !search->flags.real)
    return search;

  if (!load_symbols (search, 
# 2672 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0)
# 2672 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                ))
    return 
# 2673 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 2673 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              ;

  return search;
}



struct excluded_lib
{
  char *name;
  struct excluded_lib *next;
};
static struct excluded_lib *excluded_libs;

void
add_excluded_libs (const char *list)
{
  const char *p = list, *end;

  while (*p != '\0')
    {
      struct excluded_lib *entry;
      end = strpbrk (p, ",:");
      if (end == 
# 2696 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 2696 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    )
 end = p + strlen (p);
      entry = (struct excluded_lib *) xmalloc (sizeof (*entry));
      entry->next = excluded_libs;
      entry->name = (char *) xmalloc (end - p + 1);
      memcpy (entry->name, p, end - p);
      entry->name[end - p] = '\0';
      excluded_libs = entry;
      if (*end == '\0')
 break;
      p = end + 1;
    }
}

static void
check_excluded_libs (bfd *abfd)
{
  struct excluded_lib *lib = excluded_libs;

  while (lib)
    {
      int len = strlen (lib->name);
      const char *filename = lbasename (abfd->filename);

      if (strcmp (lib->name, "ALL") == 0)
 {
   abfd->no_export = 1;
   return;
 }

      if (filename_ncmp (lib->name, filename, len) == 0
   && (filename[len] == '\0'
       || (filename[len] == '.' && filename[len + 1] == 'a'
    && filename[len + 2] == '\0')))
 {
   abfd->no_export = 1;
   return;
 }

      lib = lib->next;
    }
}



bfd_boolean
load_symbols (lang_input_statement_type *entry,
       lang_statement_list_type *place)
{
  char **matching;

  if (entry->flags.loaded)
    return 1;

  ldfile_open_file (entry);


  if (entry->flags.missing_file)
    return 1;

  if (!bfd_check_format (entry->the_bfd, bfd_archive)
      && !bfd_check_format_matches (entry->the_bfd, bfd_object, &matching))
    {
      bfd_error_type err;
      struct lang_input_statement_flags save_flags;
      extern FILE *yyin;

      err = bfd_get_error ();


      if (ldemul_unrecognized_file (entry))
 return 1;

      if (err == bfd_error_file_ambiguously_recognized)
 {
   char **p;

   einfo (gettext ("%B: file not recognized: %E\n"), entry->the_bfd);
   einfo (gettext ("%B: matching formats:"), entry->the_bfd);
   for (p = matching; *p != 
# 2775 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 2775 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               ; p++)
     einfo (" %s", *p);
   einfo ("%F\n");
 }
      else if (err != bfd_error_file_not_recognized
        || place == 
# 2780 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 2780 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       )
 einfo (gettext ("%F%B: file not recognized: %E\n"), entry->the_bfd);

      bfd_close (entry->the_bfd);
      entry->the_bfd = 
# 2784 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 2784 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ;


      save_flags = input_flags;
      ldfile_open_command_file (entry->filename);

      push_stat_ptr (place);
      input_flags.add_DT_NEEDED_for_regular
 = entry->flags.add_DT_NEEDED_for_regular;
      input_flags.add_DT_NEEDED_for_dynamic
 = entry->flags.add_DT_NEEDED_for_dynamic;
      input_flags.whole_archive = entry->flags.whole_archive;
      input_flags.dynamic = entry->flags.dynamic;

      ldfile_assumed_script = 1;
      parser_input = input_script;
      yyparse ();
      ldfile_assumed_script = 0;




      save_flags.missing_file |= input_flags.missing_file;
      input_flags = save_flags;
      pop_stat_ptr ();
      fclose (yyin);
      yyin = 
# 2810 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 2810 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
      entry->flags.loaded = 1;

      return 1;
    }

  if (ldemul_recognized_file (entry))
    return 1;





  switch (((entry->the_bfd)->format))
    {
    default:
      break;

    case bfd_object:
      if (!entry->flags.reload)
 ldlang_add_file (entry);
      if (trace_files || verbose)
 info_msg ("%I\n", entry);
      break;

    case bfd_archive:
      check_excluded_libs (entry->the_bfd);

      if (entry->flags.whole_archive)
 {
   bfd *member = 
# 2840 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 2840 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
   bfd_boolean loaded = 1;

   for (;;)
     {
       bfd *subsbfd;
       member = bfd_openr_next_archived_file (entry->the_bfd, member);

       if (member == 
# 2848 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 2848 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
  break;

       if (!bfd_check_format (member, bfd_object))
  {
    einfo (gettext ("%F%B: member %B in archive is not an object\n"),
    entry->the_bfd, member);
    loaded = 0;
  }

       subsbfd = member;
       if (!(*link_info.callbacks
      ->add_archive_element) (&link_info, member,
         "--whole-archive", &subsbfd))
  ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 2862, __PRETTY_FUNCTION__);



       if (!((*((subsbfd)->xvec->_bfd_link_add_symbols)) (subsbfd, &link_info)))
  {
    einfo (gettext ("%F%B: error adding symbols: %E\n"), member);
    loaded = 0;
  }
     }

   entry->flags.loaded = loaded;
   return loaded;
 }
      break;
    }

  if (((*((entry->the_bfd)->xvec->_bfd_link_add_symbols)) (entry->the_bfd, &link_info)))
    entry->flags.loaded = 1;
  else
    einfo (gettext ("%F%B: error adding symbols: %E\n"), entry->the_bfd);

  return entry->flags.loaded;
}







static void
wild (lang_wild_statement_type *s,
      const char *target __attribute__ ((__unused__)),
      lang_output_section_statement_type *output)
{
  struct wildcard_list *sec;

  if (s->handler_data[0]
      && s->handler_data[0]->spec.sorted == by_name
      && !s->filenames_sorted)
    {
      lang_section_bst_type *tree;

      walk_wild (s, output_section_callback_fast, output);

      tree = s->tree;
      if (tree)
 {
   output_section_callback_tree_to_list (s, tree, output);
   s->tree = 
# 2912 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 2912 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
 }
    }
  else
    walk_wild (s, output_section_callback, output);

  if (default_common_section == 
# 2918 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 2918 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   )
    for (sec = s->section_list; sec != 
# 2919 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 2919 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; sec = sec->next)
      if (sec->spec.name != 
# 2920 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0) 
# 2920 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                && strcmp (sec->spec.name, "COMMON") == 0)
 {


   default_common_section = output;
   break;
 }
}



static int
get_target (const bfd_target *target, void *data)
{
  const char *sought = (const char *) data;

  return strcmp (target->name, sought) == 0;
}



static void
stricpy (char *dest, char *src)
{
  char c;

  while ((c = *src++) != 0)
    *dest++ = _sch_tolower[(c) & 0xff];

  *dest = 0;
}




static void
strcut (char *haystack, char *needle)
{
  haystack = strstr (haystack, needle);

  if (haystack)
    {
      char *src;

      for (src = haystack + strlen (needle); *src;)
 *haystack++ = *src++;

      *haystack = 0;
    }
}




static int
name_compare (char *first, char *second)
{
  char *copy1;
  char *copy2;
  int result;

  copy1 = (char *) xmalloc (strlen (first) + 1);
  copy2 = (char *) xmalloc (strlen (second) + 1);


  stricpy (copy1, first);
  stricpy (copy2, second);


  strcut (copy1, "big");
  strcut (copy1, "little");
  strcut (copy2, "big");
  strcut (copy2, "little");




  for (result = 0; copy1[result] == copy2[result]; result++)
    if (copy1[result] == 0)
      {
 result *= 10;
 break;
      }

  free (copy1);
  free (copy2);

  return result;
}


static const bfd_target *winner;





static int
closest_target_match (const bfd_target *target, void *data)
{
  const bfd_target *original = (const bfd_target *) data;

  if (command_line.endian == ENDIAN_BIG
      && target->byteorder != BFD_ENDIAN_BIG)
    return 0;

  if (command_line.endian == ENDIAN_LITTLE
      && target->byteorder != BFD_ENDIAN_LITTLE)
    return 0;


  if (target->flavour != original->flavour)
    return 0;


  if (strcmp (target->name, "elf32-big") == 0
      || strcmp (target->name, "elf64-big") == 0
      || strcmp (target->name, "elf32-little") == 0
      || strcmp (target->name, "elf64-little") == 0)
    return 0;


  if (winner == 
# 3042 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 3042 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
    {
      winner = target;
      return 0;
    }



  if (name_compare (target->name, original->name)
      > name_compare (winner->name, original->name))
    winner = target;


  return 0;
}



static char *
get_first_input_target (void)
{
  char *target = 
# 3063 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 3063 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;

  lang_input_statement_type *s; for (s = (lang_input_statement_type *) file_chain.head; s != (lang_input_statement_type *) 
# 3065 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 3065 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 ; s = (lang_input_statement_type *) s->next)
    {
      if (s->header.type == lang_input_statement_enum
   && s->flags.real)
 {
   ldfile_open_file (s);

   if (s->the_bfd != 
# 3072 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
       
# 3073 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && bfd_check_format (s->the_bfd, bfd_object))
     {
       target = ((s->the_bfd)->xvec->name);

       if (target != 
# 3077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 3077 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
  break;
     }
 }
    }

  return target;
}

const char *
lang_get_output_target (void)
{
  const char *target;


  if (output_target != 
# 3092 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 3092 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
    return output_target;



  if (current_target != default_target && current_target != 
# 3097 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                           ((void *)0)
# 3097 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                               )
    return current_target;


  target = get_first_input_target ();
  if (target != 
# 3102 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 3102 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
    return target;


  return default_target;
}



static void
open_output (const char *name)
{
  output_target = lang_get_output_target ();



  if (command_line.endian != ENDIAN_UNSET)
    {

      const bfd_target *target
 = bfd_iterate_over_targets (get_target, (void *) output_target);


      if (target != 
# 3125 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 3125 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       )
 {
   enum bfd_endian desired_endian;

   if (command_line.endian == ENDIAN_BIG)
     desired_endian = BFD_ENDIAN_BIG;
   else
     desired_endian = BFD_ENDIAN_LITTLE;





   if (target->byteorder != desired_endian)
     {


       if (target->alternative_target != 
# 3142 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
    
# 3143 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   && (target->alternative_target->byteorder == desired_endian))
  output_target = target->alternative_target->name;
       else
  {



    bfd_iterate_over_targets (closest_target_match,
         (void *) target);



    if (winner == 
# 3155 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 3155 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
      einfo (gettext ("%P: warning: could not find any targets" " that match endianness requirement\n")
                                               );
    else
      output_target = winner->name;
  }
     }
 }
    }

  link_info.output_bfd = bfd_openw (name, output_target);

  if (link_info.output_bfd == 
# 3167 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                             ((void *)0)
# 3167 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 )
    {
      if (bfd_get_error () == bfd_error_invalid_target)
 einfo (gettext ("%P%F: target %s not found\n"), output_target);

      einfo (gettext ("%P%F: cannot open output file %s: %E\n"), name);
    }

  delete_output_file_on_failure = 1;

  if (!bfd_set_format (link_info.output_bfd, bfd_object))
    einfo (gettext ("%P%F:%s: can not make object file: %E\n"), name);
  if (!((*((link_info.output_bfd)->xvec->_bfd_set_arch_mach)) (link_info.output_bfd, ldfile_output_architecture, ldfile_output_machine))

                            )
    einfo (gettext ("%P%F:%s: can not set architecture: %E\n"), name);

  link_info.hash = ((*((link_info.output_bfd)->xvec->_bfd_link_hash_table_create)) (link_info.output_bfd));
  if (link_info.hash == 
# 3185 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 3185 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           )
    einfo (gettext ("%P%F: can not create hash table: %E\n"));

  bfd_set_gp_size (link_info.output_bfd, g_switch_value);
}

static void
ldlang_open_output (lang_statement_union_type *statement)
{
  switch (statement->header.type)
    {
    case lang_output_statement_enum:
      do { if (!(link_info.output_bfd == 
# 3197 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 3197 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",3197); } while (0);
      open_output (statement->output_statement.name);
      ldemul_set_output_arch ();
      if (config.magic_demand_paged
   && !((&link_info)->type == type_relocatable))
 link_info.output_bfd->flags |= 0x100;
      else
 link_info.output_bfd->flags &= ~0x100;
      if (config.text_read_only)
 link_info.output_bfd->flags |= 0x80;
      else
 link_info.output_bfd->flags &= ~0x80;
      if (link_info.traditional_format)
 link_info.output_bfd->flags |= 0x400;
      else
 link_info.output_bfd->flags &= ~0x400;
      break;

    case lang_target_statement_enum:
      current_target = statement->target_statement.target;
      break;
    default:
      break;
    }
}

static void
init_opb (void)
{
  unsigned x = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
           ldfile_output_machine);
  opb_shift = 0;
  if (x > 1)
    while ((x & 1) == 0)
      {
 x >>= 1;
 ++opb_shift;
      }
  do { if (!(x == 1)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",3235); } while (0);
}



enum open_bfd_mode
  {
    OPEN_BFD_NORMAL = 0,
    OPEN_BFD_FORCE = 1,
    OPEN_BFD_RESCAN = 2
  };

static lang_input_statement_type *plugin_insert = 
# 3247 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                 ((void *)0)
# 3247 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                     ;


static void
open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
{
  for (; s != 
# 3253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 3253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      switch (s->header.type)
 {
 case lang_constructors_statement_enum:
   open_input_bfds (constructor_list.head, mode);
   break;
 case lang_output_section_statement_enum:
   open_input_bfds (s->output_section_statement.children.head, mode);
   break;
 case lang_wild_statement_enum:

   if ((mode & OPEN_BFD_RESCAN) == 0
       && s->wild_statement.filename
       && !(strpbrk ((s->wild_statement.filename), "?*[") != 
# 3267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 3267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
          )
       && !archive_path (s->wild_statement.filename))
     lookup_name (s->wild_statement.filename);
   open_input_bfds (s->wild_statement.children.head, mode);
   break;
 case lang_group_statement_enum:
   {
     struct bfd_link_hash_entry *undefs;





     do
       {
  undefs = link_info.hash->undefs_tail;
  open_input_bfds (s->group_statement.children.head,
     mode | OPEN_BFD_FORCE);
       }
     while (undefs != link_info.hash->undefs_tail);
   }
   break;
 case lang_target_statement_enum:
   current_target = s->target_statement.target;
   break;
 case lang_input_statement_enum:
   if (s->input_statement.flags.real)
     {
       lang_statement_union_type **os_tail;
       lang_statement_list_type add;
       bfd *abfd;

       s->input_statement.target = current_target;






       if (mode != OPEN_BFD_NORMAL

    && ((mode & OPEN_BFD_RESCAN) == 0
        || plugin_insert == 
# 3309 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 3309 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )

    && s->input_statement.flags.loaded
    && (abfd = s->input_statement.the_bfd) != 
# 3312 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                             ((void *)0)
    
# 3313 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   && ((((abfd)->format) == bfd_archive
         && !s->input_statement.flags.whole_archive)
        || (((abfd)->format) == bfd_object
     && ((abfd->flags) & 0x40) != 0
     && s->input_statement.flags.add_DT_NEEDED_for_regular
     && ((abfd)->xvec->flavour) == bfd_target_elf_flavour
     && ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_AS_NEEDED) != 0)))
  {
    s->input_statement.flags.loaded = 0;
    s->input_statement.flags.reload = 1;
  }

       os_tail = lang_output_section_statement.tail;
       lang_list_init (&add);

       if (!load_symbols (&s->input_statement, &add))
  config.make_executable = 0;

       if (add.head != 
# 3331 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 3331 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
  {






    if (os_tail != lang_output_section_statement.tail)
      {
        einfo (gettext ("%P: warning: %s contains output sections;" " did you forget -T?\n")
                                  ,
        s->input_statement.filename);
        *stat_ptr->tail = add.head;
        stat_ptr->tail = add.tail;
      }
    else
      {
        *add.tail = s->header.next;
        s->header.next = add.head;
      }
  }
     }



   if (&s->input_statement == plugin_insert)
     plugin_insert = 
# 3358 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 3358 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        ;

   break;
 case lang_assignment_statement_enum:
   if (s->assignment_statement.exp->type.node_class != etree_assert
       && s->assignment_statement.exp->assign.defsym)

     exp_fold_tree_no_dot (s->assignment_statement.exp);
   break;
 default:
   break;
 }
    }


  if (input_flags.missing_file)
    einfo ("%F");
}







typedef struct bfd_sym_chain ldlang_undef_chain_list_type;



void
ldlang_add_undef (const char *const name, bfd_boolean cmdline)
{
  ldlang_undef_chain_list_type *new_undef;

  undef_from_cmdline = undef_from_cmdline || cmdline;
  new_undef = (ldlang_undef_chain_list_type *) stat_alloc (sizeof (*new_undef));
  new_undef->next = entry_symbol.next;
  entry_symbol.next = new_undef;

  new_undef->name = xstrdup (name);

  if (link_info.output_bfd != 
# 3399 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                             ((void *)0)
# 3399 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 )
    insert_undefined (new_undef->name);
}



static void
insert_undefined (const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, 1, 0, 1);
  if (h == 
# 3411 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 3411 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              )
    einfo (gettext ("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = 
# 3416 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 3416 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           ;
      if ((((struct bfd_link_hash_table *) (link_info.hash))->type == bfd_link_elf_hash_table))
 ((struct elf_link_hash_entry *) h)->mark = 1;
      bfd_link_add_undef (link_info.hash, h);
    }
}





static void
lang_place_undefineds (void)
{
  ldlang_undef_chain_list_type *ptr;

  for (ptr = entry_symbol.next; ptr != 
# 3432 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                 ((void *)0)
# 3432 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                     ; ptr = ptr->next)
    insert_undefined (ptr->name);
}




struct require_defined_symbol
{
  const char *name;
  struct require_defined_symbol *next;
};



static struct require_defined_symbol *require_defined_symbol_list;




void
ldlang_add_require_defined (const char *const name)
{
  struct require_defined_symbol *ptr;

  ldlang_add_undef (name, 1);
  ptr = (struct require_defined_symbol *) stat_alloc (sizeof (*ptr));
  ptr->next = require_defined_symbol_list;
  ptr->name = strdup (name);
  require_defined_symbol_list = ptr;
}




static void
ldlang_check_require_defined_symbols (void)
{
  struct require_defined_symbol *ptr;

  for (ptr = require_defined_symbol_list; ptr != 
# 3472 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                ((void *)0)
# 3472 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                    ; ptr = ptr->next)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, ptr->name,
    0, 0, 1);
      if (h == 
# 3478 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
   
# 3479 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || (h->type != bfd_link_hash_defined
       && h->type != bfd_link_hash_defweak))
 einfo(gettext ("%P%X: required symbol `%s' not defined\n"), ptr->name);
    }
}



static void
check_input_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement)
{
  for (; s != (lang_statement_union_type *) 
# 3492 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 3492 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ; s = s->header.next)
    {
      switch (s->header.type)
 {
 case lang_wild_statement_enum:
   walk_wild (&s->wild_statement, check_section_callback,
       output_section_statement);
   if (!output_section_statement->all_input_readonly)
     return;
   break;
 case lang_constructors_statement_enum:
   check_input_sections (constructor_list.head,
    output_section_statement);
   if (!output_section_statement->all_input_readonly)
     return;
   break;
 case lang_group_statement_enum:
   check_input_sections (s->group_statement.children.head,
    output_section_statement);
   if (!output_section_statement->all_input_readonly)
     return;
   break;
 default:
   break;
 }
    }
}



static void
update_wild_statements (lang_statement_union_type *s)
{
  struct wildcard_list *sec;

  switch (sort_section)
    {
    default:
      do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",3530); } while (0);

    case none:
      break;

    case by_name:
    case by_alignment:
      for (; s != 
# 3537 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 3537 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     ; s = s->header.next)
 {
   switch (s->header.type)
     {
     default:
       break;

     case lang_wild_statement_enum:
       for (sec = s->wild_statement.section_list; sec != 
# 3545 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                        ((void *)0)
# 3545 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                            ;
     sec = sec->next)
  {
    switch (sec->spec.sorted)
      {
      case none:
        sec->spec.sorted = sort_section;
        break;
      case by_name:
        if (sort_section == by_alignment)
   sec->spec.sorted = by_name_alignment;
        break;
      case by_alignment:
        if (sort_section == by_name)
   sec->spec.sorted = by_alignment_name;
        break;
      default:
        break;
      }
  }
       break;

     case lang_constructors_statement_enum:
       update_wild_statements (constructor_list.head);
       break;

     case lang_output_section_statement_enum:

       if (strcmp (s->output_section_statement.name, ".init") != 0
    && strcmp (s->output_section_statement.name, ".fini") != 0)
  update_wild_statements
    (s->output_section_statement.children.head);
       break;

     case lang_group_statement_enum:
       update_wild_statements (s->group_statement.children.head);
       break;
     }
 }
      break;
    }
}



static void
map_input_to_output_sections
  (lang_statement_union_type *s, const char *target,
   lang_output_section_statement_type *os)
{
  for (; s != 
# 3595 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 3595 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      lang_output_section_statement_type *tos;
      flagword flags;

      switch (s->header.type)
 {
 case lang_wild_statement_enum:
   wild (&s->wild_statement, target, os);
   break;
 case lang_constructors_statement_enum:
   map_input_to_output_sections (constructor_list.head,
     target,
     os);
   break;
 case lang_output_section_statement_enum:
   tos = &s->output_section_statement;
   if (tos->constraint != 0)
     {
       if (tos->constraint != 381
    && tos->constraint != 380)
  break;
       tos->all_input_readonly = 1;
       check_input_sections (tos->children.head, tos);
       if (tos->all_input_readonly != (tos->constraint == 380))
  {
    tos->constraint = -1;
    break;
  }
     }
   map_input_to_output_sections (tos->children.head,
     target,
     tos);
   break;
 case lang_output_statement_enum:
   break;
 case lang_target_statement_enum:
   target = s->target_statement.target;
   break;
 case lang_group_statement_enum:
   map_input_to_output_sections (s->group_statement.children.head,
     target,
     os);
   break;
 case lang_data_statement_enum:


   exp_init_os (s->data_statement.exp);


   flags = 0x100 | 0x001 | 0x002;
   switch (os->sectype)
     {
     case normal_section:
     case overlay_section:
       break;
     case noalloc_section:
       flags = 0x100;
       break;
     case noload_section:
       if (((link_info.output_bfd)->xvec->flavour)
    == bfd_target_elf_flavour)
  flags = 0x200 | 0x001;
       else
  flags = 0x200 | 0x100;
       break;
     }
   if (os->bfd_section == 
# 3662 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 3662 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
     init_os (os, flags);
   else
     os->bfd_section->flags |= flags;
   break;
 case lang_input_section_enum:
   break;
 case lang_fill_statement_enum:
 case lang_object_symbols_statement_enum:
 case lang_reloc_statement_enum:
 case lang_padding_statement_enum:
 case lang_input_statement_enum:
   if (os != 
# 3674 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0) 
# 3674 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 && os->bfd_section == 
# 3674 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 3674 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           )
     init_os (os, 0);
   break;
 case lang_assignment_statement_enum:
   if (os != 
# 3678 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0) 
# 3678 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 && os->bfd_section == 
# 3678 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 3678 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           )
     init_os (os, 0);



   exp_init_os (s->assignment_statement.exp);
   break;
 case lang_address_statement_enum:
# 3695 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   if (!s->address_statement.segment
       || !s->address_statement.segment->used)
     {
       const char *name = s->address_statement.section_name;







       tos = lang_output_section_statement_lookup (name, 0, 1);
       tos->addr_tree = s->address_statement.address;
       if (tos->bfd_section == 
# 3708 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 3708 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
  init_os (tos, 0);
     }
   break;
 case lang_insert_statement_enum:
   break;
 }
    }
}







static void
process_insert_statements (void)
{
  lang_statement_union_type **s;
  lang_output_section_statement_type *first_os = 
# 3728 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                ((void *)0)
# 3728 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                    ;
  lang_output_section_statement_type *last_os = 
# 3729 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 3729 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   ;
  lang_output_section_statement_type *os;




  s = &lang_output_section_statement.head;
  while (*(s = &(*s)->header.next) != 
# 3736 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 3736 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         )
    {
      if ((*s)->header.type == lang_output_section_statement_enum)
 {


   os = &(*s)->output_section_statement;

   do { if (!(last_os == 
# 3744 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0) 
# 3744 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || last_os->next == os)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",3744); } while (0);
   last_os = os;





   last_os->constraint = -2 - last_os->constraint;
   if (first_os == 
# 3752 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 3752 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
     first_os = last_os;
 }
      else if ((*s)->header.type == lang_insert_statement_enum)
 {
   lang_insert_statement_type *i = &(*s)->insert_statement;
   lang_output_section_statement_type *where;
   lang_statement_union_type **ptr;
   lang_statement_union_type *first;

   where = lang_output_section_statement_lookup (i->where, 0, 0);
   if (where != 
# 3763 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0) 
# 3763 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    && i->is_before)
     {
       do
  where = where->prev;
       while (where != 
# 3767 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0) 
# 3767 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           && where->constraint < 0);
     }
   if (where == 
# 3769 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 3769 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
     {
       einfo (gettext ("%F%P: %s not found for insert\n"), i->where);
       return;
     }


   if (last_os != 
# 3776 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 3776 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
     {
       asection *first_sec, *last_sec;
       struct lang_output_section_statement_struct **next;


       first_os->prev->next = last_os->next;
       if (last_os->next == 
# 3783 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 3783 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
  {
    next = &first_os->prev->next;
    lang_output_section_statement.tail
      = (lang_statement_union_type **) next;
  }
       else
  last_os->next->prev = first_os->prev;

       last_os->next = where->next;
       if (where->next == 
# 3793 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 3793 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
  {
    next = &last_os->next;
    lang_output_section_statement.tail
      = (lang_statement_union_type **) next;
  }
       else
  where->next->prev = last_os;
       first_os->prev = where;
       where->next = first_os;


       first_sec = 
# 3805 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 3805 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      ;
       last_sec = 
# 3806 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 3806 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     ;
       for (os = first_os; os != 
# 3807 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
# 3807 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                    ; os = os->next)
  {
    os->constraint = -2 - os->constraint;
    if (os->bfd_section != 
# 3810 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
        
# 3811 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       && os->bfd_section->owner != 
# 3811 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                    ((void *)0)
# 3811 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                        )
      {
        last_sec = os->bfd_section;
        if (first_sec == 
# 3814 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 3814 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
   first_sec = last_sec;
      }
    if (os == last_os)
      break;
  }
       if (last_sec != 
# 3820 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 3820 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
  {
    asection *sec = where->bfd_section;
    if (sec == 
# 3823 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 3823 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  )
      sec = output_prev_sec_find (where);





    if (sec != 
# 3830 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0) 
# 3830 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   && sec != last_sec)
      {

        if (first_sec->prev != 
# 3833 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 3833 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
   first_sec->prev->next = last_sec->next;
        else
   link_info.output_bfd->sections = last_sec->next;
        if (last_sec->next != 
# 3837 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                             ((void *)0)
# 3837 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 )
   last_sec->next->prev = first_sec->prev;
        else
   link_info.output_bfd->section_last = first_sec->prev;

        last_sec->next = sec->next;
        if (sec->next != 
# 3843 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 3843 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
   sec->next->prev = last_sec;
        else
   link_info.output_bfd->section_last = last_sec;
        first_sec->prev = sec;
        sec->next = first_sec;
      }
  }

       first_os = 
# 3852 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 3852 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     ;
       last_os = 
# 3853 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 3853 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
     }

   ptr = insert_os_after (where);



   first = lang_output_section_statement.head->header.next;
   lang_output_section_statement.head->header.next = (*s)->header.next;

   *s = *ptr;
   if (*s == 
# 3864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 3864 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                )
     statement_list.tail = s;
   *ptr = first;
   s = &lang_output_section_statement.head;
 }
    }


  for (os = first_os; os != 
# 3872 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 3872 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               ; os = os->next)
    {
      os->constraint = -2 - os->constraint;
      if (os == last_os)
 break;
    }
}





void
strip_excluded_output_sections (void)
{
  lang_output_section_statement_type *os;


  if (expld.phase != lang_mark_phase_enum)
    {
      expld.phase = lang_mark_phase_enum;
      expld.dataseg.phase = exp_dataseg_none;
      one_lang_size_sections_pass (
# 3894 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                  ((void *)0)
# 3894 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                      , 0);
      lang_reset_memory_regions ();
    }

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != 
# 3899 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 3899 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
       os = os->next)
    {
      asection *output_section;
      bfd_boolean exclude;

      if (os->constraint < 0)
 continue;

      output_section = os->bfd_section;
      if (output_section == 
# 3909 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 3909 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
 continue;

      exclude = (output_section->rawsize == 0
   && (output_section->flags & 0x200000) == 0
   && !((output_section)->next == 
# 3914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
      ((void *)0) 
# 3914 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      ? (link_info.output_bfd)->section_last != (output_section) : (output_section)->next->prev != (output_section))
                         );





      if (exclude && output_section->map_head.s != 
# 3921 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                  ((void *)0)
# 3921 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                      )
 {
   asection *s;

   for (s = output_section->map_head.s; s != 
# 3925 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 3925 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                ; s = s->map_head.s)
     if ((s->flags & 0x8000) == 0
  && ((s->flags & 0x100000) != 0
      || link_info.emitrelocations))
       {
  exclude = 0;
  break;
       }
 }

      if (exclude)
 {


   if (!os->update_dot)
     os->ignored = 1;
   output_section->flags |= 0x8000;
   do { asection *_s = output_section; asection *_next = _s->next; asection *_prev = _s->prev; if (_prev) _prev->next = _next; else (link_info.output_bfd)->sections = _next; if (_next) _next->prev = _prev; else (link_info.output_bfd)->section_last = _prev; } while (0);
   link_info.output_bfd->section_count--;
 }
    }
}






void
lang_clear_os_map (void)
{
  lang_output_section_statement_type *os;

  if (map_head_is_link_order)
    return;

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != 
# 3962 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 3962 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
       os = os->next)
    {
      asection *output_section;

      if (os->constraint < 0)
 continue;

      output_section = os->bfd_section;
      if (output_section == 
# 3971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 3971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
 continue;


      output_section->map_head.link_order = 
# 3975 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 3975 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ;
      output_section->map_tail.link_order = 
# 3976 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 3976 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ;
    }



  map_head_is_link_order = 1;
}

static void
print_output_section_statement
  (lang_output_section_statement_type *output_section_statement)
{
  asection *section = output_section_statement->bfd_section;
  int len;

  if (output_section_statement != abs_output_section)
    {
      minfo ("\n%s", output_section_statement->name);

      if (section != 
# 3995 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 3995 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
 {
   print_dot = section->vma;

   len = strlen (output_section_statement->name);
   if (len >= (16) - 1)
     {
       print_nl ();
       len = 0;
     }
   while (len < (16))
     {
       print_space ();
       ++len;
     }

   minfo ("0x%V %W", section->vma, ((section->size) >> opb_shift));

   if (section->vma != section->lma)
     minfo (gettext (" load address 0x%V"), section->lma);

   if (output_section_statement->update_dot_tree != 
# 4016 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                   ((void *)0)
# 4016 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                       )
     exp_fold_tree (output_section_statement->update_dot_tree,
      (&_bfd_std_section[2]), &print_dot);
 }

      print_nl ();
    }

  print_statement_list (output_section_statement->children.head,
   output_section_statement);
}

static void
print_assignment (lang_assignment_statement_type *assignment,
    lang_output_section_statement_type *output_section)
{
  unsigned int i;
  bfd_boolean is_dot;
  etree_type *tree;
  asection *osec;

  for (i = 0; i < (16); i++)
    print_space ();

  if (assignment->exp->type.node_class == etree_assert)
    {
      is_dot = 0;
      tree = assignment->exp->assert_s.child;
    }
  else
    {
      const char *dst = assignment->exp->assign.dst;

      is_dot = (dst[0] == '.' && dst[1] == 0);
      if (!is_dot)
 expld.assign_name = dst;
      tree = assignment->exp->assign.src;
    }

  osec = output_section->bfd_section;
  if (osec == 
# 4056 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 4056 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    osec = (&_bfd_std_section[2]);

  if (assignment->exp->type.node_class != etree_provide)
    exp_fold_tree (tree, osec, &print_dot);
  else
    expld.result.valid_p = 0;

  if (expld.result.valid_p)
    {
      bfd_vma value;

      if (assignment->exp->type.node_class == etree_assert
   || is_dot
   || expld.assign_name != 
# 4070 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 4070 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
 {
   value = expld.result.value;

   if (expld.result.section != 
# 4074 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 4074 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
     value += expld.result.section->vma;

   minfo ("0x%V", value);
   if (is_dot)
     print_dot = value;
 }
      else
 {
   struct bfd_link_hash_entry *h;

   h = bfd_link_hash_lookup (link_info.hash, assignment->exp->assign.dst,
        0, 0, 1);
   if (h)
     {
       value = h->u.def.value;
       value += h->u.def.section->output_section->vma;
       value += h->u.def.section->output_offset;

       minfo ("[0x%V]", value);
     }
   else
     minfo ("[unresolved]");
 }
    }
  else
    {
      if (assignment->exp->type.node_class == etree_provide)
 minfo ("[!provide]");
      else
 minfo ("*undef*   ");

      minfo ("        ");

    }
  expld.assign_name = 
# 4109 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 4109 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         ;

  minfo ("                ");
  exp_print_tree (assignment->exp);
  print_nl ();
}

static void
print_input_statement (lang_input_statement_type *statm)
{
  if (statm->filename != 
# 4119 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
      
# 4120 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && (statm->the_bfd == 
# 4120 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
   
# 4121 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || (statm->the_bfd->flags & 0x1000) == 0))
    fprintf (config.map_file, "LOAD %s\n", statm->filename);
}




static bfd_boolean
print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)
{
  asection *sec = (asection *) ptr;

  if ((hash_entry->type == bfd_link_hash_defined
       || hash_entry->type == bfd_link_hash_defweak)
      && sec == hash_entry->u.def.section)
    {
      int i;

      for (i = 0; i < (16); i++)
 print_space ();
      minfo ("0x%V   ",
      (hash_entry->u.def.value
       + hash_entry->u.def.section->output_offset
       + hash_entry->u.def.section->output_section->vma));

      minfo ("             %T\n", hash_entry->root.string);
    }

  return 1;
}

static int
hash_entry_addr_cmp (const void *a, const void *b)
{
  const struct bfd_link_hash_entry *l = *(const struct bfd_link_hash_entry **)a;
  const struct bfd_link_hash_entry *r = *(const struct bfd_link_hash_entry **)b;

  if (l->u.def.value < r->u.def.value)
    return -1;
  else if (l->u.def.value > r->u.def.value)
    return 1;
  else
    return 0;
}

static void
print_all_symbols (asection *sec)
{
  input_section_userdata_type *ud
    = (input_section_userdata_type *) ((sec)->userdata);
  struct map_symbol_def *def;
  struct bfd_link_hash_entry **entries;
  unsigned int i;

  if (!ud)
    return;

  *ud->map_symbol_def_tail = 0;


  entries = (struct bfd_link_hash_entry **)
      __extension__ ({ struct obstack *__h = (&map_obstack); __extension__ ({ struct obstack *__o = (__h); size_t __len = ((ud->map_symbol_def_count * sizeof (*entries))); if (__extension__ ({ struct obstack const *__o1 = (__o); (size_t) (__o1->chunk_limit - __o1->next_free); }) < __len) _obstack_newchunk (__o, __len); ((void) ((__o)->next_free += (__len))); }); __extension__ ({ struct obstack *__o1 = (__h); void *__value = (void *) __o1->object_base; if (__o1->next_free == __value) __o1->maybe_empty_object = 1; __o1->next_free = ((sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (((__o1->next_free) - (sizeof (ptrdiff_t) < sizeof (void *) ? (__o1->object_base) : (char *) 0) + (__o1->alignment_mask)) & ~(__o1->alignment_mask))); if ((size_t) (__o1->next_free - (char *) __o1->chunk) > (size_t) (__o1->chunk_limit - (char *) __o1->chunk)) __o1->next_free = __o1->chunk_limit; __o1->object_base = __o1->next_free; __value; }); })
                                                    ;

  for (i = 0, def = ud->map_symbol_def_head; def; def = def->next, i++)
    entries[i] = def->entry;

  qsort (entries, ud->map_symbol_def_count, sizeof (*entries),
  hash_entry_addr_cmp);


  for (i = 0; i < ud->map_symbol_def_count; i++)
    print_one_symbol (entries[i], sec);

  __extension__ ({ struct obstack *__o = (&map_obstack); void *__obj = (void *) (entries); if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit) __o->next_free = __o->object_base = (char *) __obj; else _obstack_free (__o, __obj); });
}



static void
print_input_section (asection *i, bfd_boolean is_discarded)
{
  bfd_size_type size = i->size;
  int len;
  bfd_vma addr;

  init_opb ();

  print_space ();
  minfo ("%s", i->name);

  len = 1 + strlen (i->name);
  if (len >= (16) - 1)
    {
      print_nl ();
      len = 0;
    }
  while (len < (16))
    {
      print_space ();
      ++len;
    }

  if (i->output_section != 
# 4224 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
      
# 4225 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && i->output_section->owner == link_info.output_bfd)
    addr = i->output_section->vma + i->output_offset;
  else
    {
      addr = print_dot;
      if (!is_discarded)
 size = 0;
    }

  minfo ("0x%V %W %B\n", addr, size, i->owner);

  if (size != i->rawsize && i->rawsize != 0)
    {
      len = (16) + 3;

      len += 16;



      while (len > 0)
 {
   print_space ();
   --len;
 }

      minfo (gettext ("%W (size before relaxing)\n"), i->rawsize);
    }

  if (i->output_section != 
# 4253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
      
# 4254 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && i->output_section->owner == link_info.output_bfd)
    {
      if (link_info.reduce_memory_overheads)
 bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);
      else
 print_all_symbols (i);




      if (addr + ((size) >> opb_shift) > print_dot)
 print_dot = addr + ((size) >> opb_shift);
    }
}

static void
print_fill_statement (lang_fill_statement_type *fill)
{
  size_t size;
  unsigned char *p;
  fputs (" FILL mask 0x", config.map_file);
  for (p = fill->fill->data, size = fill->fill->size; size != 0; p++, size--)
    fprintf (config.map_file, "%02x", *p);
  fputs ("\n", config.map_file);
}

static void
print_data_statement (lang_data_statement_type *data)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;
  const char *name;

  init_opb ();
  for (i = 0; i < (16); i++)
    print_space ();

  addr = data->output_offset;
  if (data->output_section != 
# 4293 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                             ((void *)0)
# 4293 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 )
    addr += data->output_section->vma;

  switch (data->type)
    {
    default:
      ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 4299, __PRETTY_FUNCTION__);
    case 286:
      size = (1);
      name = "BYTE";
      break;
    case 285:
      size = (2);
      name = "SHORT";
      break;
    case 284:
      size = (4);
      name = "LONG";
      break;
    case 282:
      size = (8);
      name = "QUAD";
      break;
    case 283:
      size = (8);
      name = "SQUAD";
      break;
    }

  if (size < (((unsigned) 1) << opb_shift))
    size = (((unsigned) 1) << opb_shift);
  minfo ("0x%V %W %s 0x%v", addr, ((size) >> opb_shift), name, data->value);

  if (data->exp->type.node_class != etree_value)
    {
      print_space ();
      exp_print_tree (data->exp);
    }

  print_nl ();

  print_dot = addr + ((size) >> opb_shift);
}




static void
print_address_statement (lang_address_statement_type *address)
{
  minfo (gettext ("Address of section %s set to "), address->section_name);
  exp_print_tree (address->address);
  print_nl ();
}



static void
print_reloc_statement (lang_reloc_statement_type *reloc)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;

  init_opb ();
  for (i = 0; i < (16); i++)
    print_space ();

  addr = reloc->output_offset;
  if (reloc->output_section != 
# 4362 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                              ((void *)0)
# 4362 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                  )
    addr += reloc->output_section->vma;

  size = bfd_get_reloc_size (reloc->howto);

  minfo ("0x%V %W RELOC %s ", addr, ((size) >> opb_shift), reloc->howto->name);

  if (reloc->name != 
# 4369 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 4369 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
    minfo ("%s+", reloc->name);
  else
    minfo ("%s+", reloc->section->name);

  exp_print_tree (reloc->addend_exp);

  print_nl ();

  print_dot = addr + ((size) >> opb_shift);
}

static void
print_padding_statement (lang_padding_statement_type *s)
{
  int len;
  bfd_vma addr;

  init_opb ();
  minfo (" *fill*");

  len = sizeof " *fill*" - 1;
  while (len < (16))
    {
      print_space ();
      ++len;
    }

  addr = s->output_offset;
  if (s->output_section != 
# 4398 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 4398 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
    addr += s->output_section->vma;
  minfo ("0x%V %W ", addr, ((s->size) >> opb_shift));

  if (s->fill->size != 0)
    {
      size_t size;
      unsigned char *p;
      for (p = s->fill->data, size = s->fill->size; size != 0; p++, size--)
 fprintf (config.map_file, "%02x", *p);
    }

  print_nl ();

  print_dot = addr + ((s->size) >> opb_shift);
}

static void
print_wild_statement (lang_wild_statement_type *w,
        lang_output_section_statement_type *os)
{
  struct wildcard_list *sec;

  print_space ();

  if (w->exclude_name_list)
    {
      name_list *tmp;
      minfo ("EXCLUDE_FILE(%s", w->exclude_name_list->name);
      for (tmp = w->exclude_name_list->next; tmp; tmp = tmp->next)
        minfo (" %s", tmp->name);
      minfo (") ");
    }

  if (w->filenames_sorted)
    minfo ("SORT(");
  if (w->filename != 
# 4434 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 4434 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
    minfo ("%s", w->filename);
  else
    minfo ("*");
  if (w->filenames_sorted)
    minfo (")");

  minfo ("(");
  for (sec = w->section_list; sec; sec = sec->next)
    {
      if (sec->spec.sorted)
 minfo ("SORT(");
      if (sec->spec.exclude_name_list != 
# 4446 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 4446 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            )
 {
   name_list *tmp;
   minfo ("EXCLUDE_FILE(%s", sec->spec.exclude_name_list->name);
   for (tmp = sec->spec.exclude_name_list->next; tmp; tmp = tmp->next)
     minfo (" %s", tmp->name);
   minfo (") ");
 }
      if (sec->spec.name != 
# 4454 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 4454 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
 minfo ("%s", sec->spec.name);
      else
 minfo ("*");
      if (sec->spec.sorted)
 minfo (")");
      if (sec->next)
 minfo (" ");
    }
  minfo (")");

  print_nl ();

  print_statement_list (w->children.head, os);
}



static void
print_group (lang_group_statement_type *s,
      lang_output_section_statement_type *os)
{
  fprintf (config.map_file, "START GROUP\n");
  print_statement_list (s->children.head, os);
  fprintf (config.map_file, "END GROUP\n");
}




static void
print_statement_list (lang_statement_union_type *s,
        lang_output_section_statement_type *os)
{
  while (s != 
# 4488 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 4488 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    {
      print_statement (s, os);
      s = s->header.next;
    }
}




static void
print_statement (lang_statement_union_type *s,
   lang_output_section_statement_type *os)
{
  switch (s->header.type)
    {
    default:
      fprintf (config.map_file, gettext ("Fail with %d\n"), s->header.type);
      do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",4506); } while (0);
      break;
    case lang_constructors_statement_enum:
      if (constructor_list.head != 
# 4509 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                  ((void *)0)
# 4509 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                      )
 {
   if (constructors_sorted)
     minfo (" SORT (CONSTRUCTORS)\n");
   else
     minfo (" CONSTRUCTORS\n");
   print_statement_list (constructor_list.head, os);
 }
      break;
    case lang_wild_statement_enum:
      print_wild_statement (&s->wild_statement, os);
      break;
    case lang_address_statement_enum:
      print_address_statement (&s->address_statement);
      break;
    case lang_object_symbols_statement_enum:
      minfo (" CREATE_OBJECT_SYMBOLS\n");
      break;
    case lang_fill_statement_enum:
      print_fill_statement (&s->fill_statement);
      break;
    case lang_data_statement_enum:
      print_data_statement (&s->data_statement);
      break;
    case lang_reloc_statement_enum:
      print_reloc_statement (&s->reloc_statement);
      break;
    case lang_input_section_enum:
      print_input_section (s->input_section.section, 0);
      break;
    case lang_padding_statement_enum:
      print_padding_statement (&s->padding_statement);
      break;
    case lang_output_section_statement_enum:
      print_output_section_statement (&s->output_section_statement);
      break;
    case lang_assignment_statement_enum:
      print_assignment (&s->assignment_statement, os);
      break;
    case lang_target_statement_enum:
      fprintf (config.map_file, "TARGET(%s)\n", s->target_statement.target);
      break;
    case lang_output_statement_enum:
      minfo ("OUTPUT(%s", s->output_statement.name);
      if (output_target != 
# 4553 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 4553 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
 minfo (" %s", output_target);
      minfo (")\n");
      break;
    case lang_input_statement_enum:
      print_input_statement (&s->input_statement);
      break;
    case lang_group_statement_enum:
      print_group (&s->group_statement, os);
      break;
    case lang_insert_statement_enum:
      minfo ("INSERT %s %s\n",
      s->insert_statement.is_before ? "BEFORE" : "AFTER",
      s->insert_statement.where);
      break;
    }
}

static void
print_statements (void)
{
  print_statement_list (statement_list.head, abs_output_section);
}






void
dprint_statement (lang_statement_union_type *s, int n)
{
  FILE *map_save = config.map_file;

  config.map_file = 
# 4587 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   stderr
# 4587 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         ;

  if (n < 0)
    print_statement_list (s, abs_output_section);
  else
    {
      while (s && --n >= 0)
 {
   print_statement (s, abs_output_section);
   s = s->header.next;
 }
    }

  config.map_file = map_save;
}

static void
insert_pad (lang_statement_union_type **ptr,
     fill_type *fill,
     bfd_size_type alignment_needed,
     asection *output_section,
     bfd_vma dot)
{
  static fill_type zero_fill;
  lang_statement_union_type *pad = 
# 4611 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                  ((void *)0)
# 4611 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                      ;

  if (ptr != &statement_list.head)
    pad = ((lang_statement_union_type *)
    ((char *) ptr - 
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   __builtin_offsetof (
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   lang_statement_union_type
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   , 
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   header.next
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   )
# 4615 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                    ));
  if (pad != 
# 4616 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
      
# 4617 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && pad->header.type == lang_padding_statement_enum
      && pad->padding_statement.output_section == output_section)
    {

    }
  else if ((pad = *ptr) != 
# 4622 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
    
# 4623 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   && pad->header.type == lang_padding_statement_enum
    && pad->padding_statement.output_section == output_section)
    {

    }
  else
    {

      pad = (lang_statement_union_type *)
   stat_alloc (sizeof (lang_padding_statement_type));
      pad->header.next = *ptr;
      *ptr = pad;
      pad->header.type = lang_padding_statement_enum;
      pad->padding_statement.output_section = output_section;
      if (fill == 
# 4637 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 4637 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
 fill = &zero_fill;
      pad->padding_statement.fill = fill;
    }
  pad->padding_statement.output_offset = dot - output_section->vma;
  pad->padding_statement.size = alignment_needed;
  output_section->size = ((dot + ((alignment_needed) >> opb_shift) - output_section->vma) << opb_shift)
                            ;
}



static bfd_vma
size_input_section
  (lang_statement_union_type **this_ptr,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
{
  lang_input_section_type *is = &((*this_ptr)->input_section);
  asection *i = is->section;
  asection *o = output_section_statement->bfd_section;

  if (i->sec_info_type == 4)
    i->output_offset = i->vma - o->vma;
  else if (((i->flags & 0x8000) != 0)
    || output_section_statement->ignored)
    i->output_offset = dot - o->vma;
  else
    {
      bfd_size_type alignment_needed;






      if (output_section_statement->subsection_alignment != -1)
 i->alignment_power = output_section_statement->subsection_alignment;

      if (o->alignment_power < i->alignment_power)
 o->alignment_power = i->alignment_power;

      alignment_needed = (((dot) + ((bfd_vma) 1 << (i->alignment_power)) - 1) & (-((bfd_vma) 1 << (i->alignment_power)))) - dot;

      if (alignment_needed != 0)
 {
   insert_pad (this_ptr, fill, ((alignment_needed) << opb_shift), o, dot);
   dot += alignment_needed;
 }


      i->output_offset = dot - o->vma;


      dot += ((i->size) >> opb_shift);
      o->size = ((dot - o->vma) << opb_shift);
    }

  return dot;
}

struct check_sec
{
  asection *sec;
  bfd_boolean warned;
};

static int
sort_sections_by_lma (const void *arg1, const void *arg2)
{
  const asection *sec1 = ((const struct check_sec *) arg1)->sec;
  const asection *sec2 = ((const struct check_sec *) arg2)->sec;

  if (sec1->lma < sec2->lma)
    return -1;
  else if (sec1->lma > sec2->lma)
    return 1;
  else if (sec1->id < sec2->id)
    return -1;
  else if (sec1->id > sec2->id)
    return 1;

  return 0;
}

static int
sort_sections_by_vma (const void *arg1, const void *arg2)
{
  const asection *sec1 = ((const struct check_sec *) arg1)->sec;
  const asection *sec2 = ((const struct check_sec *) arg2)->sec;

  if (sec1->vma < sec2->vma)
    return -1;
  else if (sec1->vma > sec2->vma)
    return 1;
  else if (sec1->id < sec2->id)
    return -1;
  else if (sec1->id > sec2->id)
    return 1;

  return 0;
}
# 4752 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static void
lang_check_section_addresses (void)
{
  asection *s, *p;
  struct check_sec *sections;
  size_t i, count;
  bfd_vma addr_mask;
  bfd_vma s_start;
  bfd_vma s_end;
  bfd_vma p_start = 0;
  bfd_vma p_end = 0;
  lang_memory_region_type *m;
  bfd_boolean overlays;


  addr_mask = ((bfd_vma) 1 <<
        (bfd_arch_bits_per_address (link_info.output_bfd) - 1)) - 1;
  addr_mask = (addr_mask << 1) + 1;
  for (s = link_info.output_bfd->sections; s != 
# 4770 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 4770 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   ; s = s->next)
    if ((s->flags & 0x001) != 0)
      {
 s_end = (s->vma + s->size) & addr_mask;
 if (s_end != 0 && s_end < (s->vma & addr_mask))
   einfo (gettext ("%X%P: section %s VMA wraps around address space\n"),
   s->name);
 else
   {
     s_end = (s->lma + s->size) & addr_mask;
     if (s_end != 0 && s_end < (s->lma & addr_mask))
       einfo (gettext ("%X%P: section %s LMA wraps around address space\n"),
       s->name);
   }
      }

  if (((link_info.output_bfd)->section_count) <= 1)
    return;

  count = ((link_info.output_bfd)->section_count);
  sections = ((struct check_sec *) xmalloc (sizeof (struct check_sec) * (count)));


  count = 0;
  for (s = link_info.output_bfd->sections; s != 
# 4794 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 4794 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   ; s = s->next)
    {
      if (((s->flags & 0x001) == 0 || ((s->flags & (0x002 | 0x400)) == 0x400))
   || s->size == 0)
 continue;

      sections[count].sec = s;
      sections[count].warned = 0;
      count++;
    }

  if (count <= 1)
    {
      free (sections);
      return;
    }

  qsort (sections, count, sizeof (*sections), sort_sections_by_lma);



  for (p = 
# 4815 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 4815 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              , i = 0; i < count; i++)
    {
      s = sections[i].sec;
      if ((s->flags & 0x002) != 0)
 {
   s_start = s->lma;
   s_end = s_start + ((s->size) >> opb_shift) - 1;






   if (p != 
# 4828 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
       
# 4829 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && (s_start <= p_end
    || p_end < p_start))
     {
       einfo (gettext ("%X%P: section %s LMA [%V,%V]" " overlaps section %s LMA [%V,%V]\n")
                                              ,
       s->name, s_start, s_end, p->name, p_start, p_end);
       sections[i].warned = 1;
     }
   p = s;
   p_start = s_start;
   p_end = s_end;
 }
    }






  qsort (sections, count, sizeof (*sections), sort_sections_by_vma);
  overlays = 0;
  p_start = sections[0].sec->vma;
  for (i = 1; i < count; i++)
    {
      s_start = sections[i].sec->vma;
      if (p_start == s_start)
 {
   overlays = 1;
   break;
 }
      p_start = s_start;
    }


  if (!overlays)
    {
      for (p = 
# 4865 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 4865 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  , i = 0; i < count; i++)
 {
   s = sections[i].sec;
   s_start = s->vma;
   s_end = s_start + ((s->size) >> opb_shift) - 1;

   if (p != 
# 4871 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
       
# 4872 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && !sections[i].warned
       && (s_start <= p_end
    || p_end < p_start))
     einfo (gettext ("%X%P: section %s VMA [%V,%V]" " overlaps section %s VMA [%V,%V]\n")
                                            ,
     s->name, s_start, s_end, p->name, p_start, p_end);
   p = s;
   p_start = s_start;
   p_end = s_end;
 }
    }

  free (sections);
# 4894 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  for (m = lang_memory_region_list; m; m = m->next)
    if (m->had_full_message)
      einfo (gettext ("%X%P: region `%s' overflowed by %ld bytes\n"),
      m->name_list.name, (long)(m->current - (m->origin + m->length)));
}






static void
os_region_check (lang_output_section_statement_type *os,
   lang_memory_region_type *region,
   etree_type *tree,
   bfd_vma rbase)
{
  if ((region->current < region->origin
       || (region->current - region->origin > region->length))
      && ((region->current != region->origin + region->length)
   || rbase == 0))
    {
      if (tree != 
# 4916 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 4916 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
 {
   einfo (gettext ("%X%P: address 0x%v of %B section `%s'" " is not within region `%s'\n")
                                    ,
   region->current,
   os->bfd_section->owner,
   os->bfd_section->name,
   region->name_list.name);
 }
      else if (!region->had_full_message)
 {
   region->had_full_message = 1;

   einfo (gettext ("%X%P: %B section `%s' will not fit in region `%s'\n"),
   os->bfd_section->owner,
   os->bfd_section->name,
   region->name_list.name);
 }
    }
}



static bfd_vma
lang_size_sections_1
  (lang_statement_union_type **prev,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
{
  lang_statement_union_type *s;


  for (s = *prev; s != 
# 4951 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 4951 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ; s = s->header.next)
    {
      switch (s->header.type)
 {
 case lang_output_section_statement_enum:
   {
     bfd_vma newdot, after, dotdelta;
     lang_output_section_statement_type *os;
     lang_memory_region_type *r;
     int section_alignment = 0;

     os = &s->output_section_statement;
     if (os->constraint == -1)
       break;




     if (os->addr_tree == 
# 4969 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
  
# 4970 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && ((&link_info)->type == type_relocatable)
  && (((link_info.output_bfd)->xvec->flavour)
      == bfd_target_coff_flavour))
       os->addr_tree = exp_intop (0);
     if (os->addr_tree != 
# 4974 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 4974 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
       {
  os->processed_vma = 0;
  exp_fold_tree (os->addr_tree, (&_bfd_std_section[2]), &dot);

  if (expld.result.valid_p)
    {
      dot = expld.result.value;
      if (expld.result.section != 
# 4982 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                 ((void *)0)
# 4982 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                     )
        dot += expld.result.section->vma;
    }
  else if (expld.phase != lang_mark_phase_enum)
    einfo (gettext ("%F%S: non constant or forward reference" " address expression for section %s\n")
                                             ,
    os->addr_tree, os->name);
       }

     if (os->bfd_section == 
# 4991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 4991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )

       break;





     if (((((link_info.output_bfd)->xvec->flavour)
    == bfd_target_ecoff_flavour)
   || (((link_info.output_bfd)->xvec->flavour)
       == bfd_target_coff_flavour))
  && (os->bfd_section->flags & 0x4000000) != 0)
       {
  asection *input;

  if (os->children.head == 
# 5007 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
      
# 5008 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || os->children.head->header.next != 
# 5008 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
      
# 5009 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || (os->children.head->header.type
   != lang_input_section_enum))
    einfo (gettext ("%P%X: Internal error on COFF shared library" " section %s\n")
                      , os->name);

  input = os->children.head->input_section.section;
  bfd_set_section_vma (os->bfd_section->owner,
         os->bfd_section,
         ((input)->vma));
  os->bfd_section->size = input->size;
  break;
       }

     newdot = dot;
     dotdelta = 0;
     if (((os->bfd_section) == (&_bfd_std_section[2])))
       {

  do { if (!(os->bfd_section->vma == 0)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5027); } while (0);
       }
     else
       {
  if (os->addr_tree == 
# 5031 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 5031 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
    {


      if (os->region == 
# 5035 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
   
# 5036 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || ((os->bfd_section->flags & (0x001 | 0x002))
       && os->region->name_list.name[0] == '*'
       && strcmp (os->region->name_list.name,
           "*default*") == 0))
        {
   os->region = lang_memory_default (os->bfd_section);
        }




      if (!os->ignored
   && !((os->bfd_section->flags & 0x001) == 0 || ((os->bfd_section->flags & (0x002 | 0x400)) == 0x400))
   && !((&link_info)->type == type_relocatable)
   && check_regions
   && strcmp (os->region->name_list.name,
       "*default*") == 0
   && lang_memory_region_list != 
# 5053 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
   
# 5054 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && (strcmp (lang_memory_region_list->name_list.name,
        "*default*") != 0
       || lang_memory_region_list->next != 
# 5056 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 5056 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              )
   && expld.phase != lang_mark_phase_enum)
        {
# 5068 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   if (command_line.check_section_addresses)
     einfo (gettext ("%P%F: error: no memory region specified" " for loadable section `%s'\n")
                                      ,
     ((void) link_info.output_bfd, (os->bfd_section)->name)
                             );
   else
     einfo (gettext ("%P: warning: no memory region specified" " for loadable section `%s'\n")
                                      ,
     ((void) link_info.output_bfd, (os->bfd_section)->name)
                             );
        }

      newdot = os->region->current;
      section_alignment = os->bfd_section->alignment_power;
    }
  else
    section_alignment = os->section_alignment;


  if (section_alignment > 0)
    {
      bfd_vma savedot = newdot;
      newdot = (((newdot) + ((bfd_vma) 1 << (section_alignment)) - 1) & (-((bfd_vma) 1 << (section_alignment))));

      dotdelta = newdot - savedot;
      if (dotdelta != 0
   && (config.warn_section_align
       || os->addr_tree != 
# 5095 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 5095 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
   && expld.phase != lang_mark_phase_enum)
        einfo (gettext ("%P: warning: changing start of section" " %s by %lu bytes\n")
                               ,
        os->name, (unsigned long) dotdelta);
    }

  bfd_set_section_vma (0, os->bfd_section, newdot);

  os->bfd_section->output_offset = 0;
       }

     lang_size_sections_1 (&os->children.head, os,
      os->fill, newdot, relax, check_regions);

     os->processed_vma = 1;

     if (((os->bfd_section) == (&_bfd_std_section[2])) || os->ignored)





       do { if (!(os->bfd_section->size == 0)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5118); } while (0);
     else
       {
  dot = os->bfd_section->vma;



  after = ((dot
     + ((os->bfd_section->size) >> opb_shift)
     + os->block_value - 1)
    & - (bfd_vma) os->block_value);

  os->bfd_section->size = ((after - os->bfd_section->vma) << opb_shift);
       }


     r = os->region;
     if (r == 
# 5135 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 5135 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
       r = lang_memory_region_lookup ("*default*", 0);

     if (os->load_base)
       {
  bfd_vma lma = exp_get_abs_int (os->load_base, 0, "load base");
  os->bfd_section->lma = lma;
       }
     else if (os->lma_region != 
# 5143 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 5143 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   )
       {
  bfd_vma lma = os->lma_region->current;

  if (os->align_lma_with_input)
    lma += dotdelta;
  else
    {





      if (os->lma_region != os->region)
        section_alignment = os->section_alignment;
      if (section_alignment > 0)
        lma = (((lma) + ((bfd_vma) 1 << (section_alignment)) - 1) & (-((bfd_vma) 1 << (section_alignment))));
    }
  os->bfd_section->lma = lma;
       }
     else if (r->last_os != 
# 5163 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
       
# 5164 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && (os->bfd_section->flags & 0x001) != 0)
       {
  bfd_vma lma;
  asection *last;

  last = r->last_os->output_section_statement.bfd_section;





  if (dot < last->vma
      && os->bfd_section->size != 0
      && dot + ((os->bfd_section->size) >> opb_shift) <= last->vma)
    {






      if (last->vma != last->lma)
        einfo (gettext ("%P: warning: dot moved backwards " "before `%s'\n")
                          , os->name);
    }
  else
    {


      if (os->sectype == overlay_section)
        lma = last->lma + ((last->size) >> opb_shift);



      else
        lma = dot + last->lma - last->vma;

      if (section_alignment > 0)
        lma = (((lma) + ((bfd_vma) 1 << (section_alignment)) - 1) & (-((bfd_vma) 1 << (section_alignment))));
      os->bfd_section->lma = lma;
    }
       }
     os->processed_lma = 1;
# 5222 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     if (!((os->bfd_section->flags & 0x001) == 0 || ((os->bfd_section->flags & (0x002 | 0x400)) == 0x400))
  && (os->bfd_section->size != 0
      || (r->last_os == 
# 5224 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
   
# 5225 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && os->bfd_section->vma != os->bfd_section->lma)
      || (r->last_os != 
# 5226 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
   
# 5227 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && dot >= (r->last_os->output_section_statement
       .bfd_section->vma)))
  && os->lma_region == 
# 5229 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
  
# 5230 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && !((&link_info)->type == type_relocatable))
       r->last_os = s;

     if (((os->bfd_section) == (&_bfd_std_section[2])) || os->ignored)
       break;


     if (!((os->bfd_section->flags & (0x002 | 0x400)) == 0x400)
  || ((&link_info)->type == type_relocatable))
       dotdelta = ((os->bfd_section->size) >> opb_shift);
     else
       dotdelta = 0;
     dot += dotdelta;

     if (os->update_dot_tree != 0)
       exp_fold_tree (os->update_dot_tree, (&_bfd_std_section[2]), &dot);





     if (os->region != 
# 5251 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
  
# 5252 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && (os->bfd_section->flags & (0x001 | 0x002)))
       {
  os->region->current = dot;

  if (check_regions)

    os_region_check (os, os->region, os->addr_tree,
       os->bfd_section->vma);

  if (os->lma_region != 
# 5261 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0) 
# 5261 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            && os->lma_region != os->region
      && ((os->bfd_section->flags & 0x002)
   || os->align_lma_with_input))
    {
      os->lma_region->current = os->bfd_section->lma + dotdelta;

      if (check_regions)
        os_region_check (os, os->lma_region, 
# 5268 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 5268 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                ,
           os->bfd_section->lma);
    }
       }
   }
   break;

 case lang_constructors_statement_enum:
   dot = lang_size_sections_1 (&constructor_list.head,
          output_section_statement,
          fill, dot, relax, check_regions);
   break;

 case lang_data_statement_enum:
   {
     unsigned int size = 0;

     s->data_statement.output_offset =
       dot - output_section_statement->bfd_section->vma;
     s->data_statement.output_section =
       output_section_statement->bfd_section;



     exp_fold_tree (s->data_statement.exp, (&_bfd_std_section[2]), &dot);

     switch (s->data_statement.type)
       {
       default:
  ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 5297, __PRETTY_FUNCTION__);
       case 282:
       case 283:
  size = (8);
  break;
       case 284:
  size = (4);
  break;
       case 285:
  size = (2);
  break;
       case 286:
  size = (1);
  break;
       }
     if (size < (((unsigned) 1) << opb_shift))
       size = (((unsigned) 1) << opb_shift);
     dot += ((size) >> opb_shift);
     output_section_statement->bfd_section->size
       = ((dot - output_section_statement->bfd_section->vma) << opb_shift);

   }
   break;

 case lang_reloc_statement_enum:
   {
     int size;

     s->reloc_statement.output_offset =
       dot - output_section_statement->bfd_section->vma;
     s->reloc_statement.output_section =
       output_section_statement->bfd_section;
     size = bfd_get_reloc_size (s->reloc_statement.howto);
     dot += ((size) >> opb_shift);
     output_section_statement->bfd_section->size
       = ((dot - output_section_statement->bfd_section->vma) << opb_shift);
   }
   break;

 case lang_wild_statement_enum:
   dot = lang_size_sections_1 (&s->wild_statement.children.head,
          output_section_statement,
          fill, dot, relax, check_regions);
   break;

 case lang_object_symbols_statement_enum:
   link_info.create_object_symbols_section =
     output_section_statement->bfd_section;
   break;

 case lang_output_statement_enum:
 case lang_target_statement_enum:
   break;

 case lang_input_section_enum:
   {
     asection *i;

     i = s->input_section.section;
     if (relax)
       {
  bfd_boolean again;

  if (!((*((i->owner)->xvec->_bfd_relax_section)) (i->owner, i, &link_info, &again)))
    einfo (gettext ("%P%F: can't relax section: %E\n"));
  if (again)
    *relax = 1;
       }
     dot = size_input_section (prev, output_section_statement,
          fill, dot);
   }
   break;

 case lang_input_statement_enum:
   break;

 case lang_fill_statement_enum:
   s->fill_statement.output_section =
     output_section_statement->bfd_section;

   fill = s->fill_statement.fill;
   break;

 case lang_assignment_statement_enum:
   {
     bfd_vma newdot = dot;
     etree_type *tree = s->assignment_statement.exp;

     expld.dataseg.relro = exp_dataseg_relro_none;

     exp_fold_tree (tree,
      output_section_statement->bfd_section,
      &newdot);

     if (expld.dataseg.relro == exp_dataseg_relro_start)
       {
  if (!expld.dataseg.relro_start_stat)
    expld.dataseg.relro_start_stat = s;
  else
    {
      do { if (!(expld.dataseg.relro_start_stat == s)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5397); } while (0);
    }
       }
     else if (expld.dataseg.relro == exp_dataseg_relro_end)
       {
  if (!expld.dataseg.relro_end_stat)
    expld.dataseg.relro_end_stat = s;
  else
    {
      do { if (!(expld.dataseg.relro_end_stat == s)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5406); } while (0);
    }
       }
     expld.dataseg.relro = exp_dataseg_relro_none;


     if ((tree->type.node_class == etree_provided
   || tree->type.node_class == etree_assign)
  && (tree->assign.dst [0] != '.'
      || tree->assign.dst [1] != '\0'))
       output_section_statement->update_dot = 1;

     if (!output_section_statement->ignored)
       {
  if (output_section_statement == abs_output_section)
    {


      lang_memory_region_lookup ("*default*",
            0)->current = newdot;
    }
  else if (newdot != dot)
    {



      insert_pad (&s->header.next, fill, ((newdot - dot) << opb_shift),
    output_section_statement->bfd_section, dot);


      s = s->header.next;





      if (output_section_statement->sectype != noalloc_section
   && (output_section_statement->sectype != noload_section
       || (((link_info.output_bfd)->xvec->flavour)
    == bfd_target_elf_flavour)))
        output_section_statement->bfd_section->flags |= 0x001;
    }
  dot = newdot;
       }
   }
   break;

 case lang_padding_statement_enum:





   s->padding_statement.size = 0;






   s->padding_statement.output_offset
     = dot - output_section_statement->bfd_section->vma;
   break;

 case lang_group_statement_enum:
   dot = lang_size_sections_1 (&s->group_statement.children.head,
          output_section_statement,
          fill, dot, relax, check_regions);
   break;

 case lang_insert_statement_enum:
   break;


 case lang_address_statement_enum:
   break;

 default:
   do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5484); } while (0);
   break;
 }
      prev = &s->header.next;
    }
  return dot;
}






bfd_boolean
ldlang_override_segment_assignment (struct bfd_link_info *info __attribute__ ((__unused__)),
        bfd *abfd __attribute__ ((__unused__)),
        asection *current_section,
        asection *previous_section,
        bfd_boolean new_segment)
{
  lang_output_section_statement_type *cur;
  lang_output_section_statement_type *prev;



  if (new_segment)
    return 1;


  if (current_section == 
# 5513 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0) 
# 5513 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             || previous_section == 
# 5513 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                    ((void *)0)
# 5513 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                        )
    return new_segment;



  if (config.separate_code
      && ((current_section->flags ^ previous_section->flags) & 0x010))
    return 1;





  cur = lang_output_section_statement_lookup (current_section->name, 0, 0);
  prev = lang_output_section_statement_lookup (previous_section->name, 0, 0);


  if (cur == 
# 5530 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0) 
# 5530 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 || prev == 
# 5530 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0)
# 5530 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                )
    return new_segment;





  return cur->region != prev->region;
}

void
one_lang_size_sections_pass (bfd_boolean *relax, bfd_boolean check_regions)
{
  lang_statement_iteration++;
  lang_size_sections_1 (&statement_list.head, abs_output_section,
   0, 0, relax, check_regions);
}

void
lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)
{
  expld.phase = lang_allocating_phase_enum;
  expld.dataseg.phase = exp_dataseg_none;

  one_lang_size_sections_pass (relax, check_regions);
  if (expld.dataseg.phase == exp_dataseg_end_seen
      && link_info.relro && expld.dataseg.relro_end)
    {
      bfd_vma initial_base, relro_end, desired_end;
      asection *sec;


      relro_end = ((expld.dataseg.relro_end + expld.dataseg.pagesize - 1)
     & ~(expld.dataseg.pagesize - 1));


      desired_end = relro_end - expld.dataseg.relro_offset;


      for (sec = link_info.output_bfd->section_last; sec; sec = sec->prev)
 if ((sec->flags & 0x001) != 0
     && sec->vma >= expld.dataseg.base
     && sec->vma < expld.dataseg.relro_end - expld.dataseg.relro_offset)
   {


     bfd_vma start, end, bump;

     end = start = sec->vma;
     if (!((sec->flags & (0x002 | 0x400)) == 0x400))
       end += ((sec->size) >> opb_shift);
     bump = desired_end - end;


     start += bump;
     start &= ~(((bfd_vma) 1 << sec->alignment_power) - 1);

     desired_end = start;
   }

      expld.dataseg.phase = exp_dataseg_relro_adjust;
      do { if (!(desired_end >= expld.dataseg.base)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5591); } while (0);
      initial_base = expld.dataseg.base;
      expld.dataseg.base = desired_end;
      lang_reset_memory_regions ();
      one_lang_size_sections_pass (relax, check_regions);

      if (expld.dataseg.relro_end > relro_end)
 {



   expld.dataseg.base = initial_base;
   lang_reset_memory_regions ();
   one_lang_size_sections_pass (relax, check_regions);
 }

      link_info.relro_start = expld.dataseg.base;
      link_info.relro_end = expld.dataseg.relro_end;
    }
  else if (expld.dataseg.phase == exp_dataseg_end_seen)
    {


      bfd_vma first, last;

      first = -expld.dataseg.base & (expld.dataseg.pagesize - 1);
      last = expld.dataseg.end & (expld.dataseg.pagesize - 1);
      if (first && last
   && ((expld.dataseg.base & ~(expld.dataseg.pagesize - 1))
       != (expld.dataseg.end & ~(expld.dataseg.pagesize - 1)))
   && first + last <= expld.dataseg.pagesize)
 {
   expld.dataseg.phase = exp_dataseg_adjust;
   lang_reset_memory_regions ();
   one_lang_size_sections_pass (relax, check_regions);
 }
      else
 expld.dataseg.phase = exp_dataseg_done;
    }
  else
    expld.dataseg.phase = exp_dataseg_done;
}

static lang_output_section_statement_type *current_section;
static lang_assignment_statement_type *current_assign;
static bfd_boolean prefer_next_section;



static bfd_vma
lang_do_assignments_1 (lang_statement_union_type *s,
         lang_output_section_statement_type *current_os,
         fill_type *fill,
         bfd_vma dot,
         bfd_boolean *found_end)
{
  for (; s != 
# 5647 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 5647 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      switch (s->header.type)
 {
 case lang_constructors_statement_enum:
   dot = lang_do_assignments_1 (constructor_list.head,
           current_os, fill, dot, found_end);
   break;

 case lang_output_section_statement_enum:
   {
     lang_output_section_statement_type *os;
     bfd_vma newdot;

     os = &(s->output_section_statement);
     os->after_end = *found_end;
     if (os->bfd_section != 
# 5663 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0) 
# 5663 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                && !os->ignored)
       {
  if ((os->bfd_section->flags & 0x001) != 0)
    {
      current_section = os;
      prefer_next_section = 0;
    }
  dot = os->bfd_section->vma;
       }
     newdot = lang_do_assignments_1 (os->children.head,
         os, os->fill, dot, found_end);
     if (!os->ignored)
       {
  if (os->bfd_section != 
# 5676 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 5676 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
    {

      if (!((os->bfd_section->flags & (0x002 | 0x400)) == 0x400)
   || ((&link_info)->type == type_relocatable))
        dot += ((os->bfd_section->size) >> opb_shift);

      if (os->update_dot_tree != 
# 5683 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
# 5683 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                    )
        exp_fold_tree (os->update_dot_tree,
         (&_bfd_std_section[2]), &dot);
    }
  else
    dot = newdot;
       }
   }
   break;

 case lang_wild_statement_enum:

   dot = lang_do_assignments_1 (s->wild_statement.children.head,
           current_os, fill, dot, found_end);
   break;

 case lang_object_symbols_statement_enum:
 case lang_output_statement_enum:
 case lang_target_statement_enum:
   break;

 case lang_data_statement_enum:
   exp_fold_tree (s->data_statement.exp, (&_bfd_std_section[2]), &dot);
   if (expld.result.valid_p)
     {
       s->data_statement.value = expld.result.value;
       if (expld.result.section != 
# 5709 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                  ((void *)0)
# 5709 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                      )
  s->data_statement.value += expld.result.section->vma;
     }
   else if (expld.phase == lang_final_phase_enum)
     einfo (gettext ("%F%P: invalid data statement\n"));
   {
     unsigned int size;
     switch (s->data_statement.type)
       {
       default:
  ld_abort ("/doner/binutils/binutils-7a31b38/ld/ldlang.c", 5719, __PRETTY_FUNCTION__);
       case 282:
       case 283:
  size = (8);
  break;
       case 284:
  size = (4);
  break;
       case 285:
  size = (2);
  break;
       case 286:
  size = (1);
  break;
       }
     if (size < (((unsigned) 1) << opb_shift))
       size = (((unsigned) 1) << opb_shift);
     dot += ((size) >> opb_shift);
   }
   break;

 case lang_reloc_statement_enum:
   exp_fold_tree (s->reloc_statement.addend_exp,
    (&_bfd_std_section[2]), &dot);
   if (expld.result.valid_p)
     s->reloc_statement.addend_value = expld.result.value;
   else if (expld.phase == lang_final_phase_enum)
     einfo (gettext ("%F%P: invalid reloc statement\n"));
   dot += ((bfd_get_reloc_size (s->reloc_statement.howto)) >> opb_shift);
   break;

 case lang_input_section_enum:
   {
     asection *in = s->input_section.section;

     if ((in->flags & 0x8000) == 0)
       dot += ((in->size) >> opb_shift);
   }
   break;

 case lang_input_statement_enum:
   break;

 case lang_fill_statement_enum:
   fill = s->fill_statement.fill;
   break;

 case lang_assignment_statement_enum:
   current_assign = &s->assignment_statement;
   if (current_assign->exp->type.node_class != etree_assert)
     {
       const char *p = current_assign->exp->assign.dst;

       if (current_os == abs_output_section && p[0] == '.' && p[1] == 0)
  prefer_next_section = 1;

       while (*p == '_')
  ++p;
       if (strcmp (p, "end") == 0)
  *found_end = 1;
     }
   exp_fold_tree (s->assignment_statement.exp,
    (current_os->bfd_section != 
# 5781 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
     
# 5782 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
    ? current_os->bfd_section : (&_bfd_std_section[1])),
    &dot);
   break;

 case lang_padding_statement_enum:
   dot += ((s->padding_statement.size) >> opb_shift);
   break;

 case lang_group_statement_enum:
   dot = lang_do_assignments_1 (s->group_statement.children.head,
           current_os, fill, dot, found_end);
   break;

 case lang_insert_statement_enum:
   break;

 case lang_address_statement_enum:
   break;

 default:
   do { info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",5802); } while (0);
   break;
 }
    }
  return dot;
}

void
lang_do_assignments (lang_phase_type phase)
{
  bfd_boolean found_end = 0;

  current_section = 
# 5814 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 5814 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       ;
  prefer_next_section = 0;
  expld.phase = phase;
  lang_statement_iteration++;
  lang_do_assignments_1 (statement_list.head,
    abs_output_section, 
# 5819 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 5819 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           , 0, &found_end);
}





asection *
section_for_dot (void)
{
  asection *s;
# 5839 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  if (current_section == 
# 5839 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0) 
# 5839 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             || prefer_next_section)
    {
      lang_statement_union_type *stmt;
      lang_output_section_statement_type *os;

      for (stmt = (lang_statement_union_type *) current_assign;
    stmt != 
# 5845 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 5845 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;
    stmt = stmt->header.next)
 if (stmt->header.type == lang_output_section_statement_enum)
   break;

      os = &stmt->output_section_statement;
      while (os != 
# 5851 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
      
# 5852 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && !os->after_end
      && (os->bfd_section == 
# 5853 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0)
   
# 5854 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  || (os->bfd_section->flags & 0x8000) != 0
   || ((os->bfd_section)->next == 
# 5855 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0) 
# 5855 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ? (link_info.output_bfd)->section_last != (os->bfd_section) : (os->bfd_section)->next->prev != (os->bfd_section))
                         ))
 os = os->next;

      if (current_section == 
# 5859 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0) 
# 5859 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 || os == 
# 5859 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0) 
# 5859 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               || !os->after_end)
 {
   if (os != 
# 5861 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 5861 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                )
     s = os->bfd_section;
   else
     s = link_info.output_bfd->section_last;
   while (s != 
# 5865 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
   
# 5866 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && ((s->flags & 0x001) == 0
       || (s->flags & 0x400) != 0))
     s = s->prev;
   if (s != 
# 5869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 5869 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               )
     return s;

   return (&_bfd_std_section[2]);
 }
    }

  s = current_section->bfd_section;


  while (s != 
# 5879 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
  
# 5880 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && ((s->flags & 0x8000) != 0
      || (s->flags & 0x001) == 0
      || (s->flags & 0x400) != 0
      || ((s)->next == 
# 5883 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
        ((void *)0) 
# 5883 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
        ? (link_info.output_bfd)->section_last != (s) : (s)->next->prev != (s))))
    s = s->prev;
  if (s == 
# 5885 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 5885 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              )
    s = link_info.output_bfd->sections;
  while (s != 
# 5887 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
  
# 5888 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && ((s->flags & 0x001) == 0
      || (s->flags & 0x400) != 0))
    s = s->next;
  if (s != 
# 5891 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 5891 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              )
    return s;

  return (&_bfd_std_section[2]);
}



static struct bfd_link_hash_entry **start_stop_syms;
static size_t start_stop_count = 0;
static size_t start_stop_alloc = 0;




static void
lang_define_start_stop (const char *symbol, asection *sec)
{
  struct bfd_link_hash_entry *h;

  h = ((*((link_info.output_bfd)->xvec->_bfd_define_start_stop)) (&link_info, symbol, sec));
  if (h != 
# 5912 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 5912 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              )
    {
      if (start_stop_count == start_stop_alloc)
 {
   start_stop_alloc = 2 * start_stop_alloc + 10;
   start_stop_syms
     = xrealloc (start_stop_syms,
   start_stop_alloc * sizeof (*start_stop_syms));
 }
      start_stop_syms[start_stop_count++] = h;
    }
}





static void
lang_init_start_stop (void)
{
  bfd *abfd;
  asection *s;
  char leading_char = ((link_info.output_bfd)->xvec->symbol_leading_char);

  for (abfd = link_info.input_bfds; abfd != 
# 5936 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 5936 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ; abfd = abfd->link.next)
    for (s = abfd->sections; s != 
# 5937 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                 ((void *)0)
# 5937 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                     ; s = s->next)
      {
 const char *ps;
 const char *secname = s->name;

 for (ps = secname; *ps != '\0'; ps++)
   if (!(_sch_istable[((unsigned char) *ps) & 0xff] & (unsigned short)(_sch_isalnum)) && *ps != '_')
     break;
 if (*ps == '\0')
   {
     char *symbol = (char *) xmalloc (10 + strlen (secname));

     symbol[0] = leading_char;
     sprintf (symbol + (leading_char != 0), "__start_%s", secname);
     lang_define_start_stop (symbol, s);

     symbol[1] = leading_char;
     memcpy (symbol + 1 + (leading_char != 0), "__stop", 6);
     lang_define_start_stop (symbol + 1, s);

     free (symbol);
   }
      }
}



static void
foreach_start_stop (void (*func) (struct bfd_link_hash_entry *))
{
  size_t i;

  for (i = 0; i < start_stop_count; ++i)
    func (start_stop_syms[i]);
}







static void
undef_start_stop (struct bfd_link_hash_entry *h)
{
  if (h->ldscript_def)
    return;

  if (h->u.def.section->output_section == 
# 5985 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
      
# 5986 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || h->u.def.section->output_section->owner != link_info.output_bfd
      || strcmp (h->u.def.section->name,
   h->u.def.section->output_section->name) != 0)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = 
# 5991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 5991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           ;
    }
}

static void
lang_undef_start_stop (void)
{
  foreach_start_stop (undef_start_stop);
}





static void
lang_init_startof_sizeof (void)
{
  asection *s;

  for (s = link_info.output_bfd->sections; s != 
# 6010 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 6010 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   ; s = s->next)
    {
      const char *secname = s->name;
      char *symbol = (char *) xmalloc (10 + strlen (secname));

      sprintf (symbol, ".startof.%s", secname);
      lang_define_start_stop (symbol, s);

      memcpy (symbol + 1, ".size", 5);
      lang_define_start_stop (symbol + 1, s);
      free (symbol);
    }
}



static void
set_start_stop (struct bfd_link_hash_entry *h)
{
  if (h->ldscript_def
      || h->type != bfd_link_hash_defined)
    return;

  if (h->root.string[0] == '.')
    {


      if (h->root.string[2] == 'i')
 {

   h->u.def.value = ((h->u.def.section->size) >> opb_shift);
   h->u.def.section = (&_bfd_std_section[2]);
 }
    }
  else
    {

      int has_lead = ((link_info.output_bfd)->xvec->symbol_leading_char) != 0;

      h->u.def.section = h->u.def.section->output_section;
      if (h->root.string[4 + has_lead] == 'o')
 {

   h->u.def.value = ((h->u.def.section->size) >> opb_shift);
 }
    }
}

static void
lang_finalize_start_stop (void)
{
  foreach_start_stop (set_start_stop);
}

static void
lang_end (void)
{
  struct bfd_link_hash_entry *h;
  bfd_boolean warn;

  if ((((&link_info)->type == type_relocatable) && !link_info.gc_sections)
      || ((&link_info)->type == type_dll))
    warn = entry_from_cmdline;
  else
    warn = 1;



  if (link_info.gc_sections && ((&link_info)->type == type_relocatable)
      && !(entry_from_cmdline || undef_from_cmdline))
    einfo (gettext ("%P%F: gc-sections requires either an entry or " "an undefined symbol\n")
                              );

  if (entry_symbol.name == 
# 6083 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 6083 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
    {


      entry_symbol.name = entry_symbol_default;
      warn = 0;
    }

  h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,
       0, 0, 1);
  if (h != 
# 6093 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
      
# 6094 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && (h->type == bfd_link_hash_defined
   || h->type == bfd_link_hash_defweak)
      && h->u.def.section->output_section != 
# 6096 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 6096 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                )
    {
      bfd_vma val;

      val = (h->u.def.value
      + ((void) link_info.output_bfd, (h->u.def.section->output_section)->vma)

      + h->u.def.section->output_offset);
      if (!bfd_set_start_address (link_info.output_bfd, val))
 einfo (gettext ("%P%F:%s: can't set start address\n"), entry_symbol.name);
    }
  else
    {
      bfd_vma val;
      const char *send;



      val = bfd_scan_vma (entry_symbol.name, &send, 0);
      if (*send == '\0')
 {
   if (!bfd_set_start_address (link_info.output_bfd, val))
     einfo (gettext ("%P%F: can't set start address\n"));
 }
      else
 {
   asection *ts;



   ts = bfd_get_section_by_name (link_info.output_bfd, entry_section);
   if (ts != 
# 6127 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 6127 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                )
     {
       if (warn)
  einfo (gettext ("%P: warning: cannot find entry symbol %s;" " defaulting to %V\n")
                          ,
         entry_symbol.name,
         ((void) link_info.output_bfd, (ts)->vma));
       if (!(bfd_set_start_address
      (link_info.output_bfd,
       ((void) link_info.output_bfd, (ts)->vma))))
  einfo (gettext ("%P%F: can't set start address\n"));
     }
   else
     {
       if (warn)
  einfo (gettext ("%P: warning: cannot find entry symbol %s;" " not setting start address\n")
                                   ,
         entry_symbol.name);
     }
 }
    }
}




static void
ignore_bfd_errors (const char *fmt __attribute__ ((__unused__)),
     va_list ap __attribute__ ((__unused__)))
{

}





static void
lang_check (void)
{
  lang_statement_union_type *file;
  bfd *input_bfd;
  const bfd_arch_info_type *compatible;

  for (file = file_chain.head; file != 
# 6171 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 6171 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          ; file = file->input_statement.next)
    {


      if (file->input_statement.flags.claimed)
 continue;

      input_bfd = file->input_statement.the_bfd;
      compatible
 = bfd_arch_get_compatible (input_bfd, link_info.output_bfd,
       command_line.accept_unknown_input_arch);







      if ((((&link_info)->type == type_relocatable)
    || link_info.emitrelocations)
   && (compatible == 
# 6191 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
       
# 6192 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      || (((input_bfd)->xvec->flavour)
    != ((link_info.output_bfd)->xvec->flavour)))
   && (((input_bfd)->flags) & 0x01) != 0)
 {
   einfo (gettext ("%P%F: Relocatable linking with relocations from" " format %s (%B) to format %s (%B) is not supported\n")
                                                            ,
   ((input_bfd)->xvec->name), input_bfd,
   ((link_info.output_bfd)->xvec->name), link_info.output_bfd);

 }

      if (compatible == 
# 6203 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 6203 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           )
 {
   if (command_line.warn_mismatch)
     einfo (gettext ("%P%X: %s architecture of input file `%B'" " is incompatible with %s output\n")
                                           ,
     bfd_printable_name (input_bfd), input_bfd,
     bfd_printable_name (link_info.output_bfd));
 }
      else if (((input_bfd)->section_count))
 {



   bfd_error_handler_type pfn = 
# 6216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 6216 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   ;






   if (!command_line.warn_mismatch)
     pfn = bfd_set_error_handler (ignore_bfd_errors);
   if (!((*(((&link_info)->output_bfd)->xvec->_bfd_merge_private_bfd_data)) (input_bfd, &link_info)))
     {
       if (command_line.warn_mismatch)
  einfo (gettext ("%P%X: failed to merge target specific data" " of file %B\n")
                    , input_bfd);
     }
   if (!command_line.warn_mismatch)
     bfd_set_error_handler (pfn);
 }
    }
}





static void
lang_common (void)
{
  if (command_line.inhibit_common_definition)
    return;
  if (((&link_info)->type == type_relocatable)
      && !command_line.force_common_definition)
    return;

  if (!config.sort_common)
    bfd_link_hash_traverse (link_info.hash, lang_one_common, 
# 6251 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                            ((void *)0)
# 6251 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                );
  else
    {
      unsigned int power;

      if (config.sort_common == sort_descending)
 {
   for (power = 4; power > 0; power--)
     bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);

   power = 0;
   bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
 }
      else
 {
   for (power = 0; power <= 4; power++)
     bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);

   power = (unsigned int) -1;
   bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
 }
    }
}



static bfd_boolean
lang_one_common (struct bfd_link_hash_entry *h, void *info)
{
  unsigned int power_of_two;
  bfd_vma size;
  asection *section;

  if (h->type != bfd_link_hash_common)
    return 1;

  size = h->u.c.size;
  power_of_two = h->u.c.p->alignment_power;

  if (config.sort_common == sort_descending
      && power_of_two < *(unsigned int *) info)
    return 1;
  else if (config.sort_common == sort_ascending
    && power_of_two > *(unsigned int *) info)
    return 1;

  section = h->u.c.p->section;
  if (!((*((link_info.output_bfd)->xvec->_bfd_define_common_symbol)) (link_info.output_bfd, &link_info, h)))
    einfo (gettext ("%P%F: Could not define common symbol `%T': %E\n"),
    h->root.string);

  if (config.map_file != 
# 6302 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 6302 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
    {
      static bfd_boolean header_printed;
      int len;
      char *name;
      char buf[50];

      if (!header_printed)
 {
   minfo (gettext ("\nAllocating common symbols\n"));
   minfo (gettext ("Common symbol       size              file\n\n"));
   header_printed = 1;
 }

      name = bfd_demangle (link_info.output_bfd, h->root.string,
      (1 << 1) | (1 << 0));
      if (name == 
# 6318 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 6318 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
 {
   minfo ("%s", h->root.string);
   len = strlen (h->root.string);
 }
      else
 {
   minfo ("%s", name);
   len = strlen (name);
   free (name);
 }

      if (len >= 19)
 {
   print_nl ();
   len = 0;
 }
      while (len < 20)
 {
   print_space ();
   ++len;
 }

      minfo ("0x");
      if (size <= 0xffffffff)
 sprintf (buf, "%lx", (unsigned long) size);
      else
 sprintf (buf, "%016" "l" "x", size);
      minfo ("%s", buf);
      len = strlen (buf);

      while (len < 16)
 {
   print_space ();
   ++len;
 }

      minfo ("%B\n", section->owner);
    }

  return 1;
}





static void
ldlang_place_orphan (asection *s)
{
  if (config.orphan_handling == orphan_handling_discard)
    {
      lang_output_section_statement_type *os;
      os = lang_output_section_statement_lookup ("/DISCARD/", 0,
       1);
      if (os->addr_tree == 
# 6373 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
   
# 6374 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && (((&link_info)->type == type_relocatable)
       || (s->flags & (0x002 | 0x001)) == 0))
 os->addr_tree = exp_intop (0);
      lang_add_section (&os->children, s, 
# 6377 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
# 6377 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                             , os);
    }
  else
    {
      lang_output_section_statement_type *os;
      const char *name = s->name;
      int constraint = 0;

      if (config.orphan_handling == orphan_handling_error)
 einfo ("%X%P: error: unplaced orphan section `%A' from `%B'.\n",
        s, s->owner);

      if (config.unique_orphan_sections || unique_section_p (s, 
# 6389 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                               ((void *)0)
# 6389 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                   ))
 constraint = 382;

      os = ldemul_place_orphan (s, name, constraint);
      if (os == 
# 6393 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 6393 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
 {
   os = lang_output_section_statement_lookup (name, constraint, 1);
   if (os->addr_tree == 
# 6396 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
       
# 6397 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      && (((&link_info)->type == type_relocatable)
    || (s->flags & (0x002 | 0x001)) == 0))
     os->addr_tree = exp_intop (0);
   lang_add_section (&os->children, s, 
# 6400 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 6400 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          , os);
 }

      if (config.orphan_handling == orphan_handling_warn)
 einfo ("%P: warning: orphan section `%A' from `%B' being "
        "placed in section `%s'.\n",
        s, s->owner, os->name);
    }
}





static void
lang_place_orphans (void)
{
  lang_input_statement_type *file; for (file = (lang_input_statement_type *) file_chain.head; file != (lang_input_statement_type *) 
# 6417 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 6417 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 ; file = (lang_input_statement_type *) file->next)
    {
      asection *s;

      for (s = file->the_bfd->sections; s != 
# 6421 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                            ((void *)0)
# 6421 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                ; s = s->next)
 {
   if (s->output_section == 
# 6423 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                           ((void *)0)
# 6423 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                               )
     {



       if (file->flags.just_syms)
  ((*((file->the_bfd)->xvec->_bfd_link_just_syms)) (s, &link_info));
       else if (lang_discard_section_p (s))
  s->output_section = (&_bfd_std_section[2]);
       else if (strcmp (s->name, "COMMON") == 0)
  {



    if (!((&link_info)->type == type_relocatable)
        || command_line.force_common_definition)
      {
        if (default_common_section == 
# 6440 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 6440 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         )
   default_common_section
     = lang_output_section_statement_lookup (".bss", 0,
          1);
        lang_add_section (&default_common_section->children, s,
     
# 6445 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
    ((void *)0)
# 6445 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
        , default_common_section);
      }
  }
       else
  ldlang_place_orphan (s);
     }
 }
    }
}

void
lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
{
  flagword *ptr_flags;

  ptr_flags = invert ? &ptr->not_flags : &ptr->flags;

  while (*flags)
    {
      switch (*flags)
 {


 case '!':
   invert = !invert;
   ptr_flags = invert ? &ptr->not_flags : &ptr->flags;
   break;

 case 'A': case 'a':
   *ptr_flags |= 0x001;
   break;

 case 'R': case 'r':
   *ptr_flags |= 0x008;
   break;

 case 'W': case 'w':
   *ptr_flags |= 0x020;
   break;

 case 'X': case 'x':
   *ptr_flags |= 0x010;
   break;

 case 'L': case 'l':
 case 'I': case 'i':
   *ptr_flags |= 0x002;
   break;

 default:
   einfo (gettext ("%P%F: invalid character %c (%d) in flags\n"),
   *flags, *flags);
   break;
 }
      flags++;
    }
}




void
lang_for_each_input_file (void (*func) (lang_input_statement_type *))
{
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) input_file_chain.head;
       f != 
# 6512 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 6512 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;
       f = (lang_input_statement_type *) f->next_real_file)
    func (f);
}





void
lang_for_each_file (void (*func) (lang_input_statement_type *))
{
  lang_input_statement_type *f; for (f = (lang_input_statement_type *) file_chain.head; f != (lang_input_statement_type *) 
# 6524 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 6524 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 ; f = (lang_input_statement_type *) f->next)
    {
      func (f);
    }
}

void
ldlang_add_file (lang_input_statement_type *entry)
{
  lang_statement_append (&file_chain,
    (lang_statement_union_type *) entry,
    &entry->next);



  do { if (!(entry->the_bfd->link.next == 
# 6539 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 6539 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",6539); } while (0);
  do { if (!(entry->the_bfd != link_info.output_bfd)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",6540); } while (0);

  *link_info.input_bfds_tail = entry->the_bfd;
  link_info.input_bfds_tail = &entry->the_bfd->link.next;
  entry->the_bfd->usrdata = entry;
  bfd_set_gp_size (entry->the_bfd, g_switch_value);
# 6557 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  bfd_map_over_sections (entry->the_bfd, section_already_linked, entry);
}

void
lang_add_output (const char *name, int from_script)
{

  if (!had_output_filename || !from_script)
    {
      output_filename = name;
      had_output_filename = 1;
    }
}

static int
topower (int x)
{
  unsigned int i = 1;
  int l;

  if (x < 0)
    return -1;

  for (l = 0; l < 32; l++)
    {
      if (i >= (unsigned int) x)
 return l;
      i <<= 1;
    }

  return 0;
}

lang_output_section_statement_type *
lang_enter_output_section_statement (const char *output_section_statement_name,
         etree_type *address_exp,
         enum section_type sectype,
         etree_type *align,
         etree_type *subalign,
         etree_type *ebase,
         int constraint,
         int align_with_input)
{
  lang_output_section_statement_type *os;

  os = lang_output_section_statement_lookup (output_section_statement_name,
          constraint, 1);
  current_section = os;

  if (os->addr_tree == 
# 6606 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 6606 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          )
    {
      os->addr_tree = address_exp;
    }
  os->sectype = sectype;
  if (sectype != noload_section)
    os->flags = 0x000;
  else
    os->flags = 0x200;
  os->block_value = 1;


  push_stat_ptr (&os->children);

  os->align_lma_with_input = align_with_input == 384;
  if (os->align_lma_with_input && align != 
# 6621 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 6621 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              )
    einfo (gettext ("%F%P:%S: error: align with input and explicit align specified\n"),
    
# 6623 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
   ((void *)0)
# 6623 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       );

  os->subsection_alignment =
    topower (exp_get_value_int (subalign, -1, "subsection alignment"));
  os->section_alignment =
    topower (exp_get_value_int (align, -1, "section alignment"));

  os->load_base = ebase;
  return os;
}

void
lang_final (void)
{
  lang_output_statement_type *new_stmt;

  new_stmt = (lang_output_statement_type *) new_statement (lang_output_statement_enum, sizeof (lang_output_statement_type), stat_ptr);
  new_stmt->name = output_filename;
}



void
lang_reset_memory_regions (void)
{
  lang_memory_region_type *p = lang_memory_region_list;
  asection *o;
  lang_output_section_statement_type *os;

  for (p = lang_memory_region_list; p != 
# 6652 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 6652 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; p = p->next)
    {
      p->current = p->origin;
      p->last_os = 
# 6655 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 6655 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      ;
    }

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != 
# 6659 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 6659 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
       os = os->next)
    {
      os->processed_vma = 0;
      os->processed_lma = 0;
    }

  for (o = link_info.output_bfd->sections; o != 
# 6666 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                               ((void *)0)
# 6666 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                   ; o = o->next)
    {

      o->rawsize = o->size;
      o->size = 0;
    }
}



static void
gc_section_callback (lang_wild_statement_type *ptr,
       struct wildcard_list *sec __attribute__ ((__unused__)),
       asection *section,
       struct flag_info *sflag_info __attribute__ ((__unused__)),
       lang_input_statement_type *file __attribute__ ((__unused__)),
       void *data __attribute__ ((__unused__)))
{


  if (ptr->keep_sections)
    section->flags |= 0x200000;
}



static void
lang_gc_sections_1 (lang_statement_union_type *s)
{
  for (; s != 
# 6695 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 6695 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      switch (s->header.type)
 {
 case lang_wild_statement_enum:
   walk_wild (&s->wild_statement, gc_section_callback, 
# 6700 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                      ((void *)0)
# 6700 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                          );
   break;
 case lang_constructors_statement_enum:
   lang_gc_sections_1 (constructor_list.head);
   break;
 case lang_output_section_statement_enum:
   lang_gc_sections_1 (s->output_section_statement.children.head);
   break;
 case lang_group_statement_enum:
   lang_gc_sections_1 (s->group_statement.children.head);
   break;
 default:
   break;
 }
    }
}

static void
lang_gc_sections (void)
{

  lang_gc_sections_1 (statement_list.head);




  if (((&link_info)->type == type_relocatable))
    {
      lang_input_statement_type *f; for (f = (lang_input_statement_type *) file_chain.head; f != (lang_input_statement_type *) 
# 6728 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
     ((void *)0)
# 6728 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     ; f = (lang_input_statement_type *) f->next)
 {
   asection *sec;

   if (f->flags.claimed)
     continue;

   for (sec = f->the_bfd->sections; sec != 
# 6735 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 6735 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              ; sec = sec->next)
     if ((sec->flags & 0x2000) == 0)
       sec->flags &= ~0x8000;
 }
    }

  if (link_info.gc_sections)
    ((*((link_info.output_bfd)->xvec->_bfd_gc_sections)) (link_info.output_bfd, &link_info));
}



static void
find_relro_section_callback (lang_wild_statement_type *ptr __attribute__ ((__unused__)),
        struct wildcard_list *sec __attribute__ ((__unused__)),
        asection *section,
        struct flag_info *sflag_info __attribute__ ((__unused__)),
        lang_input_statement_type *file __attribute__ ((__unused__)),
        void *data)
{


  if (section->output_section != 
# 6757 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                ((void *)0)
      
# 6758 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && section->output_section->owner == link_info.output_bfd
      && (section->output_section->flags & 0x8000) == 0
      && !((section->flags & 0x001) == 0 || ((section->flags & (0x002 | 0x400)) == 0x400))
      && section->size != 0)
    {
      bfd_boolean *has_relro_section = (bfd_boolean *) data;
      *has_relro_section = 1;
    }
}



static void
lang_find_relro_sections_1 (lang_statement_union_type *s,
       bfd_boolean *has_relro_section)
{
  if (*has_relro_section)
    return;

  for (; s != 
# 6777 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 6777 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; s = s->header.next)
    {
      if (s == expld.dataseg.relro_end_stat)
 break;

      switch (s->header.type)
 {
 case lang_wild_statement_enum:
   walk_wild (&s->wild_statement,
       find_relro_section_callback,
       has_relro_section);
   break;
 case lang_constructors_statement_enum:
   lang_find_relro_sections_1 (constructor_list.head,
          has_relro_section);
   break;
 case lang_output_section_statement_enum:
   lang_find_relro_sections_1 (s->output_section_statement.children.head,
          has_relro_section);
   break;
 case lang_group_statement_enum:
   lang_find_relro_sections_1 (s->group_statement.children.head,
          has_relro_section);
   break;
 default:
   break;
 }
    }
}

static void
lang_find_relro_sections (void)
{
  bfd_boolean has_relro_section = 0;



  lang_find_relro_sections_1 (expld.dataseg.relro_start_stat,
         &has_relro_section);

  if (!has_relro_section)
    link_info.relro = 0;
}



void
lang_relax_sections (bfd_boolean need_layout)
{
  if ((link_info.disable_target_specific_optimizations == 0 || link_info.disable_target_specific_optimizations == 1))
    {

      int i = link_info.relax_pass;


      link_info.relax_pass = 0;

      while (i--)
 {

   bfd_boolean relax_again;

   link_info.relax_trip = -1;
   do
     {
       link_info.relax_trip++;







       lang_do_assignments (lang_assigning_phase_enum);



       lang_reset_memory_regions ();



       relax_again = 0;
       lang_size_sections (&relax_again, 0);
     }
   while (relax_again);

   link_info.relax_pass++;
 }
      need_layout = 1;
    }

  if (need_layout)
    {

      lang_do_assignments (lang_assigning_phase_enum);
      lang_reset_memory_regions ();
      lang_size_sections (
# 6873 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 6873 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             , 1);
    }
}
# 6889 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static lang_input_statement_type *
find_replacements_insert_point (void)
{
  lang_input_statement_type *claim1, *lastobject;
  lastobject = &input_file_chain.head->input_statement;
  for (claim1 = &file_chain.head->input_statement;
       claim1 != 
# 6895 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 6895 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
       claim1 = &claim1->next->input_statement)
    {
      if (claim1->flags.claimed)
 return claim1->flags.claim_archive ? lastobject : claim1;

      if (claim1->the_bfd != 
# 6901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0) 
# 6901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 && claim1->the_bfd->my_archive == 
# 6901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                                   ((void *)0)
# 6901 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                                       )
 lastobject = claim1;
    }



  return lastobject;
}





static void
lang_list_insert_after (lang_statement_list_type *destlist,
   lang_statement_list_type *srclist,
   lang_statement_union_type **field)
{
  *(srclist->tail) = *field;
  *field = srclist->head;
  if (destlist->tail == field)
    destlist->tail = srclist->tail;
}




static void
lang_list_remove_tail (lang_statement_list_type *destlist,
         lang_statement_list_type *origlist)
{
  union lang_statement_union **savetail;

  do { if (!(origlist->head == destlist->head)) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",6934); } while (0);
  savetail = origlist->tail;
  origlist->head = *(savetail);
  origlist->tail = destlist->tail;
  destlist->tail = savetail;
  *savetail = 
# 6939 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 6939 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ;
}




void
lang_add_gc_name (const char *name)
{
  struct bfd_sym_chain *sym;

  if (name == 
# 6950 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 6950 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    return;

  sym = (struct bfd_sym_chain *) stat_alloc (sizeof (*sym));

  sym->next = link_info.gc_sym_list;
  sym->name = name;
  link_info.gc_sym_list = sym;
}



static void
lang_check_relocs (void)
{
  if (link_info.check_relocs_after_open_input)
    {
      bfd *abfd;

      for (abfd = link_info.input_bfds;
    abfd != (bfd *) 
# 6970 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 6970 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       ; abfd = abfd->link.next)
 if (!bfd_link_check_relocs (abfd, &link_info))
   {

     config.make_executable = 0;



   }
    }
}




static void
lang_propagate_lma_regions (void)
{
  lang_output_section_statement_type *os;

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != 
# 6991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 6991 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
       os = os->next)
    {
      if (os->prev != 
# 6994 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
   
# 6995 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && os->lma_region == 
# 6995 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
   
# 6996 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && os->load_base == 
# 6996 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
   
# 6997 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && os->addr_tree == 
# 6997 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
   
# 6998 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  && os->region == os->prev->region)
 os->lma_region = os->prev->lma_region;
    }
}

void
lang_process (void)
{

  if (link_info.dynamic_list)
    lang_finalize_version_expr_head (&link_info.dynamic_list->head);

  current_target = default_target;


  lang_for_each_statement (ldlang_open_output);
  init_opb ();

  ldemul_create_output_section_statements ();


  lang_place_undefineds ();

  if (!bfd_section_already_linked_table_init ())
    einfo (gettext ("%P%F: Failed to create hash table\n"));


  current_target = default_target;
  open_input_bfds (statement_list.head, OPEN_BFD_NORMAL);


  if (link_info.lto_plugin_active)
    {
      lang_statement_list_type added;
      lang_statement_list_type files, inputfiles;







      added = *stat_ptr;

      files = file_chain;
      inputfiles = input_file_chain;
      if (plugin_call_all_symbols_read ())
 einfo (gettext ("%P%F: %s: plugin reported error after all symbols read\n"),
        plugin_error_plugin ());

      open_input_bfds (*added.tail, OPEN_BFD_NORMAL);

      lang_list_remove_tail (stat_ptr, &added);

      lang_list_remove_tail (&file_chain, &files);
      lang_list_remove_tail (&input_file_chain, &inputfiles);

      if (added.head != 
# 7055 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 7055 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           )
 {


   plugin_insert = find_replacements_insert_point ();




   do { if (!(plugin_insert != 
# 7064 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
  ((void *)0)
# 7064 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
  )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",7064); } while (0);

   lang_list_insert_after (stat_ptr, &added,
      &plugin_insert->header.next);

   lang_list_insert_after (&input_file_chain, &inputfiles,
      &plugin_insert->next_real_file);



   if (plugin_insert->filename)
     lang_list_insert_after (&file_chain, &files, &plugin_insert->next);
   else
     lang_list_insert_after (&file_chain, &files, &file_chain.head);


   open_input_bfds (statement_list.head, OPEN_BFD_RESCAN);
 }
    }




  do { if (!(link_info.gc_sym_list == 
# 7087 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 7087 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",7087); } while (0);

  link_info.gc_sym_list = &entry_symbol;

  if (entry_symbol.name == 
# 7091 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
# 7091 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                              )
    {
      link_info.gc_sym_list = entry_symbol.next;
# 7103 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
      lang_add_gc_name (entry_symbol_default);
    }

  lang_add_gc_name (link_info.init_function);
  lang_add_gc_name (link_info.fini_function);

  ldemul_after_open ();
  if (config.map_file != 
# 7110 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 7110 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
    lang_print_asneeded ();

  bfd_section_already_linked_table_free ();






  lang_check ();


  if (command_line.version_exports_section)
    lang_do_version_exports_section ();



  ldctor_build_sets ();




  if (config.build_constructors)
    lang_init_start_stop ();



  lang_do_assignments (lang_mark_phase_enum);

  lang_do_memory_regions();
  expld.phase = lang_first_phase_enum;


  lang_common ();


  lang_gc_sections ();


  lang_check_relocs ();


  update_wild_statements (statement_list.head);



  lang_statement_iteration++;
  map_input_to_output_sections (statement_list.head, 
# 7158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                    ((void *)0)
# 7158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                        , 
# 7158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                                          ((void *)0)
# 7158 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                              );

  process_insert_statements ();


  lang_place_orphans ();

  if (!((&link_info)->type == type_relocatable))
    {
      asection *found;





      ((*((link_info.output_bfd)->xvec->_bfd_merge_sections)) (link_info.output_bfd, &link_info));


      found = bfd_get_section_by_name (link_info.output_bfd, ".text");

      if (found != 
# 7178 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 7178 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
 {
   if (config.text_read_only)
     found->flags |= 0x008;
   else
     found->flags &= ~0x008;
 }
    }


  lang_propagate_lma_regions ();




  if (config.build_constructors)
    lang_undef_start_stop ();



  if (!((&link_info)->type == type_relocatable))
    lang_init_startof_sizeof ();



  ldemul_before_allocation ();



  lang_record_phdrs ();


  if (link_info.relro && !((&link_info)->type == type_relocatable))
    lang_find_relro_sections ();


  lang_size_sections (
# 7214 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 7214 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         , !(link_info.disable_target_specific_optimizations == 0 || link_info.disable_target_specific_optimizations == 1));



  ldemul_after_allocation ();


  lang_finalize_start_stop ();



  lang_do_assignments (lang_final_phase_enum);

  ldemul_finish ();


  ldexp_finalize_syms ();


  if (command_line.check_section_addresses)
    lang_check_section_addresses ();


  ldlang_check_require_defined_symbols ();

  lang_end ();
}



void
lang_add_wild (struct wildcard_spec *filespec,
        struct wildcard_list *section_list,
        bfd_boolean keep_sections)
{
  struct wildcard_list *curr, *next;
  lang_wild_statement_type *new_stmt;


  for (curr = section_list, section_list = 
# 7253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 7253 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              ;
       curr != 
# 7254 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 7254 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  ;
       section_list = curr, curr = next)
    {
      if (curr->spec.name != 
# 7257 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0) 
# 7257 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 && strcmp (curr->spec.name, "COMMON") == 0)
 placed_commons = 1;

      next = curr->next;
      curr->next = section_list;
    }

  if (filespec != 
# 7264 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0) 
# 7264 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      && filespec->name != 
# 7264 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 7264 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               )
    {
      if (strcmp (filespec->name, "*") == 0)
 filespec->name = 
# 7267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 7267 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     ;
      else if (!(strpbrk ((filespec->name), "?*[") != 
# 7268 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 7268 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ))
 lang_has_input_file = 1;
    }

  new_stmt = (lang_wild_statement_type *) new_statement (lang_wild_statement_enum, sizeof (lang_wild_statement_type), stat_ptr);
  new_stmt->filename = 
# 7273 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 7273 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ;
  new_stmt->filenames_sorted = 0;
  new_stmt->section_flag_list = 
# 7275 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 7275 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   ;
  new_stmt->exclude_name_list = 
# 7276 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 7276 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   ;
  if (filespec != 
# 7277 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 7277 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     )
    {
      new_stmt->filename = filespec->name;
      new_stmt->filenames_sorted = filespec->sorted == by_name;
      new_stmt->section_flag_list = filespec->section_flag_list;
      new_stmt->exclude_name_list = filespec->exclude_name_list;
    }
  new_stmt->section_list = section_list;
  new_stmt->keep_sections = keep_sections;
  lang_list_init (&new_stmt->children);
  analyze_walk_wild_section_handler (new_stmt);
}

void
lang_section_start (const char *name, etree_type *address,
      const segment_type *segment)
{
  lang_address_statement_type *ad;

  ad = (lang_address_statement_type *) new_statement (lang_address_statement_enum, sizeof (lang_address_statement_type), stat_ptr);
  ad->section_name = name;
  ad->address = address;
  ad->segment = segment;
}






void
lang_add_entry (const char *name, bfd_boolean cmdline)
{
  if (entry_symbol.name == 
# 7310 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                          ((void *)0)
      
# 7311 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     || cmdline
      || !entry_from_cmdline)
    {
      entry_symbol.name = name;
      entry_from_cmdline = cmdline;
    }
}





void
lang_default_entry (const char *name)
{
  entry_symbol_default = name;
}

void
lang_add_target (const char *name)
{
  lang_target_statement_type *new_stmt;

  new_stmt = (lang_target_statement_type *) new_statement (lang_target_statement_enum, sizeof (lang_target_statement_type), stat_ptr);
  new_stmt->target = name;
}

void
lang_add_map (const char *name)
{
  while (*name)
    {
      switch (*name)
 {
 case 'F':
   map_option_f = 1;
   break;
 }
      name++;
    }
}

void
lang_add_fill (fill_type *fill)
{
  lang_fill_statement_type *new_stmt;

  new_stmt = (lang_fill_statement_type *) new_statement (lang_fill_statement_enum, sizeof (lang_fill_statement_type), stat_ptr);
  new_stmt->fill = fill;
}

void
lang_add_data (int type, union etree_union *exp)
{
  lang_data_statement_type *new_stmt;

  new_stmt = (lang_data_statement_type *) new_statement (lang_data_statement_enum, sizeof (lang_data_statement_type), stat_ptr);
  new_stmt->exp = exp;
  new_stmt->type = type;
}
# 7379 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
void
lang_add_reloc (bfd_reloc_code_real_type reloc,
  reloc_howto_type *howto,
  asection *section,
  const char *name,
  union etree_union *addend)
{
  lang_reloc_statement_type *p = (lang_reloc_statement_type *) new_statement (lang_reloc_statement_enum, sizeof (lang_reloc_statement_type), stat_ptr);

  p->reloc = reloc;
  p->howto = howto;
  p->section = section;
  p->name = name;
  p->addend_exp = addend;

  p->addend_value = 0;
  p->output_section = 
# 7395 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 7395 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         ;
  p->output_offset = 0;
}

lang_assignment_statement_type *
lang_add_assignment (etree_type *exp)
{
  lang_assignment_statement_type *new_stmt;

  new_stmt = (lang_assignment_statement_type *) new_statement (lang_assignment_statement_enum, sizeof (lang_assignment_statement_type), stat_ptr);
  new_stmt->exp = exp;
  return new_stmt;
}

void
lang_add_attribute (enum statement_enum attribute)
{
  new_statement (attribute, sizeof (lang_statement_header_type), stat_ptr);
}

void
lang_startup (const char *name)
{
  if (first_file->filename != 
# 7418 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                             ((void *)0)
# 7418 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 )
    {
      einfo (gettext ("%P%F: multiple STARTUP files\n"));
    }
  first_file->filename = name;
  first_file->local_sym_name = name;
  first_file->flags.real = 1;
}

void
lang_float (bfd_boolean maybe)
{
  lang_float_flag = maybe;
}
# 7445 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
static void
lang_get_regions (lang_memory_region_type **region,
    lang_memory_region_type **lma_region,
    const char *memspec,
    const char *lma_memspec,
    bfd_boolean have_lma,
    bfd_boolean have_vma)
{
  *lma_region = lang_memory_region_lookup (lma_memspec, 0);




  if (lma_memspec != 
# 7458 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
      
# 7459 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && !have_vma
      && strcmp (memspec, "*default*") == 0)
    *region = *lma_region;
  else
    *region = lang_memory_region_lookup (memspec, 0);

  if (have_lma && lma_memspec != 0)
    einfo (gettext ("%X%P:%S: section has both a load address and a load region\n"),
    
# 7467 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
   ((void *)0)
# 7467 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
       );
}

void
lang_leave_output_section_statement (fill_type *fill, const char *memspec,
         lang_output_section_phdr_list *phdrs,
         const char *lma_memspec)
{
  lang_get_regions (&current_section->region,
      &current_section->lma_region,
      memspec, lma_memspec,
      current_section->load_base != 
# 7478 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 7478 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       ,
      current_section->addr_tree != 
# 7479 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 7479 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       );

  current_section->fill = fill;
  current_section->phdrs = phdrs;
  pop_stat_ptr ();
}

void
lang_statement_append (lang_statement_list_type *list,
         lang_statement_union_type *element,
         lang_statement_union_type **field)
{
  *(list->tail) = element;
  list->tail = field;
}



void
lang_add_output_format (const char *format,
   const char *big,
   const char *little,
   int from_script)
{
  if (output_target == 
# 7503 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0) 
# 7503 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           || !from_script)
    {
      if (command_line.endian == ENDIAN_BIG
   && big != 
# 7506 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 7506 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                )
 format = big;
      else if (command_line.endian == ENDIAN_LITTLE
        && little != 
# 7509 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 7509 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
 format = little;

      output_target = format;
    }
}

void
lang_add_insert (const char *where, int is_before)
{
  lang_insert_statement_type *new_stmt;

  new_stmt = (lang_insert_statement_type *) new_statement (lang_insert_statement_enum, sizeof (lang_insert_statement_type), stat_ptr);
  new_stmt->where = where;
  new_stmt->is_before = is_before;
  saved_script_handle = previous_script_handle;
}




void
lang_enter_group (void)
{
  lang_group_statement_type *g;

  g = (lang_group_statement_type *) new_statement (lang_group_statement_enum, sizeof (lang_group_statement_type), stat_ptr);
  lang_list_init (&g->children);
  push_stat_ptr (&g->children);
}






void
lang_leave_group (void)
{
  pop_stat_ptr ();
}




void
lang_new_phdr (const char *name,
        etree_type *type,
        bfd_boolean filehdr,
        bfd_boolean phdrs,
        etree_type *at,
        etree_type *flags)
{
  struct lang_phdr *n, **pp;
  bfd_boolean hdrs;

  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
  n->next = 
# 7566 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 7566 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;
  n->name = name;
  n->type = exp_get_value_int (type, 0, "program header type");
  n->filehdr = filehdr;
  n->phdrs = phdrs;
  n->at = at;
  n->flags = flags;

  hdrs = n->type == 1 && (phdrs || filehdr);

  for (pp = &lang_phdr_list; *pp != 
# 7576 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                   ((void *)0)
# 7576 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                       ; pp = &(*pp)->next)
    if (hdrs
 && (*pp)->type == 1
 && !((*pp)->filehdr || (*pp)->phdrs))
      {
 einfo (gettext ("%X%P:%S: PHDRS and FILEHDR are not supported" " when prior PT_LOAD headers lack them\n")
                                             , 
# 7582 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                              ((void *)0)
# 7582 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                  );
 hdrs = 0;
      }

  *pp = n;
}




static void
lang_record_phdrs (void)
{
  unsigned int alc;
  asection **secs;
  lang_output_section_phdr_list *last;
  struct lang_phdr *l;
  lang_output_section_statement_type *os;

  alc = 10;
  secs = (asection **) xmalloc (alc * sizeof (asection *));
  last = 
# 7603 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
        ((void *)0)
# 7603 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
            ;

  for (l = lang_phdr_list; l != 
# 7605 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 7605 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   ; l = l->next)
    {
      unsigned int c;
      flagword flags;
      bfd_vma at;

      c = 0;
      for (os = &lang_output_section_statement.head->output_section_statement;
    os != 
# 7613 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
         ((void *)0)
# 7613 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
             ;
    os = os->next)
 {
   lang_output_section_phdr_list *pl;

   if (os->constraint < 0)
     continue;

   pl = os->phdrs;
   if (pl != 
# 7622 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 7622 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                )
     last = pl;
   else
     {
       if (os->sectype == noload_section
    || os->bfd_section == 
# 7627 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
    
# 7628 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
   || (os->bfd_section->flags & 0x001) == 0)
  continue;


       if (l->type == 3)
  continue;

       if (last == 
# 7635 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 7635 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
  {
    lang_output_section_statement_type *tmp_os;
# 7647 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
    for (tmp_os = os; tmp_os; tmp_os = tmp_os->next)
      if (tmp_os->phdrs)
        {
   last = tmp_os->phdrs;
   break;
        }
    if (last == 
# 7653 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 7653 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
      einfo (gettext ("%F%P: no sections assigned to phdrs\n"));
  }
       pl = last;
     }

   if (os->bfd_section == 
# 7659 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 7659 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             )
     continue;

   for (; pl != 
# 7662 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 7662 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   ; pl = pl->next)
     {
       if (strcmp (pl->name, l->name) == 0)
  {
    if (c >= alc)
      {
        alc *= 2;
        secs = (asection **) xrealloc (secs,
           alc * sizeof (asection *));
      }
    secs[c] = os->bfd_section;
    ++c;
    pl->used = 1;
  }
     }
 }

      if (l->flags == 
# 7679 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 7679 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
 flags = 0;
      else
 flags = exp_get_vma (l->flags, 0, "phdr flags");

      if (l->at == 
# 7684 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 7684 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      )
 at = 0;
      else
 at = exp_get_vma (l->at, 0, "phdr load address");

      if (!bfd_record_phdr (link_info.output_bfd, l->type,
       l->flags != 
# 7690 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0)
# 7690 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      , flags, l->at != 
# 7690 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 7690 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ,
       at, l->filehdr, l->phdrs, c, secs))
 einfo (gettext ("%F%P: bfd_record_phdr failed: %E\n"));
    }

  free (secs);


  for (os = &lang_output_section_statement.head->output_section_statement;
       os != 
# 7699 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
            ((void *)0)
# 7699 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                ;
       os = os->next)
    {
      lang_output_section_phdr_list *pl;

      if (os->constraint < 0
   || os->bfd_section == 
# 7705 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                        ((void *)0)
# 7705 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                            )
 continue;

      for (pl = os->phdrs;
    pl != 
# 7709 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
         ((void *)0)
# 7709 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
             ;
    pl = pl->next)
 if (!pl->used && strcmp (pl->name, "NONE") != 0)
   einfo (gettext ("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
   os->name, pl->name);
    }
}



void
lang_add_nocrossref (lang_nocrossref_type *l)
{
  struct lang_nocrossrefs *n;

  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
  n->next = nocrossref_list;
  n->list = l;
  n->onlyfirst = 0;
  nocrossref_list = n;


  link_info.notice_all = 1;
}



void
lang_add_nocrossref_to (lang_nocrossref_type *l)
{
  lang_add_nocrossref (l);
  nocrossref_list->onlyfirst = 1;
}




static etree_type *overlay_vma;

static etree_type *overlay_subalign;


static etree_type *overlay_max;



struct overlay_list {
  struct overlay_list *next;
  lang_output_section_statement_type *os;
};

static struct overlay_list *overlay_list;



void
lang_enter_overlay (etree_type *vma_expr, etree_type *subalign)
{

  do { if (!(overlay_vma == 
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0) 
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && overlay_subalign == 
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0) 
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 && overlay_max == 
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 7768 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 )) info_assert("/doner/binutils/binutils-7a31b38/ld/ldlang.c",7768); } while (0)

                          ;

  overlay_vma = vma_expr;
  overlay_subalign = subalign;
}





void
lang_enter_overlay_section (const char *name)
{
  struct overlay_list *n;
  etree_type *size;

  lang_enter_output_section_statement (name, overlay_vma, overlay_section,
           0, overlay_subalign, 0, 0, 0);




  if (overlay_list == 
# 7792 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 7792 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
    overlay_vma = exp_nameop (323, name);


  n = (struct overlay_list *) xmalloc (sizeof *n);
  n->os = current_section;
  n->next = overlay_list;
  overlay_list = n;

  size = exp_nameop (321, name);


  if (overlay_max == 
# 7804 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                    ((void *)0)
# 7804 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                        )
    overlay_max = size;
  else
    overlay_max = exp_binop (325, overlay_max, size);
}




void
lang_leave_overlay_section (fill_type *fill,
       lang_output_section_phdr_list *phdrs)
{
  const char *name;
  char *clean, *s2;
  const char *s1;
  char *buf;

  name = current_section->name;





  lang_leave_output_section_statement (fill, "*default*", phdrs, 0);



  clean = (char *) xmalloc (strlen (name) + 1);
  s2 = clean;
  for (s1 = name; *s1 != '\0'; s1++)
    if ((_sch_istable[(*s1) & 0xff] & (unsigned short)(_sch_isalnum)) || *s1 == '_')
      *s2++ = *s1;
  *s2 = '\0';

  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_start_");
  sprintf (buf, "__load_start_%s", clean);
  lang_add_assignment (exp_provide (buf,
        exp_nameop (324, name),
        0));

  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_stop_");
  sprintf (buf, "__load_stop_%s", clean);
  lang_add_assignment (exp_provide (buf,
        exp_binop ('+',
            exp_nameop (324, name),
            exp_nameop (321, name)),
        0));

  free (clean);
}




void
lang_leave_overlay (etree_type *lma_expr,
      int nocrossrefs,
      fill_type *fill,
      const char *memspec,
      lang_output_section_phdr_list *phdrs,
      const char *lma_memspec)
{
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
  struct overlay_list *l;
  lang_nocrossref_type *nocrossref;

  lang_get_regions (&region, &lma_region,
      memspec, lma_memspec,
      lma_expr != 
# 7874 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0)
# 7874 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                     , 0);

  nocrossref = 
# 7876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
              ((void *)0)
# 7876 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  ;



  if (overlay_list != 
# 7880 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 7880 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
    {
      overlay_list->os->update_dot = 1;
      overlay_list->os->update_dot_tree
 = exp_assign (".", exp_binop ('+', overlay_vma, overlay_max), 0);
    }

  l = overlay_list;
  while (l != 
# 7888 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 7888 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    {
      struct overlay_list *next;

      if (fill != 
# 7892 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                 ((void *)0) 
# 7892 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                      && l->os->fill == 
# 7892 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 7892 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            )
 l->os->fill = fill;

      l->os->region = region;
      l->os->lma_region = lma_region;





      if (l->next == 0)
 {
   l->os->load_base = lma_expr;
   l->os->sectype = normal_section;
 }
      if (phdrs != 
# 7907 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                  ((void *)0) 
# 7907 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       && l->os->phdrs == 
# 7907 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 7907 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              )
 l->os->phdrs = phdrs;

      if (nocrossrefs)
 {
   lang_nocrossref_type *nc;

   nc = (lang_nocrossref_type *) xmalloc (sizeof *nc);
   nc->name = l->os->name;
   nc->next = nocrossref;
   nocrossref = nc;
 }

      next = l->next;
      free (l);
      l = next;
    }

  if (nocrossref != 
# 7925 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                   ((void *)0)
# 7925 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                       )
    lang_add_nocrossref (nocrossref);

  overlay_vma = 
# 7928 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 7928 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   ;
  overlay_list = 
# 7929 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 7929 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    ;
  overlay_max = 
# 7930 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 7930 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   ;
}







static struct bfd_elf_version_expr *
lang_vers_match (struct bfd_elf_version_expr_head *head,
   struct bfd_elf_version_expr *prev,
   const char *sym)
{
  const char *c_sym;
  const char *cxx_sym = sym;
  const char *java_sym = sym;
  struct bfd_elf_version_expr *expr = 
# 7947 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 7947 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         ;
  enum demangling_styles curr_style;

  curr_style = current_demangling_style;
  cplus_demangle_set_style (no_demangling);
  c_sym = bfd_demangle (link_info.output_bfd, sym, 0);
  if (!c_sym)
    c_sym = sym;
  cplus_demangle_set_style (curr_style);

  if (head->mask & 2)
    {
      cxx_sym = bfd_demangle (link_info.output_bfd, sym,
         (1 << 0) | (1 << 1));
      if (!cxx_sym)
 cxx_sym = sym;
    }
  if (head->mask & 4)
    {
      java_sym = bfd_demangle (link_info.output_bfd, sym, (1 << 2));
      if (!java_sym)
 java_sym = sym;
    }

  if (head->htab && (prev == 
# 7971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                            ((void *)0) 
# 7971 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                 || prev->literal))
    {
      struct bfd_elf_version_expr e;

      switch (prev ? prev->mask : 0)
 {
 case 0:
   if (head->mask & 1)
     {
       e.pattern = c_sym;
       expr = (struct bfd_elf_version_expr *)
    htab_find ((htab_t) head->htab, &e);
       while (expr && strcmp (expr->pattern, c_sym) == 0)
  if (expr->mask == 1)
    goto out_ret;
  else
    expr = expr->next;
     }

 case 1:
   if (head->mask & 2)
     {
       e.pattern = cxx_sym;
       expr = (struct bfd_elf_version_expr *)
    htab_find ((htab_t) head->htab, &e);
       while (expr && strcmp (expr->pattern, cxx_sym) == 0)
  if (expr->mask == 2)
    goto out_ret;
  else
    expr = expr->next;
     }

 case 2:
   if (head->mask & 4)
     {
       e.pattern = java_sym;
       expr = (struct bfd_elf_version_expr *)
    htab_find ((htab_t) head->htab, &e);
       while (expr && strcmp (expr->pattern, java_sym) == 0)
  if (expr->mask == 4)
    goto out_ret;
  else
    expr = expr->next;
     }

 default:
   break;
 }
    }


  if (prev == 
# 8022 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0) 
# 8022 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  || prev->literal)
    expr = head->remaining;
  else
    expr = prev->next;
  for (; expr; expr = expr->next)
    {
      const char *s;

      if (!expr->pattern)
 continue;

      if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
 break;

      if (expr->mask == 4)
 s = java_sym;
      else if (expr->mask == 2)
 s = cxx_sym;
      else
 s = c_sym;
      if (fnmatch (expr->pattern, s, 0) == 0)
 break;
    }

 out_ret:
  if (c_sym != sym)
    free ((char *) c_sym);
  if (cxx_sym != sym)
    free ((char *) cxx_sym);
  if (java_sym != sym)
    free ((char *) java_sym);
  return expr;
}




static const char *
realsymbol (const char *pattern)
{
  const char *p;
  bfd_boolean changed = 0, backslash = 0;
  char *s, *symbol = (char *) xmalloc (strlen (pattern) + 1);

  for (p = pattern, s = symbol; *p != '\0'; ++p)
    {


      if (backslash)
 {

   *(s - 1) = *p;
   backslash = 0;
   changed = 1;
 }
      else
 {
   if (*p == '?' || *p == '*' || *p == '[')
     {
       free (symbol);
       return 
# 8082 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 8082 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ;
     }

   *s++ = *p;
   backslash = *p == '\\';
 }
    }

  if (changed)
    {
      *s = '\0';
      return symbol;
    }
  else
    {
      free (symbol);
      return pattern;
    }
}





struct bfd_elf_version_expr *
lang_new_vers_pattern (struct bfd_elf_version_expr *orig,
         const char *new_name,
         const char *lang,
         bfd_boolean literal_p)
{
  struct bfd_elf_version_expr *ret;

  ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);
  ret->next = orig;
  ret->symver = 0;
  ret->script = 0;
  ret->literal = 1;
  ret->pattern = literal_p ? new_name : realsymbol (new_name);
  if (ret->pattern == 
# 8120 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                     ((void *)0)
# 8120 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                         )
    {
      ret->pattern = new_name;
      ret->literal = 0;
    }

  if (lang == 
# 8126 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0) 
# 8126 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                  || strcasecmp (lang, "C") == 0)
    ret->mask = 1;
  else if (strcasecmp (lang, "C++") == 0)
    ret->mask = 2;
  else if (strcasecmp (lang, "Java") == 0)
    ret->mask = 4;
  else
    {
      einfo (gettext ("%X%P: unknown language `%s' in version information\n"),
      lang);
      ret->mask = 1;
    }

  return ldemul_new_vers_pattern (ret);
}




struct bfd_elf_version_tree *
lang_new_vers_node (struct bfd_elf_version_expr *globals,
      struct bfd_elf_version_expr *locals)
{
  struct bfd_elf_version_tree *ret;

  ret = (struct bfd_elf_version_tree *) xcalloc (1, sizeof *ret);
  ret->globals.list = globals;
  ret->locals.list = locals;
  ret->match = lang_vers_match;
  ret->name_indx = (unsigned int) -1;
  return ret;
}



static int version_index;

static hashval_t
version_expr_head_hash (const void *p)
{
  const struct bfd_elf_version_expr *e =
      (const struct bfd_elf_version_expr *) p;

  return htab_hash_string (e->pattern);
}

static int
version_expr_head_eq (const void *p1, const void *p2)
{
  const struct bfd_elf_version_expr *e1 =
      (const struct bfd_elf_version_expr *) p1;
  const struct bfd_elf_version_expr *e2 =
      (const struct bfd_elf_version_expr *) p2;

  return strcmp (e1->pattern, e2->pattern) == 0;
}

static void
lang_finalize_version_expr_head (struct bfd_elf_version_expr_head *head)
{
  size_t count = 0;
  struct bfd_elf_version_expr *e, *next;
  struct bfd_elf_version_expr **list_loc, **remaining_loc;

  for (e = head->list; e; e = e->next)
    {
      if (e->literal)
 count++;
      head->mask |= e->mask;
    }

  if (count)
    {
      head->htab = htab_create (count * 2, version_expr_head_hash,
    version_expr_head_eq, 
# 8200 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                         ((void *)0)
# 8200 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                             );
      list_loc = &head->list;
      remaining_loc = &head->remaining;
      for (e = head->list; e; e = next)
 {
   next = e->next;
   if (!e->literal)
     {
       *remaining_loc = e;
       remaining_loc = &e->next;
     }
   else
     {
       void **loc = htab_find_slot ((htab_t) head->htab, e, INSERT);

       if (*loc)
  {
    struct bfd_elf_version_expr *e1, *last;

    e1 = (struct bfd_elf_version_expr *) *loc;
    last = 
# 8220 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
          ((void *)0)
# 8220 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
              ;
    do
      {
        if (e1->mask == e->mask)
   {
     last = 
# 8225 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
           ((void *)0)
# 8225 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
               ;
     break;
   }
        last = e1;
        e1 = e1->next;
      }
    while (e1 && strcmp (e1->pattern, e->pattern) == 0);

    if (last == 
# 8233 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
               ((void *)0)
# 8233 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                   )
      {




        free (e);
      }
    else
      {
        e->next = last->next;
        last->next = e;
      }
  }
       else
  {
    *loc = e;
    *list_loc = e;
    list_loc = &e->next;
  }
     }
 }
      *remaining_loc = 
# 8255 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                      ((void *)0)
# 8255 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                          ;
      *list_loc = head->remaining;
    }
  else
    head->remaining = head->list;
}




void
lang_register_vers_node (const char *name,
    struct bfd_elf_version_tree *version,
    struct bfd_elf_version_deps *deps)
{
  struct bfd_elf_version_tree *t, **pp;
  struct bfd_elf_version_expr *e1;

  if (name == 
# 8273 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 8273 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 )
    name = "";

  if (link_info.version_info != 
# 8276 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
      
# 8277 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
     && (name[0] == '\0' || link_info.version_info->name[0] == '\0'))
    {
      einfo (gettext ("%X%P: anonymous version tag cannot be combined" " with other version tags\n")
                                     );
      free (version);
      return;
    }


  for (t = link_info.version_info; t != 
# 8286 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 8286 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           ; t = t->next)
    if (strcmp (t->name, name) == 0)
      einfo (gettext ("%X%P: duplicate version tag `%s'\n"), name);

  lang_finalize_version_expr_head (&version->globals);
  lang_finalize_version_expr_head (&version->locals);




  for (e1 = version->globals.list; e1 != 
# 8296 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 8296 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; e1 = e1->next)
    {
      for (t = link_info.version_info; t != 
# 8298 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 8298 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ; t = t->next)
 {
   struct bfd_elf_version_expr *e2;

   if (t->locals.htab && e1->literal)
     {
       e2 = (struct bfd_elf_version_expr *)
    htab_find ((htab_t) t->locals.htab, e1);
       while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
  {
    if (e1->mask == e2->mask)
      einfo (gettext ("%X%P: duplicate expression `%s'" " in version information\n")
                                    , e1->pattern);
    e2 = e2->next;
  }
     }
   else if (!e1->literal)
     for (e2 = t->locals.remaining; e2 != 
# 8315 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
# 8315 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                             ; e2 = e2->next)
       if (strcmp (e1->pattern, e2->pattern) == 0
    && e1->mask == e2->mask)
  einfo (gettext ("%X%P: duplicate expression `%s'" " in version information\n")
                                , e1->pattern);
 }
    }

  for (e1 = version->locals.list; e1 != 
# 8323 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 8323 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           ; e1 = e1->next)
    {
      for (t = link_info.version_info; t != 
# 8325 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 8325 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ; t = t->next)
 {
   struct bfd_elf_version_expr *e2;

   if (t->globals.htab && e1->literal)
     {
       e2 = (struct bfd_elf_version_expr *)
    htab_find ((htab_t) t->globals.htab, e1);
       while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
  {
    if (e1->mask == e2->mask)
      einfo (gettext ("%X%P: duplicate expression `%s'" " in version information\n")
                                    ,
      e1->pattern);
    e2 = e2->next;
  }
     }
   else if (!e1->literal)
     for (e2 = t->globals.remaining; e2 != 
# 8343 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 8343 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              ; e2 = e2->next)
       if (strcmp (e1->pattern, e2->pattern) == 0
    && e1->mask == e2->mask)
  einfo (gettext ("%X%P: duplicate expression `%s'" " in version information\n")
                                , e1->pattern);
 }
    }

  version->deps = deps;
  version->name = name;
  if (name[0] != '\0')
    {
      ++version_index;
      version->vernum = version_index;
    }
  else
    version->vernum = 0;

  for (pp = &link_info.version_info; *pp != 
# 8361 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                           ((void *)0)
# 8361 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                               ; pp = &(*pp)->next)
    ;
  *pp = version;
}



struct bfd_elf_version_deps *
lang_add_vers_depend (struct bfd_elf_version_deps *list, const char *name)
{
  struct bfd_elf_version_deps *ret;
  struct bfd_elf_version_tree *t;

  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
  ret->next = list;

  for (t = link_info.version_info; t != 
# 8377 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                       ((void *)0)
# 8377 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                           ; t = t->next)
    {
      if (strcmp (t->name, name) == 0)
 {
   ret->version_needed = t;
   return ret;
 }
    }

  einfo (gettext ("%X%P: unable to find version dependency `%s'\n"), name);

  ret->version_needed = 
# 8388 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                       ((void *)0)
# 8388 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                           ;
  return ret;
}

static void
lang_do_version_exports_section (void)
{
  struct bfd_elf_version_expr *greg = 
# 8395 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                     ((void *)0)
# 8395 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                         , *lreg;

  lang_input_statement_type *is; for (is = (lang_input_statement_type *) file_chain.head; is != (lang_input_statement_type *) 
# 8397 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
 ((void *)0)
# 8397 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
 ; is = (lang_input_statement_type *) is->next)
    {
      asection *sec = bfd_get_section_by_name (is->the_bfd, ".exports");
      char *contents, *p;
      bfd_size_type len;

      if (sec == 
# 8403 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                ((void *)0)
# 8403 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                    )
 continue;

      len = sec->size;
      contents = (char *) xmalloc (len);
      if (!bfd_get_section_contents (is->the_bfd, sec, contents, 0, len))
 einfo (gettext ("%X%P: unable to read .exports section contents\n"), sec);

      p = contents;
      while (p < contents + len)
 {
   greg = lang_new_vers_pattern (greg, p, 
# 8414 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                         ((void *)0)
# 8414 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                             , 0);
   p = strchr (p, '\0') + 1;
 }




      sec->flags |= 0x8000 | 0x200000;
    }

  lreg = lang_new_vers_pattern (
# 8424 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                               ((void *)0)
# 8424 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                   , "*", 
# 8424 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                          ((void *)0)
# 8424 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                              , 0);
  lang_register_vers_node (command_line.version_exports_section,
      lang_new_vers_node (greg, lreg), 
# 8426 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                      ((void *)0)
# 8426 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                          );
}



static void
lang_do_memory_regions (void)
{
  lang_memory_region_type *r = lang_memory_region_list;

  for (; r != 
# 8436 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
             ((void *)0)
# 8436 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                 ; r = r->next)
    {
      if (r->origin_exp)
 {
   exp_fold_tree_no_dot (r->origin_exp);
   if (expld.result.valid_p)
     {
       r->origin = expld.result.value;
       r->current = r->origin;
     }
   else
     einfo (gettext ("%F%P: invalid origin for memory region %s\n"),
     r->name_list.name);
 }
      if (r->length_exp)
 {
   exp_fold_tree_no_dot (r->length_exp);
   if (expld.result.valid_p)
     r->length = expld.result.value;
   else
     einfo (gettext ("%F%P: invalid length for memory region %s\n"),
     r->name_list.name);
 }
    }
}

void
lang_add_unique (const char *name)
{
  struct unique_sections *ent;

  for (ent = unique_section_list; ent; ent = ent->next)
    if (strcmp (ent->name, name) == 0)
      return;

  ent = (struct unique_sections *) xmalloc (sizeof *ent);
  ent->name = xstrdup (name);
  ent->next = unique_section_list;
  unique_section_list = ent;
}



void
lang_append_dynamic_list (struct bfd_elf_version_expr *dynamic)
{
  if (link_info.dynamic_list)
    {
      struct bfd_elf_version_expr *tail;
      for (tail = dynamic; tail->next != 
# 8485 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 8485 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ; tail = tail->next)
 ;
      tail->next = link_info.dynamic_list->head.list;
      link_info.dynamic_list->head.list = dynamic;
    }
  else
    {
      struct bfd_elf_dynamic_list *d;

      d = (struct bfd_elf_dynamic_list *) xcalloc (1, sizeof *d);
      d->head.list = dynamic;
      d->match = lang_vers_match;
      link_info.dynamic_list = d;
    }
}




void
lang_append_dynamic_list_cpp_typeinfo (void)
{
  const char *symbols[] =
    {
      "typeinfo name for*",
      "typeinfo for*"
    };
  struct bfd_elf_version_expr *dynamic = 
# 8512 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 8512 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ;
  unsigned int i;

  for (i = 0; i < (sizeof (symbols) / sizeof ((symbols)[0])); i++)
    dynamic = lang_new_vers_pattern (dynamic, symbols [i], "C++",
         0);

  lang_append_dynamic_list (dynamic);
}




void
lang_append_dynamic_list_cpp_new (void)
{
  const char *symbols[] =
    {
      "operator new*",
      "operator delete*"
    };
  struct bfd_elf_version_expr *dynamic = 
# 8533 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                        ((void *)0)
# 8533 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                            ;
  unsigned int i;

  for (i = 0; i < (sizeof (symbols) / sizeof ((symbols)[0])); i++)
    dynamic = lang_new_vers_pattern (dynamic, symbols [i], "C++",
         0);

  lang_append_dynamic_list (dynamic);
}



void
lang_ld_feature (char *str)
{
  char *p, *q;

  p = str;
  while (*p)
    {
      char sep;
      while (*p == ',' || (_sch_istable[(*p) & 0xff] & (unsigned short)(_sch_isspace)))
 ++p;
      if (!*p)
 break;
      q = p + 1;
      while (*q && *q != ',' && !(_sch_istable[(*q) & 0xff] & (unsigned short)(_sch_isspace)))
 ++q;
      sep = *q;
      *q = 0;
      if (strcasecmp (p, "SANE_EXPR") == 0)
 config.sane_expr = 1;
      else
 einfo (gettext ("%X%P: unknown feature `%s'\n"), p);
      *q = sep;
      p = q;
    }
}



static void
lang_print_memory_size (bfd_vma sz)
{
  if ((sz & 0x3fffffff) == 0)
    printf ("%10" "l" "u GB", sz >> 30);
  else if ((sz & 0xfffff) == 0)
    printf ("%10" "l" "u MB", sz >> 20);
  else if ((sz & 0x3ff) == 0)
    printf ("%10" "l" "u KB", sz >> 10);
  else
    printf (" %10" "l" "u B", sz);
}



void
lang_print_memory_usage (void)
{
  lang_memory_region_type *r;

  printf ("Memory region         Used Size  Region Size  %%age Used\n");
  for (r = lang_memory_region_list; r->next != 
# 8595 "/doner/binutils/binutils-7a31b38/ld/ldlang.c" 3 4
                                              ((void *)0)
# 8595 "/doner/binutils/binutils-7a31b38/ld/ldlang.c"
                                                  ; r = r->next)
    {
      bfd_vma used_length = r->current - r->origin;
      double percent;

      printf ("%16s: ",r->name_list.name);
      lang_print_memory_size (used_length);
      lang_print_memory_size ((bfd_vma) r->length);

      percent = used_length * 100.0 / r->length;

      printf ("    %6.2f%%\n", percent);
    }
}
