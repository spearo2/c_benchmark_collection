/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 46 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef unsigned long size_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 38 "/usr/include/sched.h"
typedef __pid_t pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_1 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_1 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_3 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_2 {
   unsigned long long __wseq ;
   struct __anonstruct_3 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_5 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_4 {
   unsigned long long __g1_start ;
   struct __anonstruct_5 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_2  ;
   unsigned long long __wseq ;
   struct __anonstruct_3 __wseq32 ;
   union __anonunion_4  ;
   unsigned long long __g1_start ;
   struct __anonstruct_5 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_6 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_6 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_7 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_7 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_8 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_8 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_9 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_9 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_10 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_10 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_barrierattr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/pthread.h"
enum __anonenum__14 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 43
enum __anonenum__15 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 65
enum __anonenum__16 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 77
enum __anonenum__17 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 100
enum __anonenum__18 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 120
enum __anonenum__19 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 130
enum __anonenum__20 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 140
enum __anonenum__21 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 155 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 164
enum __anonenum__22 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 171
enum __anonenum__23 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 501 "/usr/include/pthread.h"
struct __anonstruct_25 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 499 "/usr/include/pthread.h"
struct __anonstruct_24 {
   struct __anonstruct_25 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 507 "/usr/include/pthread.h"
typedef struct __anonstruct_24 __pthread_unwind_buf_t;
#line 516 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 718
struct __jmp_buf_tag ;
#line 74 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__26 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__26 idtype_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef float _Float32;
#line 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef double _Float64;
#line 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef double _Float32x;
#line 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef long double _Float64x;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_27 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_27 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_28 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_28 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_29 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_29 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_30 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_30 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_31 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_31 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__32 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__33 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
#line 533
enum __anonenum__34 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__35 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 14 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h"
typedef __builtin_va_list va_list;
#line 32 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_37 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_36 {
   int __count ;
   union __anonunion_37 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_36 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list___0;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__38 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 120 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 121 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 122 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 123 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int8_t OPJ_INT8;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint8_t OPJ_UINT8;
#line 129 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 130 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 132 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 133 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 134 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 136 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 139 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 282
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 287 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 293
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 298 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 303
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 310 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 315
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 323 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 328
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 335 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 349 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 365 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 393 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 544 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 552 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 612 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 618 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 637 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_read_fn)(void * , OPJ_SIZE_T  , void * );
#line 643 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_write_fn)(void * , OPJ_SIZE_T  , void * );
#line 649 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_OFF_T (*opj_stream_skip_fn)(OPJ_OFF_T  , void * );
#line 655 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_BOOL (*opj_stream_seek_fn)(OPJ_OFF_T  , void * );
#line 661 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void (*opj_stream_free_user_data_fn)(void * );
#line 666 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 677 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 704 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 709 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 728 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 734 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 753 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 766 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 775 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 782 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 789 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 795 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 806 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 811 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 846 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 851 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 898 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 906 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 936 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 941 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 957 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 962 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 986 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 992 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 1000 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 1005 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 1032 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 1037 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1060 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 1073 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_jp2_metadata {
   OPJ_INT32 not_used ;
};
#line 1077 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_metadata opj_jp2_metadata_t;
#line 1083 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_jp2_index {
   OPJ_INT32 not_used ;
};
#line 1087 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_index opj_jp2_index_t;
#line 217 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_includes.h"
typedef unsigned int OPJ_BITFIELD;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_39 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_39 imaxdiv_t;
#line 35 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef long ptrdiff_t;
#line 19 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h"
struct __anonstruct_40 {
   long long __clang_max_align_nonce1 ;
   long double __clang_max_align_nonce2 ;
};
#line 24 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h"
typedef struct __anonstruct_40 max_align_t;
#line 50 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 71 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   opj_stream_free_user_data_fn m_free_user_data_fn ;
   OPJ_UINT64 m_user_data_length ;
   opj_stream_read_fn m_read_fn ;
   opj_stream_write_fn m_write_fn ;
   opj_stream_skip_fn m_skip_fn ;
   opj_stream_seek_fn m_seek_fn ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   OPJ_UINT32 m_status ;
};
#line 165 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
struct opj_mutex_t ;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_mutex_t opj_mutex_t;
#line 81
struct opj_cond_t ;
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_cond_t opj_cond_t;
#line 141
struct opj_thread_t ;
#line 141 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_thread_t opj_thread_t;
#line 146 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_thread_fn)(void * );
#line 167
struct opj_tls_t ;
#line 167 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_tls_t opj_tls_t;
#line 177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_tls_free_func)(void * );
#line 195
struct opj_thread_pool_t ;
#line 195 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_thread_pool_t opj_thread_pool_t;
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_job_fn)(void * , opj_tls_t * );
#line 41 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.h"
struct opj_cp ;
#line 125 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
enum J2K_STATUS {
    J2K_STATE_NONE = 0,
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_DATA = 128,
    J2K_STATE_EOC = 256,
    J2K_STATE_ERR = 32768
} ;
#line 138 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 143
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 148 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 153
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 157 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 164
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 167 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 172 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 182 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 210 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 217 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 229 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_BITFIELD m_is_irreversible ;
};
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 238 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_ppx_struct {
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 241 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_ppx_struct opj_ppx;
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 317 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 323
enum __anonenum__41 {
    RATE_DISTORTION_RATIO = 0,
    FIXED_DISTORTION_RATIO = 1,
    FIXED_LAYER = 2
} ;
#line 327 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum __anonenum__41 J2K_QUALITY_LAYER_ALLOCATION_STRATEGY;
#line 330 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   J2K_QUALITY_LAYER_ALLOCATION_STRATEGY m_quality_layer_alloc_strategy ;
   OPJ_BITFIELD m_tp_on ;
};
#line 344 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 346 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 352 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_42 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 358 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_42 m_specific_param ;
   OPJ_BOOL strict ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 467 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 470 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_numcomps_to_decode ;
   OPJ_UINT32 *m_comps_indices_to_decode ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 510 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 512 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_BOOL m_TLM ;
   OPJ_BOOL m_Ttlmi_is_byte ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
   OPJ_BOOL m_PLT ;
   OPJ_UINT32 m_reserved_bytes_for_PLT ;
   OPJ_UINT32 m_nb_comps ;
};
#line 565 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 569
struct opj_tcd ;
#line 578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_43 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 573 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_43 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   unsigned int dump_state ;
};
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
enum __anonenum__44 {
    JP2_STATE_NONE = 0,
    JP2_STATE_SIGNATURE = 1,
    JP2_STATE_FILE_TYPE = 2,
    JP2_STATE_HEADER = 4,
    JP2_STATE_CODESTREAM = 8,
    JP2_STATE_END_CODESTREAM = 16,
    JP2_STATE_UNKNOWN = 2147483647
} ;
#line 82 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef enum __anonenum__44 JP2_STATE;
#line 84
enum __anonenum__45 {
    JP2_IMG_STATE_NONE = 0,
    JP2_IMG_STATE_UNKNOWN = 2147483647
} ;
#line 88 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef enum __anonenum__45 JP2_IMG_STATE;
#line 93 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 95 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 100 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 103 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 108 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 111 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 123 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 135 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 140 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 144 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 198 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 202 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 204 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 end_of_byte_stream_counter ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
   OPJ_BYTE *lut_ctxno_zc_orient ;
   OPJ_BYTE backup[2] ;
};
#line 97 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 x ;
   OPJ_UINT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   opj_event_mgr_t *manager ;
};
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_BITFIELD term ;
};
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 72 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 77 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_size ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 90 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 94 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_seg_data_chunk {
   OPJ_BYTE *data ;
   OPJ_UINT32 len ;
};
#line 100 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg_data_chunk opj_tcd_seg_data_chunk_t;
#line 105 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_UINT32 len ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 117 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 120 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   opj_tcd_seg_t *segs ;
   opj_tcd_seg_data_chunk_t *chunks ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 Mb ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
   OPJ_UINT32 numchunks ;
   OPJ_UINT32 numchunksalloc ;
   OPJ_INT32 *decoded_data ;
};
#line 144 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 151 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
union __anonunion_46 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
   void *blocks ;
};
#line 147 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_46 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 159 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 162 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 173 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 176 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
};
#line 191 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 194 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_BOOL ownsData ;
   size_t data_size_needed ;
   size_t data_size ;
   OPJ_INT32 *data_win ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_SIZE_T numpix ;
};
#line 227 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 233 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_SIZE_T numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 242 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 247 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 250 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 256 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
   OPJ_BOOL *used_component ;
};
#line 290 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 296 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_marker_info {
   OPJ_BOOL need_PLT ;
   OPJ_UINT32 packet_count ;
   OPJ_UINT32 *p_packet_size ;
};
#line 306 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_marker_info opj_tcd_marker_info_t;
#line 179 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
typedef OPJ_UINT32 opj_flag_t;
#line 184 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t mqc ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_BOOL encoder ;
   OPJ_BOOL mustuse_cblkdatabuffer ;
   OPJ_BYTE *cblkdatabuffer ;
   OPJ_UINT32 cblkdatabuffersize ;
};
#line 210 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 60 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
struct opj_sparse_array_int32 ;
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
typedef struct opj_sparse_array_int32 opj_sparse_array_int32_t;
#line 48 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   void (*opj_decoder_set_strict_mode)(void * , OPJ_BOOL  ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
   OPJ_BOOL (*opj_set_decoded_components)(void * , OPJ_UINT32  , OPJ_UINT32 * , opj_event_mgr_t * ) ;
};
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encoder_set_extra_options)(void * , char const   * const  * , struct opj_event_mgr * ) ;
};
#line 44 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
union __anonunion_47 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_47 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 309 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_mutex_t {
   pthread_mutex_t mutex ;
};
#line 344 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_cond_t {
   pthread_cond_t cond ;
};
#line 383 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_thread_t {
   opj_thread_fn thread_fn ;
   void *user_data ;
   pthread_t thread ;
};
#line 498 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct __anonstruct_48 {
   int key ;
   void *value ;
   opj_tls_free_func opj_free_func ;
};
#line 502 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef struct __anonstruct_48 opj_tls_key_val_t;
#line 504 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_tls_t {
   opj_tls_key_val_t *key_val ;
   int key_val_count ;
};
#line 573 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct __anonstruct_49 {
   opj_job_fn job_fn ;
   void *user_data ;
};
#line 576 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef struct __anonstruct_49 opj_worker_thread_job_t;
#line 578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct __anonstruct_50 {
   opj_thread_pool_t *tp ;
   opj_thread_t *thread ;
   int marked_as_waiting ;
   opj_mutex_t *mutex ;
   opj_cond_t *cond ;
};
#line 585 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef struct __anonstruct_50 opj_worker_thread_t;
#line 587
enum __anonenum__51 {
    OPJWTS_OK = 0,
    OPJWTS_STOP = 1,
    OPJWTS_ERROR = 2
} ;
#line 591 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef enum __anonenum__51 opj_worker_thread_state;
#line 593 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_job_list_t {
   opj_worker_thread_job_t *job ;
   struct opj_job_list_t *next ;
};
#line 597 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef struct opj_job_list_t opj_job_list_t;
#line 599 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_worker_thread_list_t {
   opj_worker_thread_t *worker_thread ;
   struct opj_worker_thread_list_t *next ;
};
#line 603 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
typedef struct opj_worker_thread_list_t opj_worker_thread_list_t;
#line 605 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
struct opj_thread_pool_t {
   opj_worker_thread_t *worker_threads ;
   int worker_threads_count ;
   opj_cond_t *cond ;
   opj_mutex_t *mutex ;
   opj_worker_thread_state state ;
   opj_job_list_t *job_queue ;
   int pending_jobs_count ;
   opj_worker_thread_list_t *waiting_worker_thread_list ;
   int waiting_worker_thread_count ;
   opj_tls_t *tls ;
   int signaling_threshold ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__56 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___0 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___0 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___1 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___1 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___2 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___2 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 35 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
struct opj_sparse_array_int32 {
   OPJ_UINT32 width ;
   OPJ_UINT32 height ;
   OPJ_UINT32 block_width ;
   OPJ_UINT32 block_height ;
   OPJ_UINT32 block_count_hor ;
   OPJ_UINT32 block_count_ver ;
   OPJ_INT32 **data_blocks ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__56___3 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___3 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 365 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_poc___0 {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc___0 opj_poc_t___0;
#line 393 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_cparameters___0 {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t___0 POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 544 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters___0 opj_cparameters_t___0;
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tcp___0 {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t___0 pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 317 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tcp___0 opj_tcp_t___0;
#line 406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_63 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 358 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_cp___0 {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t___0 *tcps ;
   union __anonunion_63 m_specific_param ;
   OPJ_BOOL strict ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 467 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_cp___0 opj_cp_t___0;
#line 470 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_dec___0 {
   OPJ_UINT32 m_state ;
   opj_tcp_t___0 *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_numcomps_to_decode ;
   OPJ_UINT32 *m_comps_indices_to_decode ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 510 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec___0 opj_j2k_dec_t___0;
#line 578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_64 {
   opj_j2k_dec_t___0 m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 573 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k___0 {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_64 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t___0 m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd___0 *m_tcd ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   unsigned int dump_state ;
};
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k___0 opj_j2k_t___0;
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2___0 {
   opj_j2k_t___0 *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2___0 opj_jp2_t___0;
#line 204 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler___0 {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t___0 * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler___0 opj_jp2_header_handler_t___0;
#line 216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler___0 {
   OPJ_BYTE *(*handler)(opj_jp2_t___0 * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler___0 opj_jp2_img_header_writer_handler_t___0;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_iterator___0 {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t___0 poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 x ;
   OPJ_UINT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   opj_event_mgr_t *manager ;
};
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator___0 opj_pi_iterator_t___0;
#line 256 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd___0 {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t___0 *cp ;
   opj_tcp_t___0 *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
   OPJ_BOOL *used_component ;
};
#line 290 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd___0 opj_tcd_t___0;
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
struct opj_t2___0 {
   opj_image_t *image ;
   opj_cp_t___0 *cp ;
};
#line 60 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
typedef struct opj_t2___0 opj_t2_t___0;
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_compression___0 {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t___0 * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encoder_set_extra_options)(void * , char const   * const  * , struct opj_event_mgr * ) ;
};
#line 44 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
union __anonunion_68 {
   struct opj_decompression m_decompression ;
   struct opj_compression___0 m_compression ;
};
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_codec_private___0 {
   union __anonunion_68 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private___0 opj_codec_private_t___0;
#line 853 "/usr/include/math.h"
enum __anonenum__56___4 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___4 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 86 "/usr/include/malloc.h"
struct mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
#line 6 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 11 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 853 "/usr/include/math.h"
enum __anonenum__108 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__109 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
struct raw_comp_cparameters {
   int dx ;
   int dy ;
};
#line 48 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef struct raw_comp_cparameters raw_comp_cparameters_t;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   OPJ_BOOL rawSigned ;
   raw_comp_cparameters_t *rawComps ;
};
#line 66 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef void (*convert_32s_CXPX)(OPJ_INT32 * , OPJ_INT32 * const  * , OPJ_SIZE_T  );
#line 77 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef void (*convert_32s_PXCX)(OPJ_INT32 * const  * , OPJ_INT32 * , OPJ_SIZE_T  ,
                                 OPJ_INT32  );
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef void (*convert_XXx32s_C1R)(OPJ_BYTE * , OPJ_INT32 * , OPJ_SIZE_T  );
#line 84 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
typedef void (*convert_32sXXx_C1R)(OPJ_INT32 * , OPJ_BYTE * , OPJ_SIZE_T  );
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 68 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
typedef struct dircnt dircnt_t;
#line 71 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
   int flag ;
};
#line 82 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__56___5 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___5 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 89 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_112 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_113 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_114 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_115 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_116 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_117 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_118 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_119 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_120 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_121 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_122 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_123 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_124 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_125 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_112  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_113  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_114  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_115  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_116  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_117  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_118  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_119  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_120  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_121  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_122  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_123  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_124  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_125  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__56___6 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___6 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___7 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___7 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___8 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___8 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___9 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___9 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 197 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1347 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1350 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1371 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1395 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 853 "/usr/include/math.h"
enum __anonenum__56___10 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___10 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__126 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 853
enum __anonenum__56___11 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___11 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__147 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__150 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 138 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
struct dec_mel {
   OPJ_UINT8 *data ;
   OPJ_UINT64 tmp ;
   int bits ;
   int size ;
   OPJ_BOOL unstuff ;
   int k ;
   int num_runs ;
   OPJ_UINT64 runs ;
};
#line 150 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
typedef struct dec_mel dec_mel_t;
#line 364 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
struct rev_struct {
   OPJ_UINT8 *data ;
   OPJ_UINT64 tmp ;
   OPJ_UINT32 bits ;
   int size ;
   OPJ_BOOL unstuff ;
};
#line 372 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
typedef struct rev_struct rev_struct_t;
#line 873 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
struct frwd_struct {
   OPJ_UINT8 *data ;
   OPJ_UINT64 tmp ;
   OPJ_UINT32 bits ;
   OPJ_BOOL unstuff ;
   int size ;
   OPJ_UINT32 X ;
};
#line 880 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
typedef struct frwd_struct frwd_struct_t;
#line 853 "/usr/include/math.h"
enum __anonenum__56___12 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___12 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___13 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___13 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 46
enum __anonenum__163 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 66 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef signed char int8;
#line 67 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned char uint8;
#line 69 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef short int16;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 72 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int int32;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 75 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef long int64;
#line 76 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned long uint64;
#line 86 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int uint16_vap;
#line 91 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_164 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
};
#line 94 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_164 TIFFHeaderCommon;
#line 95 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_165 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint32 tiff_diroff ;
};
#line 99 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_165 TIFFHeaderClassic;
#line 100 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_166 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint16 tiff_offsetsize ;
   uint16 tiff_unused ;
   uint64 tiff_diroff ;
};
#line 106 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_166 TIFFHeaderBig;
#line 123
enum __anonenum__167 {
    TIFF_NOTYPE = 0,
    TIFF_BYTE = 1,
    TIFF_ASCII = 2,
    TIFF_SHORT = 3,
    TIFF_LONG = 4,
    TIFF_RATIONAL = 5,
    TIFF_SBYTE = 6,
    TIFF_UNDEFINED = 7,
    TIFF_SSHORT = 8,
    TIFF_SLONG = 9,
    TIFF_SRATIONAL = 10,
    TIFF_FLOAT = 11,
    TIFF_DOUBLE = 12,
    TIFF_IFD = 13,
    TIFF_LONG8 = 16,
    TIFF_SLONG8 = 17,
    TIFF_IFD8 = 18
} ;
#line 141 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef enum __anonenum__167 TIFFDataType;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 66 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint64 toff_t;
#line 69 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 ttag_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tdir_t;
#line 71 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tsample_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 74 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t ttile_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 104 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *thandle_t;
#line 136 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef unsigned char TIFFRGBValue;
#line 138 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_168 {
   float d_mat[3][3] ;
   float d_YCR ;
   float d_YCG ;
   float d_YCB ;
   uint32 d_Vrwr ;
   uint32 d_Vrwg ;
   uint32 d_Vrwb ;
   float d_Y0R ;
   float d_Y0G ;
   float d_Y0B ;
   float d_gammaR ;
   float d_gammaG ;
   float d_gammaB ;
};
#line 152 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_168 TIFFDisplay;
#line 154 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_169 {
   TIFFRGBValue *clamptab ;
   int *Cr_r_tab ;
   int *Cb_b_tab ;
   int32 *Cr_g_tab ;
   int32 *Cb_g_tab ;
   int32 *Y_tab ;
};
#line 161 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_169 TIFFYCbCrToRGB;
#line 163 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_170 {
   int range ;
   float rstep ;
   float gstep ;
   float bstep ;
   float X0 ;
   float Y0 ;
   float Z0 ;
   TIFFDisplay display ;
   float Yr2r[1501] ;
   float Yg2g[1501] ;
   float Yb2b[1501] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_170 TIFFCIELabToRGB;
#line 177
struct _TIFFRGBAImage ;
#line 177 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFRGBAImage TIFFRGBAImage;
#line 188 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileContigRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                  uint32  , uint32  , int32  , int32  , unsigned char * );
#line 191 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileSeparateRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                    uint32  , uint32  , int32  , int32  , unsigned char * ,
                                    unsigned char * , unsigned char * , unsigned char * );
#line 215 "/usr/include/x86_64-linux-gnu/tiffio.h"
union __anonunion_171 {
   void (*any)(TIFFRGBAImage * ) ;
   tileContigRoutine contig ;
   tileSeparateRoutine separate ;
};
#line 197 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct _TIFFRGBAImage {
   TIFF *tif ;
   int stoponerr ;
   int isContig ;
   int alpha ;
   uint32 width ;
   uint32 height ;
   uint16 bitspersample ;
   uint16 samplesperpixel ;
   uint16 orientation ;
   uint16 req_orientation ;
   uint16 photometric ;
   uint16 *redcmap ;
   uint16 *greencmap ;
   uint16 *bluecmap ;
   int (*get)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
   union __anonunion_171 put ;
   TIFFRGBValue *Map ;
   uint32 **BWmap ;
   uint32 **PALmap ;
   TIFFYCbCrToRGB *ycbcr ;
   TIFFCIELabToRGB *cielab ;
   uint8 *UaToAa ;
   uint8 *Bitdepth16To8 ;
   int row_offset ;
   int col_offset ;
};
#line 249 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFInitMethod)(TIFF * , int  );
#line 250 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_172 {
   char *name ;
   uint16 scheme ;
   TIFFInitMethod init ;
};
#line 254 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_172 TIFFCodec;
#line 271 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandler)(char const   * , char const   * , va_list  );
#line 272 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandlerExt)(thandle_t  , char const   * , char const   * ,
                                    va_list  );
#line 273 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t (*TIFFReadWriteProc)(thandle_t  , void * , tmsize_t  );
#line 274 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSeekProc)(thandle_t  , toff_t  , int  );
#line 275 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFCloseProc)(thandle_t  );
#line 276 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSizeProc)(thandle_t  );
#line 277 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFMapFileProc)(thandle_t  , void ** , toff_t * );
#line 278 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFUnmapFileProc)(thandle_t  , void * , toff_t  );
#line 279 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFExtendProc)(TIFF * );
#line 314
struct _TIFFField ;
#line 314 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFField TIFFField;
#line 315
struct _TIFFFieldArray ;
#line 315 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFFieldArray TIFFFieldArray;
#line 328 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVSetMethod)(TIFF * , uint32  , va_list  );
#line 329 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVGetMethod)(TIFF * , uint32  , va_list  );
#line 330 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFPrintMethod)(TIFF * , FILE * , long  );
#line 332 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_173 {
   TIFFVSetMethod vsetfield ;
   TIFFVGetMethod vgetfield ;
   TIFFPrintMethod printdir ;
};
#line 336 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_173 TIFFTagMethods;
#line 542 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_174 {
   ttag_t field_tag ;
   short field_readcount ;
   short field_writecount ;
   TIFFDataType field_type ;
   unsigned short field_bit ;
   unsigned char field_oktochange ;
   unsigned char field_passcount ;
   char *field_name ;
};
#line 551 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_174 TIFFFieldInfo;
#line 46 "/usr/include/ctype.h"
enum __anonenum__163___0 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 1488 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 46 "/usr/include/ctype.h"
enum __anonenum__163___1 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
#line 48 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
struct __anonstruct_178 {
   OPJ_UINT16 bfType ;
   OPJ_UINT32 bfSize ;
   OPJ_UINT16 bfReserved1 ;
   OPJ_UINT16 bfReserved2 ;
   OPJ_UINT32 bfOffBits ;
};
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_178 OPJ_BITMAPFILEHEADER;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
struct __anonstruct_179 {
   OPJ_UINT32 biSize ;
   OPJ_UINT32 biWidth ;
   OPJ_UINT32 biHeight ;
   OPJ_UINT16 biPlanes ;
   OPJ_UINT16 biBitCount ;
   OPJ_UINT32 biCompression ;
   OPJ_UINT32 biSizeImage ;
   OPJ_UINT32 biXpelsPerMeter ;
   OPJ_UINT32 biYpelsPerMeter ;
   OPJ_UINT32 biClrUsed ;
   OPJ_UINT32 biClrImportant ;
   OPJ_UINT32 biRedMask ;
   OPJ_UINT32 biGreenMask ;
   OPJ_UINT32 biBlueMask ;
   OPJ_UINT32 biAlphaMask ;
   OPJ_UINT32 biColorSpaceType ;
   OPJ_UINT8 biColorSpaceEP[36] ;
   OPJ_UINT32 biRedGamma ;
   OPJ_UINT32 biGreenGamma ;
   OPJ_UINT32 biBlueGamma ;
   OPJ_UINT32 biIntent ;
   OPJ_UINT32 biIccProfileData ;
   OPJ_UINT32 biIccProfileSize ;
   OPJ_UINT32 biReserved ;
};
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
typedef struct __anonstruct_179 OPJ_BITMAPINFOHEADER;
#line 853 "/usr/include/math.h"
enum __anonenum__108___0 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 853
enum __anonenum__56___14 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___14 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__56___15 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__59___15 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 77
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 207
extern void pthread_exit(void *__retval ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 247
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 251
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 254
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 263
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 266
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 270
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 281
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 286
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 302
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 307
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 311
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 316
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 322
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 327
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 331
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 339
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 351
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 357
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 365
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 405
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 410
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 416
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 470
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 482
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 486
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 489
extern int pthread_cancel(pthread_t __th ) ;
#line 494
extern void pthread_testcancel(void) ;
#line 656
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 668
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 719
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 734
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 743
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 761
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 768
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 776
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 789
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 793
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 797
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 803
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 809
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 816
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 821
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 828
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 833
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 839
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 845
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 871
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 876
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 880
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 884
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 889
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 902
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 911
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 931
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 945
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 950
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 956
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 978
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 997
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1020
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1024
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1028
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1034
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1039
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1045
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1056
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1060
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1064
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1068
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1072
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1080
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1090
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1095
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1099
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1109
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1123
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1128
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1131
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1134
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1140
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1157
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1165
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1165 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1167
  return (__thread1 == __thread2);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
#line 39
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
#line 54
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 


  {
#line 75
  return ((__uint64_t )((((((((((unsigned long long )__bsx & 0xff00000000000000ULL) >> 56) | (((unsigned long long )__bsx & 71776119061217280ULL) >> 40)) | (((unsigned long long )__bsx & 280375465082880ULL) >> 24)) | (((unsigned long long )__bsx & 1095216660480ULL) >> 8)) | (((unsigned long long )__bsx & 4278190080ULL) << 8)) | (((unsigned long long )__bsx & 16711680ULL) << 24)) | (((unsigned long long )__bsx & 65280ULL) << 40)) | (((unsigned long long )__bsx & 255ULL) << 56)));
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
extern  __attribute__((__nothrow__)) char *realpath(char const   *__name , char *__resolved ) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__pwcs , char const   *__s ,
                                                     size_t __n ) ;
#line 936
extern  __attribute__((__nothrow__)) size_t wcstombs(char *__s , wchar_t *__pwcs ,
                                                     size_t __n ) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 304
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 417
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 452
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 469
extern int pause(void) ;
#line 473
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 478
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 483
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 491
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 497
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 511
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 525
extern  __attribute__((__nothrow__)) char *getwd(char *__buf ) ;
#line 531
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 543
extern char **__environ ;
#line 551
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 557
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 563
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 568
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 573
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 598
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 603
extern void _exit(int __status ) ;
#line 612
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 616
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 619
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 623
extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf , size_t __len ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 637
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 646
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 689
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] ) ;
#line 700
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 710
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 774
extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf , size_t __buflen ) ;
#line 779
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 784
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 789
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 795
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 802
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 808
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path , char *__buf ,
                                                      size_t __len ) ;
#line 815
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 819
extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                        char *__buf , size_t __len ) ;
#line 825
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 829
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 834
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 838
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 841
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 848
extern char *getlogin(void) ;
#line 856
extern int getlogin_r(char *__name , size_t __name_len ) ;
#line 861
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 877 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len ) ;
#line 884
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 889
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 895
extern  __attribute__((__nothrow__)) int getdomainname(char *__name , size_t __len ) ;
#line 897
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 904
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 907
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 915
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 923
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 927
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 928
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 929
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 935
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 942
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 946
extern char *getpass(char const   *__prompt ) ;
#line 954
extern int fsync(int __fd ) ;
#line 967
extern long gethostid(void) ;
#line 970
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 976
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 981
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 991
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1035
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1041
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1056
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1079
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1115
extern int fdatasync(int __fildes ) ;
#line 1124
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1161
int getentropy(void *__buffer , size_t __length ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 47
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 133
extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n ) ;
#line 42
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n ) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 436 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void explicit_bzero(void *__s , size_t __n ) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 341
extern int vfprintf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 349
extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__format ,
                                                  __gnuc_va_list __arg ) ;
#line 354
extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __maxlen , char const   *__format 
                                                  , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 379
extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 382
extern int dprintf(int __fd , char const   *__fmt  , ...) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 41
  __cil_tmp3 = vfprintf(stdout, __fmt, __arg);
  }
#line 41
  return (__cil_tmp3);
}
}
#line 47
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 1102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1118
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1126
void opj_image_destroy(opj_image_t *image ) ;
#line 1137
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 1149
void *opj_image_data_alloc(OPJ_SIZE_T size ) ;
#line 1159
void opj_image_data_free(void *ptr ) ;
#line 1174
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) ;
#line 1185
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) ;
#line 1194
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1201
void opj_stream_set_read_function(opj_stream_t *p_stream , opj_stream_read_fn p_function ) ;
#line 1209
void opj_stream_set_write_function(opj_stream_t *p_stream , opj_stream_write_fn p_function ) ;
#line 1217
void opj_stream_set_skip_function(opj_stream_t *p_stream , opj_stream_skip_fn p_function ) ;
#line 1226
void opj_stream_set_seek_function(opj_stream_t *p_stream , opj_stream_seek_fn p_function ) ;
#line 1235
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , opj_stream_free_user_data_fn p_function ) ;
#line 1244
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1252
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1260
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) ;
#line 1276
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                              void *p_user_data ) ;
#line 1285
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                                 void *p_user_data ) ;
#line 1294
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                               void *p_user_data ) ;
#line 1310
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) ;
#line 1318
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1325
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1333
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1345
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1359
OPJ_BOOL opj_decoder_set_strict_mode(opj_codec_t *p_codec , OPJ_BOOL strict ) ;
#line 1380
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec , int num_threads ) ;
#line 1392
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1422
OPJ_BOOL opj_set_decoded_components(opj_codec_t *p_codec , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                    OPJ_BOOL apply_color_transforms ) ;
#line 1449
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1462
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1476
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1488
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1503
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1530
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1553
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1566
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) ;
#line 1589
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1598
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *image ) ;
#line 1631
OPJ_BOOL opj_encoder_set_extra_options(opj_codec_t *p_codec , char const   * const  *options ) ;
#line 1641
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1650
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1660
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) ;
#line 1673
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1685
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1697
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1708
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1711
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1723
opj_jp2_metadata_t *opj_get_jp2_metadata(opj_codec_t *p_codec ) ;
#line 1734
opj_jp2_index_t *opj_get_jp2_index(opj_codec_t *p_codec ) ;
#line 1753
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 1767
OPJ_BOOL opj_has_thread_support(void) ;
#line 1770
int opj_get_num_cpus(void) ;
#line 174 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_includes.h"
__inline static long opj_lrintf(float f ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 176
  __cil_tmp2 = lrintf(f);
  }
#line 176
  return (__cil_tmp2);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.h"
void *opj_malloc(size_t size ) ;
#line 63
void *opj_calloc(size_t num , size_t size ) ;
#line 70
void *opj_aligned_malloc(size_t size ) ;
#line 71
void *opj_aligned_realloc(void *ptr , size_t size ) ;
#line 72
void opj_aligned_free(void *ptr ) ;
#line 79
void *opj_aligned_32_malloc(size_t size ) ;
#line 80
void *opj_aligned_32_realloc(void *ptr , size_t size ) ;
#line 88
void *opj_realloc(void *ptr , size_t new_size ) ;
#line 94
void opj_free(void *ptr ) ;
#line 89 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 80 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 87
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          opj_procedure p_procedure , opj_event_mgr_t *p_manager ) ;
#line 108
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 120
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 130
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 76 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 108
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 115
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 123
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 129
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 135
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 176 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 186
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 196
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 206
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 285
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 295
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) ;
#line 305
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) ;
#line 315
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 325
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 335
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) ;
#line 345
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 355
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) ;
#line 365
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) ;
#line 375
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 381
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 386
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 392
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 398
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 403
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
opj_mutex_t *opj_mutex_create(void) ;
#line 63
void opj_mutex_lock(opj_mutex_t *mutex ) ;
#line 68
void opj_mutex_unlock(opj_mutex_t *mutex ) ;
#line 73
void opj_mutex_destroy(opj_mutex_t *mutex ) ;
#line 87
opj_cond_t *opj_cond_create(void) ;
#line 120
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) ;
#line 128
void opj_cond_signal(opj_cond_t *cond ) ;
#line 133
void opj_cond_destroy(opj_cond_t *cond ) ;
#line 154
opj_thread_t *opj_thread_create(opj_thread_fn thread_fn , void *user_data ) ;
#line 160
void opj_thread_join(opj_thread_t *thread ) ;
#line 174
void *opj_tls_get(opj_tls_t *tls , int key ) ;
#line 186
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , opj_tls_free_func opj_free_func ) ;
#line 207
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) ;
#line 225
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , opj_job_fn job_fn , void *user_data ) ;
#line 237
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) ;
#line 245
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) ;
#line 250
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) ;
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image , struct opj_cp *p_cp ) ;
#line 64
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 635 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 637
void opj_j2k_decoder_set_strict_mode(opj_j2k_t *j2k , OPJ_BOOL strict ) ;
#line 639
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) ;
#line 646
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 649
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 657
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 668
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 682
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 693
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 700
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 711
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 732
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 755
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) ;
#line 773
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 784
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 795
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 806
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 816
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 826
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 835
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 845
OPJ_BOOL opj_j2k_decode(opj_j2k_t *j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 851
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 857
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 870
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) ;
#line 884
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 894
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 908
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 917
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 921
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 245
void opj_jp2_decoder_set_strict_mode(opj_jp2_t *jp2 , OPJ_BOOL strict ) ;
#line 253
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2 , OPJ_UINT32 num_threads ) ;
#line 264
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 279
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) ;
#line 291
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 306
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 316
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 326
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 340
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 355
OPJ_BOOL opj_jp2_set_decoded_components(opj_jp2_t *jp2 , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) ;
#line 374
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 396
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 414
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 426
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 432
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 448
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 457
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 467
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 480
OPJ_BOOL opj_jp2_encoder_set_extra_options(opj_jp2_t *p_jp2 , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) ;
#line 495
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 504
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 513
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc_inl.h"
__inline static OPJ_UINT32 opj_mqc_raw_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 d ;
  OPJ_BYTE *__cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 77
  if (mqc->ct == 0U) {
#line 80
    if (mqc->c == 255U) {
#line 81
      if ((int )*(mqc->bp) > 143) {
#line 82
        mqc->c = (OPJ_UINT32 )255;
#line 83
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 85
        mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 86
        (mqc->bp) ++;
#line 87
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 90
      mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 91
      (mqc->bp) ++;
#line 92
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 95
  __cil_tmp5 = mqc->ct;
#line 95
  (mqc->ct) --;
#line 96
  d = ((OPJ_UINT32 )mqc->c >> mqc->ct) & 1U;
#line 98
  return (d);
}
}
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc_inl.h"
__inline static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;
  OPJ_BYTE *__cil_tmp5 ;

  {
#line 177
  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 177
  if ((int )*(mqc->bp) == 255) {
#line 177
    if (l_c > 143U) {
#line 177
      mqc->c += (unsigned int )65280;
#line 177
      mqc->ct = (OPJ_UINT32 )8;
#line 177
      (mqc->end_of_byte_stream_counter) ++;
    } else {
#line 177
      (mqc->bp) ++;
#line 177
      mqc->c += l_c << 9;
#line 177
      mqc->ct = (OPJ_UINT32 )7;
    }
  } else {
#line 177
    (mqc->bp) ++;
#line 177
    mqc->c += l_c << 8;
#line 177
    mqc->ct = (OPJ_UINT32 )8;
  }

  return;
}
}
#line 201
void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 118
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 126
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 133
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 145
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 151
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 158
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 166
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 172
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 177
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 192
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 197
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 202
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 222
void opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 243
void opj_mqc_raw_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 255
void opq_mqc_finish_dec(opj_mqc_t *mqc ) ;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                            J2K_T2_MODE t2_mode , opj_event_mgr_t *manager ) ;
#line 141
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 155
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 172
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                        opj_event_mgr_t *manager ) ;
#line 182
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 190
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 198
OPJ_UINT32 opj_get_encoding_packet_count(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 86 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) ;
#line 98
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) ;
#line 105
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) ;
#line 110
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) ;
#line 117
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 127
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 139
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 322 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 328
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 335
opj_tcd_marker_info_t *opj_tcd_marker_info_create(OPJ_BOOL need_PLT ) ;
#line 342
void opj_tcd_marker_info_destroy(opj_tcd_marker_info_t *p_tcd_marker_info ) ;
#line 354
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) ;
#line 369
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 375
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) ;
#line 390
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_tcd_marker_info_t *p_marker_info ,
                             opj_event_mgr_t *p_manager ) ;
#line 417
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_UINT32 numcomps_to_decode ,
                             OPJ_UINT32 *comps_indices , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) ;
#line 434
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 443
OPJ_SIZE_T opj_tcd_get_encoder_input_buffer_size(opj_tcd_t *p_tcd ) ;
#line 454
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 462
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) ;
#line 471
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) ;
#line 477
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) ;
#line 480
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) ;
#line 497
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) ;
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_tcd_t *tcd , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 240
void opj_t1_decode_cblks(opj_tcd_t *tcd , OPJ_BOOL *pret , opj_tcd_tilecomp_t *tilec ,
                         opj_tccp_t *tccp , opj_event_mgr_t *p_manager , opj_mutex_t *p_manager_mutex ,
                         OPJ_BOOL check_pterm ) ;
#line 255
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) ;
#line 262
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/dwt.h"
OPJ_BOOL opj_dwt_encode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 72
OPJ_BOOL opj_dwt_decode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 82
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 89
OPJ_BOOL opj_dwt_encode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 98
OPJ_BOOL opj_dwt_decode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 108
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 114
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 83 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               opj_tcd_marker_info_t *p_marker_info , OPJ_UINT32 p_tp_num ,
                               OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino , J2K_T2_MODE p_t2_mode ,
                               opj_event_mgr_t *p_manager ) ;
#line 112
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) ;
#line 129
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 135
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mct.h"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 72
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 79
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) ;
#line 88
void opj_mct_encode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) ;
#line 98
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) ;
#line 105
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) ;
#line 116
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *p_coding_data , OPJ_SIZE_T n , OPJ_BYTE **p_data ,
                               OPJ_UINT32 p_nb_comp , OPJ_UINT32 is_signed ) ;
#line 131
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 144
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 p_nb_comps , OPJ_FLOAT32 *pMatrix ) ;
#line 150
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 154
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 58
  if (a < b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 65 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 67
  if (a < b) {
#line 67
    tmp = a;
  } else {
#line 67
    tmp = b;
  }
#line 67
  return (tmp);
}
}
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 76
  if (a > b) {
#line 76
    tmp = a;
  } else {
#line 76
    tmp = b;
  }
#line 76
  return (tmp);
}
}
#line 83 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 85
  if (a > b) {
#line 85
    tmp = a;
  } else {
#line 85
    tmp = b;
  }
#line 85
  return (tmp);
}
}
#line 92 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_adds(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT64 sum ;

  {
#line 94
  sum = (OPJ_UINT64 )a + (OPJ_UINT64 )b;
#line 95
  return ((OPJ_UINT32 )(- ((OPJ_INT32 )(sum >> 32))) | (OPJ_UINT32 )sum);
}
}
#line 102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_subs(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 104
  if (a >= b) {
#line 104
    tmp = a - b;
  } else {
#line 104
    tmp = (unsigned int )0;
  }
#line 104
  return (tmp);
}
}
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 119
  if (a < min) {
#line 120
    return (min);
  }
#line 122
  if (a > max) {
#line 123
    return (max);
  }
#line 125
  return (a);
}
}
#line 137 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT64 opj_int64_clamp(OPJ_INT64 a , OPJ_INT64 min , OPJ_INT64 max ) 
{ 


  {
#line 140
  if (a < min) {
#line 141
    return (min);
  }
#line 143
  if (a > max) {
#line 144
    return (max);
  }
#line 146
  return (a);
}
}
#line 152 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 154
  if (a < 0) {
#line 154
    tmp = - a;
  } else {
#line 154
    tmp = a;
  }
#line 154
  return (tmp);
}
}
#line 160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 163
  return ((OPJ_INT32 )((((OPJ_INT64 )a + (long )b) - 1L) / (long )b));
}
}
#line 170 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 173
  return ((OPJ_UINT32 )((((OPJ_UINT64 )a + (unsigned long )b) - 1UL) / (unsigned long )b));
}
}
#line 180 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint64_ceildiv_res_uint32(OPJ_UINT64 a , OPJ_UINT64 b ) 
{ 


  {
#line 184
  return ((OPJ_UINT32 )(((a + b) - 1UL) / b));
}
}
#line 191 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 193
  return ((OPJ_INT32 )((((long )a + (1L << b)) - 1L) >> b));
}
}
#line 200 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int64_ceildivpow2(OPJ_INT64 a , OPJ_INT32 b ) 
{ 


  {
#line 202
  return ((OPJ_INT32 )(((a + (1L << b)) - 1L) >> b));
}
}
#line 209 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 211
  return ((OPJ_UINT32 )((((unsigned long )a + (1UL << b)) - 1UL) >> b));
}
}
#line 218 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 220
  return (a >> b);
}
}
#line 227 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floordivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 229
  return (a >> b);
}
}
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;
  OPJ_INT32 __cil_tmp3 ;

  {
#line 239
  l = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (a > 1)) {
#line 239
      goto while_break;
    }
#line 240
    a >>= 1;
#line 239
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (l);
}
}
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 251
  l = (OPJ_UINT32 )0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (a > 1U)) {
#line 251
      goto while_break;
    }
#line 252
    a >>= 1;
#line 251
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (l);
}
}
#line 263 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 268
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 270
  temp += (long )4096;
#line 273
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 276 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul_t1(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 281
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 283
  temp += (long )4096;
#line 287
  return ((OPJ_INT32 )(temp >> 18));
}
}
#line 297 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_add_no_overflow(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  void *pa ;
  void *pb ;
  OPJ_UINT32 *upa ;
  OPJ_UINT32 *upb ;
  OPJ_UINT32 ures ;
  void *pures ;
  OPJ_INT32 *ipres ;

  {
#line 299
  pa = & a;
#line 300
  pb = & b;
#line 301
  upa = (OPJ_UINT32 *)pa;
#line 302
  upb = (OPJ_UINT32 *)pb;
#line 303
  ures = *upa + *upb;
#line 304
  pures = & ures;
#line 305
  ipres = (OPJ_INT32 *)pures;
#line 306
  return (*ipres);
}
}
#line 316 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_sub_no_overflow(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  void *pa ;
  void *pb ;
  OPJ_UINT32 *upa ;
  OPJ_UINT32 *upb ;
  OPJ_UINT32 ures ;
  void *pures ;
  OPJ_INT32 *ipres ;

  {
#line 318
  pa = & a;
#line 319
  pb = & b;
#line 320
  upa = (OPJ_UINT32 *)pa;
#line 321
  upb = (OPJ_UINT32 *)pb;
#line 322
  ures = *upa - *upb;
#line 323
  pures = & ures;
#line 324
  ipres = (OPJ_INT32 *)pures;
#line 325
  return (*ipres);
}
}
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) ;
#line 70
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) ;
#line 80
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) ;
#line 102
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) ;
#line 129
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) ;
#line 295 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
OPJ_BOOL opj_has_thread_support(void) 
{ 


  {
#line 297
  return (1);
}
}
#line 300 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
int opj_get_num_cpus(void) 
{ 
  long __cil_tmp1 ;

  {
  {
#line 303
  __cil_tmp1 = sysconf(84);
  }
#line 303
  return ((int )__cil_tmp1);
}
}
#line 313 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
opj_mutex_t *opj_mutex_create(void) 
{ 
  opj_mutex_t *mutex ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 315
  __cil_tmp2 = opj_calloc((size_t )1U, sizeof(opj_mutex_t ));
#line 315
  mutex = (opj_mutex_t *)__cil_tmp2;
  }
#line 316
  if (mutex != (void *)0) {
    {
#line 317
    __cil_tmp3 = pthread_mutex_init(& mutex->mutex, (pthread_mutexattr_t *)((void *)0));
    }
#line 317
    if (__cil_tmp3 != 0) {
      {
#line 318
      opj_free(mutex);
#line 319
      mutex = (opj_mutex_t *)((void *)0);
      }
    }
  }
#line 322
  return (mutex);
}
}
#line 325 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_mutex_lock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 327
  pthread_mutex_lock(& mutex->mutex);
  }
  return;
}
}
#line 330 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_mutex_unlock(opj_mutex_t *mutex ) 
{ 


  {
  {
#line 332
  pthread_mutex_unlock(& mutex->mutex);
  }
  return;
}
}
#line 335 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_mutex_destroy(opj_mutex_t *mutex ) 
{ 


  {
#line 337
  if (! mutex) {
#line 338
    return;
  }
  {
#line 340
  pthread_mutex_destroy(& mutex->mutex);
#line 341
  opj_free(mutex);
  }
  return;
}
}
#line 348 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
opj_cond_t *opj_cond_create(void) 
{ 
  opj_cond_t *cond ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 350
  __cil_tmp2 = opj_malloc(sizeof(opj_cond_t ));
#line 350
  cond = (opj_cond_t *)__cil_tmp2;
  }
#line 351
  if (! cond) {
#line 352
    return ((opj_cond_t *)((void *)0));
  }
  {
#line 354
  __cil_tmp3 = pthread_cond_init(& cond->cond, (pthread_condattr_t *)((void *)0));
  }
#line 354
  if (__cil_tmp3 != 0) {
    {
#line 355
    opj_free(cond);
    }
#line 356
    return ((opj_cond_t *)((void *)0));
  }
#line 358
  return (cond);
}
}
#line 361 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) 
{ 


  {
  {
#line 363
  pthread_cond_wait(& cond->cond, & mutex->mutex);
  }
  return;
}
}
#line 366 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_cond_signal(opj_cond_t *cond ) 
{ 
  int ret ;
  int __cil_tmp3 ;

  {
  {
#line 368
  __cil_tmp3 = pthread_cond_signal(& cond->cond);
#line 368
  ret = __cil_tmp3;
  }
  return;
}
}
#line 373 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_cond_destroy(opj_cond_t *cond ) 
{ 


  {
#line 375
  if (! cond) {
#line 376
    return;
  }
  {
#line 378
  pthread_cond_destroy(& cond->cond);
#line 379
  opj_free(cond);
  }
  return;
}
}
#line 389 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static void *opj_thread_callback_adapter(void *info ) 
{ 
  opj_thread_t *thread ;

  {
  {
#line 391
  thread = (opj_thread_t *)info;
#line 392
  (*(thread->thread_fn))(thread->user_data);
  }
#line 393
  return ((void *)0);
}
}
#line 396 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
opj_thread_t *opj_thread_create(opj_thread_fn thread_fn , void *user_data ) 
{ 
  pthread_attr_t attr ;
  opj_thread_t *thread ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 403
  __cil_tmp5 = opj_malloc(sizeof(opj_thread_t ));
#line 403
  thread = (opj_thread_t *)__cil_tmp5;
  }
#line 404
  if (! thread) {
#line 405
    return ((opj_thread_t *)((void *)0));
  }
  {
#line 407
  thread->thread_fn = thread_fn;
#line 408
  thread->user_data = user_data;
#line 410
  pthread_attr_init(& attr);
#line 411
  pthread_attr_setdetachstate(& attr, 0);
#line 412
  __cil_tmp6 = pthread_create(& thread->thread, & attr, & opj_thread_callback_adapter,
                              (void *)thread);
  }
#line 412
  if (__cil_tmp6 != 0) {
    {
#line 414
    opj_free(thread);
    }
#line 415
    return ((opj_thread_t *)((void *)0));
  }
#line 417
  return (thread);
}
}
#line 420 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_thread_join(opj_thread_t *thread ) 
{ 
  void *status ;

  {
  {
#line 423
  pthread_join(thread->thread, & status);
#line 425
  opj_free(thread);
  }
  return;
}
}
#line 509 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static opj_tls_t *opj_tls_new(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 511
  __cil_tmp1 = opj_calloc((size_t )1, sizeof(opj_tls_t ));
  }
#line 511
  return ((opj_tls_t *)__cil_tmp1);
}
}
#line 514 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static void opj_tls_destroy(opj_tls_t *tls ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 517
  if (! tls) {
#line 518
    return;
  }
#line 520
  i = 0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < tls->key_val_count)) {
#line 520
      goto while_break;
    }
#line 521
    if ((tls->key_val + i)->opj_free_func) {
      {
#line 522
      (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
      }
    }
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 525
  opj_free(tls->key_val);
#line 526
  opj_free(tls);
  }
  return;
}
}
#line 529 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void *opj_tls_get(opj_tls_t *tls , int key ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 532
  i = 0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < tls->key_val_count)) {
#line 532
      goto while_break;
    }
#line 533
    if ((tls->key_val + i)->key == key) {
#line 534
      return ((tls->key_val + i)->value);
    }
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return ((void *)0);
}
}
#line 540 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , opj_tls_free_func opj_free_func ) 
{ 
  opj_tls_key_val_t *new_key_val ;
  int i ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 546
  if (tls->key_val_count == 2147483647) {
#line 547
    return (0);
  }
#line 549
  i = 0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    if (! (i < tls->key_val_count)) {
#line 549
      goto while_break;
    }
#line 550
    if ((tls->key_val + i)->key == key) {
#line 551
      if ((tls->key_val + i)->opj_free_func) {
        {
#line 552
        (*((tls->key_val + i)->opj_free_func))((tls->key_val + i)->value);
        }
      }
#line 554
      (tls->key_val + i)->value = value;
#line 555
      (tls->key_val + i)->opj_free_func = opj_free_func;
#line 556
      return (1);
    }
#line 549
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  __cil_tmp8 = opj_realloc(tls->key_val, ((size_t )tls->key_val_count + 1UL) * sizeof(opj_tls_key_val_t ));
#line 559
  new_key_val = (opj_tls_key_val_t *)__cil_tmp8;
  }
#line 561
  if (! new_key_val) {
#line 562
    return (0);
  }
#line 564
  tls->key_val = new_key_val;
#line 565
  (new_key_val + tls->key_val_count)->key = key;
#line 566
  (new_key_val + tls->key_val_count)->value = value;
#line 567
  (new_key_val + tls->key_val_count)->opj_free_func = opj_free_func;
#line 568
  (tls->key_val_count) ++;
#line 569
  return (1);
}
}
#line 619
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) ;
#line 620
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) ;
#line 625 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) 
{ 
  opj_thread_pool_t *tp ;
  void *__cil_tmp3 ;
  opj_tls_t *__cil_tmp4 ;
  opj_mutex_t *__cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 629
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_thread_pool_t ));
#line 629
  tp = (opj_thread_pool_t *)__cil_tmp3;
  }
#line 630
  if (! tp) {
#line 631
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 633
  tp->state = (opj_worker_thread_state )0;
#line 635
  if (num_threads <= 0) {
    {
#line 636
    tp->tls = opj_tls_new();
    }
#line 637
    if (! tp->tls) {
      {
#line 638
      opj_free(tp);
#line 639
      tp = (opj_thread_pool_t *)((void *)0);
      }
    }
#line 641
    return (tp);
  }
  {
#line 644
  tp->mutex = opj_mutex_create();
  }
#line 645
  if (! tp->mutex) {
    {
#line 646
    opj_free(tp);
    }
#line 647
    return ((opj_thread_pool_t *)((void *)0));
  }
  {
#line 649
  __cil_tmp6 = opj_thread_pool_setup(tp, num_threads);
  }
#line 649
  if (! __cil_tmp6) {
    {
#line 650
    opj_thread_pool_destroy(tp);
    }
#line 651
    return ((opj_thread_pool_t *)((void *)0));
  }
#line 653
  return (tp);
}
}
#line 656 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static void opj_worker_thread_function(void *user_data ) 
{ 
  opj_worker_thread_t *worker_thread ;
  opj_thread_pool_t *tp ;
  opj_tls_t *tls ;
  OPJ_BOOL job_finished ;
  opj_tls_t *__cil_tmp6 ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_job_t *__cil_tmp8 ;

  {
  {
#line 661
  job_finished = 0;
#line 663
  worker_thread = (opj_worker_thread_t *)user_data;
#line 664
  tp = worker_thread->tp;
#line 665
  tls = opj_tls_new();
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 668
    __cil_tmp8 = opj_thread_pool_get_next_job(tp, worker_thread, job_finished);
#line 668
    job = __cil_tmp8;
    }
#line 670
    if (job == (void *)0) {
#line 671
      goto while_break;
    }
#line 674
    if (job->job_fn) {
      {
#line 675
      (*(job->job_fn))(job->user_data, tls);
      }
    }
    {
#line 677
    opj_free(job);
#line 678
    job_finished = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 681
  opj_tls_destroy(tls);
  }
  return;
}
}
#line 684 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static OPJ_BOOL opj_thread_pool_setup(opj_thread_pool_t *tp , int num_threads ) 
{ 
  int i ;
  OPJ_BOOL bRet ;
  opj_cond_t *__cil_tmp5 ;
  void *__cil_tmp6 ;
  opj_mutex_t *__cil_tmp7 ;
  opj_cond_t *__cil_tmp8 ;
  opj_thread_t *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 687
  bRet = 1;
#line 691
  tp->cond = opj_cond_create();
  }
#line 692
  if (tp->cond == (void *)0) {
#line 693
    return (0);
  }
  {
#line 696
  __cil_tmp6 = opj_calloc((size_t )num_threads, sizeof(opj_worker_thread_t ));
#line 696
  tp->worker_threads = (opj_worker_thread_t *)__cil_tmp6;
  }
#line 698
  if (tp->worker_threads == (void *)0) {
#line 699
    return (0);
  }
#line 701
  tp->worker_threads_count = num_threads;
#line 703
  i = 0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! (i < num_threads)) {
#line 703
      goto while_break;
    }
    {
#line 704
    (tp->worker_threads + i)->tp = tp;
#line 706
    (tp->worker_threads + i)->mutex = opj_mutex_create();
    }
#line 707
    if ((tp->worker_threads + i)->mutex == (void *)0) {
#line 708
      tp->worker_threads_count = i;
#line 709
      bRet = 0;
#line 710
      goto while_break;
    }
    {
#line 713
    (tp->worker_threads + i)->cond = opj_cond_create();
    }
#line 714
    if ((tp->worker_threads + i)->cond == (void *)0) {
      {
#line 715
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 716
      tp->worker_threads_count = i;
#line 717
      bRet = 0;
      }
#line 718
      goto while_break;
    }
    {
#line 721
    (tp->worker_threads + i)->marked_as_waiting = 0;
#line 723
    (tp->worker_threads + i)->thread = opj_thread_create(& opj_worker_thread_function,
                                                         tp->worker_threads + i);
    }
#line 725
    if ((tp->worker_threads + i)->thread == (void *)0) {
      {
#line 726
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
#line 727
      opj_cond_destroy((tp->worker_threads + i)->cond);
#line 728
      tp->worker_threads_count = i;
#line 729
      bRet = 0;
      }
#line 730
      goto while_break;
    }
#line 703
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 736
  opj_mutex_lock(tp->mutex);
  }
  {
#line 737
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 737
    if (! (tp->waiting_worker_thread_count < tp->worker_threads_count)) {
#line 737
      goto while_break___0;
    }
    {
#line 738
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 740
  opj_mutex_unlock(tp->mutex);
  }
#line 743
  if ((unsigned int )tp->state == 2U) {
#line 744
    bRet = 0;
  }
#line 747
  return (bRet);
}
}
#line 757 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
static opj_worker_thread_job_t *opj_thread_pool_get_next_job(opj_thread_pool_t *tp ,
                                                             opj_worker_thread_t *worker_thread ,
                                                             OPJ_BOOL signal_job_finished ) 
{ 
  opj_job_list_t *top_job_iter ;
  int __cil_tmp5 ;
  opj_worker_thread_job_t *job ;
  opj_worker_thread_list_t *item ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    opj_mutex_lock(tp->mutex);
    }
#line 767
    if (signal_job_finished) {
#line 768
      signal_job_finished = 0;
#line 769
      __cil_tmp5 = tp->pending_jobs_count;
#line 769
      (tp->pending_jobs_count) --;
#line 771
      if (tp->pending_jobs_count <= tp->signaling_threshold) {
        {
#line 772
        opj_cond_signal(tp->cond);
        }
      }
    }
#line 776
    if ((unsigned int )tp->state == 1U) {
      {
#line 777
      opj_mutex_unlock(tp->mutex);
      }
#line 778
      return ((opj_worker_thread_job_t *)((void *)0));
    }
#line 780
    top_job_iter = tp->job_queue;
#line 781
    if (top_job_iter) {
      {
#line 783
      tp->job_queue = top_job_iter->next;
#line 785
      job = top_job_iter->job;
#line 786
      opj_mutex_unlock(tp->mutex);
#line 787
      opj_free(top_job_iter);
      }
#line 788
      return (job);
    }
#line 792
    if (! worker_thread->marked_as_waiting) {
      {
#line 795
      worker_thread->marked_as_waiting = 1;
#line 796
      (tp->waiting_worker_thread_count) ++;
#line 799
      __cil_tmp9 = opj_malloc(sizeof(opj_worker_thread_list_t ));
#line 799
      item = (opj_worker_thread_list_t *)__cil_tmp9;
      }
#line 800
      if (item == (void *)0) {
        {
#line 801
        tp->state = (opj_worker_thread_state )2;
#line 802
        opj_cond_signal(tp->cond);
#line 804
        opj_mutex_unlock(tp->mutex);
        }
#line 805
        return ((opj_worker_thread_job_t *)((void *)0));
      }
#line 808
      item->worker_thread = worker_thread;
#line 809
      item->next = tp->waiting_worker_thread_list;
#line 810
      tp->waiting_worker_thread_list = item;
    }
    {
#line 814
    opj_cond_signal(tp->cond);
#line 816
    opj_mutex_lock(worker_thread->mutex);
#line 817
    opj_mutex_unlock(tp->mutex);
#line 820
    opj_cond_wait(worker_thread->cond, worker_thread->mutex);
#line 822
    opj_mutex_unlock(worker_thread->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 827 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , opj_job_fn job_fn , void *user_data ) 
{ 
  opj_worker_thread_job_t *job ;
  opj_job_list_t *item ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  opj_worker_thread_t *worker_thread ;
  opj_worker_thread_list_t *next ;
  opj_worker_thread_list_t *to_opj_free ;
  int __cil_tmp12 ;

  {
#line 834
  if (tp->mutex == (void *)0) {
    {
#line 835
    (*job_fn)(user_data, tp->tls);
    }
#line 836
    return (1);
  }
  {
#line 839
  __cil_tmp6 = opj_malloc(sizeof(opj_worker_thread_job_t ));
#line 839
  job = (opj_worker_thread_job_t *)__cil_tmp6;
  }
#line 840
  if (job == (void *)0) {
#line 841
    return (0);
  }
  {
#line 843
  job->job_fn = job_fn;
#line 844
  job->user_data = user_data;
#line 846
  __cil_tmp7 = opj_malloc(sizeof(opj_job_list_t ));
#line 846
  item = (opj_job_list_t *)__cil_tmp7;
  }
#line 847
  if (item == (void *)0) {
    {
#line 848
    opj_free(job);
    }
#line 849
    return (0);
  }
  {
#line 851
  item->job = job;
#line 853
  opj_mutex_lock(tp->mutex);
#line 855
  tp->signaling_threshold = 100 * tp->worker_threads_count;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (tp->pending_jobs_count > tp->signaling_threshold)) {
#line 856
      goto while_break;
    }
    {
#line 858
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  item->next = tp->job_queue;
#line 863
  tp->job_queue = item;
#line 864
  (tp->pending_jobs_count) ++;
#line 866
  if (tp->waiting_worker_thread_list) {
    {
#line 871
    worker_thread = (tp->waiting_worker_thread_list)->worker_thread;
#line 874
    worker_thread->marked_as_waiting = 0;
#line 876
    next = (tp->waiting_worker_thread_list)->next;
#line 877
    to_opj_free = tp->waiting_worker_thread_list;
#line 878
    tp->waiting_worker_thread_list = next;
#line 879
    __cil_tmp12 = tp->waiting_worker_thread_count;
#line 879
    (tp->waiting_worker_thread_count) --;
#line 881
    opj_mutex_lock(worker_thread->mutex);
#line 882
    opj_mutex_unlock(tp->mutex);
#line 883
    opj_cond_signal(worker_thread->cond);
#line 884
    opj_mutex_unlock(worker_thread->mutex);
#line 886
    opj_free(to_opj_free);
    }
  } else {
    {
#line 888
    opj_mutex_unlock(tp->mutex);
    }
  }
#line 891
  return (1);
}
}
#line 894 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) 
{ 


  {
#line 897
  if (tp->mutex == (void *)0) {
#line 898
    return;
  }
#line 901
  if (max_remaining_jobs < 0) {
#line 902
    max_remaining_jobs = 0;
  }
  {
#line 904
  opj_mutex_lock(tp->mutex);
#line 905
  tp->signaling_threshold = max_remaining_jobs;
  }
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (tp->pending_jobs_count > max_remaining_jobs)) {
#line 906
      goto while_break;
    }
    {
#line 908
    opj_cond_wait(tp->cond, tp->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 911
  opj_mutex_unlock(tp->mutex);
  }
  return;
}
}
#line 914 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) 
{ 


  {
#line 916
  return (tp->worker_threads_count);
}
}
#line 919 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.c"
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) 
{ 
  int i ;
  int __cil_tmp3 ;
  opj_worker_thread_list_t *next ;

  {
#line 921
  if (! tp) {
#line 922
    return;
  }
#line 924
  if (tp->cond) {
    {
#line 926
    opj_thread_pool_wait_completion(tp, 0);
#line 928
    opj_mutex_lock(tp->mutex);
#line 929
    tp->state = (opj_worker_thread_state )1;
#line 930
    opj_mutex_unlock(tp->mutex);
#line 932
    i = 0;
    }
    {
#line 932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 932
      if (! (i < tp->worker_threads_count)) {
#line 932
        goto while_break;
      }
      {
#line 933
      opj_mutex_lock((tp->worker_threads + i)->mutex);
#line 934
      opj_cond_signal((tp->worker_threads + i)->cond);
#line 935
      opj_mutex_unlock((tp->worker_threads + i)->mutex);
#line 936
      opj_thread_join((tp->worker_threads + i)->thread);
#line 937
      opj_cond_destroy((tp->worker_threads + i)->cond);
#line 938
      opj_mutex_destroy((tp->worker_threads + i)->mutex);
      }
#line 932
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 941
    opj_free(tp->worker_threads);
    }
    {
#line 943
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 943
      if (! (tp->waiting_worker_thread_list != (void *)0)) {
#line 943
        goto while_break___0;
      }
      {
#line 944
      next = (tp->waiting_worker_thread_list)->next;
#line 945
      opj_free(tp->waiting_worker_thread_list);
#line 946
      tp->waiting_worker_thread_list = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 949
    opj_cond_destroy(tp->cond);
    }
  }
  {
#line 951
  opj_mutex_destroy(tp->mutex);
#line 952
  opj_tls_destroy(tp->tls);
#line 953
  opj_free(tp);
  }
  return;
}
}
#line 48 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 nplh[32] ;
  OPJ_INT32 nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  opj_tgt_tree_t *tree ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 numlvls ;
  OPJ_UINT32 n ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 53
  node = (opj_tgt_node_t *)0;
#line 54
  l_parent_node = (opj_tgt_node_t *)0;
#line 55
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 56
  tree = (opj_tgt_tree_t *)0;
#line 62
  __cil_tmp15 = opj_calloc((size_t )1, sizeof(opj_tgt_tree_t ));
#line 62
  tree = (opj_tgt_tree_t *)__cil_tmp15;
  }
#line 63
  if (! tree) {
    {
#line 64
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree\n");
    }
#line 65
    return ((opj_tgt_tree_t *)0);
  }
#line 68
  tree->numleafsh = numleafsh;
#line 69
  tree->numleafsv = numleafsv;
#line 71
  numlvls = (OPJ_UINT32 )0;
#line 72
  nplh[0] = (OPJ_INT32 )numleafsh;
#line 73
  nplv[0] = (OPJ_INT32 )numleafsv;
#line 74
  tree->numnodes = (OPJ_UINT32 )0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    n = (OPJ_UINT32 )(nplh[numlvls] * nplv[numlvls]);
#line 77
    nplh[numlvls + 1U] = (nplh[numlvls] + 1) / 2;
#line 78
    nplv[numlvls + 1U] = (nplv[numlvls] + 1) / 2;
#line 79
    tree->numnodes += n;
#line 80
    numlvls ++;
#line 75
    if (! (n > 1U)) {
#line 75
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (tree->numnodes == 0U) {
    {
#line 85
    opj_free(tree);
    }
#line 86
    return ((opj_tgt_tree_t *)0);
  }
  {
#line 89
  __cil_tmp16 = opj_calloc((size_t )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 89
  tree->nodes = (opj_tgt_node_t *)__cil_tmp16;
  }
#line 91
  if (! tree->nodes) {
    {
#line 92
    opj_event_msg(p_manager, 1, "Not enough memory to create Tag-tree nodes\n");
#line 94
    opj_free(tree);
    }
#line 95
    return ((opj_tgt_tree_t *)0);
  }
#line 97
  tree->nodes_size = tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 99
  node = tree->nodes;
#line 100
  l_parent_node = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 101
  l_parent_node0 = l_parent_node;
#line 103
  i = (OPJ_UINT32 )0;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i < numlvls - 1U)) {
#line 103
      goto while_break___0;
    }
#line 104
    j = 0;
    {
#line 104
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 104
      if (! (j < nplv[i])) {
#line 104
        goto while_break___1;
      }
#line 105
      k = nplh[i];
      {
#line 106
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 106
        k --;
#line 106
        if (! (k >= 0)) {
#line 106
          goto while_break___2;
        }
#line 107
        node->parent = l_parent_node;
#line 108
        node ++;
#line 109
        k --;
#line 109
        if (k >= 0) {
#line 110
          node->parent = l_parent_node;
#line 111
          node ++;
        }
#line 113
        l_parent_node ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 115
      if (j & 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else
#line 115
      if (j == nplv[i] - 1) {
#line 116
        l_parent_node0 = l_parent_node;
      } else {
#line 118
        l_parent_node = l_parent_node0;
#line 119
        l_parent_node0 += nplh[i];
      }
#line 104
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 123
  node->parent = (struct opj_tgt_node *)0;
#line 124
  opj_tgt_reset(tree);
  }
#line 125
  return (tree);
}
}
#line 136 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_INT32 l_nplh[32] ;
  OPJ_INT32 l_nplv[32] ;
  opj_tgt_node_t *l_node ;
  opj_tgt_node_t *l_parent_node ;
  opj_tgt_node_t *l_parent_node0 ;
  OPJ_UINT32 i ;
  OPJ_INT32 j ;
  OPJ_INT32 k ;
  OPJ_UINT32 l_num_levels ;
  OPJ_UINT32 n ;
  OPJ_UINT32 l_node_size ;
  opj_tgt_node_t *new_nodes ;
  void *__cil_tmp17 ;

  {
#line 141
  l_node = (opj_tgt_node_t *)0;
#line 142
  l_parent_node = (opj_tgt_node_t *)0;
#line 143
  l_parent_node0 = (opj_tgt_node_t *)0;
#line 150
  if (! p_tree) {
#line 151
    return ((opj_tgt_tree_t *)0);
  }
#line 154
  if (p_tree->numleafsh != p_num_leafs_h) {
    _L: /* CIL Label */ 
#line 156
    p_tree->numleafsh = p_num_leafs_h;
#line 157
    p_tree->numleafsv = p_num_leafs_v;
#line 159
    l_num_levels = (OPJ_UINT32 )0;
#line 160
    l_nplh[0] = (OPJ_INT32 )p_num_leafs_h;
#line 161
    l_nplv[0] = (OPJ_INT32 )p_num_leafs_v;
#line 162
    p_tree->numnodes = (OPJ_UINT32 )0;
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      n = (OPJ_UINT32 )(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
#line 165
      l_nplh[l_num_levels + 1U] = (l_nplh[l_num_levels] + 1) / 2;
#line 166
      l_nplv[l_num_levels + 1U] = (l_nplv[l_num_levels] + 1) / 2;
#line 167
      p_tree->numnodes += n;
#line 168
      l_num_levels ++;
#line 163
      if (! (n > 1U)) {
#line 163
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 172
    if (p_tree->numnodes == 0U) {
      {
#line 173
      opj_tgt_destroy(p_tree);
      }
#line 174
      return ((opj_tgt_tree_t *)0);
    }
#line 176
    l_node_size = p_tree->numnodes * (OPJ_UINT32 )sizeof(opj_tgt_node_t );
#line 178
    if (l_node_size > p_tree->nodes_size) {
      {
#line 179
      __cil_tmp17 = opj_realloc(p_tree->nodes, (size_t )l_node_size);
#line 179
      new_nodes = (opj_tgt_node_t *)__cil_tmp17;
      }
#line 181
      if (! new_nodes) {
        {
#line 182
        opj_event_msg(p_manager, 1, "Not enough memory to reinitialize the tag tree\n");
#line 184
        opj_tgt_destroy(p_tree);
        }
#line 185
        return ((opj_tgt_tree_t *)0);
      }
      {
#line 187
      p_tree->nodes = new_nodes;
#line 188
      memset((char *)p_tree->nodes + p_tree->nodes_size, 0, (unsigned long )(l_node_size - p_tree->nodes_size));
#line 190
      p_tree->nodes_size = l_node_size;
      }
    }
#line 192
    l_node = p_tree->nodes;
#line 193
    l_parent_node = p_tree->nodes + p_tree->numleafsh * p_tree->numleafsv;
#line 194
    l_parent_node0 = l_parent_node;
#line 196
    i = (OPJ_UINT32 )0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 196
      if (! (i < l_num_levels - 1U)) {
#line 196
        goto while_break___0;
      }
#line 197
      j = 0;
      {
#line 197
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 197
        if (! (j < l_nplv[i])) {
#line 197
          goto while_break___1;
        }
#line 198
        k = l_nplh[i];
        {
#line 199
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 199
          k --;
#line 199
          if (! (k >= 0)) {
#line 199
            goto while_break___2;
          }
#line 200
          l_node->parent = l_parent_node;
#line 201
          l_node ++;
#line 202
          k --;
#line 202
          if (k >= 0) {
#line 203
            l_node->parent = l_parent_node;
#line 204
            l_node ++;
          }
#line 206
          l_parent_node ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 208
        if (j & 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else
#line 208
        if (j == l_nplv[i] - 1) {
#line 209
          l_parent_node0 = l_parent_node;
        } else {
#line 211
          l_parent_node = l_parent_node0;
#line 212
          l_parent_node0 += l_nplh[i];
        }
#line 197
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 196
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 216
    l_node->parent = (struct opj_tgt_node *)0;
  } else
#line 154
  if (p_tree->numleafsv != p_num_leafs_v) {
#line 154
    goto _L;
  }
  {
#line 218
  opj_tgt_reset(p_tree);
  }
#line 220
  return (p_tree);
}
}
#line 223 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
void opj_tgt_destroy(opj_tgt_tree_t *p_tree ) 
{ 


  {
#line 225
  if (! p_tree) {
#line 226
    return;
  }
#line 229
  if (p_tree->nodes) {
    {
#line 230
    opj_free(p_tree->nodes);
#line 231
    p_tree->nodes = (opj_tgt_node_t *)0;
    }
  }
  {
#line 233
  opj_free(p_tree);
  }
  return;
}
}
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
void opj_tgt_reset(opj_tgt_tree_t *p_tree ) 
{ 
  OPJ_UINT32 i ;
  opj_tgt_node_t *l_current_node ;

  {
#line 239
  l_current_node = (opj_tgt_node_t *)0;
#line 241
  if (! p_tree) {
#line 242
    return;
  }
#line 245
  l_current_node = p_tree->nodes;
#line 246
  i = (OPJ_UINT32 )0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < p_tree->numnodes)) {
#line 246
      goto while_break;
    }
#line 247
    l_current_node->value = 999;
#line 248
    l_current_node->low = 0;
#line 249
    l_current_node->known = (OPJ_UINT32 )0;
#line 250
    l_current_node ++;
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 254 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 257
  node = tree->nodes + leafno;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (node && node->value > value)) {
#line 258
      goto while_break;
    }
#line 259
    node->value = value;
#line 260
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 264 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 272
  stkptr = (opj_tgt_node_t **)stk;
#line 273
  node = tree->nodes + leafno;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! node->parent) {
#line 274
      goto while_break;
    }
#line 275
    __cil_tmp9 = stkptr;
#line 275
    stkptr ++;
#line 275
    *__cil_tmp9 = node;
#line 276
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  low = 0;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! 1) {
#line 280
      goto while_break___0;
    }
#line 281
    if (low > node->low) {
#line 282
      node->low = low;
    } else {
#line 284
      low = node->low;
    }
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 287
      if (! (low < threshold)) {
#line 287
        goto while_break___1;
      }
#line 288
      if (low >= node->value) {
#line 289
        if (! node->known) {
          {
#line 290
          opj_bio_putbit(bio, (OPJ_UINT32 )1);
#line 291
          node->known = (OPJ_UINT32 )1;
          }
        }
#line 293
        goto while_break___1;
      }
      {
#line 295
      opj_bio_putbit(bio, (OPJ_UINT32 )0);
#line 296
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 299
    node->low = low;
#line 300
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 301
      goto while_break___0;
    }
#line 303
    stkptr --;
#line 303
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 307 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.c"
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  OPJ_INT32 low ;
  opj_tgt_node_t **__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  int tmp ;

  {
#line 315
  stkptr = (opj_tgt_node_t **)stk;
#line 316
  node = tree->nodes + leafno;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! node->parent) {
#line 317
      goto while_break;
    }
#line 318
    __cil_tmp9 = stkptr;
#line 318
    stkptr ++;
#line 318
    *__cil_tmp9 = node;
#line 319
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  low = 0;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! 1) {
#line 323
      goto while_break___0;
    }
#line 324
    if (low > node->low) {
#line 325
      node->low = low;
    } else {
#line 327
      low = node->low;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 329
      if (! (low < threshold && low < node->value)) {
#line 329
        goto while_break___1;
      }
      {
#line 330
      __cil_tmp10 = opj_bio_read(bio, (OPJ_UINT32 )1);
      }
#line 330
      if (__cil_tmp10) {
#line 331
        node->value = low;
      } else {
#line 333
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 336
    node->low = low;
#line 337
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 338
      goto while_break___0;
    }
#line 340
    stkptr --;
#line 340
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 343
  if (node->value < threshold) {
#line 343
    tmp = 1;
  } else {
#line 343
    tmp = 0;
  }
#line 343
  return ((OPJ_UINT32 )tmp);
}
}
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_SIZE_T sizeof_block ,
                                           opj_event_mgr_t *manager ) ;
#line 123
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) ;
#line 129
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 134
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 140
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) ;
#line 146
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) ;
#line 149
static void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) ;
#line 156
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) ;
#line 159
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) ;
#line 166
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 169
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) ;
#line 171
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) ;
#line 174
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) ;
#line 177
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) ;
#line 179
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) ;
#line 181
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) ;
#line 183
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) ;
#line 185
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_tcd_marker_info_t *p_marker_info , opj_event_mgr_t *p_manager ) ;
#line 193
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) ;
#line 200
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) ;
#line 208 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_tcd_t *l_tcd ;
  void *__cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 210
  l_tcd = (opj_tcd_t *)0;
#line 213
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcd_t ));
#line 213
  l_tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 214
  if (! l_tcd) {
#line 215
    return ((opj_tcd_t *)0);
  }
#line 218
  if (p_is_decoder) {
#line 218
    tmp = 1;
  } else {
#line 218
    tmp = 0;
  }
  {
#line 218
  l_tcd->m_is_decoder = (OPJ_BITFIELD )tmp;
#line 220
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_image_t ));
#line 220
  l_tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp5;
  }
#line 221
  if (! l_tcd->tcd_image) {
    {
#line 222
    opj_free(l_tcd);
    }
#line 223
    return ((opj_tcd_t *)0);
  }
#line 226
  return (l_tcd);
}
}
#line 233 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  OPJ_UINT32 layno ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 237
  layno = (OPJ_UINT32 )0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 237
      goto while_break;
    }
    {
#line 238
    opj_tcd_makelayer_fixed(tcd, layno, (OPJ_UINT32 )1);
    }
#line 237
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_makelayer(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_FLOAT64 thresh ,
                                  OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 passno ;
  opj_tcd_tile_t *tcd_tile ;
  OPJ_BOOL layer_allocation_is_same ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp16 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_UINT32 dr ;
  OPJ_FLOAT64 dd ;
  opj_tcd_pass_t *pass ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;

  {
#line 256
  tcd_tile = (tcd->tcd_image)->tiles;
#line 257
  layer_allocation_is_same = 1;
#line 259
  tcd_tile->distolayer[layno] = (OPJ_FLOAT64 )0;
#line 261
  compno = (OPJ_UINT32 )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (compno < tcd_tile->numcomps)) {
#line 261
      goto while_break;
    }
#line 262
    tilec = tcd_tile->comps + compno;
#line 264
    resno = (OPJ_UINT32 )0;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! (resno < tilec->numresolutions)) {
#line 264
        goto while_break___0;
      }
#line 265
      res = tilec->resolutions + resno;
#line 267
      bandno = (OPJ_UINT32 )0;
      {
#line 267
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 267
        if (! (bandno < res->numbands)) {
#line 267
          goto while_break___1;
        }
        {
#line 268
        band = & res->bands[bandno];
#line 271
        __cil_tmp16 = opj_tcd_is_band_empty(band);
        }
#line 271
        if (__cil_tmp16) {
#line 272
          goto while_continue___1;
        }
#line 275
        precno = (OPJ_UINT32 )0;
        {
#line 275
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 275
          if (! (precno < res->pw * res->ph)) {
#line 275
            goto while_break___2;
          }
#line 276
          prc = band->precincts + precno;
#line 278
          cblkno = (OPJ_UINT32 )0;
          {
#line 278
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 278
            if (! (cblkno < prc->cw * prc->ch)) {
#line 278
              goto while_break___3;
            }
#line 279
            cblk = prc->cblks.enc + cblkno;
#line 280
            layer = cblk->layers + layno;
#line 283
            if (layno == 0U) {
#line 284
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 287
            n = cblk->numpassesinlayers;
#line 289
            if (thresh < (double )0) {
#line 291
              n = cblk->totalpasses;
            } else {
#line 293
              passno = cblk->numpassesinlayers;
              {
#line 293
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 293
                if (! (passno < cblk->totalpasses)) {
#line 293
                  goto while_break___4;
                }
#line 296
                pass = cblk->passes + passno;
#line 298
                if (n == 0U) {
#line 299
                  dr = pass->rate;
#line 300
                  dd = pass->distortiondec;
                } else {
#line 302
                  dr = pass->rate - (cblk->passes + (n - 1U))->rate;
#line 303
                  dd = pass->distortiondec - (cblk->passes + (n - 1U))->distortiondec;
                }
#line 306
                if (! dr) {
#line 307
                  if (dd != (double )0) {
#line 308
                    n = passno + 1U;
                  }
#line 310
                  goto while_continue___4;
                }
#line 312
                if (thresh - dd / (double )dr < 2.22044604926e-16) {
#line 314
                  n = passno + 1U;
                }
#line 293
                passno ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            }
#line 319
            if (layer->numpasses != n - cblk->numpassesinlayers) {
#line 320
              layer_allocation_is_same = 0;
#line 321
              layer->numpasses = n - cblk->numpassesinlayers;
            }
#line 324
            if (! layer->numpasses) {
#line 325
              layer->disto = (OPJ_FLOAT64 )0;
#line 326
              goto while_continue___3;
            }
#line 329
            if (cblk->numpassesinlayers == 0U) {
#line 330
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 331
              layer->data = cblk->data;
#line 332
              layer->disto = (cblk->passes + (n - 1U))->distortiondec;
            } else {
#line 334
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 336
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 337
              layer->disto = (cblk->passes + (n - 1U))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1U))->distortiondec;
            }
#line 341
            tcd_tile->distolayer[layno] += layer->disto;
#line 343
            if (final) {
#line 344
              cblk->numpassesinlayers = n;
            }
#line 278
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 275
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 267
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 264
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return (layer_allocation_is_same);
}
}
#line 356 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static void opj_tcd_makelayer_fixed(opj_tcd_t *tcd , OPJ_UINT32 layno , OPJ_UINT32 final ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_INT32 value ;
  OPJ_INT32 matrice[10][10][3] ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp23 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  OPJ_UINT32 n ;
  OPJ_INT32 imsb ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;

  {
#line 364
  cp = tcd->cp;
#line 365
  tcd_tile = (tcd->tcd_image)->tiles;
#line 366
  tcd_tcp = tcd->tcp;
#line 368
  compno = (OPJ_UINT32 )0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (compno < tcd_tile->numcomps)) {
#line 368
      goto while_break;
    }
#line 369
    tilec = tcd_tile->comps + compno;
#line 371
    i = (OPJ_UINT32 )0;
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (i < tcd_tcp->numlayers)) {
#line 371
        goto while_break___0;
      }
#line 372
      j = (OPJ_UINT32 )0;
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        if (! (j < tilec->numresolutions)) {
#line 372
          goto while_break___1;
        }
#line 373
        k = (OPJ_UINT32 )0;
        {
#line 373
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 373
          if (! (k < 3U)) {
#line 373
            goto while_break___2;
          }
#line 374
          matrice[i][j][k] = (OPJ_INT32 )((OPJ_FLOAT32 )*(cp->m_specific_param.m_enc.m_matrice + (((i * tilec->numresolutions) * 3U + j * 3U) + k)) * (OPJ_FLOAT32 )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 373
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 372
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 371
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 382
    resno = (OPJ_UINT32 )0;
    {
#line 382
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 382
      if (! (resno < tilec->numresolutions)) {
#line 382
        goto while_break___3;
      }
#line 383
      res = tilec->resolutions + resno;
#line 385
      bandno = (OPJ_UINT32 )0;
      {
#line 385
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 385
        if (! (bandno < res->numbands)) {
#line 385
          goto while_break___4;
        }
        {
#line 386
        band = & res->bands[bandno];
#line 389
        __cil_tmp23 = opj_tcd_is_band_empty(band);
        }
#line 389
        if (__cil_tmp23) {
#line 390
          goto while_continue___4;
        }
#line 393
        precno = (OPJ_UINT32 )0;
        {
#line 393
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 393
          if (! (precno < res->pw * res->ph)) {
#line 393
            goto while_break___5;
          }
#line 394
          prc = band->precincts + precno;
#line 396
          cblkno = (OPJ_UINT32 )0;
          {
#line 396
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 396
            if (! (cblkno < prc->cw * prc->ch)) {
#line 396
              goto while_break___6;
            }
#line 397
            cblk = prc->cblks.enc + cblkno;
#line 398
            layer = cblk->layers + layno;
#line 400
            imsb = (OPJ_INT32 )(((tcd->image)->comps + compno)->prec - cblk->numbps);
#line 404
            if (layno == 0U) {
#line 405
              value = matrice[layno][resno][bandno];
#line 406
              if (imsb >= value) {
#line 407
                value = 0;
              } else {
#line 409
                value -= imsb;
              }
            } else {
#line 412
              value = matrice[layno][resno][bandno] - matrice[layno - 1U][resno][bandno];
#line 413
              if (imsb >= matrice[layno - 1U][resno][bandno]) {
#line 414
                value -= imsb - matrice[layno - 1U][resno][bandno];
#line 415
                if (value < 0) {
#line 416
                  value = 0;
                }
              }
            }
#line 421
            if (layno == 0U) {
#line 422
              cblk->numpassesinlayers = (OPJ_UINT32 )0;
            }
#line 425
            n = cblk->numpassesinlayers;
#line 426
            if (cblk->numpassesinlayers == 0U) {
#line 427
              if (value != 0) {
#line 428
                n = (3U * (OPJ_UINT32 )value - 2U) + cblk->numpassesinlayers;
              } else {
#line 430
                n = cblk->numpassesinlayers;
              }
            } else {
#line 433
              n = 3U * (OPJ_UINT32 )value + cblk->numpassesinlayers;
            }
#line 436
            layer->numpasses = n - cblk->numpassesinlayers;
#line 438
            if (! layer->numpasses) {
#line 439
              goto while_continue___6;
            }
#line 442
            if (cblk->numpassesinlayers == 0U) {
#line 443
              layer->len = (cblk->passes + (n - 1U))->rate;
#line 444
              layer->data = cblk->data;
            } else {
#line 446
              layer->len = (cblk->passes + (n - 1U))->rate - (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
#line 448
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1U))->rate;
            }
#line 451
            if (final) {
#line 452
              cblk->numpassesinlayers = n;
            }
#line 396
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 393
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 385
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 382
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 368
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 466 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_rateallocate(opj_tcd_t *tcd , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 passno ;
  OPJ_FLOAT64 min ;
  OPJ_FLOAT64 max ;
  OPJ_FLOAT64 cumdisto[100] ;
  OPJ_FLOAT64 K ;
  OPJ_FLOAT64 maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  OPJ_BOOL __cil_tmp25 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  OPJ_INT32 dr ;
  OPJ_FLOAT64 dd ;
  OPJ_FLOAT64 rdslope ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_SIZE_T cblk_pix_count ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 __cil_tmp38 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp40 ;
  OPJ_FLOAT64 lo ;
  OPJ_FLOAT64 hi ;
  OPJ_UINT32 maxlen ;
  double __cil_tmp44 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 tmp ;
  OPJ_FLOAT64 goodthresh ;
  OPJ_FLOAT64 stable_thresh ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 distotarget ;
  double __cil_tmp51 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp53 ;
  OPJ_FLOAT64 thresh ;
  OPJ_BOOL last_layer_allocation_ok ;
  OPJ_FLOAT64 distoachieved ;
  OPJ_BOOL layer_allocation_is_same ;
  OPJ_FLOAT64 new_thresh ;
  double __cil_tmp59 ;
  OPJ_BOOL __cil_tmp60 ;
  OPJ_BOOL __cil_tmp61 ;
  OPJ_FLOAT64 tmp___0 ;
  OPJ_FLOAT64 tmp___1 ;
  OPJ_BOOL __cil_tmp64 ;
  OPJ_FLOAT64 tmp___2 ;
  OPJ_FLOAT64 tmp___3 ;
  OPJ_UINT32 __cil_tmp67 ;

  {
#line 477
  K = (OPJ_FLOAT64 )1;
#line 478
  maxSE = (OPJ_FLOAT64 )0;
#line 480
  cp = tcd->cp;
#line 481
  tcd_tile = (tcd->tcd_image)->tiles;
#line 482
  tcd_tcp = tcd->tcp;
#line 484
  min = 1.79769313487e+308;
#line 485
  max = (OPJ_FLOAT64 )0;
#line 487
  tcd_tile->numpix = (OPJ_SIZE_T )0;
#line 489
  compno = (OPJ_UINT32 )0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (compno < tcd_tile->numcomps)) {
#line 489
      goto while_break;
    }
#line 490
    tilec = tcd_tile->comps + compno;
#line 491
    tilec->numpix = (OPJ_SIZE_T )0;
#line 493
    resno = (OPJ_UINT32 )0;
    {
#line 493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 493
      if (! (resno < tilec->numresolutions)) {
#line 493
        goto while_break___0;
      }
#line 494
      res = tilec->resolutions + resno;
#line 496
      bandno = (OPJ_UINT32 )0;
      {
#line 496
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 496
        if (! (bandno < res->numbands)) {
#line 496
          goto while_break___1;
        }
        {
#line 497
        band = & res->bands[bandno];
#line 500
        __cil_tmp25 = opj_tcd_is_band_empty(band);
        }
#line 500
        if (__cil_tmp25) {
#line 501
          goto while_continue___1;
        }
#line 504
        precno = (OPJ_UINT32 )0;
        {
#line 504
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 504
          if (! (precno < res->pw * res->ph)) {
#line 504
            goto while_break___2;
          }
#line 505
          prc = band->precincts + precno;
#line 507
          cblkno = (OPJ_UINT32 )0;
          {
#line 507
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 507
            if (! (cblkno < prc->cw * prc->ch)) {
#line 507
              goto while_break___3;
            }
#line 508
            cblk = prc->cblks.enc + cblkno;
#line 510
            passno = (OPJ_UINT32 )0;
            {
#line 510
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 510
              if (! (passno < cblk->totalpasses)) {
#line 510
                goto while_break___4;
              }
#line 511
              pass = cblk->passes + passno;
#line 515
              if (passno == 0U) {
#line 516
                dr = (OPJ_INT32 )pass->rate;
#line 517
                dd = pass->distortiondec;
              } else {
#line 519
                dr = (OPJ_INT32 )(pass->rate - (cblk->passes + (passno - 1U))->rate);
#line 520
                dd = pass->distortiondec - (cblk->passes + (passno - 1U))->distortiondec;
              }
#line 523
              if (dr == 0) {
#line 524
                goto while_continue___4;
              }
#line 527
              rdslope = dd / (double )dr;
#line 528
              if (rdslope < min) {
#line 529
                min = rdslope;
              }
#line 532
              if (rdslope > max) {
#line 533
                max = rdslope;
              }
#line 510
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 538
            cblk_pix_count = (OPJ_SIZE_T )((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
#line 540
            tcd_tile->numpix += cblk_pix_count;
#line 541
            tilec->numpix += cblk_pix_count;
#line 507
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 504
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 496
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 493
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 548
    maxSE += (((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((OPJ_FLOAT64 )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (OPJ_FLOAT64 )tilec->numpix;
#line 489
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  if (cstr_info) {
    {
#line 555
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 556
    tile_info->numpix = (int )tcd_tile->numpix;
#line 557
    tile_info->distotile = (double )((int )tcd_tile->distotile);
#line 558
    __cil_tmp40 = opj_malloc((unsigned long )tcd_tcp->numlayers * sizeof(OPJ_FLOAT64 ));
#line 558
    tile_info->thresh = (OPJ_FLOAT64 *)__cil_tmp40;
    }
#line 560
    if (! tile_info->thresh) {
#line 562
      return (0);
    }
  }
#line 566
  layno = (OPJ_UINT32 )0;
  {
#line 566
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 566
    if (! (layno < tcd_tcp->numlayers)) {
#line 566
      goto while_break___5;
    }
#line 567
    lo = min;
#line 568
    hi = max;
#line 569
    if (tcd_tcp->rates[layno] > 0.f) {
      {
#line 569
      __cil_tmp44 = ceil((double )tcd_tcp->rates[layno]);
#line 569
      __cil_tmp45 = opj_uint_min((OPJ_UINT32 )__cil_tmp44, len);
#line 569
      tmp = __cil_tmp45;
      }
    } else {
#line 569
      tmp = len;
    }
    {
#line 569
    maxlen = tmp;
#line 571
    goodthresh = (OPJ_FLOAT64 )0;
#line 572
    stable_thresh = (OPJ_FLOAT64 )0;
#line 576
    __cil_tmp51 = pow((double )((OPJ_FLOAT32 )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 576
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp51;
    }
#line 583
    if ((unsigned int )cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 0U) {
#line 583
      if (tcd_tcp->rates[layno] > 0.f) {
        _L___3: /* CIL Label */ 
        {
#line 589
        __cil_tmp53 = opj_t2_create(tcd->image, cp);
#line 589
        t2 = __cil_tmp53;
#line 590
        thresh = (OPJ_FLOAT64 )0;
#line 591
        last_layer_allocation_ok = 0;
        }
#line 593
        if (t2 == (opj_t2_t *)0) {
#line 594
          return (0);
        }
#line 597
        i = (OPJ_UINT32 )0;
        {
#line 597
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 597
          if (! (i < 128U)) {
#line 597
            goto while_break___6;
          }
          {
#line 598
          distoachieved = (OPJ_FLOAT64 )0;
#line 601
          new_thresh = (lo + hi) / (double )2;
#line 606
          __cil_tmp59 = fabs(new_thresh - thresh);
          }
#line 606
          if (__cil_tmp59 <= (0.5 * 1.00000000001e-05) * thresh) {
#line 607
            goto while_break___6;
          }
          {
#line 609
          thresh = new_thresh;
#line 615
          __cil_tmp60 = opj_tcd_makelayer(tcd, layno, thresh, (OPJ_UINT32 )0);
#line 615
          layer_allocation_is_same = __cil_tmp60 && i != 0U;
          }
#line 620
          if ((unsigned int )cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 1U) {
#line 622
            if ((int )cp->rsiz >= 3) {
#line 622
              if ((int )cp->rsiz <= 6) {
                _L: /* CIL Label */ 
                {
#line 623
                __cil_tmp61 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile,
                                                    layno + 1U, dest, p_data_written,
                                                    maxlen, cstr_info, (opj_tcd_marker_info_t *)((void *)0),
                                                    tcd->cur_tp_num, tcd->tp_pos,
                                                    tcd->cur_pino, (J2K_T2_MODE )0,
                                                    p_manager);
                }
#line 623
                if (! __cil_tmp61) {
#line 628
                  lo = thresh;
#line 629
                  goto while_continue___6;
                } else {
#line 631
                  if (layno == 0U) {
#line 631
                    tmp___0 = tcd_tile->distolayer[0];
                  } else {
#line 631
                    tmp___0 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
                  }
#line 631
                  distoachieved = tmp___0;
#line 634
                  if (distoachieved < distotarget) {
#line 635
                    hi = thresh;
#line 636
                    stable_thresh = thresh;
#line 637
                    goto while_continue___6;
                  } else {
#line 639
                    lo = thresh;
                  }
                }
              } else {
#line 622
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 622
            if ((int )cp->rsiz >= 1024) {
#line 622
              if ((int )cp->rsiz <= 2459) {
#line 622
                goto _L;
              } else {
#line 622
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 643
              if (layno == 0U) {
#line 643
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 643
                tmp___1 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
              }
#line 643
              distoachieved = tmp___1;
#line 646
              if (distoachieved < distotarget) {
#line 647
                hi = thresh;
#line 648
                stable_thresh = thresh;
#line 649
                goto while_continue___6;
              }
#line 651
              lo = thresh;
            }
          } else {
            {
#line 661
            __cil_tmp64 = opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1U,
                                                dest, p_data_written, maxlen, cstr_info,
                                                (opj_tcd_marker_info_t *)((void *)0),
                                                tcd->cur_tp_num, tcd->tp_pos, tcd->cur_pino,
                                                (J2K_T2_MODE )0, p_manager);
            }
#line 661
            if (layer_allocation_is_same) {
#line 661
              if (! last_layer_allocation_ok) {
#line 674
                last_layer_allocation_ok = 0;
#line 675
                lo = thresh;
#line 676
                goto while_continue___6;
              } else {
#line 661
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 661
            if (! layer_allocation_is_same) {
#line 661
              if (! __cil_tmp64) {
#line 674
                last_layer_allocation_ok = 0;
#line 675
                lo = thresh;
#line 676
                goto while_continue___6;
              }
            }
#line 687
            last_layer_allocation_ok = 1;
#line 688
            hi = thresh;
#line 689
            stable_thresh = thresh;
          }
#line 597
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 693
        if (stable_thresh == (double )0) {
#line 693
          tmp___2 = thresh;
        } else {
#line 693
          tmp___2 = stable_thresh;
        }
        {
#line 693
        goodthresh = tmp___2;
#line 695
        opj_t2_destroy(t2);
        }
      } else {
#line 583
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 583
    if ((unsigned int )cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 1U) {
#line 583
      if ((double )tcd_tcp->distoratio[layno] > 0.) {
#line 583
        goto _L___3;
      } else {
#line 698
        goodthresh = (OPJ_FLOAT64 )(- 1);
      }
    } else {
#line 698
      goodthresh = (OPJ_FLOAT64 )(- 1);
    }
#line 701
    if (cstr_info) {
#line 702
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 705
    opj_tcd_makelayer(tcd, layno, goodthresh, (OPJ_UINT32 )1);
    }
#line 707
    if (layno == 0U) {
#line 707
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 707
      tmp___3 = cumdisto[layno - 1U] + tcd_tile->distolayer[layno];
    }
#line 707
    cumdisto[layno] = tmp___3;
#line 566
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 711
  return (1);
}
}
#line 714 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) 
{ 
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 719
  p_tcd->image = p_image;
#line 720
  p_tcd->cp = p_cp;
#line 722
  __cil_tmp5 = opj_calloc((size_t )1, sizeof(opj_tcd_tile_t ));
#line 722
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp5;
  }
#line 724
  if (! (p_tcd->tcd_image)->tiles) {
#line 725
    return (0);
  }
  {
#line 728
  __cil_tmp6 = opj_calloc((size_t )p_image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 728
  ((p_tcd->tcd_image)->tiles)->comps = (opj_tcd_tilecomp_t *)__cil_tmp6;
  }
#line 730
  if (! ((p_tcd->tcd_image)->tiles)->comps) {
#line 731
    return (0);
  }
#line 734
  ((p_tcd->tcd_image)->tiles)->numcomps = p_image->numcomps;
#line 735
  p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
#line 736
  p_tcd->thread_pool = p_tp;
#line 738
  return (1);
}
}
#line 744 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
void opj_tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 746
  if (tcd) {
    {
#line 747
    opj_tcd_free_tile(tcd);
    }
#line 749
    if (tcd->tcd_image) {
      {
#line 750
      opj_free(tcd->tcd_image);
#line 751
      tcd->tcd_image = (opj_tcd_image_t *)0;
      }
    }
    {
#line 754
    opj_free(tcd->used_component);
#line 756
    opj_free(tcd);
    }
  }
  return;
}
}
#line 760 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 762
  if (l_tilec->data == (OPJ_INT32 *)0) {
    _L: /* CIL Label */ 
    {
#line 765
    __cil_tmp2 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 765
    l_tilec->data = (OPJ_INT32 *)__cil_tmp2;
    }
#line 766
    if (! l_tilec->data) {
#line 766
      if (l_tilec->data_size_needed != 0UL) {
#line 767
        return (0);
      }
    }
#line 770
    l_tilec->data_size = l_tilec->data_size_needed;
#line 771
    l_tilec->ownsData = 1;
  } else
#line 762
  if (l_tilec->data_size_needed > l_tilec->data_size) {
#line 762
    if (l_tilec->ownsData == 0) {
#line 762
      goto _L;
    } else {
#line 762
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 772
  if (l_tilec->data_size_needed > l_tilec->data_size) {
    {
#line 774
    opj_image_data_free(l_tilec->data);
#line 775
    __cil_tmp3 = opj_image_data_alloc(l_tilec->data_size_needed);
#line 775
    l_tilec->data = (OPJ_INT32 *)__cil_tmp3;
    }
#line 776
    if (! l_tilec->data) {
#line 777
      l_tilec->data_size = (size_t )0;
#line 778
      l_tilec->data_size_needed = (size_t )0;
#line 779
      l_tilec->ownsData = 0;
#line 780
      return (0);
    }
#line 783
    l_tilec->data_size = l_tilec->data_size_needed;
#line 784
    l_tilec->ownsData = 1;
  }
#line 786
  return (1);
}
}
#line 791 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
__inline static OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no ,
                                           OPJ_BOOL isEncoder , OPJ_SIZE_T sizeof_block ,
                                           opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 cblkno ;
  opj_tcp_t *l_tcp ;
  opj_cp_t *l_cp ;
  opj_tcd_tile_t *l_tile ;
  opj_tccp_t *l_tccp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_image_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_stepsize_t *l_step_size ;
  opj_tcd_precinct_t *l_current_precinct ;
  opj_image_t *l_image ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_INT32 l_x0b ;
  OPJ_INT32 l_y0b ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_INT32 l_tl_prc_x_start ;
  OPJ_INT32 l_tl_prc_y_start ;
  OPJ_INT32 l_br_prc_x_end ;
  OPJ_INT32 l_br_prc_y_end ;
  OPJ_UINT32 l_nb_precincts ;
  OPJ_UINT32 l_nb_precinct_size ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_nb_code_blocks_size ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 __cil_tmp44 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_INT32 __cil_tmp46 ;
  OPJ_INT32 __cil_tmp47 ;
  OPJ_INT32 __cil_tmp48 ;
  OPJ_INT32 __cil_tmp49 ;
  OPJ_SIZE_T l_tile_data_size ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  void *__cil_tmp53 ;
  opj_tcd_resolution_t *new_resolutions ;
  void *__cil_tmp55 ;
  OPJ_INT32 tlcbgxstart ;
  OPJ_INT32 tlcbgystart ;
  OPJ_UINT32 cbgwidthexpn ;
  OPJ_UINT32 cbgheightexpn ;
  OPJ_UINT32 cblkwidthexpn ;
  OPJ_UINT32 cblkheightexpn ;
  OPJ_INT32 __cil_tmp62 ;
  OPJ_INT32 __cil_tmp63 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  OPJ_INT32 __cil_tmp66 ;
  OPJ_INT32 __cil_tmp67 ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp69 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_INT32 __cil_tmp71 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  OPJ_INT32 __cil_tmp74 ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_UINT32 __cil_tmp76 ;
  OPJ_UINT32 __cil_tmp77 ;
  OPJ_INT32 __cil_tmp78 ;
  OPJ_INT32 __cil_tmp79 ;
  OPJ_INT32 __cil_tmp80 ;
  OPJ_INT32 __cil_tmp81 ;
  OPJ_INT32 __cil_tmp82 ;
  OPJ_INT32 __cil_tmp83 ;
  OPJ_INT32 __cil_tmp84 ;
  OPJ_INT32 __cil_tmp85 ;
  OPJ_BOOL __cil_tmp86 ;
  OPJ_INT32 log2_gain ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  OPJ_INT32 Rb ;
  double __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tcd_precinct_t *new_precincts ;
  void *__cil_tmp95 ;
  OPJ_INT32 tlcblkxstart ;
  OPJ_INT32 tlcblkystart ;
  OPJ_INT32 brcblkxend ;
  OPJ_INT32 brcblkyend ;
  OPJ_INT32 cbgxstart ;
  OPJ_INT32 cbgystart ;
  OPJ_INT32 cbgxend ;
  OPJ_INT32 cbgyend ;
  OPJ_INT32 __cil_tmp104 ;
  OPJ_INT32 __cil_tmp105 ;
  OPJ_INT32 __cil_tmp106 ;
  OPJ_INT32 __cil_tmp107 ;
  OPJ_INT32 __cil_tmp108 ;
  OPJ_INT32 __cil_tmp109 ;
  OPJ_INT32 __cil_tmp110 ;
  OPJ_INT32 __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *new_blocks ;
  void *__cil_tmp114 ;
  opj_tgt_tree_t *__cil_tmp115 ;
  opj_tgt_tree_t *__cil_tmp116 ;
  opj_tgt_tree_t *__cil_tmp117 ;
  opj_tgt_tree_t *__cil_tmp118 ;
  OPJ_INT32 cblkxstart ;
  OPJ_INT32 cblkystart ;
  OPJ_INT32 cblkxend ;
  OPJ_INT32 cblkyend ;
  opj_tcd_cblk_enc_t *l_code_block ;
  OPJ_BOOL __cil_tmp124 ;
  OPJ_INT32 __cil_tmp125 ;
  OPJ_INT32 __cil_tmp126 ;
  OPJ_INT32 __cil_tmp127 ;
  OPJ_INT32 __cil_tmp128 ;
  OPJ_BOOL __cil_tmp129 ;
  opj_tcd_cblk_dec_t *l_code_block___0 ;
  OPJ_BOOL __cil_tmp131 ;
  OPJ_INT32 __cil_tmp132 ;
  OPJ_INT32 __cil_tmp133 ;
  OPJ_INT32 __cil_tmp134 ;
  OPJ_INT32 __cil_tmp135 ;

  {
  {
#line 796
  l_tcp = (opj_tcp_t *)0;
#line 797
  l_cp = (opj_cp_t *)0;
#line 798
  l_tile = (opj_tcd_tile_t *)0;
#line 799
  l_tccp = (opj_tccp_t *)0;
#line 800
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 801
  l_image_comp = (opj_image_comp_t *)0;
#line 802
  l_res = (opj_tcd_resolution_t *)0;
#line 803
  l_band = (opj_tcd_band_t *)0;
#line 804
  l_step_size = (opj_stepsize_t *)0;
#line 805
  l_current_precinct = (opj_tcd_precinct_t *)0;
#line 806
  l_image = (opj_image_t *)0;
#line 825
  l_cp = p_tcd->cp;
#line 826
  l_tcp = l_cp->tcps + p_tile_no;
#line 827
  l_tile = (p_tcd->tcd_image)->tiles;
#line 828
  l_tccp = l_tcp->tccps;
#line 829
  l_tilec = l_tile->comps;
#line 830
  l_image = p_tcd->image;
#line 831
  l_image_comp = (p_tcd->image)->comps;
#line 833
  p = p_tile_no % l_cp->tw;
#line 834
  q = p_tile_no / l_cp->tw;
#line 838
  l_tx0 = l_cp->tx0 + p * l_cp->tdx;
#line 840
  __cil_tmp40 = opj_uint_max(l_tx0, l_image->x0);
#line 840
  l_tile->x0 = (OPJ_INT32 )__cil_tmp40;
#line 841
  __cil_tmp41 = opj_uint_adds(l_tx0, l_cp->tdx);
#line 841
  __cil_tmp42 = opj_uint_min(__cil_tmp41, l_image->x1);
#line 841
  l_tile->x1 = (OPJ_INT32 )__cil_tmp42;
  }
#line 844
  if (l_tile->x0 < 0) {
    {
    {
#line 845
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\nV");
    }
    }
#line 846
    return (0);
  } else
#line 844
  if (l_tile->x1 <= l_tile->x0) {
    {
    {
#line 845
    opj_event_msg(manager, 1, "Tile X coordinates are not supported\nV");
    }
    }
#line 846
    return (0);
  }
  {
#line 848
  l_ty0 = l_cp->ty0 + q * l_cp->tdy;
#line 850
  __cil_tmp43 = opj_uint_max(l_ty0, l_image->y0);
#line 850
  l_tile->y0 = (OPJ_INT32 )__cil_tmp43;
#line 851
  __cil_tmp44 = opj_uint_adds(l_ty0, l_cp->tdy);
#line 851
  __cil_tmp45 = opj_uint_min(__cil_tmp44, l_image->y1);
#line 851
  l_tile->y1 = (OPJ_INT32 )__cil_tmp45;
  }
#line 854
  if (l_tile->y0 < 0) {
    {
    {
#line 855
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\nV");
    }
    }
#line 856
    return (0);
  } else
#line 854
  if (l_tile->y1 <= l_tile->y0) {
    {
    {
#line 855
    opj_event_msg(manager, 1, "Tile Y coordinates are not supported\nV");
    }
    }
#line 856
    return (0);
  }
#line 861
  if (l_tccp->numresolutions == 0U) {
    {
#line 862
    opj_event_msg(manager, 1, "tiles require at least one resolution\n");
    }
#line 863
    return (0);
  }
#line 868
  compno = (OPJ_UINT32 )0;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    if (! (compno < l_tile->numcomps)) {
#line 868
      goto while_break;
    }
    {
#line 870
    l_image_comp->resno_decoded = (OPJ_UINT32 )0;
#line 872
    l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32 )l_image_comp->dx);
#line 873
    l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32 )l_image_comp->dy);
#line 874
    l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32 )l_image_comp->dx);
#line 875
    l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32 )l_image_comp->dy);
#line 876
    l_tilec->compno = compno;
#line 879
    l_tilec->numresolutions = l_tccp->numresolutions;
    }
#line 880
    if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
#line 881
      l_tilec->minimum_num_resolutions = (OPJ_UINT32 )1;
    } else {
#line 883
      l_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;
    }
#line 887
    if (isEncoder) {
#line 891
      w = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0);
#line 892
      h = (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 895
      if (h > 0UL) {
#line 895
        if (w > 0xffffffffffffffffUL / h) {
          {
#line 896
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 897
          return (0);
        }
      }
#line 899
      l_tile_data_size = w * h;
#line 901
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_tile_data_size) {
        {
#line 902
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 903
        return (0);
      }
#line 905
      l_tile_data_size *= sizeof(OPJ_UINT32 );
#line 907
      l_tilec->data_size_needed = l_tile_data_size;
    }
    {
#line 910
    l_data_size = l_tilec->numresolutions * (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 913
    opj_image_data_free(l_tilec->data_win);
#line 914
    l_tilec->data_win = (OPJ_INT32 *)((void *)0);
#line 915
    l_tilec->win_x0 = (OPJ_UINT32 )0;
#line 916
    l_tilec->win_y0 = (OPJ_UINT32 )0;
#line 917
    l_tilec->win_x1 = (OPJ_UINT32 )0;
#line 918
    l_tilec->win_y1 = (OPJ_UINT32 )0;
    }
#line 920
    if (l_tilec->resolutions == (opj_tcd_resolution_t *)0) {
      {
#line 921
      __cil_tmp53 = opj_malloc((size_t )l_data_size);
#line 921
      l_tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp53;
      }
#line 922
      if (! l_tilec->resolutions) {
#line 923
        return (0);
      }
      {
#line 926
      l_tilec->resolutions_size = l_data_size;
#line 927
      memset(l_tilec->resolutions, 0, (unsigned long )l_data_size);
      }
    } else
#line 928
    if (l_data_size > l_tilec->resolutions_size) {
      {
#line 929
      __cil_tmp55 = opj_realloc(l_tilec->resolutions, (size_t )l_data_size);
#line 929
      new_resolutions = (opj_tcd_resolution_t *)__cil_tmp55;
      }
#line 931
      if (! new_resolutions) {
        {
#line 932
        opj_event_msg(manager, 1, "Not enough memory for tile resolutions\n");
#line 933
        opj_free(l_tilec->resolutions);
#line 934
        l_tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
#line 935
        l_tilec->resolutions_size = (OPJ_UINT32 )0;
        }
#line 936
        return (0);
      }
      {
#line 938
      l_tilec->resolutions = new_resolutions;
#line 940
      memset((OPJ_BYTE *)l_tilec->resolutions + l_tilec->resolutions_size, 0, (unsigned long )(l_data_size - l_tilec->resolutions_size));
#line 942
      l_tilec->resolutions_size = l_data_size;
      }
    }
#line 945
    l_level_no = l_tilec->numresolutions;
#line 946
    l_res = l_tilec->resolutions;
#line 947
    l_step_size = (opj_stepsize_t *)l_tccp->stepsizes;
#line 950
    resno = (OPJ_UINT32 )0;
    {
#line 950
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 950
      if (! (resno < l_tilec->numresolutions)) {
#line 950
        goto while_break___0;
      }
      {
#line 956
      l_level_no --;
#line 959
      l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 960
      l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 961
      l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 962
      l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
#line 966
      l_pdx = l_tccp->prcw[resno];
#line 967
      l_pdy = l_tccp->prch[resno];
#line 970
      __cil_tmp66 = opj_int_floordivpow2(l_res->x0, (OPJ_INT32 )l_pdx);
#line 970
      l_tl_prc_x_start = __cil_tmp66 << l_pdx;
#line 971
      __cil_tmp67 = opj_int_floordivpow2(l_res->y0, (OPJ_INT32 )l_pdy);
#line 971
      l_tl_prc_y_start = __cil_tmp67 << l_pdy;
#line 973
      __cil_tmp69 = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32 )l_pdx);
#line 973
      tmp = (OPJ_UINT32 )__cil_tmp69 << l_pdx;
      }
#line 975
      if (tmp > 2147483647U) {
        {
#line 976
        opj_event_msg(manager, 1, "Integer overflow\n");
        }
#line 977
        return (0);
      }
      {
#line 979
      l_br_prc_x_end = (OPJ_INT32 )tmp;
#line 982
      __cil_tmp71 = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32 )l_pdy);
#line 982
      tmp___0 = (OPJ_UINT32 )__cil_tmp71 << l_pdy;
      }
#line 984
      if (tmp___0 > 2147483647U) {
        {
#line 985
        opj_event_msg(manager, 1, "Integer overflow\n<@}EV");
        }
#line 986
        return (0);
      }
#line 988
      l_br_prc_y_end = (OPJ_INT32 )tmp___0;
#line 992
      if (l_res->x0 == l_res->x1) {
#line 992
        tmp___1 = 0U;
      } else {
#line 992
        tmp___1 = (OPJ_UINT32 )((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
      }
#line 992
      l_res->pw = tmp___1;
#line 994
      if (l_res->y0 == l_res->y1) {
#line 994
        tmp___2 = 0U;
      } else {
#line 994
        tmp___2 = (OPJ_UINT32 )((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
      }
#line 994
      l_res->ph = tmp___2;
#line 998
      if (l_res->pw != 0U) {
#line 998
        if (4294967295U / l_res->pw < l_res->ph) {
          {
#line 999
          opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 1000
          return (0);
        }
      }
#line 1002
      l_nb_precincts = l_res->pw * l_res->ph;
#line 1004
      if (4294967295U / (OPJ_UINT32 )sizeof(opj_tcd_precinct_t ) < l_nb_precincts) {
        {
#line 1006
        opj_event_msg(manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1007
        return (0);
      }
#line 1009
      l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 1011
      if (resno == 0U) {
#line 1012
        tlcbgxstart = l_tl_prc_x_start;
#line 1013
        tlcbgystart = l_tl_prc_y_start;
#line 1016
        cbgwidthexpn = l_pdx;
#line 1017
        cbgheightexpn = l_pdy;
#line 1018
        l_res->numbands = (OPJ_UINT32 )1;
      } else {
        {
#line 1020
        tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
#line 1021
        tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
#line 1024
        cbgwidthexpn = l_pdx - 1U;
#line 1025
        cbgheightexpn = l_pdy - 1U;
#line 1026
        l_res->numbands = (OPJ_UINT32 )3;
        }
      }
      {
#line 1029
      cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
#line 1030
      cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
#line 1031
      l_band = (opj_tcd_band_t *)l_res->bands;
#line 1033
      bandno = (OPJ_UINT32 )0;
      }
      {
#line 1033
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1033
        if (! (bandno < l_res->numbands)) {
#line 1033
          goto while_break___1;
        }
#line 1036
        if (resno == 0U) {
          {
#line 1037
          l_band->bandno = (OPJ_UINT32 )0;
#line 1038
          l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32 )l_level_no);
#line 1039
          l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32 )l_level_no);
#line 1040
          l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32 )l_level_no);
#line 1041
          l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32 )l_level_no);
          }
        } else {
          {
#line 1043
          l_band->bandno = bandno + 1U;
#line 1045
          l_x0b = (OPJ_INT32 )(l_band->bandno & 1U);
#line 1047
          l_y0b = (OPJ_INT32 )(l_band->bandno >> 1);
#line 1049
          l_band->x0 = opj_int64_ceildivpow2((long )l_tilec->x0 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 1051
          l_band->y0 = opj_int64_ceildivpow2((long )l_tilec->y0 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 1053
          l_band->x1 = opj_int64_ceildivpow2((long )l_tilec->x1 - ((OPJ_INT64 )l_x0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
#line 1055
          l_band->y1 = opj_int64_ceildivpow2((long )l_tilec->y1 - ((OPJ_INT64 )l_y0b << l_level_no),
                                             (OPJ_INT32 )(l_level_no + 1U));
          }
        }
#line 1059
        if (isEncoder) {
          {
#line 1061
          __cil_tmp86 = opj_tcd_is_band_empty(l_band);
          }
#line 1061
          if (__cil_tmp86) {
#line 1065
            goto while_continue___1;
          }
        }
#line 1074
        if (! isEncoder && l_tccp->qmfbid == 0U) {
#line 1074
          tmp___5 = 0;
        } else {
#line 1074
          if (l_band->bandno == 0U) {
#line 1074
            tmp___4 = 0;
          } else {
#line 1074
            if (l_band->bandno == 3U) {
#line 1074
              tmp___3 = 2;
            } else {
#line 1074
              tmp___3 = 1;
            }
#line 1074
            tmp___4 = tmp___3;
          }
#line 1074
          tmp___5 = tmp___4;
        }
        {
#line 1074
        log2_gain = tmp___5;
#line 1079
        Rb = (OPJ_INT32 )l_image_comp->prec + log2_gain;
#line 1083
        __cil_tmp92 = pow(2., (double )((OPJ_INT32 )(Rb - l_step_size->expn)));
#line 1083
        l_band->stepsize = (OPJ_FLOAT32 )((1. + (double )l_step_size->mant / 2048.) * __cil_tmp92);
#line 1089
        l_band->numbps = (l_step_size->expn + (OPJ_INT32 )l_tccp->numgbits) - 1;
        }
#line 1092
        if (! l_band->precincts) {
#line 1092
          if (l_nb_precincts > 0U) {
            {
#line 1093
            __cil_tmp93 = opj_malloc((size_t )l_nb_precinct_size);
#line 1093
            l_band->precincts = (opj_tcd_precinct_t *)__cil_tmp93;
            }
#line 1095
            if (! l_band->precincts) {
              {
#line 1096
              opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
              }
#line 1098
              return (0);
            }
            {
#line 1101
            memset(l_band->precincts, 0, (unsigned long )l_nb_precinct_size);
#line 1102
            l_band->precincts_data_size = l_nb_precinct_size;
            }
          } else {
#line 1092
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1103
        if (l_band->precincts_data_size < l_nb_precinct_size) {
          {
#line 1105
          __cil_tmp95 = opj_realloc(l_band->precincts, (size_t )l_nb_precinct_size);
#line 1105
          new_precincts = (opj_tcd_precinct_t *)__cil_tmp95;
          }
#line 1107
          if (! new_precincts) {
            {
#line 1108
            opj_event_msg(manager, 1, "Not enough memory to handle band precints\n");
#line 1110
            opj_free(l_band->precincts);
#line 1111
            l_band->precincts = (opj_tcd_precinct_t *)((void *)0);
#line 1112
            l_band->precincts_data_size = (OPJ_UINT32 )0;
            }
#line 1113
            return (0);
          }
          {
#line 1115
          l_band->precincts = new_precincts;
#line 1117
          memset((OPJ_BYTE *)l_band->precincts + l_band->precincts_data_size, 0, (unsigned long )(l_nb_precinct_size - l_band->precincts_data_size));
#line 1119
          l_band->precincts_data_size = l_nb_precinct_size;
          }
        }
#line 1122
        l_current_precinct = l_band->precincts;
#line 1123
        precno = (OPJ_UINT32 )0;
        {
#line 1123
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1123
          if (! (precno < l_nb_precincts)) {
#line 1123
            goto while_break___2;
          }
          {
#line 1125
          cbgxstart = tlcbgxstart + (OPJ_INT32 )(precno % l_res->pw) * (1 << cbgwidthexpn);
#line 1127
          cbgystart = tlcbgystart + (OPJ_INT32 )(precno / l_res->pw) * (1 << cbgheightexpn);
#line 1129
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 1130
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 1137
          l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
#line 1138
          l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
#line 1139
          l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
#line 1140
          l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
#line 1143
          __cil_tmp108 = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32 )cblkwidthexpn);
#line 1143
          tlcblkxstart = __cil_tmp108 << cblkwidthexpn;
#line 1146
          __cil_tmp109 = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32 )cblkheightexpn);
#line 1146
          tlcblkystart = __cil_tmp109 << cblkheightexpn;
#line 1149
          __cil_tmp110 = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32 )cblkwidthexpn);
#line 1149
          brcblkxend = __cil_tmp110 << cblkwidthexpn;
#line 1152
          __cil_tmp111 = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32 )cblkheightexpn);
#line 1152
          brcblkyend = __cil_tmp111 << cblkheightexpn;
#line 1155
          l_current_precinct->cw = (OPJ_UINT32 )((brcblkxend - tlcblkxstart) >> cblkwidthexpn);
#line 1157
          l_current_precinct->ch = (OPJ_UINT32 )((brcblkyend - tlcblkystart) >> cblkheightexpn);
#line 1160
          l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
          }
#line 1162
          if (4294967295U / (OPJ_UINT32 )sizeof_block < l_nb_code_blocks) {
            {
#line 1164
            opj_event_msg(manager, 1, "Size of code block data exceeds system limits\n");
            }
#line 1166
            return (0);
          }
#line 1168
          l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32 )sizeof_block;
#line 1170
          if (! l_current_precinct->cblks.blocks) {
#line 1170
            if (l_nb_code_blocks > 0U) {
              {
#line 1171
              l_current_precinct->cblks.blocks = opj_malloc((size_t )l_nb_code_blocks_size);
              }
#line 1172
              if (! l_current_precinct->cblks.blocks) {
#line 1173
                return (0);
              }
              {
#line 1177
              memset(l_current_precinct->cblks.blocks, 0, (unsigned long )l_nb_code_blocks_size);
#line 1179
              l_current_precinct->block_size = l_nb_code_blocks_size;
              }
            } else {
#line 1170
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
#line 1180
          if (l_nb_code_blocks_size > l_current_precinct->block_size) {
            {
#line 1181
            __cil_tmp114 = opj_realloc(l_current_precinct->cblks.blocks, (size_t )l_nb_code_blocks_size);
#line 1181
            new_blocks = __cil_tmp114;
            }
#line 1183
            if (! new_blocks) {
              {
#line 1184
              opj_free(l_current_precinct->cblks.blocks);
#line 1185
              l_current_precinct->cblks.blocks = (void *)0;
#line 1186
              l_current_precinct->block_size = (OPJ_UINT32 )0;
#line 1187
              opj_event_msg(manager, 1, "Not enough memory for current precinct codeblock element\n");
              }
#line 1189
              return (0);
            }
            {
#line 1191
            l_current_precinct->cblks.blocks = new_blocks;
#line 1194
            memset((OPJ_BYTE *)l_current_precinct->cblks.blocks + l_current_precinct->block_size,
                   0, (unsigned long )(l_nb_code_blocks_size - l_current_precinct->block_size));
#line 1199
            l_current_precinct->block_size = l_nb_code_blocks_size;
            }
          }
#line 1202
          if (! l_current_precinct->incltree) {
            {
#line 1203
            l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1206
            l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1210
          if (! l_current_precinct->imsbtree) {
            {
#line 1211
            l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                          l_current_precinct->ch,
                                                          manager);
            }
          } else {
            {
#line 1214
            l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                        l_current_precinct->cw, l_current_precinct->ch,
                                                        manager);
            }
          }
#line 1218
          cblkno = (OPJ_UINT32 )0;
          {
#line 1218
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1218
            if (! (cblkno < l_nb_code_blocks)) {
#line 1218
              goto while_break___3;
            }
#line 1219
            cblkxstart = tlcblkxstart + (OPJ_INT32 )(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);
#line 1221
            cblkystart = tlcblkystart + (OPJ_INT32 )(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);
#line 1223
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 1224
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 1226
            if (isEncoder) {
              {
#line 1227
              l_code_block = l_current_precinct->cblks.enc + cblkno;
#line 1229
              __cil_tmp124 = opj_tcd_code_block_enc_allocate(l_code_block);
              }
#line 1229
              if (! __cil_tmp124) {
#line 1230
                return (0);
              }
              {
#line 1233
              l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1234
              l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1235
              l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1236
              l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
#line 1238
              __cil_tmp129 = opj_tcd_code_block_enc_allocate_data(l_code_block);
              }
#line 1238
              if (! __cil_tmp129) {
#line 1239
                return (0);
              }
            } else {
              {
#line 1242
              l_code_block___0 = l_current_precinct->cblks.dec + cblkno;
#line 1244
              __cil_tmp131 = opj_tcd_code_block_dec_allocate(l_code_block___0);
              }
#line 1244
              if (! __cil_tmp131) {
#line 1245
                return (0);
              }
              {
#line 1248
              l_code_block___0->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
#line 1249
              l_code_block___0->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
#line 1250
              l_code_block___0->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
#line 1251
              l_code_block___0->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
              }
            }
#line 1218
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1254
          l_current_precinct ++;
#line 1123
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1033
        l_step_size ++;
#line 1033
        l_band ++;
#line 1033
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1257
      l_res ++;
#line 950
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1259
    l_tccp ++;
#line 1260
    l_tilec ++;
#line 1261
    l_image_comp ++;
#line 868
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  return (1);
}
}
#line 1266 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1269
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 1, sizeof(opj_tcd_cblk_enc_t ),
                                 p_manager);
  }
#line 1269
  return (__cil_tmp4);
}
}
#line 1273 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 1276
  __cil_tmp4 = opj_tcd_init_tile(p_tcd, p_tile_no, 0, sizeof(opj_tcd_cblk_dec_t ),
                                 p_manager);
  }
#line 1276
  return (__cil_tmp4);
}
}
#line 1283 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
#line 1286
  if (! p_code_block->layers) {
    {
#line 1288
    __cil_tmp2 = opj_calloc((size_t )100, sizeof(opj_tcd_layer_t ));
#line 1288
    p_code_block->layers = (opj_tcd_layer_t *)__cil_tmp2;
    }
#line 1290
    if (! p_code_block->layers) {
#line 1291
      return (0);
    }
  }
#line 1294
  if (! p_code_block->passes) {
    {
#line 1295
    __cil_tmp3 = opj_calloc((size_t )100, sizeof(opj_tcd_pass_t ));
#line 1295
    p_code_block->passes = (opj_tcd_pass_t *)__cil_tmp3;
    }
#line 1297
    if (! p_code_block->passes) {
#line 1298
      return (0);
    }
  }
#line 1301
  return (1);
}
}
#line 1307 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *p_code_block ) 
{ 
  OPJ_UINT32 l_data_size ;
  void *__cil_tmp3 ;

  {
#line 1322
  l_data_size = 74U + (OPJ_UINT32 )(((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0)) * (OPJ_INT32 )sizeof(OPJ_UINT32 ));
#line 1325
  if (l_data_size > p_code_block->data_size) {
#line 1326
    if (p_code_block->data) {
      {
#line 1328
      opj_free(p_code_block->data - 1);
      }
    }
    {
#line 1330
    __cil_tmp3 = opj_malloc((size_t )(l_data_size + 1U));
#line 1330
    p_code_block->data = (OPJ_BYTE *)__cil_tmp3;
    }
#line 1331
    if (! p_code_block->data) {
#line 1332
      p_code_block->data_size = 0U;
#line 1333
      return (0);
    }
#line 1335
    p_code_block->data_size = l_data_size;
#line 1341
    *(p_code_block->data + 0) = (OPJ_BYTE )0;
#line 1342
    (p_code_block->data) ++;
  }
#line 1344
  return (1);
}
}
#line 1348 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) 
{ 


  {
  {
#line 1350
  memset(seg, 0, sizeof(opj_tcd_seg_t ));
  }
  return;
}
}
#line 1356 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *p_code_block ) 
{ 
  void *__cil_tmp2 ;
  opj_tcd_seg_t *l_segs ;
  OPJ_UINT32 l_current_max_segs ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  OPJ_UINT32 l_numchunksalloc ;
  OPJ_UINT32 i ;

  {
#line 1359
  if (! p_code_block->segs) {
    {
#line 1361
    __cil_tmp2 = opj_calloc((size_t )10, sizeof(opj_tcd_seg_t ));
#line 1361
    p_code_block->segs = (opj_tcd_seg_t *)__cil_tmp2;
    }
#line 1363
    if (! p_code_block->segs) {
#line 1364
      return (0);
    }
#line 1368
    p_code_block->m_current_max_segs = (OPJ_UINT32 )10;
  } else {
    {
#line 1372
    l_segs = p_code_block->segs;
#line 1373
    l_current_max_segs = p_code_block->m_current_max_segs;
#line 1374
    l_chunks = p_code_block->chunks;
#line 1375
    l_numchunksalloc = p_code_block->numchunksalloc;
#line 1378
    opj_aligned_free(p_code_block->decoded_data);
#line 1379
    p_code_block->decoded_data = (OPJ_INT32 *)0;
#line 1381
    memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t ));
#line 1382
    p_code_block->segs = l_segs;
#line 1383
    p_code_block->m_current_max_segs = l_current_max_segs;
#line 1384
    i = (OPJ_UINT32 )0;
    }
    {
#line 1384
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1384
      if (! (i < l_current_max_segs)) {
#line 1384
        goto while_break;
      }
      {
#line 1385
      opj_tcd_reinit_segment(l_segs + i);
      }
#line 1384
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1387
    p_code_block->chunks = l_chunks;
#line 1388
    p_code_block->numchunksalloc = l_numchunksalloc;
  }
#line 1391
  return (1);
}
}
#line 1394 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_temp ;
  OPJ_UINT32 w ;
  OPJ_UINT32 h ;

  {
#line 1398
  l_data_size = (OPJ_UINT32 )0;
#line 1399
  l_img_comp = (opj_image_comp_t *)0;
#line 1400
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1401
  l_res = (opj_tcd_resolution_t *)0;
#line 1405
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 1406
  l_img_comp = (p_tcd->image)->comps;
#line 1408
  i = (OPJ_UINT32 )0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1408
      goto while_break;
    }
#line 1410
    l_size_comp = l_img_comp->prec >> 3;
#line 1411
    l_remaining = l_img_comp->prec & 7U;
#line 1413
    if (l_remaining) {
#line 1414
      l_size_comp ++;
    }
#line 1417
    if (l_size_comp == 3U) {
#line 1418
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 1421
    l_res = (l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 1422
    if (take_into_account_partial_decoding) {
#line 1422
      if (! p_tcd->whole_tile_decoding) {
#line 1423
        w = l_res->win_x1 - l_res->win_x0;
#line 1424
        h = l_res->win_y1 - l_res->win_y0;
      } else {
#line 1426
        w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1427
        h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
      }
    } else {
#line 1426
      w = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1427
      h = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
    }
#line 1429
    if (h > 0U) {
#line 1429
      if (4294967295U / w < h) {
#line 1430
        return (4294967295U);
      }
    }
#line 1432
    l_temp = w * h;
#line 1433
    if (l_size_comp) {
#line 1433
      if (4294967295U / l_size_comp < l_temp) {
#line 1434
        return (4294967295U);
      }
    }
#line 1436
    l_temp *= l_size_comp;
#line 1438
    if (l_temp > 4294967295U - l_data_size) {
#line 1439
      return (4294967295U);
    }
#line 1441
    l_data_size += l_temp;
#line 1442
    l_img_comp ++;
#line 1443
    l_tile_comp ++;
#line 1408
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1446
  return (l_data_size);
}
}
#line 1449 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_max_length ,
                             opj_codestream_info_t *p_cstr_info , opj_tcd_marker_info_t *p_marker_info ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_packs ;
  OPJ_UINT32 i ;
  opj_tcd_tilecomp_t *l_tilec_idx ;
  opj_tccp_t *l_tccp ;
  opj_tcd_resolution_t *l_res_idx ;
  OPJ_UINT32 __cil_tmp14 ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 1459
  if (p_tcd->cur_tp_num == 0U) {
#line 1461
    p_tcd->tcd_tileno = p_tile_no;
#line 1462
    p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1465
    if (p_cstr_info) {
#line 1466
      l_num_packs = (OPJ_UINT32 )0;
#line 1468
      l_tilec_idx = ((p_tcd->tcd_image)->tiles)->comps + 0;
#line 1470
      l_tccp = (p_tcd->tcp)->tccps;
#line 1472
      i = (OPJ_UINT32 )0;
      {
#line 1472
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1472
        if (! (i < l_tilec_idx->numresolutions)) {
#line 1472
          goto while_break;
        }
#line 1473
        l_res_idx = l_tilec_idx->resolutions + i;
#line 1475
        (p_cstr_info->tile + p_tile_no)->pw[i] = (int )l_res_idx->pw;
#line 1476
        (p_cstr_info->tile + p_tile_no)->ph[i] = (int )l_res_idx->ph;
#line 1478
        l_num_packs += l_res_idx->pw * l_res_idx->ph;
#line 1479
        (p_cstr_info->tile + p_tile_no)->pdx[i] = (int )l_tccp->prcw[i];
#line 1480
        (p_cstr_info->tile + p_tile_no)->pdy[i] = (int )l_tccp->prch[i];
#line 1472
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1482
      __cil_tmp15 = opj_calloc(((OPJ_SIZE_T )p_cstr_info->numcomps * (OPJ_SIZE_T )p_cstr_info->numlayers) * (unsigned long )l_num_packs,
                               sizeof(opj_packet_info_t ));
#line 1482
      (p_cstr_info->tile + p_tile_no)->packet = (opj_packet_info_t *)__cil_tmp15;
      }
#line 1486
      if (! (p_cstr_info->tile + p_tile_no)->packet) {
#line 1488
        return (0);
      }
    }
    {
#line 1495
    __cil_tmp16 = opj_tcd_dc_level_shift_encode(p_tcd);
    }
#line 1495
    if (! __cil_tmp16) {
#line 1496
      return (0);
    }
    {
#line 1501
    __cil_tmp17 = opj_tcd_mct_encode(p_tcd);
    }
#line 1501
    if (! __cil_tmp17) {
#line 1502
      return (0);
    }
    {
#line 1507
    __cil_tmp18 = opj_tcd_dwt_encode(p_tcd);
    }
#line 1507
    if (! __cil_tmp18) {
#line 1508
      return (0);
    }
    {
#line 1513
    __cil_tmp19 = opj_tcd_t1_encode(p_tcd);
    }
#line 1513
    if (! __cil_tmp19) {
#line 1514
      return (0);
    }
    {
#line 1519
    __cil_tmp20 = opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length, p_cstr_info,
                                               p_manager);
    }
#line 1519
    if (! __cil_tmp20) {
#line 1521
      return (0);
    }
  }
#line 1529
  if (p_cstr_info) {
#line 1530
    p_cstr_info->index_write = 1;
  }
  {
#line 1534
  __cil_tmp21 = opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length, p_cstr_info,
                                  p_marker_info, p_manager);
  }
#line 1534
  if (! __cil_tmp21) {
#line 1536
    return (0);
  }
#line 1542
  return (1);
}
}
#line 1545 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_UINT32 numcomps_to_decode ,
                             OPJ_UINT32 *comps_indices , OPJ_BYTE *p_src , OPJ_UINT32 p_max_length ,
                             OPJ_UINT32 p_tile_no , opj_codestream_index_t *p_cstr_index ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_data_read ;
  OPJ_UINT32 compno ;
  OPJ_BOOL *used_component ;
  void *__cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_SIZE_T l_data_size ;
  OPJ_SIZE_T res_w ;
  OPJ_SIZE_T res_h ;
  OPJ_BOOL __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 resno ;
  opj_tcd_tilecomp_t *tilec___0 ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;
  opj_tcd_resolution_t *res ;
  OPJ_UINT32 __cil_tmp39 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_BOOL __cil_tmp44 ;
  OPJ_BOOL __cil_tmp45 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *image_comp___0 ;
  opj_tcd_resolution_t *res___0 ;
  OPJ_SIZE_T w ;
  OPJ_SIZE_T h ;
  OPJ_SIZE_T l_data_size___0 ;
  void *__cil_tmp52 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_BOOL __cil_tmp55 ;
  OPJ_BOOL __cil_tmp56 ;

  {
  {
#line 1562
  p_tcd->tcd_tileno = p_tile_no;
#line 1563
  p_tcd->tcp = (p_tcd->cp)->tcps + p_tile_no;
#line 1564
  p_tcd->win_x0 = win_x0;
#line 1565
  p_tcd->win_y0 = win_y0;
#line 1566
  p_tcd->win_x1 = win_x1;
#line 1567
  p_tcd->win_y1 = win_y1;
#line 1568
  p_tcd->whole_tile_decoding = 1;
#line 1570
  opj_free(p_tcd->used_component);
#line 1571
  p_tcd->used_component = (OPJ_BOOL *)((void *)0);
  }
#line 1573
  if (numcomps_to_decode) {
    {
#line 1574
    __cil_tmp16 = opj_calloc(sizeof(OPJ_BOOL ), (size_t )(p_tcd->image)->numcomps);
#line 1574
    used_component = (OPJ_BOOL *)__cil_tmp16;
    }
#line 1576
    if (used_component == (void *)0) {
#line 1577
      return (0);
    }
#line 1579
    compno = (OPJ_UINT32 )0;
    {
#line 1579
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1579
      if (! (compno < numcomps_to_decode)) {
#line 1579
        goto while_break;
      }
#line 1580
      *(used_component + *(comps_indices + compno)) = 1;
#line 1579
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1583
    p_tcd->used_component = used_component;
  }
#line 1586
  compno = (OPJ_UINT32 )0;
  {
#line 1586
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1586
    if (! (compno < (p_tcd->image)->numcomps)) {
#line 1586
      goto while_break___0;
    }
#line 1587
    if (p_tcd->used_component != (void *)0) {
#line 1587
      if (! *(p_tcd->used_component + compno)) {
#line 1588
        goto while_continue___0;
      }
    }
    {
#line 1591
    __cil_tmp18 = opj_tcd_is_whole_tilecomp_decoding(p_tcd, compno);
    }
#line 1591
    if (! __cil_tmp18) {
#line 1592
      p_tcd->whole_tile_decoding = 0;
#line 1593
      goto while_break___0;
    }
#line 1586
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1597
  if (p_tcd->whole_tile_decoding) {
#line 1598
    compno = (OPJ_UINT32 )0;
    {
#line 1598
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1598
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1598
        goto while_break___1;
      }
#line 1599
      tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1600
      l_res = tilec->resolutions + (tilec->minimum_num_resolutions - 1U);
#line 1605
      res_w = (OPJ_SIZE_T )(l_res->x1 - l_res->x0);
#line 1606
      res_h = (OPJ_SIZE_T )(l_res->y1 - l_res->y0);
#line 1608
      if (p_tcd->used_component != (void *)0) {
#line 1608
        if (! *(p_tcd->used_component + compno)) {
#line 1609
          goto while_continue___1;
        }
      }
#line 1613
      if (res_h > 0UL) {
#line 1613
        if (res_w > 0xffffffffffffffffUL / res_h) {
          {
#line 1614
          opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
          }
#line 1616
          return (0);
        }
      }
#line 1618
      l_data_size = res_w * res_h;
#line 1620
      if (0xffffffffffffffffUL / sizeof(OPJ_UINT32 ) < l_data_size) {
        {
#line 1621
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1623
        return (0);
      }
      {
#line 1625
      l_data_size *= sizeof(OPJ_UINT32 );
#line 1627
      tilec->data_size_needed = l_data_size;
#line 1629
      __cil_tmp25 = opj_alloc_tile_component_data(tilec);
      }
#line 1629
      if (! __cil_tmp25) {
        {
#line 1630
        opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
        }
#line 1632
        return (0);
      }
#line 1598
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1639
    compno = (OPJ_UINT32 )0;
    {
#line 1639
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1639
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1639
        goto while_break___2;
      }
#line 1641
      tilec___0 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1642
      image_comp = (p_tcd->image)->comps + compno;
#line 1644
      if (p_tcd->used_component != (void *)0) {
#line 1644
        if (! *(p_tcd->used_component + compno)) {
#line 1645
          goto while_continue___2;
        }
      }
      {
#line 1650
      __cil_tmp30 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 1650
      __cil_tmp31 = opj_uint_max((OPJ_UINT32 )tilec___0->x0, __cil_tmp30);
#line 1650
      tilec___0->win_x0 = __cil_tmp31;
#line 1653
      __cil_tmp32 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 1653
      __cil_tmp33 = opj_uint_max((OPJ_UINT32 )tilec___0->y0, __cil_tmp32);
#line 1653
      tilec___0->win_y0 = __cil_tmp33;
#line 1656
      __cil_tmp34 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 1656
      __cil_tmp35 = opj_uint_min((OPJ_UINT32 )tilec___0->x1, __cil_tmp34);
#line 1656
      tilec___0->win_x1 = __cil_tmp35;
#line 1659
      __cil_tmp36 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 1659
      __cil_tmp37 = opj_uint_min((OPJ_UINT32 )tilec___0->y1, __cil_tmp36);
#line 1659
      tilec___0->win_y1 = __cil_tmp37;
      }
#line 1662
      if (tilec___0->win_x1 < tilec___0->win_x0) {
        {
        {
#line 1667
        opj_event_msg(p_manager, 1, "Invalid tilec->win_xxx values\n");
        }
        }
#line 1669
        return (0);
      } else
#line 1662
      if (tilec___0->win_y1 < tilec___0->win_y0) {
        {
        {
#line 1667
        opj_event_msg(p_manager, 1, "Invalid tilec->win_xxx values\n");
        }
        }
#line 1669
        return (0);
      }
#line 1672
      resno = (OPJ_UINT32 )0;
      {
#line 1672
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1672
        if (! (resno < tilec___0->numresolutions)) {
#line 1672
          goto while_break___3;
        }
        {
#line 1673
        res = tilec___0->resolutions + resno;
#line 1674
        res->win_x0 = opj_uint_ceildivpow2(tilec___0->win_x0, (tilec___0->numresolutions - 1U) - resno);
#line 1676
        res->win_y0 = opj_uint_ceildivpow2(tilec___0->win_y0, (tilec___0->numresolutions - 1U) - resno);
#line 1678
        res->win_x1 = opj_uint_ceildivpow2(tilec___0->win_x1, (tilec___0->numresolutions - 1U) - resno);
#line 1680
        res->win_y1 = opj_uint_ceildivpow2(tilec___0->win_y1, (tilec___0->numresolutions - 1U) - resno);
        }
#line 1672
        resno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1639
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1712
  l_data_read = (OPJ_UINT32 )0;
#line 1713
  __cil_tmp44 = opj_tcd_t2_decode(p_tcd, p_src, & l_data_read, p_max_length, p_cstr_index,
                                  p_manager);
  }
#line 1713
  if (! __cil_tmp44) {
#line 1715
    return (0);
  }
  {
#line 1722
  __cil_tmp45 = opj_tcd_t1_decode(p_tcd, p_manager);
  }
#line 1722
  if (! __cil_tmp45) {
#line 1723
    return (0);
  }
#line 1730
  if (! p_tcd->whole_tile_decoding) {
#line 1731
    compno = (OPJ_UINT32 )0;
    {
#line 1731
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1731
      if (! (compno < (p_tcd->image)->numcomps)) {
#line 1731
        goto while_break___4;
      }
      {
#line 1732
      tilec___1 = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 1733
      image_comp___0 = (p_tcd->image)->comps + compno;
#line 1734
      res___0 = tilec___1->resolutions + image_comp___0->resno_decoded;
#line 1735
      w = (OPJ_SIZE_T )(res___0->win_x1 - res___0->win_x0);
#line 1736
      h = (OPJ_SIZE_T )(res___0->win_y1 - res___0->win_y0);
#line 1739
      opj_image_data_free(tilec___1->data_win);
#line 1740
      tilec___1->data_win = (OPJ_INT32 *)((void *)0);
      }
#line 1742
      if (p_tcd->used_component != (void *)0) {
#line 1742
        if (! *(p_tcd->used_component + compno)) {
#line 1743
          goto while_continue___4;
        }
      }
#line 1746
      if (w > 0UL) {
#line 1746
        if (h > 0UL) {
#line 1747
          if (w > 0xffffffffffffffffUL / h) {
            {
#line 1748
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1750
            return (0);
          }
#line 1752
          l_data_size___0 = w * h;
#line 1753
          if (l_data_size___0 > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
            {
#line 1754
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1756
            return (0);
          }
          {
#line 1758
          l_data_size___0 *= sizeof(OPJ_INT32 );
#line 1760
          __cil_tmp52 = opj_image_data_alloc(l_data_size___0);
#line 1760
          tilec___1->data_win = (OPJ_INT32 *)__cil_tmp52;
          }
#line 1761
          if (tilec___1->data_win == (void *)0) {
            {
#line 1762
            opj_event_msg(p_manager, 1, "Size of tile data exceeds system limits\n\220");
            }
#line 1764
            return (0);
          }
        }
      }
#line 1731
      compno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1773
  __cil_tmp54 = opj_tcd_dwt_decode(p_tcd);
  }
#line 1773
  if (! __cil_tmp54) {
#line 1775
    return (0);
  }
  {
#line 1781
  __cil_tmp55 = opj_tcd_mct_decode(p_tcd, p_manager);
  }
#line 1781
  if (! __cil_tmp55) {
#line 1783
    return (0);
  }
  {
#line 1788
  __cil_tmp56 = opj_tcd_dc_level_shift_decode(p_tcd);
  }
#line 1788
  if (! __cil_tmp56) {
#line 1790
    return (0);
  }
#line 1796
  return (1);
}
}
#line 1799 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_UINT32 l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_tcd_resolution_t *l_res ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_INT32 *l_src_data ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_CHAR *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_CHAR *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_src_ptr___0 ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 val ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT16 *__cil_tmp28 ;
  OPJ_INT16 val___0 ;
  OPJ_INT32 *__cil_tmp30 ;
  OPJ_INT16 *__cil_tmp31 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *l_src_ptr___1 ;

  {
  {
#line 1804
  l_data_size = (OPJ_UINT32 )0;
#line 1805
  l_img_comp = (opj_image_comp_t *)0;
#line 1806
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 1811
  l_data_size = opj_tcd_get_decoded_tile_size(p_tcd, 1);
  }
#line 1812
  if (l_data_size == 4294967295U) {
#line 1813
    return (0);
  } else
#line 1812
  if (l_data_size > p_dest_length) {
#line 1813
    return (0);
  }
#line 1816
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 1817
  l_img_comp = (p_tcd->image)->comps;
#line 1819
  i = (OPJ_UINT32 )0;
  {
#line 1819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1819
    if (! (i < (p_tcd->image)->numcomps)) {
#line 1819
      goto while_break;
    }
#line 1821
    l_size_comp = l_img_comp->prec >> 3;
#line 1822
    l_remaining = l_img_comp->prec & 7U;
#line 1823
    l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
#line 1824
    if (p_tcd->whole_tile_decoding) {
#line 1825
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 1826
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 1827
      l_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0) - l_width;
#line 1830
      l_src_data = l_tilec->data;
    } else {
#line 1832
      l_width = l_res->win_x1 - l_res->win_x0;
#line 1833
      l_height = l_res->win_y1 - l_res->win_y0;
#line 1834
      l_stride = (OPJ_UINT32 )0;
#line 1835
      l_src_data = l_tilec->data_win;
    }
#line 1838
    if (l_remaining) {
#line 1839
      l_size_comp ++;
    }
#line 1842
    if (l_size_comp == 3U) {
#line 1843
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 1847
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 1847
      goto case_1;
    }
#line 1870
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 1870
      goto case_2;
    }
#line 1897
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 1897
      goto case_4;
    }
#line 1846
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1848
    l_dest_ptr = (OPJ_CHAR *)p_dest;
#line 1849
    l_src_ptr = l_src_data;
#line 1851
    if (l_img_comp->sgnd) {
#line 1852
      j = (OPJ_UINT32 )0;
      {
#line 1852
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1852
        if (! (j < l_height)) {
#line 1852
          goto while_break___0;
        }
#line 1853
        k = (OPJ_UINT32 )0;
        {
#line 1853
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1853
          if (! (k < l_width)) {
#line 1853
            goto while_break___1;
          }
#line 1854
          __cil_tmp21 = l_src_ptr;
#line 1854
          l_src_ptr ++;
#line 1854
          __cil_tmp20 = l_dest_ptr;
#line 1854
          l_dest_ptr ++;
#line 1854
          *__cil_tmp20 = (OPJ_CHAR )*__cil_tmp21;
#line 1853
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1856
        l_src_ptr += l_stride;
#line 1852
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1859
      j = (OPJ_UINT32 )0;
      {
#line 1859
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1859
        if (! (j < l_height)) {
#line 1859
          goto while_break___2;
        }
#line 1860
        k = (OPJ_UINT32 )0;
        {
#line 1860
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1860
          if (! (k < l_width)) {
#line 1860
            goto while_break___3;
          }
#line 1861
          __cil_tmp23 = l_src_ptr;
#line 1861
          l_src_ptr ++;
#line 1861
          __cil_tmp22 = l_dest_ptr;
#line 1861
          l_dest_ptr ++;
#line 1861
          *__cil_tmp22 = (OPJ_CHAR )(*__cil_tmp23 & 255);
#line 1860
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1863
        l_src_ptr += l_stride;
#line 1859
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1867
    p_dest = (OPJ_BYTE *)l_dest_ptr;
#line 1869
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1871
    l_src_ptr___0 = l_src_data;
#line 1872
    l_dest_ptr___0 = (OPJ_INT16 *)p_dest;
#line 1874
    if (l_img_comp->sgnd) {
#line 1875
      j = (OPJ_UINT32 )0;
      {
#line 1875
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1875
        if (! (j < l_height)) {
#line 1875
          goto while_break___4;
        }
#line 1876
        k = (OPJ_UINT32 )0;
        {
#line 1876
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1876
          if (! (k < l_width)) {
#line 1876
            goto while_break___5;
          }
          {
#line 1877
          __cil_tmp27 = l_src_ptr___0;
#line 1877
          l_src_ptr___0 ++;
#line 1877
          val = (OPJ_INT16 )*__cil_tmp27;
#line 1878
          memcpy(l_dest_ptr___0, & val, sizeof(val));
#line 1879
          l_dest_ptr___0 ++;
          }
#line 1876
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1881
        l_src_ptr___0 += l_stride;
#line 1875
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1884
      j = (OPJ_UINT32 )0;
      {
#line 1884
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1884
        if (! (j < l_height)) {
#line 1884
          goto while_break___6;
        }
#line 1885
        k = (OPJ_UINT32 )0;
        {
#line 1885
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1885
          if (! (k < l_width)) {
#line 1885
            goto while_break___7;
          }
          {
#line 1886
          __cil_tmp30 = l_src_ptr___0;
#line 1886
          l_src_ptr___0 ++;
#line 1886
          val___0 = (OPJ_INT16 )(*__cil_tmp30 & 65535);
#line 1887
          memcpy(l_dest_ptr___0, & val___0, sizeof(val___0));
#line 1888
          l_dest_ptr___0 ++;
          }
#line 1885
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1890
        l_src_ptr___0 += l_stride;
#line 1884
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1894
    p_dest = (OPJ_BYTE *)l_dest_ptr___0;
#line 1896
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1898
    l_dest_ptr___1 = (OPJ_INT32 *)p_dest;
#line 1899
    l_src_ptr___1 = l_src_data;
#line 1901
    j = (OPJ_UINT32 )0;
    {
#line 1901
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1901
      if (! (j < l_height)) {
#line 1901
        goto while_break___8;
      }
      {
#line 1902
      memcpy(l_dest_ptr___1, l_src_ptr___1, (unsigned long )l_width * sizeof(OPJ_INT32 ));
#line 1903
      l_dest_ptr___1 += l_width;
#line 1904
      l_src_ptr___1 += l_width + l_stride;
      }
#line 1901
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1907
    p_dest = (OPJ_BYTE *)l_dest_ptr___1;
#line 1909
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1912
    l_img_comp ++;
#line 1913
    l_tilec ++;
#line 1819
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1916
  return (1);
}
}
#line 1922 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static void opj_tcd_free_tile(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 bandno ;
  OPJ_UINT32 precno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_band_t *l_band ;
  opj_tcd_precinct_t *l_precinct ;
  OPJ_UINT32 l_nb_resolutions ;
  OPJ_UINT32 l_nb_precincts ;
  void (*l_tcd_code_block_deallocate)(opj_tcd_precinct_t * ) ;

  {
#line 1925
  l_tile = (opj_tcd_tile_t *)0;
#line 1926
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 1927
  l_res = (opj_tcd_resolution_t *)0;
#line 1928
  l_band = (opj_tcd_band_t *)0;
#line 1929
  l_precinct = (opj_tcd_precinct_t *)0;
#line 1931
  l_tcd_code_block_deallocate = (void (*)(opj_tcd_precinct_t * ))0;
#line 1933
  if (! p_tcd) {
#line 1934
    return;
  }
#line 1937
  if (! p_tcd->tcd_image) {
#line 1938
    return;
  }
#line 1941
  if (p_tcd->m_is_decoder) {
#line 1942
    l_tcd_code_block_deallocate = & opj_tcd_code_block_dec_deallocate;
  } else {
#line 1944
    l_tcd_code_block_deallocate = & opj_tcd_code_block_enc_deallocate;
  }
#line 1947
  l_tile = (p_tcd->tcd_image)->tiles;
#line 1948
  if (! l_tile) {
#line 1949
    return;
  }
#line 1952
  l_tile_comp = l_tile->comps;
#line 1954
  compno = (OPJ_UINT32 )0;
  {
#line 1954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1954
    if (! (compno < l_tile->numcomps)) {
#line 1954
      goto while_break;
    }
#line 1955
    l_res = l_tile_comp->resolutions;
#line 1956
    if (l_res) {
#line 1958
      l_nb_resolutions = l_tile_comp->resolutions_size / (OPJ_UINT32 )sizeof(opj_tcd_resolution_t );
#line 1960
      resno = (OPJ_UINT32 )0;
      {
#line 1960
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1960
        if (! (resno < l_nb_resolutions)) {
#line 1960
          goto while_break___0;
        }
#line 1961
        l_band = (opj_tcd_band_t *)l_res->bands;
#line 1962
        bandno = (OPJ_UINT32 )0;
        {
#line 1962
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1962
          if (! (bandno < 3U)) {
#line 1962
            goto while_break___1;
          }
#line 1963
          l_precinct = l_band->precincts;
#line 1964
          if (l_precinct) {
#line 1966
            l_nb_precincts = l_band->precincts_data_size / (OPJ_UINT32 )sizeof(opj_tcd_precinct_t );
#line 1968
            precno = (OPJ_UINT32 )0;
            {
#line 1968
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1968
              if (! (precno < l_nb_precincts)) {
#line 1968
                goto while_break___2;
              }
              {
#line 1969
              opj_tgt_destroy(l_precinct->incltree);
#line 1970
              l_precinct->incltree = (opj_tgt_tree_t *)0;
#line 1971
              opj_tgt_destroy(l_precinct->imsbtree);
#line 1972
              l_precinct->imsbtree = (opj_tgt_tree_t *)0;
#line 1973
              (*l_tcd_code_block_deallocate)(l_precinct);
#line 1974
              l_precinct ++;
              }
#line 1968
              precno ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 1977
            opj_free(l_band->precincts);
#line 1978
            l_band->precincts = (opj_tcd_precinct_t *)0;
            }
          }
#line 1980
          l_band ++;
#line 1962
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1982
        l_res ++;
#line 1960
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1985
      opj_free(l_tile_comp->resolutions);
#line 1986
      l_tile_comp->resolutions = (opj_tcd_resolution_t *)0;
      }
    }
#line 1989
    if (l_tile_comp->data) {
#line 1989
      if (l_tile_comp->ownsData) {
        {
#line 1990
        opj_image_data_free(l_tile_comp->data);
#line 1991
        l_tile_comp->data = (OPJ_INT32 *)0;
#line 1992
        l_tile_comp->ownsData = 0;
#line 1993
        l_tile_comp->data_size = (size_t )0;
#line 1994
        l_tile_comp->data_size_needed = (size_t )0;
        }
      }
    }
    {
#line 1997
    opj_image_data_free(l_tile_comp->data_win);
#line 1999
    l_tile_comp ++;
    }
#line 1954
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2002
  opj_free(l_tile->comps);
#line 2003
  l_tile->comps = (opj_tcd_tilecomp_t *)0;
#line 2004
  opj_free((p_tcd->tcd_image)->tiles);
#line 2005
  (p_tcd->tcd_image)->tiles = (opj_tcd_tile_t *)0;
  }
  return;
}
}
#line 2009 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_decode(opj_tcd_t *p_tcd , OPJ_BYTE *p_src_data , OPJ_UINT32 *p_data_read ,
                                  OPJ_UINT32 p_max_src_size , opj_codestream_index_t *p_cstr_index ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  opj_t2_t *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2019
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 2020
  if (l_t2 == (opj_t2_t *)0) {
#line 2021
    return (0);
  }
  {
#line 2024
  __cil_tmp9 = opj_t2_decode_packets(p_tcd, l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                     p_src_data, p_data_read, p_max_src_size, p_cstr_index,
                                     p_manager);
  }
#line 2024
  if (! __cil_tmp9) {
    {
#line 2034
    opj_t2_destroy(l_t2);
    }
#line 2035
    return (0);
  }
  {
#line 2038
  opj_t2_destroy(l_t2);
  }
#line 2041
  return (1);
}
}
#line 2044 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL ret ;
  OPJ_BOOL check_pterm ;
  opj_mutex_t *p_manager_mutex ;
  opj_mutex_t *__cil_tmp10 ;

  {
  {
#line 2047
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2048
  l_tile_comp = l_tile->comps;
#line 2049
  l_tccp = (p_tcd->tcp)->tccps;
#line 2050
  ret = 1;
#line 2051
  check_pterm = 0;
#line 2052
  p_manager_mutex = (opj_mutex_t *)((void *)0);
#line 2054
  p_manager_mutex = opj_mutex_create();
  }
#line 2057
  if ((p_tcd->tcp)->num_layers_to_decode == (p_tcd->tcp)->numlayers) {
#line 2057
    if ((l_tccp->cblksty & 16U) != 0U) {
#line 2059
      check_pterm = 1;
    }
  }
#line 2062
  compno = (OPJ_UINT32 )0;
  {
#line 2062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2062
    if (! (compno < l_tile->numcomps)) {
#line 2062
      goto while_break;
    }
#line 2064
    if (p_tcd->used_component != (void *)0) {
#line 2064
      if (! *(p_tcd->used_component + compno)) {
#line 2065
        goto while_continue;
      }
    }
    {
#line 2068
    opj_t1_decode_cblks(p_tcd, & ret, l_tile_comp, l_tccp, p_manager, p_manager_mutex,
                        check_pterm);
    }
#line 2070
    if (! ret) {
#line 2071
      goto while_break;
    }
#line 2063
    l_tccp ++;
#line 2063
    l_tile_comp ++;
#line 2063
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2075
  opj_thread_pool_wait_completion(p_tcd->thread_pool, 0);
  }
#line 2076
  if (p_manager_mutex) {
    {
#line 2077
    opj_mutex_destroy(p_manager_mutex);
    }
  }
#line 2079
  return (ret);
}
}
#line 2083 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 2086
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2087
  l_tile_comp = l_tile->comps;
#line 2088
  l_tccp = (p_tcd->tcp)->tccps;
#line 2089
  l_img_comp = (p_tcd->image)->comps;
#line 2091
  compno = (OPJ_UINT32 )0;
  {
#line 2091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2091
    if (! (compno < l_tile->numcomps)) {
#line 2091
      goto while_break;
    }
#line 2093
    if (p_tcd->used_component != (void *)0) {
#line 2093
      if (! *(p_tcd->used_component + compno)) {
#line 2094
        goto while_continue;
      }
    }
#line 2097
    if (l_tccp->qmfbid == 1U) {
      {
#line 2098
      __cil_tmp7 = opj_dwt_decode(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 2098
      if (! __cil_tmp7) {
#line 2100
        return (0);
      }
    } else {
      {
#line 2103
      __cil_tmp8 = opj_dwt_decode_real(p_tcd, l_tile_comp, l_img_comp->resno_decoded + 1U);
      }
#line 2103
      if (! __cil_tmp8) {
#line 2105
        return (0);
      }
    }
#line 2092
    l_tccp ++;
#line 2092
    l_img_comp ++;
#line 2092
    l_tile_comp ++;
#line 2092
    __cil_tmp9 = compno;
#line 2092
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2111
  return (1);
}
}
#line 2114 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_decode(opj_tcd_t *p_tcd , opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcp_t *l_tcp ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_SIZE_T l_samples ;
  OPJ_UINT32 i ;
  opj_tcd_resolution_t *res_comp0 ;
  opj_tcd_resolution_t *res_comp1 ;
  opj_tcd_resolution_t *res_comp2 ;
  opj_tcd_resolution_t *res_comp0___0 ;
  opj_tcd_resolution_t *res_comp1___0 ;
  opj_tcd_resolution_t *res_comp2___0 ;
  OPJ_BYTE **l_data ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;

  {
#line 2116
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2117
  l_tcp = p_tcd->tcp;
#line 2118
  l_tile_comp = l_tile->comps;
#line 2122
  if (p_tcd->used_component != (void *)0) {
#line 2123
    return (1);
  } else
#line 2122
  if (l_tcp->mct == 0U) {
#line 2123
    return (1);
  }
#line 2126
  if (p_tcd->whole_tile_decoding) {
#line 2127
    res_comp0 = ((l_tile->comps + 0)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2133
    l_samples = (OPJ_SIZE_T )(res_comp0->x1 - res_comp0->x0) * (OPJ_SIZE_T )(res_comp0->y1 - res_comp0->y0);
#line 2135
    if (l_tile->numcomps >= 3U) {
#line 2136
      if (l_tile_comp->minimum_num_resolutions != (l_tile->comps + 1)->minimum_num_resolutions) {
        {
        {
#line 2140
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
#line 2142
        return (0);
      } else
#line 2136
      if (l_tile_comp->minimum_num_resolutions != (l_tile->comps + 2)->minimum_num_resolutions) {
        {
        {
#line 2140
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
#line 2142
        return (0);
      }
    }
#line 2145
    if (l_tile->numcomps >= 3U) {
#line 2146
      res_comp1 = ((l_tile->comps + 1)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2148
      res_comp2 = ((l_tile->comps + 2)->resolutions + l_tile_comp->minimum_num_resolutions) - 1;
#line 2151
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 1)->resno_decoded) {
        {
        {
        {
        {
#line 2159
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2161
        return (0);
      } else
#line 2151
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 2)->resno_decoded) {
        {
        {
        {
        {
#line 2159
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2161
        return (0);
      } else
#line 2151
      if ((OPJ_SIZE_T )(res_comp1->x1 - res_comp1->x0) * (OPJ_SIZE_T )(res_comp1->y1 - res_comp1->y0) != l_samples) {
        {
        {
        {
        {
#line 2159
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2161
        return (0);
      } else
#line 2151
      if ((OPJ_SIZE_T )(res_comp2->x1 - res_comp2->x0) * (OPJ_SIZE_T )(res_comp2->y1 - res_comp2->y0) != l_samples) {
        {
        {
        {
        {
#line 2159
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2161
        return (0);
      }
    }
  } else {
#line 2165
    res_comp0___0 = (l_tile->comps + 0)->resolutions + ((p_tcd->image)->comps + 0)->resno_decoded;
#line 2168
    l_samples = (OPJ_SIZE_T )(res_comp0___0->win_x1 - res_comp0___0->win_x0) * (OPJ_SIZE_T )(res_comp0___0->win_y1 - res_comp0___0->win_y0);
#line 2170
    if (l_tile->numcomps >= 3U) {
#line 2171
      res_comp1___0 = (l_tile->comps + 1)->resolutions + ((p_tcd->image)->comps + 1)->resno_decoded;
#line 2173
      res_comp2___0 = (l_tile->comps + 2)->resolutions + ((p_tcd->image)->comps + 2)->resno_decoded;
#line 2176
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 1)->resno_decoded) {
        {
        {
        {
        {
#line 2184
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2186
        return (0);
      } else
#line 2176
      if (((p_tcd->image)->comps + 0)->resno_decoded != ((p_tcd->image)->comps + 2)->resno_decoded) {
        {
        {
        {
        {
#line 2184
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2186
        return (0);
      } else
#line 2176
      if ((OPJ_SIZE_T )(res_comp1___0->win_x1 - res_comp1___0->win_x0) * (OPJ_SIZE_T )(res_comp1___0->win_y1 - res_comp1___0->win_y0) != l_samples) {
        {
        {
        {
        {
#line 2184
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2186
        return (0);
      } else
#line 2176
      if ((OPJ_SIZE_T )(res_comp2___0->win_x1 - res_comp2___0->win_x0) * (OPJ_SIZE_T )(res_comp2___0->win_y1 - res_comp2___0->win_y0) != l_samples) {
        {
        {
        {
        {
#line 2184
        opj_event_msg(p_manager, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
        }
#line 2186
        return (0);
      }
    }
  }
#line 2191
  if (l_tile->numcomps >= 3U) {
#line 2192
    if (l_tcp->mct == 2U) {
#line 2195
      if (! l_tcp->m_mct_decoding_matrix) {
#line 2196
        return (1);
      }
      {
#line 2199
      __cil_tmp15 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2199
      l_data = (OPJ_BYTE **)__cil_tmp15;
      }
#line 2200
      if (! l_data) {
#line 2201
        return (0);
      }
#line 2204
      i = (OPJ_UINT32 )0;
      {
#line 2204
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2204
        if (! (i < l_tile->numcomps)) {
#line 2204
          goto while_break;
        }
#line 2205
        if (p_tcd->whole_tile_decoding) {
#line 2206
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
        } else {
#line 2208
          *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data_win;
        }
#line 2210
        l_tile_comp ++;
#line 2204
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2213
      __cil_tmp16 = opj_mct_decode_custom((OPJ_BYTE *)l_tcp->m_mct_decoding_matrix,
                                          l_samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
      }
#line 2213
      if (! __cil_tmp16) {
        {
#line 2223
        opj_free(l_data);
        }
#line 2224
        return (0);
      }
      {
#line 2227
      opj_free(l_data);
      }
    } else
#line 2229
    if ((l_tcp->tccps)->qmfbid == 1U) {
#line 2230
      if (p_tcd->whole_tile_decoding) {
        {
#line 2231
        opj_mct_decode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                       l_samples);
        }
      } else {
        {
#line 2236
        opj_mct_decode((l_tile->comps + 0)->data_win, (l_tile->comps + 1)->data_win,
                       (l_tile->comps + 2)->data_win, l_samples);
        }
      }
    } else
#line 2242
    if (p_tcd->whole_tile_decoding) {
      {
#line 2243
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, l_samples);
      }
    } else {
      {
#line 2248
      opj_mct_decode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data_win, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data_win,
                          (OPJ_FLOAT32 *)(l_tile->comps + 2)->data_win, l_samples);
      }
    }
  } else {
    {
#line 2256
    opj_event_msg(p_manager, 1, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
                  l_tile->numcomps);
    }
  }
#line 2261
  return (1);
}
}
#line 2265 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_decode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_tile_t *l_tile ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_INT32 l_min ;
  OPJ_INT32 l_max ;
  OPJ_UINT32 l_stride ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_FLOAT32 l_value ;
  OPJ_INT64 l_value_int ;
  long __cil_tmp19 ;
  OPJ_INT64 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;

  {
#line 2268
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2269
  l_tccp = (opj_tccp_t *)0;
#line 2270
  l_img_comp = (opj_image_comp_t *)0;
#line 2271
  l_res = (opj_tcd_resolution_t *)0;
#line 2278
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2279
  l_tile_comp = l_tile->comps;
#line 2280
  l_tccp = (p_tcd->tcp)->tccps;
#line 2281
  l_img_comp = (p_tcd->image)->comps;
#line 2283
  compno = (OPJ_UINT32 )0;
  {
#line 2283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2283
    if (! (compno < l_tile->numcomps)) {
#line 2283
      goto while_break;
    }
#line 2286
    if (p_tcd->used_component != (void *)0) {
#line 2286
      if (! *(p_tcd->used_component + compno)) {
#line 2287
        goto while_continue;
      }
    }
#line 2290
    l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
#line 2292
    if (! p_tcd->whole_tile_decoding) {
#line 2293
      l_width = l_res->win_x1 - l_res->win_x0;
#line 2294
      l_height = l_res->win_y1 - l_res->win_y0;
#line 2295
      l_stride = (OPJ_UINT32 )0;
#line 2296
      l_current_ptr = l_tile_comp->data_win;
    } else {
#line 2298
      l_width = (OPJ_UINT32 )(l_res->x1 - l_res->x0);
#line 2299
      l_height = (OPJ_UINT32 )(l_res->y1 - l_res->y0);
#line 2300
      l_stride = (OPJ_UINT32 )((l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x1 - (l_tile_comp->resolutions + (l_tile_comp->minimum_num_resolutions - 1U))->x0) - l_width;
#line 2304
      l_current_ptr = l_tile_comp->data;
    }
#line 2310
    if (l_img_comp->sgnd) {
#line 2311
      l_min = - (1 << (l_img_comp->prec - 1U));
#line 2312
      l_max = (1 << (l_img_comp->prec - 1U)) - 1;
    } else {
#line 2314
      l_min = 0;
#line 2315
      l_max = (OPJ_INT32 )((1U << l_img_comp->prec) - 1U);
    }
#line 2319
    if (l_tccp->qmfbid == 1U) {
#line 2320
      j = (OPJ_UINT32 )0;
      {
#line 2320
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2320
        if (! (j < l_height)) {
#line 2320
          goto while_break___0;
        }
#line 2321
        i = (OPJ_UINT32 )0;
        {
#line 2321
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2321
          if (! (i < l_width)) {
#line 2321
            goto while_break___1;
          }
          {
#line 2323
          *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift,
                                         l_min, l_max);
#line 2325
          l_current_ptr ++;
          }
#line 2321
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2327
        l_current_ptr += l_stride;
#line 2320
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2330
      j = (OPJ_UINT32 )0;
      {
#line 2330
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2330
        if (! (j < l_height)) {
#line 2330
          goto while_break___2;
        }
#line 2331
        i = (OPJ_UINT32 )0;
        {
#line 2331
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2331
          if (! (i < l_width)) {
#line 2331
            goto while_break___3;
          }
#line 2332
          l_value = *((OPJ_FLOAT32 *)l_current_ptr);
#line 2333
          if (l_value > (float )2147483647) {
#line 2334
            *l_current_ptr = l_max;
          } else
#line 2335
          if (l_value < (float )(-0x7FFFFFFF-1)) {
#line 2336
            *l_current_ptr = l_min;
          } else {
            {
#line 2339
            __cil_tmp19 = opj_lrintf(l_value);
#line 2339
            l_value_int = (OPJ_INT64 )__cil_tmp19;
#line 2340
            __cil_tmp20 = opj_int64_clamp(l_value_int + (long )l_tccp->m_dc_level_shift,
                                          (OPJ_INT64 )l_min, (OPJ_INT64 )l_max);
#line 2340
            *l_current_ptr = (OPJ_INT32 )__cil_tmp20;
            }
          }
#line 2343
          l_current_ptr ++;
#line 2331
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2345
        l_current_ptr += l_stride;
#line 2330
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2284
    l_tile_comp ++;
#line 2284
    l_tccp ++;
#line 2284
    l_img_comp ++;
#line 2284
    __cil_tmp21 = compno;
#line 2284
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2350
  return (1);
}
}
#line 2358 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_dec_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_dec_t *l_code_block ;

  {
#line 2362
  l_code_block = p_precinct->cblks.dec;
#line 2363
  if (l_code_block) {
#line 2370
    l_nb_code_blocks = p_precinct->block_size / (OPJ_UINT32 )sizeof(opj_tcd_cblk_dec_t );
#line 2374
    cblkno = (OPJ_UINT32 )0;
    {
#line 2374
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2374
      if (! (cblkno < l_nb_code_blocks)) {
#line 2374
        goto while_break;
      }
#line 2376
      if (l_code_block->segs) {
        {
#line 2377
        opj_free(l_code_block->segs);
#line 2378
        l_code_block->segs = (opj_tcd_seg_t *)0;
        }
      }
#line 2381
      if (l_code_block->chunks) {
        {
#line 2382
        opj_free(l_code_block->chunks);
#line 2383
        l_code_block->chunks = (opj_tcd_seg_data_chunk_t *)0;
        }
      }
      {
#line 2386
      opj_aligned_free(l_code_block->decoded_data);
#line 2387
      l_code_block->decoded_data = (OPJ_INT32 *)((void *)0);
#line 2389
      l_code_block ++;
      }
#line 2374
      cblkno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2392
    opj_free(p_precinct->cblks.dec);
#line 2393
    p_precinct->cblks.dec = (opj_tcd_cblk_dec_t *)0;
    }
  }
  return;
}
}
#line 2400 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static void opj_tcd_code_block_enc_deallocate(opj_tcd_precinct_t *p_precinct ) 
{ 
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_cblk_enc_t *l_code_block ;

  {
#line 2404
  l_code_block = p_precinct->cblks.enc;
#line 2405
  if (l_code_block) {
#line 2406
    l_nb_code_blocks = p_precinct->block_size / (OPJ_UINT32 )sizeof(opj_tcd_cblk_enc_t );
#line 2409
    cblkno = (OPJ_UINT32 )0;
    {
#line 2409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2409
      if (! (cblkno < l_nb_code_blocks)) {
#line 2409
        goto while_break;
      }
#line 2410
      if (l_code_block->data) {
        {
#line 2413
        opj_free(l_code_block->data - 1);
#line 2414
        l_code_block->data = (OPJ_BYTE *)0;
        }
      }
#line 2417
      if (l_code_block->layers) {
        {
#line 2418
        opj_free(l_code_block->layers);
#line 2419
        l_code_block->layers = (opj_tcd_layer_t *)0;
        }
      }
#line 2422
      if (l_code_block->passes) {
        {
#line 2423
        opj_free(l_code_block->passes);
#line 2424
        l_code_block->passes = (opj_tcd_pass_t *)0;
        }
      }
#line 2426
      l_code_block ++;
#line 2409
      cblkno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2429
    opj_free(p_precinct->cblks.enc);
#line 2431
    p_precinct->cblks.enc = (opj_tcd_cblk_enc_t *)0;
    }
  }
  return;
}
}
#line 2435 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_SIZE_T opj_tcd_get_encoder_input_buffer_size(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;

  {
#line 2438
  l_data_size = (OPJ_SIZE_T )0;
#line 2439
  l_img_comp = (opj_image_comp_t *)0;
#line 2440
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2443
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2444
  l_img_comp = (p_tcd->image)->comps;
#line 2445
  i = (OPJ_UINT32 )0;
  {
#line 2445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2445
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2445
      goto while_break;
    }
#line 2446
    l_size_comp = l_img_comp->prec >> 3;
#line 2447
    l_remaining = l_img_comp->prec & 7U;
#line 2449
    if (l_remaining) {
#line 2450
      l_size_comp ++;
    }
#line 2453
    if (l_size_comp == 3U) {
#line 2454
      l_size_comp = (OPJ_UINT32 )4;
    }
#line 2457
    l_data_size += (unsigned long )l_size_comp * ((OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0));
#line 2459
    l_img_comp ++;
#line 2460
    l_tilec ++;
#line 2445
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2463
  return (l_data_size);
}
}
#line 2466 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dc_level_shift_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_UINT32 compno ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tile_t *l_tile ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_SIZE_T i ;
  OPJ_INT32 *l_current_ptr ;
  OPJ_UINT32 __cil_tmp10 ;

  {
#line 2469
  l_tile_comp = (opj_tcd_tilecomp_t *)0;
#line 2470
  l_tccp = (opj_tccp_t *)0;
#line 2471
  l_img_comp = (opj_image_comp_t *)0;
#line 2476
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2477
  l_tile_comp = l_tile->comps;
#line 2478
  l_tccp = (p_tcd->tcp)->tccps;
#line 2479
  l_img_comp = (p_tcd->image)->comps;
#line 2481
  compno = (OPJ_UINT32 )0;
  {
#line 2481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2481
    if (! (compno < l_tile->numcomps)) {
#line 2481
      goto while_break;
    }
#line 2482
    l_current_ptr = l_tile_comp->data;
#line 2483
    l_nb_elem = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2486
    if (l_tccp->qmfbid == 1U) {
#line 2487
      i = (OPJ_SIZE_T )0;
      {
#line 2487
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2487
        if (! (i < l_nb_elem)) {
#line 2487
          goto while_break___0;
        }
#line 2488
        *l_current_ptr -= l_tccp->m_dc_level_shift;
#line 2489
        l_current_ptr ++;
#line 2487
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2492
      i = (OPJ_SIZE_T )0;
      {
#line 2492
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2492
        if (! (i < l_nb_elem)) {
#line 2492
          goto while_break___1;
        }
#line 2493
        *((OPJ_FLOAT32 *)l_current_ptr) = (OPJ_FLOAT32 )(*l_current_ptr - l_tccp->m_dc_level_shift);
#line 2495
        l_current_ptr ++;
#line 2492
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2499
    l_img_comp ++;
#line 2500
    l_tccp ++;
#line 2501
    l_tile_comp ++;
#line 2481
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2504
  return (1);
}
}
#line 2507 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_mct_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  OPJ_SIZE_T samples ;
  OPJ_UINT32 i ;
  OPJ_BYTE **l_data ;
  opj_tcp_t *l_tcp ;
  void *__cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
#line 2509
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2510
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2511
  samples = (OPJ_SIZE_T )(l_tile_comp->x1 - l_tile_comp->x0) * (OPJ_SIZE_T )(l_tile_comp->y1 - l_tile_comp->y0);
#line 2514
  l_data = (OPJ_BYTE **)0;
#line 2515
  l_tcp = p_tcd->tcp;
#line 2517
  if (! (p_tcd->tcp)->mct) {
#line 2518
    return (1);
  }
#line 2521
  if ((p_tcd->tcp)->mct == 2U) {
#line 2522
    if (! (p_tcd->tcp)->m_mct_coding_matrix) {
#line 2523
      return (1);
    }
    {
#line 2526
    __cil_tmp8 = opj_malloc((unsigned long )l_tile->numcomps * sizeof(OPJ_BYTE *));
#line 2526
    l_data = (OPJ_BYTE **)__cil_tmp8;
    }
#line 2527
    if (! l_data) {
#line 2528
      return (0);
    }
#line 2531
    i = (OPJ_UINT32 )0;
    {
#line 2531
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2531
      if (! (i < l_tile->numcomps)) {
#line 2531
        goto while_break;
      }
#line 2532
      *(l_data + i) = (OPJ_BYTE *)l_tile_comp->data;
#line 2533
      l_tile_comp ++;
#line 2531
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2536
    __cil_tmp9 = opj_mct_encode_custom((OPJ_BYTE *)(p_tcd->tcp)->m_mct_coding_matrix,
                                       samples, l_data, l_tile->numcomps, ((p_tcd->image)->comps)->sgnd);
    }
#line 2536
    if (! __cil_tmp9) {
      {
#line 2546
      opj_free(l_data);
      }
#line 2547
      return (0);
    }
    {
#line 2550
    opj_free(l_data);
    }
  } else
#line 2551
  if ((l_tcp->tccps)->qmfbid == 0U) {
    {
#line 2552
    opj_mct_encode_real((OPJ_FLOAT32 *)(l_tile->comps + 0)->data, (OPJ_FLOAT32 *)(l_tile->comps + 1)->data,
                        (OPJ_FLOAT32 *)(l_tile->comps + 2)->data, samples);
    }
  } else {
    {
#line 2558
    opj_mct_encode((l_tile->comps + 0)->data, (l_tile->comps + 1)->data, (l_tile->comps + 2)->data,
                   samples);
    }
  }
#line 2562
  return (1);
}
}
#line 2565 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_dwt_encode(opj_tcd_t *p_tcd ) 
{ 
  opj_tcd_tile_t *l_tile ;
  opj_tcd_tilecomp_t *l_tile_comp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2567
  l_tile = (p_tcd->tcd_image)->tiles;
#line 2568
  l_tile_comp = ((p_tcd->tcd_image)->tiles)->comps;
#line 2569
  l_tccp = (p_tcd->tcp)->tccps;
#line 2572
  compno = (OPJ_UINT32 )0;
  {
#line 2572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2572
    if (! (compno < l_tile->numcomps)) {
#line 2572
      goto while_break;
    }
#line 2573
    if (l_tccp->qmfbid == 1U) {
      {
#line 2574
      __cil_tmp6 = opj_dwt_encode(p_tcd, l_tile_comp);
      }
#line 2574
      if (! __cil_tmp6) {
#line 2575
        return (0);
      }
    } else
#line 2577
    if (l_tccp->qmfbid == 0U) {
      {
#line 2578
      __cil_tmp7 = opj_dwt_encode_real(p_tcd, l_tile_comp);
      }
#line 2578
      if (! __cil_tmp7) {
#line 2579
        return (0);
      }
    }
#line 2583
    l_tile_comp ++;
#line 2584
    l_tccp ++;
#line 2572
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2587
  return (1);
}
}
#line 2590 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd ) 
{ 
  OPJ_FLOAT64 *l_mct_norms ;
  OPJ_UINT32 l_mct_numcomps ;
  opj_tcp_t *l_tcp ;
  OPJ_FLOAT64 *__cil_tmp5 ;
  OPJ_FLOAT64 *__cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 2593
  l_mct_numcomps = 0U;
#line 2594
  l_tcp = p_tcd->tcp;
#line 2596
  if (l_tcp->mct == 1U) {
#line 2597
    l_mct_numcomps = 3U;
#line 2599
    if ((l_tcp->tccps)->qmfbid == 0U) {
      {
#line 2600
      l_mct_norms = opj_mct_get_mct_norms_real();
      }
    } else {
      {
#line 2602
      l_mct_norms = opj_mct_get_mct_norms();
      }
    }
  } else {
#line 2605
    l_mct_numcomps = (p_tcd->image)->numcomps;
#line 2606
    l_mct_norms = (OPJ_FLOAT64 *)l_tcp->mct_norms;
  }
  {
#line 2609
  __cil_tmp7 = opj_t1_encode_cblks(p_tcd, (p_tcd->tcd_image)->tiles, l_tcp, l_mct_norms,
                                   l_mct_numcomps);
  }
#line 2609
  return (__cil_tmp7);
#line 2613
  return (1);
}
}
#line 2616 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_t2_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data , OPJ_UINT32 *p_data_written ,
                                  OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                  opj_tcd_marker_info_t *p_marker_info , opj_event_mgr_t *p_manager ) 
{ 
  opj_t2_t *l_t2 ;
  opj_t2_t *__cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2626
  l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
  }
#line 2627
  if (l_t2 == (opj_t2_t *)0) {
#line 2628
    return (0);
  }
  {
#line 2631
  __cil_tmp10 = opj_t2_encode_packets(l_t2, p_tcd->tcd_tileno, (p_tcd->tcd_image)->tiles,
                                      (p_tcd->tcp)->numlayers, p_dest_data, p_data_written,
                                      p_max_dest_size, p_cstr_info, p_marker_info,
                                      p_tcd->tp_num, p_tcd->tp_pos, p_tcd->cur_pino,
                                      (J2K_T2_MODE )1, p_manager);
  }
#line 2631
  if (! __cil_tmp10) {
    {
#line 2646
    opj_t2_destroy(l_t2);
    }
#line 2647
    return (0);
  }
  {
#line 2650
  opj_t2_destroy(l_t2);
  }
#line 2653
  return (1);
}
}
#line 2657 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_rate_allocate_encode(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest_data ,
                                             OPJ_UINT32 p_max_dest_size , opj_codestream_info_t *p_cstr_info ,
                                             opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_nb_written ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 2663
  l_cp = p_tcd->cp;
#line 2664
  l_nb_written = (OPJ_UINT32 )0;
#line 2666
  if (p_cstr_info) {
#line 2667
    p_cstr_info->index_write = 0;
  }
#line 2670
  if ((unsigned int )l_cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 0U) {
    _L: /* CIL Label */ 
    {
#line 2674
    __cil_tmp8 = opj_tcd_rateallocate(p_tcd, p_dest_data, & l_nb_written, p_max_dest_size,
                                      p_cstr_info, p_manager);
    }
#line 2674
    if (! __cil_tmp8) {
#line 2676
      return (0);
    }
  } else
#line 2670
  if ((unsigned int )l_cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 1U) {
#line 2670
    goto _L;
  } else {
    {
#line 2680
    opj_tcd_rateallocate_fixed(p_tcd);
    }
  }
#line 2683
  return (1);
}
}
#line 2687 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) 
{ 
  OPJ_UINT32 i ;
  OPJ_SIZE_T j ;
  OPJ_SIZE_T l_data_size ;
  opj_image_comp_t *l_img_comp ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_remaining ;
  OPJ_SIZE_T l_nb_elem ;
  OPJ_SIZE_T __cil_tmp12 ;
  OPJ_CHAR *l_src_ptr ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 *__cil_tmp15 ;
  OPJ_CHAR *__cil_tmp16 ;
  OPJ_INT32 *__cil_tmp17 ;
  OPJ_CHAR *__cil_tmp18 ;
  OPJ_INT32 *l_dest_ptr___0 ;
  OPJ_INT16 *l_src_ptr___0 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT16 *__cil_tmp24 ;
  OPJ_INT32 *l_src_ptr___1 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp27 ;
  OPJ_INT32 *__cil_tmp28 ;

  {
  {
#line 2693
  l_data_size = (OPJ_SIZE_T )0;
#line 2694
  l_img_comp = (opj_image_comp_t *)0;
#line 2695
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 2699
  l_data_size = opj_tcd_get_encoder_input_buffer_size(p_tcd);
  }
#line 2700
  if (l_data_size != p_src_length) {
#line 2701
    return (0);
  }
#line 2704
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 2705
  l_img_comp = (p_tcd->image)->comps;
#line 2706
  i = (OPJ_UINT32 )0;
  {
#line 2706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2706
    if (! (i < (p_tcd->image)->numcomps)) {
#line 2706
      goto while_break;
    }
#line 2707
    l_size_comp = l_img_comp->prec >> 3;
#line 2708
    l_remaining = l_img_comp->prec & 7U;
#line 2709
    l_nb_elem = (OPJ_SIZE_T )(l_tilec->x1 - l_tilec->x0) * (OPJ_SIZE_T )(l_tilec->y1 - l_tilec->y0);
#line 2712
    if (l_remaining) {
#line 2713
      l_size_comp ++;
    }
#line 2716
    if (l_size_comp == 3U) {
#line 2717
      l_size_comp = (OPJ_UINT32 )4;
    }
    {
#line 2721
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 2721
      goto case_1;
    }
#line 2738
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 2738
      goto case_2;
    }
#line 2755
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 2755
      goto case_4;
    }
#line 2720
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2722
    l_src_ptr = (OPJ_CHAR *)p_src;
#line 2723
    l_dest_ptr = l_tilec->data;
#line 2725
    if (l_img_comp->sgnd) {
#line 2726
      j = (OPJ_SIZE_T )0;
      {
#line 2726
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2726
        if (! (j < l_nb_elem)) {
#line 2726
          goto while_break___0;
        }
#line 2727
        __cil_tmp16 = l_src_ptr;
#line 2727
        l_src_ptr ++;
#line 2727
        __cil_tmp15 = l_dest_ptr;
#line 2727
        l_dest_ptr ++;
#line 2727
        *__cil_tmp15 = (OPJ_INT32 )*__cil_tmp16;
#line 2726
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2730
      j = (OPJ_SIZE_T )0;
      {
#line 2730
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2730
        if (! (j < l_nb_elem)) {
#line 2730
          goto while_break___1;
        }
#line 2731
        __cil_tmp18 = l_src_ptr;
#line 2731
        l_src_ptr ++;
#line 2731
        __cil_tmp17 = l_dest_ptr;
#line 2731
        l_dest_ptr ++;
#line 2731
        *__cil_tmp17 = (int )*__cil_tmp18 & 255;
#line 2730
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2735
    p_src = (OPJ_BYTE *)l_src_ptr;
#line 2737
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2739
    l_dest_ptr___0 = l_tilec->data;
#line 2740
    l_src_ptr___0 = (OPJ_INT16 *)p_src;
#line 2742
    if (l_img_comp->sgnd) {
#line 2743
      j = (OPJ_SIZE_T )0;
      {
#line 2743
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2743
        if (! (j < l_nb_elem)) {
#line 2743
          goto while_break___2;
        }
#line 2744
        __cil_tmp22 = l_src_ptr___0;
#line 2744
        l_src_ptr___0 ++;
#line 2744
        __cil_tmp21 = l_dest_ptr___0;
#line 2744
        l_dest_ptr___0 ++;
#line 2744
        *__cil_tmp21 = (OPJ_INT32 )*__cil_tmp22;
#line 2743
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2747
      j = (OPJ_SIZE_T )0;
      {
#line 2747
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2747
        if (! (j < l_nb_elem)) {
#line 2747
          goto while_break___3;
        }
#line 2748
        __cil_tmp24 = l_src_ptr___0;
#line 2748
        l_src_ptr___0 ++;
#line 2748
        __cil_tmp23 = l_dest_ptr___0;
#line 2748
        l_dest_ptr___0 ++;
#line 2748
        *__cil_tmp23 = (int )*__cil_tmp24 & 65535;
#line 2747
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 2752
    p_src = (OPJ_BYTE *)l_src_ptr___0;
#line 2754
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2756
    l_src_ptr___1 = (OPJ_INT32 *)p_src;
#line 2757
    l_dest_ptr___1 = l_tilec->data;
#line 2759
    j = (OPJ_SIZE_T )0;
    {
#line 2759
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2759
      if (! (j < l_nb_elem)) {
#line 2759
        goto while_break___4;
      }
#line 2760
      __cil_tmp28 = l_src_ptr___1;
#line 2760
      l_src_ptr___1 ++;
#line 2760
      __cil_tmp27 = l_dest_ptr___1;
#line 2760
      l_dest_ptr___1 ++;
#line 2760
      *__cil_tmp27 = (OPJ_INT32 )*__cil_tmp28;
#line 2759
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2763
    p_src = (OPJ_BYTE *)l_src_ptr___1;
#line 2765
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2768
    l_img_comp ++;
#line 2769
    l_tilec ++;
#line 2706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2772
  return (1);
}
}
#line 2775 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) 
{ 


  {
#line 2777
  return (band->x1 - band->x0 == 0 || band->y1 - band->y0 == 0);
}
}
#line 2780 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 band_x0 , OPJ_UINT32 band_y0 ,
                                             OPJ_UINT32 band_x1 , OPJ_UINT32 band_y1 ) 
{ 
  OPJ_UINT32 filter_margin ;
  int tmp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 nb ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 x0b ;
  OPJ_UINT32 y0b ;
  OPJ_UINT32 tbx0 ;
  OPJ_UINT32 __cil_tmp30 ;
  unsigned int tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_UINT32 tby0 ;
  OPJ_UINT32 __cil_tmp34 ;
  unsigned int tmp___3 ;
  OPJ_UINT32 tmp___4 ;
  OPJ_UINT32 tbx1 ;
  OPJ_UINT32 __cil_tmp38 ;
  unsigned int tmp___5 ;
  OPJ_UINT32 tmp___6 ;
  OPJ_UINT32 tby1 ;
  OPJ_UINT32 __cil_tmp42 ;
  unsigned int tmp___7 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_BOOL intersects ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;

  {
#line 2797
  if (((tcd->tcp)->tccps + compno)->qmfbid == 1U) {
#line 2797
    tmp = 2;
  } else {
#line 2797
    tmp = 3;
  }
  {
#line 2797
  filter_margin = (OPJ_UINT32 )tmp;
#line 2798
  tilec = ((tcd->tcd_image)->tiles)->comps + compno;
#line 2799
  image_comp = (tcd->image)->comps + compno;
#line 2802
  __cil_tmp14 = opj_uint_ceildiv(tcd->win_x0, image_comp->dx);
#line 2802
  __cil_tmp15 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp14);
#line 2802
  tcx0 = __cil_tmp15;
#line 2805
  __cil_tmp17 = opj_uint_ceildiv(tcd->win_y0, image_comp->dy);
#line 2805
  __cil_tmp18 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp17);
#line 2805
  tcy0 = __cil_tmp18;
#line 2808
  __cil_tmp20 = opj_uint_ceildiv(tcd->win_x1, image_comp->dx);
#line 2808
  __cil_tmp21 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp20);
#line 2808
  tcx1 = __cil_tmp21;
#line 2811
  __cil_tmp23 = opj_uint_ceildiv(tcd->win_y1, image_comp->dy);
#line 2811
  __cil_tmp24 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp23);
#line 2811
  tcy1 = __cil_tmp24;
  }
#line 2815
  if (resno == 0U) {
#line 2815
    tmp___0 = tilec->numresolutions - 1U;
  } else {
#line 2815
    tmp___0 = tilec->numresolutions - resno;
  }
#line 2815
  nb = tmp___0;
#line 2820
  x0b = bandno & 1U;
#line 2821
  y0b = bandno >> 1;
#line 2822
  if (nb == 0U) {
#line 2822
    tmp___2 = tcx0;
  } else {
#line 2822
    if (tcx0 <= (1U << (nb - 1U)) * x0b) {
#line 2822
      tmp___1 = (unsigned int )0;
    } else {
      {
#line 2822
      __cil_tmp30 = opj_uint_ceildivpow2(tcx0 - (1U << (nb - 1U)) * x0b, nb);
#line 2822
      tmp___1 = __cil_tmp30;
      }
    }
#line 2822
    tmp___2 = tmp___1;
  }
#line 2822
  tbx0 = tmp___2;
#line 2825
  if (nb == 0U) {
#line 2825
    tmp___4 = tcy0;
  } else {
#line 2825
    if (tcy0 <= (1U << (nb - 1U)) * y0b) {
#line 2825
      tmp___3 = (unsigned int )0;
    } else {
      {
#line 2825
      __cil_tmp34 = opj_uint_ceildivpow2(tcy0 - (1U << (nb - 1U)) * y0b, nb);
#line 2825
      tmp___3 = __cil_tmp34;
      }
    }
#line 2825
    tmp___4 = tmp___3;
  }
#line 2825
  tby0 = tmp___4;
#line 2828
  if (nb == 0U) {
#line 2828
    tmp___6 = tcx1;
  } else {
#line 2828
    if (tcx1 <= (1U << (nb - 1U)) * x0b) {
#line 2828
      tmp___5 = (unsigned int )0;
    } else {
      {
#line 2828
      __cil_tmp38 = opj_uint_ceildivpow2(tcx1 - (1U << (nb - 1U)) * x0b, nb);
#line 2828
      tmp___5 = __cil_tmp38;
      }
    }
#line 2828
    tmp___6 = tmp___5;
  }
#line 2828
  tbx1 = tmp___6;
#line 2831
  if (nb == 0U) {
#line 2831
    tmp___8 = tcy1;
  } else {
#line 2831
    if (tcy1 <= (1U << (nb - 1U)) * y0b) {
#line 2831
      tmp___7 = (unsigned int )0;
    } else {
      {
#line 2831
      __cil_tmp42 = opj_uint_ceildivpow2(tcy1 - (1U << (nb - 1U)) * y0b, nb);
#line 2831
      tmp___7 = __cil_tmp42;
      }
    }
#line 2831
    tmp___8 = tmp___7;
  }
#line 2831
  tby1 = tmp___8;
#line 2836
  if (tbx0 < filter_margin) {
#line 2837
    tbx0 = (OPJ_UINT32 )0;
  } else {
#line 2839
    tbx0 -= filter_margin;
  }
#line 2841
  if (tby0 < filter_margin) {
#line 2842
    tby0 = (OPJ_UINT32 )0;
  } else {
#line 2844
    tby0 -= filter_margin;
  }
  {
#line 2846
  tbx1 = opj_uint_adds(tbx1, filter_margin);
#line 2847
  tby1 = opj_uint_adds(tby1, filter_margin);
#line 2849
  intersects = ((band_x0 < tbx1 && band_y0 < tby1) && band_x1 > tbx0) && band_y1 > tby0;
  }
#line 2858
  return (intersects);
}
}
#line 2868 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
static OPJ_BOOL opj_tcd_is_whole_tilecomp_decoding(opj_tcd_t *p_tcd , OPJ_UINT32 compno ) 
{ 
  opj_tcd_tilecomp_t *tilec ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 tcx0 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 tcy0 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tcx1 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 tcy1 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 shift ;

  {
  {
#line 2871
  tilec = ((p_tcd->tcd_image)->tiles)->comps + compno;
#line 2872
  image_comp = (p_tcd->image)->comps + compno;
#line 2875
  __cil_tmp6 = opj_uint_ceildiv(p_tcd->win_x0, image_comp->dx);
#line 2875
  __cil_tmp7 = opj_uint_max((OPJ_UINT32 )tilec->x0, __cil_tmp6);
#line 2875
  tcx0 = __cil_tmp7;
#line 2878
  __cil_tmp9 = opj_uint_ceildiv(p_tcd->win_y0, image_comp->dy);
#line 2878
  __cil_tmp10 = opj_uint_max((OPJ_UINT32 )tilec->y0, __cil_tmp9);
#line 2878
  tcy0 = __cil_tmp10;
#line 2881
  __cil_tmp12 = opj_uint_ceildiv(p_tcd->win_x1, image_comp->dx);
#line 2881
  __cil_tmp13 = opj_uint_min((OPJ_UINT32 )tilec->x1, __cil_tmp12);
#line 2881
  tcx1 = __cil_tmp13;
#line 2884
  __cil_tmp15 = opj_uint_ceildiv(p_tcd->win_y1, image_comp->dy);
#line 2884
  __cil_tmp16 = opj_uint_min((OPJ_UINT32 )tilec->y1, __cil_tmp15);
#line 2884
  tcy1 = __cil_tmp16;
#line 2888
  shift = tilec->numresolutions - tilec->minimum_num_resolutions;
  }
#line 2891
  return ((((tcx0 >= (OPJ_UINT32 )tilec->x0 && tcy0 >= (OPJ_UINT32 )tilec->y0) && tcx1 <= (OPJ_UINT32 )tilec->x1) && tcy1 <= (OPJ_UINT32 )tilec->y1) && (shift >= 32U || ((((tcx0 - (OPJ_UINT32 )tilec->x0) >> shift == 0U && (tcy0 - (OPJ_UINT32 )tilec->y0) >> shift == 0U) && ((OPJ_UINT32 )tilec->x1 - tcx1) >> shift == 0U) && ((OPJ_UINT32 )tilec->y1 - tcy1) >> shift == 0U)));
}
}
#line 2904 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
opj_tcd_marker_info_t *opj_tcd_marker_info_create(OPJ_BOOL need_PLT ) 
{ 
  opj_tcd_marker_info_t *l_tcd_marker_info ;
  void *__cil_tmp3 ;

  {
  {
#line 2906
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcd_marker_info_t ));
#line 2906
  l_tcd_marker_info = (opj_tcd_marker_info_t *)__cil_tmp3;
  }
#line 2908
  if (! l_tcd_marker_info) {
#line 2909
    return ((opj_tcd_marker_info_t *)((void *)0));
  }
#line 2912
  l_tcd_marker_info->need_PLT = need_PLT;
#line 2914
  return (l_tcd_marker_info);
}
}
#line 2919 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.c"
void opj_tcd_marker_info_destroy(opj_tcd_marker_info_t *p_tcd_marker_info ) 
{ 


  {
#line 2921
  if (p_tcd_marker_info) {
    {
#line 2922
    opj_free(p_tcd_marker_info->p_packet_size);
#line 2923
    opj_free(p_tcd_marker_info);
    }
  }
  return;
}
}
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) ;
#line 53
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) ;
#line 59
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 60
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) ;
#line 76
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) ;
#line 101
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) ;
#line 111
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) ;
#line 132
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) ;
#line 141
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) ;
#line 155
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) ;
#line 167 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static void opj_t2_putcommacode(opj_bio_t *bio , OPJ_INT32 n ) 
{ 


  {
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    n --;
#line 169
    if (! (n >= 0)) {
#line 169
      goto while_break;
    }
    {
#line 170
    opj_bio_putbit(bio, (OPJ_UINT32 )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  opj_bio_putbit(bio, (OPJ_UINT32 )0);
  }
  return;
}
}
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 177
  n = (OPJ_UINT32 )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
    }
#line 178
    if (! __cil_tmp3) {
#line 178
      goto while_break;
    }
#line 179
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (n);
}
}
#line 184 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static void opj_t2_putnumpasses(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 


  {
#line 186
  if (n == 1U) {
    {
#line 187
    opj_bio_putbit(bio, (OPJ_UINT32 )0);
    }
  } else
#line 188
  if (n == 2U) {
    {
#line 189
    opj_bio_write(bio, (OPJ_UINT32 )2, (OPJ_UINT32 )2);
    }
  } else
#line 190
  if (n <= 5U) {
    {
#line 191
    opj_bio_write(bio, 12U | (n - 3U), (OPJ_UINT32 )4);
    }
  } else
#line 192
  if (n <= 36U) {
    {
#line 193
    opj_bio_write(bio, 480U | (n - 6U), (OPJ_UINT32 )9);
    }
  } else
#line 194
  if (n <= 164U) {
    {
#line 195
    opj_bio_write(bio, 65408U | (n - 37U), (OPJ_UINT32 )16);
    }
  }
  return;
}
}
#line 199 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 n ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
  {
#line 202
  __cil_tmp3 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 202
  if (! __cil_tmp3) {
#line 203
    return ((OPJ_UINT32 )1);
  }
  {
#line 205
  __cil_tmp4 = opj_bio_read(bio, (OPJ_UINT32 )1);
  }
#line 205
  if (! __cil_tmp4) {
#line 206
    return ((OPJ_UINT32 )2);
  }
  {
#line 208
  n = opj_bio_read(bio, (OPJ_UINT32 )2);
  }
#line 208
  if (n != 3U) {
#line 209
    return (3U + n);
  }
  {
#line 211
  n = opj_bio_read(bio, (OPJ_UINT32 )5);
  }
#line 211
  if (n != 31U) {
#line 212
    return (6U + n);
  }
  {
#line 214
  __cil_tmp7 = opj_bio_read(bio, (OPJ_UINT32 )7);
  }
#line 214
  return (37U + __cil_tmp7);
}
}
#line 219 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no , opj_tcd_tile_t *p_tile ,
                               OPJ_UINT32 p_maxlayers , OPJ_BYTE *p_dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 p_max_len , opj_codestream_info_t *cstr_info ,
                               opj_tcd_marker_info_t *p_marker_info , OPJ_UINT32 p_tp_num ,
                               OPJ_INT32 p_tp_pos , OPJ_UINT32 p_pino , J2K_T2_MODE p_t2_mode ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 poc ;
  opj_pi_iterator_t *l_pi ;
  opj_pi_iterator_t *l_current_pi ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 pocno ;
  int tmp ;
  OPJ_UINT32 l_max_comp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *__cil_tmp29 ;
  OPJ_UINT32 l_comp_len ;
  OPJ_UINT32 l_tp_num ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  void *__cil_tmp35 ;
  OPJ_BOOL __cil_tmp36 ;
  OPJ_BOOL __cil_tmp37 ;
  OPJ_UINT32 __cil_tmp38 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  OPJ_OFF_T tmp___1 ;
  int __cil_tmp42 ;

  {
#line 234
  l_current_data = p_dest;
#line 235
  l_nb_bytes = (OPJ_UINT32 )0;
#line 238
  l_pi = (opj_pi_iterator_t *)0;
#line 239
  l_current_pi = (opj_pi_iterator_t *)0;
#line 240
  l_image = p_t2->image;
#line 241
  l_cp = p_t2->cp;
#line 242
  l_tcp = l_cp->tcps + p_tile_no;
#line 243
  if ((int )l_cp->rsiz == 4) {
#line 243
    tmp = 2;
  } else {
#line 243
    tmp = 1;
  }
#line 243
  pocno = (OPJ_UINT32 )tmp;
#line 244
  if (l_cp->m_specific_param.m_enc.m_max_comp_size > 0U) {
#line 244
    tmp___0 = l_image->numcomps;
  } else {
#line 244
    tmp___0 = (unsigned int )1;
  }
  {
#line 244
  l_max_comp = tmp___0;
#line 246
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 248
  l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode, p_manager);
  }
#line 249
  if (! l_pi) {
#line 250
    return (0);
  }
#line 253
  *p_data_written = (OPJ_UINT32 )0;
#line 255
  if ((unsigned int )p_t2_mode == 0U) {
#line 256
    l_current_pi = l_pi;
#line 258
    compno = (OPJ_UINT32 )0;
    {
#line 258
    while (1) {
      while_continue: /* CIL Label */ ;
#line 258
      if (! (compno < l_max_comp)) {
#line 258
        goto while_break;
      }
#line 259
      l_comp_len = (OPJ_UINT32 )0;
#line 260
      l_current_pi = l_pi;
#line 262
      poc = (OPJ_UINT32 )0;
      {
#line 262
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 262
        if (! (poc < pocno)) {
#line 262
          goto while_break___0;
        }
        {
#line 263
        l_tp_num = compno;
#line 266
        opj_pi_create_encode(l_pi, l_cp, p_tile_no, poc, l_tp_num, p_tp_pos, p_t2_mode);
        }
#line 268
        if ((int )l_current_pi->poc.prg == -1) {
          {
#line 270
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 271
          return (0);
        }
        {
#line 273
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 273
          __cil_tmp32 = opj_pi_next(l_current_pi);
          }
#line 273
          if (! __cil_tmp32) {
#line 273
            goto while_break___1;
          }
#line 274
          if (l_current_pi->layno < p_maxlayers) {
            {
#line 275
            l_nb_bytes = (OPJ_UINT32 )0;
#line 277
            __cil_tmp33 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                               l_current_data, & l_nb_bytes, p_max_len,
                                               cstr_info, p_t2_mode, p_manager);
            }
#line 277
            if (! __cil_tmp33) {
              {
#line 282
              opj_pi_destroy(l_pi, l_nb_pocs);
              }
#line 283
              return (0);
            }
#line 286
            l_comp_len += l_nb_bytes;
#line 287
            l_current_data += l_nb_bytes;
#line 288
            p_max_len -= l_nb_bytes;
#line 290
            *p_data_written += l_nb_bytes;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 294
        if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
#line 295
          if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
            {
#line 296
            opj_pi_destroy(l_pi, l_nb_pocs);
            }
#line 297
            return (0);
          }
        }
#line 301
        l_current_pi ++;
#line 262
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 258
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 305
    opj_pi_create_encode(l_pi, l_cp, p_tile_no, p_pino, p_tp_num, p_tp_pos, p_t2_mode);
#line 308
    l_current_pi = l_pi + p_pino;
    }
#line 309
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 311
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 312
      return (0);
    }
#line 315
    if (p_marker_info) {
#line 315
      if (p_marker_info->need_PLT) {
        {
#line 320
        __cil_tmp34 = opj_get_encoding_packet_count(l_image, l_cp, p_tile_no);
#line 320
        __cil_tmp35 = opj_malloc((unsigned long )__cil_tmp34 * sizeof(OPJ_UINT32 ));
#line 320
        p_marker_info->p_packet_size = (OPJ_UINT32 *)__cil_tmp35;
        }
#line 322
        if (p_marker_info->p_packet_size == (void *)0) {
          {
#line 323
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 324
          return (0);
        }
      }
    }
    {
#line 328
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 328
      __cil_tmp36 = opj_pi_next(l_current_pi);
      }
#line 328
      if (! __cil_tmp36) {
#line 328
        goto while_break___2;
      }
#line 329
      if (l_current_pi->layno < p_maxlayers) {
        {
#line 330
        l_nb_bytes = (OPJ_UINT32 )0;
#line 332
        __cil_tmp37 = opj_t2_encode_packet(p_tile_no, p_tile, l_tcp, l_current_pi,
                                           l_current_data, & l_nb_bytes, p_max_len,
                                           cstr_info, p_t2_mode, p_manager);
        }
#line 332
        if (! __cil_tmp37) {
          {
#line 335
          opj_pi_destroy(l_pi, l_nb_pocs);
          }
#line 336
          return (0);
        }
#line 339
        l_current_data += l_nb_bytes;
#line 340
        p_max_len -= l_nb_bytes;
#line 342
        *p_data_written += l_nb_bytes;
#line 344
        if (p_marker_info) {
#line 344
          if (p_marker_info->need_PLT) {
#line 345
            *(p_marker_info->p_packet_size + p_marker_info->packet_count) = l_nb_bytes;
#line 346
            (p_marker_info->packet_count) ++;
          }
        }
#line 350
        if (cstr_info) {
#line 351
          if (cstr_info->index_write) {
#line 352
            info_TL = cstr_info->tile + p_tile_no;
#line 353
            info_PK = info_TL->packet + cstr_info->packno;
#line 354
            if (! cstr_info->packno) {
#line 355
              info_PK->start_pos = (OPJ_OFF_T )(info_TL->end_header + 1);
            } else {
#line 357
              if ((int )l_cp->m_specific_param.m_enc.m_tp_on | (int )l_tcp->POC && info_PK->start_pos) {
#line 357
                tmp___1 = info_PK->start_pos;
              } else {
#line 357
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1L;
              }
#line 357
              info_PK->start_pos = tmp___1;
            }
#line 361
            info_PK->end_pos = (info_PK->start_pos + (long )l_nb_bytes) - 1L;
#line 362
            info_PK->end_ph_pos += info_PK->start_pos - 1L;
          }
#line 367
          (cstr_info->packno) ++;
        }
#line 370
        (p_tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 375
  opj_pi_destroy(l_pi, l_nb_pocs);
  }
#line 377
  return (1);
}
}
#line 385 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static void opj_null_jas_fprintf(FILE *file , char const   *format  , ...) 
{ 


  {
  return;
}
}
#line 393 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *p_t2 , OPJ_UINT32 p_tile_no ,
                               opj_tcd_tile_t *p_tile , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 p_max_len , opj_codestream_index_t *p_cstr_index ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  opj_pi_iterator_t *l_pi ;
  OPJ_UINT32 pino ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_pocs ;
  opj_pi_iterator_t *l_current_pi ;
  opj_packet_info_t *l_pack_info ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t *__cil_tmp21 ;
  OPJ_BOOL *first_pass_failed ;
  void *__cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_BOOL skip_packet ;
  OPJ_UINT32 bandno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  OPJ_BOOL __cil_tmp31 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_BOOL __cil_tmp34 ;

  {
  {
#line 403
  l_current_data = p_src;
#line 404
  l_pi = (opj_pi_iterator_t *)0;
#line 406
  l_image = p_t2->image;
#line 407
  l_cp = p_t2->cp;
#line 408
  l_tcp = (p_t2->cp)->tcps + p_tile_no;
#line 410
  l_nb_pocs = l_tcp->numpocs + 1U;
#line 411
  l_current_pi = (opj_pi_iterator_t *)0;
#line 416
  l_pack_info = (opj_packet_info_t *)0;
#line 417
  l_img_comp = (opj_image_comp_t *)0;
#line 428
  l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no, p_manager);
  }
#line 429
  if (! l_pi) {
#line 430
    return (0);
  }
#line 434
  l_current_pi = l_pi;
#line 436
  pino = (OPJ_UINT32 )0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (pino <= l_tcp->numpocs)) {
#line 436
      goto while_break;
    }
#line 443
    first_pass_failed = (OPJ_BOOL *)((void *)0);
#line 445
    if ((int )l_current_pi->poc.prg == -1) {
      {
#line 447
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 448
      return (0);
    }
    {
#line 451
    __cil_tmp23 = opj_malloc((unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
#line 451
    first_pass_failed = (OPJ_BOOL *)__cil_tmp23;
    }
#line 452
    if (! first_pass_failed) {
      {
#line 453
      opj_pi_destroy(l_pi, l_nb_pocs);
      }
#line 454
      return (0);
    }
    {
#line 456
    memset(first_pass_failed, 1, (unsigned long )l_image->numcomps * sizeof(OPJ_BOOL ));
    }
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 458
      __cil_tmp24 = opj_pi_next(l_current_pi);
      }
#line 458
      if (! __cil_tmp24) {
#line 458
        goto while_break___0;
      }
      {
#line 459
      skip_packet = 0;
#line 460
      opj_null_jas_fprintf(stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
                           (int )l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno,
                           l_current_pi->precno, l_current_pi->layno);
      }
#line 467
      if (l_current_pi->layno >= l_tcp->num_layers_to_decode) {
#line 468
        skip_packet = 1;
      } else
#line 472
      if (l_current_pi->resno >= (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions) {
#line 474
        skip_packet = 1;
      } else {
#line 479
        tilec = p_tile->comps + l_current_pi->compno;
#line 480
        res = tilec->resolutions + l_current_pi->resno;
#line 482
        skip_packet = 1;
#line 483
        bandno = (OPJ_UINT32 )0;
        {
#line 483
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 483
          if (! (bandno < res->numbands)) {
#line 483
            goto while_break___1;
          }
          {
#line 484
          band = & res->bands[bandno];
#line 485
          prec = band->precincts + l_current_pi->precno;
#line 487
          __cil_tmp31 = opj_tcd_is_subband_area_of_interest(tcd, l_current_pi->compno,
                                                            l_current_pi->resno, band->bandno,
                                                            (OPJ_UINT32 )prec->x0,
                                                            (OPJ_UINT32 )prec->y0,
                                                            (OPJ_UINT32 )prec->x1,
                                                            (OPJ_UINT32 )prec->y1);
          }
#line 487
          if (__cil_tmp31) {
#line 495
            skip_packet = 0;
#line 496
            goto while_break___1;
          }
#line 483
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 505
      if (! skip_packet) {
        {
#line 506
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 508
        *(first_pass_failed + l_current_pi->compno) = 0;
#line 510
        __cil_tmp32 = opj_t2_decode_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                           & l_nb_bytes_read, p_max_len, l_pack_info,
                                           p_manager);
        }
#line 510
        if (! __cil_tmp32) {
          {
#line 512
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 513
          opj_free(first_pass_failed);
          }
#line 514
          return (0);
        }
        {
#line 517
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 518
        l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
        }
      } else {
        {
#line 521
        l_nb_bytes_read = (OPJ_UINT32 )0;
#line 522
        __cil_tmp34 = opj_t2_skip_packet(p_t2, p_tile, l_tcp, l_current_pi, l_current_data,
                                         & l_nb_bytes_read, p_max_len, l_pack_info,
                                         p_manager);
        }
#line 522
        if (! __cil_tmp34) {
          {
#line 524
          opj_pi_destroy(l_pi, l_nb_pocs);
#line 525
          opj_free(first_pass_failed);
          }
#line 526
          return (0);
        }
      }
#line 530
      if (*(first_pass_failed + l_current_pi->compno)) {
#line 531
        l_img_comp = l_image->comps + l_current_pi->compno;
#line 532
        if (l_img_comp->resno_decoded == 0U) {
#line 533
          l_img_comp->resno_decoded = (p_tile->comps + l_current_pi->compno)->minimum_num_resolutions - 1U;
        }
      }
#line 538
      l_current_data += l_nb_bytes_read;
#line 539
      p_max_len -= l_nb_bytes_read;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 570
    l_current_pi ++;
#line 572
    opj_free(first_pass_failed);
    }
#line 436
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 585
  opj_pi_destroy(l_pi, l_nb_pocs);
#line 586
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src);
  }
#line 587
  return (1);
}
}
#line 599 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) 
{ 
  opj_t2_t *l_t2 ;
  void *__cil_tmp4 ;

  {
  {
#line 602
  __cil_tmp4 = opj_calloc((size_t )1, sizeof(opj_t2_t ));
#line 602
  l_t2 = (opj_t2_t *)__cil_tmp4;
  }
#line 603
  if (! l_t2) {
#line 604
    return ((opj_t2_t *)((void *)0));
  }
#line 607
  l_t2->image = p_image;
#line 608
  l_t2->cp = p_cp;
#line 610
  return (l_t2);
}
}
#line 613 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
void opj_t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 615
  if (t2) {
    {
#line 616
    opj_free(t2);
    }
  }
  return;
}
}
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_decode_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                     opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                     OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 631
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 632
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 634
  *p_data_read = (OPJ_UINT32 )0;
#line 636
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 636
  if (! __cil_tmp13) {
#line 638
    return (0);
  }
#line 641
  p_src += l_nb_bytes_read;
#line 642
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 643
  p_max_length -= l_nb_bytes_read;
#line 646
  if (l_read_data) {
    {
#line 647
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 649
    __cil_tmp14 = opj_t2_read_packet_data(p_t2, p_tile, p_pi, p_src, & l_nb_bytes_read,
                                          p_max_length, p_pack_info, p_manager);
    }
#line 649
    if (! __cil_tmp14) {
#line 651
      return (0);
    }
#line 654
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 657
  *p_data_read = l_nb_total_bytes_read;
#line 659
  return (1);
}
}
#line 662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                                     opj_pi_iterator_t *pi , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                                     OPJ_UINT32 length , opj_codestream_info_t *cstr_info ,
                                     J2K_T2_MODE p_t2_mode , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_BYTE *c ;
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 precno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 l_nb_blocks ;
  opj_tcd_band_t *band ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  OPJ_BOOL packet_empty ;
  opj_tcd_precinct_t *prc ;
  OPJ_BOOL __cil_tmp28 ;
  opj_bio_t *__cil_tmp29 ;
  int tmp ;
  opj_tcd_precinct_t *prc___0 ;
  OPJ_BOOL __cil_tmp32 ;
  opj_tcd_layer_t *layer ;
  opj_tcd_layer_t *layer___0 ;
  OPJ_UINT32 increment ;
  OPJ_UINT32 nump ;
  OPJ_UINT32 len ;
  OPJ_UINT32 passno ;
  OPJ_UINT32 l_nb_passes ;
  OPJ_INT32 __cil_tmp40 ;
  OPJ_INT32 __cil_tmp41 ;
  OPJ_INT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_INT32 __cil_tmp44 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_BOOL __cil_tmp46 ;
  ptrdiff_t __cil_tmp47 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_precinct_t *prc___1 ;
  OPJ_BOOL __cil_tmp50 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  OPJ_UINT32 __cil_tmp53 ;

  {
#line 674
  c = dest;
#line 676
  compno = pi->compno;
#line 677
  resno = pi->resno;
#line 678
  precno = pi->precno;
#line 679
  layno = pi->layno;
#line 681
  band = (opj_tcd_band_t *)0;
#line 682
  cblk = (opj_tcd_cblk_enc_t *)0;
#line 683
  pass = (opj_tcd_pass_t *)0;
#line 685
  tilec = tile->comps + compno;
#line 686
  res = tilec->resolutions + resno;
#line 688
  bio = (opj_bio_t *)0;
#line 692
  packet_empty = 0;
#line 704
  if (tcp->csty & 2U) {
#line 705
    if (length < 6U) {
#line 706
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 707
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                      length, 6);
        }
      }
#line 712
      return (0);
    }
#line 714
    *(c + 0) = (OPJ_BYTE )255;
#line 715
    *(c + 1) = (OPJ_BYTE )145;
#line 716
    *(c + 2) = (OPJ_BYTE )0;
#line 717
    *(c + 3) = (OPJ_BYTE )4;
#line 722
    *(c + 4) = (OPJ_BYTE )((tile->packno >> 8) & 255U);
#line 723
    *(c + 5) = (OPJ_BYTE )(tile->packno & 255U);
#line 725
    c += 6;
#line 726
    length -= (unsigned int )6;
  }
#line 730
  if (! layno) {
#line 731
    band = (opj_tcd_band_t *)res->bands;
#line 733
    bandno = (OPJ_UINT32 )0;
    {
#line 733
    while (1) {
      while_continue: /* CIL Label */ ;
#line 733
      if (! (bandno < res->numbands)) {
#line 733
        goto while_break;
      }
      {
#line 737
      __cil_tmp28 = opj_tcd_is_band_empty(band);
      }
#line 737
      if (__cil_tmp28) {
#line 738
        goto while_continue;
      }
#line 743
      if (precno >= res->pw * res->ph) {
        {
#line 744
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): accessing precno=%u >= %u\na}EV",
                      precno, res->pw * res->ph);
        }
#line 747
        return (0);
      }
      {
#line 750
      prc = band->precincts + precno;
#line 751
      opj_tgt_reset(prc->incltree);
#line 752
      opj_tgt_reset(prc->imsbtree);
#line 754
      l_nb_blocks = prc->cw * prc->ch;
#line 755
      cblkno = (OPJ_UINT32 )0;
      }
      {
#line 755
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 755
        if (! (cblkno < l_nb_blocks)) {
#line 755
          goto while_break___0;
        }
        {
#line 756
        cblk = prc->cblks.enc + cblkno;
#line 758
        cblk->numpasses = (OPJ_UINT32 )0;
#line 759
        opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32 )cblk->numbps);
        }
#line 755
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 733
      band ++;
#line 733
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 764
  bio = opj_bio_create();
  }
#line 765
  if (! bio) {
#line 767
    return (0);
  }
  {
#line 769
  opj_bio_init_enc(bio, c, length);
  }
#line 804
  if (packet_empty) {
#line 804
    tmp = 0;
  } else {
#line 804
    tmp = 1;
  }
  {
#line 804
  opj_bio_putbit(bio, (OPJ_UINT32 )tmp);
#line 807
  band = (opj_tcd_band_t *)res->bands;
#line 808
  bandno = (OPJ_UINT32 )0;
  }
  {
#line 808
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 808
    if (! (! packet_empty && bandno < res->numbands)) {
#line 808
      goto while_break___1;
    }
    {
#line 813
    __cil_tmp32 = opj_tcd_is_band_empty(band);
    }
#line 813
    if (__cil_tmp32) {
#line 814
      goto while_continue___1;
    }
#line 819
    if (precno >= res->pw * res->ph) {
      {
#line 820
      opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): accessing precno=%u >= %u\n`}EV",
                    precno, res->pw * res->ph);
      }
#line 823
      return (0);
    }
#line 826
    prc___0 = band->precincts + precno;
#line 827
    l_nb_blocks = prc___0->cw * prc___0->ch;
#line 828
    cblk = prc___0->cblks.enc;
#line 830
    cblkno = (OPJ_UINT32 )0;
    {
#line 830
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 830
      if (! (cblkno < l_nb_blocks)) {
#line 830
        goto while_break___2;
      }
#line 831
      layer = cblk->layers + layno;
#line 833
      if (! cblk->numpasses) {
#line 833
        if (layer->numpasses) {
          {
#line 834
          opj_tgt_setvalue(prc___0->incltree, cblkno, (OPJ_INT32 )layno);
          }
        }
      }
#line 837
      cblk ++;
#line 830
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 840
    cblk = prc___0->cblks.enc;
#line 841
    cblkno = (OPJ_UINT32 )0;
    {
#line 841
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 841
      if (! (cblkno < l_nb_blocks)) {
#line 841
        goto while_break___3;
      }
#line 842
      layer___0 = cblk->layers + layno;
#line 843
      increment = (OPJ_UINT32 )0;
#line 844
      nump = (OPJ_UINT32 )0;
#line 845
      len = (OPJ_UINT32 )0;
#line 849
      if (! cblk->numpasses) {
        {
#line 850
        opj_tgt_encode(bio, prc___0->incltree, cblkno, (OPJ_INT32 )(layno + 1U));
        }
      } else {
        {
#line 852
        opj_bio_putbit(bio, layer___0->numpasses != 0U);
        }
      }
#line 856
      if (! layer___0->numpasses) {
#line 857
        cblk ++;
#line 858
        goto while_continue___3;
      }
#line 862
      if (! cblk->numpasses) {
        {
#line 863
        cblk->numlenbits = (OPJ_UINT32 )3;
#line 864
        opj_tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 868
      opj_t2_putnumpasses(bio, layer___0->numpasses);
#line 869
      l_nb_passes = cblk->numpasses + layer___0->numpasses;
#line 870
      pass = cblk->passes + cblk->numpasses;
#line 873
      passno = cblk->numpasses;
      }
      {
#line 873
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 873
        if (! (passno < l_nb_passes)) {
#line 873
          goto while_break___4;
        }
#line 874
        nump ++;
#line 875
        len += pass->len;
#line 877
        if ((int )pass->term) {
          _L: /* CIL Label */ 
          {
#line 878
          __cil_tmp41 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 878
          __cil_tmp40 = opj_int_floorlog2((OPJ_INT32 )len);
#line 878
          __cil_tmp42 = opj_int_max((OPJ_INT32 )increment, (__cil_tmp40 + 1) - ((OPJ_INT32 )cblk->numlenbits + __cil_tmp41));
#line 878
          increment = (OPJ_UINT32 )__cil_tmp42;
#line 881
          len = (OPJ_UINT32 )0;
#line 882
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 877
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
#line 877
          goto _L;
        }
#line 885
        pass ++;
#line 873
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 887
      opj_t2_putcommacode(bio, (OPJ_INT32 )increment);
#line 890
      cblk->numlenbits += increment;
#line 892
      pass = cblk->passes + cblk->numpasses;
#line 894
      passno = cblk->numpasses;
      }
      {
#line 894
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 894
        if (! (passno < l_nb_passes)) {
#line 894
          goto while_break___5;
        }
#line 895
        nump ++;
#line 896
        len += pass->len;
#line 898
        if ((int )pass->term) {
          {
          {
#line 899
          __cil_tmp44 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 899
          opj_bio_write(bio, (OPJ_UINT32 )len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp44);
          }
#line 901
          len = (OPJ_UINT32 )0;
#line 902
          nump = (OPJ_UINT32 )0;
          }
        } else
#line 898
        if (passno == (cblk->numpasses + layer___0->numpasses) - 1U) {
          {
          {
#line 899
          __cil_tmp44 = opj_int_floorlog2((OPJ_INT32 )nump);
          }
          {
#line 899
          opj_bio_write(bio, (OPJ_UINT32 )len, cblk->numlenbits + (OPJ_UINT32 )__cil_tmp44);
          }
#line 901
          len = (OPJ_UINT32 )0;
#line 902
          nump = (OPJ_UINT32 )0;
          }
        }
#line 904
        pass ++;
#line 894
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 907
      cblk ++;
#line 841
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 809
    band ++;
#line 809
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 911
  __cil_tmp46 = opj_bio_flush(bio);
  }
#line 911
  if (! __cil_tmp46) {
    {
#line 912
    opj_bio_destroy(bio);
    }
#line 913
    return (0);
  }
  {
#line 916
  __cil_tmp47 = opj_bio_numbytes(bio);
#line 916
  l_nb_bytes = (OPJ_UINT32 )__cil_tmp47;
#line 917
  c += l_nb_bytes;
#line 918
  length -= l_nb_bytes;
#line 920
  opj_bio_destroy(bio);
  }
#line 923
  if (tcp->csty & 4U) {
#line 924
    if (length < 2U) {
#line 925
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 926
        opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                      length, 2);
        }
      }
#line 931
      return (0);
    }
#line 933
    *(c + 0) = (OPJ_BYTE )255;
#line 934
    *(c + 1) = (OPJ_BYTE )146;
#line 935
    c += 2;
#line 936
    length -= (unsigned int )2;
  }
#line 943
  if (cstr_info) {
#line 943
    if (cstr_info->index_write) {
#line 944
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 945
      info_PK->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(c - dest));
    }
  }
#line 950
  band = (opj_tcd_band_t *)res->bands;
#line 951
  bandno = (OPJ_UINT32 )0;
  {
#line 951
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 951
    if (! (! packet_empty && bandno < res->numbands)) {
#line 951
      goto while_break___6;
    }
    {
#line 955
    __cil_tmp50 = opj_tcd_is_band_empty(band);
    }
#line 955
    if (__cil_tmp50) {
#line 956
      goto while_continue___6;
    }
#line 959
    prc___1 = band->precincts + precno;
#line 960
    l_nb_blocks = prc___1->cw * prc___1->ch;
#line 961
    cblk = prc___1->cblks.enc;
#line 963
    cblkno = (OPJ_UINT32 )0;
    {
#line 963
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 963
      if (! (cblkno < l_nb_blocks)) {
#line 963
        goto while_break___7;
      }
#line 964
      layer___1 = cblk->layers + layno;
#line 966
      if (! layer___1->numpasses) {
#line 967
        cblk ++;
#line 968
        goto while_continue___7;
      }
#line 971
      if (layer___1->len > length) {
#line 972
        if ((unsigned int )p_t2_mode == 1U) {
          {
#line 973
          opj_event_msg(p_manager, 1, "opj_t2_encode_packet(): only %u bytes remaining in output buffer. %u needed.\n",
                        length, layer___1->len);
          }
        }
#line 978
        return (0);
      }
#line 981
      if ((unsigned int )p_t2_mode == 1U) {
        {
#line 982
        memcpy(c, layer___1->data, (unsigned long )layer___1->len);
        }
      }
#line 984
      cblk->numpasses += layer___1->numpasses;
#line 985
      c += layer___1->len;
#line 986
      length -= layer___1->len;
#line 989
      if (cstr_info) {
#line 989
        if (cstr_info->index_write) {
#line 990
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 991
          info_PK___0->disto += layer___1->disto;
#line 992
          if (cstr_info->D_max < info_PK___0->disto) {
#line 993
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 997
      cblk ++;
#line 963
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 951
    band ++;
#line 951
    __cil_tmp53 = bandno;
#line 951
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1003
  *p_data_written += (OPJ_UINT32 )(c - dest);
#line 1005
  return (1);
}
}
#line 1008 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile , opj_tcp_t *p_tcp ,
                                   opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src , OPJ_UINT32 *p_data_read ,
                                   OPJ_UINT32 p_max_length , opj_packet_info_t *p_pack_info ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_read_data ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_UINT32 l_nb_total_bytes_read ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;

  {
  {
#line 1019
  l_nb_bytes_read = (OPJ_UINT32 )0;
#line 1020
  l_nb_total_bytes_read = (OPJ_UINT32 )0;
#line 1022
  *p_data_read = (OPJ_UINT32 )0;
#line 1024
  __cil_tmp13 = opj_t2_read_packet_header(p_t2, p_tile, p_tcp, p_pi, & l_read_data,
                                          p_src, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
  }
#line 1024
  if (! __cil_tmp13) {
#line 1026
    return (0);
  }
#line 1029
  p_src += l_nb_bytes_read;
#line 1030
  l_nb_total_bytes_read += l_nb_bytes_read;
#line 1031
  p_max_length -= l_nb_bytes_read;
#line 1034
  if (l_read_data) {
    {
#line 1035
    l_nb_bytes_read = (OPJ_UINT32 )0;
#line 1037
    __cil_tmp14 = opj_t2_skip_packet_data(p_t2, p_tile, p_pi, & l_nb_bytes_read, p_max_length,
                                          p_pack_info, p_manager);
    }
#line 1037
    if (! __cil_tmp14) {
#line 1039
      return (0);
    }
#line 1042
    l_nb_total_bytes_read += l_nb_bytes_read;
  }
#line 1044
  *p_data_read = l_nb_total_bytes_read;
#line 1046
  return (1);
}
}
#line 1050 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_header(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                          opj_tcp_t *p_tcp , opj_pi_iterator_t *p_pi ,
                                          OPJ_BOOL *p_is_data_present , OPJ_BYTE *p_src_data ,
                                          OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                          opj_packet_info_t *p_pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_UINT32 l_remaining_length ;
  OPJ_UINT32 l_header_length ;
  OPJ_UINT32 *l_modified_length_ptr ;
  OPJ_BYTE *l_current_data ;
  opj_cp_t *l_cp ;
  opj_bio_t *l_bio ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BYTE *l_header_data ;
  OPJ_BYTE **l_header_data_start ;
  OPJ_UINT32 l_present ;
  OPJ_BOOL __cil_tmp26 ;
  opj_tcd_precinct_t *l_prc ;
  opj_bio_t *__cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  ptrdiff_t __cil_tmp30 ;
  opj_tcd_precinct_t *l_prc___0 ;
  OPJ_BOOL __cil_tmp32 ;
  OPJ_UINT32 l_included ;
  OPJ_UINT32 l_increment ;
  OPJ_UINT32 l_segno ;
  OPJ_INT32 n ;
  OPJ_UINT32 __cil_tmp37 ;
  OPJ_UINT32 __cil_tmp38 ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_BOOL __cil_tmp43 ;
  OPJ_BOOL __cil_tmp44 ;
  OPJ_UINT32 bit_number ;
  unsigned int tmp ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_BOOL __cil_tmp49 ;
  OPJ_UINT32 bit_number___0 ;
  OPJ_INT32 __cil_tmp51 ;
  OPJ_UINT32 __cil_tmp52 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_BOOL __cil_tmp54 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_BOOL __cil_tmp56 ;
  ptrdiff_t __cil_tmp57 ;

  {
#line 1067
  l_modified_length_ptr = (OPJ_UINT32 *)0;
#line 1068
  l_current_data = p_src_data;
#line 1069
  l_cp = p_t2->cp;
#line 1070
  l_bio = (opj_bio_t *)0;
#line 1071
  l_band = (opj_tcd_band_t *)0;
#line 1072
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1073
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1076
  l_header_data = (OPJ_BYTE *)0;
#line 1077
  l_header_data_start = (OPJ_BYTE **)0;
#line 1081
  if (p_pi->layno == 0U) {
#line 1082
    l_band = (opj_tcd_band_t *)l_res->bands;
#line 1085
    bandno = (OPJ_UINT32 )0;
    {
#line 1085
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1085
      if (! (bandno < l_res->numbands)) {
#line 1085
        goto while_break;
      }
      {
#line 1086
      __cil_tmp26 = opj_tcd_is_band_empty(l_band);
      }
#line 1086
      if (! __cil_tmp26) {
#line 1087
        l_prc = l_band->precincts + p_pi->precno;
#line 1088
        if (! ((unsigned long )p_pi->precno < (unsigned long )l_band->precincts_data_size / sizeof(opj_tcd_precinct_t ))) {
          {
#line 1090
          opj_event_msg(p_manager, 1, "Invalid precinct\n\177b}EV");
          }
#line 1091
          return (0);
        }
        {
#line 1095
        opj_tgt_reset(l_prc->incltree);
#line 1096
        opj_tgt_reset(l_prc->imsbtree);
#line 1097
        l_cblk = l_prc->cblks.dec;
#line 1099
        l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1100
        cblkno = (OPJ_UINT32 )0;
        }
        {
#line 1100
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1100
          if (! (cblkno < l_nb_code_blocks)) {
#line 1100
            goto while_break___0;
          }
#line 1101
          l_cblk->numsegs = (OPJ_UINT32 )0;
#line 1102
          l_cblk->real_num_segs = (OPJ_UINT32 )0;
#line 1103
          l_cblk ++;
#line 1100
          cblkno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1107
      l_band ++;
#line 1085
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1113
  if (p_tcp->csty & 2U) {
#line 1114
    if (p_max_length < 6U) {
      {
#line 1115
      opj_event_msg(p_manager, 2, "Not enough space for expected SOP marker\n\207b}EV");
      }
    } else
#line 1117
    if ((int )*l_current_data != 255) {
      {
      {
#line 1118
      opj_event_msg(p_manager, 2, "Expected SOP marker\nEV");
      }
      }
    } else
#line 1117
    if ((int )*(l_current_data + 1) != 145) {
      {
      {
#line 1118
      opj_event_msg(p_manager, 2, "Expected SOP marker\nEV");
      }
      }
    } else {
#line 1120
      l_current_data += 6;
    }
  }
  {
#line 1133
  l_bio = opj_bio_create();
  }
#line 1134
  if (! l_bio) {
#line 1135
    return (0);
  }
#line 1138
  if ((int )l_cp->ppm == 1) {
#line 1139
    l_header_data_start = & l_cp->ppm_data;
#line 1140
    l_header_data = *l_header_data_start;
#line 1141
    l_modified_length_ptr = & l_cp->ppm_len;
  } else
#line 1143
  if ((int )p_tcp->ppt == 1) {
#line 1144
    l_header_data_start = & p_tcp->ppt_data;
#line 1145
    l_header_data = *l_header_data_start;
#line 1146
    l_modified_length_ptr = & p_tcp->ppt_len;
  } else {
#line 1148
    l_header_data_start = & l_current_data;
#line 1149
    l_header_data = *l_header_data_start;
#line 1150
    l_remaining_length = (OPJ_UINT32 )((p_src_data + p_max_length) - l_header_data);
#line 1151
    l_modified_length_ptr = & l_remaining_length;
  }
  {
#line 1154
  opj_bio_init_dec(l_bio, l_header_data, *l_modified_length_ptr);
#line 1156
  l_present = opj_bio_read(l_bio, (OPJ_UINT32 )1);
#line 1157
  opj_null_jas_fprintf(stderr, "present=%d \nEV", l_present);
  }
#line 1158
  if (! l_present) {
    {
#line 1160
    opj_bio_inalign(l_bio);
#line 1161
    __cil_tmp30 = opj_bio_numbytes(l_bio);
    }
    {
#line 1161
    l_header_data += __cil_tmp30;
#line 1162
    opj_bio_destroy(l_bio);
    }
#line 1165
    if (p_tcp->csty & 4U) {
#line 1166
      if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
        {
#line 1168
        opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n\311a}EV");
        }
      } else
#line 1170
      if ((int )*l_header_data != 255) {
        {
        {
#line 1171
        opj_event_msg(p_manager, 2, "Expected EPH marker\nEV");
        }
        }
      } else
#line 1170
      if ((int )*(l_header_data + 1) != 146) {
        {
        {
#line 1171
        opj_event_msg(p_manager, 2, "Expected EPH marker\nEV");
        }
        }
      } else {
#line 1173
        l_header_data += 2;
      }
    }
#line 1177
    l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1178
    *l_modified_length_ptr -= l_header_length;
#line 1179
    *l_header_data_start += l_header_length;
#line 1184
    if (p_pack_info) {
#line 1185
      p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
    }
#line 1189
    *p_is_data_present = 0;
#line 1190
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1191
    return (1);
  }
#line 1194
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 1195
  bandno = (OPJ_UINT32 )0;
  {
#line 1195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1195
    if (! (bandno < l_res->numbands)) {
#line 1195
      goto while_break___1;
    }
    {
#line 1196
    l_prc___0 = l_band->precincts + p_pi->precno;
#line 1198
    __cil_tmp32 = opj_tcd_is_band_empty(l_band);
    }
#line 1198
    if (__cil_tmp32) {
#line 1199
      goto while_continue___1;
    }
#line 1202
    l_nb_code_blocks = l_prc___0->cw * l_prc___0->ch;
#line 1203
    l_cblk = l_prc___0->cblks.dec;
#line 1204
    cblkno = (OPJ_UINT32 )0;
    {
#line 1204
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1204
      if (! (cblkno < l_nb_code_blocks)) {
#line 1204
        goto while_break___2;
      }
#line 1209
      if (! l_cblk->numsegs) {
        {
#line 1210
        l_included = opj_tgt_decode(l_bio, l_prc___0->incltree, cblkno, (OPJ_INT32 )(p_pi->layno + 1U));
        }
      } else {
        {
#line 1214
        l_included = opj_bio_read(l_bio, (OPJ_UINT32 )1);
        }
      }
#line 1218
      if (! l_included) {
        {
#line 1219
        l_cblk->numnewpasses = (OPJ_UINT32 )0;
#line 1220
        l_cblk ++;
#line 1221
        opj_null_jas_fprintf(stderr, "included=%d \nV", l_included);
        }
#line 1222
        goto while_continue___2;
      }
#line 1226
      if (! l_cblk->numsegs) {
#line 1227
        i = (OPJ_UINT32 )0;
        {
#line 1229
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1229
          __cil_tmp40 = opj_tgt_decode(l_bio, l_prc___0->imsbtree, cblkno, (OPJ_INT32 )i);
          }
#line 1229
          if (! (! __cil_tmp40)) {
#line 1229
            goto while_break___3;
          }
#line 1230
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1233
        l_cblk->Mb = (OPJ_UINT32 )l_band->numbps;
#line 1234
        l_cblk->numbps = ((OPJ_UINT32 )l_band->numbps + 1U) - i;
#line 1235
        l_cblk->numlenbits = (OPJ_UINT32 )3;
      }
      {
#line 1239
      l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
#line 1240
      l_increment = opj_t2_getcommacode(l_bio);
#line 1243
      l_cblk->numlenbits += l_increment;
#line 1244
      l_segno = (OPJ_UINT32 )0;
      }
#line 1246
      if (! l_cblk->numsegs) {
        {
#line 1247
        __cil_tmp43 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                      (OPJ_UINT32 )1);
        }
#line 1247
        if (! __cil_tmp43) {
          {
#line 1248
          opj_bio_destroy(l_bio);
          }
#line 1249
          return (0);
        }
      } else {
#line 1252
        l_segno = l_cblk->numsegs - 1U;
#line 1253
        if ((l_cblk->segs + l_segno)->numpasses == (l_cblk->segs + l_segno)->maxpasses) {
          {
#line 1254
          l_segno ++;
#line 1255
          __cil_tmp44 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                        (OPJ_UINT32 )0);
          }
#line 1255
          if (! __cil_tmp44) {
            {
#line 1256
            opj_bio_destroy(l_bio);
            }
#line 1257
            return (0);
          }
        }
      }
#line 1261
      n = (OPJ_INT32 )l_cblk->numnewpasses;
#line 1263
      if (((p_tcp->tccps + p_pi->compno)->cblksty & 64U) != 0U) {
        {
#line 1264
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1266
          if (l_segno == 0U) {
#line 1266
            tmp = (unsigned int )1;
          } else {
#line 1266
            tmp = (OPJ_UINT32 )n;
          }
          {
#line 1266
          (l_cblk->segs + l_segno)->numnewpasses = tmp;
#line 1267
          __cil_tmp47 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1267
          bit_number = l_cblk->numlenbits + __cil_tmp47;
          }
#line 1269
          if (bit_number > 32U) {
            {
#line 1270
            opj_event_msg(p_manager, 1, "Invalid bit number %d in opj_t2_read_packet_header()\n",
                          bit_number);
#line 1273
            opj_bio_destroy(l_bio);
            }
#line 1274
            return (0);
          }
          {
#line 1276
          (l_cblk->segs + l_segno)->newlen = opj_bio_read(l_bio, bit_number);
#line 1277
          opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n#c}EV",
                               l_included, (l_cblk->segs + l_segno)->numnewpasses,
                               l_increment, (l_cblk->segs + l_segno)->newlen);
#line 1281
          n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
          }
#line 1282
          if (n > 0) {
            {
#line 1283
            l_segno ++;
#line 1285
            __cil_tmp49 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                          (OPJ_UINT32 )0);
            }
#line 1285
            if (! __cil_tmp49) {
              {
#line 1286
              opj_bio_destroy(l_bio);
              }
#line 1287
              return (0);
            }
          }
#line 1264
          if (! (n > 0)) {
#line 1264
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 1292
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1294
          __cil_tmp51 = opj_int_min((OPJ_INT32 )((l_cblk->segs + l_segno)->maxpasses - (l_cblk->segs + l_segno)->numpasses),
                                    n);
#line 1294
          (l_cblk->segs + l_segno)->numnewpasses = (OPJ_UINT32 )__cil_tmp51;
#line 1296
          __cil_tmp52 = opj_uint_floorlog2((l_cblk->segs + l_segno)->numnewpasses);
#line 1296
          bit_number___0 = l_cblk->numlenbits + __cil_tmp52;
          }
#line 1298
          if (bit_number___0 > 32U) {
            {
#line 1299
            opj_event_msg(p_manager, 1, "Invalid bit number %d in opj_t2_read_packet_header()\n",
                          bit_number___0);
#line 1302
            opj_bio_destroy(l_bio);
            }
#line 1303
            return (0);
          }
          {
#line 1305
          (l_cblk->segs + l_segno)->newlen = opj_bio_read(l_bio, bit_number___0);
#line 1306
          opj_null_jas_fprintf(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n",
                               l_included, (l_cblk->segs + l_segno)->numnewpasses,
                               l_increment, (l_cblk->segs + l_segno)->newlen);
#line 1310
          n -= (OPJ_INT32 )(l_cblk->segs + l_segno)->numnewpasses;
          }
#line 1311
          if (n > 0) {
            {
#line 1312
            l_segno ++;
#line 1314
            __cil_tmp54 = opj_t2_init_seg(l_cblk, l_segno, (p_tcp->tccps + p_pi->compno)->cblksty,
                                          (OPJ_UINT32 )0);
            }
#line 1314
            if (! __cil_tmp54) {
              {
#line 1315
              opj_bio_destroy(l_bio);
              }
#line 1316
              return (0);
            }
          }
#line 1292
          if (! (n > 0)) {
#line 1292
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 1321
      l_cblk ++;
#line 1204
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1195
    l_band ++;
#line 1195
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1325
  __cil_tmp56 = opj_bio_inalign(l_bio);
  }
#line 1325
  if (! __cil_tmp56) {
    {
#line 1326
    opj_bio_destroy(l_bio);
    }
#line 1327
    return (0);
  }
  {
#line 1330
  __cil_tmp57 = opj_bio_numbytes(l_bio);
  }
  {
#line 1330
  l_header_data += __cil_tmp57;
#line 1331
  opj_bio_destroy(l_bio);
  }
#line 1334
  if (p_tcp->csty & 4U) {
#line 1335
    if (*l_modified_length_ptr - (OPJ_UINT32 )(l_header_data - *l_header_data_start) < 2U) {
      {
#line 1337
      opj_event_msg(p_manager, 2, "Not enough space for expected EPH marker\n");
      }
    } else
#line 1339
    if ((int )*l_header_data != 255) {
      {
      {
#line 1340
      opj_event_msg(p_manager, 2, "Expected EPH marker\n");
      }
      }
    } else
#line 1339
    if ((int )*(l_header_data + 1) != 146) {
      {
      {
#line 1340
      opj_event_msg(p_manager, 2, "Expected EPH marker\n");
      }
      }
    } else {
#line 1342
      l_header_data += 2;
    }
  }
  {
#line 1346
  l_header_length = (OPJ_UINT32 )(l_header_data - *l_header_data_start);
#line 1347
  opj_null_jas_fprintf(stderr, "hdrlen=%d \n", l_header_length);
#line 1348
  opj_null_jas_fprintf(stderr, "packet body\n");
#line 1349
  *l_modified_length_ptr -= l_header_length;
#line 1350
  *l_header_data_start += l_header_length;
  }
#line 1355
  if (p_pack_info) {
#line 1356
    p_pack_info->end_ph_pos = (OPJ_OFF_T )((OPJ_INT32 )(l_current_data - p_src_data));
  }
#line 1360
  *p_is_data_present = 1;
#line 1361
  *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
#line 1363
  return (1);
}
}
#line 1366 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_BYTE *p_src_data ,
                                        OPJ_UINT32 *p_data_read , OPJ_UINT32 p_max_length ,
                                        opj_packet_info_t *pack_info , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  OPJ_BYTE *l_current_data ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  OPJ_BOOL partial_buffer ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;
  OPJ_UINT32 l_numchunksalloc ;
  opj_tcd_seg_data_chunk_t *l_chunks ;
  void *__cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 1377
  l_current_data = p_src_data;
#line 1378
  l_band = (opj_tcd_band_t *)0;
#line 1379
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1380
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1382
  partial_buffer = 0;
#line 1387
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 1388
  bandno = (OPJ_UINT32 )0;
  {
#line 1388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1388
    if (! (bandno < l_res->numbands)) {
#line 1388
      goto while_break;
    }
#line 1389
    l_prc = l_band->precincts + p_pi->precno;
#line 1391
    if (l_band->x1 - l_band->x0 == 0) {
#line 1392
      l_band ++;
#line 1393
      goto while_continue;
    } else
#line 1391
    if (l_band->y1 - l_band->y0 == 0) {
#line 1392
      l_band ++;
#line 1393
      goto while_continue;
    }
#line 1396
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1397
    l_cblk = l_prc->cblks.dec;
#line 1399
    cblkno = (OPJ_UINT32 )0;
    {
#line 1399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1399
      if (! (cblkno < l_nb_code_blocks)) {
#line 1399
        goto while_break___0;
      }
#line 1400
      l_seg = (opj_tcd_seg_t *)0;
#line 1404
      if (partial_buffer) {
#line 1405
        l_cblk->numchunks = (OPJ_UINT32 )0;
      }
#line 1408
      if (! l_cblk->numnewpasses) {
#line 1410
        l_cblk ++;
#line 1411
        goto while_continue___0;
      }
#line 1414
      if (! l_cblk->numsegs) {
#line 1415
        l_seg = l_cblk->segs;
#line 1416
        (l_cblk->numsegs) ++;
      } else {
#line 1418
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1420
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1421
          l_seg ++;
#line 1422
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1426
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1428
        if (l_current_data + l_seg->newlen > p_src_data + p_max_length) {
          _L: /* CIL Label */ 
          _L___7: /* CIL Label */ 
#line 1432
          if ((p_t2->cp)->strict) {
            {
#line 1433
            opj_event_msg(p_manager, 1, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                          l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                          p_pi->resno, p_pi->compno);
            }
#line 1437
            return (0);
          } else {
            {
#line 1439
            opj_event_msg(p_manager, 2, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
                          l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                          p_pi->resno, p_pi->compno);
#line 1444
            partial_buffer = 1;
#line 1445
            l_cblk->numchunks = (OPJ_UINT32 )0;
#line 1447
            l_seg->numpasses += l_seg->numnewpasses;
#line 1448
            l_cblk->numnewpasses -= l_seg->numnewpasses;
            }
#line 1449
            if (l_cblk->numnewpasses > 0U) {
#line 1450
              l_seg ++;
#line 1451
              (l_cblk->numsegs) ++;
#line 1452
              goto while_break___1;
            }
#line 1454
            goto while_continue___1;
          }
        } else
#line 1428
        if ((OPJ_SIZE_T )l_current_data + (OPJ_SIZE_T )l_seg->newlen < (OPJ_SIZE_T )l_current_data) {
#line 1428
          goto _L;
        } else
#line 1428
        if (partial_buffer) {
#line 1428
          goto _L;
        }
#line 1479
        if (l_cblk->numchunks == l_cblk->numchunksalloc) {
          {
#line 1480
          l_numchunksalloc = l_cblk->numchunksalloc * 2U + 1U;
#line 1481
          __cil_tmp21 = opj_realloc(l_cblk->chunks, (unsigned long )l_numchunksalloc * sizeof(opj_tcd_seg_data_chunk_t ));
#line 1481
          l_chunks = (opj_tcd_seg_data_chunk_t *)__cil_tmp21;
          }
#line 1484
          if (l_chunks == (void *)0) {
            {
#line 1485
            opj_event_msg(p_manager, 1, "cannot allocate opj_tcd_seg_data_chunk_t* array");
            }
#line 1487
            return (0);
          }
#line 1489
          l_cblk->chunks = l_chunks;
#line 1490
          l_cblk->numchunksalloc = l_numchunksalloc;
        }
#line 1493
        (l_cblk->chunks + l_cblk->numchunks)->data = l_current_data;
#line 1494
        (l_cblk->chunks + l_cblk->numchunks)->len = l_seg->newlen;
#line 1495
        (l_cblk->numchunks) ++;
#line 1497
        l_current_data += l_seg->newlen;
#line 1498
        l_seg->len += l_seg->newlen;
#line 1499
        l_seg->numpasses += l_seg->numnewpasses;
#line 1500
        l_cblk->numnewpasses -= l_seg->numnewpasses;
#line 1502
        l_seg->real_num_passes = l_seg->numpasses;
#line 1504
        if (l_cblk->numnewpasses > 0U) {
#line 1505
          l_seg ++;
#line 1506
          (l_cblk->numsegs) ++;
        }
#line 1426
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1426
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1510
      l_cblk->real_num_segs = l_cblk->numsegs;
#line 1511
      l_cblk ++;
#line 1399
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1514
    l_band ++;
#line 1388
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1518
  if (partial_buffer) {
#line 1519
    *p_data_read = p_max_length;
  } else {
#line 1521
    *p_data_read = (OPJ_UINT32 )(l_current_data - p_src_data);
  }
#line 1524
  return (1);
}
}
#line 1527 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t *p_t2 , opj_tcd_tile_t *p_tile ,
                                        opj_pi_iterator_t *p_pi , OPJ_UINT32 *p_data_read ,
                                        OPJ_UINT32 p_max_length , opj_packet_info_t *pack_info ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 bandno ;
  OPJ_UINT32 cblkno ;
  OPJ_UINT32 l_nb_code_blocks ;
  opj_tcd_band_t *l_band ;
  opj_tcd_cblk_dec_t *l_cblk ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_precinct_t *l_prc ;
  opj_tcd_seg_t *l_seg ;

  {
#line 1537
  l_band = (opj_tcd_band_t *)0;
#line 1538
  l_cblk = (opj_tcd_cblk_dec_t *)0;
#line 1539
  l_res = (p_tile->comps + p_pi->compno)->resolutions + p_pi->resno;
#line 1545
  *p_data_read = (OPJ_UINT32 )0;
#line 1546
  l_band = (opj_tcd_band_t *)l_res->bands;
#line 1548
  bandno = (OPJ_UINT32 )0;
  {
#line 1548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1548
    if (! (bandno < l_res->numbands)) {
#line 1548
      goto while_break;
    }
#line 1549
    l_prc = l_band->precincts + p_pi->precno;
#line 1551
    if (l_band->x1 - l_band->x0 == 0) {
#line 1552
      l_band ++;
#line 1553
      goto while_continue;
    } else
#line 1551
    if (l_band->y1 - l_band->y0 == 0) {
#line 1552
      l_band ++;
#line 1553
      goto while_continue;
    }
#line 1556
    l_nb_code_blocks = l_prc->cw * l_prc->ch;
#line 1557
    l_cblk = l_prc->cblks.dec;
#line 1559
    cblkno = (OPJ_UINT32 )0;
    {
#line 1559
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1559
      if (! (cblkno < l_nb_code_blocks)) {
#line 1559
        goto while_break___0;
      }
#line 1560
      l_seg = (opj_tcd_seg_t *)0;
#line 1562
      if (! l_cblk->numnewpasses) {
#line 1564
        l_cblk ++;
#line 1565
        goto while_continue___0;
      }
#line 1568
      if (! l_cblk->numsegs) {
#line 1569
        l_seg = l_cblk->segs;
#line 1570
        (l_cblk->numsegs) ++;
      } else {
#line 1572
        l_seg = l_cblk->segs + (l_cblk->numsegs - 1U);
#line 1574
        if (l_seg->numpasses == l_seg->maxpasses) {
#line 1575
          l_seg ++;
#line 1576
          (l_cblk->numsegs) ++;
        }
      }
      {
#line 1580
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1582
        if (*p_data_read + l_seg->newlen < *p_data_read) {
          _L: /* CIL Label */ 
#line 1584
          if ((p_t2->cp)->strict) {
            {
#line 1585
            opj_event_msg(p_manager, 1, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                          l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                          p_pi->resno, p_pi->compno);
            }
#line 1589
            return (0);
          } else {
            {
#line 1591
            opj_event_msg(p_manager, 2, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\nEV",
                          l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno,
                          p_pi->resno, p_pi->compno);
            }
#line 1595
            return (1);
          }
        } else
#line 1582
        if (*p_data_read + l_seg->newlen > p_max_length) {
#line 1582
          goto _L;
        }
        {
#line 1619
        opj_null_jas_fprintf(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read,
                             l_seg->newlen);
#line 1621
        *p_data_read += l_seg->newlen;
#line 1623
        l_seg->numpasses += l_seg->numnewpasses;
#line 1624
        l_cblk->numnewpasses -= l_seg->numnewpasses;
        }
#line 1625
        if (l_cblk->numnewpasses > 0U) {
#line 1626
          l_seg ++;
#line 1627
          (l_cblk->numsegs) ++;
        }
#line 1580
        if (! (l_cblk->numnewpasses > 0U)) {
#line 1580
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1631
      l_cblk ++;
#line 1559
      cblkno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1634
    l_band ++;
#line 1548
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1637
  return (1);
}
}
#line 1641 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.c"
static OPJ_BOOL opj_t2_init_seg(opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 index___0 ,
                                OPJ_UINT32 cblksty , OPJ_UINT32 first ) 
{ 
  opj_tcd_seg_t *seg ;
  OPJ_UINT32 l_nb_segs ;
  opj_tcd_seg_t *new_segs ;
  OPJ_UINT32 l_m_current_max_segs ;
  void *__cil_tmp9 ;
  int tmp ;

  {
#line 1646
  seg = (opj_tcd_seg_t *)0;
#line 1647
  l_nb_segs = index___0 + 1U;
#line 1649
  if (l_nb_segs > cblk->m_current_max_segs) {
    {
#line 1651
    l_m_current_max_segs = cblk->m_current_max_segs + 10U;
#line 1654
    __cil_tmp9 = opj_realloc(cblk->segs, (unsigned long )l_m_current_max_segs * sizeof(opj_tcd_seg_t ));
#line 1654
    new_segs = (opj_tcd_seg_t *)__cil_tmp9;
    }
#line 1656
    if (! new_segs) {
#line 1658
      return (0);
    }
    {
#line 1660
    cblk->segs = new_segs;
#line 1661
    memset(new_segs + cblk->m_current_max_segs, 0, 10UL * sizeof(opj_tcd_seg_t ));
#line 1663
    cblk->m_current_max_segs = l_m_current_max_segs;
    }
  }
  {
#line 1666
  seg = cblk->segs + index___0;
#line 1667
  opj_tcd_reinit_segment(seg);
  }
#line 1669
  if (cblksty & 4U) {
#line 1670
    seg->maxpasses = (OPJ_UINT32 )1;
  } else
#line 1671
  if (cblksty & 1U) {
#line 1672
    if (first) {
#line 1673
      seg->maxpasses = (OPJ_UINT32 )10;
    } else {
#line 1675
      if ((seg - 1)->maxpasses == 1U || (seg - 1)->maxpasses == 10U) {
#line 1675
        tmp = 2;
      } else {
#line 1675
        tmp = 1;
      }
#line 1675
      seg->maxpasses = (OPJ_UINT32 )tmp;
    }
  } else {
#line 1683
    seg->maxpasses = (OPJ_UINT32 )109;
  }
#line 1686
  return (1);
}
}
#line 45 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) 
{ 
  opj_sparse_array_int32_t *sa ;
  void *__cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 52
  if (width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_width == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  } else
#line 52
  if (block_height == 0U) {
#line 53
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 55
  if ((unsigned long )block_width > (unsigned long )(4294967295U / block_height) / sizeof(OPJ_INT32 )) {
#line 56
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 59
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_sparse_array_int32_t ));
#line 59
  sa = (opj_sparse_array_int32_t *)__cil_tmp6;
#line 61
  sa->width = width;
#line 62
  sa->height = height;
#line 63
  sa->block_width = block_width;
#line 64
  sa->block_height = block_height;
#line 65
  sa->block_count_hor = opj_uint_ceildiv(width, block_width);
#line 66
  sa->block_count_ver = opj_uint_ceildiv(height, block_height);
  }
#line 67
  if (sa->block_count_hor > 4294967295U / sa->block_count_ver) {
    {
#line 68
    opj_free(sa);
    }
#line 69
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
  {
#line 71
  __cil_tmp9 = opj_calloc(sizeof(OPJ_INT32 *), (size_t )sa->block_count_hor * (unsigned long )sa->block_count_ver);
#line 71
  sa->data_blocks = (OPJ_INT32 **)__cil_tmp9;
  }
#line 73
  if (sa->data_blocks == (void *)0) {
    {
#line 74
    opj_free(sa);
    }
#line 75
    return ((opj_sparse_array_int32_t *)((void *)0));
  }
#line 78
  return (sa);
}
}
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 83
  if (sa) {
#line 85
    i = (OPJ_UINT32 )0;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (i < sa->block_count_hor * sa->block_count_ver)) {
#line 85
        goto while_break;
      }
#line 86
      if (*(sa->data_blocks + i)) {
        {
#line 87
        opj_free(*(sa->data_blocks + i));
        }
      }
#line 85
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 90
    opj_free(sa->data_blocks);
#line 91
    opj_free(sa);
    }
  }
  return;
}
}
#line 95 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ) 
{ 


  {
#line 101
  return (! (((((x0 >= sa->width || x1 <= x0) || x1 > sa->width) || y0___0 >= sa->height) || y1___0 <= y0___0) || y1___0 > sa->height));
}
}
#line 105 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
static OPJ_BOOL opj_sparse_array_int32_read_or_write(opj_sparse_array_int32_t *sa ,
                                                     OPJ_UINT32 x0 , OPJ_UINT32 y0___0 ,
                                                     OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                                     OPJ_INT32 *buf , OPJ_UINT32 buf_col_stride ,
                                                     OPJ_UINT32 buf_line_stride ,
                                                     OPJ_BOOL forgiving , OPJ_BOOL is_read_op ) 
{ 
  OPJ_UINT32 y ;
  OPJ_UINT32 block_y ;
  OPJ_UINT32 y_incr ;
  OPJ_UINT32 block_width ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_UINT32 x ;
  OPJ_UINT32 block_x ;
  OPJ_UINT32 x_incr ;
  OPJ_UINT32 block_y_offset ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 j ;
  OPJ_UINT32 block_x_offset ;
  OPJ_INT32 *src_block ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_INT32 *dest_ptr ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_INT32 *dest_ptr___0 ;
  OPJ_UINT32 k ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_INT32 *src_ptr ;
  OPJ_INT32 *dest_ptr___1 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_INT32 *dest_ptr___2 ;
  OPJ_UINT32 __cil_tmp38 ;
  OPJ_UINT32 k___0 ;
  OPJ_UINT32 __cil_tmp40 ;
  OPJ_UINT32 k___1 ;
  OPJ_UINT32 __cil_tmp42 ;
  OPJ_UINT32 __cil_tmp43 ;
  OPJ_UINT32 k___2 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  void *__cil_tmp47 ;
  OPJ_INT32 *dest_ptr___3 ;
  OPJ_INT32 *src_ptr___0 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_INT32 *dest_ptr___4 ;
  OPJ_INT32 *src_ptr___1 ;
  OPJ_UINT32 __cil_tmp54 ;
  OPJ_UINT32 k___3 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 k___4 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 __cil_tmp62 ;

  {
  {
#line 118
  y_incr = (OPJ_UINT32 )0;
#line 119
  block_width = sa->block_width;
#line 121
  __cil_tmp15 = opj_sparse_array_is_region_valid(sa, x0, y0___0, x1, y1___0);
  }
#line 121
  if (! __cil_tmp15) {
#line 122
    return (forgiving);
  }
#line 125
  block_y = y0___0 / sa->block_height;
#line 126
  y = y0___0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (y < y1___0)) {
#line 126
      goto while_break;
    }
#line 128
    x_incr = (OPJ_UINT32 )0;
#line 130
    if (y == y0___0) {
#line 130
      tmp = sa->block_height - y0___0 % sa->block_height;
    } else {
#line 130
      tmp = sa->block_height;
    }
    {
#line 130
    y_incr = tmp;
#line 132
    block_y_offset = sa->block_height - y_incr;
#line 133
    y_incr = opj_uint_min(y_incr, y1___0 - y);
#line 134
    block_x = x0 / block_width;
#line 135
    x = x0;
    }
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! (x < x1)) {
#line 135
        goto while_break___0;
      }
#line 139
      if (x == x0) {
#line 139
        tmp___0 = block_width - x0 % block_width;
      } else {
#line 139
        tmp___0 = block_width;
      }
      {
#line 139
      x_incr = tmp___0;
#line 140
      block_x_offset = block_width - x_incr;
#line 141
      x_incr = opj_uint_min(x_incr, x1 - x);
#line 142
      src_block = *(sa->data_blocks + (block_y * sa->block_count_hor + block_x));
      }
#line 143
      if (is_read_op) {
#line 144
        if (src_block == (void *)0) {
#line 145
          if (buf_col_stride == 1U) {
#line 146
            dest_ptr = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 148
            j = (OPJ_UINT32 )0;
            {
#line 148
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 148
              if (! (j < y_incr)) {
#line 148
                goto while_break___1;
              }
              {
#line 149
              memset(dest_ptr, 0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 150
              dest_ptr += buf_line_stride;
              }
#line 148
              j ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
#line 153
            dest_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 155
            j = (OPJ_UINT32 )0;
            {
#line 155
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 155
              if (! (j < y_incr)) {
#line 155
                goto while_break___2;
              }
#line 157
              k = (OPJ_UINT32 )0;
              {
#line 157
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 157
                if (! (k < x_incr)) {
#line 157
                  goto while_break___3;
                }
#line 158
                *(dest_ptr___0 + k * buf_col_stride) = 0;
#line 157
                k ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 160
              dest_ptr___0 += buf_line_stride;
#line 155
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 164
          src_ptr = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 166
          if (buf_col_stride == 1U) {
#line 167
            dest_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 170
            if (x_incr == 4U) {
#line 174
              j = (OPJ_UINT32 )0;
              {
#line 174
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 174
                if (! (j < y_incr)) {
#line 174
                  goto while_break___4;
                }
                {
#line 175
                memcpy(dest_ptr___1, src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 176
                dest_ptr___1 += buf_line_stride;
#line 177
                src_ptr += block_width;
                }
#line 174
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 180
              j = (OPJ_UINT32 )0;
              {
#line 180
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 180
                if (! (j < y_incr)) {
#line 180
                  goto while_break___5;
                }
                {
#line 181
                memcpy(dest_ptr___1, src_ptr, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 182
                dest_ptr___1 += buf_line_stride;
#line 183
                src_ptr += block_width;
                }
#line 180
                j ++;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
          } else {
#line 187
            dest_ptr___2 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 190
            if (x_incr == 1U) {
#line 191
              j = (OPJ_UINT32 )0;
              {
#line 191
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 191
                if (! (j < y_incr)) {
#line 191
                  goto while_break___6;
                }
#line 192
                *dest_ptr___2 = *src_ptr;
#line 193
                dest_ptr___2 += buf_line_stride;
#line 194
                src_ptr += block_width;
#line 191
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            } else
#line 196
            if (y_incr == 1U) {
#line 196
              if (buf_col_stride == 2U) {
#line 198
                k___0 = (OPJ_UINT32 )0;
                {
#line 198
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 198
                  if (! (k___0 < (x_incr & 4294967292U))) {
#line 198
                    goto while_break___7;
                  }
#line 199
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 200
                  *(dest_ptr___2 + (k___0 + 1U) * buf_col_stride) = *(src_ptr + (k___0 + 1U));
#line 201
                  *(dest_ptr___2 + (k___0 + 2U) * buf_col_stride) = *(src_ptr + (k___0 + 2U));
#line 202
                  *(dest_ptr___2 + (k___0 + 3U) * buf_col_stride) = *(src_ptr + (k___0 + 3U));
#line 198
                  k___0 += (unsigned int )4;
                }
                while_break___7: /* CIL Label */ ;
                }
                {
#line 204
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 204
                  if (! (k___0 < x_incr)) {
#line 204
                    goto while_break___8;
                  }
#line 205
                  *(dest_ptr___2 + k___0 * buf_col_stride) = *(src_ptr + k___0);
#line 204
                  k___0 ++;
                }
                while_break___8: /* CIL Label */ ;
                }
              } else {
#line 196
                goto _L___8;
              }
            } else
            _L___8: /* CIL Label */ 
#line 207
            if (x_incr >= 8U) {
#line 207
              if (buf_col_stride == 8U) {
#line 208
                j = (OPJ_UINT32 )0;
                {
#line 208
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 208
                  if (! (j < y_incr)) {
#line 208
                    goto while_break___9;
                  }
#line 210
                  k___1 = (OPJ_UINT32 )0;
                  {
#line 210
                  while (1) {
                    while_continue___10: /* CIL Label */ ;
#line 210
                    if (! (k___1 < (x_incr & 4294967292U))) {
#line 210
                      goto while_break___10;
                    }
#line 211
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 212
                    *(dest_ptr___2 + (k___1 + 1U) * buf_col_stride) = *(src_ptr + (k___1 + 1U));
#line 213
                    *(dest_ptr___2 + (k___1 + 2U) * buf_col_stride) = *(src_ptr + (k___1 + 2U));
#line 214
                    *(dest_ptr___2 + (k___1 + 3U) * buf_col_stride) = *(src_ptr + (k___1 + 3U));
#line 210
                    k___1 += (unsigned int )4;
                  }
                  while_break___10: /* CIL Label */ ;
                  }
                  {
#line 216
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 216
                    if (! (k___1 < x_incr)) {
#line 216
                      goto while_break___11;
                    }
#line 217
                    *(dest_ptr___2 + k___1 * buf_col_stride) = *(src_ptr + k___1);
#line 216
                    k___1 ++;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
#line 219
                  dest_ptr___2 += buf_line_stride;
#line 220
                  src_ptr += block_width;
#line 208
                  j ++;
                }
                while_break___9: /* CIL Label */ ;
                }
              } else {
#line 207
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 224
              j = (OPJ_UINT32 )0;
              {
#line 224
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 224
                if (! (j < y_incr)) {
#line 224
                  goto while_break___12;
                }
#line 226
                k___2 = (OPJ_UINT32 )0;
                {
#line 226
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 226
                  if (! (k___2 < x_incr)) {
#line 226
                    goto while_break___13;
                  }
#line 227
                  *(dest_ptr___2 + k___2 * buf_col_stride) = *(src_ptr + k___2);
#line 226
                  k___2 ++;
                }
                while_break___13: /* CIL Label */ ;
                }
#line 229
                dest_ptr___2 += buf_line_stride;
#line 230
                src_ptr += block_width;
#line 224
                j ++;
              }
              while_break___12: /* CIL Label */ ;
              }
            }
          }
        }
      } else {
#line 236
        if (src_block == (void *)0) {
          {
#line 237
          __cil_tmp47 = opj_calloc((size_t )1, ((size_t )sa->block_width * (unsigned long )sa->block_height) * sizeof(OPJ_INT32 ));
#line 237
          src_block = (OPJ_INT32 *)__cil_tmp47;
          }
#line 239
          if (src_block == (void *)0) {
#line 240
            return (0);
          }
#line 242
          *(sa->data_blocks + (block_y * sa->block_count_hor + block_x)) = src_block;
        }
#line 245
        if (buf_col_stride == 1U) {
#line 246
          dest_ptr___3 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 248
          src_ptr___0 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 250
          if (x_incr == 4U) {
#line 254
            j = (OPJ_UINT32 )0;
            {
#line 254
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 254
              if (! (j < y_incr)) {
#line 254
                goto while_break___14;
              }
              {
#line 255
              memcpy(dest_ptr___3, src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 256
              dest_ptr___3 += block_width;
#line 257
              src_ptr___0 += buf_line_stride;
              }
#line 254
              j ++;
            }
            while_break___14: /* CIL Label */ ;
            }
          } else {
#line 260
            j = (OPJ_UINT32 )0;
            {
#line 260
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 260
              if (! (j < y_incr)) {
#line 260
                goto while_break___15;
              }
              {
#line 261
              memcpy(dest_ptr___3, src_ptr___0, sizeof(OPJ_INT32 ) * (unsigned long )x_incr);
#line 262
              dest_ptr___3 += block_width;
#line 263
              src_ptr___0 += buf_line_stride;
              }
#line 260
              j ++;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        } else {
#line 267
          dest_ptr___4 = (src_block + (unsigned long )block_y_offset * (OPJ_SIZE_T )block_width) + block_x_offset;
#line 269
          src_ptr___1 = (buf + (unsigned long )(y - y0___0) * (OPJ_SIZE_T )buf_line_stride) + (x - x0) * buf_col_stride;
#line 271
          if (x_incr == 1U) {
#line 272
            j = (OPJ_UINT32 )0;
            {
#line 272
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 272
              if (! (j < y_incr)) {
#line 272
                goto while_break___16;
              }
#line 273
              *dest_ptr___4 = *src_ptr___1;
#line 274
              src_ptr___1 += buf_line_stride;
#line 275
              dest_ptr___4 += block_width;
#line 272
              j ++;
            }
            while_break___16: /* CIL Label */ ;
            }
          } else
#line 277
          if (x_incr >= 8U) {
#line 277
            if (buf_col_stride == 8U) {
#line 278
              j = (OPJ_UINT32 )0;
              {
#line 278
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 278
                if (! (j < y_incr)) {
#line 278
                  goto while_break___17;
                }
#line 280
                k___3 = (OPJ_UINT32 )0;
                {
#line 280
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 280
                  if (! (k___3 < (x_incr & 4294967292U))) {
#line 280
                    goto while_break___18;
                  }
#line 281
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 282
                  *(dest_ptr___4 + (k___3 + 1U)) = *(src_ptr___1 + (k___3 + 1U) * buf_col_stride);
#line 283
                  *(dest_ptr___4 + (k___3 + 2U)) = *(src_ptr___1 + (k___3 + 2U) * buf_col_stride);
#line 284
                  *(dest_ptr___4 + (k___3 + 3U)) = *(src_ptr___1 + (k___3 + 3U) * buf_col_stride);
#line 280
                  k___3 += (unsigned int )4;
                }
                while_break___18: /* CIL Label */ ;
                }
                {
#line 286
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 286
                  if (! (k___3 < x_incr)) {
#line 286
                    goto while_break___19;
                  }
#line 287
                  *(dest_ptr___4 + k___3) = *(src_ptr___1 + k___3 * buf_col_stride);
#line 286
                  k___3 ++;
                }
                while_break___19: /* CIL Label */ ;
                }
#line 289
                src_ptr___1 += buf_line_stride;
#line 290
                dest_ptr___4 += block_width;
#line 278
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            } else {
#line 277
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ 
#line 294
            j = (OPJ_UINT32 )0;
            {
#line 294
            while (1) {
              while_continue___20: /* CIL Label */ ;
#line 294
              if (! (j < y_incr)) {
#line 294
                goto while_break___20;
              }
#line 296
              k___4 = (OPJ_UINT32 )0;
              {
#line 296
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 296
                if (! (k___4 < x_incr)) {
#line 296
                  goto while_break___21;
                }
#line 297
                *(dest_ptr___4 + k___4) = *(src_ptr___1 + k___4 * buf_col_stride);
#line 296
                k___4 ++;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 299
              src_ptr___1 += buf_line_stride;
#line 300
              dest_ptr___4 += block_width;
#line 294
              j ++;
            }
            while_break___20: /* CIL Label */ ;
            }
          }
        }
      }
#line 135
      x += x_incr;
#line 135
      __cil_tmp61 = block_x;
#line 135
      block_x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    y += y_incr;
#line 126
    __cil_tmp62 = block_y;
#line 126
    block_y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return (1);
}
}
#line 311 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 321
  __cil_tmp10 = opj_sparse_array_int32_read_or_write((opj_sparse_array_int32_t *)sa,
                                                     x0, y0___0, x1, y1___0, dest,
                                                     dest_col_stride, dest_line_stride,
                                                     forgiving, 1);
  }
#line 321
  return (__cil_tmp10);
}
}
#line 330 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.c"
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0___0 , OPJ_UINT32 x1 , OPJ_UINT32 y1___0 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) 
{ 
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 340
  __cil_tmp10 = opj_sparse_array_int32_read_or_write(sa, x0, y0___0, x1, y1___0, (OPJ_INT32 *)src,
                                                     src_col_stride, src_line_stride,
                                                     forgiving, 0);
  }
#line 340
  return (__cil_tmp10);
}
}
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t___0 *pi ) ;
#line 60
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t___0 *pi ) ;
#line 66
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t___0 *pi ) ;
#line 72
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t___0 *pi ) ;
#line 78
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t___0 *pi ) ;
#line 94
static void opj_pi_update_encode_poc_and_final(opj_cp_t___0 *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_UINT32 p_tx0 , OPJ_UINT32 p_tx1 ,
                                               OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 120
static void opj_pi_update_encode_not_poc(opj_cp_t___0 *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_UINT32 p_tx0 ,
                                         OPJ_UINT32 p_tx1 , OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                         OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                         OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 146
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                        OPJ_UINT32 p_tileno , OPJ_UINT32 *p_tx0 ,
                                        OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 , OPJ_UINT32 *p_ty1 ,
                                        OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                        OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) ;
#line 178
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_UINT32 *p_tx0 ,
                                            OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 ,
                                            OPJ_UINT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) ;
#line 199
static opj_pi_iterator_t___0 *opj_pi_create(opj_image_t *image , opj_cp_t___0 *cp ,
                                            OPJ_UINT32 tileno , opj_event_mgr_t *manager ) ;
#line 206
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 213
static void opj_pi_update_decode_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 221
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 237 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 239
  comp = (opj_pi_comp_t *)((void *)0);
#line 240
  res = (opj_pi_resolution_t *)((void *)0);
#line 241
  index___0 = (OPJ_UINT32 )0;
#line 243
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 245
    opj_event_msg(pi->manager, 1, "opj_pi_next_lrcp(): invalid compno0/compno1\n");
    }
    }
#line 247
    return (0);
  } else
#line 243
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 245
    opj_event_msg(pi->manager, 1, "opj_pi_next_lrcp(): invalid compno0/compno1\n");
    }
    }
#line 247
    return (0);
  }
#line 250
  if (! pi->first) {
#line 251
    comp = pi->comps + pi->compno;
#line 252
    res = comp->resolutions + pi->resno;
#line 253
    goto LABEL_SKIP;
  } else {
#line 255
    pi->first = 0;
  }
#line 258
  pi->layno = pi->poc.layno0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (pi->layno < pi->poc.layno1)) {
#line 258
      goto while_break;
    }
#line 259
    pi->resno = pi->poc.resno0;
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      if (! (pi->resno < pi->poc.resno1)) {
#line 259
        goto while_break___0;
      }
#line 261
      pi->compno = pi->poc.compno0;
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (pi->compno < pi->poc.compno1)) {
#line 261
          goto while_break___1;
        }
#line 262
        comp = pi->comps + pi->compno;
#line 263
        if (pi->resno >= comp->numresolutions) {
#line 264
          goto while_continue___1;
        }
#line 266
        res = comp->resolutions + pi->resno;
#line 267
        if (! pi->tp_on) {
#line 268
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 270
        pi->precno = pi->poc.precno0;
        {
#line 270
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 270
          if (! (pi->precno < pi->poc.precno1)) {
#line 270
            goto while_break___2;
          }
#line 271
          index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 279
          if (index___0 >= pi->include_size) {
            {
#line 280
            opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
            }
#line 281
            return (0);
          }
#line 283
          if (! *(pi->include + index___0)) {
#line 284
            *(pi->include + index___0) = (OPJ_INT16 )1;
#line 285
            return (1);
          }
          LABEL_SKIP: ;
#line 270
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 261
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 260
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 297 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 299
  comp = (opj_pi_comp_t *)((void *)0);
#line 300
  res = (opj_pi_resolution_t *)((void *)0);
#line 301
  index___0 = (OPJ_UINT32 )0;
#line 303
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 305
    opj_event_msg(pi->manager, 1, "opj_pi_next_rlcp(): invalid compno0/compno1\nEV");
    }
    }
#line 307
    return (0);
  } else
#line 303
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 305
    opj_event_msg(pi->manager, 1, "opj_pi_next_rlcp(): invalid compno0/compno1\nEV");
    }
    }
#line 307
    return (0);
  }
#line 310
  if (! pi->first) {
#line 311
    comp = pi->comps + pi->compno;
#line 312
    res = comp->resolutions + pi->resno;
#line 313
    goto LABEL_SKIP;
  } else {
#line 315
    pi->first = 0;
  }
#line 318
  pi->resno = pi->poc.resno0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (pi->resno < pi->poc.resno1)) {
#line 318
      goto while_break;
    }
#line 319
    pi->layno = pi->poc.layno0;
    {
#line 319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 319
      if (! (pi->layno < pi->poc.layno1)) {
#line 319
        goto while_break___0;
      }
#line 320
      pi->compno = pi->poc.compno0;
      {
#line 320
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 320
        if (! (pi->compno < pi->poc.compno1)) {
#line 320
          goto while_break___1;
        }
#line 321
        comp = pi->comps + pi->compno;
#line 322
        if (pi->resno >= comp->numresolutions) {
#line 323
          goto while_continue___1;
        }
#line 325
        res = comp->resolutions + pi->resno;
#line 326
        if (! pi->tp_on) {
#line 327
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 329
        pi->precno = pi->poc.precno0;
        {
#line 329
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 329
          if (! (pi->precno < pi->poc.precno1)) {
#line 329
            goto while_break___2;
          }
#line 330
          index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 332
          if (index___0 >= pi->include_size) {
            {
#line 333
            opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
            }
#line 334
            return (0);
          }
#line 336
          if (! *(pi->include + index___0)) {
#line 337
            *(pi->include + index___0) = (OPJ_INT16 )1;
#line 338
            return (1);
          }
          LABEL_SKIP: ;
#line 329
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 320
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 319
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 318
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return (0);
}
}
#line 350 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;

  {
#line 352
  comp = (opj_pi_comp_t *)((void *)0);
#line 353
  res = (opj_pi_resolution_t *)((void *)0);
#line 354
  index___0 = (OPJ_UINT32 )0;
#line 356
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 358
    opj_event_msg(pi->manager, 1, "opj_pi_next_rpcl(): invalid compno0/compno1\n");
    }
    }
#line 360
    return (0);
  } else
#line 356
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 358
    opj_event_msg(pi->manager, 1, "opj_pi_next_rpcl(): invalid compno0/compno1\n");
    }
    }
#line 360
    return (0);
  }
#line 363
  if (! pi->first) {
#line 364
    goto LABEL_SKIP;
  } else {
#line 367
    pi->first = 0;
#line 368
    pi->dx = (OPJ_UINT32 )0;
#line 369
    pi->dy = (OPJ_UINT32 )0;
#line 370
    compno = (OPJ_UINT32 )0;
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;
#line 370
      if (! (compno < pi->numcomps)) {
#line 370
        goto while_break;
      }
#line 371
      comp = pi->comps + compno;
#line 372
      resno = (OPJ_UINT32 )0;
      {
#line 372
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 372
        if (! (resno < comp->numresolutions)) {
#line 372
          goto while_break___0;
        }
#line 374
        res = comp->resolutions + resno;
#line 375
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 375
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 377
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 378
            if (! pi->dx) {
#line 378
              tmp = dx;
            } else {
              {
#line 378
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 378
              tmp = __cil_tmp9;
              }
            }
#line 378
            pi->dx = tmp;
          }
        }
#line 380
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 380
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 382
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 383
            if (! pi->dy) {
#line 383
              tmp___0 = dy;
            } else {
              {
#line 383
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 383
              tmp___0 = __cil_tmp11;
              }
            }
#line 383
            pi->dy = tmp___0;
          }
        }
#line 372
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 370
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 387
    if (pi->dx == 0U) {
#line 388
      return (0);
    } else
#line 387
    if (pi->dy == 0U) {
#line 388
      return (0);
    }
  }
#line 391
  if (! pi->tp_on) {
#line 392
    pi->poc.ty0 = pi->ty0;
#line 393
    pi->poc.tx0 = pi->tx0;
#line 394
    pi->poc.ty1 = pi->ty1;
#line 395
    pi->poc.tx1 = pi->tx1;
  }
#line 397
  pi->resno = pi->poc.resno0;
  {
#line 397
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 397
    if (! (pi->resno < pi->poc.resno1)) {
#line 397
      goto while_break___1;
    }
#line 398
    pi->y = (OPJ_UINT32 )pi->poc.ty0;
    {
#line 398
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 398
      if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 398
        goto while_break___2;
      }
#line 400
      pi->x = (OPJ_UINT32 )pi->poc.tx0;
      {
#line 400
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 400
        if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 400
          goto while_break___3;
        }
#line 402
        pi->compno = pi->poc.compno0;
        {
#line 402
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 402
          if (! (pi->compno < pi->poc.compno1)) {
#line 402
            goto while_break___4;
          }
#line 408
          comp = pi->comps + pi->compno;
#line 409
          if (pi->resno >= comp->numresolutions) {
#line 410
            goto while_continue___4;
          }
#line 412
          res = comp->resolutions + pi->resno;
#line 413
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 415
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 417
            goto while_continue___4;
          } else
#line 415
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 417
            goto while_continue___4;
          }
          {
#line 420
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 422
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 424
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 426
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 428
          rpx = res->pdx + levelno;
#line 429
          rpy = res->pdy + levelno;
          }
#line 431
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 433
            goto while_continue___4;
          } else
#line 431
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 433
            goto while_continue___4;
          }
#line 437
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 440
            goto while_continue___4;
          }
#line 442
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 445
            goto while_continue___4;
          }
#line 448
          if (res->pw == 0U) {
#line 449
            goto while_continue___4;
          } else
#line 448
          if (res->ph == 0U) {
#line 449
            goto while_continue___4;
          }
#line 452
          if (trx0 == trx1) {
#line 453
            goto while_continue___4;
          } else
#line 452
          if (try0 == try1) {
#line 453
            goto while_continue___4;
          }
          {
#line 456
          __cil_tmp30 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 456
          __cil_tmp28 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 456
          __cil_tmp29 = opj_uint_floordivpow2(__cil_tmp28, res->pdx);
#line 456
          prci = __cil_tmp29 - __cil_tmp30;
#line 459
          __cil_tmp33 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 459
          __cil_tmp31 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 459
          __cil_tmp32 = opj_uint_floordivpow2(__cil_tmp31, res->pdy);
#line 459
          prcj = __cil_tmp32 - __cil_tmp33;
#line 462
          pi->precno = prci + prcj * res->pw;
#line 463
          pi->layno = pi->poc.layno0;
          }
          {
#line 463
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 463
            if (! (pi->layno < pi->poc.layno1)) {
#line 463
              goto while_break___5;
            }
#line 464
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 466
            if (index___0 >= pi->include_size) {
              {
#line 467
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 468
              return (0);
            }
#line 470
            if (! *(pi->include + index___0)) {
#line 471
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 472
              return (1);
            }
            LABEL_SKIP: ;
#line 463
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 402
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 401
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 399
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 397
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 482
  return (0);
}
}
#line 485 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;

  {
#line 487
  comp = (opj_pi_comp_t *)((void *)0);
#line 488
  res = (opj_pi_resolution_t *)((void *)0);
#line 489
  index___0 = (OPJ_UINT32 )0;
#line 491
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 493
    opj_event_msg(pi->manager, 1, "opj_pi_next_pcrl(): invalid compno0/compno1\n");
    }
    }
#line 495
    return (0);
  } else
#line 491
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 493
    opj_event_msg(pi->manager, 1, "opj_pi_next_pcrl(): invalid compno0/compno1\n");
    }
    }
#line 495
    return (0);
  }
#line 498
  if (! pi->first) {
#line 499
    comp = pi->comps + pi->compno;
#line 500
    goto LABEL_SKIP;
  } else {
#line 503
    pi->first = 0;
#line 504
    pi->dx = (OPJ_UINT32 )0;
#line 505
    pi->dy = (OPJ_UINT32 )0;
#line 506
    compno = (OPJ_UINT32 )0;
    {
#line 506
    while (1) {
      while_continue: /* CIL Label */ ;
#line 506
      if (! (compno < pi->numcomps)) {
#line 506
        goto while_break;
      }
#line 507
      comp = pi->comps + compno;
#line 508
      resno = (OPJ_UINT32 )0;
      {
#line 508
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 508
        if (! (resno < comp->numresolutions)) {
#line 508
          goto while_break___0;
        }
#line 510
        res = comp->resolutions + resno;
#line 511
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 511
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 513
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 514
            if (! pi->dx) {
#line 514
              tmp = dx;
            } else {
              {
#line 514
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 514
              tmp = __cil_tmp9;
              }
            }
#line 514
            pi->dx = tmp;
          }
        }
#line 516
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 516
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 518
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 519
            if (! pi->dy) {
#line 519
              tmp___0 = dy;
            } else {
              {
#line 519
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 519
              tmp___0 = __cil_tmp11;
              }
            }
#line 519
            pi->dy = tmp___0;
          }
        }
#line 508
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 506
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 523
    if (pi->dx == 0U) {
#line 524
      return (0);
    } else
#line 523
    if (pi->dy == 0U) {
#line 524
      return (0);
    }
  }
#line 527
  if (! pi->tp_on) {
#line 528
    pi->poc.ty0 = pi->ty0;
#line 529
    pi->poc.tx0 = pi->tx0;
#line 530
    pi->poc.ty1 = pi->ty1;
#line 531
    pi->poc.tx1 = pi->tx1;
  }
#line 533
  pi->y = (OPJ_UINT32 )pi->poc.ty0;
  {
#line 533
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 533
    if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 533
      goto while_break___1;
    }
#line 535
    pi->x = (OPJ_UINT32 )pi->poc.tx0;
    {
#line 535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 535
      if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 535
        goto while_break___2;
      }
#line 537
      pi->compno = pi->poc.compno0;
      {
#line 537
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 537
        if (! (pi->compno < pi->poc.compno1)) {
#line 537
          goto while_break___3;
        }
#line 538
        comp = pi->comps + pi->compno;
#line 539
        pi->resno = pi->poc.resno0;
        {
#line 539
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 539
          if (! (pi->resno < __cil_tmp15)) {
#line 539
            goto while_break___4;
          }
#line 546
          res = comp->resolutions + pi->resno;
#line 547
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 549
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 551
            goto while_continue___4;
          } else
#line 549
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 551
            goto while_continue___4;
          }
          {
#line 554
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 556
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 558
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 560
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 562
          rpx = res->pdx + levelno;
#line 563
          rpy = res->pdy + levelno;
          }
#line 565
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 567
            goto while_continue___4;
          } else
#line 565
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 567
            goto while_continue___4;
          }
#line 571
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 574
            goto while_continue___4;
          }
#line 576
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 579
            goto while_continue___4;
          }
#line 582
          if (res->pw == 0U) {
#line 583
            goto while_continue___4;
          } else
#line 582
          if (res->ph == 0U) {
#line 583
            goto while_continue___4;
          }
#line 586
          if (trx0 == trx1) {
#line 587
            goto while_continue___4;
          } else
#line 586
          if (try0 == try1) {
#line 587
            goto while_continue___4;
          }
          {
#line 590
          __cil_tmp31 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 590
          __cil_tmp29 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 590
          __cil_tmp30 = opj_uint_floordivpow2(__cil_tmp29, res->pdx);
#line 590
          prci = __cil_tmp30 - __cil_tmp31;
#line 593
          __cil_tmp34 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 593
          __cil_tmp32 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 593
          __cil_tmp33 = opj_uint_floordivpow2(__cil_tmp32, res->pdy);
#line 593
          prcj = __cil_tmp33 - __cil_tmp34;
#line 596
          pi->precno = prci + prcj * res->pw;
#line 597
          pi->layno = pi->poc.layno0;
          }
          {
#line 597
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 597
            if (! (pi->layno < pi->poc.layno1)) {
#line 597
              goto while_break___5;
            }
#line 598
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 600
            if (index___0 >= pi->include_size) {
              {
#line 601
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 602
              return (0);
            }
#line 604
            if (! *(pi->include + index___0)) {
#line 605
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 606
              return (1);
            }
            LABEL_SKIP: ;
#line 597
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 540
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 537
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 536
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 534
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 616
  return (0);
}
}
#line 619 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;

  {
#line 621
  comp = (opj_pi_comp_t *)((void *)0);
#line 622
  res = (opj_pi_resolution_t *)((void *)0);
#line 623
  index___0 = (OPJ_UINT32 )0;
#line 625
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 627
    opj_event_msg(pi->manager, 1, "opj_pi_next_cprl(): invalid compno0/compno1\nEV");
    }
    }
#line 629
    return (0);
  } else
#line 625
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 627
    opj_event_msg(pi->manager, 1, "opj_pi_next_cprl(): invalid compno0/compno1\nEV");
    }
    }
#line 629
    return (0);
  }
#line 632
  if (! pi->first) {
#line 633
    comp = pi->comps + pi->compno;
#line 634
    goto LABEL_SKIP;
  } else {
#line 636
    pi->first = 0;
  }
#line 639
  pi->compno = pi->poc.compno0;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (pi->compno < pi->poc.compno1)) {
#line 639
      goto while_break;
    }
#line 641
    comp = pi->comps + pi->compno;
#line 642
    pi->dx = (OPJ_UINT32 )0;
#line 643
    pi->dy = (OPJ_UINT32 )0;
#line 644
    resno = (OPJ_UINT32 )0;
    {
#line 644
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 644
      if (! (resno < comp->numresolutions)) {
#line 644
        goto while_break___0;
      }
#line 646
      res = comp->resolutions + resno;
#line 647
      if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 647
        if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 649
          dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 650
          if (! pi->dx) {
#line 650
            tmp = dx;
          } else {
            {
#line 650
            __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 650
            tmp = __cil_tmp8;
            }
          }
#line 650
          pi->dx = tmp;
        }
      }
#line 652
      if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 652
        if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 654
          dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 655
          if (! pi->dy) {
#line 655
            tmp___0 = dy;
          } else {
            {
#line 655
            __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 655
            tmp___0 = __cil_tmp10;
            }
          }
#line 655
          pi->dy = tmp___0;
        }
      }
#line 644
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 658
    if (pi->dx == 0U) {
#line 659
      return (0);
    } else
#line 658
    if (pi->dy == 0U) {
#line 659
      return (0);
    }
#line 661
    if (! pi->tp_on) {
#line 662
      pi->poc.ty0 = pi->ty0;
#line 663
      pi->poc.tx0 = pi->tx0;
#line 664
      pi->poc.ty1 = pi->ty1;
#line 665
      pi->poc.tx1 = pi->tx1;
    }
#line 667
    pi->y = (OPJ_UINT32 )pi->poc.ty0;
    {
#line 667
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 667
      if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 667
        goto while_break___1;
      }
#line 669
      pi->x = (OPJ_UINT32 )pi->poc.tx0;
      {
#line 669
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 669
        if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 669
          goto while_break___2;
        }
#line 671
        pi->resno = pi->poc.resno0;
        {
#line 671
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 671
          if (! (pi->resno < __cil_tmp13)) {
#line 671
            goto while_break___3;
          }
#line 678
          res = comp->resolutions + pi->resno;
#line 679
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 681
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 683
            goto while_continue___3;
          } else
#line 681
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 683
            goto while_continue___3;
          }
          {
#line 686
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 688
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 690
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 692
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 694
          rpx = res->pdx + levelno;
#line 695
          rpy = res->pdy + levelno;
          }
#line 697
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 699
            goto while_continue___3;
          } else
#line 697
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 699
            goto while_continue___3;
          }
#line 703
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 706
            goto while_continue___3;
          }
#line 708
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 711
            goto while_continue___3;
          }
#line 714
          if (res->pw == 0U) {
#line 715
            goto while_continue___3;
          } else
#line 714
          if (res->ph == 0U) {
#line 715
            goto while_continue___3;
          }
#line 718
          if (trx0 == trx1) {
#line 719
            goto while_continue___3;
          } else
#line 718
          if (try0 == try1) {
#line 719
            goto while_continue___3;
          }
          {
#line 722
          __cil_tmp29 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 722
          __cil_tmp27 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 722
          __cil_tmp28 = opj_uint_floordivpow2(__cil_tmp27, res->pdx);
#line 722
          prci = __cil_tmp28 - __cil_tmp29;
#line 725
          __cil_tmp32 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 725
          __cil_tmp30 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 725
          __cil_tmp31 = opj_uint_floordivpow2(__cil_tmp30, res->pdy);
#line 725
          prcj = __cil_tmp31 - __cil_tmp32;
#line 728
          pi->precno = (OPJ_UINT32 )(prci + prcj * res->pw);
#line 729
          pi->layno = pi->poc.layno0;
          }
          {
#line 729
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 729
            if (! (pi->layno < pi->poc.layno1)) {
#line 729
              goto while_break___4;
            }
#line 730
            index___0 = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 732
            if (index___0 >= pi->include_size) {
              {
#line 733
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 734
              return (0);
            }
#line 736
            if (! *(pi->include + index___0)) {
#line 737
              *(pi->include + index___0) = (OPJ_INT16 )1;
#line 738
              return (1);
            }
            LABEL_SKIP: ;
#line 729
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 672
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 670
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 668
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 639
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return (0);
}
}
#line 751 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                        OPJ_UINT32 p_tileno , OPJ_UINT32 *p_tx0 ,
                                        OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 , OPJ_UINT32 *p_ty1 ,
                                        OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                        OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_rx0 ;
  OPJ_UINT32 l_ry0 ;
  OPJ_UINT32 l_rx1 ;
  OPJ_UINT32 l_ry1 ;
  OPJ_UINT32 l_px0 ;
  OPJ_UINT32 l_py0 ;
  OPJ_UINT32 l_px1 ;
  OPJ_UINT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_UINT32 l_tcx0 ;
  OPJ_UINT32 l_tcy0 ;
  OPJ_UINT32 l_tcx1 ;
  OPJ_UINT32 l_tcy1 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_UINT64 l_dx ;
  OPJ_UINT64 l_dy ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 __cil_tmp52 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_UINT32 __cil_tmp54 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 766
  l_tcp = (opj_tcp_t___0 *)0;
#line 767
  l_tccp = (opj_tccp_t *)0;
#line 768
  l_img_comp = (opj_image_comp_t *)0;
#line 782
  l_tcp = p_cp->tcps + p_tileno;
#line 783
  l_img_comp = p_image->comps;
#line 784
  l_tccp = l_tcp->tccps;
#line 787
  p = p_tileno % p_cp->tw;
#line 788
  q = p_tileno / p_cp->tw;
#line 791
  l_tx0 = p_cp->tx0 + p * p_cp->tdx;
#line 793
  *p_tx0 = opj_uint_max(l_tx0, p_image->x0);
#line 794
  __cil_tmp22 = opj_uint_adds(l_tx0, p_cp->tdx);
#line 794
  __cil_tmp23 = opj_uint_min(__cil_tmp22, p_image->x1);
#line 794
  *p_tx1 = __cil_tmp23;
#line 795
  l_ty0 = p_cp->ty0 + q * p_cp->tdy;
#line 797
  *p_ty0 = opj_uint_max(l_ty0, p_image->y0);
#line 798
  __cil_tmp25 = opj_uint_adds(l_ty0, p_cp->tdy);
#line 798
  __cil_tmp26 = opj_uint_min(__cil_tmp25, p_image->y1);
#line 798
  *p_ty1 = __cil_tmp26;
#line 801
  *p_max_prec = (OPJ_UINT32 )0;
#line 802
  *p_max_res = (OPJ_UINT32 )0;
#line 805
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 806
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 808
  compno = (OPJ_UINT32 )0;
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (compno < p_image->numcomps)) {
#line 808
      goto while_break;
    }
    {
#line 818
    l_tcx0 = opj_uint_ceildiv(*p_tx0, l_img_comp->dx);
#line 819
    l_tcy0 = opj_uint_ceildiv(*p_ty0, l_img_comp->dy);
#line 820
    l_tcx1 = opj_uint_ceildiv(*p_tx1, l_img_comp->dx);
#line 821
    l_tcy1 = opj_uint_ceildiv(*p_ty1, l_img_comp->dy);
    }
#line 823
    if (l_tccp->numresolutions > *p_max_res) {
#line 824
      *p_max_res = l_tccp->numresolutions;
    }
#line 828
    resno = (OPJ_UINT32 )0;
    {
#line 828
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 828
      if (! (resno < l_tccp->numresolutions)) {
#line 828
        goto while_break___0;
      }
#line 832
      l_pdx = l_tccp->prcw[resno];
#line 833
      l_pdy = l_tccp->prch[resno];
#line 835
      l_dx = (unsigned long )l_img_comp->dx * (1UL << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 837
      l_dy = (unsigned long )l_img_comp->dy * (1UL << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 841
      if (l_dx <= 4294967295UL) {
        {
#line 842
        *p_dx_min = opj_uint_min(*p_dx_min, (OPJ_UINT32 )l_dx);
        }
      }
#line 844
      if (l_dy <= 4294967295UL) {
        {
#line 845
        *p_dy_min = opj_uint_min(*p_dy_min, (OPJ_UINT32 )l_dy);
        }
      }
      {
#line 849
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 851
      l_rx0 = opj_uint_ceildivpow2(l_tcx0, l_level_no);
#line 852
      l_ry0 = opj_uint_ceildivpow2(l_tcy0, l_level_no);
#line 853
      l_rx1 = opj_uint_ceildivpow2(l_tcx1, l_level_no);
#line 854
      l_ry1 = opj_uint_ceildivpow2(l_tcy1, l_level_no);
#line 856
      __cil_tmp57 = opj_uint_floordivpow2(l_rx0, l_pdx);
#line 856
      l_px0 = __cil_tmp57 << l_pdx;
#line 857
      __cil_tmp58 = opj_uint_floordivpow2(l_ry0, l_pdy);
#line 857
      l_py0 = __cil_tmp58 << l_pdy;
#line 858
      __cil_tmp59 = opj_uint_ceildivpow2(l_rx1, l_pdx);
#line 858
      l_px1 = __cil_tmp59 << l_pdx;
#line 860
      __cil_tmp60 = opj_uint_ceildivpow2(l_ry1, l_pdy);
#line 860
      py1 = __cil_tmp60 << l_pdy;
      }
#line 862
      if (l_rx0 == l_rx1) {
#line 862
        tmp = (unsigned int )0;
      } else {
#line 862
        tmp = (l_px1 - l_px0) >> l_pdx;
      }
#line 862
      l_pw = tmp;
#line 863
      if (l_ry0 == l_ry1) {
#line 863
        tmp___0 = (unsigned int )0;
      } else {
#line 863
        tmp___0 = (py1 - l_py0) >> l_pdy;
      }
#line 863
      l_ph = tmp___0;
#line 865
      l_product = l_pw * l_ph;
#line 868
      if (l_product > *p_max_prec) {
#line 869
        *p_max_prec = l_product;
      }
#line 828
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 872
    l_img_comp ++;
#line 873
    l_tccp ++;
#line 808
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 878 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_UINT32 *p_tx0 ,
                                            OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 ,
                                            OPJ_UINT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t___0 *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_rx0 ;
  OPJ_UINT32 l_ry0 ;
  OPJ_UINT32 l_rx1 ;
  OPJ_UINT32 l_ry1 ;
  OPJ_UINT32 l_px0 ;
  OPJ_UINT32 l_py0 ;
  OPJ_UINT32 l_px1 ;
  OPJ_UINT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_UINT32 l_tcx0 ;
  OPJ_UINT32 l_tcy0 ;
  OPJ_UINT32 l_tcx1 ;
  OPJ_UINT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 *tmp ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_UINT32 __cil_tmp49 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp54 ;
  OPJ_UINT32 *__cil_tmp55 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_UINT32 __cil_tmp65 ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  OPJ_UINT32 *__cil_tmp68 ;
  OPJ_UINT32 *__cil_tmp69 ;

  {
  {
#line 895
  tcp = (opj_tcp_t___0 *)0;
#line 896
  l_tccp = (opj_tccp_t *)0;
#line 897
  l_img_comp = (opj_image_comp_t *)0;
#line 914
  tcp = p_cp->tcps + tileno;
#line 915
  l_tccp = tcp->tccps;
#line 916
  l_img_comp = p_image->comps;
#line 919
  p = tileno % p_cp->tw;
#line 920
  q = tileno / p_cp->tw;
#line 923
  l_tx0 = p_cp->tx0 + p * p_cp->tdx;
#line 925
  *p_tx0 = opj_uint_max(l_tx0, p_image->x0);
#line 926
  __cil_tmp24 = opj_uint_adds(l_tx0, p_cp->tdx);
#line 926
  __cil_tmp25 = opj_uint_min(__cil_tmp24, p_image->x1);
#line 926
  *p_tx1 = __cil_tmp25;
#line 927
  l_ty0 = p_cp->ty0 + q * p_cp->tdy;
#line 929
  *p_ty0 = opj_uint_max(l_ty0, p_image->y0);
#line 930
  __cil_tmp27 = opj_uint_adds(l_ty0, p_cp->tdy);
#line 930
  __cil_tmp28 = opj_uint_min(__cil_tmp27, p_image->y1);
#line 930
  *p_ty1 = __cil_tmp28;
#line 933
  *p_max_prec = (OPJ_UINT32 )0;
#line 934
  *p_max_res = (OPJ_UINT32 )0;
#line 937
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 938
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 940
  compno = (OPJ_UINT32 )0;
  }
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    if (! (compno < p_image->numcomps)) {
#line 940
      goto while_break;
    }
#line 949
    if (p_resolutions) {
#line 949
      tmp = *(p_resolutions + compno);
    } else {
#line 949
      tmp = (OPJ_UINT32 *)((void *)0);
    }
    {
#line 949
    lResolutionPtr = tmp;
#line 951
    l_tcx0 = opj_uint_ceildiv(*p_tx0, l_img_comp->dx);
#line 952
    l_tcy0 = opj_uint_ceildiv(*p_ty0, l_img_comp->dy);
#line 953
    l_tcx1 = opj_uint_ceildiv(*p_tx1, l_img_comp->dx);
#line 954
    l_tcy1 = opj_uint_ceildiv(*p_ty1, l_img_comp->dy);
    }
#line 956
    if (l_tccp->numresolutions > *p_max_res) {
#line 957
      *p_max_res = l_tccp->numresolutions;
    }
#line 961
    l_level_no = l_tccp->numresolutions;
#line 962
    resno = (OPJ_UINT32 )0;
    {
#line 962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 962
      if (! (resno < l_tccp->numresolutions)) {
#line 962
        goto while_break___0;
      }
#line 965
      l_level_no --;
#line 968
      l_pdx = l_tccp->prcw[resno];
#line 969
      l_pdy = l_tccp->prch[resno];
#line 970
      if (lResolutionPtr) {
#line 971
        __cil_tmp54 = lResolutionPtr;
#line 971
        lResolutionPtr ++;
#line 971
        *__cil_tmp54 = l_pdx;
#line 972
        __cil_tmp55 = lResolutionPtr;
#line 972
        lResolutionPtr ++;
#line 972
        *__cil_tmp55 = l_pdy;
      }
#line 974
      if (l_pdx + l_level_no < 32U) {
#line 974
        if (l_img_comp->dx <= 4294967295U / (1U << (l_pdx + l_level_no))) {
          {
#line 976
          l_dx = l_img_comp->dx * (1U << (l_pdx + l_level_no));
#line 978
          *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
          }
        }
      }
#line 980
      if (l_pdy + l_level_no < 32U) {
#line 980
        if (l_img_comp->dy <= 4294967295U / (1U << (l_pdy + l_level_no))) {
          {
#line 982
          l_dy = l_img_comp->dy * (1U << (l_pdy + l_level_no));
#line 983
          *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
          }
        }
      }
      {
#line 987
      l_rx0 = opj_uint_ceildivpow2(l_tcx0, l_level_no);
#line 988
      l_ry0 = opj_uint_ceildivpow2(l_tcy0, l_level_no);
#line 989
      l_rx1 = opj_uint_ceildivpow2(l_tcx1, l_level_no);
#line 990
      l_ry1 = opj_uint_ceildivpow2(l_tcy1, l_level_no);
#line 991
      __cil_tmp62 = opj_uint_floordivpow2(l_rx0, l_pdx);
#line 991
      l_px0 = __cil_tmp62 << l_pdx;
#line 992
      __cil_tmp63 = opj_uint_floordivpow2(l_ry0, l_pdy);
#line 992
      l_py0 = __cil_tmp63 << l_pdy;
#line 993
      __cil_tmp64 = opj_uint_ceildivpow2(l_rx1, l_pdx);
#line 993
      l_px1 = __cil_tmp64 << l_pdx;
#line 994
      __cil_tmp65 = opj_uint_ceildivpow2(l_ry1, l_pdy);
#line 994
      py1 = __cil_tmp65 << l_pdy;
      }
#line 995
      if (l_rx0 == l_rx1) {
#line 995
        tmp___0 = (unsigned int )0;
      } else {
#line 995
        tmp___0 = (l_px1 - l_px0) >> l_pdx;
      }
#line 995
      l_pw = tmp___0;
#line 996
      if (l_ry0 == l_ry1) {
#line 996
        tmp___1 = (unsigned int )0;
      } else {
#line 996
        tmp___1 = (py1 - l_py0) >> l_pdy;
      }
#line 996
      l_ph = tmp___1;
#line 997
      if (lResolutionPtr) {
#line 998
        __cil_tmp68 = lResolutionPtr;
#line 998
        lResolutionPtr ++;
#line 998
        *__cil_tmp68 = l_pw;
#line 999
        __cil_tmp69 = lResolutionPtr;
#line 999
        lResolutionPtr ++;
#line 999
        *__cil_tmp69 = l_ph;
      }
#line 1001
      l_product = l_pw * l_ph;
#line 1004
      if (l_product > *p_max_prec) {
#line 1005
        *p_max_prec = l_product;
      }
#line 962
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1009
    l_tccp ++;
#line 1010
    l_img_comp ++;
#line 940
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1014 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static opj_pi_iterator_t___0 *opj_pi_create(opj_image_t *image , opj_cp_t___0 *cp ,
                                            OPJ_UINT32 tileno , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp15 ;

  {
  {
#line 1025
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1026
  tcp = (opj_tcp_t___0 *)0;
#line 1027
  tccp = (opj_tccp_t *)0;
#line 1030
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1038
  tcp = cp->tcps + tileno;
#line 1039
  l_poc_bound = tcp->numpocs + 1U;
#line 1042
  __cil_tmp12 = opj_calloc((size_t )l_poc_bound, sizeof(opj_pi_iterator_t___0 ));
#line 1042
  l_pi = (opj_pi_iterator_t___0 *)__cil_tmp12;
  }
#line 1044
  if (! l_pi) {
#line 1045
    return ((opj_pi_iterator_t___0 *)((void *)0));
  }
#line 1048
  l_current_pi = l_pi;
#line 1049
  pino = (OPJ_UINT32 )0;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1049
    if (! (pino < l_poc_bound)) {
#line 1049
      goto while_break;
    }
    {
#line 1051
    l_current_pi->manager = manager;
#line 1053
    __cil_tmp13 = opj_calloc((size_t )image->numcomps, sizeof(opj_pi_comp_t ));
#line 1053
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp13;
    }
#line 1055
    if (! l_current_pi->comps) {
      {
#line 1056
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 1057
      return ((opj_pi_iterator_t___0 *)((void *)0));
    }
#line 1060
    l_current_pi->numcomps = image->numcomps;
#line 1062
    compno = (OPJ_UINT32 )0;
    {
#line 1062
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1062
      if (! (compno < image->numcomps)) {
#line 1062
        goto while_break___0;
      }
      {
#line 1063
      comp = l_current_pi->comps + compno;
#line 1065
      tccp = tcp->tccps + compno;
#line 1067
      __cil_tmp15 = opj_calloc((size_t )tccp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 1067
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp15;
      }
#line 1069
      if (! comp->resolutions) {
        {
#line 1070
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 1071
        return ((opj_pi_iterator_t___0 *)0);
      }
#line 1074
      comp->numresolutions = tccp->numresolutions;
#line 1062
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1076
    l_current_pi ++;
#line 1049
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  return (l_pi);
}
}
#line 1081 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_poc_and_final(opj_cp_t___0 *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_UINT32 p_tx0 , OPJ_UINT32 p_tx1 ,
                                               OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t___0 *l_tcp ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  OPJ_UINT32 tmp ;

  {
#line 1095
  l_tcp = (opj_tcp_t___0 *)0;
#line 1097
  l_current_poc = (opj_poc_t___0 *)0;
#line 1109
  l_tcp = p_cp->tcps + p_tileno;
#line 1111
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1115
  l_current_poc = (opj_poc_t___0 *)l_tcp->pocs;
#line 1117
  l_current_poc->compS = l_current_poc->compno0;
#line 1118
  l_current_poc->compE = l_current_poc->compno1;
#line 1119
  l_current_poc->resS = l_current_poc->resno0;
#line 1120
  l_current_poc->resE = l_current_poc->resno1;
#line 1121
  l_current_poc->layE = l_current_poc->layno1;
#line 1124
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 1125
  l_current_poc->prg = l_current_poc->prg1;
#line 1126
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1128
  l_current_poc->prcE = p_max_prec;
#line 1129
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1130
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1131
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1132
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1133
  l_current_poc->dx = p_dx_min;
#line 1134
  l_current_poc->dy = p_dy_min;
#line 1136
  l_current_poc ++;
#line 1137
  pino = (OPJ_UINT32 )1;
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! (pino < l_poc_bound)) {
#line 1137
      goto while_break;
    }
#line 1138
    l_current_poc->compS = l_current_poc->compno0;
#line 1139
    l_current_poc->compE = l_current_poc->compno1;
#line 1140
    l_current_poc->resS = l_current_poc->resno0;
#line 1141
    l_current_poc->resE = l_current_poc->resno1;
#line 1142
    l_current_poc->layE = l_current_poc->layno1;
#line 1143
    l_current_poc->prg = l_current_poc->prg1;
#line 1144
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1146
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 1146
      tmp = l_current_poc->layE;
    } else {
#line 1146
      tmp = (unsigned int )0;
    }
#line 1146
    l_current_poc->layS = tmp;
#line 1149
    l_current_poc->prcE = p_max_prec;
#line 1150
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1151
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1152
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1153
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1154
    l_current_poc->dx = p_dx_min;
#line 1155
    l_current_poc->dy = p_dy_min;
#line 1156
    l_current_poc ++;
#line 1137
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_not_poc(opj_cp_t___0 *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_UINT32 p_tx0 ,
                                         OPJ_UINT32 p_tx1 , OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                         OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                         OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t___0 *l_tcp ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;

  {
#line 1175
  l_tcp = (opj_tcp_t___0 *)0;
#line 1177
  l_current_poc = (opj_poc_t___0 *)0;
#line 1186
  l_tcp = p_cp->tcps + p_tileno;
#line 1189
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1193
  l_current_poc = (opj_poc_t___0 *)l_tcp->pocs;
#line 1195
  pino = (OPJ_UINT32 )0;
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1195
    if (! (pino < l_poc_bound)) {
#line 1195
      goto while_break;
    }
#line 1196
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 1197
    l_current_poc->compE = p_num_comps;
#line 1198
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 1199
    l_current_poc->resE = p_max_res;
#line 1200
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 1201
    l_current_poc->layE = l_tcp->numlayers;
#line 1202
    l_current_poc->prg = l_tcp->prg;
#line 1203
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1204
    l_current_poc->prcE = p_max_prec;
#line 1205
    l_current_poc->txS = p_tx0;
#line 1206
    l_current_poc->txE = p_tx1;
#line 1207
    l_current_poc->tyS = p_ty0;
#line 1208
    l_current_poc->tyE = p_ty1;
#line 1209
    l_current_poc->dx = p_dx_min;
#line 1210
    l_current_poc->dy = p_dy_min;
#line 1211
    l_current_poc ++;
#line 1195
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1215 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t___0 *l_current_pi ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 1226
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1227
  l_current_poc = (opj_poc_t___0 *)0;
#line 1236
  l_bound = p_tcp->numpocs + 1U;
#line 1237
  l_current_pi = p_pi;
#line 1238
  l_current_poc = (opj_poc_t___0 *)p_tcp->pocs;
#line 1240
  pino = (OPJ_UINT32 )0;
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    if (! (pino < l_bound)) {
#line 1240
      goto while_break;
    }
    {
#line 1241
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1242
    l_current_pi->first = 1;
#line 1244
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1246
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1248
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1249
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1250
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1252
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1254
    l_current_pi->poc.layno1 = opj_uint_min(l_current_poc->layno1, p_tcp->numlayers);
#line 1256
    l_current_pi->poc.precno1 = p_max_precision;
#line 1257
    l_current_pi ++;
#line 1258
    l_current_poc ++;
    }
#line 1240
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1262 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t___0 *l_current_pi ;

  {
#line 1273
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1279
  l_bound = p_tcp->numpocs + 1U;
#line 1280
  l_current_pi = p_pi;
#line 1282
  pino = (OPJ_UINT32 )0;
  {
#line 1282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1282
    if (! (pino < l_bound)) {
#line 1282
      goto while_break;
    }
#line 1283
    l_current_pi->poc.prg = p_tcp->prg;
#line 1284
    l_current_pi->first = 1;
#line 1285
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1286
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1287
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1288
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1289
    l_current_pi->poc.resno1 = p_max_res;
#line 1290
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1291
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1292
    l_current_pi->poc.precno1 = p_max_precision;
#line 1293
    l_current_pi ++;
#line 1282
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1299 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t___0 *tcps ;
  opj_poc_t___0 *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1306
  tcps = cp->tcps + tileno;
#line 1307
  tcp = & tcps->pocs[pino];
#line 1309
  if (pos >= 0) {
#line 1310
    i = pos;
    {
#line 1310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1310
      if (! (i >= 0)) {
#line 1310
        goto while_break;
      }
      {
#line 1312
      if ((int )*(prog + i) == 'R') {
#line 1312
        goto case_82;
      }
#line 1323
      if ((int )*(prog + i) == 'C') {
#line 1323
        goto case_67;
      }
#line 1334
      if ((int )*(prog + i) == 'L') {
#line 1334
        goto case_76;
      }
#line 1345
      if ((int )*(prog + i) == 'P') {
#line 1345
        goto case_80;
      }
#line 1348
      if ((int )*(prog + i) == 1) {
#line 1348
        goto case_1;
      }
#line 1348
      if ((int )*(prog + i) == 0) {
#line 1348
        goto case_1;
      }
#line 1359
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1313
      if (tcp->res_t == tcp->resE) {
        {
#line 1314
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1314
        if (__cil_tmp9) {
#line 1315
          return (1);
        } else {
#line 1317
          return (0);
        }
      } else {
#line 1320
        return (1);
      }
#line 1322
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1324
      if (tcp->comp_t == tcp->compE) {
        {
#line 1325
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1325
        if (__cil_tmp10) {
#line 1326
          return (1);
        } else {
#line 1328
          return (0);
        }
      } else {
#line 1331
        return (1);
      }
#line 1333
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1335
      if (tcp->lay_t == tcp->layE) {
        {
#line 1336
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1336
        if (__cil_tmp11) {
#line 1337
          return (1);
        } else {
#line 1339
          return (0);
        }
      } else {
#line 1342
        return (1);
      }
#line 1344
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1348
      if ((int )tcp->prg == 1) {
#line 1348
        goto case_1;
      }
#line 1348
      if ((int )tcp->prg == 0) {
#line 1348
        goto case_1;
      }
#line 1359
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1349
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1350
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1350
        if (__cil_tmp12) {
#line 1351
          return (1);
        } else {
#line 1353
          return (0);
        }
      } else {
#line 1356
        return (1);
      }
#line 1358
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1360
      if (tcp->tx0_t == tcp->txE) {
#line 1362
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1363
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1363
          if (__cil_tmp13) {
#line 1364
            return (1);
          } else {
#line 1366
            return (0);
          }
        } else {
#line 1369
          return (1);
        }
      } else {
#line 1372
        return (1);
      }
#line 1374
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 1310
      __cil_tmp14 = i;
#line 1310
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1379
  return (0);
}
}
#line 1388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
opj_pi_iterator_t___0 *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 p_tile_no , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  opj_pi_iterator_t___0 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp37 ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp43 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;

  {
  {
#line 1393
  numcomps = p_image->numcomps;
#line 1413
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1414
  l_tcp = (opj_tcp_t___0 *)0;
#line 1415
  l_tccp = (opj_tccp_t *)0;
#line 1416
  l_current_comp = (opj_pi_comp_t *)0;
#line 1417
  l_img_comp = (opj_image_comp_t *)0;
#line 1418
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1419
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1427
  l_tcp = p_cp->tcps + p_tile_no;
#line 1428
  l_bound = l_tcp->numpocs + 1U;
#line 1430
  l_data_stride = (OPJ_UINT32 )132;
#line 1431
  __cil_tmp32 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1431
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp32;
  }
#line 1433
  if (! l_tmp_data) {
#line 1435
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1437
  __cil_tmp33 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1437
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp33;
  }
#line 1439
  if (! l_tmp_ptr) {
    {
#line 1441
    opj_free(l_tmp_data);
    }
#line 1442
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1446
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no, manager);
  }
#line 1447
  if (! l_pi) {
    {
#line 1448
    opj_free(l_tmp_data);
#line 1449
    opj_free(l_tmp_ptr);
    }
#line 1450
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1453
  l_encoding_value_ptr = l_tmp_data;
#line 1456
  compno = (OPJ_UINT32 )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (compno < numcomps)) {
#line 1455
      goto while_break;
    }
#line 1457
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1458
    l_encoding_value_ptr += l_data_stride;
#line 1456
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1461
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1465
  l_step_p = (OPJ_UINT32 )1;
#line 1466
  l_step_c = l_max_prec * l_step_p;
#line 1467
  l_step_r = numcomps * l_step_c;
#line 1468
  l_step_l = l_max_res * l_step_r;
#line 1471
  l_current_pi = l_pi;
#line 1476
  l_current_pi->include = (OPJ_INT16 *)0;
  }
#line 1477
  if (l_step_l <= 4294967295U / (l_tcp->numlayers + 1U)) {
    {
#line 1478
    l_current_pi->include_size = (l_tcp->numlayers + 1U) * l_step_l;
#line 1479
    __cil_tmp35 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1479
    l_current_pi->include = (OPJ_INT16 *)__cil_tmp35;
    }
  }
#line 1483
  if (! l_current_pi->include) {
    {
#line 1484
    opj_free(l_tmp_data);
#line 1485
    opj_free(l_tmp_ptr);
#line 1486
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1487
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1491
  l_current_comp = l_current_pi->comps;
#line 1492
  l_img_comp = p_image->comps;
#line 1493
  l_tccp = l_tcp->tccps;
#line 1495
  l_current_pi->tx0 = l_tx0;
#line 1496
  l_current_pi->ty0 = l_ty0;
#line 1497
  l_current_pi->tx1 = l_tx1;
#line 1498
  l_current_pi->ty1 = l_ty1;
#line 1503
  l_current_pi->step_p = l_step_p;
#line 1504
  l_current_pi->step_c = l_step_c;
#line 1505
  l_current_pi->step_r = l_step_r;
#line 1506
  l_current_pi->step_l = l_step_l;
#line 1510
  compno = (OPJ_UINT32 )0;
  {
#line 1509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1509
    if (! (compno < numcomps)) {
#line 1509
      goto while_break___0;
    }
#line 1511
    l_res = l_current_comp->resolutions;
#line 1512
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1514
    l_current_comp->dx = l_img_comp->dx;
#line 1515
    l_current_comp->dy = l_img_comp->dy;
#line 1518
    resno = (OPJ_UINT32 )0;
    {
#line 1517
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1517
      if (! (resno < l_current_comp->numresolutions)) {
#line 1517
        goto while_break___1;
      }
#line 1519
      __cil_tmp37 = l_encoding_value_ptr;
#line 1519
      l_encoding_value_ptr ++;
#line 1519
      l_res->pdx = *__cil_tmp37;
#line 1520
      __cil_tmp38 = l_encoding_value_ptr;
#line 1520
      l_encoding_value_ptr ++;
#line 1520
      l_res->pdy = *__cil_tmp38;
#line 1521
      __cil_tmp39 = l_encoding_value_ptr;
#line 1521
      l_encoding_value_ptr ++;
#line 1521
      l_res->pw = *__cil_tmp39;
#line 1522
      __cil_tmp40 = l_encoding_value_ptr;
#line 1522
      l_encoding_value_ptr ++;
#line 1522
      l_res->ph = *__cil_tmp40;
#line 1523
      l_res ++;
#line 1518
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1525
    l_current_comp ++;
#line 1526
    l_img_comp ++;
#line 1527
    l_tccp ++;
#line 1510
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1529
  l_current_pi ++;
#line 1531
  pino = (OPJ_UINT32 )1;
  {
#line 1531
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1531
    if (! (pino < l_bound)) {
#line 1531
      goto while_break___2;
    }
#line 1532
    l_current_comp = l_current_pi->comps;
#line 1533
    l_img_comp = p_image->comps;
#line 1534
    l_tccp = l_tcp->tccps;
#line 1536
    l_current_pi->tx0 = l_tx0;
#line 1537
    l_current_pi->ty0 = l_ty0;
#line 1538
    l_current_pi->tx1 = l_tx1;
#line 1539
    l_current_pi->ty1 = l_ty1;
#line 1542
    l_current_pi->step_p = l_step_p;
#line 1543
    l_current_pi->step_c = l_step_c;
#line 1544
    l_current_pi->step_r = l_step_r;
#line 1545
    l_current_pi->step_l = l_step_l;
#line 1549
    compno = (OPJ_UINT32 )0;
    {
#line 1548
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1548
      if (! (compno < numcomps)) {
#line 1548
        goto while_break___3;
      }
#line 1550
      l_res___0 = l_current_comp->resolutions;
#line 1551
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1553
      l_current_comp->dx = l_img_comp->dx;
#line 1554
      l_current_comp->dy = l_img_comp->dy;
#line 1557
      resno = (OPJ_UINT32 )0;
      {
#line 1556
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1556
        if (! (resno < l_current_comp->numresolutions)) {
#line 1556
          goto while_break___4;
        }
#line 1558
        __cil_tmp43 = l_encoding_value_ptr;
#line 1558
        l_encoding_value_ptr ++;
#line 1558
        l_res___0->pdx = *__cil_tmp43;
#line 1559
        __cil_tmp44 = l_encoding_value_ptr;
#line 1559
        l_encoding_value_ptr ++;
#line 1559
        l_res___0->pdy = *__cil_tmp44;
#line 1560
        __cil_tmp45 = l_encoding_value_ptr;
#line 1560
        l_encoding_value_ptr ++;
#line 1560
        l_res___0->pw = *__cil_tmp45;
#line 1561
        __cil_tmp46 = l_encoding_value_ptr;
#line 1561
        l_encoding_value_ptr ++;
#line 1561
        l_res___0->ph = *__cil_tmp46;
#line 1562
        l_res___0 ++;
#line 1557
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1564
      l_current_comp ++;
#line 1565
      l_img_comp ++;
#line 1566
      l_tccp ++;
#line 1549
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1569
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1570
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1571
    l_current_pi ++;
#line 1531
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1573
  opj_free(l_tmp_data);
#line 1574
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1575
  opj_free(l_tmp_ptr);
#line 1576
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1577
  if (l_tcp->POC) {
    {
#line 1579
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1581
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1583
  return (l_pi);
}
}
#line 1587 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
OPJ_UINT32 opj_get_encoding_packet_count(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                         OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;

  {
  {
#line 1602
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  (OPJ_UINT32 **)((void *)0));
  }
#line 1605
  return ((((p_cp->tcps + p_tile_no)->numlayers * l_max_prec) * p_image->numcomps) * l_max_res);
}
}
#line 1610 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
opj_pi_iterator_t___0 *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                                OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ,
                                                opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  opj_pi_iterator_t___0 *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;

  {
  {
#line 1616
  numcomps = p_image->numcomps;
#line 1636
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1637
  l_tcp = (opj_tcp_t___0 *)0;
#line 1638
  l_tccp = (opj_tccp_t *)0;
#line 1639
  l_current_comp = (opj_pi_comp_t *)0;
#line 1640
  l_img_comp = (opj_image_comp_t *)0;
#line 1641
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1642
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1650
  l_tcp = p_cp->tcps + p_tile_no;
#line 1651
  l_bound = l_tcp->numpocs + 1U;
#line 1653
  l_data_stride = (OPJ_UINT32 )132;
#line 1654
  __cil_tmp33 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1654
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp33;
  }
#line 1656
  if (! l_tmp_data) {
#line 1657
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1660
  __cil_tmp34 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1660
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp34;
  }
#line 1662
  if (! l_tmp_ptr) {
    {
#line 1663
    opj_free(l_tmp_data);
    }
#line 1664
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1668
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no, manager);
  }
#line 1669
  if (! l_pi) {
    {
#line 1670
    opj_free(l_tmp_data);
#line 1671
    opj_free(l_tmp_ptr);
    }
#line 1672
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1675
  l_encoding_value_ptr = l_tmp_data;
#line 1677
  compno = (OPJ_UINT32 )0;
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    if (! (compno < numcomps)) {
#line 1677
      goto while_break;
    }
#line 1678
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1679
    l_encoding_value_ptr += l_data_stride;
#line 1677
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1683
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1687
  l_step_p = (OPJ_UINT32 )1;
#line 1688
  l_step_c = l_max_prec * l_step_p;
#line 1689
  l_step_r = numcomps * l_step_c;
#line 1690
  l_step_l = l_max_res * l_step_r;
#line 1693
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1694
  l_current_pi = l_pi;
#line 1697
  l_current_pi->include_size = l_tcp->numlayers * l_step_l;
#line 1698
  __cil_tmp36 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1698
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp36;
  }
#line 1700
  if (! l_current_pi->include) {
    {
#line 1701
    opj_free(l_tmp_data);
#line 1702
    opj_free(l_tmp_ptr);
#line 1703
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1704
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1708
  l_current_comp = l_current_pi->comps;
#line 1709
  l_img_comp = p_image->comps;
#line 1710
  l_tccp = l_tcp->tccps;
#line 1711
  l_current_pi->tx0 = l_tx0;
#line 1712
  l_current_pi->ty0 = l_ty0;
#line 1713
  l_current_pi->tx1 = l_tx1;
#line 1714
  l_current_pi->ty1 = l_ty1;
#line 1715
  l_current_pi->dx = l_dx_min;
#line 1716
  l_current_pi->dy = l_dy_min;
#line 1717
  l_current_pi->step_p = l_step_p;
#line 1718
  l_current_pi->step_c = l_step_c;
#line 1719
  l_current_pi->step_r = l_step_r;
#line 1720
  l_current_pi->step_l = l_step_l;
#line 1723
  compno = (OPJ_UINT32 )0;
  {
#line 1723
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1723
    if (! (compno < numcomps)) {
#line 1723
      goto while_break___0;
    }
#line 1724
    l_res = l_current_comp->resolutions;
#line 1725
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1727
    l_current_comp->dx = l_img_comp->dx;
#line 1728
    l_current_comp->dy = l_img_comp->dy;
#line 1731
    resno = (OPJ_UINT32 )0;
    {
#line 1731
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1731
      if (! (resno < l_current_comp->numresolutions)) {
#line 1731
        goto while_break___1;
      }
#line 1732
      __cil_tmp38 = l_encoding_value_ptr;
#line 1732
      l_encoding_value_ptr ++;
#line 1732
      l_res->pdx = *__cil_tmp38;
#line 1733
      __cil_tmp39 = l_encoding_value_ptr;
#line 1733
      l_encoding_value_ptr ++;
#line 1733
      l_res->pdy = *__cil_tmp39;
#line 1734
      __cil_tmp40 = l_encoding_value_ptr;
#line 1734
      l_encoding_value_ptr ++;
#line 1734
      l_res->pw = *__cil_tmp40;
#line 1735
      __cil_tmp41 = l_encoding_value_ptr;
#line 1735
      l_encoding_value_ptr ++;
#line 1735
      l_res->ph = *__cil_tmp41;
#line 1736
      l_res ++;
#line 1731
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1739
    l_current_comp ++;
#line 1740
    l_img_comp ++;
#line 1741
    l_tccp ++;
#line 1723
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1743
  l_current_pi ++;
#line 1745
  pino = (OPJ_UINT32 )1;
  {
#line 1745
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1745
    if (! (pino < l_bound)) {
#line 1745
      goto while_break___2;
    }
#line 1746
    l_current_comp = l_current_pi->comps;
#line 1747
    l_img_comp = p_image->comps;
#line 1748
    l_tccp = l_tcp->tccps;
#line 1750
    l_current_pi->tx0 = l_tx0;
#line 1751
    l_current_pi->ty0 = l_ty0;
#line 1752
    l_current_pi->tx1 = l_tx1;
#line 1753
    l_current_pi->ty1 = l_ty1;
#line 1754
    l_current_pi->dx = l_dx_min;
#line 1755
    l_current_pi->dy = l_dy_min;
#line 1756
    l_current_pi->step_p = l_step_p;
#line 1757
    l_current_pi->step_c = l_step_c;
#line 1758
    l_current_pi->step_r = l_step_r;
#line 1759
    l_current_pi->step_l = l_step_l;
#line 1762
    compno = (OPJ_UINT32 )0;
    {
#line 1762
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1762
      if (! (compno < numcomps)) {
#line 1762
        goto while_break___3;
      }
#line 1763
      l_res___0 = l_current_comp->resolutions;
#line 1764
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1766
      l_current_comp->dx = l_img_comp->dx;
#line 1767
      l_current_comp->dy = l_img_comp->dy;
#line 1769
      resno = (OPJ_UINT32 )0;
      {
#line 1769
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1769
        if (! (resno < l_current_comp->numresolutions)) {
#line 1769
          goto while_break___4;
        }
#line 1770
        __cil_tmp44 = l_encoding_value_ptr;
#line 1770
        l_encoding_value_ptr ++;
#line 1770
        l_res___0->pdx = *__cil_tmp44;
#line 1771
        __cil_tmp45 = l_encoding_value_ptr;
#line 1771
        l_encoding_value_ptr ++;
#line 1771
        l_res___0->pdy = *__cil_tmp45;
#line 1772
        __cil_tmp46 = l_encoding_value_ptr;
#line 1772
        l_encoding_value_ptr ++;
#line 1772
        l_res___0->pw = *__cil_tmp46;
#line 1773
        __cil_tmp47 = l_encoding_value_ptr;
#line 1773
        l_encoding_value_ptr ++;
#line 1773
        l_res___0->ph = *__cil_tmp47;
#line 1774
        l_res___0 ++;
#line 1769
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1776
      l_current_comp ++;
#line 1777
      l_img_comp ++;
#line 1778
      l_tccp ++;
#line 1762
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1782
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1783
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1784
    l_current_pi ++;
#line 1745
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1787
  opj_free(l_tmp_data);
#line 1788
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1789
  opj_free(l_tmp_ptr);
#line 1790
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1792
  if ((int )l_tcp->POC) {
#line 1792
    if ((int )p_cp->rsiz >= 3) {
#line 1792
      if ((int )p_cp->rsiz <= 6) {
        {
        {
#line 1793
        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);
        }
        }
      } else {
#line 1792
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1792
    if ((unsigned int )p_t2_mode == 1U) {
      {
      {
#line 1793
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
      }
    } else {
      {
      {
#line 1796
      opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0,
                                   l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
      }
    }
  } else {
    {
    {
#line 1796
    opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                 l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
    }
  }
#line 1800
  return (l_pi);
}
}
#line 1803 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t___0 *pi , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t___0 *tcps ;
  opj_poc_t___0 *tcp ;
  char const   *__cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;

  {
#line 1813
  incr_top = (OPJ_UINT32 )1;
  {
#line 1813
  resetX = (OPJ_UINT32 )0;
#line 1814
  tcps = cp->tcps + tileno;
#line 1815
  tcp = & tcps->pocs[pino];
#line 1817
  prog = (OPJ_CHAR *)opj_j2k_convert_progression_order(tcp->prg);
#line 1819
  (pi + pino)->first = 1;
#line 1820
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1822
  if (! ((int )cp->m_specific_param.m_enc.m_tp_on && ((((! ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6) && ! ((int )cp->rsiz >= 1024 && (int )cp->rsiz <= 2459)) && (unsigned int )t2_mode == 1U) || ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6)) || ((int )cp->rsiz >= 1024 && (int )cp->rsiz <= 2459)))) {
#line 1825
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1826
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1827
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1828
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1829
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1830
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1831
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1832
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1833
    (pi + pino)->poc.tx0 = tcp->txS;
#line 1834
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 1835
    (pi + pino)->poc.tx1 = tcp->txE;
#line 1836
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else {
#line 1838
    i = tppos + 1;
    {
#line 1838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1838
      if (! (i < 4)) {
#line 1838
        goto while_break;
      }
      {
#line 1840
      if ((int )*(prog + i) == 'R') {
#line 1840
        goto case_82;
      }
#line 1844
      if ((int )*(prog + i) == 'C') {
#line 1844
        goto case_67;
      }
#line 1848
      if ((int )*(prog + i) == 'L') {
#line 1848
        goto case_76;
      }
#line 1852
      if ((int )*(prog + i) == 'P') {
#line 1852
        goto case_80;
      }
#line 1855
      if ((int )*(prog + i) == 1) {
#line 1855
        goto case_1;
      }
#line 1855
      if ((int )*(prog + i) == 0) {
#line 1855
        goto case_1;
      }
#line 1859
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1841
      (pi + pino)->poc.resno0 = tcp->resS;
#line 1842
      (pi + pino)->poc.resno1 = tcp->resE;
#line 1843
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1845
      (pi + pino)->poc.compno0 = tcp->compS;
#line 1846
      (pi + pino)->poc.compno1 = tcp->compE;
#line 1847
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1849
      (pi + pino)->poc.layno0 = tcp->layS;
#line 1850
      (pi + pino)->poc.layno1 = tcp->layE;
#line 1851
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1855
      if ((int )tcp->prg == 1) {
#line 1855
        goto case_1;
      }
#line 1855
      if ((int )tcp->prg == 0) {
#line 1855
        goto case_1;
      }
#line 1859
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1856
      (pi + pino)->poc.precno0 = tcp->prcS;
#line 1857
      (pi + pino)->poc.precno1 = tcp->prcE;
#line 1858
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1860
      (pi + pino)->poc.tx0 = tcp->txS;
#line 1861
      (pi + pino)->poc.ty0 = tcp->tyS;
#line 1862
      (pi + pino)->poc.tx1 = tcp->txE;
#line 1863
      (pi + pino)->poc.ty1 = tcp->tyE;
#line 1864
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1866
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1838
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1870
    if (tpnum == 0U) {
#line 1871
      i = tppos;
      {
#line 1871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1871
        if (! (i >= 0)) {
#line 1871
          goto while_break___0;
        }
        {
#line 1873
        if ((int )*(prog + i) == 'C') {
#line 1873
          goto case_67___0;
        }
#line 1879
        if ((int )*(prog + i) == 'R') {
#line 1879
          goto case_82___0;
        }
#line 1885
        if ((int )*(prog + i) == 'L') {
#line 1885
          goto case_76___0;
        }
#line 1891
        if ((int )*(prog + i) == 'P') {
#line 1891
          goto case_80___0;
        }
#line 1894
        if ((int )*(prog + i) == 1) {
#line 1894
          goto case_1___0;
        }
#line 1894
        if ((int )*(prog + i) == 0) {
#line 1894
          goto case_1___0;
        }
#line 1900
        goto switch_default___0;
        case_67___0: /* CIL Label */ 
#line 1874
        tcp->comp_t = tcp->compS;
#line 1875
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1876
        (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1877
        tcp->comp_t += (unsigned int )1;
#line 1878
        goto switch_break___1;
        case_82___0: /* CIL Label */ 
#line 1880
        tcp->res_t = tcp->resS;
#line 1881
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 1882
        (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1883
        tcp->res_t += (unsigned int )1;
#line 1884
        goto switch_break___1;
        case_76___0: /* CIL Label */ 
#line 1886
        tcp->lay_t = tcp->layS;
#line 1887
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1888
        (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1889
        tcp->lay_t += (unsigned int )1;
#line 1890
        goto switch_break___1;
        case_80___0: /* CIL Label */ 
        {
#line 1894
        if ((int )tcp->prg == 1) {
#line 1894
          goto case_1___0;
        }
#line 1894
        if ((int )tcp->prg == 0) {
#line 1894
          goto case_1___0;
        }
#line 1900
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 1895
        tcp->prc_t = tcp->prcS;
#line 1896
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1897
        (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1898
        tcp->prc_t += (unsigned int )1;
#line 1899
        goto switch_break___2;
        switch_default___0: /* CIL Label */ 
#line 1901
        tcp->tx0_t = tcp->txS;
#line 1902
        tcp->ty0_t = tcp->tyS;
#line 1903
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 1904
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 1905
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 1906
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 1907
        tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1908
        tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1909
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 1911
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1871
        __cil_tmp16 = i;
#line 1871
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1914
      incr_top = (OPJ_UINT32 )1;
    } else {
#line 1916
      i = tppos;
      {
#line 1916
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1916
        if (! (i >= 0)) {
#line 1916
          goto while_break___1;
        }
        {
#line 1918
        if ((int )*(prog + i) == 'C') {
#line 1918
          goto case_67___1;
        }
#line 1922
        if ((int )*(prog + i) == 'R') {
#line 1922
          goto case_82___1;
        }
#line 1926
        if ((int )*(prog + i) == 'L') {
#line 1926
          goto case_76___1;
        }
#line 1930
        if ((int )*(prog + i) == 'P') {
#line 1930
          goto case_80___1;
        }
#line 1933
        if ((int )*(prog + i) == 1) {
#line 1933
          goto case_1___1;
        }
#line 1933
        if ((int )*(prog + i) == 0) {
#line 1933
          goto case_1___1;
        }
#line 1937
        goto switch_default___1;
        case_67___1: /* CIL Label */ 
#line 1919
        (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1920
        (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1921
        goto switch_break___3;
        case_82___1: /* CIL Label */ 
#line 1923
        (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1924
        (pi + pino)->poc.resno1 = tcp->res_t;
#line 1925
        goto switch_break___3;
        case_76___1: /* CIL Label */ 
#line 1927
        (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1928
        (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1929
        goto switch_break___3;
        case_80___1: /* CIL Label */ 
        {
#line 1933
        if ((int )tcp->prg == 1) {
#line 1933
          goto case_1___1;
        }
#line 1933
        if ((int )tcp->prg == 0) {
#line 1933
          goto case_1___1;
        }
#line 1937
        goto switch_default___1;
        case_1___1: /* CIL Label */ 
        case_0___1: /* CIL Label */ 
#line 1934
        (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1935
        (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1936
        goto switch_break___4;
        switch_default___1: /* CIL Label */ 
#line 1938
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 1939
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 1940
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 1941
        (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 1942
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 1944
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 1946
        if (incr_top == 1U) {
          {
#line 1948
          if ((int )*(prog + i) == 'R') {
#line 1948
            goto case_82___2;
          }
#line 1966
          if ((int )*(prog + i) == 'C') {
#line 1966
            goto case_67___2;
          }
#line 1984
          if ((int )*(prog + i) == 'L') {
#line 1984
            goto case_76___2;
          }
#line 2002
          if ((int )*(prog + i) == 'P') {
#line 2002
            goto case_80___2;
          }
#line 2005
          if ((int )*(prog + i) == 1) {
#line 2005
            goto case_1___2;
          }
#line 2005
          if ((int )*(prog + i) == 0) {
#line 2005
            goto case_1___2;
          }
#line 2023
          goto switch_default___2;
          case_82___2: /* CIL Label */ 
#line 1949
          if (tcp->res_t == tcp->resE) {
            {
#line 1950
            __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1950
            if (__cil_tmp17) {
#line 1951
              tcp->res_t = tcp->resS;
#line 1952
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 1953
              (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1954
              tcp->res_t += (unsigned int )1;
#line 1955
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1957
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1960
            (pi + pino)->poc.resno0 = tcp->res_t;
#line 1961
            (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1962
            tcp->res_t += (unsigned int )1;
#line 1963
            incr_top = (OPJ_UINT32 )0;
          }
#line 1965
          goto switch_break___5;
          case_67___2: /* CIL Label */ 
#line 1967
          if (tcp->comp_t == tcp->compE) {
            {
#line 1968
            __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1968
            if (__cil_tmp18) {
#line 1969
              tcp->comp_t = tcp->compS;
#line 1970
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1971
              (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1972
              tcp->comp_t += (unsigned int )1;
#line 1973
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1975
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1978
            (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1979
            (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1980
            tcp->comp_t += (unsigned int )1;
#line 1981
            incr_top = (OPJ_UINT32 )0;
          }
#line 1983
          goto switch_break___5;
          case_76___2: /* CIL Label */ 
#line 1985
          if (tcp->lay_t == tcp->layE) {
            {
#line 1986
            __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1986
            if (__cil_tmp19) {
#line 1987
              tcp->lay_t = tcp->layS;
#line 1988
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1989
              (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1990
              tcp->lay_t += (unsigned int )1;
#line 1991
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1993
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1996
            (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1997
            (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1998
            tcp->lay_t += (unsigned int )1;
#line 1999
            incr_top = (OPJ_UINT32 )0;
          }
#line 2001
          goto switch_break___5;
          case_80___2: /* CIL Label */ 
          {
#line 2005
          if ((int )tcp->prg == 1) {
#line 2005
            goto case_1___2;
          }
#line 2005
          if ((int )tcp->prg == 0) {
#line 2005
            goto case_1___2;
          }
#line 2023
          goto switch_default___2;
          case_1___2: /* CIL Label */ 
          case_0___2: /* CIL Label */ 
#line 2006
          if (tcp->prc_t == tcp->prcE) {
            {
#line 2007
            __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 2007
            if (__cil_tmp20) {
#line 2008
              tcp->prc_t = tcp->prcS;
#line 2009
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 2010
              (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 2011
              tcp->prc_t += (unsigned int )1;
#line 2012
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 2014
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 2017
            (pi + pino)->poc.precno0 = tcp->prc_t;
#line 2018
            (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 2019
            tcp->prc_t += (unsigned int )1;
#line 2020
            incr_top = (OPJ_UINT32 )0;
          }
#line 2022
          goto switch_break___6;
          switch_default___2: /* CIL Label */ 
#line 2024
          if (tcp->tx0_t >= tcp->txE) {
#line 2025
            if (tcp->ty0_t >= tcp->tyE) {
              {
#line 2026
              __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 2026
              if (__cil_tmp21) {
#line 2027
                tcp->ty0_t = tcp->tyS;
#line 2028
                (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 2029
                (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 2030
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 2031
                incr_top = (OPJ_UINT32 )1;
#line 2032
                resetX = (OPJ_UINT32 )1;
              } else {
#line 2034
                incr_top = (OPJ_UINT32 )0;
#line 2035
                resetX = (OPJ_UINT32 )0;
              }
            } else {
#line 2038
              (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 2039
              (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 2040
              tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 2041
              incr_top = (OPJ_UINT32 )0;
#line 2042
              resetX = (OPJ_UINT32 )1;
            }
#line 2044
            if (resetX == 1U) {
#line 2045
              tcp->tx0_t = tcp->txS;
#line 2046
              (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 2047
              (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 2048
              tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
            }
          } else {
#line 2051
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 2052
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 2053
            tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 2054
            incr_top = (OPJ_UINT32 )0;
          }
#line 2056
          goto switch_break___6;
          switch_break___6: /* CIL Label */ ;
          }
#line 2058
          goto switch_break___5;
          switch_break___5: /* CIL Label */ ;
          }
        }
#line 1916
        __cil_tmp22 = i;
#line 1916
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 2066 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t___0 *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t___0 *l_current_pi ;
  opj_pi_comp_t *l_current_component ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 2070
  l_current_pi = p_pi;
#line 2071
  if (p_pi) {
#line 2072
    if (p_pi->include) {
      {
#line 2073
      opj_free(p_pi->include);
#line 2074
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 2076
    pino = (OPJ_UINT32 )0;
    {
#line 2076
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2076
      if (! (pino < p_nb_elements)) {
#line 2076
        goto while_break;
      }
#line 2077
      if (l_current_pi->comps) {
#line 2078
        l_current_component = l_current_pi->comps;
#line 2079
        compno = (OPJ_UINT32 )0;
        {
#line 2079
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2079
          if (! (compno < l_current_pi->numcomps)) {
#line 2079
            goto while_break___0;
          }
#line 2080
          if (l_current_component->resolutions) {
            {
#line 2081
            opj_free(l_current_component->resolutions);
#line 2082
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 2085
          l_current_component ++;
#line 2079
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2087
        opj_free(l_current_pi->comps);
#line 2088
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 2090
      l_current_pi ++;
#line 2076
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2092
    opj_free(p_pi);
    }
  }
  return;
}
}
#line 2098 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                       OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t___0 *l_tcp ;

  {
  {
#line 2109
  l_tcp = (opj_tcp_t___0 *)0;
#line 2116
  l_tcp = p_cp->tcps + p_tile_no;
#line 2119
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 2122
  if (l_tcp->POC) {
    {
#line 2123
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 2126
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
  return;
}
}
#line 2131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t___0 *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 2134
  if ((int )pi->poc.prg == 0) {
#line 2134
    goto case_0;
  }
#line 2136
  if ((int )pi->poc.prg == 1) {
#line 2136
    goto case_1;
  }
#line 2138
  if ((int )pi->poc.prg == 2) {
#line 2138
    goto case_2;
  }
#line 2140
  if ((int )pi->poc.prg == 3) {
#line 2140
    goto case_3;
  }
#line 2142
  if ((int )pi->poc.prg == 4) {
#line 2142
    goto case_4;
  }
#line 2144
  if ((int )pi->poc.prg == -1) {
#line 2144
    goto case_neg_1;
  }
#line 2133
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2135
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 2135
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 2137
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 2137
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 2139
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 2139
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 2141
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 2141
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 2143
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 2143
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 2145
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 2148
  return (0);
}
}
#line 65 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *memalign(size_t __alignment , size_t __size ) ;
#line 74
extern  __attribute__((__nothrow__)) void *pvalloc(size_t __size ) ;
#line 78
extern void *(*__morecore)(ptrdiff_t  ) ;
#line 81
extern  __attribute__((__nothrow__)) void *__default_morecore(ptrdiff_t __size ) ;
#line 101
extern  __attribute__((__nothrow__)) struct mallinfo mallinfo(void) ;
#line 128
extern  __attribute__((__nothrow__)) int mallopt(int __param , int __val ) ;
#line 132
extern  __attribute__((__nothrow__)) int malloc_trim(size_t __pad ) ;
#line 136
extern  __attribute__((__nothrow__)) size_t malloc_usable_size(void *__ptr ) ;
#line 139
extern  __attribute__((__nothrow__)) void malloc_stats(void) ;
#line 142
extern  __attribute__((__nothrow__)) int malloc_info(int __options , FILE *__fp ) ;
#line 145
extern void (*__free_hook)(void * , void const   * ) ;
#line 148
extern void *(*__malloc_hook)(size_t  , void const   * ) ;
#line 151
extern void *(*__realloc_hook)(void * , size_t  , void const   * ) ;
#line 155
extern void *(*__memalign_hook)(size_t  , size_t  , void const   * ) ;
#line 159
extern void (*__after_morecore_hook)(void) ;
#line 43 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_alloc_n(size_t alignment , size_t size ) 
{ 
  void *ptr ;
  int __cil_tmp4 ;

  {
#line 52
  if (size == 0UL) {
#line 53
    return ((void *)0);
  }
  {
#line 61
  __cil_tmp4 = posix_memalign(& ptr, alignment, size);
  }
#line 61
  if (__cil_tmp4) {
#line 62
    ptr = (void *)0;
  }
#line 105
  return (ptr);
}
}
#line 107 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
__inline static void *opj_aligned_realloc_n(void *ptr , size_t alignment , size_t new_size ) 
{ 
  void *r_ptr ;
  void *__cil_tmp5 ;
  void *a_ptr ;
  void *__cil_tmp7 ;

  {
#line 117
  if (new_size == 0UL) {
#line 118
    return ((void *)0);
  }
  {
#line 124
  r_ptr = realloc(ptr, new_size);
  }
#line 127
  if (((size_t )r_ptr & (alignment - 1UL)) != 0UL) {
    {
#line 132
    __cil_tmp7 = opj_aligned_alloc_n(alignment, new_size);
#line 132
    a_ptr = __cil_tmp7;
    }
#line 133
    if (a_ptr != (void *)0) {
      {
#line 134
      memcpy(a_ptr, r_ptr, new_size);
      }
    }
    {
#line 136
    free(r_ptr);
#line 137
    r_ptr = a_ptr;
    }
  }
#line 189
  return (r_ptr);
}
}
#line 191 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
#line 193
  if (size == 0UL) {
#line 194
    return ((void *)0);
  }
  {
#line 196
  __cil_tmp2 = malloc(size);
  }
#line 196
  return (__cil_tmp2);
}
}
#line 198 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_calloc(size_t num , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
#line 200
  if (num == 0UL) {
#line 202
    return ((void *)0);
  } else
#line 200
  if (size == 0UL) {
#line 202
    return ((void *)0);
  }
  {
#line 204
  __cil_tmp3 = calloc(num, size);
  }
#line 204
  return (__cil_tmp3);
}
}
#line 207 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 209
  __cil_tmp2 = opj_aligned_alloc_n((size_t )16U, size);
  }
#line 209
  return (__cil_tmp2);
}
}
#line 211 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_realloc(void *ptr , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 213
  __cil_tmp3 = opj_aligned_realloc_n(ptr, (size_t )16U, size);
  }
#line 213
  return (__cil_tmp3);
}
}
#line 216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_malloc(size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 218
  __cil_tmp2 = opj_aligned_alloc_n((size_t )32U, size);
  }
#line 218
  return (__cil_tmp2);
}
}
#line 220 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_aligned_32_realloc(void *ptr , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 222
  __cil_tmp3 = opj_aligned_realloc_n(ptr, (size_t )32U, size);
  }
#line 222
  return (__cil_tmp3);
}
}
#line 225 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void opj_aligned_free(void *ptr ) 
{ 


  {
  {
#line 228
  free(ptr);
  }
  return;
}
}
#line 239 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void *opj_realloc(void *ptr , size_t new_size ) 
{ 
  void *__cil_tmp3 ;

  {
#line 241
  if (new_size == 0UL) {
#line 242
    return ((void *)0);
  }
  {
#line 244
  __cil_tmp3 = realloc(ptr, new_size);
  }
#line 244
  return (__cil_tmp3);
}
}
#line 246 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.c"
void opj_free(void *ptr ) 
{ 


  {
  {
#line 248
  free(ptr);
  }
  return;
}
}
#line 17 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.h"
int opj_opterr ;
#line 18
int opj_optind ;
#line 19
int opj_optopt ;
#line 20
int opj_optreset ;
#line 21
char *opj_optarg ;
#line 23
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 24
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 26
void opj_reset_options_reading(void) ;
#line 46 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
int opj_opterr  =    1;
#line 47 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
int opj_optind  =    1;
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
void opj_reset_options_reading(void) 
{ 


  {
#line 59
  opj_opterr = 1;
#line 60
  opj_optind = 1;
  return;
}
}
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char const   *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 70
  place = (char *)EMSG;
#line 71
  oli = (char const   *)((void *)0);
#line 73
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 74
    opj_optreset = 0;
#line 75
    place = *(nargv + opj_optind);
#line 75
    if (opj_optind >= nargc) {
#line 76
      place = (char *)EMSG;
#line 77
      return (- 1);
    } else
#line 75
    if ((int )*place != 45) {
#line 76
      place = (char *)EMSG;
#line 77
      return (- 1);
    }
#line 79
    place ++;
#line 79
    if ((int )*(place + 1)) {
#line 79
      if ((int )*place == 45) {
#line 80
        opj_optind ++;
#line 81
        place = (char *)EMSG;
#line 82
        return (- 1);
      }
    }
  } else
#line 73
  if (! *place) {
#line 73
    goto _L;
  }
  {
#line 85
  __cil_tmp7 = strchr(ostr, opj_optopt);
#line 85
  oli = (char const   *)__cil_tmp7;
  }
#line 85
  __cil_tmp6 = place;
#line 85
  place ++;
#line 85
  opj_optopt = (int )*__cil_tmp6;
#line 85
  if (! oli) {
    _L___10: /* CIL Label */ 
#line 91
    if (opj_optopt == 45) {
#line 92
      return (- 1);
    }
#line 94
    if (! *place) {
#line 95
      opj_optind ++;
    }
#line 97
    if (opj_opterr) {
#line 97
      if ((int )*ostr != 58) {
        {
#line 98
        fprintf(stderr, "%s: illegal option -- %c\n", *(nargv + 0), opj_optopt);
        }
#line 100
        return ((int )'?');
      }
    }
  } else
#line 85
  if (opj_optopt == 58) {
#line 85
    goto _L___10;
  }
#line 103
  oli ++;
#line 103
  if ((int )*oli != 58) {
#line 104
    opj_optarg = (char *)((void *)0);
#line 105
    if (! *place) {
#line 106
      opj_optind ++;
    }
  } else {
#line 109
    if (*place) {
#line 110
      opj_optarg = place;
    } else {
#line 111
      opj_optind ++;
#line 111
      if (nargc <= opj_optind) {
#line 112
        place = (char *)EMSG;
#line 113
        if ((int )*ostr == 58) {
#line 114
          return ((int )':');
        }
#line 116
        if (opj_opterr) {
          {
#line 117
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 120
          return ((int )'?');
        }
      } else {
#line 123
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 125
    place = (char *)EMSG;
#line 126
    opj_optind ++;
  }
#line 128
  return (opj_optopt);
}
}
#line 132 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char const   *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 138
  param = (char )1;
  again: 
#line 141
  if (! argv[opj_optind]) {
#line 142
    return (- 1);
  } else
#line 141
  if (opj_optind >= argc) {
#line 142
    return (- 1);
  } else
#line 141
  if ((int )*(argv[opj_optind]) != 45) {
#line 142
    return (- 1);
  }
#line 145
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 145
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 146
      if (opj_optind >= argc - 1) {
#line 147
        param = (char )0;
      } else
#line 149
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 150
        param = (char )0;
      } else {
#line 152
        param = (char )2;
      }
    }
  }
#line 157
  if ((int )param == 0) {
#line 158
    opj_optind ++;
#line 159
    return ((int )'?');
  }
#line 162
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 165
    o = longopts;
#line 166
    len = (int )sizeof(*(longopts + 0));
#line 168
    if ((int )param > 1) {
#line 169
      if (opj_optind + 1 >= argc) {
#line 170
        return (- 1);
      }
#line 172
      arg = argv[opj_optind + 1];
#line 173
      opj_optind ++;
    } else {
#line 175
      arg = argv[opj_optind] + 1;
    }
    {
#line 178
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 178
    if (__cil_tmp15 > 1UL) {
#line 179
      i = 0;
      {
#line 179
      while (1) {
        while_continue: /* CIL Label */ ;
#line 179
        if (! (i < totlen)) {
#line 179
          goto while_break;
        }
        {
#line 180
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 180
        if (! __cil_tmp16) {
#line 181
          if (o->has_arg == 0) {
#line 182
            if (argv[opj_optind + 1]) {
#line 182
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 183
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 185
                opj_optind ++;
                }
              }
            }
          } else {
#line 188
            opj_optarg = argv[opj_optind + 1];
#line 189
            if (opj_optarg) {
#line 190
              if ((int )*(opj_optarg + 0) == 45) {
#line 192
                if (opj_opterr) {
                  {
#line 193
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 194
                  return ((int )'?');
                }
              }
            }
#line 198
            if (! opj_optarg) {
#line 198
              if (o->has_arg == 1) {
#line 199
                if (opj_opterr) {
                  {
#line 200
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 201
                  return ((int )'?');
                }
              }
            }
#line 204
            opj_optind ++;
          }
#line 206
          opj_optind ++;
#line 207
          if (o->flag) {
#line 208
            *(o->flag) = o->val;
          } else {
#line 210
            return (o->val);
          }
#line 212
          return (0);
        }
#line 179
        __cil_tmp17 = o;
#line 179
        o ++;
#line 179
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 215
      fprintf(stderr, "Invalid option %s\n\311}EV", arg);
#line 216
      opj_optind ++;
      }
#line 217
      return ((int )'?');
    } else {
#line 219
      if ((int )*optstring == 58) {
#line 220
        return (':');
      }
#line 222
      if (lastidx != opj_optind) {
#line 223
        lastidx = opj_optind;
#line 224
        lastofs = 0;
      }
      {
#line 226
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 227
      __cil_tmp18 = strchr(optstring, opj_optopt);
#line 227
      tmp = (char const   *)__cil_tmp18;
      }
#line 227
      if (tmp) {
#line 228
        if ((int )*tmp == 0) {
#line 229
          opj_optind ++;
#line 230
          goto again;
        }
#line 232
        if ((int )*(tmp + 1) == 58) {
#line 233
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 235
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 235
            if (! *opj_optarg) {
#line 236
              opj_optarg = (char *)0;
            }
#line 238
            goto found;
          } else
#line 233
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 233
            goto _L;
          }
#line 240
          opj_optarg = argv[opj_optind + 1];
#line 241
          if (opj_optarg) {
#line 242
            if ((int )*(opj_optarg + 0) == 45) {
#line 244
              if (opj_opterr) {
                {
#line 245
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
#line 246
                opj_optind ++;
                }
#line 247
                return ((int )'?');
              }
            }
          }
#line 251
          if (! opj_optarg) {
#line 252
            if (opj_opterr) {
              {
#line 253
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
#line 254
              opj_optind ++;
              }
#line 255
              return ((int )'?');
            }
          }
#line 258
          opj_optind ++;
        } else {
#line 260
          lastofs ++;
#line 261
          return (opj_optopt);
        }
        found: 
#line 264
        opj_optind ++;
#line 265
        return (opj_optopt);
      } else {
        {
#line 267
        fprintf(stderr, "Invalid option %s\n", arg);
#line 268
        opj_optind ++;
        }
#line 269
        return ((int )'?');
      }
    }
  }
  {
#line 274
  fprintf(stderr, "Invalid option\n");
#line 275
  opj_optind ++;
  }
#line 276
  return ((int )'?');

}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 69 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.h"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 71
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) ;
#line 76
convert_32s_CXPX convert_32s_CXPX_LUT[5] ;
#line 79
convert_32s_PXCX convert_32s_PXCX_LUT[5] ;
#line 83
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] ;
#line 86
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] ;
#line 90
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 91
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 94
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 95
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 98
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters , unsigned int target_bitdepth ) ;
#line 100
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 107
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 108
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 110
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 111
int imagetopnm(opj_image_t *image , char const   *outfile , int force_split ) ;
#line 114
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 115
int imagetorawl(opj_image_t *image , char const   *outfile ) ;
#line 116
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 118
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) ;
#line 122
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 123
extern opj_image_t *pngtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 47 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 40 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_string.h"
static size_t opj_strnlen_s(char const   *src , size_t max_len ) 
{ 
  size_t len ;
  char const   *__cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
#line 44
  if (src == (void *)0) {
#line 45
    return ((size_t )0U);
  }
#line 47
  len = (size_t )0U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((int )*src != 0 && len < max_len)) {
#line 47
      goto while_break;
    }

#line 47
    __cil_tmp5 = len;
#line 47
    len ++;
#line 47
    __cil_tmp4 = src;
#line 47
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (len);
}
}
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/opj_string.h"
static int opj_strcpy_s(char *dst , size_t dst_size , char const   *src ) 
{ 
  size_t src_len ;
  size_t __cil_tmp5 ;

  {
#line 55
  src_len = (size_t )0U;
#line 56
  if (dst == (void *)0) {
#line 57
    return (22);
  } else
#line 56
  if (dst_size == 0UL) {
#line 57
    return (22);
  }
#line 59
  if (src == (void *)0) {
#line 60
    *(dst + 0) = (char )'\000';
#line 61
    return (22);
  }
  {
#line 63
  src_len = opj_strnlen_s(src, dst_size);
  }
#line 64
  if (src_len >= dst_size) {
#line 65
    return (34);
  }
  {
#line 67
  memcpy(dst, src, src_len);
#line 68
  *(dst + src_len) = (char )'\000';
  }
#line 69
  return (0);
}
}
#line 86 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static unsigned int get_num_images(char *imgdirpath ) ;
#line 87
static int load_images(dircnt_t *dirptr , char *imgdirpath ) ;
#line 88
static int get_file_format(char const   *filename ) ;
#line 89
static char get_next_file(unsigned int imageno , dircnt_t *dirptr , img_fol_t *img_fol ,
                          opj_dparameters_t *parameters ) ;
#line 92
static int infile_format(char const   *fname ) ;
#line 94
static int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                                 img_fol_t *img_fol ) ;
#line 98 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static void decode_help_display(void) 
{ 
  char const   *__cil_tmp1 ;

  {
  {
#line 100
  __cil_tmp1 = opj_version();
#line 100
  fprintf(stdout, "\nThis is the opj_dump utility from the OpenJPEG project.\nIt dumps JPEG 2000 codestream info to stdout or a given file.\nIt has been compiled against openjp2 library v%s.\n\n",
          __cil_tmp1);
#line 104
  fprintf(stdout, "Parameters:\n");
#line 105
  fprintf(stdout, "-----------\n");
#line 106
  fprintf(stdout, "\n");
#line 107
  fprintf(stdout, "  -ImgDir <directory>\n");
#line 108
  fprintf(stdout, "\tImage file Directory path \n");
#line 109
  fprintf(stdout, "  -i <compressed file>\n");
#line 110
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n");
#line 112
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 114
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 115
  fprintf(stdout, "  -o <output file>\n");
#line 116
  fprintf(stdout, "    OPTIONAL\n");
#line 117
  fprintf(stdout, "    Output file where file info will be dump.\n");
#line 118
  fprintf(stdout, "    By default it will be in the stdout.\n");
#line 119
  fprintf(stdout, "  -v ");
#line 120
  fprintf(stdout, "    OPTIONAL\n");
#line 121
  fprintf(stdout, "    Enable informative messages\n\220");
#line 122
  fprintf(stdout, "    By default verbose mode is off.\n");
#line 123
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static unsigned int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  unsigned int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 131
  num_images = (unsigned int )0;
#line 135
  dir = opendir((char const   *)imgdirpath);
  }
#line 136
  if (! dir) {
    {
#line 137
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 138
    return ((unsigned int )0);
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    content = readdir(dir);
    }
#line 141
    if (! (content != (void *)0)) {
#line 141
      goto while_break;
    }
    {
#line 142
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 142
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 142
    if (__cil_tmp7 == 0) {
#line 143
      goto while_continue;
    } else
#line 142
    if (__cil_tmp8 == 0) {
#line 143
      goto while_continue;
    }
#line 145
    if (num_images == 4294967295U) {
      {
#line 146
      fprintf(stderr, "Too many files in folder %s\n", imgdirpath);
#line 147
      num_images = (unsigned int )0;
      }
#line 148
      goto while_break;
    }
#line 150
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  closedir(dir);
  }
#line 153
  return (num_images);
}
}
#line 157 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 161
  i = 0;
#line 165
  dir = opendir((char const   *)imgdirpath);
  }
#line 166
  if (! dir) {
    {
#line 167
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 168
    return (1);
  } else {
    {
#line 170
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    content = readdir(dir);
    }
#line 173
    if (! (content != (void *)0)) {
#line 173
      goto while_break;
    }
    {
#line 174
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 174
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 174
    if (__cil_tmp8 == 0) {
#line 175
      goto while_continue;
    } else
#line 174
    if (__cil_tmp9 == 0) {
#line 175
      goto while_continue;
    }
    {
#line 178
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  closedir(dir);
  }
#line 182
  return (0);
}
}
#line 186 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static int get_file_format(char const   *filename ) 
{ 
  unsigned int i ;
  static char const   * const  extension[19] ;
  static int const   format[19] ;
  char const   *ext ;
  char *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 189
  extension[0] = "pgx}EV";
#line 189
  extension[1] = "pnm}EV";
#line 189
  extension[2] = "pgm}EV";
#line 189
  extension[3] = "ppm}EV";
#line 189
  extension[4] = "bmp}EV";
#line 189
  extension[5] = "tif}EV";
#line 189
  extension[6] = "tiffEV";
#line 189
  extension[7] = "raw}EV";
#line 189
  extension[8] = "yuv}EV";
#line 189
  extension[9] = "rawlEV";
#line 189
  extension[10] = "tga}EV";
#line 189
  extension[11] = "png}EV";
#line 189
  extension[12] = "j2k}EV";
#line 189
  extension[13] = "jp2}EV";
#line 189
  extension[14] = "jpt}EV";
#line 189
  extension[15] = "j2c}EV";
#line 189
  extension[16] = "jpc";
#line 189
  extension[17] = "jph}EV";
#line 189
  extension[18] = "jhc";
#line 198
  format[0] = 11;
#line 198
  format[1] = 10;
#line 198
  format[2] = 10;
#line 198
  format[3] = 10;
#line 198
  format[4] = 12;
#line 198
  format[5] = 14;
#line 198
  format[6] = 14;
#line 198
  format[7] = 15;
#line 198
  format[8] = 15;
#line 198
  format[9] = 18;
#line 198
  format[10] = 16;
#line 198
  format[11] = 17;
#line 198
  format[12] = 0;
#line 198
  format[13] = 1;
#line 198
  format[14] = 2;
#line 198
  format[15] = 0;
#line 198
  format[16] = 0;
#line 198
  format[17] = 1;
#line 198
  format[18] = 0;
#line 207
  __cil_tmp6 = strrchr(filename, '.');
#line 207
  ext = (char const   *)__cil_tmp6;
  }
#line 208
  if (ext == (void *)0) {
#line 209
    return (- 1);
  }
#line 211
  ext ++;
#line 212
  if (ext) {
#line 213
    i = (unsigned int )0;
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 213
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 213
        goto while_break;
      }
      {
#line 214
      __cil_tmp8 = strncasecmp(ext, extension[i], (unsigned long )3);
      }
#line 214
      if (__cil_tmp8 == 0) {
#line 215
        return (format[i]);
      }
#line 213
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 220
  return (- 1);
}
}
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static char get_next_file(unsigned int imageno , dircnt_t *dirptr , img_fol_t *img_fol ,
                          opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 230
  temp1 = "\002";
#line 232
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 233
  fprintf(stderr, "File Number %u \"%s\"\n", imageno, (char *)image_filename);
#line 234
  parameters->decod_format = get_file_format((char const   *)((char *)image_filename));
  }
#line 235
  if (parameters->decod_format == -1) {
#line 236
    return ((char )1);
  }
  {
#line 238
  __cil_tmp13 = strlen((char const   *)((char *)image_filename));
  }
  {
#line 238
  __cil_tmp12 = strlen((char const   *)img_fol->imgdirpath);
  }
#line 238
  if (((__cil_tmp12 + 1UL) + __cil_tmp13) + 1UL > sizeof(infilename)) {
#line 240
    return ((char )1);
  }
  {
#line 242
  strcpy((char *)infilename, (char const   *)img_fol->imgdirpath);
#line 243
  strcat((char *)infilename, "/");
#line 244
  strcat((char *)infilename, (char const   *)((char *)image_filename));
#line 245
  __cil_tmp14 = opj_strcpy_s((char *)parameters->infile, sizeof(parameters->infile),
                             (char const   *)((char *)infilename));
  }
#line 245
  if (__cil_tmp14 != 0) {
#line 247
    return ((char )1);
  }
  {
#line 251
  __cil_tmp15 = strtok((char *)image_filename, ".");
#line 251
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp15);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 252
    if (! (temp_p != (void *)0)) {
#line 252
      goto while_break;
    }
    {
#line 253
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 254
    sprintf((char *)temp1, ".%s", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if ((int )img_fol->set_out_format == 1) {
    {
#line 257
    __cil_tmp19 = strlen(img_fol->out_format);
    }
    {
#line 257
    __cil_tmp18 = strlen((char const   *)((char *)temp_ofname));
    }
    {
#line 257
    __cil_tmp17 = strlen((char const   *)img_fol->imgdirpath);
    }
#line 257
    if (((((__cil_tmp17 + 1UL) + __cil_tmp18) + 1UL) + __cil_tmp19) + 1UL > sizeof(outfilename)) {
#line 259
      return ((char )1);
    }
    {
#line 261
    strcpy((char *)outfilename, (char const   *)img_fol->imgdirpath);
#line 262
    strcat((char *)outfilename, "/");
#line 263
    strcat((char *)outfilename, (char const   *)((char *)temp_ofname));
#line 264
    strcat((char *)outfilename, ".");
#line 265
    strcat((char *)outfilename, img_fol->out_format);
#line 266
    __cil_tmp20 = opj_strcpy_s((char *)parameters->outfile, sizeof(parameters->outfile),
                               (char const   *)((char *)outfilename));
    }
#line 266
    if (__cil_tmp20 != 0) {
#line 268
      return ((char )1);
    }
  }
#line 271
  return ((char )0);
}
}
#line 280 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static int infile_format(char const   *fname ) 
{ 
  FILE *reader ;
  char const   *s ;
  char const   *magic_s ;
  int ext_format ;
  int magic_format ;
  unsigned char buf[12] ;
  size_t l_nb_read ;
  FILE *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;

  {
  {
#line 288
  reader = fopen(fname, "rb");
  }
#line 290
  if (reader == (void *)0) {
#line 291
    return (- 1);
  }
  {
#line 294
  memset((unsigned char *)buf, 0, (unsigned long )12);
#line 295
  l_nb_read = fread((unsigned char *)buf, (unsigned long )1, (unsigned long )12, reader);
#line 296
  fclose(reader);
  }
#line 297
  if (l_nb_read != 12UL) {
#line 298
    return (- 1);
  }
  {
#line 303
  ext_format = get_file_format(fname);
  }
#line 305
  if (ext_format == 2) {
#line 306
    return (2);
  }
  {
#line 309
  __cil_tmp13 = memcmp((unsigned char *)buf, "\r\n\207\nEV", (unsigned long )4);
  }
  {
#line 309
  __cil_tmp12 = memcmp((unsigned char *)buf, "", (unsigned long )12);
  }
#line 309
  if (__cil_tmp12 == 0) {
#line 310
    magic_format = 1;
#line 311
    magic_s = ".jp2 or .jphEV";
  } else
#line 309
  if (__cil_tmp13 == 0) {
#line 310
    magic_format = 1;
#line 311
    magic_s = ".jp2 or .jphEV";
  } else {
    {
#line 312
    __cil_tmp14 = memcmp((unsigned char *)buf, "\377O\377QEV", (unsigned long )4);
    }
#line 312
    if (__cil_tmp14 == 0) {
#line 313
      magic_format = 0;
#line 314
      magic_s = ".j2k or .jpc or .j2c or .jhcEV";
    } else {
#line 316
      return (- 1);
    }
  }
#line 319
  if (magic_format == ext_format) {
#line 320
    return (ext_format);
  }
  {
#line 323
  __cil_tmp15 = strlen(fname);
#line 323
  s = (fname + __cil_tmp15) - 4;
#line 325
  fputs("\n===========================================\nV", stderr);
#line 326
  fprintf(stderr, "The extension of this file is incorrect.\nFOUND %s. SHOULD BE %s\n",
          s, magic_s);
#line 328
  fputs("===========================================\n", stderr);
  }
#line 330
  return (magic_format);
}
}
#line 337 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                                 img_fol_t *img_fol ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[1] ;
  char const   optlist[9] ;
  int __cil_tmp9 ;
  char *infile ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 341
  long_option[0].name = "ImgDir";
#line 341
  long_option[0].has_arg = 1;
#line 341
  long_option[0].flag = (int *)((void *)0);
#line 341
  long_option[0].val = 'y';
#line 344
  optlist = "i:o:f:hv**\342}EV";
#line 346
  totlen = (int )sizeof(long_option);
#line 347
  img_fol->set_out_format = (char )0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 350
    if (c == -1) {
#line 351
      goto while_break;
    }
    {
#line 354
    if (c == 'i') {
#line 354
      goto case_105;
    }
#line 358
    if (c == 0) {
#line 358
      goto case_0;
    }
#line 360
    if (c == 1) {
#line 360
      goto case_1;
    }
#line 362
    if (c == 2) {
#line 362
      goto case_2;
    }
#line 380
    if (c == 'o') {
#line 380
      goto case_111;
    }
#line 390
    if (c == 'f') {
#line 390
      goto case_102;
    }
#line 395
    if (c == 'h') {
#line 395
      goto case_104;
    }
#line 401
    if (c == 'y') {
#line 401
      goto case_121;
    }
#line 413
    if (c == 'v') {
#line 413
      goto case_118;
    }
#line 419
    goto switch_default___0;
    case_105: /* CIL Label */ 
    {
#line 355
    infile = opj_optarg;
#line 356
    parameters->decod_format = infile_format((char const   *)infile);
    }
    {
#line 358
    if (parameters->decod_format == 0) {
#line 358
      goto case_0;
    }
#line 360
    if (parameters->decod_format == 1) {
#line 360
      goto case_1;
    }
#line 362
    if (parameters->decod_format == 2) {
#line 362
      goto case_2;
    }
#line 364
    goto switch_default;
    case_0: /* CIL Label */ 
#line 359
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 361
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 363
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 365
    fprintf(stderr, "[ERROR] Unknown input file format: %s \n        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\n",
            infile);
    }
#line 369
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 371
    __cil_tmp12 = opj_strcpy_s((char *)parameters->infile, sizeof(parameters->infile),
                               (char const   *)infile);
    }
#line 371
    if (__cil_tmp12 != 0) {
      {
#line 372
      fprintf(stderr, "[ERROR] Path is too long\n");
      }
#line 373
      return (1);
    }
#line 376
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 381
    __cil_tmp13 = opj_strcpy_s((char *)parameters->outfile, sizeof(parameters->outfile),
                               (char const   *)opj_optarg);
    }
#line 381
    if (__cil_tmp13 != 0) {
      {
#line 383
      fprintf(stderr, "[ERROR] Path is too long\n");
      }
#line 384
      return (1);
    }
#line 387
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 391
    img_fol->flag = atoi((char const   *)opj_optarg);
    }
#line 392
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 396
    decode_help_display();
    }
#line 397
    return (1);
    case_121: /* CIL Label */ 
    {
#line 402
    __cil_tmp15 = strlen((char const   *)opj_optarg);
#line 402
    __cil_tmp16 = malloc(__cil_tmp15 + 1UL);
#line 402
    img_fol->imgdirpath = (char *)__cil_tmp16;
    }
#line 403
    if (img_fol->imgdirpath == (void *)0) {
#line 404
      return (1);
    }
    {
#line 406
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 407
    img_fol->set_imgdir = (char )1;
    }
#line 409
    goto switch_break;
    case_118: /* CIL Label */ 
#line 414
    parameters->m_verbose = 1;
#line 416
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 420
    fprintf(stderr, "[WARNING] An invalid option has been ignored.\n");
    }
#line 421
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 348
    if (! (c != -1)) {
#line 348
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if ((int )img_fol->set_imgdir == 1) {
#line 427
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 428
      fprintf(stderr, "[ERROR] options -ImgDir and -i cannot be used together.\n\220");
      }
#line 429
      return (1);
    }
#line 431
    if ((int )img_fol->set_out_format == 0) {
      {
#line 432
      fprintf(stderr, "[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\nV");
#line 434
      fprintf(stderr, "Only one format allowed.\nValid format are PGM, PPM, PNM, PGX, BMP, TIF, TIFF, RAW, YUV and TGA.\n");
      }
#line 436
      return (1);
    }
#line 438
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 439
      fprintf(stderr, "[ERROR] options -ImgDir and -o cannot be used together\n");
      }
#line 440
      return (1);
    }
  } else
#line 443
  if ((int )parameters->infile[0] == 0) {
    {
#line 444
    fprintf(stderr, "[ERROR] Required parameter is missing\n");
#line 445
    fprintf(stderr, "Example: %s -i image.j2k\n", *(argv + 0));
#line 446
    fprintf(stderr, "   Help: %s -h\n", *(argv + 0));
    }
#line 447
    return (1);
  }
#line 451
  return (0);
}
}
#line 459 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 462
  fprintf(stdout, "[ERROR] %s", msg);
  }
  return;
}
}
#line 467 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 470
  fprintf(stdout, "[WARNING] %s", msg);
  }
  return;
}
}
#line 475 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 478
  fprintf(stdout, "[INFO] %s", msg);
  }
  return;
}
}
#line 486 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/opj_dump.c"
int main(int argc , char *argv[] ) 
{ 
  FILE *fout ;
  opj_dparameters_t parameters ;
  opj_image_t *image ;
  opj_codec_t *l_codec ;
  opj_stream_t *l_stream ;
  opj_codestream_info_v2_t *cstr_info ;
  opj_codestream_index_t *cstr_index ;
  unsigned int num_images ;
  unsigned int imageno ;
  img_fol_t img_fol ;
  dircnt_t *dirptr ;
  int __cil_tmp14 ;
  unsigned int it_image ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int __cil_tmp21 ;
  FILE *__cil_tmp22 ;
  char __cil_tmp23 ;
  opj_stream_t *__cil_tmp24 ;
  opj_codec_t *__cil_tmp25 ;
  opj_codec_t *__cil_tmp26 ;
  opj_codec_t *__cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  opj_codestream_info_v2_t *__cil_tmp30 ;
  opj_codestream_index_t *__cil_tmp31 ;
  unsigned int __cil_tmp32 ;

  {
  {
#line 488
  fout = (FILE *)((void *)0);
#line 491
  image = (opj_image_t *)((void *)0);
#line 492
  l_codec = (opj_codec_t *)((void *)0);
#line 493
  l_stream = (opj_stream_t *)((void *)0);
#line 494
  cstr_info = (opj_codestream_info_v2_t *)((void *)0);
#line 495
  cstr_index = (opj_codestream_index_t *)((void *)0);
#line 499
  dirptr = (dircnt_t *)((void *)0);
#line 502
  opj_set_default_decoder_parameters(& parameters);
#line 505
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 506
  img_fol.flag = 19;
#line 509
  __cil_tmp14 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol);
  }
#line 509
  if (__cil_tmp14 == 1) {
#line 510
    if (img_fol.imgdirpath) {
      {
#line 511
      free(img_fol.imgdirpath);
      }
    }
#line 514
    return (1);
  }
#line 518
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 520
    num_images = get_num_images(img_fol.imgdirpath);
    }
#line 521
    if (num_images == 0U) {
      {
#line 522
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 523
      goto fails;
    }
    {
#line 525
    __cil_tmp17 = malloc(sizeof(dircnt_t ));
#line 525
    dirptr = (dircnt_t *)__cil_tmp17;
    }
#line 526
    if (! dirptr) {
#line 527
      return (1);
    }
    {
#line 530
    __cil_tmp18 = calloc((size_t )num_images, 4096UL * sizeof(char ));
#line 530
    dirptr->filename_buf = (char *)__cil_tmp18;
    }
#line 532
    if (! dirptr->filename_buf) {
      {
#line 533
      free(dirptr);
      }
#line 534
      return (1);
    }
    {
#line 536
    __cil_tmp19 = calloc((size_t )num_images, sizeof(char *));
#line 536
    dirptr->filename = (char **)__cil_tmp19;
    }
#line 538
    if (! dirptr->filename) {
#line 539
      goto fails;
    }
#line 542
    it_image = (unsigned int )0;
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (! (it_image < num_images)) {
#line 542
        goto while_break;
      }
#line 543
      *(dirptr->filename + it_image) = dirptr->filename_buf + (size_t )it_image * 4096UL;
#line 542
      it_image ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 547
    __cil_tmp21 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 547
    if (__cil_tmp21 == 1) {
#line 548
      goto fails;
    }
  } else {
#line 552
    num_images = (unsigned int )1;
  }
#line 556
  if ((int )parameters.outfile[0] != 0) {
    {
#line 557
    fout = fopen((char const   *)((char *)parameters.outfile), "w");
    }
#line 558
    if (! fout) {
      {
#line 559
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", (char *)parameters.outfile);
      }
#line 560
      goto fails;
    }
  } else {
#line 563
    fout = stdout;
  }
#line 567
  imageno = (unsigned int )0;
  {
#line 567
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 567
    if (! (imageno < num_images)) {
#line 567
      goto while_break___0;
    }
    {
#line 569
    fprintf(stderr, "\n");
    }
#line 571
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 572
      __cil_tmp23 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 572
      if (__cil_tmp23) {
        {
#line 573
        fprintf(stderr, "skipping file...\n\360\342}EV");
        }
#line 574
        goto while_continue___0;
      }
    }
    {
#line 581
    l_stream = opj_stream_create_default_file_stream((char const   *)((char *)parameters.infile),
                                                     1);
    }
#line 582
    if (! l_stream) {
      {
#line 583
      fprintf(stderr, "ERROR -> failed to create the stream from the file %s\n", (char *)parameters.infile);
      }
#line 585
      goto fails;
    }
    {
#line 592
    if (parameters.decod_format == 0) {
#line 592
      goto case_0;
    }
#line 597
    if (parameters.decod_format == 1) {
#line 597
      goto case_1;
    }
#line 602
    if (parameters.decod_format == 2) {
#line 602
      goto case_2;
    }
#line 607
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 594
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )0);
    }
#line 595
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 599
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )2);
    }
#line 600
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 604
    l_codec = opj_create_decompress((OPJ_CODEC_FORMAT )1);
    }
#line 605
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 608
    fprintf(stderr, "skipping file..\n\220");
    }
    {
#line 609
    opj_stream_destroy(l_stream);
    }
#line 610
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 614
    opj_set_info_handler(l_codec, & info_callback, (void *)0);
#line 615
    opj_set_warning_handler(l_codec, & warning_callback, (void *)0);
#line 616
    opj_set_error_handler(l_codec, & error_callback, (void *)0);
#line 618
    parameters.flags |= (unsigned int )2;
#line 621
    __cil_tmp28 = opj_setup_decoder(l_codec, & parameters);
    }
#line 621
    if (! __cil_tmp28) {
      {
#line 622
      fprintf(stderr, "ERROR -> opj_dump: failed to setup the decoder\n");
#line 623
      opj_stream_destroy(l_stream);
#line 624
      opj_destroy_codec(l_codec);
#line 625
      fclose(fout);
      }
#line 626
      goto fails;
    }
    {
#line 630
    __cil_tmp29 = opj_read_header(l_stream, l_codec, & image);
    }
#line 630
    if (! __cil_tmp29) {
      {
#line 631
      fprintf(stderr, "ERROR -> opj_dump: failed to read the header\n");
#line 632
      opj_stream_destroy(l_stream);
#line 633
      opj_destroy_codec(l_codec);
#line 634
      opj_image_destroy(image);
#line 635
      fclose(fout);
      }
#line 636
      goto fails;
    }
    {
#line 639
    opj_dump_codec(l_codec, img_fol.flag, fout);
#line 641
    cstr_info = opj_get_cstr_info(l_codec);
#line 643
    cstr_index = opj_get_cstr_index(l_codec);
#line 646
    opj_stream_destroy(l_stream);
    }
#line 649
    if (l_codec) {
      {
#line 650
      opj_destroy_codec(l_codec);
      }
    }
    {
#line 654
    opj_image_destroy(image);
#line 657
    opj_destroy_cstr_index(& cstr_index);
#line 660
    opj_destroy_cstr_info(& cstr_info);
    }
#line 567
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 665
  fclose(fout);
  }
#line 667
  return (0);
  fails: 
#line 670
  if (dirptr) {
#line 671
    if (dirptr->filename) {
      {
#line 672
      free(dirptr->filename);
      }
    }
#line 674
    if (dirptr->filename_buf) {
      {
#line 675
      free(dirptr->filename_buf);
      }
    }
    {
#line 677
    free(dirptr);
    }
  }
#line 679
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_clock.c"
OPJ_FLOAT64 opj_clock(void) 
{ 
  struct rusage t ;
  OPJ_FLOAT64 procTime ;

  {
  {
#line 58
  getrusage(0, & t);
#line 61
  procTime = (OPJ_FLOAT64 )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 63
  return (procTime + (OPJ_FLOAT64 )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 44 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                              void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 48
  l_codec = (opj_codec_private_t *)p_codec;
#line 49
  if (! l_codec) {
#line 50
    return (0);
  }
#line 53
  l_codec->m_event_mgr.info_handler = p_callback;
#line 54
  l_codec->m_event_mgr.m_info_data = p_user_data;
#line 56
  return (1);
}
}
#line 59 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                                 void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 63
  l_codec = (opj_codec_private_t *)p_codec;
#line 64
  if (! l_codec) {
#line 65
    return (0);
  }
#line 68
  l_codec->m_event_mgr.warning_handler = p_callback;
#line 69
  l_codec->m_event_mgr.m_warning_data = p_user_data;
#line 71
  return (1);
}
}
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                               void *p_user_data ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 78
  l_codec = (opj_codec_private_t *)p_codec;
#line 79
  if (! l_codec) {
#line 80
    return (0);
  }
#line 83
  l_codec->m_event_mgr.error_handler = p_callback;
#line 84
  l_codec->m_event_mgr.m_error_data = p_user_data;
#line 86
  return (1);
}
}
#line 91 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_read_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 
  FILE *p_file ;
  OPJ_SIZE_T l_nb_read ;
  unsigned long __cil_tmp6 ;
  OPJ_SIZE_T tmp ;

  {
  {
#line 94
  p_file = (FILE *)p_user_data;
#line 95
  __cil_tmp6 = fread(p_buffer, (unsigned long )1, p_nb_bytes, (FILE *)p_file);
#line 95
  l_nb_read = __cil_tmp6;
  }
#line 96
  if (l_nb_read) {
#line 96
    tmp = l_nb_read;
  } else {
#line 96
    tmp = (OPJ_SIZE_T )(- 1);
  }
#line 96
  return (tmp);
}
}
#line 99 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static OPJ_UINT64 opj_get_data_length_from_file(void *p_user_data ) 
{ 
  FILE *p_file ;
  OPJ_OFF_T file_length ;
  __off_t __cil_tmp4 ;

  {
  {
#line 101
  p_file = (FILE *)p_user_data;
#line 102
  file_length = (OPJ_OFF_T )0;
#line 104
  fseeko(p_file, (__off_t )0, 2);
#line 105
  __cil_tmp4 = ftello(p_file);
#line 105
  file_length = (OPJ_OFF_T )__cil_tmp4;
#line 106
  fseeko(p_file, (__off_t )0, 0);
  }
#line 108
  return ((OPJ_UINT64 )file_length);
}
}
#line 111 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static OPJ_SIZE_T opj_write_from_file(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 
  FILE *p_file ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 114
  p_file = (FILE *)p_user_data;
#line 115
  __cil_tmp5 = fwrite(p_buffer, (unsigned long )1, p_nb_bytes, p_file);
  }
#line 115
  return (__cil_tmp5);
}
}
#line 118 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 
  FILE *p_file ;
  int __cil_tmp4 ;

  {
  {
#line 120
  p_file = (FILE *)p_user_data;
#line 121
  __cil_tmp4 = fseeko(p_file, p_nb_bytes, 1);
  }
#line 121
  if (__cil_tmp4) {
#line 122
    return ((OPJ_OFF_T )(- 1));
  }
#line 125
  return (p_nb_bytes);
}
}
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 
  FILE *p_file ;
  int __cil_tmp4 ;

  {
  {
#line 130
  p_file = (FILE *)p_user_data;
#line 131
  __cil_tmp4 = fseeko(p_file, p_nb_bytes, 0);
  }
#line 131
  if (__cil_tmp4) {
#line 132
    return (0);
  }
#line 135
  return (1);
}
}
#line 138 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
static void opj_close_from_file(void *p_user_data ) 
{ 
  FILE *p_file ;

  {
  {
#line 140
  p_file = (FILE *)p_user_data;
#line 141
  fclose(p_file);
  }
  return;
}
}
#line 176 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 178
  return ("2.5.0");
}
}
#line 184 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 186
  l_codec = (opj_codec_private_t *)0;
#line 188
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 188
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 189
  if (! l_codec) {
#line 190
    return ((opj_codec_t *)0);
  }
#line 193
  l_codec->is_decompressor = 1;
  {
#line 196
  if ((int )p_format == 0) {
#line 196
    goto case_0;
  }
#line 286
  if ((int )p_format == 2) {
#line 286
    goto case_2;
  }
#line 378
  goto switch_default;
  case_0: /* CIL Label */ 
#line 197
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& j2k_dump);
  {
#line 199
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& j2k_get_cstr_info);
#line 202
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& j2k_get_cstr_index);
#line 205
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_j2k_decode);
#line 210
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_j2k_end_decompress);
#line 215
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_read_header);
#line 221
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 224
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_j2k_setup_decoder);
#line 227
  l_codec->m_codec_data.m_decompression.opj_decoder_set_strict_mode = (void (*)(void * ,
                                                                                OPJ_BOOL  ))(& opj_j2k_decoder_set_strict_mode);
#line 231
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_read_tile_header);
#line 242
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_j2k_decode_tile);
#line 250
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_j2k_set_decode_area);
#line 256
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_j2k_get_tile);
#line 263
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          struct opj_event_mgr * ))(& opj_j2k_set_decoded_resolution_factor);
#line 268
  l_codec->m_codec_data.m_decompression.opj_set_decoded_components = (OPJ_BOOL (*)(void * ,
                                                                                   OPJ_UINT32  ,
                                                                                   OPJ_UINT32 * ,
                                                                                   struct opj_event_mgr * ))(& opj_j2k_set_decoded_components);
#line 274
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_j2k_set_threads);
#line 277
  l_codec->m_codec = (void *)opj_j2k_create_decompress();
  }
#line 279
  if (! l_codec->m_codec) {
    {
#line 280
    opj_free(l_codec);
    }
#line 281
    return ((opj_codec_t *)((void *)0));
  }
#line 284
  goto switch_break;
  case_2: /* CIL Label */ 
#line 288
  l_codec->opj_dump_codec = (void (*)(void * , OPJ_INT32  , FILE * ))(& jp2_dump);
  {
#line 290
  l_codec->opj_get_codec_info = (opj_codestream_info_v2_t *(*)(void * ))(& jp2_get_cstr_info);
#line 293
  l_codec->opj_get_codec_index = (opj_codestream_index_t *(*)(void * ))(& jp2_get_cstr_index);
#line 296
  l_codec->m_codec_data.m_decompression.opj_decode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                   opj_image_t * ,
                                                                   struct opj_event_mgr * ))(& opj_jp2_decode);
#line 302
  l_codec->m_codec_data.m_decompression.opj_end_decompress = (OPJ_BOOL (*)(void * ,
                                                                           struct opj_stream_private * ,
                                                                           struct opj_event_mgr * ))(& opj_jp2_end_decompress);
#line 307
  l_codec->m_codec_data.m_decompression.opj_read_header = (OPJ_BOOL (*)(struct opj_stream_private * ,
                                                                        void * , opj_image_t ** ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_read_header);
#line 313
  l_codec->m_codec_data.m_decompression.opj_read_tile_header = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_INT32 * ,
                                                                             OPJ_UINT32 * ,
                                                                             OPJ_BOOL * ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_read_tile_header);
#line 326
  l_codec->m_codec_data.m_decompression.opj_decode_tile_data = (OPJ_BOOL (*)(void * ,
                                                                             OPJ_UINT32  ,
                                                                             OPJ_BYTE * ,
                                                                             OPJ_UINT32  ,
                                                                             struct opj_stream_private * ,
                                                                             struct opj_event_mgr * ))(& opj_jp2_decode_tile);
#line 332
  l_codec->m_codec_data.m_decompression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 335
  l_codec->m_codec_data.m_decompression.opj_setup_decoder = (void (*)(void * , opj_dparameters_t * ))(& opj_jp2_setup_decoder);
#line 338
  l_codec->m_codec_data.m_decompression.opj_decoder_set_strict_mode = (void (*)(void * ,
                                                                                OPJ_BOOL  ))(& opj_jp2_decoder_set_strict_mode);
#line 341
  l_codec->m_codec_data.m_decompression.opj_set_decode_area = (OPJ_BOOL (*)(void * ,
                                                                            opj_image_t * ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            OPJ_INT32  ,
                                                                            struct opj_event_mgr * ))(& opj_jp2_set_decode_area);
#line 347
  l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = (OPJ_BOOL (*)(void * ,
                                                                             opj_stream_private_t * ,
                                                                             opj_image_t * ,
                                                                             struct opj_event_mgr * ,
                                                                             OPJ_UINT32  ))(& opj_jp2_get_tile);
#line 354
  l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = (OPJ_BOOL (*)(void * ,
                                                                                          OPJ_UINT32  ,
                                                                                          opj_event_mgr_t * ))(& opj_jp2_set_decoded_resolution_factor);
#line 359
  l_codec->m_codec_data.m_decompression.opj_set_decoded_components = (OPJ_BOOL (*)(void * ,
                                                                                   OPJ_UINT32  ,
                                                                                   OPJ_UINT32 * ,
                                                                                   struct opj_event_mgr * ))(& opj_jp2_set_decoded_components);
#line 365
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_jp2_set_threads);
#line 368
  l_codec->m_codec = (void *)opj_jp2_create(1);
  }
#line 370
  if (! l_codec->m_codec) {
    {
#line 371
    opj_free(l_codec);
    }
#line 372
    return ((opj_codec_t *)0);
  }
#line 375
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 379
  opj_free(l_codec);
  }
#line 380
  return ((opj_codec_t *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 383
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 384
  return ((opj_codec_t *)l_codec);
}
}
#line 387 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 390
  if (parameters) {
    {
#line 391
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 393
    parameters->cp_layer = (OPJ_UINT32 )0;
#line 394
    parameters->cp_reduce = (OPJ_UINT32 )0;
#line 396
    parameters->decod_format = - 1;
#line 397
    parameters->cod_format = - 1;
#line 398
    parameters->flags = (unsigned int )0;
    }
  }
  return;
}
}
#line 410 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec , int num_threads ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp4 ;

  {
#line 413
  if (p_codec) {
#line 413
    if (num_threads >= 0) {
      {
#line 414
      l_codec = (opj_codec_private_t *)p_codec;
#line 416
      __cil_tmp4 = (*(l_codec->opj_set_threads))(l_codec->m_codec, (OPJ_UINT32 )num_threads);
      }
#line 416
      return (__cil_tmp4);
    }
  }
#line 418
  return (0);
}
}
#line 421 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 425
  if (p_codec) {
#line 425
    if (parameters) {
#line 426
      l_codec = (opj_codec_private_t *)p_codec;
#line 428
      if (! l_codec->is_decompressor) {
        {
#line 429
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_setup_decoder function is not a decompressor handler.\npC\031~EV");
        }
#line 431
        return (0);
      }
      {
#line 434
      (*(l_codec->m_codec_data.m_decompression.opj_setup_decoder))(l_codec->m_codec,
                                                                   parameters);
      }
#line 436
      return (1);
    }
  }
#line 438
  return (0);
}
}
#line 441 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decoder_set_strict_mode(opj_codec_t *p_codec , OPJ_BOOL strict ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 444
  if (p_codec) {
#line 445
    l_codec = (opj_codec_private_t *)p_codec;
#line 447
    if (! l_codec->is_decompressor) {
      {
#line 448
      opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_decoder_set_strict_mode function is not a decompressor handler.\n");
      }
#line 450
      return (0);
    }
    {
#line 453
    (*(l_codec->m_codec_data.m_decompression.opj_decoder_set_strict_mode))(l_codec->m_codec,
                                                                           strict);
    }
#line 456
    return (1);
  }
#line 458
  return (0);
}
}
#line 461 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 465
  if (p_codec) {
#line 465
    if (p_stream) {
#line 466
      l_codec = (opj_codec_private_t *)p_codec;
#line 467
      l_stream = (opj_stream_private_t *)p_stream;
#line 469
      if (! l_codec->is_decompressor) {
        {
#line 470
        opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_read_header function is not a decompressor handler.\n");
        }
#line 472
        return (0);
      }
      {
#line 475
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_read_header))(l_stream,
                                                                              l_codec->m_codec,
                                                                              p_image,
                                                                              & l_codec->m_event_mgr);
      }
#line 475
      return (__cil_tmp6);
    }
  }
#line 481
  return (0);
}
}
#line 485 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_components(opj_codec_t *p_codec , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                    OPJ_BOOL apply_color_transforms ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 490
  if (p_codec) {
#line 491
    l_codec = (opj_codec_private_t *)p_codec;
#line 493
    if (! l_codec->is_decompressor) {
      {
#line 494
      opj_event_msg(& l_codec->m_event_mgr, 1, "Codec provided to the opj_set_decoded_components function is not a decompressor handler.\n");
      }
#line 496
      return (0);
    }
#line 499
    if (apply_color_transforms) {
      {
#line 500
      opj_event_msg(& l_codec->m_event_mgr, 1, "apply_color_transforms = OPJ_TRUE is not supported.\nEV");
      }
#line 502
      return (0);
    }
    {
#line 505
    __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_components))(l_codec->m_codec,
                                                                                       numcomps,
                                                                                       comps_indices,
                                                                                       & l_codec->m_event_mgr);
    }
#line 505
    return (__cil_tmp6);
  }
#line 511
  return (0);
}
}
#line 514 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 518
  if (p_codec) {
#line 518
    if (p_stream) {
#line 519
      l_codec = (opj_codec_private_t *)p_codec;
#line 520
      l_stream = (opj_stream_private_t *)p_stream;
#line 522
      if (! l_codec->is_decompressor) {
#line 523
        return (0);
      }
      {
#line 526
      __cil_tmp6 = (*(l_codec->m_codec_data.m_decompression.opj_decode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         p_image,
                                                                         & l_codec->m_event_mgr);
      }
#line 526
      return (__cil_tmp6);
    }
  }
#line 532
  return (0);
}
}
#line 535 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 541
  if (p_codec) {
#line 542
    l_codec = (opj_codec_private_t *)p_codec;
#line 544
    if (! l_codec->is_decompressor) {
#line 545
      return (0);
    }
    {
#line 548
    __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_set_decode_area))(l_codec->m_codec,
                                                                                p_image,
                                                                                p_start_x,
                                                                                p_start_y,
                                                                                p_end_x,
                                                                                p_end_y,
                                                                                & l_codec->m_event_mgr);
    }
#line 548
    return (__cil_tmp8);
  }
#line 555
  return (0);
}
}
#line 558 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp13 ;

  {
#line 567
  if (p_codec) {
#line 567
    if (p_stream) {
#line 567
      if (p_data_size) {
#line 567
        if (p_tile_index) {
#line 568
          l_codec = (opj_codec_private_t *)p_codec;
#line 569
          l_stream = (opj_stream_private_t *)p_stream;
#line 571
          if (! l_codec->is_decompressor) {
#line 572
            return (0);
          }
          {
#line 575
          __cil_tmp13 = (*(l_codec->m_codec_data.m_decompression.opj_read_tile_header))(l_codec->m_codec,
                                                                                        p_tile_index,
                                                                                        p_data_size,
                                                                                        p_tile_x0,
                                                                                        p_tile_y0,
                                                                                        p_tile_x1,
                                                                                        p_tile_y1,
                                                                                        p_nb_comps,
                                                                                        p_should_go_on,
                                                                                        l_stream,
                                                                                        & l_codec->m_event_mgr);
          }
#line 575
          return (__cil_tmp13);
        }
      }
    }
  }
#line 586
  return (0);
}
}
#line 589 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 596
  if (p_codec) {
#line 596
    if (p_data) {
#line 596
      if (p_stream) {
#line 597
        l_codec = (opj_codec_private_t *)p_codec;
#line 598
        l_stream = (opj_stream_private_t *)p_stream;
#line 600
        if (! l_codec->is_decompressor) {
#line 601
          return (0);
        }
        {
#line 604
        __cil_tmp8 = (*(l_codec->m_codec_data.m_decompression.opj_decode_tile_data))(l_codec->m_codec,
                                                                                     p_tile_index,
                                                                                     p_data,
                                                                                     p_data_size,
                                                                                     l_stream,
                                                                                     & l_codec->m_event_mgr);
        }
#line 604
        return (__cil_tmp8);
      }
    }
  }
#line 612
  return (0);
}
}
#line 615 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 620
  if (p_codec) {
#line 620
    if (p_stream) {
#line 621
      l_codec = (opj_codec_private_t *)p_codec;
#line 622
      l_stream = (opj_stream_private_t *)p_stream;
#line 624
      if (! l_codec->is_decompressor) {
#line 625
        return (0);
      }
      {
#line 628
      __cil_tmp7 = (*(l_codec->m_codec_data.m_decompression.opj_get_decoded_tile))(l_codec->m_codec,
                                                                                   l_stream,
                                                                                   p_image,
                                                                                   & l_codec->m_event_mgr,
                                                                                   tile_index);
      }
#line 628
      return (__cil_tmp7);
    }
  }
#line 636
  return (0);
}
}
#line 639 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp4 ;

  {
#line 642
  l_codec = (opj_codec_private_t *)p_codec;
#line 644
  if (! l_codec) {
#line 645
    return (0);
  }
  {
#line 648
  __cil_tmp4 = (*(l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor))(l_codec->m_codec,
                                                                                            res_factor,
                                                                                            & l_codec->m_event_mgr);
  }
#line 648
  return (__cil_tmp4);
}
}
#line 657 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT p_format ) 
{ 
  opj_codec_private_t *l_codec ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 659
  l_codec = (opj_codec_private_t *)0;
#line 661
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codec_private_t ));
#line 661
  l_codec = (opj_codec_private_t *)__cil_tmp3;
  }
#line 662
  if (! l_codec) {
#line 663
    return ((opj_codec_t *)0);
  }
#line 666
  l_codec->is_decompressor = 0;
  {
#line 669
  if ((int )p_format == 0) {
#line 669
    goto case_0;
  }
#line 714
  if ((int )p_format == 2) {
#line 714
    goto case_2;
  }
#line 762
  goto switch_default;
  case_0: /* CIL Label */ 
#line 670
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_j2k_encode);
  {
#line 674
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_j2k_end_compress);
#line 678
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_j2k_start_compress);
#line 683
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_j2k_write_tile);
#line 690
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_j2k_destroy);
#line 693
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_j2k_setup_encoder);
#line 698
  l_codec->m_codec_data.m_compression.opj_encoder_set_extra_options = (OPJ_BOOL (*)(void * ,
                                                                                    char const   * const  * ,
                                                                                    struct opj_event_mgr * ))(& opj_j2k_encoder_set_extra_options);
#line 703
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_j2k_set_threads);
#line 706
  l_codec->m_codec = (void *)opj_j2k_create_compress();
  }
#line 707
  if (! l_codec->m_codec) {
    {
#line 708
    opj_free(l_codec);
    }
#line 709
    return ((opj_codec_t *)0);
  }
#line 712
  goto switch_break;
  case_2: /* CIL Label */ 
#line 716
  l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                 struct opj_event_mgr * ))(& opj_jp2_encode);
  {
#line 720
  l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*)(void * , struct opj_stream_private * ,
                                                                       struct opj_event_mgr * ))(& opj_jp2_end_compress);
#line 724
  l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*)(void * ,
                                                                         struct opj_stream_private * ,
                                                                         struct opj_image * ,
                                                                         struct opj_event_mgr * ))(& opj_jp2_start_compress);
#line 729
  l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*)(void * , OPJ_UINT32  ,
                                                                     OPJ_BYTE * ,
                                                                     OPJ_UINT32  ,
                                                                     struct opj_stream_private * ,
                                                                     struct opj_event_mgr * ))(& opj_jp2_write_tile);
#line 736
  l_codec->m_codec_data.m_compression.opj_destroy = (void (*)(void * ))(& opj_jp2_destroy);
#line 739
  l_codec->m_codec_data.m_compression.opj_setup_encoder = (OPJ_BOOL (*)(void * , opj_cparameters_t * ,
                                                                        struct opj_image * ,
                                                                        struct opj_event_mgr * ))(& opj_jp2_setup_encoder);
#line 744
  l_codec->m_codec_data.m_compression.opj_encoder_set_extra_options = (OPJ_BOOL (*)(void * ,
                                                                                    char const   * const  * ,
                                                                                    struct opj_event_mgr * ))(& opj_jp2_encoder_set_extra_options);
#line 749
  l_codec->opj_set_threads = (OPJ_BOOL (*)(void * , OPJ_UINT32  ))(& opj_jp2_set_threads);
#line 752
  l_codec->m_codec = (void *)opj_jp2_create(0);
  }
#line 753
  if (! l_codec->m_codec) {
    {
#line 754
    opj_free(l_codec);
    }
#line 755
    return ((opj_codec_t *)0);
  }
#line 758
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 763
  opj_free(l_codec);
  }
#line 764
  return ((opj_codec_t *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 767
  opj_set_default_event_handler(& l_codec->m_event_mgr);
  }
#line 768
  return ((opj_codec_t *)l_codec);
}
}
#line 771 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 774
  if (parameters) {
    {
#line 775
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 777
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 778
    parameters->rsiz = (OPJ_UINT16 )0;
#line 779
    parameters->max_comp_size = 0;
#line 780
    parameters->numresolution = 6;
#line 781
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 782
    parameters->cblockw_init = 64;
#line 783
    parameters->cblockh_init = 64;
#line 784
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 785
    parameters->roi_compno = - 1;
#line 786
    parameters->subsampling_dx = 1;
#line 787
    parameters->subsampling_dy = 1;
#line 788
    parameters->tp_on = (char )0;
#line 789
    parameters->decod_format = - 1;
#line 790
    parameters->cod_format = - 1;
#line 791
    parameters->tcp_rates[0] = (float )0;
#line 792
    parameters->tcp_numlayers = 0;
#line 793
    parameters->cp_disto_alloc = 0;
#line 794
    parameters->cp_fixed_alloc = 0;
#line 795
    parameters->cp_fixed_quality = 0;
#line 796
    parameters->jpip_on = 0;
    }
  }
  return;
}
}
#line 832 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *p_image ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 836
  if (p_codec) {
#line 836
    if (parameters) {
#line 836
      if (p_image) {
#line 837
        l_codec = (opj_codec_private_t *)p_codec;
#line 839
        if (! l_codec->is_decompressor) {
          {
#line 840
          __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_setup_encoder))(l_codec->m_codec,
                                                                                  parameters,
                                                                                  p_image,
                                                                                  & l_codec->m_event_mgr);
          }
#line 840
          return (__cil_tmp5);
        }
      }
    }
  }
#line 847
  return (0);
}
}
#line 852 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encoder_set_extra_options(opj_codec_t *p_codec , char const   * const  *options ) 
{ 
  opj_codec_private_t *l_codec ;
  OPJ_BOOL __cil_tmp4 ;

  {
#line 855
  if (p_codec) {
#line 856
    l_codec = (opj_codec_private_t *)p_codec;
#line 858
    if (! l_codec->is_decompressor) {
      {
#line 859
      __cil_tmp4 = (*(l_codec->m_codec_data.m_compression.opj_encoder_set_extra_options))(l_codec->m_codec,
                                                                                          options,
                                                                                          & l_codec->m_event_mgr);
      }
#line 859
      return (__cil_tmp4);
    }
  }
#line 866
  return (0);
}
}
#line 871 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 875
  if (p_codec) {
#line 875
    if (p_stream) {
#line 876
      l_codec = (opj_codec_private_t *)p_codec;
#line 877
      l_stream = (opj_stream_private_t *)p_stream;
#line 879
      if (! l_codec->is_decompressor) {
        {
#line 880
        __cil_tmp6 = (*(l_codec->m_codec_data.m_compression.opj_start_compress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 p_image,
                                                                                 & l_codec->m_event_mgr);
        }
#line 880
        return (__cil_tmp6);
      }
    }
  }
#line 887
  return (0);
}
}
#line 890 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_encode(opj_codec_t *p_info , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 892
  if (p_info) {
#line 892
    if (p_stream) {
#line 893
      l_codec = (opj_codec_private_t *)p_info;
#line 894
      l_stream = (opj_stream_private_t *)p_stream;
#line 896
      if (! l_codec->is_decompressor) {
        {
#line 897
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_encode))(l_codec->m_codec,
                                                                         l_stream,
                                                                         & l_codec->m_event_mgr);
        }
#line 897
        return (__cil_tmp5);
      }
    }
  }
#line 903
  return (0);
}
}
#line 907 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 910
  if (p_codec) {
#line 910
    if (p_stream) {
#line 911
      l_codec = (opj_codec_private_t *)p_codec;
#line 912
      l_stream = (opj_stream_private_t *)p_stream;
#line 914
      if (! l_codec->is_decompressor) {
        {
#line 915
        __cil_tmp5 = (*(l_codec->m_codec_data.m_compression.opj_end_compress))(l_codec->m_codec,
                                                                               l_stream,
                                                                               & l_codec->m_event_mgr);
        }
#line 915
        return (__cil_tmp5);
      }
    }
  }
#line 920
  return (0);
}
}
#line 924 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 927
  if (p_codec) {
#line 927
    if (p_stream) {
#line 928
      l_codec = (opj_codec_private_t *)p_codec;
#line 929
      l_stream = (opj_stream_private_t *)p_stream;
#line 931
      if (! l_codec->is_decompressor) {
#line 932
        return (0);
      }
      {
#line 935
      __cil_tmp5 = (*(l_codec->m_codec_data.m_decompression.opj_end_decompress))(l_codec->m_codec,
                                                                                 l_stream,
                                                                                 & l_codec->m_event_mgr);
      }
#line 935
      return (__cil_tmp5);
    }
  }
#line 941
  return (0);
}
}
#line 944 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) 
{ 
  OPJ_UINT32 l_matrix_size ;
  OPJ_UINT32 l_dc_shift_size ;
  OPJ_UINT32 l_mct_total_size ;
  void *__cil_tmp8 ;

  {
#line 948
  l_matrix_size = (pNbComp * pNbComp) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 949
  l_dc_shift_size = pNbComp * (OPJ_UINT32 )sizeof(OPJ_INT32 );
#line 950
  l_mct_total_size = l_matrix_size + l_dc_shift_size;
#line 953
  if ((int )parameters->rsiz & 32768) {
#line 954
    parameters->rsiz |= 256;
  } else {
#line 956
    parameters->rsiz = (OPJ_UINT16 )33024;
  }
  {
#line 958
  parameters->irreversible = 1;
#line 961
  parameters->tcp_mct = (char )2;
#line 962
  parameters->mct_data = opj_malloc((size_t )l_mct_total_size);
  }
#line 963
  if (! parameters->mct_data) {
#line 964
    return (0);
  }
  {
#line 967
  memcpy(parameters->mct_data, pEncodingMatrix, (unsigned long )l_matrix_size);
#line 968
  memcpy((OPJ_BYTE *)parameters->mct_data + l_matrix_size, p_dc_shift, (unsigned long )l_dc_shift_size);
  }
#line 971
  return (1);
}
}
#line 974 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_stream_private_t *l_stream ;
  OPJ_BOOL __cil_tmp8 ;

  {
#line 980
  if (p_codec) {
#line 980
    if (p_stream) {
#line 980
      if (p_data) {
#line 981
        l_codec = (opj_codec_private_t *)p_codec;
#line 982
        l_stream = (opj_stream_private_t *)p_stream;
#line 984
        if (l_codec->is_decompressor) {
#line 985
          return (0);
        }
        {
#line 988
        __cil_tmp8 = (*(l_codec->m_codec_data.m_compression.opj_write_tile))(l_codec->m_codec,
                                                                             p_tile_index,
                                                                             p_data,
                                                                             p_data_size,
                                                                             l_stream,
                                                                             & l_codec->m_event_mgr);
        }
#line 988
        return (__cil_tmp8);
      }
    }
  }
#line 996
  return (0);
}
}
#line 1001 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_destroy_codec(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 1003
  if (p_codec) {
#line 1004
    l_codec = (opj_codec_private_t *)p_codec;
#line 1006
    if (l_codec->is_decompressor) {
      {
#line 1007
      (*(l_codec->m_codec_data.m_decompression.opj_destroy))(l_codec->m_codec);
      }
    } else {
      {
#line 1009
      (*(l_codec->m_codec_data.m_compression.opj_destroy))(l_codec->m_codec);
      }
    }
    {
#line 1012
    l_codec->m_codec = (void *)0;
#line 1013
    opj_free(l_codec);
    }
  }
  return;
}
}
#line 1019 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) 
{ 
  opj_codec_private_t *l_codec ;

  {
#line 1023
  if (p_codec) {
    {
#line 1024
    l_codec = (opj_codec_private_t *)p_codec;
#line 1026
    (*(l_codec->opj_dump_codec))(l_codec->m_codec, info_flag, output_stream);
    }
#line 1027
    return;
  }
#line 1032
  return;
}
}
#line 1035 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_info_v2_t *__cil_tmp3 ;

  {
#line 1037
  if (p_codec) {
    {
#line 1038
    l_codec = (opj_codec_private_t *)p_codec;
#line 1040
    __cil_tmp3 = (*(l_codec->opj_get_codec_info))(l_codec->m_codec);
    }
#line 1040
    return (__cil_tmp3);
  }
#line 1043
  return ((opj_codestream_info_v2_t *)((void *)0));
}
}
#line 1046 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) 
{ 


  {
#line 1048
  if (cstr_info) {
#line 1050
    if ((*cstr_info)->m_default_tile_info.tccp_info) {
      {
#line 1051
      opj_free((*cstr_info)->m_default_tile_info.tccp_info);
      }
    }
#line 1054
    if ((*cstr_info)->tile_info) {

    }
    {
#line 1058
    opj_free(*cstr_info);
#line 1059
    *cstr_info = (opj_codestream_info_v2_t *)((void *)0);
    }
  }
  return;
}
}
#line 1063 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) 
{ 
  opj_codec_private_t *l_codec ;
  opj_codestream_index_t *__cil_tmp3 ;

  {
#line 1065
  if (p_codec) {
    {
#line 1066
    l_codec = (opj_codec_private_t *)p_codec;
#line 1068
    __cil_tmp3 = (*(l_codec->opj_get_codec_index))(l_codec->m_codec);
    }
#line 1068
    return (__cil_tmp3);
  }
#line 1071
  return ((opj_codestream_index_t *)((void *)0));
}
}
#line 1074 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) 
{ 


  {
#line 1076
  if (*p_cstr_index) {
    {
#line 1077
    j2k_destroy_cstr_index(*p_cstr_index);
#line 1078
    *p_cstr_index = (opj_codestream_index_t *)((void *)0);
    }
  }
  return;
}
}
#line 1082 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *__cil_tmp3 ;

  {
  {
#line 1085
  __cil_tmp3 = opj_stream_create_file_stream(fname, (OPJ_SIZE_T )1048576, p_is_read_stream);
  }
#line 1085
  return (__cil_tmp3);
}
}
#line 1089 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_size ,
                                            OPJ_BOOL p_is_read_stream ) 
{ 
  opj_stream_t *l_stream ;
  FILE *p_file ;
  char const   *mode ;
  FILE *__cil_tmp7 ;
  opj_stream_t *__cil_tmp8 ;
  OPJ_UINT64 __cil_tmp9 ;

  {
#line 1094
  l_stream = (opj_stream_t *)0;
#line 1098
  if (! fname) {
#line 1099
    return ((opj_stream_t *)((void *)0));
  }
#line 1102
  if (p_is_read_stream) {
#line 1103
    mode = "rb";
  } else {
#line 1105
    mode = "wb";
  }
  {
#line 1108
  p_file = fopen(fname, mode);
  }
#line 1110
  if (! p_file) {
#line 1111
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1114
  l_stream = opj_stream_create(p_size, p_is_read_stream);
  }
#line 1115
  if (! l_stream) {
    {
#line 1116
    fclose(p_file);
    }
#line 1117
    return ((opj_stream_t *)((void *)0));
  }
  {
#line 1120
  opj_stream_set_user_data(l_stream, p_file, & opj_close_from_file);
#line 1121
  __cil_tmp9 = opj_get_data_length_from_file(p_file);
#line 1121
  opj_stream_set_user_data_length(l_stream, __cil_tmp9);
#line 1123
  opj_stream_set_read_function(l_stream, & opj_read_from_file);
#line 1124
  opj_stream_set_write_function(l_stream, (opj_stream_write_fn )(& opj_write_from_file));
#line 1126
  opj_stream_set_skip_function(l_stream, & opj_skip_from_file);
#line 1127
  opj_stream_set_seek_function(l_stream, & opj_seek_from_file);
  }
#line 1129
  return (l_stream);
}
}
#line 1133 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void *opj_image_data_alloc(OPJ_SIZE_T size ) 
{ 
  void *ret ;
  void *__cil_tmp3 ;

  {
  {
#line 1135
  __cil_tmp3 = opj_aligned_malloc(size);
#line 1135
  ret = __cil_tmp3;
  }
#line 1137
  return (ret);
}
}
#line 1140 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.c"
void opj_image_data_free(void *ptr ) 
{ 


  {
  {
#line 1143
  opj_aligned_free(ptr);
  }
  return;
}
}
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
static void opj_mqc_setbits(opj_mqc_t *mqc ) ;
#line 61 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 61
  {      {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[2], & mqc_states[3]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[3], & mqc_states[2]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[4], & mqc_states[12]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[5], & mqc_states[13]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[6], & mqc_states[18]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[7], & mqc_states[19]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[8], & mqc_states[24]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[9], & mqc_states[25]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[10], & mqc_states[58]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[11], & mqc_states[59]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[66]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[67]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[14], & mqc_states[13]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[15], & mqc_states[12]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[16], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[17], & mqc_states[29]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[18], & mqc_states[28]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[19], & mqc_states[29]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[20], & mqc_states[28]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[21], & mqc_states[29]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[22], & mqc_states[34]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[23], & mqc_states[35]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[24], & mqc_states[36]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[25], & mqc_states[37]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[26], & mqc_states[40]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[27], & mqc_states[41]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[42]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[43]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[30], & mqc_states[29]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[31], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )0, & mqc_states[32], & mqc_states[28]}, 
        {(OPJ_UINT32 )21505, (OPJ_UINT32 )1, & mqc_states[33], & mqc_states[29]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )0, & mqc_states[34], & mqc_states[30]}, 
        {(OPJ_UINT32 )20737, (OPJ_UINT32 )1, & mqc_states[35], & mqc_states[31]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )0, & mqc_states[36], & mqc_states[32]}, 
        {(OPJ_UINT32 )18433, (OPJ_UINT32 )1, & mqc_states[37], & mqc_states[33]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )0, & mqc_states[38], & mqc_states[34]}, 
        {(OPJ_UINT32 )14337, (OPJ_UINT32 )1, & mqc_states[39], & mqc_states[35]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )0, & mqc_states[40], & mqc_states[36]}, 
        {(OPJ_UINT32 )13313, (OPJ_UINT32 )1, & mqc_states[41], & mqc_states[37]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )0, & mqc_states[42], & mqc_states[38]}, 
        {(OPJ_UINT32 )12289, (OPJ_UINT32 )1, & mqc_states[43], & mqc_states[39]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )0, & mqc_states[44], & mqc_states[38]}, 
        {(OPJ_UINT32 )10241, (OPJ_UINT32 )1, & mqc_states[45], & mqc_states[39]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )0, & mqc_states[46], & mqc_states[40]}, 
        {(OPJ_UINT32 )9217, (OPJ_UINT32 )1, & mqc_states[47], & mqc_states[41]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )0, & mqc_states[48], & mqc_states[42]}, 
        {(OPJ_UINT32 )8705, (OPJ_UINT32 )1, & mqc_states[49], & mqc_states[43]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )0, & mqc_states[50], & mqc_states[44]}, 
        {(OPJ_UINT32 )7169, (OPJ_UINT32 )1, & mqc_states[51], & mqc_states[45]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )0, & mqc_states[52], & mqc_states[46]}, 
        {(OPJ_UINT32 )6145, (OPJ_UINT32 )1, & mqc_states[53], & mqc_states[47]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )0, & mqc_states[54], & mqc_states[48]}, 
        {(OPJ_UINT32 )5633, (OPJ_UINT32 )1, & mqc_states[55], & mqc_states[49]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )0, & mqc_states[56], & mqc_states[50]}, 
        {(OPJ_UINT32 )5121, (OPJ_UINT32 )1, & mqc_states[57], & mqc_states[51]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )0, & mqc_states[58], & mqc_states[52]}, 
        {(OPJ_UINT32 )4609, (OPJ_UINT32 )1, & mqc_states[59], & mqc_states[53]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )0, & mqc_states[60], & mqc_states[54]}, 
        {(OPJ_UINT32 )4353, (OPJ_UINT32 )1, & mqc_states[61], & mqc_states[55]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )0, & mqc_states[62], & mqc_states[56]}, 
        {(OPJ_UINT32 )2753, (OPJ_UINT32 )1, & mqc_states[63], & mqc_states[57]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )0, & mqc_states[64], & mqc_states[58]}, 
        {(OPJ_UINT32 )2497, (OPJ_UINT32 )1, & mqc_states[65], & mqc_states[59]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )0, & mqc_states[66], & mqc_states[60]}, 
        {(OPJ_UINT32 )2209, (OPJ_UINT32 )1, & mqc_states[67], & mqc_states[61]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )0, & mqc_states[68], & mqc_states[62]}, 
        {(OPJ_UINT32 )1313, (OPJ_UINT32 )1, & mqc_states[69], & mqc_states[63]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )0, & mqc_states[70], & mqc_states[64]}, 
        {(OPJ_UINT32 )1089, (OPJ_UINT32 )1, & mqc_states[71], & mqc_states[65]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )0, & mqc_states[72], & mqc_states[66]}, 
        {(OPJ_UINT32 )673, (OPJ_UINT32 )1, & mqc_states[73], & mqc_states[67]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )0, & mqc_states[74], & mqc_states[68]}, 
        {(OPJ_UINT32 )545, (OPJ_UINT32 )1, & mqc_states[75], & mqc_states[69]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )0, & mqc_states[76], & mqc_states[70]}, 
        {(OPJ_UINT32 )321, (OPJ_UINT32 )1, & mqc_states[77], & mqc_states[71]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )0, & mqc_states[78], & mqc_states[72]}, 
        {(OPJ_UINT32 )273, (OPJ_UINT32 )1, & mqc_states[79], & mqc_states[73]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )0, & mqc_states[80], & mqc_states[74]}, 
        {(OPJ_UINT32 )133, (OPJ_UINT32 )1, & mqc_states[81], & mqc_states[75]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )0, & mqc_states[82], & mqc_states[76]}, 
        {(OPJ_UINT32 )73, (OPJ_UINT32 )1, & mqc_states[83], & mqc_states[77]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )0, & mqc_states[84], & mqc_states[78]}, 
        {(OPJ_UINT32 )37, (OPJ_UINT32 )1, & mqc_states[85], & mqc_states[79]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )0, & mqc_states[86], & mqc_states[80]}, 
        {(OPJ_UINT32 )21, (OPJ_UINT32 )1, & mqc_states[87], & mqc_states[81]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )0, & mqc_states[88], & mqc_states[82]}, 
        {(OPJ_UINT32 )9, (OPJ_UINT32 )1, & mqc_states[89], & mqc_states[83]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[84]}, 
        {(OPJ_UINT32 )5, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[85]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )0, & mqc_states[90], & mqc_states[86]}, 
        {(OPJ_UINT32 )1, (OPJ_UINT32 )1, & mqc_states[91], & mqc_states[87]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )0, & mqc_states[92], & mqc_states[92]}, 
        {(OPJ_UINT32 )22017, (OPJ_UINT32 )1, & mqc_states[93], & mqc_states[93]}};
#line 164 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
static void opj_mqc_setbits(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 tempc ;

  {
#line 166
  tempc = mqc->c + mqc->a;
#line 167
  mqc->c |= (unsigned int )65535;
#line 168
  if (mqc->c >= tempc) {
#line 169
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 179 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) 
{ 
  ptrdiff_t diff ;

  {
#line 181
  diff = mqc->bp - mqc->start;
#line 185
  return ((OPJ_UINT32 )diff);
}
}
#line 188 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) 
{ 


  {
#line 192
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 196
  mqc->a = (OPJ_UINT32 )32768;
#line 197
  mqc->c = (OPJ_UINT32 )0;
#line 200
  mqc->bp = bp - 1;
#line 201
  mqc->ct = (OPJ_UINT32 )12;
#line 207
  mqc->start = bp;
#line 208
  mqc->end_of_byte_stream_counter = (OPJ_UINT32 )0;
  return;
}
}
#line 212 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_flush(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
  {
#line 216
  opj_mqc_setbits(mqc);
#line 217
  mqc->c <<= mqc->ct;
#line 218
  opj_mqc_byteout(mqc);
#line 219
  mqc->c <<= mqc->ct;
#line 220
  opj_mqc_byteout(mqc);
  }
#line 223
  if ((int )*(mqc->bp) != 255) {
#line 225
    (mqc->bp) ++;
  }
  return;
}
}
#line 229 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 235
  mqc->c = (OPJ_UINT32 )0;
#line 241
  mqc->ct = 3735928559U;
  return;
}
}
#line 247 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;

  {
#line 249
  if (mqc->ct == 3735928559U) {
#line 250
    mqc->ct = (OPJ_UINT32 )8;
  }
#line 252
  __cil_tmp3 = mqc->ct;
#line 252
  (mqc->ct) --;
#line 253
  mqc->c += d << mqc->ct;
#line 254
  if (mqc->ct == 0U) {
#line 255
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 256
    mqc->ct = (OPJ_UINT32 )8;
#line 258
    if ((int )*(mqc->bp) == 255) {
#line 259
      mqc->ct = (OPJ_UINT32 )7;
    }
#line 261
    (mqc->bp) ++;
#line 262
    mqc->c = (OPJ_UINT32 )0;
  }
  return;
}
}
#line 266 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc , OPJ_BOOL erterm ) 
{ 
  int tmp ;

  {
#line 268
  if (mqc->ct < 7U || (mqc->ct == 7U && (erterm || (int )*(mqc->bp + -1) != 255))) {
#line 268
    tmp = 1;
  } else {
#line 268
    tmp = 0;
  }
#line 268
  return ((OPJ_UINT32 )tmp);
}
}
#line 272 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc , OPJ_BOOL erterm ) 
{ 
  OPJ_BYTE bit_value ;
  OPJ_UINT32 __cil_tmp4 ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 280
  if (mqc->ct < 7U) {
    _L___11: /* CIL Label */ 
#line 281
    bit_value = (OPJ_BYTE )0;
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
#line 286
      if (! (mqc->ct > 0U)) {
#line 286
        goto while_break;
      }
#line 287
      __cil_tmp4 = mqc->ct;
#line 287
      (mqc->ct) --;
#line 288
      mqc->c += (OPJ_UINT32 )((int )bit_value << mqc->ct);
#line 289
      bit_value = (OPJ_BYTE )(1U - (unsigned int )bit_value);
    }
    while_break: /* CIL Label */ ;
    }
#line 291
    *(mqc->bp) = (OPJ_BYTE )mqc->c;
#line 293
    (mqc->bp) ++;
  } else
#line 280
  if (mqc->ct == 7U) {
#line 280
    if (erterm) {
#line 280
      goto _L___11;
    } else
#line 280
    if ((int )*(mqc->bp + -1) != 255) {
#line 280
      goto _L___11;
    } else {
#line 280
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
#line 294
  if (mqc->ct == 7U) {
#line 294
    if ((int )*(mqc->bp + -1) == 255) {
#line 297
      __cil_tmp6 = mqc->bp;
#line 297
      (mqc->bp) --;
    } else {
#line 294
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 298
  if (mqc->ct == 8U) {
#line 298
    if (! erterm) {
#line 298
      if ((int )*(mqc->bp + -1) == 127) {
#line 298
        if ((int )*(mqc->bp + -2) == 255) {
#line 304
          mqc->bp -= 2;
        }
      }
    }
  }
  return;
}
}
#line 310 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 312
  opj_mqc_resetstates(mqc);
#line 313
  opj_mqc_setstate(mqc, (OPJ_UINT32 )18, (OPJ_UINT32 )0, 46);
#line 314
  opj_mqc_setstate(mqc, (OPJ_UINT32 )17, (OPJ_UINT32 )0, 3);
#line 315
  opj_mqc_setstate(mqc, (OPJ_UINT32 )0, (OPJ_UINT32 )0, 4);
  }
  return;
}
}
#line 337 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;

  {
#line 343
  mqc->a = (OPJ_UINT32 )32768;
#line 344
  mqc->c = (OPJ_UINT32 )0;
#line 345
  mqc->ct = (OPJ_UINT32 )12;
#line 349
  __cil_tmp2 = mqc->bp;
#line 349
  (mqc->bp) --;
#line 352
  if ((int )*(mqc->bp) == 255) {
#line 353
    mqc->ct = (OPJ_UINT32 )13;
  }
  return;
}
}
#line 357 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_INT32 k ;

  {
#line 359
  k = (OPJ_INT32 )((11U - mqc->ct) + 1U);
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (k > 0)) {
#line 361
      goto while_break;
    }
    {
#line 362
    mqc->c <<= mqc->ct;
#line 363
    mqc->ct = (OPJ_UINT32 )0;
#line 364
    opj_mqc_byteout(mqc);
#line 365
    k -= (OPJ_INT32 )mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if ((int )*(mqc->bp) != 255) {
    {
#line 369
    opj_mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 373 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_renorme(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    mqc->a <<= 1;
#line 375
    mqc->c <<= 1;
#line 375
    __cil_tmp2 = mqc->ct;
#line 375
    (mqc->ct) --;
#line 375
    if (mqc->ct == 0U) {
      {
#line 375
      mqc->c = mqc->c;
#line 375
      opj_mqc_byteout(mqc);
#line 375
      mqc->c = mqc->c;
#line 375
      mqc->ct = mqc->ct;
      }
    }
#line 375
    if (! ((mqc->a & 32768U) == 0U)) {
#line 375
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 382 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_codemps(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 384
  mqc->a -= (*(mqc->curctx))->qeval;
#line 384
  if ((mqc->a & 32768U) == 0U) {
#line 384
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 384
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 384
      mqc->c += (*(mqc->curctx))->qeval;
    }
#line 384
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
    {
#line 384
    while (1) {
      while_continue: /* CIL Label */ ;
#line 384
      mqc->a <<= 1;
#line 384
      mqc->c <<= 1;
#line 384
      __cil_tmp2 = mqc->ct;
#line 384
      (mqc->ct) --;
#line 384
      if (mqc->ct == 0U) {
        {
#line 384
        mqc->c = mqc->c;
#line 384
        opj_mqc_byteout(mqc);
#line 384
        mqc->c = mqc->c;
#line 384
        mqc->ct = mqc->ct;
        }
      }
#line 384
      if (! ((mqc->a & 32768U) == 0U)) {
#line 384
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }

  } else {
#line 384
    mqc->c += (*(mqc->curctx))->qeval;
  }

  return;
}
}
#line 391 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_codelps(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 393
  mqc->a -= (*(mqc->curctx))->qeval;
#line 393
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 393
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 393
    mqc->a = (*(mqc->curctx))->qeval;
  }
#line 393
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    mqc->a <<= 1;
#line 393
    mqc->c <<= 1;
#line 393
    __cil_tmp2 = mqc->ct;
#line 393
    (mqc->ct) --;
#line 393
    if (mqc->ct == 0U) {
      {
#line 393
      mqc->c = mqc->c;
#line 393
      opj_mqc_byteout(mqc);
#line 393
      mqc->c = mqc->c;
#line 393
      mqc->ct = mqc->ct;
      }
    }
#line 393
    if (! ((mqc->a & 32768U) == 0U)) {
#line 393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 401 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
__inline static void opj_mqc_encode(opj_mqc_t *mqc , OPJ_UINT32 d ) 
{ 


  {
#line 403
  if ((*(mqc->curctx))->mps == d) {
    {
#line 404
    opj_mqc_codemps(mqc);
    }
  } else {
    {
#line 406
    opj_mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 410 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 413
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )18];
#line 415
  i = (OPJ_UINT32 )1;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < 5U)) {
#line 415
      goto while_break;
    }
    {
#line 416
    opj_mqc_encode(mqc, i % 2U);
    }
#line 415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 420 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
static void opj_mqc_init_dec_common(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len ,
                                    OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 428
  mqc->start = bp;
#line 429
  mqc->end = bp + len;
#line 434
  memcpy((OPJ_BYTE *)mqc->backup, mqc->end, (unsigned long )2);
#line 435
  *(mqc->end + 0) = (OPJ_BYTE )255;
#line 436
  *(mqc->end + 1) = (OPJ_BYTE )255;
#line 437
  mqc->bp = bp;
  }
  return;
}
}
#line 439 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 447
  opj_mqc_init_dec_common(mqc, bp, len, extra_writable_bytes);
#line 448
  mqc->curctx = & mqc->ctxs[(OPJ_UINT32 )0];
#line 449
  mqc->end_of_byte_stream_counter = (OPJ_UINT32 )0;
  }
#line 450
  if (len == 0U) {
#line 451
    mqc->c = (OPJ_UINT32 )(255 << 16);
  } else {
#line 453
    mqc->c = (OPJ_UINT32 )((int )*(mqc->bp) << 16);
  }
  {
#line 456
  opj_mqc_bytein(mqc);
#line 457
  mqc->c <<= 7;
#line 458
  mqc->ct -= (unsigned int )7;
#line 459
  mqc->a = (OPJ_UINT32 )32768;
  }
  return;
}
}
#line 463 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_raw_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) 
{ 


  {
  {
#line 466
  opj_mqc_init_dec_common(mqc, bp, len, extra_writable_bytes);
#line 467
  mqc->c = (OPJ_UINT32 )0;
#line 468
  mqc->ct = (OPJ_UINT32 )0;
  }
  return;
}
}
#line 472 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opq_mqc_finish_dec(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 475
  memcpy(mqc->end, (OPJ_BYTE *)mqc->backup, (unsigned long )2);
  }
  return;
}
}
#line 478 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 481
  i = (OPJ_UINT32 )0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < 19U)) {
#line 481
      goto while_break;
    }
#line 482
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 486 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) 
{ 


  {
#line 489
  mqc->ctxs[ctxno] = & mqc_states[msb + (OPJ_UINT32 )(prob << 1)];
  return;
}
}
#line 492 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.c"
void opj_mqc_byteout(opj_mqc_t *mqc ) 
{ 
  OPJ_BYTE *__cil_tmp2 ;
  OPJ_BYTE *__cil_tmp3 ;
  OPJ_BYTE __cil_tmp4 ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 497
  if ((int )*(mqc->bp) == 255) {
#line 498
    (mqc->bp) ++;
#line 499
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 500
    mqc->c &= (unsigned int )1048575;
#line 501
    mqc->ct = (OPJ_UINT32 )7;
  } else
#line 503
  if ((mqc->c & 134217728U) == 0U) {
#line 504
    (mqc->bp) ++;
#line 505
    *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 506
    mqc->c &= (unsigned int )524287;
#line 507
    mqc->ct = (OPJ_UINT32 )8;
  } else {
#line 509
    (*(mqc->bp)) ++;
#line 510
    if ((int )*(mqc->bp) == 255) {
#line 511
      mqc->c &= (unsigned int )134217727;
#line 512
      (mqc->bp) ++;
#line 513
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 20);
#line 514
      mqc->c &= (unsigned int )1048575;
#line 515
      mqc->ct = (OPJ_UINT32 )7;
    } else {
#line 517
      (mqc->bp) ++;
#line 518
      *(mqc->bp) = (OPJ_BYTE )(mqc->c >> 19);
#line 519
      mqc->c &= (unsigned int )524287;
#line 520
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
  return;
}
}
#line 64 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager ) ;
#line 77
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 88
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 101
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 106
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager ) ;
#line 111
static void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *manager ) ;
#line 122
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 133
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) ;
#line 145
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 159
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 164
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 178
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) ;
#line 192
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 205
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 251
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) ;
#line 265
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 276
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *p_manager ) ;
#line 280
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) ;
#line 292
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager ) ;
#line 308
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager ) ;
#line 323
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager ) ;
#line 336
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 343
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 355
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 369
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 384
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 393
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 399
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 402
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio ,
                                           opj_event_mgr_t *p_manager ) ;
#line 413
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) ;
#line 423
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) ;
#line 425 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_header[3]  = {      {(OPJ_UINT32 )1783636000, & opj_jp2_read_jp}, 
        {(OPJ_UINT32 )1718909296, & opj_jp2_read_ftyp}, 
        {(OPJ_UINT32 )1785737832, & opj_jp2_read_jp2h}};
#line 431 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t jp2_img_header[6]  = {      {(OPJ_UINT32 )1768449138, & opj_jp2_read_ihdr}, 
        {(OPJ_UINT32 )1668246642, & opj_jp2_read_colr}, 
        {(OPJ_UINT32 )1651532643, & opj_jp2_read_bpcc}, 
        {(OPJ_UINT32 )1885564018, & opj_jp2_read_pclr}, 
        {(OPJ_UINT32 )1668112752, & opj_jp2_read_cmap}, 
        {(OPJ_UINT32 )1667523942, & opj_jp2_read_cdef}};
#line 452
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                         OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) ;
#line 462
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 469
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) ;
#line 473 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box , OPJ_UINT32 *p_number_bytes_read ,
                                    opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data_header[8] ;
  OPJ_SIZE_T __cil_tmp6 ;
  OPJ_OFF_T bleft ;
  OPJ_OFF_T __cil_tmp8 ;
  OPJ_UINT32 l_xl_part_size ;
  OPJ_UINT32 l_nb_bytes_read ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 487
  __cil_tmp6 = opj_stream_read_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                    p_manager);
#line 487
  *p_number_bytes_read = (OPJ_UINT32 )__cil_tmp6;
  }
#line 489
  if (*p_number_bytes_read != 8U) {
#line 490
    return (0);
  }
  {
#line 494
  opj_read_bytes_LE((OPJ_BYTE *)l_data_header, & box->length, (OPJ_UINT32 )4);
#line 495
  opj_read_bytes_LE((OPJ_BYTE *)l_data_header + 4, & box->type, (OPJ_UINT32 )4);
  }
#line 497
  if (box->length == 0U) {
    {
#line 498
    __cil_tmp8 = opj_stream_get_number_byte_left(cio);
#line 498
    bleft = __cil_tmp8;
    }
#line 499
    if (bleft > 4294967287L) {
      {
#line 500
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 502
      return (0);
    }
#line 504
    box->length = (OPJ_UINT32 )bleft + 8U;
#line 506
    return (1);
  }
#line 511
  if (box->length == 1U) {
    {
#line 514
    __cil_tmp11 = opj_stream_read_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                       p_manager);
#line 514
    l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp11;
    }
#line 516
    if (l_nb_bytes_read != 8U) {
#line 517
      if (l_nb_bytes_read > 0U) {
#line 518
        *p_number_bytes_read += l_nb_bytes_read;
      }
#line 521
      return (0);
    }
    {
#line 524
    *p_number_bytes_read = (OPJ_UINT32 )16;
#line 525
    opj_read_bytes_LE((OPJ_BYTE *)l_data_header, & l_xl_part_size, (OPJ_UINT32 )4);
    }
#line 526
    if (l_xl_part_size != 0U) {
      {
#line 527
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 529
      return (0);
    }
    {
#line 531
    opj_read_bytes_LE((OPJ_BYTE *)l_data_header + 4, & box->length, (OPJ_UINT32 )4);
    }
  }
#line 533
  return (1);
}
}
#line 561 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ihdr(opj_jp2_t *jp2 , OPJ_BYTE *p_image_header_data ,
                                  OPJ_UINT32 p_image_header_size , opj_event_mgr_t *p_manager ) 
{ 
  void *__cil_tmp5 ;

  {
#line 571
  if (jp2->comps != (void *)0) {
    {
#line 572
    opj_event_msg(p_manager, 2, "Ignoring ihdr box. First ihdr box already read\n");
    }
#line 574
    return (1);
  }
#line 577
  if (p_image_header_size != 14U) {
    {
#line 578
    opj_event_msg(p_manager, 1, "Bad image header box (bad size)\n\220");
    }
#line 579
    return (0);
  }
  {
#line 582
  opj_read_bytes_LE(p_image_header_data, & jp2->h, (OPJ_UINT32 )4);
#line 583
  p_image_header_data += 4;
#line 584
  opj_read_bytes_LE(p_image_header_data, & jp2->w, (OPJ_UINT32 )4);
#line 585
  p_image_header_data += 4;
#line 586
  opj_read_bytes_LE(p_image_header_data, & jp2->numcomps, (OPJ_UINT32 )2);
#line 587
  p_image_header_data += 2;
  }
#line 589
  if (jp2->h < 1U) {
    {
    {
    {
#line 590
    opj_event_msg(p_manager, 1, "Wrong values for: w(%d) h(%d) numcomps(%d) (ihdr)\n",
                  jp2->w, jp2->h, jp2->numcomps);
    }
    }
    }
#line 593
    return (0);
  } else
#line 589
  if (jp2->w < 1U) {
    {
    {
    {
#line 590
    opj_event_msg(p_manager, 1, "Wrong values for: w(%d) h(%d) numcomps(%d) (ihdr)\n",
                  jp2->w, jp2->h, jp2->numcomps);
    }
    }
    }
#line 593
    return (0);
  } else
#line 589
  if (jp2->numcomps < 1U) {
    {
    {
    {
#line 590
    opj_event_msg(p_manager, 1, "Wrong values for: w(%d) h(%d) numcomps(%d) (ihdr)\n",
                  jp2->w, jp2->h, jp2->numcomps);
    }
    }
    }
#line 593
    return (0);
  }
#line 595
  if (jp2->numcomps - 1U >= 16384U) {
    {
#line 597
    opj_event_msg(p_manager, 1, "Invalid number of components (ihdr)\n");
    }
#line 598
    return (0);
  }
  {
#line 602
  __cil_tmp5 = opj_calloc((size_t )jp2->numcomps, sizeof(opj_jp2_comps_t ));
#line 602
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp5;
  }
#line 604
  if (jp2->comps == (opj_jp2_comps_t *)0) {
    {
#line 605
    opj_event_msg(p_manager, 1, "Not enough memory to handle image header (ihdr)\n\220");
    }
#line 607
    return (0);
  }
  {
#line 610
  opj_read_bytes_LE(p_image_header_data, & jp2->bpc, (OPJ_UINT32 )1);
#line 611
  p_image_header_data ++;
#line 613
  opj_read_bytes_LE(p_image_header_data, & jp2->C, (OPJ_UINT32 )1);
#line 614
  p_image_header_data ++;
  }
#line 617
  if (jp2->C != 7U) {
    {
#line 618
    opj_event_msg(p_manager, 4, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n",
                  jp2->C);
    }
  }
  {
#line 623
  opj_read_bytes_LE(p_image_header_data, & jp2->UnkC, (OPJ_UINT32 )1);
#line 624
  p_image_header_data ++;
#line 625
  opj_read_bytes_LE(p_image_header_data, & jp2->IPR, (OPJ_UINT32 )1);
#line 626
  p_image_header_data ++;
#line 628
  (jp2->j2k)->m_cp.allow_different_bit_depth_sign = jp2->bpc == 255U;
#line 629
  (jp2->j2k)->ihdr_w = jp2->w;
#line 630
  (jp2->j2k)->ihdr_h = jp2->h;
#line 631
  jp2->has_ihdr = (OPJ_BYTE )1;
  }
#line 633
  return (1);
}
}
#line 636 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_ihdr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_BYTE *l_ihdr_data ;
  OPJ_BYTE *l_current_ihdr_ptr ;
  void *__cil_tmp5 ;

  {
  {
#line 647
  __cil_tmp5 = opj_calloc((size_t )1, (size_t )22);
#line 647
  l_ihdr_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 648
  if (l_ihdr_data == (OPJ_BYTE *)0) {
#line 649
    return ((OPJ_BYTE *)0);
  }
  {
#line 652
  l_current_ihdr_ptr = l_ihdr_data;
#line 654
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )22, (OPJ_UINT32 )4);
#line 655
  l_current_ihdr_ptr += 4;
#line 657
  opj_write_bytes_LE(l_current_ihdr_ptr, (OPJ_UINT32 )1768449138, (OPJ_UINT32 )4);
#line 658
  l_current_ihdr_ptr += 4;
#line 660
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->h, (OPJ_UINT32 )4);
#line 661
  l_current_ihdr_ptr += 4;
#line 663
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->w, (OPJ_UINT32 )4);
#line 664
  l_current_ihdr_ptr += 4;
#line 666
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->numcomps, (OPJ_UINT32 )2);
#line 667
  l_current_ihdr_ptr += 2;
#line 669
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->bpc, (OPJ_UINT32 )1);
#line 670
  l_current_ihdr_ptr ++;
#line 672
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->C, (OPJ_UINT32 )1);
#line 673
  l_current_ihdr_ptr ++;
#line 675
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->UnkC, (OPJ_UINT32 )1);
#line 677
  l_current_ihdr_ptr ++;
#line 679
  opj_write_bytes_LE(l_current_ihdr_ptr, jp2->IPR, (OPJ_UINT32 )1);
#line 681
  l_current_ihdr_ptr ++;
#line 683
  *p_nb_bytes_written = (OPJ_UINT32 )22;
  }
#line 685
  return (l_ihdr_data);
}
}
#line 688 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_bpcc(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_bpcc_size ;
  OPJ_BYTE *l_bpcc_data ;
  OPJ_BYTE *l_current_bpcc_ptr ;
  void *__cil_tmp7 ;

  {
  {
#line 700
  l_bpcc_size = 8U + jp2->numcomps;
#line 702
  __cil_tmp7 = opj_calloc((size_t )1, (size_t )l_bpcc_size);
#line 702
  l_bpcc_data = (OPJ_BYTE *)__cil_tmp7;
  }
#line 703
  if (l_bpcc_data == (OPJ_BYTE *)0) {
#line 704
    return ((OPJ_BYTE *)0);
  }
  {
#line 707
  l_current_bpcc_ptr = l_bpcc_data;
#line 709
  opj_write_bytes_LE(l_current_bpcc_ptr, l_bpcc_size, (OPJ_UINT32 )4);
#line 711
  l_current_bpcc_ptr += 4;
#line 713
  opj_write_bytes_LE(l_current_bpcc_ptr, (OPJ_UINT32 )1651532643, (OPJ_UINT32 )4);
#line 714
  l_current_bpcc_ptr += 4;
#line 716
  i = (OPJ_UINT32 )0;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < jp2->numcomps)) {
#line 716
      goto while_break;
    }
    {
#line 717
    opj_write_bytes_LE(l_current_bpcc_ptr, (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 719
    l_current_bpcc_ptr ++;
    }
#line 716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 722
  *p_nb_bytes_written = l_bpcc_size;
#line 724
  return (l_bpcc_data);
}
}
#line 727 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_bpcc(opj_jp2_t *jp2 , OPJ_BYTE *p_bpc_header_data , OPJ_UINT32 p_bpc_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;

  {
#line 741
  if (jp2->bpc != 255U) {
    {
#line 742
    opj_event_msg(p_manager, 2, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n\240R~EV",
                  jp2->bpc);
    }
  }
#line 748
  if (p_bpc_header_size != jp2->numcomps) {
    {
#line 749
    opj_event_msg(p_manager, 1, "Bad BPCC header box (bad size)\n");
    }
#line 750
    return (0);
  }
#line 754
  i = (OPJ_UINT32 )0;
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (i < jp2->numcomps)) {
#line 754
      goto while_break;
    }
    {
#line 755
    opj_read_bytes_LE(p_bpc_header_data, & (jp2->comps + i)->bpcc, (OPJ_UINT32 )1);
#line 757
    p_bpc_header_data ++;
    }
#line 754
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  return (1);
}
}
#line 762 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_cdef(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_cdef_size ;
  OPJ_BYTE *l_cdef_data ;
  OPJ_BYTE *l_current_cdef_ptr ;
  OPJ_UINT32 l_value ;
  OPJ_UINT16 i ;
  void *__cil_tmp8 ;

  {
  {
#line 766
  l_cdef_size = (OPJ_UINT32 )10;
#line 778
  l_cdef_size += 6U * (unsigned int )(jp2->color.jp2_cdef)->n;
#line 780
  __cil_tmp8 = opj_malloc((size_t )l_cdef_size);
#line 780
  l_cdef_data = (OPJ_BYTE *)__cil_tmp8;
  }
#line 781
  if (l_cdef_data == (OPJ_BYTE *)0) {
#line 782
    return ((OPJ_BYTE *)0);
  }
  {
#line 785
  l_current_cdef_ptr = l_cdef_data;
#line 787
  opj_write_bytes_LE(l_current_cdef_ptr, l_cdef_size, (OPJ_UINT32 )4);
#line 788
  l_current_cdef_ptr += 4;
#line 790
  opj_write_bytes_LE(l_current_cdef_ptr, (OPJ_UINT32 )1667523942, (OPJ_UINT32 )4);
#line 791
  l_current_cdef_ptr += 4;
#line 793
  l_value = (OPJ_UINT32 )(jp2->color.jp2_cdef)->n;
#line 794
  opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 795
  l_current_cdef_ptr += 2;
#line 797
  i = (OPJ_UINT16 )0U;
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 797
      goto while_break;
    }
    {
#line 798
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + i)->cn;
#line 799
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 800
    l_current_cdef_ptr += 2;
#line 801
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + i)->typ;
#line 802
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 803
    l_current_cdef_ptr += 2;
#line 804
    l_value = (OPJ_UINT32 )((jp2->color.jp2_cdef)->info + i)->asoc;
#line 805
    opj_write_bytes_LE(l_current_cdef_ptr, l_value, (OPJ_UINT32 )2);
#line 806
    l_current_cdef_ptr += 2;
    }
#line 797
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  *p_nb_bytes_written = l_cdef_size;
#line 810
  return (l_cdef_data);
}
}
#line 813 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BYTE *opj_jp2_write_colr(opj_jp2_t *jp2 , OPJ_UINT32 *p_nb_bytes_written ) 
{ 
  OPJ_UINT32 l_colr_size ;
  OPJ_BYTE *l_colr_data ;
  OPJ_BYTE *l_current_colr_ptr ;
  void *__cil_tmp6 ;
  OPJ_UINT32 i ;

  {
#line 818
  l_colr_size = (OPJ_UINT32 )11;
  {
#line 827
  if (jp2->meth == (OPJ_UINT32 )1) {
#line 827
    goto case_1;
  }
#line 834
  goto switch_default;
  case_1: /* CIL Label */ 
#line 828
  l_colr_size += (unsigned int )4;
#line 829
  goto switch_break;
#line 832
  l_colr_size += jp2->color.icc_profile_len;
#line 833
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 835
  return ((OPJ_BYTE *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 838
  __cil_tmp6 = opj_calloc((size_t )1, (size_t )l_colr_size);
#line 838
  l_colr_data = (OPJ_BYTE *)__cil_tmp6;
  }
#line 839
  if (l_colr_data == (OPJ_BYTE *)0) {
#line 840
    return ((OPJ_BYTE *)0);
  }
  {
#line 843
  l_current_colr_ptr = l_colr_data;
#line 845
  opj_write_bytes_LE(l_current_colr_ptr, l_colr_size, (OPJ_UINT32 )4);
#line 847
  l_current_colr_ptr += 4;
#line 849
  opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )1668246642, (OPJ_UINT32 )4);
#line 850
  l_current_colr_ptr += 4;
#line 852
  opj_write_bytes_LE(l_current_colr_ptr, jp2->meth, (OPJ_UINT32 )1);
#line 853
  l_current_colr_ptr ++;
#line 855
  opj_write_bytes_LE(l_current_colr_ptr, jp2->precedence, (OPJ_UINT32 )1);
#line 856
  l_current_colr_ptr ++;
#line 858
  opj_write_bytes_LE(l_current_colr_ptr, jp2->approx, (OPJ_UINT32 )1);
#line 859
  l_current_colr_ptr ++;
  }
#line 861
  if (jp2->meth == 1U) {
    {
#line 863
    opj_write_bytes_LE(l_current_colr_ptr, jp2->enumcs, (OPJ_UINT32 )4);
    }
  } else
#line 866
  if (jp2->meth == 2U) {
#line 868
    i = (OPJ_UINT32 )0;
    {
#line 868
    while (1) {
      while_continue: /* CIL Label */ ;
#line 868
      if (! (i < jp2->color.icc_profile_len)) {
#line 868
        goto while_break;
      }
      {
#line 869
      opj_write_bytes_LE(l_current_colr_ptr, (OPJ_UINT32 )*(jp2->color.icc_profile_buf + i),
                         (OPJ_UINT32 )1);
#line 870
      l_current_colr_ptr ++;
      }
#line 868
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 875
  *p_nb_bytes_written = l_colr_size;
#line 877
  return (l_colr_data);
}
}
#line 880 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static void opj_jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 882
  opj_free((color->jp2_pclr)->channel_sign);
#line 883
  opj_free((color->jp2_pclr)->channel_size);
#line 884
  opj_free((color->jp2_pclr)->entries);
  }
#line 886
  if ((color->jp2_pclr)->cmap) {
    {
#line 887
    opj_free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 890
  opj_free(color->jp2_pclr);
#line 891
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 894 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color ,
                                    opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 i ;
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 n ;
  OPJ_UINT32 nr_channels ;
  OPJ_UINT16 __cil_tmp8 ;
  OPJ_UINT16 nr_channels___0 ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BOOL *pcol_usage ;
  OPJ_BOOL is_sane ;
  OPJ_UINT16 __cil_tmp13 ;
  void *__cil_tmp14 ;
  OPJ_BYTE mtyp ;
  OPJ_BYTE pcol ;
  OPJ_UINT16 __cil_tmp17 ;
  OPJ_UINT16 __cil_tmp18 ;
  OPJ_UINT16 __cil_tmp19 ;
  OPJ_UINT16 __cil_tmp20 ;

  {
#line 900
  if (color->jp2_cdef) {
#line 901
    info = (color->jp2_cdef)->info;
#line 902
    n = (color->jp2_cdef)->n;
#line 903
    nr_channels = image->numcomps;
#line 907
    if (color->jp2_pclr) {
#line 907
      if ((color->jp2_pclr)->cmap) {
#line 908
        nr_channels = (OPJ_UINT32 )(color->jp2_pclr)->nr_channels;
      }
    }
#line 911
    i = (OPJ_UINT16 )0;
    {
#line 911
    while (1) {
      while_continue: /* CIL Label */ ;
#line 911
      if (! ((int )i < (int )n)) {
#line 911
        goto while_break;
      }
#line 912
      if ((unsigned int )(info + i)->cn >= nr_channels) {
        {
#line 913
        opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\n", (int )(info + i)->cn,
                      nr_channels);
        }
#line 915
        return (0);
      }
#line 917
      if ((unsigned int )(info + i)->asoc == 65535U) {
#line 918
        goto while_continue;
      }
#line 921
      if ((int )(info + i)->asoc > 0) {
#line 921
        if ((OPJ_UINT32 )((int )(info + i)->asoc - 1) >= nr_channels) {
          {
#line 922
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\nEV", (int )(info + i)->asoc - 1,
                        nr_channels);
          }
#line 924
          return (0);
        }
      }
#line 911
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 930
      if (! (nr_channels > 0U)) {
#line 930
        goto while_break___0;
      }
#line 931
      i = (OPJ_UINT16 )0;
      {
#line 931
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 931
        if (! ((int )i < (int )n)) {
#line 931
          goto while_break___1;
        }
#line 932
        if ((OPJ_UINT32 )(info + i)->cn == nr_channels - 1U) {
#line 933
          goto while_break___1;
        }
#line 931
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 936
      if ((int )i == (int )n) {
        {
#line 937
        opj_event_msg(p_manager, 1, "Incomplete channel definitions.\n\220");
        }
#line 938
        return (0);
      }
#line 940
      nr_channels --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 946
  if (color->jp2_pclr) {
#line 946
    if ((color->jp2_pclr)->cmap) {
#line 947
      nr_channels___0 = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 948
      cmap = (color->jp2_pclr)->cmap;
#line 949
      is_sane = 1;
#line 952
      i = (OPJ_UINT16 )0;
      {
#line 952
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 952
        if (! ((int )i < (int )nr_channels___0)) {
#line 952
          goto while_break___2;
        }
#line 953
        if ((unsigned int )(cmap + i)->cmp >= image->numcomps) {
          {
#line 954
          opj_event_msg(p_manager, 1, "Invalid component index %d (>= %d).\nEV", (int )(cmap + i)->cmp,
                        image->numcomps);
#line 956
          is_sane = 0;
          }
        }
#line 952
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 960
      __cil_tmp14 = opj_calloc((size_t )nr_channels___0, sizeof(OPJ_BOOL ));
#line 960
      pcol_usage = (OPJ_BOOL *)__cil_tmp14;
      }
#line 961
      if (! pcol_usage) {
        {
#line 962
        opj_event_msg(p_manager, 1, "Unexpected OOM.\n\220");
        }
#line 963
        return (0);
      }
#line 966
      i = (OPJ_UINT16 )0;
      {
#line 966
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 966
        if (! ((int )i < (int )nr_channels___0)) {
#line 966
          goto while_break___3;
        }
#line 967
        mtyp = (cmap + i)->mtyp;
#line 968
        pcol = (cmap + i)->pcol;
#line 970
        if ((int )mtyp != 0) {
#line 970
          if ((int )mtyp != 1) {
            {
#line 971
            opj_event_msg(p_manager, 1, "Invalid value for cmap[%d].mtyp = %d.\n",
                          (int )i, (int )mtyp);
#line 974
            is_sane = 0;
            }
          } else {
#line 970
            goto _L___14;
          }
        } else
        _L___14: /* CIL Label */ 
#line 975
        if ((int )pcol >= (int )nr_channels___0) {
          {
#line 976
          opj_event_msg(p_manager, 1, "Invalid component/palette index for direct mapping %d.\n",
                        (int )pcol);
#line 978
          is_sane = 0;
          }
        } else
#line 979
        if (*(pcol_usage + pcol)) {
#line 979
          if ((int )mtyp == 1) {
            {
#line 980
            opj_event_msg(p_manager, 1, "Component %d is mapped twice.\n", (int )pcol);
#line 981
            is_sane = 0;
            }
          } else {
#line 979
            goto _L___13;
          }
        } else
        _L___13: /* CIL Label */ 
#line 982
        if ((int )mtyp == 0) {
#line 982
          if ((int )pcol != 0) {
            {
#line 985
            opj_event_msg(p_manager, 1, "Direct use at #%d however pcol=%d.\n", (int )i,
                          (int )pcol);
#line 987
            is_sane = 0;
            }
          } else {
#line 982
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 988
        if ((int )mtyp == 1) {
#line 988
          if ((int )pcol != (int )i) {
            {
#line 991
            opj_event_msg(p_manager, 1, "Implementation limitation: for palette mapping, pcol[%d] should be equal to %d, but is equal to %d.\n",
                          (int )i, (int )i, (int )pcol);
#line 995
            is_sane = 0;
            }
          } else {
#line 997
            *(pcol_usage + pcol) = 1;
          }
        } else {
#line 997
          *(pcol_usage + pcol) = 1;
        }
#line 966
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1001
      i = (OPJ_UINT16 )0;
      {
#line 1001
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1001
        if (! ((int )i < (int )nr_channels___0)) {
#line 1001
          goto while_break___4;
        }
#line 1002
        if (! *(pcol_usage + i)) {
#line 1002
          if ((int )(cmap + i)->mtyp != 0) {
            {
#line 1003
            opj_event_msg(p_manager, 1, "Component %d doesn\'t have a mapping.\n",
                          (int )i);
#line 1005
            is_sane = 0;
            }
          }
        }
#line 1001
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1009
      if (is_sane) {
#line 1009
        if (image->numcomps == 1U) {
#line 1010
          i = (OPJ_UINT16 )0;
          {
#line 1010
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1010
            if (! ((int )i < (int )nr_channels___0)) {
#line 1010
              goto while_break___5;
            }
#line 1011
            if (! *(pcol_usage + i)) {
              {
#line 1012
              is_sane = (OPJ_BOOL )0U;
#line 1013
              opj_event_msg(p_manager, 2, "Component mapping seems wrong. Trying to correct.\n");
              }
#line 1015
              goto while_break___5;
            }
#line 1010
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1018
          if (! is_sane) {
#line 1019
            is_sane = 1;
#line 1020
            i = (OPJ_UINT16 )0;
            {
#line 1020
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1020
              if (! ((int )i < (int )nr_channels___0)) {
#line 1020
                goto while_break___6;
              }
#line 1021
              (cmap + i)->mtyp = (OPJ_BYTE )1U;
#line 1022
              (cmap + i)->pcol = (OPJ_BYTE )i;
#line 1020
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 1026
      opj_free(pcol_usage);
      }
#line 1027
      if (! is_sane) {
#line 1028
        return (0);
      }
    }
  }
#line 1032
  return (1);
}
}
#line 1036 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_apply_pclr(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *p_manager ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_INT32 *src ;
  OPJ_INT32 *dst ;
  OPJ_UINT32 j ;
  OPJ_UINT32 max ;
  OPJ_UINT16 i ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 cmp ;
  OPJ_UINT16 pcol ;
  OPJ_INT32 k ;
  OPJ_INT32 top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 1049
  channel_size = (color->jp2_pclr)->channel_size;
#line 1050
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 1051
  entries = (color->jp2_pclr)->entries;
#line 1052
  cmap = (color->jp2_pclr)->cmap;
#line 1053
  nr_channels = (OPJ_UINT16 )(color->jp2_pclr)->nr_channels;
#line 1055
  i = (OPJ_UINT16 )0;
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    if (! ((int )i < (int )nr_channels)) {
#line 1055
      goto while_break;
    }
#line 1057
    cmp = (cmap + i)->cmp;
#line 1058
    if ((image->comps + cmp)->data == (void *)0) {
      {
#line 1059
      opj_event_msg(p_manager, 1, "image->comps[%d].data == NULL in opj_jp2_apply_pclr().\n",
                    (int )i);
      }
#line 1061
      return (0);
    }
#line 1055
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1065
  old_comps = image->comps;
#line 1066
  __cil_tmp20 = opj_malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 1066
  new_comps = (opj_image_comp_t *)__cil_tmp20;
  }
#line 1068
  if (! new_comps) {
    {
#line 1069
    opj_event_msg(p_manager, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n");
    }
#line 1071
    return (0);
  }
#line 1073
  i = (OPJ_UINT16 )0;
  {
#line 1073
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1073
    if (! ((int )i < (int )nr_channels)) {
#line 1073
      goto while_break___0;
    }
#line 1074
    pcol = (OPJ_UINT16 )(cmap + i)->pcol;
#line 1075
    cmp = (cmap + i)->cmp;
#line 1078
    if ((int )(cmap + i)->mtyp == 0) {
#line 1080
      *(new_comps + i) = *(old_comps + cmp);
    } else {
#line 1083
      *(new_comps + pcol) = *(old_comps + cmp);
    }
    {
#line 1087
    __cil_tmp21 = opj_image_data_alloc((sizeof(OPJ_INT32 ) * (unsigned long )(old_comps + cmp)->w) * (unsigned long )(old_comps + cmp)->h);
#line 1087
    (new_comps + i)->data = (OPJ_INT32 *)__cil_tmp21;
    }
#line 1089
    if (! (new_comps + i)->data) {
      {
#line 1090
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1090
        if (! ((int )i > 0)) {
#line 1090
          goto while_break___1;
        }
        {
#line 1091
        i --;
#line 1092
        opj_image_data_free((new_comps + i)->data);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1094
      opj_free(new_comps);
#line 1095
      opj_event_msg(p_manager, 1, "Memory allocation failure in opj_jp2_apply_pclr().\n");
      }
#line 1097
      return (0);
    }
#line 1099
    (new_comps + i)->prec = (OPJ_UINT32 )*(channel_size + i);
#line 1100
    (new_comps + i)->sgnd = (OPJ_UINT32 )*(channel_sign + i);
#line 1073
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1103
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 1105
  i = (OPJ_UINT16 )0;
  {
#line 1105
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1105
    if (! ((int )i < (int )nr_channels)) {
#line 1105
      goto while_break___2;
    }
#line 1107
    cmp = (cmap + i)->cmp;
#line 1108
    pcol = (OPJ_UINT16 )(cmap + i)->pcol;
#line 1109
    src = (old_comps + cmp)->data;
#line 1111
    max = (new_comps + i)->w * (new_comps + i)->h;
#line 1114
    if ((int )(cmap + i)->mtyp == 0) {
#line 1115
      dst = (new_comps + i)->data;
#line 1117
      j = (OPJ_UINT32 )0;
      {
#line 1117
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1117
        if (! (j < max)) {
#line 1117
          goto while_break___3;
        }
#line 1118
        *(dst + j) = *(src + j);
#line 1117
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 1122
      dst = (new_comps + pcol)->data;
#line 1124
      j = (OPJ_UINT32 )0;
      {
#line 1124
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1124
        if (! (j < max)) {
#line 1124
          goto while_break___4;
        }
#line 1126
        k = *(src + j);
#line 1126
        if (k < 0) {
#line 1127
          k = 0;
        } else
#line 1128
        if (k > top_k) {
#line 1129
          k = top_k;
        }
#line 1133
        *(dst + j) = (OPJ_INT32 )*(entries + (k * (int )nr_channels + (int )pcol));
#line 1124
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1105
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1138
  max = image->numcomps;
#line 1139
  j = (OPJ_UINT32 )0;
  {
#line 1139
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1139
    if (! (j < max)) {
#line 1139
      goto while_break___5;
    }
#line 1140
    if ((old_comps + j)->data) {
      {
#line 1141
      opj_image_data_free((old_comps + j)->data);
      }
    }
#line 1139
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1145
  opj_free(old_comps);
#line 1146
  image->comps = new_comps;
#line 1147
  image->numcomps = (OPJ_UINT32 )nr_channels;
  }
#line 1149
  return (1);
}
}
#line 1152 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_pclr(opj_jp2_t *jp2 , OPJ_BYTE *p_pclr_header_data ,
                                  OPJ_UINT32 p_pclr_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  OPJ_BYTE *channel_size ;
  OPJ_BYTE *channel_sign ;
  OPJ_UINT32 *entries ;
  OPJ_UINT16 nr_entries ;
  OPJ_UINT16 nr_channels ;
  OPJ_UINT16 i ;
  OPJ_UINT16 j ;
  OPJ_UINT32 l_value ;
  OPJ_BYTE *orig_header_data ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int tmp ;
  OPJ_UINT32 bytes_to_read ;
  OPJ_UINT32 *__cil_tmp21 ;

  {
#line 1164
  orig_header_data = p_pclr_header_data;
#line 1172
  if (jp2->color.jp2_pclr) {
#line 1173
    return (0);
  }
#line 1176
  if (p_pclr_header_size < 3U) {
#line 1177
    return (0);
  }
  {
#line 1180
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )2);
#line 1181
  p_pclr_header_data += 2;
#line 1182
  nr_entries = (OPJ_UINT16 )l_value;
  }
#line 1183
  if ((unsigned int )nr_entries == 0U) {
    {
    {
#line 1184
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\nV", (int )nr_entries);
    }
    }
#line 1186
    return (0);
  } else
#line 1183
  if ((unsigned int )nr_entries > 1024U) {
    {
    {
#line 1184
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports %d entries\nV", (int )nr_entries);
    }
    }
#line 1186
    return (0);
  }
  {
#line 1189
  opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1190
  p_pclr_header_data ++;
#line 1191
  nr_channels = (OPJ_UINT16 )l_value;
  }
#line 1192
  if ((unsigned int )nr_channels == 0U) {
    {
#line 1193
    opj_event_msg(p_manager, 1, "Invalid PCLR box. Reports 0 palette columns\nEV");
    }
#line 1195
    return (0);
  }
#line 1198
  if (p_pclr_header_size < 3U + (OPJ_UINT32 )nr_channels) {
#line 1199
    return (0);
  }
  {
#line 1202
  __cil_tmp15 = opj_malloc((sizeof(OPJ_UINT32 ) * (unsigned long )nr_channels) * (unsigned long )nr_entries);
#line 1202
  entries = (OPJ_UINT32 *)__cil_tmp15;
  }
#line 1204
  if (! entries) {
#line 1205
    return (0);
  }
  {
#line 1207
  __cil_tmp16 = opj_malloc((size_t )nr_channels);
#line 1207
  channel_size = (OPJ_BYTE *)__cil_tmp16;
  }
#line 1208
  if (! channel_size) {
    {
#line 1209
    opj_free(entries);
    }
#line 1210
    return (0);
  }
  {
#line 1212
  __cil_tmp17 = opj_malloc((size_t )nr_channels);
#line 1212
  channel_sign = (OPJ_BYTE *)__cil_tmp17;
  }
#line 1213
  if (! channel_sign) {
    {
#line 1214
    opj_free(entries);
#line 1215
    opj_free(channel_size);
    }
#line 1216
    return (0);
  }
  {
#line 1219
  __cil_tmp18 = opj_malloc(sizeof(opj_jp2_pclr_t ));
#line 1219
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp18;
  }
#line 1220
  if (! jp2_pclr) {
    {
#line 1221
    opj_free(entries);
#line 1222
    opj_free(channel_size);
#line 1223
    opj_free(channel_sign);
    }
#line 1224
    return (0);
  }
#line 1227
  jp2_pclr->channel_sign = channel_sign;
#line 1228
  jp2_pclr->channel_size = channel_size;
#line 1229
  jp2_pclr->entries = entries;
#line 1230
  jp2_pclr->nr_entries = nr_entries;
#line 1231
  jp2_pclr->nr_channels = (OPJ_BYTE )l_value;
#line 1232
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 1234
  jp2->color.jp2_pclr = jp2_pclr;
#line 1236
  i = (OPJ_UINT16 )0;
  {
#line 1236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1236
    if (! ((int )i < (int )nr_channels)) {
#line 1236
      goto while_break;
    }
    {
#line 1237
    opj_read_bytes_LE(p_pclr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1238
    p_pclr_header_data ++;
#line 1240
    *(channel_size + i) = (OPJ_BYTE )((l_value & 127U) + 1U);
    }
#line 1241
    if (l_value & 128U) {
#line 1241
      tmp = 1;
    } else {
#line 1241
      tmp = 0;
    }
#line 1241
    *(channel_sign + i) = (OPJ_BYTE )tmp;
#line 1236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  j = (OPJ_UINT16 )0;
  {
#line 1244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1244
    if (! ((int )j < (int )nr_entries)) {
#line 1244
      goto while_break___0;
    }
#line 1245
    i = (OPJ_UINT16 )0;
    {
#line 1245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1245
      if (! ((int )i < (int )nr_channels)) {
#line 1245
        goto while_break___1;
      }
#line 1246
      bytes_to_read = (OPJ_UINT32 )(((int )*(channel_size + i) + 7) >> 3);
#line 1248
      if ((unsigned long )bytes_to_read > sizeof(OPJ_UINT32 )) {
#line 1249
        bytes_to_read = (OPJ_UINT32 )sizeof(OPJ_UINT32 );
      }
#line 1251
      if ((ptrdiff_t )p_pclr_header_size < (ptrdiff_t )(p_pclr_header_data - orig_header_data) + (ptrdiff_t )bytes_to_read) {
#line 1253
        return (0);
      }
      {
#line 1256
      opj_read_bytes_LE(p_pclr_header_data, & l_value, bytes_to_read);
#line 1257
      p_pclr_header_data += bytes_to_read;
#line 1258
      *entries = (OPJ_UINT32 )l_value;
#line 1259
      entries ++;
      }
#line 1245
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1244
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1263
  return (1);
}
}
#line 1266 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cmap(opj_jp2_t *jp2 , OPJ_BYTE *p_cmap_header_data ,
                                  OPJ_UINT32 p_cmap_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  OPJ_BYTE i ;
  OPJ_BYTE nr_channels ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp9 ;

  {
#line 1283
  if (jp2->color.jp2_pclr == (void *)0) {
    {
#line 1284
    opj_event_msg(p_manager, 1, "Need to read a PCLR box before the CMAP box.\n");
    }
#line 1286
    return (0);
  }
#line 1292
  if ((jp2->color.jp2_pclr)->cmap) {
    {
#line 1293
    opj_event_msg(p_manager, 1, "Only one CMAP box is allowed.\n");
    }
#line 1294
    return (0);
  }
#line 1297
  nr_channels = (jp2->color.jp2_pclr)->nr_channels;
#line 1298
  if (p_cmap_header_size < (OPJ_UINT32 )nr_channels * 4U) {
    {
#line 1299
    opj_event_msg(p_manager, 1, "Insufficient data for CMAP box.\n\220");
    }
#line 1300
    return (0);
  }
  {
#line 1303
  __cil_tmp9 = opj_malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 1303
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp9;
  }
#line 1305
  if (! cmap) {
#line 1306
    return (0);
  }
#line 1310
  i = (OPJ_BYTE )0;
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! ((int )i < (int )nr_channels)) {
#line 1310
      goto while_break;
    }
    {
#line 1311
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )2);
#line 1312
    p_cmap_header_data += 2;
#line 1313
    (cmap + i)->cmp = (OPJ_UINT16 )l_value;
#line 1315
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1316
    p_cmap_header_data ++;
#line 1317
    (cmap + i)->mtyp = (OPJ_BYTE )l_value;
#line 1319
    opj_read_bytes_LE(p_cmap_header_data, & l_value, (OPJ_UINT32 )1);
#line 1320
    p_cmap_header_data ++;
#line 1321
    (cmap + i)->pcol = (OPJ_BYTE )l_value;
    }
#line 1310
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1324
  (jp2->color.jp2_pclr)->cmap = cmap;
#line 1326
  return (1);
}
}
#line 1329 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static void opj_jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color , opj_event_mgr_t *manager ) 
{ 
  opj_jp2_cdef_info_t *info ;
  OPJ_UINT16 i ;
  OPJ_UINT16 n ;
  OPJ_UINT16 cn ;
  OPJ_UINT16 asoc ;
  OPJ_UINT16 acn ;
  opj_image_comp_t saved ;
  OPJ_UINT16 j ;

  {
#line 1335
  info = (color->jp2_cdef)->info;
#line 1336
  n = (color->jp2_cdef)->n;
#line 1338
  i = (OPJ_UINT16 )0;
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! ((int )i < (int )n)) {
#line 1338
      goto while_break;
    }
#line 1340
    asoc = (info + i)->asoc;
#line 1341
    cn = (info + i)->cn;
#line 1343
    if ((unsigned int )cn >= image->numcomps) {
      {
#line 1344
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: cn=%d, numcomps=%d\n", (int )cn,
                    image->numcomps);
      }
#line 1346
      goto while_continue;
    }
#line 1348
    if ((int )asoc == 0) {
#line 1349
      (image->comps + cn)->alpha = (info + i)->typ;
#line 1350
      goto while_continue;
    } else
#line 1348
    if ((int )asoc == 65535) {
#line 1349
      (image->comps + cn)->alpha = (info + i)->typ;
#line 1350
      goto while_continue;
    }
#line 1353
    acn = (OPJ_UINT16 )((int )asoc - 1);
#line 1354
    if ((unsigned int )acn >= image->numcomps) {
      {
#line 1355
      opj_event_msg(manager, 2, "opj_jp2_apply_cdef: acn=%d, numcomps=%d\n\230\001",
                    (int )acn, image->numcomps);
      }
#line 1357
      goto while_continue;
    }
#line 1361
    if ((int )cn != (int )acn) {
#line 1361
      if ((int )(info + i)->typ == 0) {
        {
#line 1365
        memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 1366
        memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 1367
        memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 1370
        j = (OPJ_UINT16 )((unsigned int )i + 1U);
        }
        {
#line 1370
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1370
          if (! ((int )j < (int )n)) {
#line 1370
            goto while_break___0;
          }
#line 1371
          if ((int )(info + j)->cn == (int )cn) {
#line 1372
            (info + j)->cn = acn;
          } else
#line 1373
          if ((int )(info + j)->cn == (int )acn) {
#line 1374
            (info + j)->cn = cn;
          }
#line 1370
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1380
    (image->comps + cn)->alpha = (info + i)->typ;
#line 1338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1383
  if ((color->jp2_cdef)->info) {
    {
#line 1384
    opj_free((color->jp2_cdef)->info);
    }
  }
  {
#line 1387
  opj_free(color->jp2_cdef);
#line 1388
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 1392 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_cdef(opj_jp2_t *jp2 , OPJ_BYTE *p_cdef_header_data ,
                                  OPJ_UINT32 p_cdef_header_size , opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_cdef_info_t *cdef_info ;
  OPJ_UINT16 i ;
  OPJ_UINT32 l_value ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 1410
  if (jp2->color.jp2_cdef) {
#line 1411
    return (0);
  }
#line 1414
  if (p_cdef_header_size < 2U) {
    {
#line 1415
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1416
    return (0);
  }
  {
#line 1419
  opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1420
  p_cdef_header_data += 2;
  }
#line 1422
  if ((int )((OPJ_UINT16 )l_value) == 0) {
    {
#line 1423
    opj_event_msg(p_manager, 1, "Number of channel description is equal to zero in CDEF box.\n");
    }
#line 1425
    return (0);
  }
#line 1428
  if (p_cdef_header_size < 2U + (OPJ_UINT32 )((OPJ_UINT16 )l_value) * 6U) {
    {
#line 1429
    opj_event_msg(p_manager, 1, "Insufficient data for CDEF box.\n\220");
    }
#line 1430
    return (0);
  }
  {
#line 1433
  __cil_tmp8 = opj_malloc((unsigned long )l_value * sizeof(opj_jp2_cdef_info_t ));
#line 1433
  cdef_info = (opj_jp2_cdef_info_t *)__cil_tmp8;
  }
#line 1435
  if (! cdef_info) {
#line 1436
    return (0);
  }
  {
#line 1439
  __cil_tmp9 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 1439
  jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp9;
  }
#line 1440
  if (! jp2->color.jp2_cdef) {
    {
#line 1441
    opj_free(cdef_info);
    }
#line 1442
    return (0);
  }
#line 1444
  (jp2->color.jp2_cdef)->info = cdef_info;
#line 1445
  (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )l_value;
#line 1447
  i = (OPJ_UINT16 )0;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1447
    if (! ((int )i < (int )(jp2->color.jp2_cdef)->n)) {
#line 1447
      goto while_break;
    }
    {
#line 1448
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1449
    p_cdef_header_data += 2;
#line 1450
    (cdef_info + i)->cn = (OPJ_UINT16 )l_value;
#line 1452
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1453
    p_cdef_header_data += 2;
#line 1454
    (cdef_info + i)->typ = (OPJ_UINT16 )l_value;
#line 1456
    opj_read_bytes_LE(p_cdef_header_data, & l_value, (OPJ_UINT32 )2);
#line 1457
    p_cdef_header_data += 2;
#line 1458
    (cdef_info + i)->asoc = (OPJ_UINT16 )l_value;
    }
#line 1447
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1461
  return (1);
}
}
#line 1464 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_colr(opj_jp2_t *jp2 , OPJ_BYTE *p_colr_header_data ,
                                  OPJ_UINT32 p_colr_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 *cielab ;
  OPJ_UINT32 rl ;
  OPJ_UINT32 ol ;
  OPJ_UINT32 ra ;
  OPJ_UINT32 oa ;
  OPJ_UINT32 rb ;
  OPJ_UINT32 ob ;
  OPJ_UINT32 il ;
  void *__cil_tmp14 ;
  OPJ_INT32 it_icc_value ;
  OPJ_INT32 icc_len ;
  void *__cil_tmp17 ;

  {
#line 1477
  if (p_colr_header_size < 3U) {
    {
#line 1478
    opj_event_msg(p_manager, 1, "Bad COLR header box (bad size)\n");
    }
#line 1479
    return (0);
  }
#line 1485
  if (jp2->color.jp2_has_colr) {
    {
#line 1486
    opj_event_msg(p_manager, 4, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n");
#line 1488
    p_colr_header_data += p_colr_header_size;
    }
#line 1489
    return (1);
  }
  {
#line 1492
  opj_read_bytes_LE(p_colr_header_data, & jp2->meth, (OPJ_UINT32 )1);
#line 1493
  p_colr_header_data ++;
#line 1495
  opj_read_bytes_LE(p_colr_header_data, & jp2->precedence, (OPJ_UINT32 )1);
#line 1496
  p_colr_header_data ++;
#line 1498
  opj_read_bytes_LE(p_colr_header_data, & jp2->approx, (OPJ_UINT32 )1);
#line 1499
  p_colr_header_data ++;
  }
#line 1501
  if (jp2->meth == 1U) {
#line 1502
    if (p_colr_header_size < 7U) {
      {
#line 1503
      opj_event_msg(p_manager, 1, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
      }
#line 1505
      return (0);
    }
#line 1507
    if (p_colr_header_size > 7U) {
#line 1507
      if (jp2->enumcs != 14U) {
        {
#line 1510
        opj_event_msg(p_manager, 2, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
        }
      }
    }
    {
#line 1514
    opj_read_bytes_LE(p_colr_header_data, & jp2->enumcs, (OPJ_UINT32 )4);
#line 1516
    p_colr_header_data += 4;
    }
#line 1518
    if (jp2->enumcs == 14U) {
      {
#line 1522
      __cil_tmp14 = opj_malloc(9UL * sizeof(OPJ_UINT32 ));
#line 1522
      cielab = (OPJ_UINT32 *)__cil_tmp14;
      }
#line 1523
      if (cielab == (void *)0) {
        {
#line 1524
        opj_event_msg(p_manager, 1, "Not enough memory for cielab\nV");
        }
#line 1525
        return (0);
      }
#line 1527
      *(cielab + 0) = (OPJ_UINT32 )14;
#line 1530
      ob = (OPJ_UINT32 )0;
#line 1530
      oa = ob;
#line 1530
      ol = oa;
#line 1530
      rb = ol;
#line 1530
      ra = rb;
#line 1530
      rl = ra;
#line 1531
      il = (OPJ_UINT32 )4470064;
#line 1532
      *(cielab + 1) = (OPJ_UINT32 )1145390592;
#line 1534
      if (p_colr_header_size == 35U) {
        {
#line 1535
        opj_read_bytes_LE(p_colr_header_data, & rl, (OPJ_UINT32 )4);
#line 1536
        p_colr_header_data += 4;
#line 1537
        opj_read_bytes_LE(p_colr_header_data, & ol, (OPJ_UINT32 )4);
#line 1538
        p_colr_header_data += 4;
#line 1539
        opj_read_bytes_LE(p_colr_header_data, & ra, (OPJ_UINT32 )4);
#line 1540
        p_colr_header_data += 4;
#line 1541
        opj_read_bytes_LE(p_colr_header_data, & oa, (OPJ_UINT32 )4);
#line 1542
        p_colr_header_data += 4;
#line 1543
        opj_read_bytes_LE(p_colr_header_data, & rb, (OPJ_UINT32 )4);
#line 1544
        p_colr_header_data += 4;
#line 1545
        opj_read_bytes_LE(p_colr_header_data, & ob, (OPJ_UINT32 )4);
#line 1546
        p_colr_header_data += 4;
#line 1547
        opj_read_bytes_LE(p_colr_header_data, & il, (OPJ_UINT32 )4);
#line 1548
        p_colr_header_data += 4;
#line 1550
        *(cielab + 1) = (OPJ_UINT32 )0;
        }
      } else
#line 1551
      if (p_colr_header_size != 7U) {
        {
#line 1552
        opj_event_msg(p_manager, 2, "Bad COLR header box (CIELab, bad size: %d)\n~EV",
                      p_colr_header_size);
        }
      }
#line 1555
      *(cielab + 2) = rl;
#line 1556
      *(cielab + 4) = ra;
#line 1557
      *(cielab + 6) = rb;
#line 1558
      *(cielab + 3) = ol;
#line 1559
      *(cielab + 5) = oa;
#line 1560
      *(cielab + 7) = ob;
#line 1561
      *(cielab + 8) = il;
#line 1563
      jp2->color.icc_profile_buf = (OPJ_BYTE *)cielab;
#line 1564
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
    }
#line 1566
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1567
  if (jp2->meth == 2U) {
    {
#line 1569
    it_icc_value = 0;
#line 1570
    icc_len = (OPJ_INT32 )p_colr_header_size - 3;
#line 1572
    jp2->color.icc_profile_len = (OPJ_UINT32 )icc_len;
#line 1573
    __cil_tmp17 = opj_calloc((size_t )1, (size_t )icc_len);
#line 1573
    jp2->color.icc_profile_buf = (OPJ_BYTE *)__cil_tmp17;
    }
#line 1574
    if (! jp2->color.icc_profile_buf) {
#line 1575
      jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 1576
      return (0);
    }
#line 1579
    it_icc_value = 0;
    {
#line 1579
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1579
      if (! (it_icc_value < icc_len)) {
#line 1579
        goto while_break;
      }
      {
#line 1580
      opj_read_bytes_LE(p_colr_header_data, & l_value, (OPJ_UINT32 )1);
#line 1581
      p_colr_header_data ++;
#line 1582
      *(jp2->color.icc_profile_buf + it_icc_value) = (OPJ_BYTE )l_value;
      }
#line 1579
      it_icc_value ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1585
    jp2->color.jp2_has_colr = (OPJ_BYTE )1;
  } else
#line 1586
  if (jp2->meth > 2U) {
    {
#line 1589
    opj_event_msg(p_manager, 4, "COLR BOX meth value is not a regular value (%d), so we will ignore the entire Colour Specification box. \n",
                  jp2->meth);
    }
  }
#line 1594
  return (1);
}
}
#line 1597 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_apply_color_postprocessing(opj_jp2_t *jp2 , opj_image_t *p_image ,
                                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
#line 1601
  if ((jp2->j2k)->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 1603
    return (1);
  }
#line 1606
  if (! jp2->ignore_pclr_cmap_cdef) {
    {
#line 1607
    __cil_tmp4 = opj_jp2_check_color(p_image, & jp2->color, p_manager);
    }
#line 1607
    if (! __cil_tmp4) {
#line 1608
      return (0);
    }
#line 1611
    if (jp2->color.jp2_pclr) {
#line 1613
      if (! (jp2->color.jp2_pclr)->cmap) {
        {
#line 1614
        opj_jp2_free_pclr(& jp2->color);
        }
      } else {
        {
#line 1616
        __cil_tmp5 = opj_jp2_apply_pclr(p_image, & jp2->color, p_manager);
        }
#line 1616
        if (! __cil_tmp5) {
#line 1617
          return (0);
        }
      }
    }
#line 1623
    if (jp2->color.jp2_cdef) {
      {
#line 1624
      opj_jp2_apply_cdef(p_image, & jp2->color, p_manager);
      }
    }
  }
#line 1628
  return (1);
}
}
#line 1631 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 1636
  if (! p_image) {
#line 1637
    return (0);
  }
  {
#line 1641
  __cil_tmp5 = opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager);
  }
#line 1641
  if (! __cil_tmp5) {
    {
#line 1642
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 1644
    return (0);
  }
  {
#line 1647
  __cil_tmp6 = opj_jp2_apply_color_postprocessing(jp2, p_image, p_manager);
  }
#line 1647
  return (__cil_tmp6);
}
}
#line 1650 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_img_header_writer_handler_t l_writers[4] ;
  opj_jp2_img_header_writer_handler_t *l_current_writer ;
  OPJ_INT32 i ;
  OPJ_INT32 l_nb_pass ;
  OPJ_UINT32 l_jp2h_size ;
  OPJ_BOOL l_result ;
  OPJ_BYTE l_jp2h_data[8] ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;
  OPJ_SIZE_T __cil_tmp14 ;

  {
  {
#line 1660
  l_jp2h_size = (OPJ_UINT32 )8;
#line 1661
  l_result = 1;
#line 1671
  memset((opj_jp2_img_header_writer_handler_t *)l_writers, 0, sizeof(l_writers));
  }
#line 1673
  if (jp2->bpc == 255U) {
#line 1674
    l_nb_pass = 3;
#line 1675
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1676
    l_writers[1].handler = & opj_jp2_write_bpcc;
#line 1677
    l_writers[2].handler = & opj_jp2_write_colr;
  } else {
#line 1679
    l_nb_pass = 2;
#line 1680
    l_writers[0].handler = & opj_jp2_write_ihdr;
#line 1681
    l_writers[1].handler = & opj_jp2_write_colr;
  }
#line 1684
  if (jp2->color.jp2_cdef != (void *)0) {
#line 1685
    l_writers[l_nb_pass].handler = & opj_jp2_write_cdef;
#line 1686
    l_nb_pass ++;
  }
  {
#line 1691
  opj_write_bytes_LE((OPJ_BYTE *)l_jp2h_data + 4, (OPJ_UINT32 )1785737832, (OPJ_UINT32 )4);
#line 1693
  l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1694
  i = 0;
  }
  {
#line 1694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1694
    if (! (i < l_nb_pass)) {
#line 1694
      goto while_break;
    }
    {
#line 1695
    l_current_writer->m_data = (*(l_current_writer->handler))(jp2, & l_current_writer->m_size);
    }
#line 1697
    if (l_current_writer->m_data == (OPJ_BYTE *)0) {
      {
#line 1698
      opj_event_msg(p_manager, 1, "Not enough memory to hold JP2 Header data\n");
#line 1700
      l_result = 0;
      }
#line 1701
      goto while_break;
    }
#line 1704
    l_jp2h_size += l_current_writer->m_size;
#line 1705
    l_current_writer ++;
#line 1694
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1708
  if (! l_result) {
#line 1709
    l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1710
    i = 0;
    {
#line 1710
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1710
      if (! (i < l_nb_pass)) {
#line 1710
        goto while_break___0;
      }
#line 1711
      if (l_current_writer->m_data != (OPJ_BYTE *)0) {
        {
#line 1712
        opj_free(l_current_writer->m_data);
        }
      }
#line 1714
      l_current_writer ++;
#line 1710
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1717
    return (0);
  }
  {
#line 1721
  opj_write_bytes_LE((OPJ_BYTE *)l_jp2h_data, l_jp2h_size, (OPJ_UINT32 )4);
#line 1724
  __cil_tmp13 = opj_stream_write_data(stream, (OPJ_BYTE *)l_jp2h_data, (OPJ_SIZE_T )8,
                                      p_manager);
  }
#line 1724
  if (__cil_tmp13 != 8UL) {
    {
#line 1725
    opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\n");
#line 1727
    l_result = 0;
    }
  }
#line 1730
  if (l_result) {
#line 1731
    l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1732
    i = 0;
    {
#line 1732
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1732
      if (! (i < l_nb_pass)) {
#line 1732
        goto while_break___1;
      }
      {
#line 1733
      __cil_tmp14 = opj_stream_write_data(stream, l_current_writer->m_data, (OPJ_SIZE_T )l_current_writer->m_size,
                                          p_manager);
      }
#line 1733
      if (__cil_tmp14 != (unsigned long )l_current_writer->m_size) {
        {
#line 1735
        opj_event_msg(p_manager, 1, "Stream error while writing JP2 Header box\nU~EV");
#line 1737
        l_result = 0;
        }
#line 1738
        goto while_break___1;
      }
#line 1740
      l_current_writer ++;
#line 1732
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1744
  l_current_writer = (opj_jp2_img_header_writer_handler_t *)l_writers;
#line 1747
  i = 0;
  {
#line 1747
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1747
    if (! (i < l_nb_pass)) {
#line 1747
      goto while_break___2;
    }
#line 1748
    if (l_current_writer->m_data != (OPJ_BYTE *)0) {
      {
#line 1749
      opj_free(l_current_writer->m_data);
      }
    }
#line 1751
    l_current_writer ++;
#line 1747
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1754
  return (l_result);
}
}
#line 1757 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ftyp_size ;
  OPJ_BYTE *l_ftyp_data ;
  OPJ_BYTE *l_current_data_ptr ;
  OPJ_BOOL l_result ;
  void *__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 1770
  l_ftyp_size = 16U + 4U * jp2->numcl;
#line 1772
  __cil_tmp9 = opj_calloc((size_t )1, (size_t )l_ftyp_size);
#line 1772
  l_ftyp_data = (OPJ_BYTE *)__cil_tmp9;
  }
#line 1774
  if (l_ftyp_data == (OPJ_BYTE *)0) {
    {
#line 1775
    opj_event_msg(p_manager, 1, "Not enough memory to handle ftyp data\n");
    }
#line 1776
    return (0);
  }
  {
#line 1779
  l_current_data_ptr = l_ftyp_data;
#line 1781
  opj_write_bytes_LE(l_current_data_ptr, l_ftyp_size, (OPJ_UINT32 )4);
#line 1782
  l_current_data_ptr += 4;
#line 1784
  opj_write_bytes_LE(l_current_data_ptr, (OPJ_UINT32 )1718909296, (OPJ_UINT32 )4);
#line 1785
  l_current_data_ptr += 4;
#line 1787
  opj_write_bytes_LE(l_current_data_ptr, jp2->brand, (OPJ_UINT32 )4);
#line 1788
  l_current_data_ptr += 4;
#line 1790
  opj_write_bytes_LE(l_current_data_ptr, jp2->minversion, (OPJ_UINT32 )4);
#line 1791
  l_current_data_ptr += 4;
#line 1793
  i = (OPJ_UINT32 )0;
  }
  {
#line 1793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1793
    if (! (i < jp2->numcl)) {
#line 1793
      goto while_break;
    }
    {
#line 1794
    opj_write_bytes_LE(l_current_data_ptr, *(jp2->cl + i), (OPJ_UINT32 )4);
    }
#line 1793
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1797
  __cil_tmp11 = opj_stream_write_data(cio, l_ftyp_data, (OPJ_SIZE_T )l_ftyp_size,
                                      p_manager);
#line 1797
  l_result = __cil_tmp11 == (unsigned long )l_ftyp_size;
  }
#line 1799
  if (! l_result) {
    {
#line 1800
    opj_event_msg(p_manager, 1, "Error while writing ftyp data to stream\n\220");
    }
  }
  {
#line 1804
  opj_free(l_ftyp_data);
  }
#line 1806
  return (l_result);
}
}
#line 1809 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T j2k_codestream_exit ;
  OPJ_BYTE l_data_header[8] ;
  OPJ_OFF_T __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_SIZE_T __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 1822
  j2k_codestream_exit = opj_stream_tell(cio);
#line 1823
  opj_write_bytes_LE((OPJ_BYTE *)l_data_header, (OPJ_UINT32 )(j2k_codestream_exit - jp2->j2k_codestream_offset),
                     (OPJ_UINT32 )4);
#line 1826
  opj_write_bytes_LE((OPJ_BYTE *)l_data_header + 4, (OPJ_UINT32 )1785737827, (OPJ_UINT32 )4);
#line 1829
  __cil_tmp7 = opj_stream_seek(cio, jp2->j2k_codestream_offset, p_manager);
  }
#line 1829
  if (! __cil_tmp7) {
    {
#line 1830
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1831
    return (0);
  }
  {
#line 1834
  __cil_tmp8 = opj_stream_write_data(cio, (OPJ_BYTE *)l_data_header, (OPJ_SIZE_T )8,
                                     p_manager);
  }
#line 1834
  if (__cil_tmp8 != 8UL) {
    {
#line 1835
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1836
    return (0);
  }
  {
#line 1839
  __cil_tmp9 = opj_stream_seek(cio, j2k_codestream_exit, p_manager);
  }
#line 1839
  if (! __cil_tmp9) {
    {
#line 1840
    opj_event_msg(p_manager, 1, "Failed to seek in the stream.\n");
    }
#line 1841
    return (0);
  }
#line 1844
  return (1);
}
}
#line 1847 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_write_jp(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_signature_data[12] ;
  OPJ_SIZE_T __cil_tmp5 ;

  {
  {
#line 1862
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data, (OPJ_UINT32 )12, (OPJ_UINT32 )4);
#line 1864
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data + 4, (OPJ_UINT32 )1783636000, (OPJ_UINT32 )4);
#line 1866
  opj_write_bytes_LE((OPJ_BYTE *)l_signature_data + 8, (OPJ_UINT32 )218793738, (OPJ_UINT32 )4);
#line 1868
  __cil_tmp5 = opj_stream_write_data(cio, (OPJ_BYTE *)l_signature_data, (OPJ_SIZE_T )12,
                                     p_manager);
  }
#line 1868
  if (__cil_tmp5 != 12UL) {
#line 1869
    return (0);
  }
#line 1872
  return (1);
}
}
#line 1879 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1882
  opj_j2k_setup_decoder(jp2->j2k, parameters);
#line 1885
  jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 1886
  jp2->ignore_pclr_cmap_cdef = (OPJ_BOOL )(parameters->flags & 1U);
  }
  return;
}
}
#line 1890 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
void opj_jp2_decoder_set_strict_mode(opj_jp2_t *jp2 , OPJ_BOOL strict ) 
{ 


  {
  {
#line 1892
  opj_j2k_decoder_set_strict_mode(jp2->j2k, strict);
  }
  return;
}
}
#line 1895 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2 , OPJ_UINT32 num_threads ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 1897
  __cil_tmp3 = opj_j2k_set_threads(jp2->j2k, num_threads);
  }
#line 1897
  return (__cil_tmp3);
}
}
#line 1904 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 depth_0 ;
  OPJ_UINT32 sign ;
  OPJ_UINT32 alpha_count ;
  OPJ_UINT32 color_channels ;
  OPJ_UINT32 alpha_channel ;
  OPJ_BOOL __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  OPJ_UINT32 depth ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 1913
  color_channels = 0U;
#line 1914
  alpha_channel = 0U;
#line 1917
  if (! jp2) {
#line 1918
    return (0);
  } else
#line 1917
  if (! parameters) {
#line 1918
    return (0);
  } else
#line 1917
  if (! image) {
#line 1918
    return (0);
  }
#line 1925
  if (image->numcomps < 1U) {
    {
    {
#line 1926
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\nEV");
    }
    }
#line 1928
    return (0);
  } else
#line 1925
  if (image->numcomps > 16384U) {
    {
    {
#line 1926
    opj_event_msg(p_manager, 1, "Invalid number of components specified while setting up JP2 encoder\nEV");
    }
    }
#line 1928
    return (0);
  }
  {
#line 1931
  __cil_tmp11 = opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager);
  }
#line 1931
  if (__cil_tmp11 == 0) {
#line 1933
    return (0);
  }
  {
#line 1941
  jp2->brand = (OPJ_UINT32 )1785737760;
#line 1942
  jp2->minversion = (OPJ_UINT32 )0;
#line 1943
  jp2->numcl = (OPJ_UINT32 )1;
#line 1944
  __cil_tmp12 = opj_malloc((unsigned long )jp2->numcl * sizeof(OPJ_UINT32 ));
#line 1944
  jp2->cl = (OPJ_UINT32 *)__cil_tmp12;
  }
#line 1945
  if (! jp2->cl) {
    {
#line 1946
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1948
    return (0);
  }
  {
#line 1950
  *(jp2->cl + 0) = (OPJ_UINT32 )1785737760;
#line 1954
  jp2->numcomps = image->numcomps;
#line 1955
  __cil_tmp13 = opj_malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1955
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp13;
  }
#line 1957
  if (! jp2->comps) {
    {
#line 1958
    opj_event_msg(p_manager, 1, "Not enough memory when setup the JP2 encoder\n");
    }
#line 1961
    return (0);
  }
#line 1964
  jp2->h = image->y1 - image->y0;
#line 1965
  jp2->w = image->x1 - image->x0;
#line 1967
  depth_0 = (image->comps + 0)->prec - 1U;
#line 1968
  sign = (image->comps + 0)->sgnd;
#line 1969
  jp2->bpc = depth_0 + (sign << 7);
#line 1970
  i = (OPJ_UINT32 )1;
  {
#line 1970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1970
    if (! (i < image->numcomps)) {
#line 1970
      goto while_break;
    }
#line 1971
    depth = (image->comps + i)->prec - 1U;
#line 1972
    sign = (image->comps + i)->sgnd;
#line 1973
    if (depth_0 != depth) {
#line 1974
      jp2->bpc = (OPJ_UINT32 )255;
    }
#line 1970
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1977
  jp2->C = (OPJ_UINT32 )7;
#line 1978
  jp2->UnkC = (OPJ_UINT32 )0;
#line 1979
  jp2->IPR = (OPJ_UINT32 )0;
#line 1982
  i = (OPJ_UINT32 )0;
  {
#line 1982
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1982
    if (! (i < image->numcomps)) {
#line 1982
      goto while_break___0;
    }
#line 1983
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1U) + ((image->comps + i)->sgnd << 7);
#line 1982
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1987
  if (image->icc_profile_len) {
#line 1988
    jp2->meth = (OPJ_UINT32 )2;
#line 1989
    jp2->enumcs = (OPJ_UINT32 )0;
  } else {
#line 1991
    jp2->meth = (OPJ_UINT32 )1;
#line 1992
    if ((int )image->color_space == 1) {
#line 1993
      jp2->enumcs = (OPJ_UINT32 )16;
    } else
#line 1994
    if ((int )image->color_space == 2) {
#line 1995
      jp2->enumcs = (OPJ_UINT32 )17;
    } else
#line 1996
    if ((int )image->color_space == 3) {
#line 1997
      jp2->enumcs = (OPJ_UINT32 )18;
    }
  }
#line 2004
  alpha_count = 0U;
#line 2005
  i = (OPJ_UINT32 )0;
  {
#line 2005
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2005
    if (! (i < image->numcomps)) {
#line 2005
      goto while_break___1;
    }
#line 2006
    if ((int )(image->comps + i)->alpha != 0) {
#line 2007
      alpha_count ++;
#line 2008
      alpha_channel = i;
    }
#line 2005
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2011
  if (alpha_count == 1U) {
    {
#line 2014
    if (jp2->enumcs == (OPJ_UINT32 )18) {
#line 2014
      goto case_18;
    }
#line 2014
    if (jp2->enumcs == (OPJ_UINT32 )16) {
#line 2014
      goto case_18;
    }
#line 2017
    if (jp2->enumcs == (OPJ_UINT32 )17) {
#line 2017
      goto case_17;
    }
#line 2020
    goto switch_default;
    case_18: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 2015
    color_channels = (OPJ_UINT32 )3;
#line 2016
    goto switch_break;
    case_17: /* CIL Label */ 
#line 2018
    color_channels = (OPJ_UINT32 )1;
#line 2019
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2021
    alpha_count = 0U;
#line 2022
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2024
    if (alpha_count == 0U) {
      {
#line 2025
      opj_event_msg(p_manager, 2, "Alpha channel specified but unknown enumcs. No cdef box will be created.\n");
      }
    } else
#line 2027
    if (image->numcomps < color_channels + 1U) {
      {
#line 2028
      opj_event_msg(p_manager, 2, "Alpha channel specified but not enough image components for an automatic cdef box creation.\n");
#line 2030
      alpha_count = 0U;
      }
    } else
#line 2031
    if ((OPJ_UINT32 )alpha_channel < color_channels) {
      {
#line 2032
      opj_event_msg(p_manager, 2, "Alpha channel position conflicts with color channel. No cdef box will be created.\n");
#line 2034
      alpha_count = 0U;
      }
    }
  } else
#line 2036
  if (alpha_count > 1U) {
    {
#line 2037
    opj_event_msg(p_manager, 2, "Multiple alpha channels specified. No cdef box will be created.\n\220");
    }
  }
#line 2040
  if (alpha_count == 1U) {
    {
#line 2041
    __cil_tmp19 = opj_malloc(sizeof(opj_jp2_cdef_t ));
#line 2041
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp19;
    }
#line 2042
    if (! jp2->color.jp2_cdef) {
      {
#line 2043
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2045
      return (0);
    }
    {
#line 2049
    __cil_tmp20 = opj_malloc((unsigned long )image->numcomps * sizeof(opj_jp2_cdef_info_t ));
#line 2049
    (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)__cil_tmp20;
    }
#line 2051
    if (! (jp2->color.jp2_cdef)->info) {
      {
#line 2053
      opj_event_msg(p_manager, 1, "Not enough memory to setup the JP2 encoder\n");
      }
#line 2055
      return (0);
    }
#line 2057
    (jp2->color.jp2_cdef)->n = (OPJ_UINT16 )image->numcomps;
#line 2059
    i = 0U;
    {
#line 2059
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2059
      if (! (i < color_channels)) {
#line 2059
        goto while_break___2;
      }
#line 2060
      ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2062
      ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )0U;
#line 2063
      ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )(i + 1U);
#line 2059
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2066
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2066
      if (! (i < image->numcomps)) {
#line 2066
        goto while_break___3;
      }
#line 2067
      if ((int )(image->comps + i)->alpha != 0) {
#line 2068
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2070
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )1U;
#line 2071
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )0U;
      } else {
#line 2075
        ((jp2->color.jp2_cdef)->info + i)->cn = (OPJ_UINT16 )i;
#line 2077
        ((jp2->color.jp2_cdef)->info + i)->typ = (OPJ_UINT16 )65535U;
#line 2078
        ((jp2->color.jp2_cdef)->info + i)->asoc = (OPJ_UINT16 )65535U;
      }
#line 2066
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2083
  jp2->precedence = (OPJ_UINT32 )0;
#line 2084
  jp2->approx = (OPJ_UINT32 )0;
#line 2086
  jp2->jpip_on = parameters->jpip_on;
#line 2088
  return (1);
}
}
#line 2091 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 2095
  __cil_tmp4 = opj_j2k_encode(jp2->j2k, stream, p_manager);
  }
#line 2095
  return (__cil_tmp4);
}
}
#line 2098 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 2109
  __cil_tmp4 = opj_jp2_setup_end_header_reading(jp2, p_manager);
  }
#line 2109
  if (! __cil_tmp4) {
#line 2110
    return (0);
  }
  {
#line 2114
  __cil_tmp5 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 2114
  if (! __cil_tmp5) {
#line 2115
    return (0);
  }
  {
#line 2118
  __cil_tmp6 = opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
  }
#line 2118
  return (__cil_tmp6);
}
}
#line 2121 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 2132
  __cil_tmp4 = opj_jp2_setup_end_header_writing(jp2, p_manager);
  }
#line 2132
  if (! __cil_tmp4) {
#line 2133
    return (0);
  }
  {
#line 2136
  __cil_tmp5 = opj_j2k_end_compress(jp2->j2k, cio, p_manager);
  }
#line 2136
  if (! __cil_tmp5) {
#line 2137
    return (0);
  }
  {
#line 2141
  __cil_tmp6 = opj_jp2_exec(jp2, jp2->m_procedure_list, cio, p_manager);
  }
#line 2141
  return (__cil_tmp6);
}
}
#line 2144 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 2159
  __cil_tmp3 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp2c),
                                                p_manager);
  }
#line 2159
  if (! __cil_tmp3) {
#line 2161
    return (0);
  }
#line 2176
  return (1);
}
}
#line 2179 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_end_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 2186
  __cil_tmp3 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_read_header_procedure),
                                                p_manager);
  }
#line 2186
  if (! __cil_tmp3) {
#line 2188
    return (0);
  }
#line 2192
  return (1);
}
}
#line 2195 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_default_validation(opj_jp2_t *jp2 , opj_stream_private_t *cio ,
                                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 2200
  l_is_valid = 1;
#line 2214
  l_is_valid &= jp2->jp2_state == 0U;
#line 2217
  l_is_valid &= jp2->jp2_img_state == 0U;
#line 2221
  l_is_valid &= jp2->j2k != (opj_j2k_t *)0;
#line 2224
  l_is_valid &= jp2->m_procedure_list != (struct opj_procedure_list *)0;
#line 2227
  l_is_valid &= jp2->m_validation_list != (struct opj_procedure_list *)0;
#line 2231
  l_is_valid &= jp2->numcl > 0U;
#line 2233
  l_is_valid &= jp2->h > 0U;
#line 2235
  l_is_valid &= jp2->w > 0U;
#line 2237
  i = (OPJ_UINT32 )0;
  {
#line 2237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2237
    if (! (i < jp2->numcomps)) {
#line 2237
      goto while_break;
    }
#line 2238
    l_is_valid &= ((jp2->comps + i)->bpcc & 127U) < 38U;
#line 2237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2243
  l_is_valid &= jp2->meth > 0U && jp2->meth < 3U;
#line 2247
  __cil_tmp6 = opj_stream_has_seek(cio);
  }
#line 2247
  l_is_valid &= __cil_tmp6;
#line 2249
  return (l_is_valid);
}
}
#line 2252 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_header_procedure(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  opj_jp2_box_t box ;
  OPJ_UINT32 l_nb_bytes_read ;
  opj_jp2_header_handler_t *l_current_handler ;
  opj_jp2_header_handler_t *l_current_handler_misplaced ;
  OPJ_UINT32 l_last_data_size ;
  OPJ_UINT32 l_current_data_size ;
  OPJ_BYTE *l_current_data ;
  void *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  opj_jp2_header_handler_t *__cil_tmp13 ;
  opj_jp2_header_handler_t *__cil_tmp14 ;
  OPJ_OFF_T __cil_tmp15 ;
  OPJ_OFF_T __cil_tmp16 ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_BYTE *new_current_data ;
  void *__cil_tmp19 ;
  OPJ_SIZE_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;

  {
  {
#line 2261
  l_last_data_size = (OPJ_UINT32 )1024;
#line 2263
  l_current_data = (OPJ_BYTE *)0;
#line 2270
  __cil_tmp11 = opj_calloc((size_t )1, (size_t )l_last_data_size);
#line 2270
  l_current_data = (OPJ_BYTE *)__cil_tmp11;
  }
#line 2272
  if (l_current_data == (OPJ_BYTE *)0) {
    {
#line 2273
    opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 file header\n\022V~EV");
    }
#line 2275
    return (0);
  }
  {
#line 2278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2278
    __cil_tmp12 = opj_jp2_read_boxhdr(& box, & l_nb_bytes_read, stream, p_manager);
    }
#line 2278
    if (! __cil_tmp12) {
#line 2278
      goto while_break;
    }
#line 2280
    if (box.type == 1785737827U) {
#line 2281
      if (jp2->jp2_state & 4U) {
        {
#line 2282
        jp2->jp2_state |= (unsigned int )8;
#line 2283
        opj_free(l_current_data);
        }
#line 2284
        return (1);
      } else {
        {
#line 2286
        opj_event_msg(p_manager, 1, "bad placed jpeg codestream\n");
#line 2287
        opj_free(l_current_data);
        }
#line 2288
        return (0);
      }
    } else
#line 2290
    if (box.length == 0U) {
      {
#line 2291
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
#line 2292
      opj_free(l_current_data);
      }
#line 2293
      return (0);
    } else
#line 2296
    if (box.length < l_nb_bytes_read) {
      {
#line 2297
      opj_event_msg(p_manager, 1, "invalid box size %d (%x)\n\255V~EV", box.length,
                    box.type);
#line 2299
      opj_free(l_current_data);
      }
#line 2300
      return (0);
    }
    {
#line 2303
    l_current_handler = opj_jp2_find_handler(box.type);
#line 2304
    l_current_handler_misplaced = opj_jp2_img_find_handler(box.type);
#line 2305
    l_current_data_size = box.length - l_nb_bytes_read;
    }
#line 2307
    if (l_current_handler != (opj_jp2_header_handler_t *)0) {
      _L: /* CIL Label */ 
#line 2308
      if (l_current_handler == (opj_jp2_header_handler_t *)0) {
        {
#line 2309
        opj_event_msg(p_manager, 2, "Found a misplaced \'%c%c%c%c\' box outside jp2h box\nV~EV",
                      (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type));
        }
#line 2313
        if (jp2->jp2_state & 4U) {
#line 2315
          l_current_handler = l_current_handler_misplaced;
        } else {
          {
#line 2317
          opj_event_msg(p_manager, 2, "JPEG2000 Header box not read yet, \'%c%c%c%c\' box will be ignored\n",
                        (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                        (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type));
#line 2321
          jp2->jp2_state |= (unsigned int )2147483647;
#line 2322
          __cil_tmp15 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
          }
#line 2322
          if (__cil_tmp15 != (long )l_current_data_size) {
            {
#line 2324
            opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n\300U~EV");
#line 2326
            opj_free(l_current_data);
            }
#line 2327
            return (0);
          }
#line 2329
          goto while_continue;
        }
      }
      {
#line 2332
      __cil_tmp16 = opj_stream_get_number_byte_left(stream);
      }
#line 2332
      if ((OPJ_OFF_T )l_current_data_size > __cil_tmp16) {
        {
#line 2334
        __cil_tmp17 = opj_stream_get_number_byte_left(stream);
#line 2334
        opj_event_msg(p_manager, 1, "Invalid box size %d for box \'%c%c%c%c\'. Need %d bytes, %d bytes remaining \n~EV",
                      box.length, (int )((OPJ_BYTE )(box.type >> 24)), (int )((OPJ_BYTE )(box.type >> 16)),
                      (int )((OPJ_BYTE )(box.type >> 8)), (int )((OPJ_BYTE )box.type),
                      l_current_data_size, (OPJ_UINT32 )__cil_tmp17);
#line 2339
        opj_free(l_current_data);
        }
#line 2340
        return (0);
      }
#line 2342
      if (l_current_data_size > l_last_data_size) {
        {
#line 2343
        __cil_tmp19 = opj_realloc(l_current_data, (size_t )l_current_data_size);
#line 2343
        new_current_data = (OPJ_BYTE *)__cil_tmp19;
        }
#line 2345
        if (! new_current_data) {
          {
#line 2346
          opj_free(l_current_data);
#line 2347
          opj_event_msg(p_manager, 1, "Not enough memory to handle jpeg2000 box\n\326V~EV");
          }
#line 2349
          return (0);
        }
#line 2351
        l_current_data = new_current_data;
#line 2352
        l_last_data_size = l_current_data_size;
      }
      {
#line 2355
      __cil_tmp20 = opj_stream_read_data(stream, l_current_data, (OPJ_SIZE_T )l_current_data_size,
                                         p_manager);
#line 2355
      l_nb_bytes_read = (OPJ_UINT32 )__cil_tmp20;
      }
#line 2357
      if (l_nb_bytes_read != l_current_data_size) {
        {
#line 2358
        opj_event_msg(p_manager, 1, "Problem with reading JPEG2000 box, stream error\n\220");
#line 2360
        opj_free(l_current_data);
        }
#line 2361
        return (0);
      }
      {
#line 2364
      __cil_tmp21 = (*(l_current_handler->handler))(jp2, l_current_data, l_current_data_size,
                                                    p_manager);
      }
#line 2364
      if (! __cil_tmp21) {
        {
#line 2366
        opj_free(l_current_data);
        }
#line 2367
        return (0);
      }
    } else
#line 2307
    if (l_current_handler_misplaced != (opj_jp2_header_handler_t *)0) {
#line 2307
      goto _L;
    } else {
#line 2370
      if (! (jp2->jp2_state & 1U)) {
        {
#line 2371
        opj_event_msg(p_manager, 1, "Malformed JP2 file format: first box must be JPEG 2000 signature box\n");
#line 2373
        opj_free(l_current_data);
        }
#line 2374
        return (0);
      }
#line 2376
      if (! (jp2->jp2_state & 2U)) {
        {
#line 2377
        opj_event_msg(p_manager, 1, "Malformed JP2 file format: second box must be file type box\n");
#line 2379
        opj_free(l_current_data);
        }
#line 2380
        return (0);
      }
      {
#line 2382
      jp2->jp2_state |= (unsigned int )2147483647;
#line 2383
      __cil_tmp22 = opj_stream_skip(stream, (OPJ_OFF_T )l_current_data_size, p_manager);
      }
#line 2383
      if (__cil_tmp22 != (long )l_current_data_size) {
#line 2385
        if (jp2->jp2_state & 8U) {
          {
#line 2388
          opj_event_msg(p_manager, 2, "Problem with skipping JPEG2000 box, stream error\n");
#line 2390
          opj_free(l_current_data);
          }
#line 2391
          return (1);
        } else {
          {
#line 2393
          opj_event_msg(p_manager, 1, "Problem with skipping JPEG2000 box, stream error\n");
#line 2395
          opj_free(l_current_data);
          }
#line 2396
          return (0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2402
  opj_free(l_current_data);
  }
#line 2404
  return (1);
}
}
#line 2417 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_exec(opj_jp2_t *jp2 , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp9 ;
  opj_procedure *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 2424
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 2426
  l_result = 1;
#line 2435
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 2436
  __cil_tmp10 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 2436
  l_procedure = (OPJ_BOOL (**)(opj_jp2_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp10;
#line 2439
  i = (OPJ_UINT32 )0;
  }
  {
#line 2439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2439
    if (! (i < l_nb_proc)) {
#line 2439
      goto while_break;
    }
    {
#line 2440
    __cil_tmp11 = (*(*l_procedure))(jp2, stream, p_manager);
#line 2440
    l_result = l_result && __cil_tmp11;
#line 2441
    l_procedure ++;
    }
#line 2439
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2445
  opj_procedure_list_clear(p_procedure_list);
  }
#line 2446
  return (l_result);
}
}
#line 2449 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;

  {
  {
#line 2461
  __cil_tmp5 = opj_jp2_setup_encoding_validation(jp2, p_manager);
  }
#line 2461
  if (! __cil_tmp5) {
#line 2462
    return (0);
  }
  {
#line 2466
  __cil_tmp6 = opj_jp2_exec(jp2, jp2->m_validation_list, stream, p_manager);
  }
#line 2466
  if (! __cil_tmp6) {
#line 2467
    return (0);
  }
  {
#line 2471
  __cil_tmp7 = opj_jp2_setup_header_writing(jp2, p_manager);
  }
#line 2471
  if (! __cil_tmp7) {
#line 2472
    return (0);
  }
  {
#line 2476
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_procedure_list, stream, p_manager);
  }
#line 2476
  if (! __cil_tmp8) {
#line 2477
    return (0);
  }
  {
#line 2480
  __cil_tmp9 = opj_j2k_start_compress(jp2->j2k, stream, p_image, p_manager);
  }
#line 2480
  return (__cil_tmp9);
}
}
#line 2483 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2485
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t ));
#line 2488
  i = (OPJ_UINT32 )0;
  {
#line 2488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2488
    if (! (i < l_handler_size)) {
#line 2488
      goto while_break;
    }
#line 2489
    if (jp2_header[i].id == p_id) {
#line 2490
      return (& jp2_header[i]);
    }
#line 2488
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2493
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2503 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static opj_jp2_header_handler_t *opj_jp2_img_find_handler(OPJ_UINT32 p_id ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_handler_size ;

  {
#line 2506
  l_handler_size = (OPJ_UINT32 )(sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t ));
#line 2508
  i = (OPJ_UINT32 )0;
  {
#line 2508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2508
    if (! (i < l_handler_size)) {
#line 2508
      goto while_break;
    }
#line 2509
    if (jp2_img_header[i].id == p_id) {
#line 2510
      return (& jp2_img_header[i]);
    }
#line 2508
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2514
  return ((opj_jp2_header_handler_t *)((void *)0));
}
}
#line 2527 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_magic_number ;

  {
#line 2541
  if (jp2->jp2_state != 0U) {
    {
#line 2542
    opj_event_msg(p_manager, 1, "The signature box must be the first box in the file.\nV");
    }
#line 2544
    return (0);
  }
#line 2548
  if (p_header_size != 4U) {
    {
#line 2549
    opj_event_msg(p_manager, 1, "Error with JP signature Box size\n");
    }
#line 2550
    return (0);
  }
  {
#line 2554
  opj_read_bytes_LE(p_header_data, & l_magic_number, (OPJ_UINT32 )4);
  }
#line 2555
  if (l_magic_number != 218793738U) {
    {
#line 2556
    opj_event_msg(p_manager, 1, "Error with JP Signature : bad magic number\n~EV");
    }
#line 2558
    return (0);
  }
#line 2561
  jp2->jp2_state |= (unsigned int )1;
#line 2563
  return (1);
}
}
#line 2576 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_ftyp(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_remaining_bytes ;
  void *__cil_tmp7 ;

  {
#line 2589
  if (jp2->jp2_state != 1U) {
    {
#line 2590
    opj_event_msg(p_manager, 1, "The ftyp box must be the second box in the file.\n");
    }
#line 2592
    return (0);
  }
#line 2596
  if (p_header_size < 8U) {
    {
#line 2597
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2598
    return (0);
  }
  {
#line 2601
  opj_read_bytes_LE(p_header_data, & jp2->brand, (OPJ_UINT32 )4);
#line 2602
  p_header_data += 4;
#line 2604
  opj_read_bytes_LE(p_header_data, & jp2->minversion, (OPJ_UINT32 )4);
#line 2605
  p_header_data += 4;
#line 2607
  l_remaining_bytes = p_header_size - 8U;
  }
#line 2610
  if ((l_remaining_bytes & 3U) != 0U) {
    {
#line 2611
    opj_event_msg(p_manager, 1, "Error with FTYP signature Box size\n");
    }
#line 2612
    return (0);
  }
#line 2616
  jp2->numcl = l_remaining_bytes >> 2;
#line 2617
  if (jp2->numcl) {
    {
#line 2618
    __cil_tmp7 = opj_calloc((size_t )jp2->numcl, sizeof(OPJ_UINT32 ));
#line 2618
    jp2->cl = (OPJ_UINT32 *)__cil_tmp7;
    }
#line 2619
    if (jp2->cl == (OPJ_UINT32 *)0) {
      {
#line 2620
      opj_event_msg(p_manager, 1, "Not enough memory with FTYP Box\n\220");
      }
#line 2621
      return (0);
    }
  }
#line 2625
  i = (OPJ_UINT32 )0;
  {
#line 2625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2625
    if (! (i < jp2->numcl)) {
#line 2625
      goto while_break;
    }
    {
#line 2626
    opj_read_bytes_LE(p_header_data, jp2->cl + i, (OPJ_UINT32 )4);
#line 2627
    p_header_data += 4;
    }
#line 2625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2630
  jp2->jp2_state |= (unsigned int )2;
#line 2632
  return (1);
}
}
#line 2635 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_skip_jp2c(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp4 ;
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 2644
  jp2->j2k_codestream_offset = opj_stream_tell(stream);
#line 2646
  __cil_tmp5 = opj_stream_skip(stream, (OPJ_OFF_T )8, p_manager);
  }
#line 2646
  if (__cil_tmp5 != 8L) {
#line 2647
    return (0);
  }
#line 2650
  return (1);
}
}
#line 2653 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jpip_skip_iptr(opj_jp2_t *jp2 , opj_stream_private_t *stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp4 ;
  OPJ_OFF_T __cil_tmp5 ;

  {
  {
#line 2662
  jp2->jpip_iptr_offset = opj_stream_tell(stream);
#line 2664
  __cil_tmp5 = opj_stream_skip(stream, (OPJ_OFF_T )24, p_manager);
  }
#line 2664
  if (__cil_tmp5 != 24L) {
#line 2665
    return (0);
  }
#line 2668
  return (1);
}
}
#line 2681 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_jp2h(opj_jp2_t *jp2 , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_box_size ;
  OPJ_UINT32 l_current_data_size ;
  opj_jp2_box_t box ;
  opj_jp2_header_handler_t *l_current_handler ;
  OPJ_BOOL l_has_ihdr ;
  OPJ_BOOL __cil_tmp10 ;
  opj_jp2_header_handler_t *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 2687
  l_box_size = (OPJ_UINT32 )0;
#line 2687
  l_current_data_size = (OPJ_UINT32 )0;
#line 2690
  l_has_ihdr = 0;
#line 2698
  if ((jp2->jp2_state & 2U) != 2U) {
    {
#line 2699
    opj_event_msg(p_manager, 1, "The  box must be the first box in the file.\n");
    }
#line 2701
    return (0);
  }
#line 2704
  jp2->jp2_img_state = (OPJ_UINT32 )0;
  {
#line 2707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2707
    if (! (p_header_size > 0U)) {
#line 2707
      goto while_break;
    }
    {
#line 2709
    __cil_tmp10 = opj_jp2_read_boxhdr_char(& box, p_header_data, & l_box_size, p_header_size,
                                           p_manager);
    }
#line 2709
    if (! __cil_tmp10) {
      {
#line 2711
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box\nW~EV");
      }
#line 2713
      return (0);
    }
#line 2716
    if (box.length > p_header_size) {
      {
#line 2717
      opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
      }
#line 2719
      return (0);
    }
    {
#line 2722
    l_current_handler = opj_jp2_img_find_handler(box.type);
#line 2723
    l_current_data_size = box.length - l_box_size;
#line 2724
    p_header_data += l_box_size;
    }
#line 2726
    if (l_current_handler != (opj_jp2_header_handler_t *)0) {
      {
#line 2727
      __cil_tmp12 = (*(l_current_handler->handler))(jp2, p_header_data, l_current_data_size,
                                                    p_manager);
      }
#line 2727
      if (! __cil_tmp12) {
#line 2729
        return (0);
      }
    } else {
#line 2732
      jp2->jp2_img_state |= (unsigned int )2147483647;
    }
#line 2735
    if (box.type == 1768449138U) {
#line 2736
      l_has_ihdr = 1;
    }
#line 2739
    p_header_data += l_current_data_size;
#line 2740
    p_header_size -= box.length;
  }
  while_break: /* CIL Label */ ;
  }
#line 2743
  if (l_has_ihdr == 0) {
    {
#line 2744
    opj_event_msg(p_manager, 1, "Stream error while reading JP2 Header box: no \'ihdr\' box.\nW~EV");
    }
#line 2746
    return (0);
  }
#line 2749
  jp2->jp2_state |= (unsigned int )4;
#line 2750
  jp2->has_jp2h = (OPJ_BYTE )1;
#line 2752
  return (1);
}
}
#line 2755 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_read_boxhdr_char(opj_jp2_box_t *box , OPJ_BYTE *p_data , OPJ_UINT32 *p_number_bytes_read ,
                                         OPJ_UINT32 p_box_max_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_value ;
  OPJ_UINT32 l_xl_part_size ;

  {
#line 2770
  if (p_box_max_size < 8U) {
    {
#line 2771
    opj_event_msg(p_manager, 1, "Cannot handle box of less than 8 bytes\n");
    }
#line 2772
    return (0);
  }
  {
#line 2776
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2777
  p_data += 4;
#line 2778
  box->length = (OPJ_UINT32 )l_value;
#line 2780
  opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2781
  p_data += 4;
#line 2782
  box->type = (OPJ_UINT32 )l_value;
#line 2784
  *p_number_bytes_read = (OPJ_UINT32 )8;
  }
#line 2788
  if (box->length == 1U) {
#line 2791
    if (p_box_max_size < 16U) {
      {
#line 2792
      opj_event_msg(p_manager, 1, "Cannot handle XL box of less than 16 bytes\n");
      }
#line 2794
      return (0);
    }
    {
#line 2797
    opj_read_bytes_LE(p_data, & l_xl_part_size, (OPJ_UINT32 )4);
#line 2798
    p_data += 4;
#line 2799
    *p_number_bytes_read += (unsigned int )4;
    }
#line 2801
    if (l_xl_part_size != 0U) {
      {
#line 2802
      opj_event_msg(p_manager, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 2804
      return (0);
    }
    {
#line 2807
    opj_read_bytes_LE(p_data, & l_value, (OPJ_UINT32 )4);
#line 2808
    *p_number_bytes_read += (unsigned int )4;
#line 2809
    box->length = (OPJ_UINT32 )l_value;
    }
#line 2811
    if (box->length == 0U) {
      {
#line 2812
      opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
      }
#line 2813
      return (0);
    }
  } else
#line 2815
  if (box->length == 0U) {
    {
#line 2816
    opj_event_msg(p_manager, 1, "Cannot handle box of undefined sizes\n");
    }
#line 2817
    return (0);
  }
#line 2819
  if (box->length < *p_number_bytes_read) {
    {
#line 2820
    opj_event_msg(p_manager, 1, "Box length is inconsistent.\n");
    }
#line 2821
    return (0);
  }
#line 2823
  return (1);
}
}
#line 2826 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  int ret ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
  {
#line 2840
  __cil_tmp6 = opj_jp2_setup_decoding_validation(jp2, p_manager);
  }
#line 2840
  if (! __cil_tmp6) {
#line 2841
    return (0);
  }
  {
#line 2845
  __cil_tmp7 = opj_jp2_setup_header_reading(jp2, p_manager);
  }
#line 2845
  if (! __cil_tmp7) {
#line 2846
    return (0);
  }
  {
#line 2850
  __cil_tmp8 = opj_jp2_exec(jp2, jp2->m_validation_list, p_stream, p_manager);
  }
#line 2850
  if (! __cil_tmp8) {
#line 2851
    return (0);
  }
  {
#line 2855
  __cil_tmp9 = opj_jp2_exec(jp2, jp2->m_procedure_list, p_stream, p_manager);
  }
#line 2855
  if (! __cil_tmp9) {
#line 2856
    return (0);
  }
#line 2858
  if ((int )jp2->has_jp2h == 0) {
    {
#line 2859
    opj_event_msg(p_manager, 1, "JP2H box missing. Required.\n");
    }
#line 2860
    return (0);
  }
#line 2862
  if ((int )jp2->has_ihdr == 0) {
    {
#line 2863
    opj_event_msg(p_manager, 1, "IHDR box_missing. Required.\nEV");
    }
#line 2864
    return (0);
  }
  {
#line 2867
  ret = opj_j2k_read_header(p_stream, jp2->j2k, p_image, p_manager);
  }
#line 2872
  if (p_image) {
#line 2872
    if (*p_image) {
#line 2874
      if (jp2->enumcs == 16U) {
#line 2875
        (*p_image)->color_space = (OPJ_COLOR_SPACE )1;
      } else
#line 2876
      if (jp2->enumcs == 17U) {
#line 2877
        (*p_image)->color_space = (OPJ_COLOR_SPACE )2;
      } else
#line 2878
      if (jp2->enumcs == 18U) {
#line 2879
        (*p_image)->color_space = (OPJ_COLOR_SPACE )3;
      } else
#line 2880
      if (jp2->enumcs == 24U) {
#line 2881
        (*p_image)->color_space = (OPJ_COLOR_SPACE )4;
      } else
#line 2882
      if (jp2->enumcs == 12U) {
#line 2883
        (*p_image)->color_space = (OPJ_COLOR_SPACE )5;
      } else {
#line 2885
        (*p_image)->color_space = (OPJ_COLOR_SPACE )-1;
      }
#line 2888
      if (jp2->color.icc_profile_buf) {
#line 2889
        (*p_image)->icc_profile_buf = jp2->color.icc_profile_buf;
#line 2890
        (*p_image)->icc_profile_len = jp2->color.icc_profile_len;
#line 2891
        jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
      }
    }
  }
#line 2894
  return (ret);
}
}
#line 2897 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_encoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 2904
  __cil_tmp3 = opj_procedure_list_add_procedure(jp2->m_validation_list, (opj_procedure )(& opj_jp2_default_validation),
                                                p_manager);
  }
#line 2904
  if (! __cil_tmp3) {
#line 2906
    return (0);
  }
#line 2910
  return (1);
}
}
#line 2913 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_decoding_validation(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2925
  return (1);
}
}
#line 2928 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_writing(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 2935
  __cil_tmp3 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp),
                                                p_manager);
  }
#line 2935
  if (! __cil_tmp3) {
#line 2937
    return (0);
  }
  {
#line 2939
  __cil_tmp4 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_ftyp),
                                                p_manager);
  }
#line 2939
  if (! __cil_tmp4) {
#line 2941
    return (0);
  }
  {
#line 2943
  __cil_tmp5 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_write_jp2h),
                                                p_manager);
  }
#line 2943
  if (! __cil_tmp5) {
#line 2945
    return (0);
  }
#line 2947
  if (jp2->jpip_on) {
    {
#line 2948
    __cil_tmp6 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jpip_skip_iptr),
                                                  p_manager);
    }
#line 2948
    if (! __cil_tmp6) {
#line 2950
      return (0);
    }
  }
  {
#line 2953
  __cil_tmp7 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_skip_jp2c),
                                                p_manager);
  }
#line 2953
  if (! __cil_tmp7) {
#line 2955
    return (0);
  }
#line 2960
  return (1);
}
}
#line 2963 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
static OPJ_BOOL opj_jp2_setup_header_reading(opj_jp2_t *jp2 , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 2970
  __cil_tmp3 = opj_procedure_list_add_procedure(jp2->m_procedure_list, (opj_procedure )(& opj_jp2_read_header_procedure),
                                                p_manager);
  }
#line 2970
  if (! __cil_tmp3) {
#line 2972
    return (0);
  }
#line 2977
  return (1);
}
}
#line 2980 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 2993
  __cil_tmp12 = opj_j2k_read_tile_header(p_jp2->j2k, p_tile_index, p_data_size, p_tile_x0,
                                         p_tile_y0, p_tile_x1, p_tile_y1, p_nb_comps,
                                         p_go_on, p_stream, p_manager);
  }
#line 2993
  return (__cil_tmp12);
}
}
#line 3004 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 3013
  __cil_tmp7 = opj_j2k_write_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size, p_stream,
                                  p_manager);
  }
#line 3013
  return (__cil_tmp7);
}
}
#line 3017 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 3025
  __cil_tmp7 = opj_j2k_decode_tile(p_jp2->j2k, p_tile_index, p_data, p_data_size,
                                   p_stream, p_manager);
  }
#line 3025
  return (__cil_tmp7);
}
}
#line 3029 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
void opj_jp2_destroy(opj_jp2_t *jp2 ) 
{ 


  {
#line 3031
  if (jp2) {
    {
#line 3033
    opj_j2k_destroy(jp2->j2k);
#line 3034
    jp2->j2k = (opj_j2k_t *)0;
    }
#line 3036
    if (jp2->comps) {
      {
#line 3037
      opj_free(jp2->comps);
#line 3038
      jp2->comps = (opj_jp2_comps_t *)0;
      }
    }
#line 3041
    if (jp2->cl) {
      {
#line 3042
      opj_free(jp2->cl);
#line 3043
      jp2->cl = (OPJ_UINT32 *)0;
      }
    }
#line 3046
    if (jp2->color.icc_profile_buf) {
      {
#line 3047
      opj_free(jp2->color.icc_profile_buf);
#line 3048
      jp2->color.icc_profile_buf = (OPJ_BYTE *)0;
      }
    }
#line 3051
    if (jp2->color.jp2_cdef) {
#line 3052
      if ((jp2->color.jp2_cdef)->info) {
        {
#line 3053
        opj_free((jp2->color.jp2_cdef)->info);
#line 3054
        (jp2->color.jp2_cdef)->info = (opj_jp2_cdef_info_t *)((void *)0);
        }
      }
      {
#line 3057
      opj_free(jp2->color.jp2_cdef);
#line 3058
      jp2->color.jp2_cdef = (opj_jp2_cdef_t *)0;
      }
    }
#line 3061
    if (jp2->color.jp2_pclr) {
#line 3062
      if ((jp2->color.jp2_pclr)->cmap) {
        {
#line 3063
        opj_free((jp2->color.jp2_pclr)->cmap);
#line 3064
        (jp2->color.jp2_pclr)->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
        }
      }
#line 3066
      if ((jp2->color.jp2_pclr)->channel_sign) {
        {
#line 3067
        opj_free((jp2->color.jp2_pclr)->channel_sign);
#line 3068
        (jp2->color.jp2_pclr)->channel_sign = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3070
      if ((jp2->color.jp2_pclr)->channel_size) {
        {
#line 3071
        opj_free((jp2->color.jp2_pclr)->channel_size);
#line 3072
        (jp2->color.jp2_pclr)->channel_size = (OPJ_BYTE *)((void *)0);
        }
      }
#line 3074
      if ((jp2->color.jp2_pclr)->entries) {
        {
#line 3075
        opj_free((jp2->color.jp2_pclr)->entries);
#line 3076
        (jp2->color.jp2_pclr)->entries = (OPJ_UINT32 *)((void *)0);
        }
      }
      {
#line 3079
      opj_free(jp2->color.jp2_pclr);
#line 3080
      jp2->color.jp2_pclr = (opj_jp2_pclr_t *)0;
      }
    }
#line 3083
    if (jp2->m_validation_list) {
      {
#line 3084
      opj_procedure_list_destroy(jp2->m_validation_list);
#line 3085
      jp2->m_validation_list = (struct opj_procedure_list *)0;
      }
    }
#line 3088
    if (jp2->m_procedure_list) {
      {
#line 3089
      opj_procedure_list_destroy(jp2->m_procedure_list);
#line 3090
      jp2->m_procedure_list = (struct opj_procedure_list *)0;
      }
    }
    {
#line 3093
    opj_free(jp2);
    }
  }
  return;
}
}
#line 3097 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_components(opj_jp2_t *p_jp2 , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 3102
  __cil_tmp5 = opj_j2k_set_decoded_components(p_jp2->j2k, numcomps, comps_indices,
                                              p_manager);
  }
#line 3102
  return (__cil_tmp5);
}
}
#line 3107 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 3114
  __cil_tmp8 = opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y,
                                       p_end_x, p_end_y, p_manager);
  }
#line 3114
  return (__cil_tmp8);
}
}
#line 3118 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 3125
  if (! p_image) {
#line 3126
    return (0);
  }
  {
#line 3129
  opj_event_msg(p_manager, 2, "JP2 box which are after the codestream will not be read by this function.\n");
#line 3132
  __cil_tmp6 = opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index);
  }
#line 3132
  if (! __cil_tmp6) {
    {
#line 3133
    opj_event_msg(p_manager, 1, "Failed to decode the codestream in the JP2 file\n\220");
    }
#line 3135
    return (0);
  }
  {
#line 3138
  __cil_tmp7 = opj_jp2_apply_color_postprocessing(p_jp2, p_image, p_manager);
  }
#line 3138
  return (__cil_tmp7);
}
}
#line 3145 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_j2k_t *__cil_tmp5 ;
  opj_procedure_list_t *__cil_tmp6 ;
  opj_procedure_list_t *__cil_tmp7 ;

  {
  {
#line 3147
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_jp2_t ));
#line 3147
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 3148
  if (jp2) {
#line 3151
    if (! p_is_decoder) {
      {
#line 3152
      jp2->j2k = opj_j2k_create_compress();
      }
    } else {
      {
#line 3154
      jp2->j2k = opj_j2k_create_decompress();
      }
    }
#line 3157
    if (jp2->j2k == (opj_j2k_t *)0) {
      {
#line 3158
      opj_jp2_destroy(jp2);
      }
#line 3159
      return ((opj_jp2_t *)0);
    }
    {
#line 3163
    jp2->color.icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 3164
    jp2->color.icc_profile_len = (OPJ_UINT32 )0;
#line 3165
    jp2->color.jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
#line 3166
    jp2->color.jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
#line 3167
    jp2->color.jp2_has_colr = (OPJ_BYTE )0;
#line 3170
    jp2->m_validation_list = opj_procedure_list_create();
    }
#line 3171
    if (! jp2->m_validation_list) {
      {
#line 3172
      opj_jp2_destroy(jp2);
      }
#line 3173
      return ((opj_jp2_t *)0);
    }
    {
#line 3177
    jp2->m_procedure_list = opj_procedure_list_create();
    }
#line 3178
    if (! jp2->m_procedure_list) {
      {
#line 3179
      opj_jp2_destroy(jp2);
      }
#line 3180
      return ((opj_jp2_t *)0);
    }
  }
#line 3184
  return (jp2);
}
}
#line 3187 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) 
{ 


  {
  {
#line 3192
  j2k_dump(p_jp2->j2k, flag, out_stream);
  }
  return;
}
}
#line 3197 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_index_t *__cil_tmp2 ;

  {
  {
#line 3199
  __cil_tmp2 = j2k_get_cstr_index(p_jp2->j2k);
  }
#line 3199
  return (__cil_tmp2);
}
}
#line 3202 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) 
{ 
  opj_codestream_info_v2_t *__cil_tmp2 ;

  {
  {
#line 3204
  __cil_tmp2 = j2k_get_cstr_info(p_jp2->j2k);
  }
#line 3204
  return (__cil_tmp2);
}
}
#line 3207 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3211
  __cil_tmp4 = opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
  }
#line 3211
  return (__cil_tmp4);
}
}
#line 3216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.c"
OPJ_BOOL opj_jp2_encoder_set_extra_options(opj_jp2_t *p_jp2 , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3221
  __cil_tmp4 = opj_j2k_encoder_set_extra_options(p_jp2->j2k, p_options, p_manager);
  }
#line 3221
  return (__cil_tmp4);
}
}
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 61
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 74
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 87
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 95
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 102
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 109
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 128
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 134
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 145
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 159
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 171
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 179
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 186
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 197
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 205
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 212
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 219
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 231
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 246
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 262
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) ;
#line 274
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 289
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) ;
#line 303
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 318
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 328
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 340
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 351
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 358
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 363
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 367
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 372
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) ;
#line 375
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) ;
#line 387
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 389
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) ;
#line 397
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 400
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 407
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 421
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 425
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 440
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 450
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 461
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 472
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 484
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 495
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 506
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 517
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 531
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 542
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 556
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 567
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 576
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 588
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 599
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 613
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 624
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 638
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 647
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 656
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 667
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 678
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 685
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 695
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 703
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 710
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 720
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 732
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 744
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) ;
#line 756
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 768
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 782
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 794
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) ;
#line 804
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 815
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) ;
#line 826
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 840
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 860
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) ;
#line 875
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 892
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 907
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 911 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
#line 913
  if (p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte) {
    {
#line 914
    opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                       p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 916
    (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
    }
  } else {
    {
#line 918
    opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                       p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 920
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 2;
    }
  }
  {
#line 923
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 925
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
  return;
}
}
#line 938
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 953
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 965
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 989
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) ;
#line 1000
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1011
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1021
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1035
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) ;
#line 1048
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1061
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1074
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1087
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1099
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1111
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1116
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 1119
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1121
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1123
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1125
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1128
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1130
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1132
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1134
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1137
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1139
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1141
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1143
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) ;
#line 1153
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) ;
#line 1164
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1175
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1189
static OPJ_BOOL opj_j2k_read_cap(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1201
static OPJ_BOOL opj_j2k_read_cpf(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1214
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1225
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1236
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1247
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1265
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager ) ;
#line 1282
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1297
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1303
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1305
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1307
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1309
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1311
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1313
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1315
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) ;
#line 1318
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) ;
#line 1321
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                       opj_event_mgr_t *p_manager ) ;
#line 1324
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters , opj_image_t *image ,
                                         opj_event_mgr_t *p_manager ) ;
#line 1338
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) ;
#line 1352 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 1364 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1374 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1381 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1408 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[23]  = 
#line 1408
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & opj_j2k_read_ppm}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65360, (OPJ_UINT32 )4, & opj_j2k_read_cap}, 
        {(OPJ_UINT32 )65369, (OPJ_UINT32 )4, & opj_j2k_read_cpf}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1447 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1450
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1451
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1455
  i = (OPJ_UINT32 )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (i < p_nb_elem)) {
#line 1455
      goto while_break;
    }
    {
#line 1456
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1458
    l_src_data += sizeof(OPJ_INT16 );
#line 1460
    __cil_tmp8 = l_dest_data;
#line 1460
    l_dest_data ++;
#line 1460
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1464 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1467
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1468
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1472
  i = (OPJ_UINT32 )0;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1472
    if (! (i < p_nb_elem)) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1475
    l_src_data += sizeof(OPJ_INT32 );
#line 1477
    __cil_tmp8 = l_dest_data;
#line 1477
    l_dest_data ++;
#line 1477
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1481 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1484
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1485
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1489
  i = (OPJ_UINT32 )0;
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1489
    if (! (i < p_nb_elem)) {
#line 1489
      goto while_break;
    }
    {
#line 1490
    opj_read_float_LE(l_src_data, & l_temp);
#line 1492
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1494
    __cil_tmp8 = l_dest_data;
#line 1494
    l_dest_data ++;
#line 1494
    *__cil_tmp8 = l_temp;
    }
#line 1489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1498 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1501
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1502
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1506
  i = (OPJ_UINT32 )0;
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (! (i < p_nb_elem)) {
#line 1506
      goto while_break;
    }
    {
#line 1507
    opj_read_double_LE(l_src_data, & l_temp);
#line 1509
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1511
    __cil_tmp8 = l_dest_data;
#line 1511
    l_dest_data ++;
#line 1511
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1515 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1518
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1519
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1523
  i = (OPJ_UINT32 )0;
  {
#line 1523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1523
    if (! (i < p_nb_elem)) {
#line 1523
      goto while_break;
    }
    {
#line 1524
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1526
    l_src_data += sizeof(OPJ_INT16 );
#line 1528
    __cil_tmp8 = l_dest_data;
#line 1528
    l_dest_data ++;
#line 1528
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1532 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1535
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1536
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1540
  i = (OPJ_UINT32 )0;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1540
    if (! (i < p_nb_elem)) {
#line 1540
      goto while_break;
    }
    {
#line 1541
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1543
    l_src_data += sizeof(OPJ_INT32 );
#line 1545
    __cil_tmp8 = l_dest_data;
#line 1545
    l_dest_data ++;
#line 1545
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1549 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1552
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1553
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1557
  i = (OPJ_UINT32 )0;
  {
#line 1557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1557
    if (! (i < p_nb_elem)) {
#line 1557
      goto while_break;
    }
    {
#line 1558
    opj_read_float_LE(l_src_data, & l_temp);
#line 1560
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1562
    __cil_tmp8 = l_dest_data;
#line 1562
    l_dest_data ++;
#line 1562
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1566 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1569
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1570
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1574
  i = (OPJ_UINT32 )0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! (i < p_nb_elem)) {
#line 1574
      goto while_break;
    }
    {
#line 1575
    opj_read_double_LE(l_src_data, & l_temp);
#line 1577
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1579
    __cil_tmp8 = l_dest_data;
#line 1579
    l_dest_data ++;
#line 1579
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1583 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1586
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1587
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1591
  i = (OPJ_UINT32 )0;
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1591
    if (! (i < p_nb_elem)) {
#line 1591
      goto while_break;
    }
    {
#line 1592
    __cil_tmp8 = l_src_data;
#line 1592
    l_src_data ++;
#line 1592
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1594
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1596
    l_dest_data += sizeof(OPJ_INT16 );
    }
#line 1591
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1600 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1603
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1604
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1608
  i = (OPJ_UINT32 )0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (i < p_nb_elem)) {
#line 1608
      goto while_break;
    }
    {
#line 1609
    __cil_tmp8 = l_src_data;
#line 1609
    l_src_data ++;
#line 1609
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1611
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1613
    l_dest_data += sizeof(OPJ_INT32 );
    }
#line 1608
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1617 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1620
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1621
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1625
  i = (OPJ_UINT32 )0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (i < p_nb_elem)) {
#line 1625
      goto while_break;
    }
    {
#line 1626
    __cil_tmp8 = l_src_data;
#line 1626
    l_src_data ++;
#line 1626
    l_temp = (OPJ_FLOAT32 )*__cil_tmp8;
#line 1628
    opj_write_float_LE(l_dest_data, l_temp);
#line 1630
    l_dest_data += sizeof(OPJ_FLOAT32 );
    }
#line 1625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1634 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1637
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1638
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1642
  i = (OPJ_UINT32 )0;
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1642
    if (! (i < p_nb_elem)) {
#line 1642
      goto while_break;
    }
    {
#line 1643
    __cil_tmp8 = l_src_data;
#line 1643
    l_src_data ++;
#line 1643
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1645
    opj_write_double_LE(l_dest_data, l_temp);
#line 1647
    l_dest_data += sizeof(OPJ_FLOAT64 );
    }
#line 1642
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1651 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 1654
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! ((int )po->enum_prog != -1)) {
#line 1654
      goto while_break;
    }
#line 1655
    if ((int )po->enum_prog == (int )prg_order) {
#line 1656
      return ((char const   *)po->str_prog);
    }
#line 1654
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1659
  return ((char const   *)po->str_prog);
}
}
#line 1662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index___0 ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  void *__cil_tmp18 ;
  opj_poc_t *poc ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 layno0 ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 __cil_tmp25 ;

  {
  {
#line 1673
  step_c = (OPJ_UINT32 )1;
#line 1674
  step_r = p_num_comps * step_c;
#line 1675
  step_l = p_nb_resolutions * step_r;
#line 1676
  loss = 0;
#line 1680
  __cil_tmp18 = opj_calloc((size_t )step_l * (unsigned long )p_num_layers, sizeof(OPJ_UINT32 ));
#line 1680
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1682
  if (packet_array == (OPJ_UINT32 *)0) {
    {
#line 1683
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1685
    return (0);
  }
#line 1689
  i = (OPJ_UINT32 )0;
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! (i < p_nb_pocs)) {
#line 1689
      goto while_break;
    }
#line 1690
    poc = p_pocs + i;
#line 1691
    if (tileno + 1U == poc->tile) {
#line 1692
      index___0 = step_r * poc->resno0;
#line 1695
      resno = poc->resno0;
      {
#line 1695
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1695
        if (! (resno < __cil_tmp20)) {
#line 1695
          goto while_break___0;
        }
#line 1697
        res_index = index___0 + poc->compno0 * step_c;
#line 1700
        compno = poc->compno0;
        {
#line 1700
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1700
          if (! (compno < __cil_tmp22)) {
#line 1700
            goto while_break___1;
          }
#line 1703
          layno0 = (OPJ_UINT32 )0;
#line 1704
          comp_index = res_index + layno0 * step_l;
#line 1707
          layno = layno0;
          {
#line 1707
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1707
            if (! (layno < __cil_tmp25)) {
#line 1707
              goto while_break___2;
            }
#line 1709
            *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1710
            comp_index += step_l;
#line 1708
            layno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1713
          res_index += step_c;
#line 1701
          compno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1716
        index___0 += step_r;
#line 1696
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1689
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1721
  index___0 = (OPJ_UINT32 )0;
#line 1722
  layno = (OPJ_UINT32 )0;
  {
#line 1722
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1722
    if (! (layno < p_num_layers)) {
#line 1722
      goto while_break___3;
    }
#line 1723
    resno = (OPJ_UINT32 )0;
    {
#line 1723
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1723
      if (! (resno < p_nb_resolutions)) {
#line 1723
        goto while_break___4;
      }
#line 1724
      compno = (OPJ_UINT32 )0;
      {
#line 1724
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1724
        if (! (compno < p_num_comps)) {
#line 1724
          goto while_break___5;
        }
#line 1725
        loss |= *(packet_array + index___0) != 1U;
#line 1733
        index___0 += step_c;
#line 1724
        compno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1723
      resno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1722
    layno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1738
  if (loss) {
    {
#line 1739
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1742
  opj_free(packet_array);
  }
#line 1744
  return (! loss);
}
}
#line 1749 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;
  char const   *__cil_tmp9 ;

  {
  {
#line 1752
  prog = (OPJ_CHAR *)0;
#line 1754
  tpnum = (OPJ_UINT32 )1;
#line 1755
  tcp = (opj_tcp_t *)0;
#line 1756
  l_current_poc = (opj_poc_t *)0;
#line 1763
  tcp = cp->tcps + tileno;
#line 1766
  l_current_poc = & tcp->pocs[pino];
#line 1770
  prog = (OPJ_CHAR *)opj_j2k_convert_progression_order(tcp->prg);
  }
#line 1773
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1774
    i = 0;
    {
#line 1774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1774
      if (! (i < 4)) {
#line 1774
        goto while_break;
      }
      {
#line 1777
      if ((int )*(prog + i) == 'C') {
#line 1777
        goto case_67;
      }
#line 1781
      if ((int )*(prog + i) == 'R') {
#line 1781
        goto case_82;
      }
#line 1785
      if ((int )*(prog + i) == 'P') {
#line 1785
        goto case_80;
      }
#line 1789
      if ((int )*(prog + i) == 'L') {
#line 1789
        goto case_76;
      }
#line 1775
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1778
      tpnum *= l_current_poc->compE;
#line 1779
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1782
      tpnum *= l_current_poc->resE;
#line 1783
      goto switch_break;
      case_80: /* CIL Label */ 
#line 1786
      tpnum *= l_current_poc->prcE;
#line 1787
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1790
      tpnum *= l_current_poc->layE;
#line 1791
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1794
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1795
        cp->m_specific_param.m_enc.m_tp_pos = i;
#line 1796
        goto while_break;
      }
#line 1774
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1800
    tpnum = (OPJ_UINT32 )1;
  }
#line 1803
  return (tpnum);
}
}
#line 1806 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp12 ;

  {
#line 1827
  l_nb_tiles = cp->tw * cp->th;
#line 1828
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1829
  tcp = cp->tcps;
#line 1866
  tileno = (OPJ_UINT32 )0;
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (! (tileno < l_nb_tiles)) {
#line 1866
      goto while_break;
    }
    {
#line 1867
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1869
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1871
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1871
      if (! (pino <= tcp->numpocs)) {
#line 1871
        goto while_break___0;
      }
      {
#line 1872
      __cil_tmp12 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1872
      tp_num = __cil_tmp12;
#line 1874
      *p_nb_tiles += tp_num;
#line 1876
      cur_totnum_tp += tp_num;
      }
#line 1871
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1878
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1880
    tcp ++;
#line 1866
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1884
  return (1);
}
}
#line 1887 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp5 ;

  {
  {
#line 1892
  l_start_stream = (OPJ_BYTE *)0;
#line 1899
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1902
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1904
  __cil_tmp5 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1904
  if (__cil_tmp5 != 2UL) {
#line 1905
    return (0);
  }
#line 1918
  return (1);
}
}
#line 1927 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp6 ;
  OPJ_OFF_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1940
  __cil_tmp6 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                    p_manager);
  }
#line 1940
  if (__cil_tmp6 != 2UL) {
#line 1941
    return (0);
  }
  {
#line 1944
  opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1945
  if (l_marker != 65359U) {
#line 1946
    return (0);
  }
  {
#line 1950
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1953
  __cil_tmp7 = opj_stream_tell(p_stream);
#line 1953
  (p_j2k->cstr_index)->main_head_start = __cil_tmp7 - 2L;
#line 1955
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%ld).\n", (p_j2k->cstr_index)->main_head_start);
#line 1960
  __cil_tmp8 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                    (OPJ_UINT32 )2);
  }
#line 1960
  if (0 == __cil_tmp8) {
    {
#line 1962
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n");
    }
#line 1963
    return (0);
  }
#line 1965
  return (1);
}
}
#line 1968 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 1975
  l_image = (opj_image_t *)0;
#line 1976
  cp = (opj_cp_t *)0;
#line 1977
  l_img_comp = (opj_image_comp_t *)0;
#line 1984
  l_image = p_j2k->m_private_image;
#line 1985
  cp = & p_j2k->m_cp;
#line 1986
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1987
  l_img_comp = l_image->comps;
#line 1989
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1991
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_size_len);
#line 1991
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 1993
    if (! new_header_tile_data) {
      {
#line 1994
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1995
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1996
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1997
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1998
      return (0);
    }
#line 2000
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2001
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 2004
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2007
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 2008
  l_current_ptr += 2;
#line 2010
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 2011
  l_current_ptr += 2;
#line 2013
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 2014
  l_current_ptr += 2;
#line 2016
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 2017
  l_current_ptr += 4;
#line 2019
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 2020
  l_current_ptr += 4;
#line 2022
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 2023
  l_current_ptr += 4;
#line 2025
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 2026
  l_current_ptr += 4;
#line 2028
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 2029
  l_current_ptr += 4;
#line 2031
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 2032
  l_current_ptr += 4;
#line 2034
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 2035
  l_current_ptr += 4;
#line 2037
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 2038
  l_current_ptr += 4;
#line 2040
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 2041
  l_current_ptr += 2;
#line 2043
  i = (OPJ_UINT32 )0;
  }
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! (i < l_image->numcomps)) {
#line 2043
      goto while_break;
    }
    {
#line 2045
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 2047
    l_current_ptr ++;
#line 2049
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 2050
    l_current_ptr ++;
#line 2052
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 2053
    l_current_ptr ++;
#line 2055
    l_img_comp ++;
    }
#line 2043
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2058
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 2058
  if (__cil_tmp12 != (unsigned long )l_size_len) {
#line 2061
    return (0);
  }
#line 2064
  return (1);
}
}
#line 2074 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_prec0 ;
  OPJ_UINT32 l_sgnd0 ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 siz_w ;
  OPJ_UINT32 siz_h ;
  void *__cil_tmp23 ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 2087
  l_image = (opj_image_t *)0;
#line 2088
  l_cp = (opj_cp_t *)0;
#line 2089
  l_img_comp = (opj_image_comp_t *)0;
#line 2090
  l_current_tile_param = (opj_tcp_t *)0;
#line 2097
  l_image = p_j2k->m_private_image;
#line 2098
  l_cp = & p_j2k->m_cp;
#line 2101
  if (p_header_size < 36U) {
    {
#line 2102
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 2103
    return (0);
  }
#line 2106
  l_remaining_size = p_header_size - 36U;
#line 2107
  l_nb_comp = l_remaining_size / 3U;
#line 2108
  l_nb_comp_remain = l_remaining_size % 3U;
#line 2109
  if (l_nb_comp_remain != 0U) {
    {
#line 2110
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 2111
    return (0);
  }
  {
#line 2114
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 2116
  p_header_data += 2;
#line 2117
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 2118
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x1), (OPJ_UINT32 )4);
#line 2119
  p_header_data += 4;
#line 2120
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y1), (OPJ_UINT32 )4);
#line 2121
  p_header_data += 4;
#line 2122
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x0), (OPJ_UINT32 )4);
#line 2123
  p_header_data += 4;
#line 2124
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y0), (OPJ_UINT32 )4);
#line 2125
  p_header_data += 4;
#line 2126
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdx), (OPJ_UINT32 )4);
#line 2128
  p_header_data += 4;
#line 2129
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdy), (OPJ_UINT32 )4);
#line 2131
  p_header_data += 4;
#line 2132
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tx0), (OPJ_UINT32 )4);
#line 2134
  p_header_data += 4;
#line 2135
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->ty0), (OPJ_UINT32 )4);
#line 2137
  p_header_data += 4;
#line 2138
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_tmp), (OPJ_UINT32 )2);
#line 2140
  p_header_data += 2;
  }
#line 2141
  if (l_tmp < 16385U) {
#line 2142
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 2144
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\n",
                  l_tmp);
    }
#line 2146
    return (0);
  }
#line 2149
  if (l_image->numcomps != l_nb_comp) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                  l_image->numcomps, l_nb_comp);
    }
#line 2153
    return (0);
  }
#line 2158
  if (l_image->x0 >= l_image->x1) {
    {
    {
#line 2159
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
    }
#line 2163
    return (0);
  } else
#line 2158
  if (l_image->y0 >= l_image->y1) {
    {
    {
#line 2159
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
    }
#line 2163
    return (0);
  }
#line 2166
  if (l_cp->tdx == 0U) {
    {
    {
#line 2167
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
    }
#line 2170
    return (0);
  } else
#line 2166
  if (l_cp->tdy == 0U) {
    {
    {
#line 2167
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
    }
#line 2170
    return (0);
  }
  {
#line 2174
  l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx);
#line 2175
  l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy);
  }
#line 2176
  if (l_cp->tx0 > l_image->x0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_cp->ty0 > l_image->y0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_tx1 <= l_image->x0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_ty1 <= l_image->y0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  }
#line 2182
  if (! p_j2k->dump_state) {
#line 2185
    siz_w = l_image->x1 - l_image->x0;
#line 2186
    siz_h = l_image->y1 - l_image->y0;
#line 2188
    if (p_j2k->ihdr_w > 0U) {
#line 2188
      if (p_j2k->ihdr_h > 0U) {
#line 2188
        if (p_j2k->ihdr_w != siz_w) {
          {
          {
#line 2190
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
          }
#line 2193
          return (0);
        } else
#line 2188
        if (p_j2k->ihdr_h != siz_h) {
          {
          {
#line 2190
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
          }
#line 2193
          return (0);
        }
      }
    }
  }
  {
#line 2239
  __cil_tmp23 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2239
  l_image->comps = (opj_image_comp_t *)__cil_tmp23;
  }
#line 2241
  if (l_image->comps == (opj_image_comp_t *)0) {
    {
#line 2242
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2243
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2245
    return (0);
  }
#line 2248
  l_img_comp = l_image->comps;
#line 2250
  l_prec0 = (OPJ_UINT32 )0;
#line 2251
  l_sgnd0 = (OPJ_UINT32 )0;
#line 2253
  i = (OPJ_UINT32 )0;
  {
#line 2253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2253
    if (! (i < l_image->numcomps)) {
#line 2253
      goto while_break;
    }
    {
#line 2255
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2256
    p_header_data ++;
#line 2257
    l_img_comp->prec = (tmp & 127U) + 1U;
#line 2258
    l_img_comp->sgnd = tmp >> 7;
    }
#line 2260
    if (p_j2k->dump_state == 0U) {
#line 2261
      if (i == 0U) {
#line 2262
        l_prec0 = l_img_comp->prec;
#line 2263
        l_sgnd0 = l_img_comp->sgnd;
      } else
#line 2264
      if (! l_cp->allow_different_bit_depth_sign) {
#line 2264
        if (l_img_comp->prec != l_prec0) {
          {
          {
#line 2266
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
          }
        } else
#line 2264
        if (l_img_comp->sgnd != l_sgnd0) {
          {
          {
#line 2266
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
          }
        }
      }
    }
    {
#line 2273
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2274
    p_header_data ++;
#line 2275
    l_img_comp->dx = (OPJ_UINT32 )tmp;
#line 2276
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2277
    p_header_data ++;
#line 2278
    l_img_comp->dy = (OPJ_UINT32 )tmp;
    }
#line 2279
    if (l_img_comp->dx < 1U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dx > 255U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dy < 1U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dy > 255U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    }
#line 2289
    if (l_img_comp->prec > 31U) {
      {
#line 2290
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_img_comp->prec);
      }
#line 2293
      return (0);
    }
#line 2324
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2326
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2328
    l_img_comp ++;
#line 2253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2331
  if (l_cp->tdx == 0U) {
#line 2332
    return (0);
  } else
#line 2331
  if (l_cp->tdy == 0U) {
#line 2332
    return (0);
  }
  {
#line 2336
  __cil_tmp25 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2336
  l_cp->tw = (OPJ_UINT32 )__cil_tmp25;
#line 2338
  __cil_tmp26 = opj_int_ceildiv((OPJ_INT32 )(l_image->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2338
  l_cp->th = (OPJ_UINT32 )__cil_tmp26;
  }
#line 2342
  if (l_cp->tw == 0U) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  } else
#line 2342
  if (l_cp->th == 0U) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  } else
#line 2342
  if (l_cp->tw > 65535U / l_cp->th) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  }
#line 2348
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2351
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2352
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2354
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2356
    __cil_tmp27 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2356
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp27;
#line 2359
    __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2359
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp28;
    }
  } else {
#line 2363
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2364
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2365
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2366
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2415
  __cil_tmp29 = opj_calloc((size_t )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2415
  l_cp->tcps = (opj_tcp_t *)__cil_tmp29;
  }
#line 2416
  if (l_cp->tcps == (opj_tcp_t *)0) {
    {
#line 2417
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2419
    return (0);
  }
  {
#line 2435
  __cil_tmp30 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2435
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp30;
  }
#line 2437
  if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (opj_tccp_t *)0) {
    {
#line 2438
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2440
    return (0);
  }
  {
#line 2443
  __cil_tmp31 = opj_calloc((size_t )10, sizeof(opj_mct_data_t ));
#line 2443
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp31;
  }
#line 2447
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2448
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2450
    return (0);
  }
  {
#line 2452
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2455
  __cil_tmp32 = opj_calloc((size_t )10, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2455
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp32;
  }
#line 2460
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2461
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2463
    return (0);
  }
#line 2465
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2469
  i = (OPJ_UINT32 )0;
  {
#line 2469
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2469
    if (! (i < l_image->numcomps)) {
#line 2469
      goto while_break___0;
    }
#line 2470
    if (! (l_image->comps + i)->sgnd) {
#line 2471
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2469
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2476
  l_current_tile_param = l_cp->tcps;
#line 2477
  i = (OPJ_UINT32 )0;
  {
#line 2477
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2477
    if (! (i < l_nb_tiles)) {
#line 2477
      goto while_break___1;
    }
    {
#line 2478
    __cil_tmp33 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2478
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp33;
    }
#line 2480
    if (l_current_tile_param->tccps == (opj_tccp_t *)0) {
      {
#line 2481
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2483
      return (0);
    }
#line 2486
    l_current_tile_param ++;
#line 2477
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2489
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2490
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2492
  return (1);
}
}
#line 2495 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  unsigned long __cil_tmp8 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 2503
  l_current_ptr = (OPJ_BYTE *)0;
#line 2510
  l_comment = p_j2k->m_cp.comment;
#line 2511
  __cil_tmp8 = strlen(l_comment);
#line 2511
  l_comment_size = (OPJ_UINT32 )__cil_tmp8;
#line 2512
  l_total_com_size = l_comment_size + 6U;
  }
#line 2514
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2516
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_total_com_size);
#line 2516
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 2518
    if (! new_header_tile_data) {
      {
#line 2519
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2520
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2521
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2522
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\nx~EV");
      }
#line 2524
      return (0);
    }
#line 2526
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2527
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2530
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2532
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2533
  l_current_ptr += 2;
#line 2535
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2536
  l_current_ptr += 2;
#line 2538
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2540
  l_current_ptr += 2;
#line 2542
  memcpy(l_current_ptr, l_comment, (unsigned long )l_comment_size);
#line 2544
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2544
  if (__cil_tmp11 != (unsigned long )l_total_com_size) {
#line 2547
    return (0);
  }
#line 2550
  return (1);
}
}
#line 2560 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2576
  return (1);
}
}
#line 2579 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
  {
#line 2583
  l_cp = (opj_cp_t *)0;
#line 2584
  l_tcp = (opj_tcp_t *)0;
#line 2586
  l_current_data = (OPJ_BYTE *)0;
#line 2593
  l_cp = & p_j2k->m_cp;
#line 2594
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2595
  __cil_tmp9 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2595
  l_code_size = 9U + __cil_tmp9;
#line 2597
  l_remaining_size = l_code_size;
  }
#line 2599
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2600
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_code_size);
#line 2600
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 2602
    if (! new_header_tile_data) {
      {
#line 2603
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2604
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2605
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2606
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2607
      return (0);
    }
#line 2609
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2610
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2613
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2615
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2616
  l_current_data += 2;
#line 2618
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2619
  l_current_data += 2;
#line 2621
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2622
  l_current_data ++;
#line 2624
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2625
  l_current_data ++;
#line 2627
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2628
  l_current_data += 2;
#line 2630
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2631
  l_current_data ++;
#line 2633
  l_remaining_size -= (unsigned int )9;
#line 2635
  __cil_tmp12 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2635
  if (! __cil_tmp12) {
    {
#line 2637
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2638
    return (0);
  }
#line 2641
  if (l_remaining_size != 0U) {
    {
#line 2642
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2643
    return (0);
  }
  {
#line 2646
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2646
  if (__cil_tmp13 != (unsigned long )l_code_size) {
#line 2649
    return (0);
  }
#line 2652
  return (1);
}
}
#line 2662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp ;
  OPJ_BOOL __cil_tmp11 ;

  {
#line 2671
  l_cp = (opj_cp_t *)0;
#line 2672
  l_tcp = (opj_tcp_t *)0;
#line 2673
  l_image = (opj_image_t *)0;
#line 2680
  l_image = p_j2k->m_private_image;
#line 2681
  l_cp = & p_j2k->m_cp;
#line 2684
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2684
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2684
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2684
  l_tcp = tmp;
#line 2699
  l_tcp->cod = (OPJ_BITFIELD )1;
#line 2702
  if (p_header_size < 5U) {
    {
#line 2703
    opj_event_msg(p_manager, 1, "Error reading COD marker\nax~EV");
    }
#line 2704
    return (0);
  }
  {
#line 2707
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2708
  p_header_data ++;
  }
#line 2710
  if ((l_tcp->csty & 4294967288U) != 0U) {
    {
#line 2712
    opj_event_msg(p_manager, 1, "Unknown Scod value in COD marker\n\237w~EV");
    }
#line 2713
    return (0);
  }
  {
#line 2715
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2716
  p_header_data ++;
#line 2717
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
  }
#line 2719
  if ((int )l_tcp->prg > 4) {
    {
#line 2720
    opj_event_msg(p_manager, 1, "Unknown progression order in COD marker\n\220");
#line 2722
    l_tcp->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2724
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2725
  p_header_data += 2;
  }
#line 2727
  if (l_tcp->numlayers < 1U) {
    {
    {
#line 2728
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp->numlayers);
    }
    }
#line 2731
    return (0);
  } else
#line 2727
  if (l_tcp->numlayers > 65535U) {
    {
    {
#line 2728
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp->numlayers);
    }
    }
#line 2731
    return (0);
  }
#line 2735
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2736
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2738
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2741
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2742
  p_header_data ++;
  }
#line 2744
  if (l_tcp->mct > 1U) {
    {
#line 2745
    opj_event_msg(p_manager, 1, "Invalid multiple component transformation\nx~EV");
    }
#line 2747
    return (0);
  }
#line 2750
  p_header_size -= (unsigned int )5;
#line 2751
  i = (OPJ_UINT32 )0;
  {
#line 2751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2751
    if (! (i < l_image->numcomps)) {
#line 2751
      goto while_break;
    }
#line 2752
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2755
  __cil_tmp11 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2755
  if (! __cil_tmp11) {
    {
#line 2757
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\215w~EV");
    }
#line 2758
    return (0);
  }
#line 2761
  if (p_header_size != 0U) {
    {
#line 2762
    opj_event_msg(p_manager, 1, "Error reading COD marker\n");
    }
#line 2763
    return (0);
  }
  {
#line 2767
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2786
  return (1);
}
}
#line 2789 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_comp_room ;
  int tmp ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 2802
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 2802
    tmp = 1;
  } else {
#line 2802
    tmp = 2;
  }
  {
#line 2802
  l_comp_room = (OPJ_UINT32 )tmp;
#line 2804
  __cil_tmp9 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 2804
  l_coc_size = (5U + l_comp_room) + __cil_tmp9;
  }
#line 2807
  if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2814
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_coc_size);
#line 2814
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 2816
    if (! new_header_tile_data) {
      {
#line 2817
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2818
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2819
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2820
      opj_event_msg(p_manager, 1, "Not enough memory to write COC marker\n");
      }
#line 2821
      return (0);
    }
#line 2823
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2824
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
  }
  {
#line 2827
  opj_j2k_write_coc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 2831
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_coc_size, p_manager);
  }
#line 2831
  if (__cil_tmp12 != (unsigned long )l_coc_size) {
#line 2834
    return (0);
  }
#line 2837
  return (1);
}
}
#line 2840 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 2843
  l_cp = (opj_cp_t *)((void *)0);
#line 2844
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2849
  l_cp = & p_j2k->m_cp;
#line 2850
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2852
  if ((l_tcp->tccps + p_first_comp_no)->csty != (l_tcp->tccps + p_second_comp_no)->csty) {
#line 2853
    return (0);
  }
  {
#line 2857
  __cil_tmp6 = opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                           p_second_comp_no);
  }
#line 2857
  return (__cil_tmp6);
}
}
#line 2861 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  int tmp ;
  OPJ_UINT32 __cil_tmp14 ;

  {
#line 2868
  l_cp = (opj_cp_t *)0;
#line 2869
  l_tcp = (opj_tcp_t *)0;
#line 2871
  l_current_data = (OPJ_BYTE *)0;
#line 2872
  l_image = (opj_image_t *)0;
#line 2879
  l_cp = & p_j2k->m_cp;
#line 2880
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2881
  l_image = p_j2k->m_private_image;
#line 2882
  if (l_image->numcomps <= 256U) {
#line 2882
    tmp = 1;
  } else {
#line 2882
    tmp = 2;
  }
  {
#line 2882
  l_comp_room = (OPJ_UINT32 )tmp;
#line 2884
  __cil_tmp14 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2884
  l_coc_size = (5U + l_comp_room) + __cil_tmp14;
#line 2886
  l_remaining_size = l_coc_size;
#line 2888
  l_current_data = p_data;
#line 2890
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65363, (OPJ_UINT32 )2);
#line 2892
  l_current_data += 2;
#line 2894
  opj_write_bytes_LE(l_current_data, l_coc_size - 2U, (OPJ_UINT32 )2);
#line 2896
  l_current_data += 2;
#line 2898
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 2899
  l_current_data += l_comp_room;
#line 2901
  opj_write_bytes_LE(l_current_data, (l_tcp->tccps + p_comp_no)->csty, (OPJ_UINT32 )1);
#line 2903
  l_current_data ++;
#line 2905
  l_remaining_size -= 5U + l_comp_room;
#line 2906
  opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0, l_current_data,
                            & l_remaining_size, p_manager);
#line 2908
  *p_data_written = l_coc_size;
  }
  return;
}
}
#line 2911 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2916
  l_max = (OPJ_UINT32 )0;
#line 2920
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2921
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2923
  i = (OPJ_UINT32 )0;
  {
#line 2923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2923
    if (! (i < l_nb_tiles)) {
#line 2923
      goto while_break;
    }
#line 2924
    j = (OPJ_UINT32 )0;
    {
#line 2924
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2924
      if (! (j < l_nb_comp)) {
#line 2924
        goto while_break___0;
      }
      {
#line 2925
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2925
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2925
      l_max = __cil_tmp8;
      }
#line 2924
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2923
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2929
  return (6U + l_max);
}
}
#line 2939 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp ;
  int tmp___0 ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 2945
  l_cp = (opj_cp_t *)((void *)0);
#line 2946
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2947
  l_image = (opj_image_t *)((void *)0);
#line 2956
  l_cp = & p_j2k->m_cp;
#line 2957
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2957
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2957
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2957
  l_tcp = tmp;
#line 2961
  l_image = p_j2k->m_private_image;
#line 2963
  if (l_image->numcomps <= 256U) {
#line 2963
    tmp___0 = 1;
  } else {
#line 2963
    tmp___0 = 2;
  }
#line 2963
  l_comp_room = (OPJ_UINT32 )tmp___0;
#line 2966
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2967
    opj_event_msg(p_manager, 1, "Error reading COC marker\n\362w~EV");
    }
#line 2968
    return (0);
  }
  {
#line 2970
  p_header_size -= l_comp_room + 1U;
#line 2972
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2974
  p_header_data += l_comp_room;
  }
#line 2975
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2976
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\n");
    }
#line 2978
    return (0);
  }
  {
#line 2981
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2983
  p_header_data ++;
#line 2985
  __cil_tmp12 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2985
  if (! __cil_tmp12) {
    {
#line 2987
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2988
    return (0);
  }
#line 2991
  if (p_header_size != 0U) {
    {
#line 2992
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2993
    return (0);
  }
#line 2995
  return (1);
}
}
#line 2998 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 3004
  l_current_data = (OPJ_BYTE *)0;
#line 3011
  __cil_tmp7 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 3011
  l_qcd_size = 4U + __cil_tmp7;
#line 3013
  l_remaining_size = l_qcd_size;
  }
#line 3015
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3016
    __cil_tmp9 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_qcd_size);
#line 3016
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp9;
    }
#line 3018
    if (! new_header_tile_data) {
      {
#line 3019
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3020
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3021
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3022
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 3023
      return (0);
    }
#line 3025
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3026
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 3029
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 3031
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 3032
  l_current_data += 2;
#line 3034
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 3035
  l_current_data += 2;
#line 3037
  l_remaining_size -= (unsigned int )4;
#line 3039
  __cil_tmp10 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 3039
  if (! __cil_tmp10) {
    {
#line 3041
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3042
    return (0);
  }
#line 3045
  if (l_remaining_size != 0U) {
    {
#line 3046
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3047
    return (0);
  }
  {
#line 3050
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 3050
  if (__cil_tmp11 != (unsigned long )l_qcd_size) {
#line 3053
    return (0);
  }
#line 3056
  return (1);
}
}
#line 3066 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 3077
  __cil_tmp5 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 3077
  if (! __cil_tmp5) {
    {
#line 3079
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 3080
    return (0);
  }
#line 3083
  if (p_header_size != 0U) {
    {
#line 3084
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n\'y~EV");
    }
#line 3085
    return (0);
  }
  {
#line 3089
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 3091
  return (1);
}
}
#line 3094 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 __cil_tmp7 ;
  int tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 3107
  __cil_tmp7 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3107
  l_qcc_size = 5U + __cil_tmp7;
  }
#line 3109
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 3109
    tmp = 0;
  } else {
#line 3109
    tmp = 1;
  }
#line 3109
  l_qcc_size += (unsigned int )tmp;
#line 3110
  l_remaining_size = l_qcc_size;
#line 3112
  if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3113
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_qcc_size);
#line 3113
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 3115
    if (! new_header_tile_data) {
      {
#line 3116
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3117
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3118
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3119
      opj_event_msg(p_manager, 1, "Not enough memory to write QCC marker\n");
      }
#line 3120
      return (0);
    }
#line 3122
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3123
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
  }
  {
#line 3126
  opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 3130
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcc_size, p_manager);
  }
#line 3130
  if (__cil_tmp11 != (unsigned long )l_qcc_size) {
#line 3133
    return (0);
  }
#line 3136
  return (1);
}
}
#line 3139 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3142
  __cil_tmp4 = opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                         p_second_comp_no);
  }
#line 3142
  return (__cil_tmp4);
}
}
#line 3146 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3154
  l_current_data = (OPJ_BYTE *)0;
#line 3160
  __cil_tmp9 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3160
  l_qcc_size = 6U + __cil_tmp9;
#line 3162
  l_remaining_size = l_qcc_size;
#line 3164
  l_current_data = p_data;
#line 3166
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65373, (OPJ_UINT32 )2);
#line 3167
  l_current_data += 2;
  }
#line 3169
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
    {
#line 3170
    l_qcc_size --;
#line 3172
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3173
    l_current_data += 2;
#line 3175
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )1);
#line 3176
    l_current_data ++;
#line 3179
    l_remaining_size -= (unsigned int )6;
    }
  } else {
    {
#line 3181
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3182
    l_current_data += 2;
#line 3184
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )2);
#line 3185
    l_current_data += 2;
#line 3187
    l_remaining_size -= (unsigned int )6;
    }
  }
  {
#line 3190
  opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no, l_current_data,
                          & l_remaining_size, p_manager);
#line 3193
  *p_data_written = l_qcc_size;
  }
  return;
}
}
#line 3196 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 3198
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 3198
  return (__cil_tmp2);
}
}
#line 3208 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 3221
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 3223
  if (l_num_comp <= 256U) {
#line 3224
    if (p_header_size < 1U) {
      {
#line 3225
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3226
      return (0);
    }
    {
#line 3228
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 3229
    p_header_data ++;
#line 3230
    p_header_size --;
    }
  } else {
#line 3232
    if (p_header_size < 2U) {
      {
#line 3233
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3234
      return (0);
    }
    {
#line 3236
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 3237
    p_header_data += 2;
#line 3238
    p_header_size -= (unsigned int )2;
    }
  }
#line 3267
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 3268
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\n",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 3271
    return (0);
  }
  {
#line 3274
  __cil_tmp7 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 3274
  if (! __cil_tmp7) {
    {
#line 3276
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3277
    return (0);
  }
#line 3280
  if (p_header_size != 0U) {
    {
#line 3281
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3282
    return (0);
  }
#line 3285
  return (1);
}
}
#line 3288 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 3296
  l_written_size = (OPJ_UINT32 )0;
#line 3297
  l_tcp = (opj_tcp_t *)0;
#line 3305
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3306
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3307
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3309
  if (l_nb_comp <= 256U) {
#line 3310
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3312
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 3314
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3316
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3317
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_poc_size);
#line 3317
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 3319
    if (! new_header_tile_data) {
      {
#line 3320
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3321
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3322
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3323
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 3324
      return (0);
    }
#line 3326
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3327
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 3330
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 3334
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 3334
  if (__cil_tmp12 != (unsigned long )l_poc_size) {
#line 3337
    return (0);
  }
#line 3340
  return (1);
}
}
#line 3343 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;

  {
#line 3350
  l_current_data = (OPJ_BYTE *)0;
#line 3354
  l_image = (opj_image_t *)0;
#line 3355
  l_tcp = (opj_tcp_t *)0;
#line 3356
  l_tccp = (opj_tccp_t *)0;
#line 3357
  l_current_poc = (opj_poc_t *)0;
#line 3366
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3367
  l_tccp = l_tcp->tccps + 0;
#line 3368
  l_image = p_j2k->m_private_image;
#line 3369
  l_nb_comp = l_image->numcomps;
#line 3370
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3372
  if (l_nb_comp <= 256U) {
#line 3373
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3375
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 3378
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3380
  l_current_data = p_data;
#line 3382
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3384
  l_current_data += 2;
#line 3386
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 3388
  l_current_data += 2;
#line 3390
  l_current_poc = (opj_poc_t *)l_tcp->pocs;
#line 3391
  i = (OPJ_UINT32 )0;
  }
  {
#line 3391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3391
    if (! (i < l_nb_poc)) {
#line 3391
      goto while_break;
    }
    {
#line 3392
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3394
    l_current_data ++;
#line 3396
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 3398
    l_current_data += l_poc_room;
#line 3400
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3402
    l_current_data += 2;
#line 3404
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3406
    l_current_data ++;
#line 3408
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 3410
    l_current_data += l_poc_room;
#line 3412
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 3414
    l_current_data ++;
#line 3417
    __cil_tmp15 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3417
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp15;
#line 3419
    __cil_tmp16 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3419
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp16;
#line 3421
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3421
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3424
    l_current_poc ++;
    }
#line 3391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3427
  *p_data_written = l_poc_size;
  return;
}
}
#line 3430 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3432
  l_tcp = (opj_tcp_t *)0;
#line 3433
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3434
  l_max_poc = (OPJ_UINT32 )0;
#line 3437
  l_tcp = p_j2k->m_cp.tcps;
#line 3438
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3440
  i = (OPJ_UINT32 )0;
  {
#line 3440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3440
    if (! (i < l_nb_tiles)) {
#line 3440
      goto while_break;
    }
    {
#line 3441
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3442
    l_tcp ++;
    }
#line 3440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3445
  l_max_poc ++;
#line 3447
  return (4U + 9U * l_max_poc);
}
}
#line 3450 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3454
  l_max = (OPJ_UINT32 )0;
#line 3455
  l_tcp = (opj_tcp_t *)0;
#line 3457
  l_tcp = p_j2k->m_cp.tcps;
#line 3458
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3460
  i = (OPJ_UINT32 )0;
  {
#line 3460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3460
    if (! (i < l_nb_tiles)) {
#line 3460
      goto while_break;
    }
    {
#line 3461
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3463
    l_tcp ++;
    }
#line 3460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3466
  return (12U * l_max);
}
}
#line 3469 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_max_packet_count ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;

  {
  {
#line 3471
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3475
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3476
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
  }
#line 3476
  l_nb_bytes += __cil_tmp6;
#line 3478
  if (! ((int )p_j2k->m_cp.rsiz >= 3 && (int )p_j2k->m_cp.rsiz <= 6)) {
    {
#line 3479
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3480
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3482
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3483
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3486
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
  }
#line 3486
  l_nb_bytes += __cil_tmp9;
#line 3488
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
#line 3492
    l_cp = & p_j2k->m_cp;
#line 3493
    l_max_packet_count = (OPJ_UINT32 )0;
#line 3494
    i = (OPJ_UINT32 )0;
    {
#line 3494
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3494
      if (! (i < l_cp->th * l_cp->tw)) {
#line 3494
        goto while_break;
      }
      {
#line 3495
      __cil_tmp13 = opj_get_encoding_packet_count(p_j2k->m_private_image, l_cp, i);
#line 3495
      __cil_tmp14 = opj_uint_max(l_max_packet_count, __cil_tmp13);
#line 3495
      l_max_packet_count = __cil_tmp14;
      }
#line 3494
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3501
    __cil_tmp15 = opj_uint_ceildiv(l_max_packet_count, (OPJ_UINT32 )16382);
#line 3501
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT = 6U * __cil_tmp15;
#line 3504
    l_nb_bytes += 5U * l_max_packet_count;
    }
#line 3504
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT += l_nb_bytes;
#line 3506
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT += (unsigned int )1;
#line 3507
    l_nb_bytes += p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
  }
#line 3512
  return (l_nb_bytes);
}
}
#line 3523 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  opj_tcp_t *tmp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;

  {
#line 3530
  l_image = (opj_image_t *)0;
#line 3534
  l_cp = (opj_cp_t *)0;
#line 3535
  l_tcp = (opj_tcp_t *)0;
#line 3536
  l_current_poc = (opj_poc_t *)0;
#line 3543
  l_image = p_j2k->m_private_image;
#line 3544
  l_nb_comp = l_image->numcomps;
#line 3545
  if (l_nb_comp <= 256U) {
#line 3546
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3548
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3550
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3551
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3552
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3554
  if (l_current_poc_nb <= 0U) {
    {
    {
#line 3555
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3556
    return (0);
  } else
#line 3554
  if (l_current_poc_remaining != 0U) {
    {
    {
#line 3555
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3556
    return (0);
  }
#line 3559
  l_cp = & p_j2k->m_cp;
#line 3560
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3560
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3560
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3560
  l_tcp = tmp;
#line 3563
  if ((int )l_tcp->POC) {
#line 3563
    tmp___0 = l_tcp->numpocs + 1U;
  } else {
#line 3563
    tmp___0 = (unsigned int )0;
  }
#line 3563
  l_old_poc_nb = tmp___0;
#line 3564
  l_current_poc_nb += l_old_poc_nb;
#line 3566
  if (l_current_poc_nb >= 32U) {
    {
#line 3567
    opj_event_msg(p_manager, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3568
    return (0);
  }
#line 3572
  l_tcp->POC = (OPJ_BITFIELD )1;
#line 3574
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3575
  i = l_old_poc_nb;
  {
#line 3575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3575
    if (! (i < l_current_poc_nb)) {
#line 3575
      goto while_break;
    }
    {
#line 3576
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3578
    p_header_data ++;
#line 3579
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3581
    p_header_data += l_comp_room;
#line 3582
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3585
    l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
#line 3586
    p_header_data += 2;
#line 3587
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3589
    p_header_data ++;
#line 3590
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3592
    p_header_data += l_comp_room;
#line 3593
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3595
    p_header_data ++;
#line 3596
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3598
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3599
    l_current_poc ++;
    }
#line 3575
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3602
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3603
  return (1);
}
}
#line 3614 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;

  {
#line 3628
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3630
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3631
    opj_event_msg(p_manager, 1, "Error reading CRG marker\n");
    }
#line 3632
    return (0);
  }
#line 3645
  return (1);
}
}
#line 3656 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3671
  if (p_header_size < 2U) {
    {
#line 3672
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n");
    }
#line 3673
    return (0);
  }
  {
#line 3675
  p_header_size -= (unsigned int )2;
#line 3677
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3679
  p_header_data ++;
#line 3680
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3682
  p_header_data ++;
#line 3684
  l_ST = (l_Stlm >> 4) & 3U;
#line 3685
  l_SP = (l_Stlm >> 6) & 1U;
#line 3687
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3688
  l_quotient = l_Ptlm_size + l_ST;
#line 3690
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3692
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3693
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n");
    }
#line 3694
    return (0);
  }
#line 3706
  return (1);
}
}
#line 3717 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 3731
  if (p_header_size < 1U) {
    {
#line 3732
    opj_event_msg(p_manager, 1, "Error reading PLM marker\n");
    }
#line 3733
    return (0);
  }
#line 3779
  return (1);
}
}
#line 3790 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;

  {
#line 3796
  l_packet_len = (OPJ_UINT32 )0;
#line 3805
  if (p_header_size < 1U) {
    {
#line 3806
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3807
    return (0);
  }
  {
#line 3810
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3811
  p_header_data ++;
#line 3812
  p_header_size --;
#line 3814
  i = (OPJ_UINT32 )0;
  }
  {
#line 3814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3814
    if (! (i < p_header_size)) {
#line 3814
      goto while_break;
    }
    {
#line 3815
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3816
    p_header_data ++;
#line 3818
    l_packet_len |= l_tmp & 127U;
    }
#line 3819
    if (l_tmp & 128U) {
#line 3820
      l_packet_len <<= 7;
    } else {
#line 3823
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3814
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3827
  if (l_packet_len != 0U) {
    {
#line 3828
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3829
    return (0);
  }
#line 3832
  return (1);
}
}
#line 3844 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp8 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppm_markers ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 3850
  l_cp = (opj_cp_t *)0;
#line 3859
  if (p_header_size < 2U) {
    {
#line 3860
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n\207z~EV");
    }
#line 3861
    return (0);
  }
  {
#line 3864
  l_cp = & p_j2k->m_cp;
#line 3865
  l_cp->ppm = (OPJ_BITFIELD )1;
#line 3867
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3868
  p_header_data ++;
#line 3869
  p_header_size --;
  }
#line 3872
  if (l_cp->ppm_markers == (void *)0) {
    {
#line 3873
    l_newCount = l_Z_ppm + 1U;
#line 3876
    __cil_tmp8 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 3876
    l_cp->ppm_markers = (opj_ppx *)__cil_tmp8;
    }
#line 3877
    if (l_cp->ppm_markers == (void *)0) {
      {
#line 3878
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nV");
      }
#line 3879
      return (0);
    }
#line 3881
    l_cp->ppm_markers_count = l_newCount;
  } else
#line 3882
  if (l_cp->ppm_markers_count <= l_Z_ppm) {
    {
#line 3883
    l_newCount___0 = l_Z_ppm + 1U;
#line 3885
    __cil_tmp11 = opj_realloc(l_cp->ppm_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 3885
    new_ppm_markers = (opj_ppx *)__cil_tmp11;
    }
#line 3887
    if (new_ppm_markers == (void *)0) {
      {
#line 3889
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
      }
#line 3890
      return (0);
    }
    {
#line 3892
    l_cp->ppm_markers = new_ppm_markers;
#line 3893
    memset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0, (unsigned long )(l_newCount___0 - l_cp->ppm_markers_count) * sizeof(opj_ppx ));
#line 3895
    l_cp->ppm_markers_count = l_newCount___0;
    }
  }
#line 3898
  if ((l_cp->ppm_markers + l_Z_ppm)->m_data != (void *)0) {
    {
#line 3900
    opj_event_msg(p_manager, 1, "Zppm %u already read\n", l_Z_ppm);
    }
#line 3901
    return (0);
  }
  {
#line 3904
  __cil_tmp12 = opj_malloc((size_t )p_header_size);
#line 3904
  (l_cp->ppm_markers + l_Z_ppm)->m_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 3905
  if ((l_cp->ppm_markers + l_Z_ppm)->m_data == (void *)0) {
    {
#line 3907
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
    }
#line 3908
    return (0);
  }
  {
#line 3910
  (l_cp->ppm_markers + l_Z_ppm)->m_data_size = p_header_size;
#line 3911
  memcpy((l_cp->ppm_markers + l_Z_ppm)->m_data, p_header_data, (unsigned long )p_header_size);
  }
#line 3913
  return (1);
}
}
#line 3922 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppm_data_size ;
  OPJ_UINT32 l_N_ppm_remaining ;
  OPJ_UINT32 l_N_ppm ;
  OPJ_UINT32 l_data_size ;
  OPJ_BYTE *l_data ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_N_ppm___0 ;
  OPJ_UINT32 l_data_size___0 ;
  OPJ_BYTE *l_data___0 ;

  {
#line 3931
  if (p_cp->ppm == 0U) {
#line 3932
    return (1);
  }
#line 3935
  l_ppm_data_size = 0U;
#line 3936
  l_N_ppm_remaining = 0U;
#line 3937
  i = 0U;
  {
#line 3937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3937
    if (! (i < p_cp->ppm_markers_count)) {
#line 3937
      goto while_break;
    }
#line 3938
    if ((p_cp->ppm_markers + i)->m_data != (void *)0) {
#line 3941
      l_data_size = (p_cp->ppm_markers + i)->m_data_size;
#line 3942
      l_data = (p_cp->ppm_markers + i)->m_data;
#line 3944
      if (l_N_ppm_remaining >= l_data_size) {
#line 3945
        l_N_ppm_remaining -= l_data_size;
#line 3946
        l_data_size = 0U;
      } else {
#line 3948
        l_data += l_N_ppm_remaining;
#line 3949
        l_data_size -= l_N_ppm_remaining;
#line 3950
        l_N_ppm_remaining = 0U;
      }
#line 3953
      if (l_data_size > 0U) {
        {
#line 3954
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3956
          if (l_data_size < 4U) {
            {
#line 3958
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 3959
            return (0);
          }
          {
#line 3961
          opj_read_bytes_LE(l_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3962
          l_data += 4;
#line 3963
          l_data_size -= (unsigned int )4;
#line 3964
          l_ppm_data_size += l_N_ppm;
          }
#line 3967
          if (l_data_size >= l_N_ppm) {
#line 3968
            l_data_size -= l_N_ppm;
#line 3969
            l_data += l_N_ppm;
          } else {
#line 3971
            l_N_ppm_remaining = l_N_ppm - l_data_size;
#line 3972
            l_data_size = 0U;
          }
#line 3954
          if (! (l_data_size > 0U)) {
#line 3954
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 3937
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3979
  if (l_N_ppm_remaining != 0U) {
    {
#line 3981
    opj_event_msg(p_manager, 1, "Corrupted PPM markers\n");
    }
#line 3982
    return (0);
  }
  {
#line 3985
  __cil_tmp9 = opj_malloc((size_t )l_ppm_data_size);
#line 3985
  p_cp->ppm_buffer = (OPJ_BYTE *)__cil_tmp9;
  }
#line 3986
  if (p_cp->ppm_buffer == (OPJ_BYTE *)0) {
    {
#line 3987
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nV");
    }
#line 3988
    return (0);
  }
#line 3990
  p_cp->ppm_len = l_ppm_data_size;
#line 3991
  l_ppm_data_size = 0U;
#line 3992
  l_N_ppm_remaining = 0U;
#line 3993
  i = 0U;
  {
#line 3993
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3993
    if (! (i < p_cp->ppm_markers_count)) {
#line 3993
      goto while_break___1;
    }
#line 3994
    if ((p_cp->ppm_markers + i)->m_data != (void *)0) {
#line 3997
      l_data_size___0 = (p_cp->ppm_markers + i)->m_data_size;
#line 3998
      l_data___0 = (p_cp->ppm_markers + i)->m_data;
#line 4000
      if (l_N_ppm_remaining >= l_data_size___0) {
        {
#line 4001
        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_data_size___0);
#line 4002
        l_ppm_data_size += l_data_size___0;
#line 4003
        l_N_ppm_remaining -= l_data_size___0;
#line 4004
        l_data_size___0 = 0U;
        }
      } else {
        {
#line 4006
        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_N_ppm_remaining);
#line 4007
        l_ppm_data_size += l_N_ppm_remaining;
#line 4008
        l_data___0 += l_N_ppm_remaining;
#line 4009
        l_data_size___0 -= l_N_ppm_remaining;
#line 4010
        l_N_ppm_remaining = 0U;
        }
      }
#line 4013
      if (l_data_size___0 > 0U) {
        {
#line 4014
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4016
          if (l_data_size___0 < 4U) {
            {
#line 4018
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 4019
            return (0);
          }
          {
#line 4021
          opj_read_bytes_LE(l_data___0, & l_N_ppm___0, (OPJ_UINT32 )4);
#line 4022
          l_data___0 += 4;
#line 4023
          l_data_size___0 -= (unsigned int )4;
          }
#line 4025
          if (l_data_size___0 >= l_N_ppm___0) {
            {
#line 4026
            memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_N_ppm___0);
#line 4027
            l_ppm_data_size += l_N_ppm___0;
#line 4028
            l_data_size___0 -= l_N_ppm___0;
#line 4029
            l_data___0 += l_N_ppm___0;
            }
          } else {
            {
#line 4031
            memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_data_size___0);
#line 4032
            l_ppm_data_size += l_data_size___0;
#line 4033
            l_N_ppm_remaining = l_N_ppm___0 - l_data_size___0;
#line 4034
            l_data_size___0 = 0U;
            }
          }
#line 4014
          if (! (l_data_size___0 > 0U)) {
#line 4014
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 4038
      opj_free((p_cp->ppm_markers + i)->m_data);
#line 4039
      (p_cp->ppm_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 4040
      (p_cp->ppm_markers + i)->m_data_size = 0U;
      }
    }
#line 3993
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4044
  p_cp->ppm_data = p_cp->ppm_buffer;
#line 4045
  p_cp->ppm_data_size = p_cp->ppm_len;
#line 4047
  p_cp->ppm_markers_count = 0U;
#line 4048
  opj_free(p_cp->ppm_markers);
#line 4049
  p_cp->ppm_markers = (opj_ppx *)((void *)0);
  }
#line 4051
  return (1);
}
}
#line 4062 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppt_markers ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 4068
  l_cp = (opj_cp_t *)0;
#line 4069
  l_tcp = (opj_tcp_t *)0;
#line 4078
  if (p_header_size < 2U) {
    {
#line 4079
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n\022{~EV");
    }
#line 4080
    return (0);
  }
#line 4083
  l_cp = & p_j2k->m_cp;
#line 4084
  if (l_cp->ppm) {
    {
#line 4085
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
    }
#line 4087
    return (0);
  }
  {
#line 4090
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4091
  l_tcp->ppt = (OPJ_BITFIELD )1;
#line 4093
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 4094
  p_header_data ++;
#line 4095
  p_header_size --;
  }
#line 4098
  if (l_tcp->ppt_markers == (void *)0) {
    {
#line 4099
    l_newCount = l_Z_ppt + 1U;
#line 4102
    __cil_tmp9 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 4102
    l_tcp->ppt_markers = (opj_ppx *)__cil_tmp9;
    }
#line 4103
    if (l_tcp->ppt_markers == (void *)0) {
      {
#line 4104
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
      }
#line 4105
      return (0);
    }
#line 4107
    l_tcp->ppt_markers_count = l_newCount;
  } else
#line 4108
  if (l_tcp->ppt_markers_count <= l_Z_ppt) {
    {
#line 4109
    l_newCount___0 = l_Z_ppt + 1U;
#line 4111
    __cil_tmp12 = opj_realloc(l_tcp->ppt_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 4111
    new_ppt_markers = (opj_ppx *)__cil_tmp12;
    }
#line 4113
    if (new_ppt_markers == (void *)0) {
      {
#line 4115
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
      }
#line 4116
      return (0);
    }
    {
#line 4118
    l_tcp->ppt_markers = new_ppt_markers;
#line 4119
    memset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0, (unsigned long )(l_newCount___0 - l_tcp->ppt_markers_count) * sizeof(opj_ppx ));
#line 4121
    l_tcp->ppt_markers_count = l_newCount___0;
    }
  }
#line 4124
  if ((l_tcp->ppt_markers + l_Z_ppt)->m_data != (void *)0) {
    {
#line 4126
    opj_event_msg(p_manager, 1, "Zppt %u already read\nV", l_Z_ppt);
    }
#line 4127
    return (0);
  }
  {
#line 4130
  __cil_tmp13 = opj_malloc((size_t )p_header_size);
#line 4130
  (l_tcp->ppt_markers + l_Z_ppt)->m_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 4131
  if ((l_tcp->ppt_markers + l_Z_ppt)->m_data == (void *)0) {
    {
#line 4133
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
    }
#line 4134
    return (0);
  }
  {
#line 4136
  (l_tcp->ppt_markers + l_Z_ppt)->m_data_size = p_header_size;
#line 4137
  memcpy((l_tcp->ppt_markers + l_Z_ppt)->m_data, p_header_data, (unsigned long )p_header_size);
  }
#line 4138
  return (1);
}
}
#line 4147 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppt_data_size ;
  void *__cil_tmp5 ;

  {
#line 4154
  if (p_tcp->ppt_buffer != (void *)0) {
    {
#line 4155
    opj_event_msg(p_manager, 1, "opj_j2k_merge_ppt() has already been called\nEV");
    }
#line 4157
    return (0);
  }
#line 4160
  if (p_tcp->ppt == 0U) {
#line 4161
    return (1);
  }
#line 4164
  l_ppt_data_size = 0U;
#line 4165
  i = 0U;
  {
#line 4165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4165
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4165
      goto while_break;
    }
#line 4166
    l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4170
  __cil_tmp5 = opj_malloc((size_t )l_ppt_data_size);
#line 4170
  p_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp5;
  }
#line 4171
  if (p_tcp->ppt_buffer == (OPJ_BYTE *)0) {
    {
#line 4172
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nV");
    }
#line 4173
    return (0);
  }
#line 4175
  p_tcp->ppt_len = l_ppt_data_size;
#line 4176
  l_ppt_data_size = 0U;
#line 4177
  i = 0U;
  {
#line 4177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4177
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4177
      goto while_break___0;
    }
#line 4178
    if ((p_tcp->ppt_markers + i)->m_data != (void *)0) {
      {
#line 4180
      memcpy(p_tcp->ppt_buffer + l_ppt_data_size, (p_tcp->ppt_markers + i)->m_data,
             (unsigned long )(p_tcp->ppt_markers + i)->m_data_size);
#line 4182
      l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4185
      opj_free((p_tcp->ppt_markers + i)->m_data);
#line 4186
      (p_tcp->ppt_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 4187
      (p_tcp->ppt_markers + i)->m_data_size = 0U;
      }
    }
#line 4177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4191
  p_tcp->ppt_markers_count = 0U;
#line 4192
  opj_free(p_tcp->ppt_markers);
#line 4193
  p_tcp->ppt_markers = (opj_ppx *)((void *)0);
#line 4195
  p_tcp->ppt_data = p_tcp->ppt_buffer;
#line 4196
  p_tcp->ppt_data_size = p_tcp->ppt_len;
  }
#line 4197
  return (1);
}
}
#line 4200 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_UINT32 size_per_tile_part ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp8 ;
  OPJ_OFF_T __cil_tmp9 ;
  int tmp ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 4205
  l_current_data = (OPJ_BYTE *)0;
#line 4216
  if (p_j2k->m_specific_param.m_encoder.m_total_tile_parts > 10921U) {
    {
#line 4218
    opj_event_msg(p_manager, 1, "A maximum of 10921 tile-parts are supported currently when writing TLM marker\n");
    }
#line 4221
    return (0);
  }
#line 4224
  if (p_j2k->m_specific_param.m_encoder.m_total_tile_parts <= 255U) {
#line 4225
    size_per_tile_part = (OPJ_UINT32 )5;
#line 4226
    p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte = 1;
  } else {
#line 4228
    size_per_tile_part = (OPJ_UINT32 )6;
#line 4229
    p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte = 0;
  }
#line 4232
  l_tlm_size = 6U + size_per_tile_part * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 4235
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 4236
    __cil_tmp8 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_tlm_size);
#line 4236
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp8;
    }
#line 4238
    if (! new_header_tile_data) {
      {
#line 4239
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 4240
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 4241
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 4242
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 4243
      return (0);
    }
#line 4245
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 4246
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 4248
  memset(p_j2k->m_specific_param.m_encoder.m_header_tile_data, 0, (unsigned long )l_tlm_size);
#line 4250
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4254
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 4256
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 4258
  l_current_data += 2;
#line 4260
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 4262
  l_current_data += 2;
#line 4264
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4266
  l_current_data ++;
  }
#line 4270
  if (size_per_tile_part == 5U) {
#line 4270
    tmp = 80;
  } else {
#line 4270
    tmp = 96;
  }
  {
#line 4270
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )tmp, (OPJ_UINT32 )1);
#line 4273
  l_current_data ++;
#line 4276
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 4276
  if (__cil_tmp11 != (unsigned long )l_tlm_size) {
#line 4279
    return (0);
  }
#line 4282
  return (1);
}
}
#line 4285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4300
  if (total_data_size < 12U) {
    {
#line 4301
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOT marker\n");
    }
#line 4303
    return (0);
  }
  {
#line 4306
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 4308
  p_data += 2;
#line 4310
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 4312
  p_data += 2;
#line 4314
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 4316
  p_data += 2;
#line 4319
  p_data += 4;
#line 4321
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 4324
  p_data ++;
#line 4326
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 4329
  p_data ++;
#line 4340
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 4342
  return (1);
}
}
#line 4345 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4358
  if (p_header_size != 8U) {
    {
#line 4359
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4360
    return (0);
  }
  {
#line 4363
  opj_read_bytes_LE(p_header_data, p_tile_no, (OPJ_UINT32 )2);
#line 4364
  p_header_data += 2;
#line 4365
  opj_read_bytes_LE(p_header_data, p_tot_len, (OPJ_UINT32 )4);
#line 4366
  p_header_data += 4;
#line 4367
  opj_read_bytes_LE(p_header_data, p_current_part, (OPJ_UINT32 )1);
#line 4368
  p_header_data ++;
#line 4369
  opj_read_bytes_LE(p_header_data, p_num_parts, (OPJ_UINT32 )1);
#line 4370
  p_header_data ++;
  }
#line 4371
  return (1);
}
}
#line 4374 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  OPJ_BOOL __cil_tmp12 ;
  void *__cil_tmp13 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp18 ;

  {
  {
#line 4379
  l_cp = (opj_cp_t *)0;
#line 4380
  l_tcp = (opj_tcp_t *)0;
#line 4381
  l_num_parts = (OPJ_UINT32 )0;
#line 4390
  __cil_tmp12 = opj_j2k_get_sot_values(p_header_data, p_header_size, & p_j2k->m_current_tile_number,
                                       & l_tot_len, & l_current_part, & l_num_parts,
                                       p_manager);
  }
#line 4390
  if (! __cil_tmp12) {
    {
#line 4393
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4394
    return (0);
  }
#line 4401
  l_cp = & p_j2k->m_cp;
#line 4404
  if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
    {
#line 4405
    opj_event_msg(p_manager, 1, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
    }
#line 4407
    return (0);
  }
#line 4410
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4411
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 4412
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 4414
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec < 0) {
    _L: /* CIL Label */ 
#line 4427
    if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32 )l_current_part) {
      {
#line 4428
      opj_event_msg(p_manager, 1, "Invalid tile part index for tile number %d. Got %d, expected %d\n",
                    p_j2k->m_current_tile_number, l_current_part, l_tcp->m_current_tile_part_number + 1);
      }
#line 4434
      return (0);
    }
  } else
#line 4414
  if (p_j2k->m_current_tile_number == (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec) {
#line 4414
    goto _L;
  }
#line 4438
  l_tcp->m_current_tile_part_number = (OPJ_INT32 )l_current_part;
#line 4472
  if (l_tot_len != 0U) {
#line 4472
    if (l_tot_len < 14U) {
#line 4473
      if (l_tot_len == 12U) {
        {
#line 4475
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 4478
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\nEV",
                      l_tot_len);
        }
#line 4480
        return (0);
      }
    }
  }
#line 4508
  if (! l_tot_len) {
    {
#line 4509
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\n{~EV");
#line 4512
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
#line 4515
  if (l_tcp->m_nb_tile_parts != 0U) {
#line 4515
    if (l_current_part >= l_tcp->m_nb_tile_parts) {
      {
#line 4517
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the previous number of tile-part (%d), giving up\n",
                    l_current_part, l_tcp->m_nb_tile_parts);
#line 4521
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4522
      return (0);
    }
  }
#line 4525
  if (l_num_parts != 0U) {
#line 4527
    l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;
#line 4530
    if (l_tcp->m_nb_tile_parts) {
#line 4531
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 4532
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 4536
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4537
        return (0);
      }
    }
#line 4540
    if (l_current_part >= l_num_parts) {
      {
#line 4542
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4545
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4546
      return (0);
    }
#line 4548
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4552
  if (l_tcp->m_nb_tile_parts) {
#line 4553
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4554
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )1;
    }
  }
#line 4559
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4561
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4565
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4568
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4571
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4572
    p_j2k->m_specific_param.m_decoder.m_skip_data = ((l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x || l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) || l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) || l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y;
  } else {
#line 4579
    p_j2k->m_specific_param.m_decoder.m_skip_data = p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
  }
#line 4585
  if (p_j2k->cstr_index) {
#line 4587
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4589
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4592
    if (l_num_parts != 0U) {
#line 4593
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4595
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4598
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4599
        __cil_tmp13 = opj_calloc((size_t )l_num_parts, sizeof(opj_tp_index_t ));
#line 4599
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp13;
        }
#line 4601
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4602
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4604
          return (0);
        }
      } else {
        {
#line 4607
        __cil_tmp15 = opj_realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4607
        new_tp_index = (opj_tp_index_t *)__cil_tmp15;
        }
#line 4610
        if (! new_tp_index) {
          {
#line 4611
          opj_free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4612
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4613
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4615
          return (0);
        }
#line 4617
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4623
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4624
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4625
        __cil_tmp16 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                                 sizeof(opj_tp_index_t ));
#line 4625
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp16;
        }
#line 4629
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4630
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4631
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4633
          return (0);
        }
      }
#line 4637
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4640
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4642
        __cil_tmp18 = opj_realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4642
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp18;
        }
#line 4646
        if (! new_tp_index___0) {
          {
#line 4647
          opj_free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4648
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4649
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4650
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4652
          return (0);
        }
#line 4654
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4690
  return (1);
}
}
#line 4696 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_plt_in_memory(opj_j2k_t *p_j2k , opj_tcd_marker_info_t *marker_info ,
                                            OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE Zplt ;
  OPJ_UINT16 Lplt ;
  OPJ_BYTE *p_data_start ;
  OPJ_BYTE *p_data_Lplt ;
  OPJ_UINT32 i ;
  OPJ_BYTE var_bytes[5] ;
  OPJ_UINT8 var_bytes_size ;
  OPJ_UINT32 packet_size ;
  OPJ_UINT8 __cil_tmp14 ;
  OPJ_UINT8 __cil_tmp15 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;

  {
  {
#line 4702
  Zplt = (OPJ_BYTE )0;
#line 4704
  p_data_start = p_data;
#line 4705
  p_data_Lplt = p_data + 2;
#line 4710
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4711
  p_data += 2;
#line 4714
  p_data += 2;
#line 4716
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4717
  p_data ++;
#line 4719
  Lplt = (OPJ_UINT16 )3;
#line 4721
  i = (OPJ_UINT32 )0;
  }
  {
#line 4721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4721
    if (! (i < marker_info->packet_count)) {
#line 4721
      goto while_break;
    }
#line 4723
    var_bytes_size = (OPJ_UINT8 )0;
#line 4724
    packet_size = *(marker_info->p_packet_size + i);
#line 4727
    var_bytes[var_bytes_size] = (OPJ_BYTE )(packet_size & 127U);
#line 4728
    var_bytes_size ++;
#line 4729
    packet_size >>= 7;
    {
#line 4730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4730
      if (! (packet_size > 0U)) {
#line 4730
        goto while_break___0;
      }
#line 4731
      var_bytes[var_bytes_size] = (OPJ_BYTE )((packet_size & 127U) | 128U);
#line 4732
      var_bytes_size ++;
#line 4733
      packet_size >>= 7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4738
    if ((int )Lplt + (int )var_bytes_size > 65535) {
#line 4739
      if ((int )Zplt == 255) {
        {
#line 4740
        opj_event_msg(p_manager, 1, "More than 255 PLT markers would be needed for current tile-part !\n|~EV");
        }
#line 4742
        return (0);
      }
      {
#line 4746
      opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
#line 4749
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4750
      p_data += 2;
#line 4753
      p_data_Lplt = p_data;
#line 4754
      p_data += 2;
#line 4756
      Zplt ++;
#line 4757
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4758
      p_data ++;
#line 4760
      Lplt = (OPJ_UINT16 )3;
      }
    }
#line 4763
    Lplt = (OPJ_UINT16 )((int )Lplt + (int )var_bytes_size);
    {
#line 4766
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4766
      if (! ((int )var_bytes_size > 0)) {
#line 4766
        goto while_break___1;
      }
      {
#line 4767
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )var_bytes[(int )var_bytes_size - 1],
                         (OPJ_UINT32 )1);
#line 4768
      p_data ++;
      }
#line 4766
      var_bytes_size --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4721
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4772
  *p_data_written = (OPJ_UINT32 )(p_data - p_data_start);
#line 4775
  opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
  }
#line 4777
  return (1);
}
}
#line 4780 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  opj_tcd_marker_info_t *marker_info ;
  opj_tcd_marker_info_t *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_UINT32 l_data_written_PLT ;
  OPJ_BYTE *p_PLT_buffer ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;

  {
#line 4789
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4791
  marker_info = (opj_tcd_marker_info_t *)((void *)0);
#line 4800
  if (total_data_size < 4U) {
    {
#line 4801
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOD marker\n");
    }
#line 4803
    return (0);
  }
  {
#line 4806
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4810
  l_remaining_data = total_data_size - 4U;
#line 4813
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4815
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4846
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4847
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
  }
#line 4855
  *p_data_written = (OPJ_UINT32 )0;
#line 4857
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
    {
#line 4858
    marker_info = opj_tcd_marker_info_create(p_j2k->m_specific_param.m_encoder.m_PLT);
    }
#line 4860
    if (marker_info == (void *)0) {
      {
#line 4861
      opj_event_msg(p_manager, 1, "Cannot encode tile: opj_tcd_marker_info_create() failed\n\220");
      }
#line 4863
      return (0);
    }
  }
#line 4867
  if (l_remaining_data < p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT) {
    {
#line 4869
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOD marker\n");
#line 4871
    opj_tcd_marker_info_destroy(marker_info);
    }
#line 4872
    return (0);
  }
  {
#line 4874
  l_remaining_data -= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
#line 4876
  __cil_tmp12 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data + 2,
                                    p_data_written, l_remaining_data, l_cstr_info,
                                    marker_info, p_manager);
  }
#line 4876
  if (! __cil_tmp12) {
    {
#line 4881
    opj_event_msg(p_manager, 1, "Cannot encode tile\n~EV");
#line 4882
    opj_tcd_marker_info_destroy(marker_info);
    }
#line 4883
    return (0);
  }
#line 4887
  *p_data_written += (unsigned int )2;
#line 4889
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
    {
#line 4890
    l_data_written_PLT = (OPJ_UINT32 )0;
#line 4891
    __cil_tmp15 = opj_malloc((size_t )p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);
#line 4891
    p_PLT_buffer = (OPJ_BYTE *)__cil_tmp15;
    }
#line 4893
    if (! p_PLT_buffer) {
      {
#line 4894
      opj_event_msg(p_manager, 1, "Cannot allocate memory\n");
#line 4895
      opj_tcd_marker_info_destroy(marker_info);
      }
#line 4896
      return (0);
    }
    {
#line 4898
    __cil_tmp16 = opj_j2k_write_plt_in_memory(p_j2k, marker_info, p_PLT_buffer, & l_data_written_PLT,
                                              p_manager);
    }
#line 4898
    if (! __cil_tmp16) {
      {
#line 4903
      opj_tcd_marker_info_destroy(marker_info);
#line 4904
      opj_free(p_PLT_buffer);
      }
#line 4905
      return (0);
    }
    {
#line 4912
    memmove(p_data + l_data_written_PLT, p_data, (unsigned long )*p_data_written);
#line 4913
    memcpy(p_data, p_PLT_buffer, (unsigned long )l_data_written_PLT);
#line 4914
    opj_free(p_PLT_buffer);
#line 4915
    *p_data_written += l_data_written_PLT;
    }
  }
  {
#line 4918
  opj_tcd_marker_info_destroy(marker_info);
  }
#line 4920
  return (1);
}
}
#line 4923 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_OFF_T __cil_tmp11 ;
  void *__cil_tmp12 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp14 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp16 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_SIZE_T __cil_tmp19 ;

  {
#line 4929
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4930
  l_current_data = (OPJ_BYTE **)0;
#line 4931
  l_tcp = (opj_tcp_t *)0;
#line 4932
  l_tile_len = (OPJ_UINT32 *)0;
#line 4933
  l_sot_length_pb_detected = 0;
#line 4940
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4942
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4947
    __cil_tmp10 = opj_stream_get_number_byte_left(p_stream);
#line 4947
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp10 - 2L);
    }
  } else
#line 4951
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4952
    p_j2k->m_specific_param.m_decoder.m_sot_length -= (unsigned int )2;
  }
#line 4958
  l_current_data = & l_tcp->m_data;
#line 4959
  l_tile_len = & l_tcp->m_data_size;
#line 4962
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4965
    __cil_tmp11 = opj_stream_get_number_byte_left(p_stream);
    }
#line 4965
    if ((OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length > __cil_tmp11) {
#line 4967
      if (p_j2k->m_cp.strict) {
        {
#line 4968
        opj_event_msg(p_manager, 1, "Tile part length size inconsistent with stream length\n");
        }
#line 4970
        return (0);
      } else {
        {
#line 4972
        opj_event_msg(p_manager, 2, "Tile part length size inconsistent with stream length\n");
        }
      }
    }
#line 4976
    if (p_j2k->m_specific_param.m_decoder.m_sot_length > 4294967293U) {
      {
#line 4978
      opj_event_msg(p_manager, 1, "p_j2k->m_specific_param.m_decoder.m_sot_length > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA|~EV");
      }
#line 4981
      return (0);
    }
#line 4986
    if (! *l_current_data) {
      {
#line 4990
      __cil_tmp12 = opj_malloc((size_t )(p_j2k->m_specific_param.m_decoder.m_sot_length + 2U));
#line 4990
      *l_current_data = (OPJ_BYTE *)__cil_tmp12;
      }
    } else {
#line 4994
      if (*l_tile_len > 4294967293U - p_j2k->m_specific_param.m_decoder.m_sot_length) {
        {
#line 4996
        opj_event_msg(p_manager, 1, "*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - p_j2k->m_specific_param.m_decoder.m_sot_length\220");
        }
#line 4999
        return (0);
      }
      {
#line 5002
      __cil_tmp14 = opj_realloc(*l_current_data, (size_t )((*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length) + 2U));
#line 5002
      l_new_current_data = (OPJ_BYTE *)__cil_tmp14;
      }
#line 5005
      if (! l_new_current_data) {
        {
#line 5006
        opj_free(*l_current_data);
        }
      }
#line 5012
      *l_current_data = l_new_current_data;
    }
#line 5015
    if (*l_current_data == (OPJ_BYTE *)0) {
      {
#line 5016
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n");
      }
#line 5017
      return (0);
    }
  } else {
#line 5020
    l_sot_length_pb_detected = 1;
  }
#line 5024
  l_cstr_index = p_j2k->cstr_index;
#line 5025
  if (l_cstr_index) {
    {
#line 5026
    __cil_tmp16 = opj_stream_tell(p_stream);
#line 5026
    l_current_pos = __cil_tmp16 - 2L;
#line 5028
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 5030
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 5033
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 5037
    __cil_tmp18 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 5037
    if (0 == __cil_tmp18) {
      {
#line 5042
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
      }
#line 5043
      return (0);
    }
  }
#line 5050
  if (! l_sot_length_pb_detected) {
    {
#line 5051
    l_current_read_size = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                               p_manager);
    }
  } else {
#line 5057
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 5060
  if (l_current_read_size != (unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 5061
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 5063
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 5066
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 5068
  return (1);
}
}
#line 5071 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5079
  l_current_data = (OPJ_BYTE *)0;
#line 5081
  l_cp = (opj_cp_t *)0;
#line 5082
  l_tcp = (opj_tcp_t *)0;
#line 5083
  l_tccp = (opj_tccp_t *)0;
#line 5091
  l_cp = & p_j2k->m_cp;
#line 5092
  l_tcp = l_cp->tcps + p_tile_no;
#line 5093
  l_tccp = l_tcp->tccps + p_comp_no;
#line 5095
  if (nb_comps <= 256U) {
#line 5096
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 5098
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 5101
  l_rgn_size = 6U + l_comp_room;
#line 5103
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5105
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 5107
  l_current_data += 2;
#line 5109
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 5111
  l_current_data += 2;
#line 5113
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 5115
  l_current_data += l_comp_room;
#line 5117
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 5119
  l_current_data ++;
#line 5121
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 5123
  l_current_data ++;
#line 5125
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 5125
  if (__cil_tmp13 != (unsigned long )l_rgn_size) {
#line 5128
    return (0);
  }
#line 5131
  return (1);
}
}
#line 5134 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 5144
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 5155
  __cil_tmp4 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 5155
  if (__cil_tmp4 != 2UL) {
#line 5157
    return (0);
  }
  {
#line 5160
  __cil_tmp5 = opj_stream_flush(p_stream, p_manager);
  }
#line 5160
  if (! __cil_tmp5) {
#line 5161
    return (0);
  }
#line 5164
  return (1);
}
}
#line 5175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp ;

  {
#line 5182
  l_image = (opj_image_t *)0;
#line 5184
  l_cp = (opj_cp_t *)0;
#line 5185
  l_tcp = (opj_tcp_t *)0;
#line 5193
  l_image = p_j2k->m_private_image;
#line 5194
  l_nb_comp = l_image->numcomps;
#line 5196
  if (l_nb_comp <= 256U) {
#line 5197
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 5199
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 5202
  if (p_header_size != 2U + l_comp_room) {
    {
#line 5203
    opj_event_msg(p_manager, 1, "Error reading RGN marker\n");
    }
#line 5204
    return (0);
  }
#line 5207
  l_cp = & p_j2k->m_cp;
#line 5208
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5208
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 5208
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 5208
  l_tcp = tmp;
#line 5212
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 5213
  p_header_data += l_comp_room;
#line 5214
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 5216
  p_header_data ++;
  }
#line 5234
  if (l_comp_no >= l_nb_comp) {
    {
#line 5235
    opj_event_msg(p_manager, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no, l_nb_comp);
    }
#line 5238
    return (0);
  }
  {
#line 5241
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 5243
  p_header_data ++;
  }
#line 5245
  return (1);
}
}
#line 5249 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5251
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 5254 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5257
  return ((OPJ_FLOAT32 )0);
}
}
#line 5260 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT64 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
  {
#line 5264
  l_cp = (opj_cp_t *)0;
#line 5265
  l_image = (opj_image_t *)0;
#line 5266
  l_tcp = (opj_tcp_t *)0;
#line 5267
  l_img_comp = (opj_image_comp_t *)0;
#line 5271
  l_rates = (OPJ_FLOAT32 *)0;
#line 5274
  l_tile_size = (OPJ_UINT64 )0;
#line 5276
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 5285
  l_cp = & p_j2k->m_cp;
#line 5286
  l_image = p_j2k->m_private_image;
#line 5287
  l_tcp = l_cp->tcps;
#line 5289
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 5290
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 5291
  __cil_tmp22 = opj_stream_tell(p_stream);
#line 5291
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp22 / (OPJ_FLOAT32 )(l_cp->th * l_cp->tw);
  }
#line 5294
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 5295
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 5297
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 5300
  i = (OPJ_UINT32 )0;
  {
#line 5300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5300
    if (! (i < l_cp->th)) {
#line 5300
      goto while_break;
    }
#line 5301
    j = (OPJ_UINT32 )0;
    {
#line 5301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5301
      if (! (j < l_cp->tw)) {
#line 5301
        goto while_break___0;
      }
      {
#line 5302
      __cil_tmp24 = (*l_tp_stride_func)(l_tcp);
#line 5302
      l_offset = (OPJ_FLOAT32 )__cil_tmp24 / (OPJ_FLOAT32 )l_tcp->numlayers;
#line 5306
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 5308
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 5310
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 5312
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 5315
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
#line 5318
      k = (OPJ_UINT32 )0;
      }
      {
#line 5318
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5318
        if (! (k < l_tcp->numlayers)) {
#line 5318
          goto while_break___1;
        }
#line 5319
        if (*l_rates > 0.f) {
#line 5320
          *l_rates = (OPJ_FLOAT32 )((((OPJ_FLOAT64 )l_size_pixel * (double )((OPJ_UINT32 )(l_x1 - l_x0))) * (double )((OPJ_UINT32 )(l_y1 - l_y0))) / (double )(*l_rates * (OPJ_FLOAT32 )l_bits_empty)) - l_offset;
        }
#line 5328
        l_rates ++;
#line 5318
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5331
      l_tcp ++;
#line 5301
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5336
  l_tcp = l_cp->tcps;
#line 5338
  i = (OPJ_UINT32 )0;
  {
#line 5338
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5338
    if (! (i < l_cp->th)) {
#line 5338
      goto while_break___2;
    }
#line 5339
    j = (OPJ_UINT32 )0;
    {
#line 5339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5339
      if (! (j < l_cp->tw)) {
#line 5339
        goto while_break___3;
      }
#line 5340
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
#line 5342
      if (*l_rates > 0.f) {
#line 5343
        *l_rates -= l_sot_remove;
#line 5345
        if (*l_rates < 30.f) {
#line 5346
          *l_rates = 30.f;
        }
      }
#line 5350
      l_rates ++;
#line 5352
      l_last_res = l_tcp->numlayers - 1U;
#line 5354
      k = (OPJ_UINT32 )1;
      {
#line 5354
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5354
        if (! (k < l_last_res)) {
#line 5354
          goto while_break___4;
        }
#line 5356
        if (*l_rates > 0.f) {
#line 5357
          *l_rates -= l_sot_remove;
#line 5359
          if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5360
            *l_rates = *(l_rates - 1) + 20.f;
          }
        }
#line 5364
        l_rates ++;
#line 5354
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5367
      if (*l_rates > 0.f) {
#line 5368
        *l_rates -= l_sot_remove + 2.f;
#line 5370
        if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5371
          *l_rates = *(l_rates - 1) + 20.f;
        }
      }
#line 5375
      l_tcp ++;
#line 5339
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 5338
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5379
  l_img_comp = l_image->comps;
#line 5380
  l_tile_size = (OPJ_UINT64 )0;
#line 5382
  i = (OPJ_UINT32 )0;
  {
#line 5382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5382
    if (! (i < l_image->numcomps)) {
#line 5382
      goto while_break___5;
    }
    {
#line 5383
    __cil_tmp30 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
    }
    {
#line 5383
    __cil_tmp29 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
    }
#line 5383
    l_tile_size += ((OPJ_UINT64 )__cil_tmp29 * (unsigned long )__cil_tmp30) * (unsigned long )l_img_comp->prec;
#line 5389
    l_img_comp ++;
#line 5382
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 5398
  l_tile_size = (OPJ_UINT64 )(((double )l_tile_size * 1.4) / (double )8);
#line 5402
  l_tile_size += (unsigned long )500;
#line 5404
  __cil_tmp31 = opj_j2k_get_specific_header_sizes(p_j2k);
  }
#line 5404
  l_tile_size += (unsigned long )__cil_tmp31;
#line 5406
  if (l_tile_size > 4294967295UL) {
#line 5407
    l_tile_size = (OPJ_UINT64 )4294967295U;
  }
  {
#line 5410
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )l_tile_size;
#line 5411
  __cil_tmp32 = opj_malloc((size_t )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 5411
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp32;
  }
#line 5413
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (OPJ_BYTE *)0) {
    {
#line 5414
    opj_event_msg(p_manager, 1, "Not enough memory to allocate m_encoded_tile_data. %u MB required\n",
                  (OPJ_UINT32 )((l_tile_size / 1024UL) / 1024UL));
    }
#line 5417
    return (0);
  }
#line 5420
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 5421
    __cil_tmp33 = opj_malloc((size_t )(6U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 5421
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp33;
    }
#line 5424
    if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 5425
      return (0);
    }
#line 5428
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
  }
#line 5432
  return (1);
}
}
#line 5487 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp4 ;

  {
  {
#line 5498
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 5500
  return (1);
}
}
#line 5503 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 5517
  __cil_tmp8 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 5517
  if (! __cil_tmp8) {
#line 5518
    return (0);
  }
#line 5521
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5522
  l_mct_record = l_tcp->m_mct_records;
#line 5524
  i = (OPJ_UINT32 )0;
  {
#line 5524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5524
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5524
      goto while_break;
    }
    {
#line 5526
    __cil_tmp9 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 5526
    if (! __cil_tmp9) {
#line 5527
      return (0);
    }
#line 5530
    l_mct_record ++;
#line 5524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5533
  l_mcc_record = l_tcp->m_mcc_records;
#line 5535
  i = (OPJ_UINT32 )0;
  {
#line 5535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5535
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5535
      goto while_break___0;
    }
    {
#line 5537
    __cil_tmp10 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 5537
    if (! __cil_tmp10) {
#line 5538
      return (0);
    }
#line 5541
    l_mcc_record ++;
#line 5535
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5544
  __cil_tmp11 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 5544
  if (! __cil_tmp11) {
#line 5545
    return (0);
  }
#line 5548
  return (1);
}
}
#line 5551 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5563
  compno = (OPJ_UINT32 )1;
  {
#line 5563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5563
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5563
      goto while_break;
    }
    {
#line 5565
    __cil_tmp5 = opj_j2k_compare_coc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5565
    if (! __cil_tmp5) {
      {
#line 5566
      __cil_tmp6 = opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager);
      }
#line 5566
      if (! __cil_tmp6) {
#line 5567
        return (0);
      }
    }
#line 5563
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5572
  return (1);
}
}
#line 5575 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5587
  compno = (OPJ_UINT32 )1;
  {
#line 5587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5587
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5587
      goto while_break;
    }
    {
#line 5589
    __cil_tmp5 = opj_j2k_compare_qcc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5589
    if (! __cil_tmp5) {
      {
#line 5590
      __cil_tmp6 = opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager);
      }
#line 5590
      if (! __cil_tmp6) {
#line 5591
        return (0);
      }
    }
#line 5587
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5595
  return (1);
}
}
#line 5598 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5603
  l_tccp = (opj_tccp_t *)0;
#line 5610
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 5612
  compno = (OPJ_UINT32 )0;
  {
#line 5612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5612
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5612
      goto while_break;
    }
#line 5613
    if (l_tccp->roishift) {
      {
#line 5615
      __cil_tmp6 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 5615
      if (! __cil_tmp6) {
#line 5617
        return (0);
      }
    }
#line 5621
    l_tccp ++;
#line 5612
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5624
  return (1);
}
}
#line 5627 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  OPJ_OFF_T __cil_tmp5 ;

  {
#line 5631
  l_cstr_index = (opj_codestream_index_t *)0;
#line 5640
  l_cstr_index = p_j2k->cstr_index;
#line 5641
  if (l_cstr_index) {
    {
#line 5642
    __cil_tmp5 = opj_stream_tell(p_stream);
#line 5642
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp5;
#line 5647
    l_cstr_index->codestream_size -= (OPJ_UINT64 )l_cstr_index->main_head_start;
    }
  }
#line 5664
  return (1);
}
}
#line 5667 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp8 ;
  struct opj_dec_memory_marker_handler *__cil_tmp9 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 5675
  l_size_unk = (OPJ_UINT32 )2;
#line 5682
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 5684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5684
    if (! 1) {
#line 5684
      goto while_break;
    }
    {
#line 5686
    __cil_tmp8 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                      (OPJ_SIZE_T )2, p_manager);
    }
#line 5686
    if (__cil_tmp8 != 2UL) {
      {
#line 5688
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 5689
      return (0);
    }
    {
#line 5693
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5696
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5699
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5701
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5702
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n~~EV");
        }
#line 5704
        return (0);
      } else
#line 5706
      if (l_marker_handler->id != 0U) {
#line 5708
        if (l_marker_handler->id != 65424U) {
          {
#line 5709
          __cil_tmp11 = opj_stream_tell(p_stream);
#line 5709
          __cil_tmp12 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp11 - l_size_unk),
                                             l_size_unk);
#line 5709
          res = __cil_tmp12;
          }
#line 5712
          if (res == 0) {
            {
#line 5713
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n~EV");
            }
#line 5714
            return (0);
          }
        }
#line 5717
        goto while_break;
      } else {
#line 5719
        l_size_unk += (unsigned int )2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5725
  *output_marker = l_marker_handler->id;
#line 5727
  return (1);
}
}
#line 5730 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp9 ;
  OPJ_SIZE_T __cil_tmp10 ;

  {
#line 5736
  l_current_data = (OPJ_BYTE *)0;
#line 5744
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5746
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5747
    __cil_tmp9 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_mct_size);
#line 5747
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp9;
    }
#line 5749
    if (! new_header_tile_data) {
      {
#line 5750
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5751
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5752
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5753
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 5754
      return (0);
    }
#line 5756
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5757
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5760
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5762
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5764
  l_current_data += 2;
#line 5766
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5768
  l_current_data += 2;
#line 5770
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5772
  l_current_data += 2;
#line 5775
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5778
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 5779
  l_current_data += 2;
#line 5781
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5783
  l_current_data += 2;
#line 5785
  memcpy(l_current_data, p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5787
  __cil_tmp10 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 5787
  if (__cil_tmp10 != (unsigned long )l_mct_size) {
#line 5790
    return (0);
  }
#line 5793
  return (1);
}
}
#line 5804 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp12 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  void *__cil_tmp14 ;

  {
#line 5811
  l_tcp = (opj_tcp_t *)0;
#line 5820
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5820
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5820
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5820
  l_tcp = tmp;
#line 5824
  if (p_header_size < 2U) {
    {
#line 5825
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5826
    return (0);
  }
  {
#line 5830
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5831
  p_header_data += 2;
  }
#line 5832
  if (l_tmp != 0U) {
    {
#line 5833
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n~EV");
    }
#line 5835
    return (1);
  }
#line 5838
  if (p_header_size <= 6U) {
    {
#line 5839
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n\222~~EV");
    }
#line 5840
    return (0);
  }
  {
#line 5844
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5845
  p_header_data += 2;
#line 5847
  l_indix = l_tmp & 255U;
#line 5848
  l_mct_data = l_tcp->m_mct_records;
#line 5850
  i = (OPJ_UINT32 )0;
  }
  {
#line 5850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5850
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5850
      goto while_break;
    }
#line 5851
    if (l_mct_data->m_index == l_indix) {
#line 5852
      goto while_break;
    }
#line 5854
    l_mct_data ++;
#line 5850
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5858
  if (i == l_tcp->m_nb_mct_records) {
#line 5859
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5861
      l_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 5863
      __cil_tmp12 = opj_realloc(l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5863
      new_mct_records = (opj_mct_data_t *)__cil_tmp12;
      }
#line 5865
      if (! new_mct_records) {
        {
#line 5866
        opj_free(l_tcp->m_mct_records);
#line 5867
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5868
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5869
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5870
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5871
        return (0);
      }
#line 5876
      if (new_mct_records != l_tcp->m_mct_records) {
#line 5877
        i = (OPJ_UINT32 )0;
        {
#line 5877
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 5877
          if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5877
            goto while_break___0;
          }
#line 5878
          l_mcc_record = l_tcp->m_mcc_records + i;
#line 5880
          if (l_mcc_record->m_decorrelation_array) {
#line 5881
            l_mcc_record->m_decorrelation_array = new_mct_records + (l_mcc_record->m_decorrelation_array - l_tcp->m_mct_records);
          }
#line 5886
          if (l_mcc_record->m_offset_array) {
#line 5887
            l_mcc_record->m_offset_array = new_mct_records + (l_mcc_record->m_offset_array - l_tcp->m_mct_records);
          }
#line 5877
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 5895
      l_tcp->m_mct_records = new_mct_records;
#line 5896
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5897
      memset(l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5901
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5902
    (l_tcp->m_nb_mct_records) ++;
  }
#line 5905
  if (l_mct_data->m_data) {
    {
#line 5906
    opj_free(l_mct_data->m_data);
#line 5907
    l_mct_data->m_data = (OPJ_BYTE *)0;
#line 5908
    l_mct_data->m_data_size = (OPJ_UINT32 )0;
    }
  }
  {
#line 5911
  l_mct_data->m_index = l_indix;
#line 5912
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5913
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5915
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5916
  p_header_data += 2;
  }
#line 5917
  if (l_tmp != 0U) {
    {
#line 5918
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5920
    return (1);
  }
  {
#line 5923
  p_header_size -= (unsigned int )6;
#line 5925
  __cil_tmp14 = opj_malloc((size_t )p_header_size);
#line 5925
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp14;
  }
#line 5926
  if (! l_mct_data->m_data) {
    {
#line 5927
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5928
    return (0);
  }
  {
#line 5930
  memcpy(l_mct_data->m_data, p_header_data, (unsigned long )p_header_size);
#line 5932
  l_mct_data->m_data_size = p_header_size;
  }
#line 5934
  return (1);
}
}
#line 5937 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5944
  l_current_data = (OPJ_BYTE *)0;
#line 5954
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5955
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5956
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5958
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5959
    l_mask = (OPJ_UINT32 )0;
  }
#line 5962
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5963
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5964
    __cil_tmp12 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mcc_size);
#line 5964
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 5966
    if (! new_header_tile_data) {
      {
#line 5967
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5968
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5969
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5970
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5971
      return (0);
    }
#line 5973
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5974
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5977
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5979
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5981
  l_current_data += 2;
#line 5983
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5985
  l_current_data += 2;
#line 5988
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5990
  l_current_data += 2;
#line 5992
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5994
  l_current_data ++;
#line 5997
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5999
  l_current_data += 2;
#line 6001
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 6003
  l_current_data += 2;
#line 6005
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 6007
  l_current_data ++;
#line 6009
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 6011
  l_current_data += 2;
#line 6013
  i = (OPJ_UINT32 )0;
  }
  {
#line 6013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6013
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 6013
      goto while_break;
    }
    {
#line 6014
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 6016
    l_current_data += l_nb_bytes_for_comp;
    }
#line 6013
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6019
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 6021
  l_current_data += 2;
#line 6023
  i = (OPJ_UINT32 )0;
  }
  {
#line 6023
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6023
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 6023
      goto while_break___0;
    }
    {
#line 6024
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 6026
    l_current_data += l_nb_bytes_for_comp;
    }
#line 6023
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6029
  l_tmcc = (! p_mcc_record->m_is_irreversible & 1U) << 16;
#line 6031
  if (p_mcc_record->m_decorrelation_array) {
#line 6032
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 6035
  if (p_mcc_record->m_offset_array) {
#line 6036
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 6039
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 6041
  l_current_data += 3;
#line 6043
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 6043
  if (__cil_tmp13 != (unsigned long )l_mcc_size) {
#line 6046
    return (0);
  }
#line 6049
  return (1);
}
}
#line 6052 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  OPJ_BOOL l_new_mcc ;
  opj_tcp_t *tmp ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp18 ;

  {
#line 6066
  l_new_mcc = 0;
#line 6073
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 6073
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 6073
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6073
  l_tcp = tmp;
#line 6077
  if (p_header_size < 2U) {
    {
#line 6078
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n\314~~EV");
    }
#line 6079
    return (0);
  }
  {
#line 6083
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 6084
  p_header_data += 2;
  }
#line 6085
  if (l_tmp != 0U) {
    {
#line 6086
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 6088
    return (1);
  }
#line 6091
  if (p_header_size < 7U) {
    {
#line 6092
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 6093
    return (0);
  }
  {
#line 6096
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 6098
  p_header_data ++;
#line 6100
  l_mcc_record = l_tcp->m_mcc_records;
#line 6102
  i = (OPJ_UINT32 )0;
  }
  {
#line 6102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6102
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 6102
      goto while_break;
    }
#line 6103
    if (l_mcc_record->m_index == l_indix) {
#line 6104
      goto while_break;
    }
#line 6106
    l_mcc_record ++;
#line 6102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6110
  if (i == l_tcp->m_nb_mcc_records) {
#line 6111
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 6113
      l_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 6115
      __cil_tmp18 = opj_realloc(l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 6115
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp18;
      }
#line 6118
      if (! new_mcc_records) {
        {
#line 6119
        opj_free(l_tcp->m_mcc_records);
#line 6120
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 6121
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 6122
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 6123
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\n");
        }
#line 6124
        return (0);
      }
      {
#line 6126
      l_tcp->m_mcc_records = new_mcc_records;
#line 6127
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 6128
      memset(l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 6131
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 6132
    l_new_mcc = 1;
  }
  {
#line 6134
  l_mcc_record->m_index = l_indix;
#line 6137
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 6138
  p_header_data += 2;
  }
#line 6139
  if (l_tmp != 0U) {
    {
#line 6140
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\nV");
    }
#line 6142
    return (1);
  }
  {
#line 6145
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 6147
  p_header_data += 2;
  }
#line 6149
  if (l_nb_collections > 1U) {
    {
#line 6150
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\n");
    }
#line 6152
    return (1);
  }
#line 6155
  p_header_size -= (unsigned int )7;
#line 6157
  i = (OPJ_UINT32 )0;
  {
#line 6157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6157
    if (! (i < l_nb_collections)) {
#line 6157
      goto while_break___0;
    }
#line 6158
    if (p_header_size < 3U) {
      {
#line 6159
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n\026\177~EV");
      }
#line 6160
      return (0);
    }
    {
#line 6163
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 6165
    p_header_data ++;
    }
#line 6167
    if (l_tmp != 1U) {
      {
#line 6168
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n\236\177~EV");
      }
#line 6170
      return (1);
    }
    {
#line 6173
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 6175
    p_header_data += 2;
#line 6176
    p_header_size -= (unsigned int )3;
#line 6178
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 6179
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 6181
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 6182
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 6183
      return (0);
    }
#line 6186
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 6188
    j = (OPJ_UINT32 )0;
    {
#line 6188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6188
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 6188
        goto while_break___1;
      }
      {
#line 6189
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 6191
      p_header_data += l_nb_bytes_by_comp;
      }
#line 6193
      if (l_tmp != j) {
        {
#line 6194
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 6196
        return (1);
      }
#line 6188
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 6200
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 6201
    p_header_data += 2;
#line 6203
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 6204
    l_nb_comps &= (unsigned int )32767;
    }
#line 6206
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 6207
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 6209
      return (1);
    }
#line 6212
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 6213
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 6214
      return (0);
    }
#line 6217
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 6219
    j = (OPJ_UINT32 )0;
    {
#line 6219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6219
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 6219
        goto while_break___2;
      }
      {
#line 6220
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 6222
      p_header_data += l_nb_bytes_by_comp;
      }
#line 6224
      if (l_tmp != j) {
        {
#line 6225
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 6227
        return (1);
      }
#line 6219
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6231
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 6232
    p_header_data += 3;
#line 6234
    l_mcc_record->m_is_irreversible = ! ((l_tmp >> 16) & 1U);
#line 6235
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 6236
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 6238
    l_indix = l_tmp & 255U;
    }
#line 6239
    if (l_indix != 0U) {
#line 6240
      l_mct_data = l_tcp->m_mct_records;
#line 6241
      j = (OPJ_UINT32 )0;
      {
#line 6241
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6241
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 6241
          goto while_break___3;
        }
#line 6242
        if (l_mct_data->m_index == l_indix) {
#line 6243
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 6244
          goto while_break___3;
        }
#line 6246
        l_mct_data ++;
#line 6241
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6249
      if (l_mcc_record->m_decorrelation_array == (opj_mct_data_t *)0) {
        {
#line 6250
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6251
        return (0);
      }
    }
#line 6255
    l_indix = (l_tmp >> 8) & 255U;
#line 6256
    if (l_indix != 0U) {
#line 6257
      l_mct_data = l_tcp->m_mct_records;
#line 6258
      j = (OPJ_UINT32 )0;
      {
#line 6258
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 6258
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 6258
          goto while_break___4;
        }
#line 6259
        if (l_mct_data->m_index == l_indix) {
#line 6260
          l_mcc_record->m_offset_array = l_mct_data;
#line 6261
          goto while_break___4;
        }
#line 6263
        l_mct_data ++;
#line 6258
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 6266
      if (l_mcc_record->m_offset_array == (opj_mct_data_t *)0) {
        {
#line 6267
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6268
        return (0);
      }
    }
#line 6157
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6273
  if (p_header_size != 0U) {
    {
#line 6274
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 6275
    return (0);
  }
#line 6278
  if (l_new_mcc) {
#line 6279
    (l_tcp->m_nb_mcc_records) ++;
  }
#line 6282
  return (1);
}
}
#line 6285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 6290
  l_current_data = (OPJ_BYTE *)0;
#line 6292
  l_tcp = (opj_tcp_t *)0;
#line 6301
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 6303
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 6304
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6306
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mco_size);
#line 6306
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 6308
    if (! new_header_tile_data) {
      {
#line 6309
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6310
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6311
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6312
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 6313
      return (0);
    }
#line 6315
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6316
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 6318
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6321
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 6322
  l_current_data += 2;
#line 6324
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 6325
  l_current_data += 2;
#line 6327
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 6329
  l_current_data ++;
#line 6331
  l_mcc_record = l_tcp->m_mcc_records;
#line 6332
  i = (OPJ_UINT32 )0;
  }
  {
#line 6332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6332
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 6332
      goto while_break;
    }
    {
#line 6333
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 6335
    l_current_data ++;
#line 6336
    l_mcc_record ++;
    }
#line 6332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6339
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 6339
  if (__cil_tmp11 != (unsigned long )l_mco_size) {
#line 6342
    return (0);
  }
#line 6345
  return (1);
}
}
#line 6356 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 6373
  l_image = p_j2k->m_private_image;
#line 6374
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 6374
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 6374
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6374
  l_tcp = tmp;
#line 6378
  if (p_header_size < 1U) {
    {
#line 6379
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n\n\200~EV");
    }
#line 6380
    return (0);
  }
  {
#line 6383
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 6385
  p_header_data ++;
  }
#line 6387
  if (l_nb_stages > 1U) {
    {
#line 6388
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 6390
    return (1);
  }
#line 6393
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 6394
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n");
    }
#line 6395
    return (0);
  }
#line 6398
  l_tccp = l_tcp->tccps;
#line 6400
  i = (OPJ_UINT32 )0;
  {
#line 6400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6400
    if (! (i < l_image->numcomps)) {
#line 6400
      goto while_break;
    }
#line 6401
    l_tccp->m_dc_level_shift = 0;
#line 6402
    l_tccp ++;
#line 6400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6405
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 6406
    opj_free(l_tcp->m_mct_decoding_matrix);
#line 6407
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 6410
  i = (OPJ_UINT32 )0;
  {
#line 6410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6410
    if (! (i < l_nb_stages)) {
#line 6410
      goto while_break___0;
    }
    {
#line 6411
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 6412
    p_header_data ++;
#line 6414
    __cil_tmp12 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 6414
    if (! __cil_tmp12) {
#line 6415
      return (0);
    }
#line 6410
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6419
  return (1);
}
}
#line 6422 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  OPJ_UINT32 *__cil_tmp17 ;

  {
#line 6436
  l_mcc_record = p_tcp->m_mcc_records;
#line 6438
  i = (OPJ_UINT32 )0;
  {
#line 6438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6438
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 6438
      goto while_break;
    }
#line 6439
    if (l_mcc_record->m_index == p_index) {
#line 6440
      goto while_break;
    }
#line 6438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6444
  if (i == p_tcp->m_nb_mcc_records) {
#line 6446
    return (1);
  }
#line 6449
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 6451
    return (1);
  }
#line 6454
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 6456
  if (l_deco_array) {
#line 6457
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 6459
    if (l_deco_array->m_data_size != l_data_size) {
#line 6460
      return (0);
    }
    {
#line 6463
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6464
    l_mct_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6465
    __cil_tmp15 = opj_malloc((size_t )l_mct_size);
#line 6465
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp15;
    }
#line 6467
    if (! p_tcp->m_mct_decoding_matrix) {
#line 6468
      return (0);
    }
    {
#line 6471
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))(l_deco_array->m_data,
                                                                       p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 6475
  l_offset_array = l_mcc_record->m_offset_array;
#line 6477
  if (l_offset_array) {
#line 6478
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 6480
    if (l_offset_array->m_data_size != l_data_size) {
#line 6481
      return (0);
    }
    {
#line 6484
    l_nb_elem = p_image->numcomps;
#line 6485
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 6486
    __cil_tmp16 = opj_malloc((size_t )l_offset_size);
#line 6486
    l_offset_data = (OPJ_UINT32 *)__cil_tmp16;
    }
#line 6488
    if (! l_offset_data) {
#line 6489
      return (0);
    }
    {
#line 6492
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))(l_offset_array->m_data,
                                                                         l_offset_data,
                                                                         l_nb_elem);
#line 6495
    l_tccp = p_tcp->tccps;
#line 6496
    l_current_offset_data = l_offset_data;
#line 6498
    i = (OPJ_UINT32 )0;
    }
    {
#line 6498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6498
      if (! (i < p_image->numcomps)) {
#line 6498
        goto while_break___0;
      }
#line 6499
      __cil_tmp17 = l_current_offset_data;
#line 6499
      l_current_offset_data ++;
#line 6499
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp17;
#line 6500
      l_tccp ++;
#line 6498
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6503
    opj_free(l_offset_data);
    }
  }
#line 6506
  return (1);
}
}
#line 6509 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 6515
  l_current_data = (OPJ_BYTE *)0;
#line 6516
  l_image = (opj_image_t *)0;
#line 6517
  l_comp = (opj_image_comp_t *)0;
#line 6524
  l_image = p_j2k->m_private_image;
#line 6525
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 6527
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6528
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_cbd_size);
#line 6528
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 6530
    if (! new_header_tile_data) {
      {
#line 6531
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6532
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6533
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6534
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 6535
      return (0);
    }
#line 6537
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6538
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 6541
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6543
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 6544
  l_current_data += 2;
#line 6546
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 6547
  l_current_data += 2;
#line 6549
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 6550
  l_current_data += 2;
#line 6552
  l_comp = l_image->comps;
#line 6554
  i = (OPJ_UINT32 )0;
  }
  {
#line 6554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6554
    if (! (i < l_image->numcomps)) {
#line 6554
      goto while_break;
    }
    {
#line 6555
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 6557
    l_current_data ++;
#line 6559
    l_comp ++;
    }
#line 6554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6562
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 6562
  if (__cil_tmp11 != (unsigned long )l_cbd_size) {
#line 6565
    return (0);
  }
#line 6568
  return (1);
}
}
#line 6578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;

  {
#line 6587
  l_comp = (opj_image_comp_t *)0;
#line 6594
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 6596
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 6597
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n*\200~EV");
    }
#line 6598
    return (0);
  }
  {
#line 6601
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 6603
  p_header_data += 2;
  }
#line 6605
  if (l_nb_comp != l_num_comp) {
    {
#line 6606
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 6607
    return (0);
  }
#line 6610
  l_comp = (p_j2k->m_private_image)->comps;
#line 6611
  i = (OPJ_UINT32 )0;
  {
#line 6611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6611
    if (! (i < l_num_comp)) {
#line 6611
      goto while_break;
    }
    {
#line 6612
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 6614
    p_header_data ++;
#line 6615
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 6616
    l_comp->prec = (l_comp_def & 127U) + 1U;
    }
#line 6618
    if (l_comp->prec > 31U) {
      {
#line 6619
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_comp->prec);
      }
#line 6622
      return (0);
    }
#line 6624
    l_comp ++;
#line 6611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6627
  return (1);
}
}
#line 6639 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cap(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6655
  return (1);
}
}
#line 6665 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cpf(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6681
  return (1);
}
}
#line 6688 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 6690
  if (j2k) {
#line 6690
    if (parameters) {
#line 6691
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 6692
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
#line 6694
      j2k->dump_state = parameters->flags & 2U;
    }
  }
  return;
}
}
#line 6703 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_decoder_set_strict_mode(opj_j2k_t *j2k , OPJ_BOOL strict ) 
{ 


  {
#line 6705
  if (j2k) {
#line 6706
    j2k->m_cp.strict = strict;
  }
  return;
}
}
#line 6710 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  opj_thread_pool_t *__cil_tmp4 ;
  opj_thread_pool_t *__cil_tmp5 ;

  {
  {
#line 6714
  __cil_tmp3 = opj_has_thread_support();
  }
#line 6714
  if (j2k->m_tcd == (void *)0) {
#line 6714
    if (__cil_tmp3) {
      {
#line 6715
      opj_thread_pool_destroy(j2k->m_tp);
#line 6716
      j2k->m_tp = (opj_thread_pool_t *)((void *)0);
      }
#line 6717
      if (num_threads <= 2147483647U) {
        {
#line 6718
        j2k->m_tp = opj_thread_pool_create((int )num_threads);
        }
      }
#line 6720
      if (j2k->m_tp == (void *)0) {
        {
#line 6721
        j2k->m_tp = opj_thread_pool_create(0);
        }
#line 6722
        return (0);
      }
#line 6724
      return (1);
    }
  }
#line 6726
  return (0);
}
}
#line 6729 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_get_default_thread_count(void) 
{ 
  char const   *num_threads_str ;
  char *__cil_tmp2 ;
  int num_cpus ;
  int num_threads ;
  OPJ_BOOL __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 6731
  __cil_tmp2 = getenv("OPJ_NUM_THREADS");
#line 6731
  num_threads_str = (char const   *)__cil_tmp2;
#line 6735
  __cil_tmp5 = opj_has_thread_support();
  }
#line 6735
  if (num_threads_str == (void *)0) {
#line 6736
    return (0);
  } else
#line 6735
  if (! __cil_tmp5) {
#line 6736
    return (0);
  }
  {
#line 6738
  num_cpus = opj_get_num_cpus();
#line 6739
  __cil_tmp7 = strcmp(num_threads_str, "ALL_CPUS\220");
  }
#line 6739
  if (__cil_tmp7 == 0) {
#line 6740
    return (num_cpus);
  }
#line 6742
  if (num_cpus == 0) {
#line 6743
    num_cpus = 32;
  }
  {
#line 6745
  num_threads = atoi(num_threads_str);
  }
#line 6746
  if (num_threads < 0) {
#line 6747
    num_threads = 0;
  } else
#line 6748
  if (num_threads > 2 * num_cpus) {
#line 6749
    num_threads = 2 * num_cpus;
  }
#line 6751
  return (num_threads);
}
}
#line 6758 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  opj_procedure_list_t *__cil_tmp4 ;
  opj_procedure_list_t *__cil_tmp5 ;
  int __cil_tmp6 ;
  opj_thread_pool_t *__cil_tmp7 ;
  opj_thread_pool_t *__cil_tmp8 ;

  {
  {
#line 6760
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 6760
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 6761
  if (! l_j2k) {
#line 6762
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6766
  l_j2k->m_is_decoder = 0;
#line 6767
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )0;
#line 6769
  __cil_tmp3 = opj_malloc((size_t )1000);
#line 6769
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 6771
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 6772
    opj_j2k_destroy(l_j2k);
    }
#line 6773
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6776
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 6780
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 6781
  if (! l_j2k->m_validation_list) {
    {
#line 6782
    opj_j2k_destroy(l_j2k);
    }
#line 6783
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6787
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 6788
  if (! l_j2k->m_procedure_list) {
    {
#line 6789
    opj_j2k_destroy(l_j2k);
    }
#line 6790
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6793
  __cil_tmp6 = opj_j2k_get_default_thread_count();
#line 6793
  __cil_tmp7 = opj_thread_pool_create(__cil_tmp6);
#line 6793
  l_j2k->m_tp = __cil_tmp7;
  }
#line 6794
  if (! l_j2k->m_tp) {
    {
#line 6795
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 6797
  if (! l_j2k->m_tp) {
    {
#line 6798
    opj_j2k_destroy(l_j2k);
    }
#line 6799
    return ((opj_j2k_t *)((void *)0));
  }
#line 6802
  return (l_j2k);
}
}
#line 6805 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 6807
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 6808
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 6809
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 6810
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 6811
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 6812
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 6813
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 6814
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 6815
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 6816
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 6817
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 6818
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 6819
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 6820
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 6821
  return (2);
}
}
#line 6824 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 6831
  parameters->tile_size_on = 0;
#line 6832
  parameters->cp_tdx = 1;
#line 6833
  parameters->cp_tdy = 1;
#line 6836
  parameters->tp_flag = (char )'C';
#line 6837
  parameters->tp_on = (char )1;
#line 6840
  parameters->cp_tx0 = 0;
#line 6841
  parameters->cp_ty0 = 0;
#line 6842
  parameters->image_offset_x0 = 0;
#line 6843
  parameters->image_offset_y0 = 0;
#line 6846
  parameters->cblockw_init = 32;
#line 6847
  parameters->cblockh_init = 32;
#line 6850
  parameters->mode = 0;
#line 6853
  parameters->roi_compno = - 1;
#line 6856
  parameters->subsampling_dx = 1;
#line 6857
  parameters->subsampling_dy = 1;
#line 6860
  parameters->irreversible = 1;
#line 6863
  if (parameters->tcp_numlayers > 1) {
    {
#line 6864
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters->tcp_numlayers, (double )parameters->tcp_rates[parameters->tcp_numlayers - 1]);
#line 6871
    parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
#line 6872
    parameters->tcp_numlayers = 1;
    }
  }
  {
#line 6877
  if ((int )parameters->rsiz == 3) {
#line 6877
    goto case_3;
  }
#line 6887
  if ((int )parameters->rsiz == 4) {
#line 6887
    goto case_4;
  }
#line 6904
  goto switch_default;
  case_3: /* CIL Label */ 
#line 6878
  if (parameters->numresolution > 6) {
    {
#line 6879
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6884
    parameters->numresolution = 6;
    }
  }
#line 6886
  goto switch_break;
  case_4: /* CIL Label */ 
#line 6888
  if (parameters->numresolution < 2) {
    {
#line 6889
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6894
    parameters->numresolution = 1;
    }
  } else
#line 6895
  if (parameters->numresolution > 7) {
    {
#line 6896
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6901
    parameters->numresolution = 7;
    }
  }
#line 6903
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 6905
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6909
  parameters->csty |= 1;
#line 6910
  if (parameters->numresolution == 1) {
#line 6911
    parameters->res_spec = 1;
#line 6912
    parameters->prcw_init[0] = 128;
#line 6913
    parameters->prch_init[0] = 128;
  } else {
#line 6915
    parameters->res_spec = parameters->numresolution - 1;
#line 6916
    i = 0;
    {
#line 6916
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6916
      if (! (i < parameters->res_spec)) {
#line 6916
        goto while_break;
      }
#line 6917
      parameters->prcw_init[i] = 256;
#line 6918
      parameters->prch_init[i] = 256;
#line 6916
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6923
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 6926
  if ((int )parameters->rsiz == 4) {
    {
#line 6927
    __cil_tmp6 = opj_j2k_initialise_4K_poc((opj_poc_t *)parameters->POC, parameters->numresolution);
#line 6927
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp6;
    }
  } else {
#line 6930
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 6934
  parameters->cp_disto_alloc = 1;
#line 6935
  if (parameters->max_cs_size <= 0) {
    {
#line 6937
    parameters->max_cs_size = 1302083;
#line 6938
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6942
  if (parameters->max_cs_size > 1302083) {
    {
#line 6943
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6947
    parameters->max_cs_size = 1302083;
    }
  }
#line 6950
  if (parameters->max_comp_size <= 0) {
    {
#line 6952
    parameters->max_comp_size = 1041666;
#line 6953
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6957
  if (parameters->max_comp_size > 1041666) {
    {
#line 6958
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6962
    parameters->max_comp_size = 1041666;
    }
  }
#line 6965
  parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
  return;
}
}
#line 6972 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 6978
  if (image->numcomps != 3U) {
    {
#line 6979
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 6985
    return (0);
  }
#line 6989
  i = (OPJ_UINT32 )0;
  {
#line 6989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6989
    if (! (i < image->numcomps)) {
#line 6989
      goto while_break;
    }
#line 6990
    if (((image->comps + i)->prec != 12U) | (image->comps + i)->sgnd) {
#line 6991
      signed_str = "signed";
#line 6992
      unsigned_str = "unsigned\f";
#line 6993
      if ((image->comps + i)->sgnd) {
#line 6993
        tmp = (char *)signed_str;
      } else {
#line 6993
        tmp = (char *)unsigned_str;
      }
      {
#line 6993
      tmp_str = tmp;
#line 6994
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->prec, tmp_str);
      }
#line 7000
      return (0);
    }
#line 6989
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7006
  if ((int )rsiz == 3) {
#line 7006
    goto case_3;
  }
#line 7017
  if ((int )rsiz == 4) {
#line 7017
    goto case_4;
  }
#line 7028
  goto switch_default;
  case_3: /* CIL Label */ 
#line 7007
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 7008
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 7014
    return (0);
  }
#line 7016
  goto switch_break;
  case_4: /* CIL Label */ 
#line 7018
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 7019
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 7025
    return (0);
  }
#line 7027
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 7029
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 7032
  return (1);
}
}
#line 7035 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_get_imf_max_NL(opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  OPJ_UINT32 XTsiz ;
  OPJ_UINT32 tmp ;

  {
#line 7039
  rsiz = parameters->rsiz;
#line 7040
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7041
  if (parameters->tile_size_on) {
#line 7041
    tmp = (OPJ_UINT32 )parameters->cp_tdx;
  } else {
#line 7041
    tmp = image->x1;
  }
#line 7041
  XTsiz = tmp;
  {
#line 7044
  if ((int )profile == 1024) {
#line 7044
    goto case_1024;
  }
#line 7046
  if ((int )profile == 1280) {
#line 7046
    goto case_1280;
  }
#line 7048
  if ((int )profile == 1536) {
#line 7048
    goto case_1536;
  }
#line 7050
  if ((int )profile == 1792) {
#line 7050
    goto case_1792;
  }
#line 7058
  if ((int )profile == 2048) {
#line 7058
    goto case_2048;
  }
#line 7068
  if ((int )profile == 2304) {
#line 7068
    goto case_2304;
  }
#line 7080
  goto switch_default;
  case_1024: /* CIL Label */ 
#line 7045
  return (5);
  case_1280: /* CIL Label */ 
#line 7047
  return (6);
  case_1536: /* CIL Label */ 
#line 7049
  return (7);
  case_1792: /* CIL Label */ 
#line 7051
  if (XTsiz >= 2048U) {
#line 7052
    return (5);
  } else
#line 7053
  if (XTsiz >= 1024U) {
#line 7054
    return (4);
  }
#line 7056
  goto switch_break;
  case_2048: /* CIL Label */ 
#line 7059
  if (XTsiz >= 4096U) {
#line 7060
    return (6);
  } else
#line 7061
  if (XTsiz >= 2048U) {
#line 7062
    return (5);
  } else
#line 7063
  if (XTsiz >= 1024U) {
#line 7064
    return (4);
  }
#line 7066
  goto switch_break;
  case_2304: /* CIL Label */ 
#line 7069
  if (XTsiz >= 8192U) {
#line 7070
    return (7);
  } else
#line 7071
  if (XTsiz >= 4096U) {
#line 7072
    return (6);
  } else
#line 7073
  if (XTsiz >= 2048U) {
#line 7074
    return (5);
  } else
#line 7075
  if (XTsiz >= 1024U) {
#line 7076
    return (4);
  }
#line 7078
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 7081
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 7083
  return (- 1);
}
}
#line 7086 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  int max_NL ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int i ;
  int __cil_tmp11 ;

  {
#line 7089
  rsiz = parameters->rsiz;
#line 7090
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7095
  if (parameters->cblockw_init == 64) {
#line 7095
    if (parameters->cblockh_init == 64) {
#line 7097
      parameters->cblockw_init = 32;
#line 7098
      parameters->cblockh_init = 32;
    }
  }
#line 7102
  parameters->tp_flag = (char )'C';
#line 7103
  parameters->tp_on = (char )1;
#line 7105
  if ((int )parameters->prog_order == 0) {
#line 7106
    parameters->prog_order = (OPJ_PROG_ORDER )4;
  }
#line 7109
  if ((int )profile == 1024) {
#line 7113
    parameters->irreversible = 1;
  } else
#line 7109
  if ((int )profile == 1280) {
#line 7113
    parameters->irreversible = 1;
  } else
#line 7109
  if ((int )profile == 1536) {
#line 7113
    parameters->irreversible = 1;
  }
#line 7117
  if (parameters->numresolution == 6) {
#line 7117
    if (image->x0 == 0U) {
#line 7117
      if (image->y0 == 0U) {
        {
#line 7120
        __cil_tmp7 = opj_j2k_get_imf_max_NL(parameters, image);
#line 7120
        max_NL = __cil_tmp7;
        }
#line 7121
        if (max_NL >= 0) {
#line 7121
          if (parameters->numresolution > max_NL) {
#line 7122
            parameters->numresolution = max_NL + 1;
          }
        }
#line 7126
        if (! parameters->tile_size_on) {
          {
#line 7127
          while (1) {
            while_continue: /* CIL Label */ ;
#line 7127
            if (! (parameters->numresolution > 0)) {
#line 7127
              goto while_break;
            }
#line 7128
            if (image->x1 < 1U << ((OPJ_UINT32 )parameters->numresolution - 1U)) {
#line 7129
              __cil_tmp8 = parameters->numresolution;
#line 7129
              (parameters->numresolution) --;
#line 7130
              goto while_continue;
            }
#line 7132
            if (image->y1 < 1U << ((OPJ_UINT32 )parameters->numresolution - 1U)) {
#line 7133
              __cil_tmp9 = parameters->numresolution;
#line 7133
              (parameters->numresolution) --;
#line 7134
              goto while_continue;
            }
#line 7136
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 7142
  if (parameters->csty == 0) {
#line 7143
    parameters->csty |= 1;
#line 7144
    if (parameters->numresolution == 1) {
#line 7145
      parameters->res_spec = 1;
#line 7146
      parameters->prcw_init[0] = 128;
#line 7147
      parameters->prch_init[0] = 128;
    } else {
#line 7150
      parameters->res_spec = parameters->numresolution - 1;
#line 7151
      i = 0;
      {
#line 7151
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 7151
        if (! (i < parameters->res_spec)) {
#line 7151
          goto while_break___0;
        }
#line 7152
        parameters->prcw_init[i] = 256;
#line 7153
        parameters->prch_init[i] = 256;
#line 7151
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 7160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT16 tabMaxSubLevelFromMainLevel[12]  = 
#line 7160
  {      (OPJ_UINT16 )15,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )3,      (OPJ_UINT16 )4,      (OPJ_UINT16 )5, 
        (OPJ_UINT16 )6,      (OPJ_UINT16 )7,      (OPJ_UINT16 )8,      (OPJ_UINT16 )9};
#line 7175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters , opj_image_t *image ,
                                         opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  OPJ_UINT16 mainlevel ;
  OPJ_UINT16 sublevel ;
  int NL ;
  OPJ_UINT32 XTsiz ;
  OPJ_UINT32 tmp ;
  OPJ_BOOL ret ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp___0 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  int i___23 ;
  int __cil_tmp20 ;

  {
#line 7180
  rsiz = parameters->rsiz;
#line 7181
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7182
  mainlevel = (OPJ_UINT16 )((int )rsiz & 15);
#line 7183
  sublevel = (OPJ_UINT16 )(((int )rsiz >> 4) & 15);
#line 7184
  NL = parameters->numresolution - 1;
#line 7185
  if (parameters->tile_size_on) {
#line 7185
    tmp = (OPJ_UINT32 )parameters->cp_tdx;
  } else {
#line 7185
    tmp = image->x1;
  }
#line 7185
  XTsiz = tmp;
#line 7187
  ret = 1;
#line 7190
  if ((int )mainlevel > 11) {
    {
#line 7191
    opj_event_msg(p_manager, 2, "IMF profile require mainlevel <= 11.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n",
                  (int )mainlevel);
#line 7196
    ret = 0;
    }
  } else
#line 7201
  if ((int )sublevel > (int )tabMaxSubLevelFromMainLevel[mainlevel]) {
    {
#line 7202
    opj_event_msg(p_manager, 2, "IMF profile require sublevel <= %d for mainlevel = %d.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n~EV",
                  (int )tabMaxSubLevelFromMainLevel[mainlevel], (int )mainlevel, (int )sublevel);
#line 7209
    ret = 0;
    }
  }
#line 7214
  if (image->numcomps > 3U) {
    {
#line 7215
    opj_event_msg(p_manager, 2, "IMF profiles require at most 3 components.\n-> Number of components of input image (%d) is not compliant\n-> Non-IMF codestream will be generated\n\230\001",
                  image->numcomps);
#line 7220
    ret = 0;
    }
  }
#line 7223
  if (image->x0 != 0U) {
    {
    {
#line 7224
    opj_event_msg(p_manager, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image->x0, image->y0 != 0U);
    }
#line 7229
    ret = 0;
    }
  } else
#line 7223
  if (image->y0 != 0U) {
    {
    {
#line 7224
    opj_event_msg(p_manager, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image->x0, image->y0 != 0U);
    }
#line 7229
    ret = 0;
    }
  }
#line 7232
  if (parameters->cp_tx0 != 0) {
    {
    {
#line 7233
    opj_event_msg(p_manager, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters->cp_tx0, parameters->cp_ty0);
    }
#line 7238
    ret = 0;
    }
  } else
#line 7232
  if (parameters->cp_ty0 != 0) {
    {
    {
#line 7233
    opj_event_msg(p_manager, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters->cp_tx0, parameters->cp_ty0);
    }
#line 7238
    ret = 0;
    }
  }
#line 7241
  if (parameters->tile_size_on) {
#line 7242
    if ((int )profile == 1024) {
      _L___18: /* CIL Label */ 
      _L___19: /* CIL Label */ 
#line 7245
      if ((OPJ_UINT32 )parameters->cp_tdx < image->x1) {
        {
        {
#line 7247
        opj_event_msg(p_manager, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy, image->x1, image->y1);
        }
#line 7255
        ret = 0;
        }
      } else
#line 7245
      if ((OPJ_UINT32 )parameters->cp_tdy < image->y1) {
        {
        {
#line 7247
        opj_event_msg(p_manager, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy, image->x1, image->y1);
        }
#line 7255
        ret = 0;
        }
      }
    } else
#line 7242
    if ((int )profile == 1280) {
#line 7242
      goto _L___18;
    } else
#line 7242
    if ((int )profile == 1536) {
#line 7242
      goto _L___18;
    } else
#line 7258
    if ((OPJ_UINT32 )parameters->cp_tdx >= image->x1) {
#line 7258
      if (! ((OPJ_UINT32 )parameters->cp_tdy >= image->y1)) {
#line 7258
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 7261
    if (parameters->cp_tdx == 1024) {
#line 7261
      if (! (parameters->cp_tdy == 1024)) {
#line 7261
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 7264
    if (parameters->cp_tdx == 2048) {
#line 7264
      if (parameters->cp_tdy == 2048) {
#line 7264
        if (! ((int )profile == 1280)) {
#line 7264
          if (! ((int )profile == 1536)) {
#line 7264
            goto _L;
          }
        }
      } else {
#line 7264
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___15: /* CIL Label */ 
#line 7269
    if (parameters->cp_tdx == 4096) {
#line 7269
      if (parameters->cp_tdy == 4096) {
#line 7269
        if (! ((int )profile == 1536)) {
          {
          {
          {
#line 7274
          opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                        parameters->cp_tdx, parameters->cp_tdy);
          }
          }
#line 7283
          ret = 0;
          }
        }
      } else {
        {
        {
        {
#line 7274
        opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy);
        }
        }
#line 7283
        ret = 0;
        }
      }
    } else {
      {
      {
      {
#line 7274
      opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                    parameters->cp_tdx, parameters->cp_tdy);
      }
      }
#line 7283
      ret = 0;
      }
    }
  }
#line 7289
  i = (OPJ_UINT32 )0;
  {
#line 7289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7289
    if (! (i < image->numcomps)) {
#line 7289
      goto while_break;
    }
#line 7290
    if (! ((image->comps + i)->prec >= 8U && (image->comps + i)->prec <= 16U)) {
      _L___20: /* CIL Label */ 
#line 7292
      signed_str = "signed";
#line 7293
      unsigned_str = "unsigned\f";
#line 7294
      if ((image->comps + i)->sgnd) {
#line 7294
        tmp___0 = (char *)signed_str;
      } else {
#line 7294
        tmp___0 = (char *)unsigned_str;
      }
      {
#line 7294
      tmp_str = tmp___0;
#line 7295
      opj_event_msg(p_manager, 2, "IMF profiles require precision of each component to b in [8-16] bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-IMF codestream will be generated\n",
                    i, (image->comps + i)->prec, tmp_str);
#line 7300
      ret = 0;
      }
    } else
#line 7290
    if ((image->comps + i)->sgnd) {
#line 7290
      goto _L___20;
    }
#line 7289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7305
  i = (OPJ_UINT32 )0;
  {
#line 7305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7305
    if (! (i < image->numcomps)) {
#line 7305
      goto while_break___0;
    }
#line 7306
    if (i == 0U) {
#line 7306
      if ((image->comps + i)->dx != 1U) {
        {
#line 7307
        opj_event_msg(p_manager, 2, "IMF profiles require XRSiz1 == 1. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                      (image->comps + i)->dx);
#line 7311
        ret = 0;
        }
      }
    }
#line 7313
    if (i == 1U) {
#line 7313
      if ((image->comps + i)->dx != 1U) {
#line 7313
        if ((image->comps + i)->dx != 2U) {
          {
#line 7314
          opj_event_msg(p_manager, 2, "IMF profiles require XRSiz2 == 1 or 2. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                        (image->comps + i)->dx);
#line 7318
          ret = 0;
          }
        }
      }
    }
#line 7320
    if (i > 1U) {
#line 7320
      if ((image->comps + i)->dx != (image->comps + (i - 1U))->dx) {
        {
#line 7321
        opj_event_msg(p_manager, 2, "IMF profiles require XRSiz%d to be the same as XRSiz2. Here it is set to %d instead of %d.\n-> Non-IMF codestream will be generated\n",
                      i + 1U, (image->comps + i)->dx, (image->comps + (i - 1U))->dx);
#line 7326
        ret = 0;
        }
      }
    }
#line 7328
    if ((image->comps + i)->dy != 1U) {
      {
#line 7329
      opj_event_msg(p_manager, 2, "IMF profiles require YRsiz == 1. Here it is set to %d for component %d.\n-> Non-IMF codestream will be generated\n\230\001",
                    (image->comps + i)->dy, i);
#line 7334
      ret = 0;
      }
    }
#line 7305
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7341
  if ((int )profile == 1792) {
#line 7341
    goto case_1792;
  }
#line 7341
  if ((int )profile == 1024) {
#line 7341
    goto case_1792;
  }
#line 7353
  if ((int )profile == 2048) {
#line 7353
    goto case_2048;
  }
#line 7353
  if ((int )profile == 1280) {
#line 7353
    goto case_2048;
  }
#line 7365
  if ((int )profile == 2304) {
#line 7365
    goto case_2304;
  }
#line 7365
  if ((int )profile == 1536) {
#line 7365
    goto case_2304;
  }
#line 7339
  goto switch_break;
  case_1792: /* CIL Label */ 
  case_1024: /* CIL Label */ 
#line 7342
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1556U)) {
    {
#line 7343
    opj_event_msg(p_manager, 2, "IMF 2K/2K_R profile require:\nwidth <= 2048 and height <= 1556\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7349
    ret = 0;
    }
  }
#line 7351
  goto switch_break;
  case_2048: /* CIL Label */ 
  case_1280: /* CIL Label */ 
#line 7354
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 3112U)) {
    {
#line 7355
    opj_event_msg(p_manager, 2, "IMF 4K/4K_R profile require:\nwidth <= 4096 and height <= 3112\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7361
    ret = 0;
    }
  }
#line 7363
  goto switch_break;
  case_2304: /* CIL Label */ 
  case_1536: /* CIL Label */ 
#line 7366
  if (((image->comps + 0)->w > 8192U) | ((image->comps + 0)->h > 6224U)) {
    {
#line 7367
    opj_event_msg(p_manager, 2, "IMF 8K/8K_R profile require:\nwidth <= 8192 and height <= 6224\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7373
    ret = 0;
    }
  }
#line 7375
  goto switch_break;
#line 7378
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 7381
  if (parameters->roi_compno != -1) {
    {
#line 7382
    opj_event_msg(p_manager, 2, "IMF profile forbid RGN / region of interest marker.\n-> Compression parameters specify a ROI\n-> Non-IMF codestream will be generated\n");
#line 7386
    ret = 0;
    }
  }
#line 7389
  if (parameters->cblockw_init != 32) {
    {
    {
#line 7390
    opj_event_msg(p_manager, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters->cblockw_init, parameters->cblockh_init);
    }
#line 7396
    ret = 0;
    }
  } else
#line 7389
  if (parameters->cblockh_init != 32) {
    {
    {
#line 7390
    opj_event_msg(p_manager, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters->cblockw_init, parameters->cblockh_init);
    }
#line 7396
    ret = 0;
    }
  }
#line 7399
  if ((int )parameters->prog_order != 4) {
    {
#line 7400
    opj_event_msg(p_manager, 2, "IMF profile require progression order to be CPRL.\n-> Compression parameters set it to %d.\n-> Non-IMF codestream will be generated\n",
                  (int )parameters->prog_order);
#line 7405
    ret = 0;
    }
  }
#line 7408
  if (parameters->numpocs != 0U) {
    {
#line 7409
    opj_event_msg(p_manager, 2, "IMF profile forbid POC markers.\n-> Compression parameters set %d POC.\n-> Non-IMF codestream will be generated\n",
                  parameters->numpocs);
#line 7414
    ret = 0;
    }
  }
#line 7418
  if (parameters->mode != 0) {
    {
#line 7419
    opj_event_msg(p_manager, 2, "IMF profile forbid mode switch in code block style.\n-> Compression parameters set code block style to %d.\n-> Non-IMF codestream will be generated\n",
                  parameters->mode);
#line 7424
    ret = 0;
    }
  }
#line 7427
  if ((int )profile == 1024) {
    _L___21: /* CIL Label */ 
    _L___22: /* CIL Label */ 
#line 7431
    if (parameters->irreversible != 1) {
      {
#line 7432
      opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 9-7 Irreversible Transform.\n-> Compression parameters set it to reversible.\n-> Non-IMF codestream will be generated\n");
#line 7436
      ret = 0;
      }
    }
  } else
#line 7427
  if ((int )profile == 1280) {
#line 7427
    goto _L___21;
  } else
#line 7427
  if ((int )profile == 1536) {
#line 7427
    goto _L___21;
  } else
#line 7440
  if (parameters->irreversible != 0) {
    {
#line 7441
    opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 5-3 reversible Transform.\n-> Compression parameters set it to irreversible.\n-> Non-IMF codestream will be generated\n");
#line 7445
    ret = 0;
    }
  }
#line 7450
  if (parameters->tcp_numlayers != 1) {
    {
#line 7451
    opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 1 single quality layer.\n-> Number of layers is %d.\n-> Non-IMF codestream will be generated\n",
                  parameters->tcp_numlayers);
#line 7456
    ret = 0;
    }
  }
  {
#line 7461
  if ((int )profile == 1024) {
#line 7461
    goto case_1024___0;
  }
#line 7471
  if ((int )profile == 1280) {
#line 7471
    goto case_1280___0;
  }
#line 7481
  if ((int )profile == 1536) {
#line 7481
    goto case_1536___0;
  }
#line 7491
  if ((int )profile == 1792) {
#line 7491
    goto case_1792___0;
  }
#line 7513
  if ((int )profile == 2048) {
#line 7513
    goto case_2048___0;
  }
#line 7544
  if ((int )profile == 2304) {
#line 7544
    goto case_2304___0;
  }
#line 7584
  goto switch_default;
  case_1024___0: /* CIL Label */ 
#line 7462
  if (! (NL >= 1 && NL <= 5)) {
    {
#line 7463
    opj_event_msg(p_manager, 2, "IMF 2K profile requires 1 <= NL <= 5:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7468
    ret = 0;
    }
  }
#line 7470
  goto switch_break___0;
  case_1280___0: /* CIL Label */ 
#line 7472
  if (! (NL >= 1 && NL <= 6)) {
    {
#line 7473
    opj_event_msg(p_manager, 2, "IMF 4K profile requires 1 <= NL <= 6:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7478
    ret = 0;
    }
  }
#line 7480
  goto switch_break___0;
  case_1536___0: /* CIL Label */ 
#line 7482
  if (! (NL >= 1 && NL <= 7)) {
    {
#line 7483
    opj_event_msg(p_manager, 2, "IMF 8K profile requires 1 <= NL <= 7:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7488
    ret = 0;
    }
  }
#line 7490
  goto switch_break___0;
  case_1792___0: /* CIL Label */ 
#line 7492
  if (XTsiz >= 2048U) {
#line 7493
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7494
      opj_event_msg(p_manager, 2, "IMF 2K_R profile requires 1 <= NL <= 5 for XTsiz >= 2048:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7499
      ret = 0;
      }
    }
  } else
#line 7501
  if (XTsiz >= 1024U) {
#line 7502
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7503
      opj_event_msg(p_manager, 2, "IMF 2K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7508
      ret = 0;
      }
    }
  }
#line 7511
  goto switch_break___0;
  case_2048___0: /* CIL Label */ 
#line 7514
  if (XTsiz >= 4096U) {
#line 7515
    if (! (NL >= 1 && NL <= 6)) {
      {
#line 7516
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz >= 4096:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7521
      ret = 0;
      }
    }
  } else
#line 7523
  if (XTsiz >= 2048U) {
#line 7524
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7525
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7530
      ret = 0;
      }
    }
  } else
#line 7532
  if (XTsiz >= 1024U) {
#line 7533
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7534
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7539
      ret = 0;
      }
    }
  }
#line 7542
  goto switch_break___0;
  case_2304___0: /* CIL Label */ 
#line 7545
  if (XTsiz >= 8192U) {
#line 7546
    if (! (NL >= 1 && NL <= 7)) {
      {
#line 7547
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 7 for XTsiz >= 8192:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7552
      ret = 0;
      }
    }
  } else
#line 7554
  if (XTsiz >= 4096U) {
#line 7555
    if (! (NL >= 1 && NL <= 6)) {
      {
#line 7556
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz in [4096,8192[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7561
      ret = 0;
      }
    }
  } else
#line 7563
  if (XTsiz >= 2048U) {
#line 7564
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7565
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7570
      ret = 0;
      }
    }
  } else
#line 7572
  if (XTsiz >= 1024U) {
#line 7573
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7574
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7579
      ret = 0;
      }
    }
  }
#line 7582
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 7585
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 7588
  if (parameters->numresolution == 1) {
#line 7589
    if (parameters->res_spec != 1) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    } else
#line 7589
    if (parameters->prcw_init[0] != 128) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    } else
#line 7589
    if (parameters->prch_init[0] != 128) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    }
  } else {
#line 7600
    i___23 = 0;
    {
#line 7600
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7600
      if (! (i___23 < parameters->res_spec)) {
#line 7600
        goto while_break___1;
      }
#line 7601
      if (parameters->prcw_init[i___23] != 256) {
        {
        {
#line 7603
        opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
        }
#line 7607
        ret = 0;
        }
      } else
#line 7601
      if (parameters->prch_init[i___23] != 256) {
        {
        {
#line 7603
        opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
        }
#line 7607
        ret = 0;
        }
      }
#line 7600
      i___23 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 7612
  return (ret);
}
}
#line 7616 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_UINT32 cblkw ;
  OPJ_UINT32 cblkh ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 rate_i_corr ;
  OPJ_FLOAT32 rate_i_m_1_corr ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp20 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;
  size_t array_size ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void *__cil_tmp29 ;
  char const   comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp32 ;
  char const   *version ;
  char const   *__cil_tmp34 ;
  size_t cp_comment_buf_size ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 __cil_tmp39 ;
  void *__cil_tmp40 ;
  opj_tcp_t *tcp ;
  OPJ_BOOL fixed_distoratio ;
  OPJ_UINT32 __cil_tmp43 ;
  opj_poc_t *tcp_poc ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  void *__cil_tmp48 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp51 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  OPJ_BOOL __cil_tmp55 ;
  void *__cil_tmp56 ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_BOOL __cil_tmp59 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  OPJ_UINT32 __cil_tmp62 ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp70 ;
  OPJ_INT32 __cil_tmp71 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_INT32 __cil_tmp76 ;
  OPJ_INT32 __cil_tmp77 ;
  OPJ_INT32 __cil_tmp78 ;
  OPJ_UINT32 __cil_tmp79 ;
  OPJ_UINT32 __cil_tmp80 ;
  OPJ_UINT32 __cil_tmp81 ;

  {
#line 7622
  cp = (opj_cp_t *)0;
#line 7625
  if (! p_j2k) {
#line 7626
    return (0);
  } else
#line 7625
  if (! parameters) {
#line 7626
    return (0);
  } else
#line 7625
  if (! image) {
#line 7626
    return (0);
  }
#line 7629
  if (parameters->numresolution <= 0) {
    {
    {
#line 7631
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 7634
    return (0);
  } else
#line 7629
  if (parameters->numresolution > 33) {
    {
    {
#line 7631
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 7634
    return (0);
  }
#line 7637
  if (parameters->cblockw_init < 4) {
    {
    {
#line 7638
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
    }
#line 7641
    return (0);
  } else
#line 7637
  if (parameters->cblockw_init > 1024) {
    {
    {
#line 7638
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
    }
#line 7641
    return (0);
  }
#line 7643
  if (parameters->cblockh_init < 4) {
    {
    {
#line 7644
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
    }
#line 7647
    return (0);
  } else
#line 7643
  if (parameters->cblockh_init > 1024) {
    {
    {
#line 7644
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
    }
#line 7647
    return (0);
  }
#line 7649
  if (parameters->cblockw_init * parameters->cblockh_init > 4096) {
    {
#line 7650
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init * cblockh_init: should be <= 4096\n");
    }
#line 7652
    return (0);
  }
  {
#line 7654
  __cil_tmp12 = opj_int_floorlog2(parameters->cblockw_init);
#line 7654
  cblkw = (OPJ_UINT32 )__cil_tmp12;
#line 7655
  __cil_tmp13 = opj_int_floorlog2(parameters->cblockh_init);
#line 7655
  cblkh = (OPJ_UINT32 )__cil_tmp13;
  }
#line 7656
  if (parameters->cblockw_init != 1 << cblkw) {
    {
#line 7657
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
#line 7660
    return (0);
  }
#line 7662
  if (parameters->cblockh_init != 1 << cblkh) {
    {
#line 7663
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockh_init);
    }
#line 7666
    return (0);
  }
#line 7669
  if (parameters->cp_fixed_alloc) {
#line 7670
    if (parameters->cp_matrice == (void *)0) {
      {
#line 7671
      opj_event_msg(p_manager, 1, "cp_fixed_alloc set, but cp_matrice missing\n");
      }
#line 7673
      return (0);
    }
#line 7676
    if (parameters->tcp_numlayers > 10) {
      {
#line 7677
      opj_event_msg(p_manager, 1, "tcp_numlayers when cp_fixed_alloc set should not exceed %d\n~EV",
                    10);
      }
#line 7680
      return (0);
    }
#line 7682
    if (parameters->numresolution > 10) {
      {
#line 7683
      opj_event_msg(p_manager, 1, "numresolution when cp_fixed_alloc set should not exceed %d\n~EV",
                    10);
      }
#line 7686
      return (0);
    }
  }
#line 7690
  p_j2k->m_specific_param.m_encoder.m_nb_comps = image->numcomps;
#line 7693
  cp = & p_j2k->m_cp;
#line 7696
  cp->tw = (OPJ_UINT32 )1;
#line 7697
  cp->th = (OPJ_UINT32 )1;
#line 7700
  if ((int )parameters->rsiz == 0) {
#line 7702
    deprecated_used = 0;
    {
#line 7704
    if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 7704
      goto case_1;
    }
#line 7710
    if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 7710
      goto case_2;
    }
#line 7716
    if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 7716
      goto case_3;
    }
#line 7723
    goto switch_default;
    case_1: /* CIL Label */ 
#line 7705
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7706
    parameters->max_cs_size = 1302083;
#line 7707
    parameters->max_comp_size = 1041666;
#line 7708
    deprecated_used = 1;
#line 7709
    goto switch_break;
    case_2: /* CIL Label */ 
#line 7711
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7712
    parameters->max_cs_size = 651041;
#line 7713
    parameters->max_comp_size = 520833;
#line 7714
    deprecated_used = 1;
#line 7715
    goto switch_break;
    case_3: /* CIL Label */ 
#line 7717
    parameters->rsiz = (OPJ_UINT16 )4;
#line 7718
    parameters->max_cs_size = 1302083;
#line 7719
    parameters->max_comp_size = 1041666;
#line 7720
    deprecated_used = 1;
#line 7721
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 7724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 7727
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )3) {
#line 7727
      goto case_3___0;
    }
#line 7731
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )4) {
#line 7731
      goto case_4;
    }
#line 7735
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )33024) {
#line 7735
      goto case_33024;
    }
#line 7739
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 7728
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7729
    deprecated_used = 1;
#line 7730
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 7732
    parameters->rsiz = (OPJ_UINT16 )4;
#line 7733
    deprecated_used = 1;
#line 7734
    goto switch_break___0;
    case_33024: /* CIL Label */ 
#line 7736
    parameters->rsiz = (OPJ_UINT16 )33024;
#line 7737
    deprecated_used = 1;
    switch_default___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 7740
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 7742
    if (deprecated_used) {
      {
#line 7743
      opj_event_msg(p_manager, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 7751
  if (parameters->tcp_numlayers == 0) {
#line 7752
    parameters->tcp_numlayers = 1;
#line 7753
    parameters->cp_disto_alloc = 1;
#line 7754
    parameters->tcp_rates[0] = (float )0;
  }
#line 7757
  if (parameters->cp_disto_alloc) {
#line 7759
    i = (OPJ_UINT32 )1;
    {
#line 7759
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7759
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7759
        goto while_break;
      }
#line 7760
      rate_i_corr = parameters->tcp_rates[i];
#line 7761
      rate_i_m_1_corr = parameters->tcp_rates[i - 1U];
#line 7762
      if ((double )rate_i_corr <= 1.) {
#line 7763
        rate_i_corr = (OPJ_FLOAT32 )1.;
      }
#line 7765
      if ((double )rate_i_m_1_corr <= 1.) {
#line 7766
        rate_i_m_1_corr = (OPJ_FLOAT32 )1.;
      }
#line 7768
      if (rate_i_corr >= rate_i_m_1_corr) {
#line 7769
        if (rate_i_corr != parameters->tcp_rates[i]) {
#line 7769
          if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
            {
#line 7771
            opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n\202\202~EV",
                          i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                          i - 1U, (double )parameters->tcp_rates[i - 1U], (double )rate_i_m_1_corr);
            }
          } else {
#line 7769
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 7776
        if (rate_i_corr != parameters->tcp_rates[i]) {
          {
#line 7777
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f\n",
                        i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                        i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        } else
#line 7782
        if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
          {
#line 7783
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U],
                        (double )rate_i_m_1_corr);
          }
        } else {
          {
#line 7789
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f\nV",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        }
      }
#line 7759
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 7797
  if (parameters->cp_fixed_quality) {
#line 7799
    i = (OPJ_UINT32 )1;
    {
#line 7799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7799
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7799
        goto while_break___0;
      }
#line 7800
      if (parameters->tcp_distoratio[i] < parameters->tcp_distoratio[i - 1U]) {
#line 7800
        if (! (i == (OPJ_UINT32 )parameters->tcp_numlayers - 1U && parameters->tcp_distoratio[i] == (float )0)) {
          {
#line 7803
          opj_event_msg(p_manager, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                        i, (double )parameters->tcp_distoratio[i], i - 1U, (double )parameters->tcp_distoratio[i - 1U]);
          }
        }
      }
#line 7799
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7813
  if (parameters->max_cs_size <= 0) {
#line 7814
    if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > (float )0) {
#line 7816
      temp_size = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->tcp_rates[parameters->tcp_numlayers - 1] * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 7820
      if (temp_size > (float )2147483647) {
#line 7821
        parameters->max_cs_size = 2147483647;
      } else {
        {
#line 7823
        __cil_tmp20 = floor((double )temp_size);
#line 7823
        parameters->max_cs_size = (int )__cil_tmp20;
        }
      }
    } else {
#line 7826
      parameters->max_cs_size = 0;
    }
  } else {
#line 7830
    cap = 0;
#line 7832
    if ((int )parameters->rsiz >= 1024) {
#line 7832
      if ((int )parameters->rsiz <= 2459) {
#line 7832
        if (parameters->max_cs_size > 0) {
#line 7832
          if (parameters->tcp_numlayers == 1) {
#line 7832
            if (parameters->tcp_rates[0] == (float )0) {
#line 7834
              parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
            }
          }
        }
      }
    }
#line 7840
    temp_rate = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->max_cs_size * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 7844
    i = (OPJ_UINT32 )0;
    {
#line 7844
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7844
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7844
        goto while_break___1;
      }
#line 7845
      if (parameters->tcp_rates[i] < temp_rate) {
#line 7846
        parameters->tcp_rates[i] = temp_rate;
#line 7847
        cap = 1;
      }
#line 7844
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7850
    if (cap) {
      {
#line 7851
      opj_event_msg(p_manager, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 7857
  if ((int )parameters->rsiz >= 3) {
#line 7857
    if ((int )parameters->rsiz <= 6) {
#line 7858
      p_j2k->m_specific_param.m_encoder.m_TLM = 1;
    } else {
#line 7857
      goto _L___24;
    }
  } else
  _L___24: /* CIL Label */ 
#line 7857
  if ((int )parameters->rsiz >= 1024) {
#line 7857
    if ((int )parameters->rsiz <= 2459) {
#line 7858
      p_j2k->m_specific_param.m_encoder.m_TLM = 1;
    }
  }
#line 7863
  if ((int )parameters->rsiz >= 3) {
#line 7863
    if ((int )parameters->rsiz <= 6) {
#line 7864
      if ((int )parameters->rsiz == 5) {
        {
        {
#line 7866
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 7868
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 7864
      if ((int )parameters->rsiz == 6) {
        {
        {
#line 7866
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 7868
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 7870
        opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 7871
        __cil_tmp24 = opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager);
        }
#line 7871
        if (! __cil_tmp24) {
#line 7872
          parameters->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 7863
      goto _L___27;
    }
  } else
  _L___27: /* CIL Label */ 
#line 7875
  if ((int )parameters->rsiz == 7) {
    {
#line 7876
    opj_event_msg(p_manager, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 7878
    parameters->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 7879
  if ((int )parameters->rsiz >= 256) {
#line 7879
    if ((int )parameters->rsiz <= 779) {
      {
#line 7880
      opj_event_msg(p_manager, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 7882
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7879
      goto _L___26;
    }
  } else
  _L___26: /* CIL Label */ 
#line 7883
  if ((int )parameters->rsiz >= 1024) {
#line 7883
    if ((int )parameters->rsiz <= 2459) {
      {
#line 7884
      opj_j2k_set_imf_parameters(parameters, image, p_manager);
#line 7885
      __cil_tmp25 = opj_j2k_is_imf_compliant(parameters, image, p_manager);
      }
#line 7885
      if (! __cil_tmp25) {
#line 7886
        parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7883
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 7888
  if ((int )parameters->rsiz & 32768) {
#line 7889
    if ((int )parameters->rsiz == 32768) {
      {
#line 7890
      opj_event_msg(p_manager, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 7894
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 7895
    if ((int )parameters->rsiz != 33024) {
      {
#line 7896
      opj_event_msg(p_manager, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 7899
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 7906
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 7908
  cp->rsiz = parameters->rsiz;
#line 7909
  if (parameters->cp_fixed_alloc) {
#line 7910
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )2;
  } else
#line 7911
  if (parameters->cp_fixed_quality) {
#line 7912
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )1;
  } else {
#line 7915
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )0;
  }
#line 7919
  if (parameters->cp_fixed_alloc) {
    {
#line 7920
    array_size = (((size_t )parameters->tcp_numlayers * (size_t )parameters->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 7922
    __cil_tmp27 = opj_malloc(array_size);
#line 7922
    cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp27;
    }
#line 7923
    if (! cp->m_specific_param.m_enc.m_matrice) {
      {
#line 7924
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
      }
#line 7926
      return (0);
    }
    {
#line 7928
    memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);
    }
  }
#line 7933
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 7934
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 7937
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 7938
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 7941
  if (parameters->cp_comment) {
    {
#line 7942
    __cil_tmp28 = strlen((char const   *)parameters->cp_comment);
#line 7942
    __cil_tmp29 = opj_malloc(__cil_tmp28 + 1UL);
#line 7942
    cp->comment = (char *)__cil_tmp29;
    }
#line 7943
    if (! cp->comment) {
      {
#line 7944
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 7946
      return (0);
    }
    {
#line 7948
    strcpy(cp->comment, (char const   *)parameters->cp_comment);
    }
  } else {
    {
#line 7951
    comment = "Created by OpenJPEG version EV";
#line 7952
    __cil_tmp32 = strlen((char const   *)comment);
#line 7952
    clen = __cil_tmp32;
#line 7953
    __cil_tmp34 = opj_version();
#line 7953
    version = __cil_tmp34;
#line 7967
    __cil_tmp36 = strlen(version);
#line 7967
    cp_comment_buf_size = (clen + __cil_tmp36) + 1UL;
#line 7968
    __cil_tmp37 = opj_malloc(cp_comment_buf_size);
#line 7968
    cp->comment = (char *)__cil_tmp37;
    }
#line 7969
    if (! cp->comment) {
      {
#line 7970
      opj_event_msg(p_manager, 1, "Not enough memory to allocate comment string\n");
      }
#line 7972
      return (0);
    }
    {
#line 7974
    snprintf(cp->comment, cp_comment_buf_size, "%s%sEV", (char const   *)comment,
             version);
    }
  }
#line 7983
  if (parameters->tile_size_on) {
#line 7984
    if (cp->tdx == 0U) {
      {
#line 7985
      opj_event_msg(p_manager, 1, "Invalid tile width\n~EV");
      }
#line 7986
      return (0);
    }
#line 7988
    if (cp->tdy == 0U) {
      {
#line 7989
      opj_event_msg(p_manager, 1, "Invalid tile height\nEV");
      }
#line 7990
      return (0);
    }
    {
#line 7992
    __cil_tmp38 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 7992
    cp->tw = (OPJ_UINT32 )__cil_tmp38;
#line 7994
    __cil_tmp39 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 7994
    cp->th = (OPJ_UINT32 )__cil_tmp39;
    }
#line 7997
    if (cp->tw > 65535U / cp->th) {
      {
#line 7998
      opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n\202~EV",
                    cp->tw, cp->th);
      }
#line 8001
      return (0);
    }
  } else {
#line 8004
    cp->tdx = image->x1 - cp->tx0;
#line 8005
    cp->tdy = image->y1 - cp->ty0;
  }
#line 8008
  if (parameters->tp_on) {
#line 8009
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 8010
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_BITFIELD )1;
  }
  {
#line 8071
  __cil_tmp40 = opj_calloc((size_t )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 8071
  cp->tcps = (opj_tcp_t *)__cil_tmp40;
  }
#line 8072
  if (! cp->tcps) {
    {
#line 8073
    opj_event_msg(p_manager, 1, "Not enough memory to allocate tile coding parameters\n");
    }
#line 8075
    return (0);
  }
#line 8078
  tileno = (OPJ_UINT32 )0;
  {
#line 8078
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8078
    if (! (tileno < cp->tw * cp->th)) {
#line 8078
      goto while_break___2;
    }
#line 8079
    tcp = cp->tcps + tileno;
#line 8080
    fixed_distoratio = (unsigned int )cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 1U;
#line 8083
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 8085
    j = (OPJ_UINT32 )0;
    {
#line 8085
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 8085
      if (! (j < tcp->numlayers)) {
#line 8085
        goto while_break___3;
      }
#line 8086
      if ((int )cp->rsiz >= 3) {
#line 8086
        if ((int )cp->rsiz <= 6) {
          _L___28: /* CIL Label */ 
#line 8087
          if (fixed_distoratio) {
#line 8088
            tcp->distoratio[j] = parameters->tcp_distoratio[j];
          }
#line 8090
          tcp->rates[j] = parameters->tcp_rates[j];
        } else {
#line 8086
          goto _L___30;
        }
      } else
      _L___30: /* CIL Label */ 
#line 8086
      if ((int )cp->rsiz >= 1024) {
#line 8086
        if ((int )cp->rsiz <= 2459) {
#line 8086
          goto _L___28;
        } else {
#line 8086
          goto _L___29;
        }
      } else
      _L___29: /* CIL Label */ 
#line 8092
      if (fixed_distoratio) {
#line 8093
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 8095
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 8098
      if (! fixed_distoratio) {
#line 8098
        if ((double )tcp->rates[j] <= 1.) {
#line 8100
          tcp->rates[j] = (OPJ_FLOAT32 )0.;
        }
      }
#line 8085
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 8104
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 8105
    tcp->prg = parameters->prog_order;
#line 8106
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 8108
    numpocs_tile = (OPJ_UINT32 )0;
#line 8109
    tcp->POC = (OPJ_BITFIELD )0;
#line 8111
    if (parameters->numpocs) {
#line 8113
      i = (OPJ_UINT32 )0;
      {
#line 8113
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 8113
        if (! (i < parameters->numpocs)) {
#line 8113
          goto while_break___4;
        }
#line 8114
        if (tileno + 1U == parameters->POC[i].tile) {
#line 8115
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 8117
          if (parameters->POC[numpocs_tile].compno0 >= image->numcomps) {
            {
#line 8118
            opj_event_msg(p_manager, 1, "Invalid compno0 for POC %d\n", i);
            }
#line 8120
            return (0);
          }
          {
#line 8123
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 8124
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 8125
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 8126
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 8127
          tcp_poc->compno1 = opj_uint_min(parameters->POC[numpocs_tile].compno1, image->numcomps);
#line 8129
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 8130
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 8132
          numpocs_tile ++;
          }
        }
#line 8113
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 8136
      if (numpocs_tile) {
        {
#line 8139
        opj_j2k_check_poc_val((opj_poc_t *)parameters->POC, tileno, parameters->numpocs,
                              (OPJ_UINT32 )parameters->numresolution, image->numcomps,
                              (OPJ_UINT32 )parameters->tcp_numlayers, p_manager);
#line 8143
        tcp->POC = (OPJ_BITFIELD )1;
#line 8144
        tcp->numpocs = numpocs_tile - 1U;
        }
      }
    } else {
#line 8147
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 8150
    __cil_tmp48 = opj_calloc((size_t )image->numcomps, sizeof(opj_tccp_t ));
#line 8150
    tcp->tccps = (opj_tccp_t *)__cil_tmp48;
    }
#line 8151
    if (! tcp->tccps) {
      {
#line 8152
      opj_event_msg(p_manager, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 8154
      return (0);
    }
#line 8156
    if (parameters->mct_data) {
      {
#line 8158
      lMctSize = (image->numcomps * image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 8160
      __cil_tmp51 = opj_malloc((size_t )lMctSize);
#line 8160
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp51;
#line 8161
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
      }
#line 8164
      if (! lTmpBuf) {
        {
#line 8165
        opj_event_msg(p_manager, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 8167
        return (0);
      }
      {
#line 8170
      tcp->mct = (OPJ_UINT32 )2;
#line 8171
      __cil_tmp53 = opj_malloc((size_t )lMctSize);
#line 8171
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp53;
      }
#line 8172
      if (! tcp->m_mct_coding_matrix) {
        {
#line 8173
        opj_free(lTmpBuf);
#line 8174
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8175
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 8177
        return (0);
      }
      {
#line 8179
      memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, (unsigned long )lMctSize);
#line 8180
      memcpy(lTmpBuf, parameters->mct_data, (unsigned long )lMctSize);
#line 8182
      __cil_tmp54 = opj_malloc((size_t )lMctSize);
#line 8182
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp54;
      }
#line 8183
      if (! tcp->m_mct_decoding_matrix) {
        {
#line 8184
        opj_free(lTmpBuf);
#line 8185
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8186
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 8188
        return (0);
      }
      {
#line 8190
      __cil_tmp55 = opj_matrix_inversion_f(lTmpBuf, tcp->m_mct_decoding_matrix, image->numcomps);
      }
#line 8190
      if (__cil_tmp55 == 0) {
        {
#line 8192
        opj_free(lTmpBuf);
#line 8193
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8194
        opj_event_msg(p_manager, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 8196
        return (0);
      }
      {
#line 8199
      __cil_tmp56 = opj_malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 8199
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp56;
      }
#line 8201
      if (! tcp->mct_norms) {
        {
#line 8202
        opj_free(lTmpBuf);
#line 8203
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8204
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 8206
        return (0);
      }
      {
#line 8208
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 8210
      opj_free(lTmpBuf);
#line 8212
      i = (OPJ_UINT32 )0;
      }
      {
#line 8212
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 8212
        if (! (i < image->numcomps)) {
#line 8212
          goto while_break___5;
        }
#line 8213
        tccp = tcp->tccps + i;
#line 8214
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 8212
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 8217
      __cil_tmp59 = opj_j2k_setup_mct_encoding(tcp, image);
      }
#line 8217
      if (__cil_tmp59 == 0) {
        {
#line 8219
        opj_event_msg(p_manager, 1, "Failed to setup j2k mct encoding\n");
        }
#line 8220
        return (0);
      }
    } else {
#line 8223
      if (tcp->mct == 1U) {
#line 8223
        if (image->numcomps >= 3U) {
#line 8224
          if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 8233
      i = (OPJ_UINT32 )0;
      {
#line 8233
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 8233
        if (! (i < image->numcomps)) {
#line 8233
          goto while_break___6;
        }
#line 8234
        tccp___0 = tcp->tccps + i;
#line 8235
        l_comp = image->comps + i;
#line 8237
        if (! l_comp->sgnd) {
#line 8238
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 8233
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 8243
    i = (OPJ_UINT32 )0;
    {
#line 8243
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 8243
      if (! (i < image->numcomps)) {
#line 8243
        goto while_break___7;
      }
      {
#line 8244
      tccp___1 = tcp->tccps + i;
#line 8246
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 8248
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 8249
      __cil_tmp64 = opj_int_floorlog2(parameters->cblockw_init);
#line 8249
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp64;
#line 8250
      __cil_tmp65 = opj_int_floorlog2(parameters->cblockh_init);
#line 8250
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp65;
#line 8251
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 8252
      if (parameters->irreversible) {
#line 8252
        tmp = 0;
      } else {
#line 8252
        tmp = 1;
      }
#line 8252
      tccp___1->qmfbid = (OPJ_UINT32 )tmp;
#line 8253
      if (parameters->irreversible) {
#line 8253
        tmp___0 = 2;
      } else {
#line 8253
        tmp___0 = 0;
      }
#line 8253
      tccp___1->qntsty = (OPJ_UINT32 )tmp___0;
#line 8255
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 8257
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 8258
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 8260
        tccp___1->roishift = 0;
      }
#line 8263
      if (parameters->csty & 1) {
#line 8264
        p = 0;
#line 8266
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 8266
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 8266
          if (! (it_res >= 0)) {
#line 8266
            goto while_break___8;
          }
#line 8267
          if (p < parameters->res_spec) {
#line 8269
            if (parameters->prcw_init[p] < 1) {
#line 8270
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8272
              __cil_tmp70 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 8272
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp70;
              }
            }
#line 8275
            if (parameters->prch_init[p] < 1) {
#line 8276
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8278
              __cil_tmp71 = opj_int_floorlog2(parameters->prch_init[p]);
#line 8278
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp71;
              }
            }
          } else {
#line 8282
            res_spec = parameters->res_spec;
#line 8283
            size_prcw = 0;
#line 8284
            size_prch = 0;
#line 8287
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8288
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8291
            if (size_prcw < 1) {
#line 8292
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8294
              __cil_tmp75 = opj_int_floorlog2(size_prcw);
#line 8294
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp75;
              }
            }
#line 8297
            if (size_prch < 1) {
#line 8298
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8300
              __cil_tmp76 = opj_int_floorlog2(size_prch);
#line 8300
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp76;
              }
            }
          }
#line 8303
          p ++;
#line 8266
          __cil_tmp78 = it_res;
#line 8266
          it_res --;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
#line 8307
        j = (OPJ_UINT32 )0;
        {
#line 8307
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 8307
          if (! (j < tccp___1->numresolutions)) {
#line 8307
            goto while_break___9;
          }
#line 8308
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 8309
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 8307
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      {
#line 8313
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
      }
#line 8243
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 8078
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 8317
  if (parameters->mct_data) {
    {
#line 8318
    opj_free(parameters->mct_data);
#line 8319
    parameters->mct_data = (void *)0;
    }
  }
#line 8321
  return (1);
}
}
#line 8324 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 8330
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 8332
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 8334
    __cil_tmp6 = opj_realloc(cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 8334
    new_marker = (opj_marker_info_t *)__cil_tmp6;
    }
#line 8336
    if (! new_marker) {
      {
#line 8337
      opj_free(cstr_index->marker);
#line 8338
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 8339
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 8340
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 8342
      return (0);
    }
#line 8344
    cstr_index->marker = new_marker;
  }
#line 8348
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 8349
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 8350
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 8351
  (cstr_index->marknum) ++;
#line 8352
  return (1);
}
}
#line 8355 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 8363
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 8366
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum);
#line 8368
    __cil_tmp7 = opj_realloc((cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 8368
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 8371
    if (! new_marker) {
      {
#line 8372
      opj_free((cstr_index->tile_index + tileno)->marker);
#line 8373
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 8374
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 8375
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 8377
      return (0);
    }
#line 8379
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 8383
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 8385
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 8387
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 8389
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 8391
  if (type == 65424U) {
#line 8392
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 8394
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 8395
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 8399
  return (1);
}
}
#line 8408 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8416
  return (1);
}
}
#line 8419 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  opj_image_t *__cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  opj_image_t *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 8430
  p_j2k->m_private_image = opj_image_create0();
  }
#line 8431
  if (! p_j2k->m_private_image) {
#line 8432
    return (0);
  }
  {
#line 8436
  __cil_tmp6 = opj_j2k_setup_decoding_validation(p_j2k, p_manager);
  }
#line 8436
  if (! __cil_tmp6) {
    {
#line 8437
    opj_image_destroy(p_j2k->m_private_image);
#line 8438
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8439
    return (0);
  }
  {
#line 8443
  __cil_tmp7 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 8443
  if (! __cil_tmp7) {
    {
#line 8444
    opj_image_destroy(p_j2k->m_private_image);
#line 8445
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8446
    return (0);
  }
  {
#line 8450
  __cil_tmp8 = opj_j2k_setup_header_reading(p_j2k, p_manager);
  }
#line 8450
  if (! __cil_tmp8) {
    {
#line 8451
    opj_image_destroy(p_j2k->m_private_image);
#line 8452
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8453
    return (0);
  }
  {
#line 8457
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 8457
  if (! __cil_tmp9) {
    {
#line 8458
    opj_image_destroy(p_j2k->m_private_image);
#line 8459
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8460
    return (0);
  }
  {
#line 8463
  *p_image = opj_image_create0();
  }
#line 8464
  if (! *p_image) {
#line 8465
    return (0);
  }
  {
#line 8469
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 8472
  __cil_tmp11 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 8472
  if (! __cil_tmp11) {
    {
#line 8473
    opj_image_destroy(*p_image);
#line 8474
    *p_image = (opj_image_t *)((void *)0);
    }
#line 8475
    return (0);
  }
#line 8478
  return (1);
}
}
#line 8481 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 8488
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_read_header_procedure),
                                                p_manager);
  }
#line 8488
  if (! __cil_tmp3) {
#line 8490
    return (0);
  }
  {
#line 8494
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_copy_default_tcp_and_create_tcd),
                                                p_manager);
  }
#line 8494
  if (! __cil_tmp4) {
#line 8496
    return (0);
  }
#line 8499
  return (1);
}
}
#line 8502 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 8509
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_decoder),
                                                p_manager);
  }
#line 8509
  if (! __cil_tmp3) {
#line 8511
    return (0);
  }
  {
#line 8513
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_decoding_validation),
                                                p_manager);
  }
#line 8513
  if (! __cil_tmp4) {
#line 8515
    return (0);
  }
#line 8519
  return (1);
}
}
#line 8522 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8526
  l_is_valid = 1;
#line 8537
  if (((int )p_j2k->m_cp.rsiz & 33280) == 33280) {
#line 8538
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 8539
    l_tcp = p_j2k->m_cp.tcps;
#line 8541
    i = (OPJ_UINT32 )0;
    {
#line 8541
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8541
      if (! (i < l_nb_tiles)) {
#line 8541
        goto while_break;
      }
#line 8542
      if (l_tcp->mct == 2U) {
#line 8543
        l_tccp = l_tcp->tccps;
#line 8544
        l_is_valid &= l_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0;
#line 8546
        j = (OPJ_UINT32 )0;
        {
#line 8546
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 8546
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 8546
            goto while_break___0;
          }
#line 8547
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 8548
          l_tccp ++;
#line 8546
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 8551
      l_tcp ++;
#line 8541
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 8555
  return (l_is_valid);
}
}
#line 8558 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  void *__cil_tmp16 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;

  {
#line 8561
  l_indix = (OPJ_UINT32 )1;
#line 8562
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 8562
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 8571
  if (p_tcp->mct != 2U) {
#line 8572
    return (1);
  }
#line 8575
  if (p_tcp->m_mct_decoding_matrix) {
#line 8576
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 8578
      p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 8580
      __cil_tmp14 = opj_realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8580
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 8582
      if (! new_mct_records) {
        {
#line 8583
        opj_free(p_tcp->m_mct_records);
#line 8584
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8585
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8586
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 8588
        return (0);
      }
      {
#line 8590
      p_tcp->m_mct_records = new_mct_records;
#line 8591
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8593
      memset(l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 8597
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8599
    if (l_mct_deco_data->m_data) {
      {
#line 8600
      opj_free(l_mct_deco_data->m_data);
#line 8601
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 8604
    __cil_tmp15 = l_indix;
#line 8604
    l_indix ++;
#line 8604
    l_mct_deco_data->m_index = __cil_tmp15;
#line 8605
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 8606
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8607
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 8608
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 8609
    __cil_tmp16 = opj_malloc((size_t )l_mct_size);
#line 8609
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp16;
    }
#line 8611
    if (! l_mct_deco_data->m_data) {
#line 8612
      return (0);
    }
    {
#line 8615
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))(p_tcp->m_mct_decoding_matrix,
                                                                             l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 8618
    l_mct_deco_data->m_data_size = l_mct_size;
#line 8619
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 8622
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 8624
    p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 8625
    __cil_tmp18 = opj_realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8625
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp18;
    }
#line 8627
    if (! new_mct_records___0) {
      {
#line 8628
      opj_free(p_tcp->m_mct_records);
#line 8629
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8630
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8631
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 8633
      return (0);
    }
    {
#line 8635
    p_tcp->m_mct_records = new_mct_records___0;
#line 8636
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8638
    memset(l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 8642
    if (l_mct_deco_data) {
#line 8643
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 8647
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8649
  if (l_mct_offset_data->m_data) {
    {
#line 8650
    opj_free(l_mct_offset_data->m_data);
#line 8651
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 8654
  __cil_tmp19 = l_indix;
#line 8654
  l_indix ++;
#line 8654
  l_mct_offset_data->m_index = __cil_tmp19;
#line 8655
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 8656
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8657
  l_nb_elem = p_image->numcomps;
#line 8658
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 8659
  __cil_tmp20 = opj_malloc((size_t )l_mct_size);
#line 8659
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp20;
  }
#line 8661
  if (! l_mct_offset_data->m_data) {
#line 8662
    return (0);
  }
  {
#line 8665
  __cil_tmp21 = opj_malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 8665
  l_data = (OPJ_FLOAT32 *)__cil_tmp21;
  }
#line 8666
  if (! l_data) {
    {
#line 8667
    opj_free(l_mct_offset_data->m_data);
#line 8668
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 8669
    return (0);
  }
#line 8672
  l_tccp = p_tcp->tccps;
#line 8673
  l_current_data = l_data;
#line 8675
  i = (OPJ_UINT32 )0;
  {
#line 8675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8675
    if (! (i < l_nb_elem)) {
#line 8675
      goto while_break;
    }
#line 8676
    __cil_tmp22 = l_current_data;
#line 8676
    l_current_data ++;
#line 8676
    *__cil_tmp22 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 8677
    l_tccp ++;
#line 8675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8680
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))(l_data,
                                                                             l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 8683
  opj_free(l_data);
#line 8685
  l_mct_offset_data->m_data_size = l_mct_size;
#line 8687
  (p_tcp->m_nb_mct_records) ++;
  }
#line 8689
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 8691
    p_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 8692
    __cil_tmp24 = opj_realloc(p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 8692
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp24;
    }
#line 8695
    if (! new_mcc_records) {
      {
#line 8696
      opj_free(p_tcp->m_mcc_records);
#line 8697
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 8698
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8699
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 8701
      return (0);
    }
    {
#line 8703
    p_tcp->m_mcc_records = new_mcc_records;
#line 8704
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 8705
    memset(l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 8710
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 8711
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 8712
  l_mcc_data->m_is_irreversible = (OPJ_BITFIELD )1;
#line 8713
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 8714
  __cil_tmp25 = l_indix;
#line 8714
  l_indix ++;
#line 8714
  l_mcc_data->m_index = __cil_tmp25;
#line 8715
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 8716
  (p_tcp->m_nb_mcc_records) ++;
#line 8718
  return (1);
}
}
#line 8721 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8730
  return (1);
}
}
#line 8733 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8742
  return (1);
}
}
#line 8745 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 8749
  l_is_valid = 1;
#line 8760
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 8764
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 8766
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 8771
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
    {
#line 8773
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 8775
    return (0);
  } else
#line 8771
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions > 32U) {
    {
    {
#line 8773
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 8775
    return (0);
  }
#line 8778
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8780
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 8782
    return (0);
  }
#line 8785
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8787
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nV");
    }
#line 8789
    return (0);
  }
#line 8793
  return (l_is_valid);
}
}
#line 8796 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 8801
  l_is_valid = 1;
#line 8816
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 8821
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 8823
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 8826
  return (l_is_valid);
}
}
#line 8829 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;
  struct opj_dec_memory_marker_handler *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  struct opj_dec_memory_marker_handler *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_SIZE_T __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_OFF_T __cil_tmp24 ;

  {
  {
#line 8835
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 8836
  l_has_siz = 0;
#line 8837
  l_has_cod = 0;
#line 8838
  l_has_qcd = 0;
#line 8846
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 8849
  __cil_tmp10 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 8849
  if (! __cil_tmp10) {
    {
#line 8850
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 8851
    return (0);
  }
  {
#line 8855
  __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 8855
  if (__cil_tmp11 != 2UL) {
    {
#line 8857
    opj_event_msg(p_manager, 1, "Stream too short\n");
    }
#line 8858
    return (0);
  }
  {
#line 8862
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 8866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8866
    if (! (l_current_marker != 65424U)) {
#line 8866
      goto while_break;
    }
#line 8869
    if (l_current_marker < 65280U) {
      {
#line 8870
      opj_event_msg(p_manager, 1, "A marker ID was expected (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 8872
      return (0);
    }
    {
#line 8876
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 8879
    if (l_marker_handler->id == 0U) {
      {
#line 8880
      __cil_tmp13 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 8880
      if (! __cil_tmp13) {
        {
#line 8881
        opj_event_msg(p_manager, 1, "Unknown marker has been detected and generated error.\n");
        }
#line 8883
        return (0);
      }
#line 8886
      if (l_current_marker == 65424U) {
#line 8887
        goto while_break;
      } else {
        {
#line 8889
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 8893
    if (l_marker_handler->id == 65361U) {
#line 8895
      l_has_siz = 1;
    }
#line 8897
    if (l_marker_handler->id == 65362U) {
#line 8899
      l_has_cod = 1;
    }
#line 8901
    if (l_marker_handler->id == 65372U) {
#line 8903
      l_has_qcd = 1;
    }
#line 8907
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 8908
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n\205~EV");
      }
#line 8910
      return (0);
    }
    {
#line 8914
    __cil_tmp15 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 8914
    if (__cil_tmp15 != 2UL) {
      {
#line 8916
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8917
      return (0);
    }
    {
#line 8921
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
    }
#line 8923
    if (l_marker_size < 2U) {
      {
#line 8924
      opj_event_msg(p_manager, 1, "Invalid marker size\nEV");
      }
#line 8925
      return (0);
    }
#line 8927
    l_marker_size -= (unsigned int )2;
#line 8930
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 8931
      __cil_tmp17 = opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, (size_t )l_marker_size);
#line 8931
      new_header_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 8933
      if (! new_header_data) {
        {
#line 8934
        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 8935
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 8936
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 8937
        opj_event_msg(p_manager, 1, "Not enough memory to read header\nL\205~EV");
        }
#line 8938
        return (0);
      }
#line 8940
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 8941
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 8945
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 8945
    if (__cil_tmp18 != (unsigned long )l_marker_size) {
      {
#line 8948
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8949
      return (0);
    }
    {
#line 8953
    __cil_tmp19 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 8953
    if (! __cil_tmp19) {
      {
#line 8955
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n");
      }
#line 8957
      return (0);
    }
    {
#line 8961
    __cil_tmp20 = opj_stream_tell(p_stream);
#line 8961
    __cil_tmp21 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp20 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 8961
    if (0 == __cil_tmp21) {
      {
#line 8966
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n~EV");
      }
#line 8967
      return (0);
    }
    {
#line 8971
    __cil_tmp22 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 8971
    if (__cil_tmp22 != 2UL) {
      {
#line 8973
      opj_event_msg(p_manager, 1, "Stream too short\n\234\203~EV");
      }
#line 8974
      return (0);
    }
    {
#line 8978
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8982
  if (l_has_siz == 0) {
    {
#line 8983
    opj_event_msg(p_manager, 1, "required SIZ marker not found in main header\n");
    }
#line 8985
    return (0);
  }
#line 8987
  if (l_has_cod == 0) {
    {
#line 8988
    opj_event_msg(p_manager, 1, "required COD marker not found in main header\nV");
    }
#line 8990
    return (0);
  }
#line 8992
  if (l_has_qcd == 0) {
    {
#line 8993
    opj_event_msg(p_manager, 1, "required QCD marker not found in main header\n");
    }
#line 8995
    return (0);
  }
  {
#line 8998
  __cil_tmp23 = opj_j2k_merge_ppm(& p_j2k->m_cp, p_manager);
  }
#line 8998
  if (! __cil_tmp23) {
    {
#line 8999
    opj_event_msg(p_manager, 1, "Failed to merge PPM data\n");
    }
#line 9000
    return (0);
  }
  {
#line 9003
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 9006
  __cil_tmp24 = opj_stream_tell(p_stream);
#line 9006
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp24 - 2U);
#line 9009
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 9011
  return (1);
}
}
#line 9014 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp9 ;
  opj_procedure *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 9019
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 9021
  l_result = 1;
#line 9030
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 9031
  __cil_tmp10 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 9031
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp10;
#line 9034
  i = (OPJ_UINT32 )0;
  }
  {
#line 9034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9034
    if (! (i < l_nb_proc)) {
#line 9034
      goto while_break;
    }
    {
#line 9035
    __cil_tmp11 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
#line 9035
    l_result = l_result && __cil_tmp11;
#line 9036
    l_procedure ++;
    }
#line 9034
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9040
  opj_procedure_list_clear(p_procedure_list);
  }
#line 9041
  return (l_result);
}
}
#line 9045 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tcd_t *__cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;

  {
#line 9050
  l_tcp = (opj_tcp_t *)0;
#line 9051
  l_default_tcp = (opj_tcp_t *)0;
#line 9054
  l_current_tccp = (opj_tccp_t *)0;
#line 9070
  l_image = p_j2k->m_private_image;
#line 9071
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9072
  l_tcp = p_j2k->m_cp.tcps;
#line 9073
  l_tccp_size = l_image->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 9074
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 9075
  l_mct_size = (l_image->numcomps * l_image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 9079
  i = (OPJ_UINT32 )0;
  {
#line 9079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9079
    if (! (i < l_nb_tiles)) {
#line 9079
      goto while_break;
    }
    {
#line 9081
    l_current_tccp = l_tcp->tccps;
#line 9083
    memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t ));
#line 9085
    l_tcp->cod = (OPJ_BITFIELD )0;
#line 9086
    l_tcp->ppt = (OPJ_BITFIELD )0;
#line 9087
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 9088
    l_tcp->m_current_tile_part_number = - 1;
#line 9090
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
#line 9091
    l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 9092
    l_tcp->m_mct_records = (opj_mct_data_t *)0;
#line 9093
    l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 9094
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 9096
    l_tcp->tccps = l_current_tccp;
    }
#line 9099
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 9100
      __cil_tmp20 = opj_malloc((size_t )l_mct_size);
#line 9100
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp20;
      }
#line 9101
      if (! l_tcp->m_mct_decoding_matrix) {
#line 9102
        return (0);
      }
      {
#line 9104
      memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix, (unsigned long )l_mct_size);
      }
    }
    {
#line 9109
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 9111
    __cil_tmp21 = opj_malloc((size_t )l_mct_records_size);
#line 9111
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp21;
    }
#line 9112
    if (! l_tcp->m_mct_records) {
#line 9113
      return (0);
    }
    {
#line 9115
    memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, (unsigned long )l_mct_records_size);
#line 9118
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 9119
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 9121
    j = (OPJ_UINT32 )0;
    }
    {
#line 9121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9121
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 9121
        goto while_break___0;
      }
#line 9123
      if (l_src_mct_rec->m_data) {
        {
#line 9125
        __cil_tmp22 = opj_malloc((size_t )l_src_mct_rec->m_data_size);
#line 9125
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp22;
        }
#line 9126
        if (! l_dest_mct_rec->m_data) {
#line 9127
          return (0);
        }
        {
#line 9129
        memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data, (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 9133
      l_src_mct_rec ++;
#line 9134
      l_dest_mct_rec ++;
#line 9136
      l_tcp->m_nb_max_mct_records += (unsigned int )1;
#line 9121
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9140
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 9142
    __cil_tmp23 = opj_malloc((size_t )l_mcc_records_size);
#line 9142
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp23;
    }
#line 9144
    if (! l_tcp->m_mcc_records) {
#line 9145
      return (0);
    }
    {
#line 9147
    memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, (unsigned long )l_mcc_records_size);
#line 9148
    l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;
#line 9151
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 9152
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 9154
    j = (OPJ_UINT32 )0;
    }
    {
#line 9154
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 9154
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 9154
        goto while_break___1;
      }
#line 9156
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 9157
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 9159
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 9162
      if (l_src_mcc_rec->m_offset_array) {
#line 9163
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 9165
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 9168
      l_src_mcc_rec ++;
#line 9169
      l_dest_mcc_rec ++;
#line 9154
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 9173
    memcpy(l_current_tccp, l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 9176
    l_tcp ++;
    }
#line 9079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9180
  p_j2k->m_tcd = opj_tcd_create(1);
  }
#line 9181
  if (! p_j2k->m_tcd) {
#line 9182
    return (0);
  }
  {
#line 9185
  __cil_tmp25 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 9185
  if (! __cil_tmp25) {
    {
#line 9186
    opj_tcd_destroy(p_j2k->m_tcd);
#line 9187
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 9188
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n\v\206~EV");
    }
#line 9189
    return (0);
  }
#line 9192
  return (1);
}
}
#line 9195 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 9199
  e = (opj_dec_memory_marker_handler_t *)j2k_memory_marker_handler_tab;
  {
#line 9199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9199
    if (! (e->id != 0U)) {
#line 9199
      goto while_break;
    }
#line 9200
    if (e->id == p_id) {
#line 9201
      goto while_break;
    }
#line 9199
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9204
  return (e);
}
}
#line 9207 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 9209
  if (p_j2k == (opj_j2k_t *)0) {
#line 9210
    return;
  }
#line 9213
  if (p_j2k->m_is_decoder) {
#line 9215
    if (p_j2k->m_specific_param.m_decoder.m_default_tcp != (opj_tcp_t *)0) {
      {
#line 9216
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 9217
      opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 9218
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 9221
    if (p_j2k->m_specific_param.m_decoder.m_header_data != (OPJ_BYTE *)0) {
      {
#line 9222
      opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 9223
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 9224
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
    {
#line 9227
    opj_free(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode);
#line 9228
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)0;
#line 9229
    p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
    }
  } else {
#line 9233
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 9234
      opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 9235
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 9238
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 9239
      opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 9240
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 9241
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 9244
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 9245
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 9246
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 9247
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 9251
  opj_tcd_destroy(p_j2k->m_tcd);
#line 9253
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 9254
  memset(& p_j2k->m_cp, 0, sizeof(opj_cp_t ));
#line 9256
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 9257
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 9259
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 9260
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 9262
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 9263
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 9265
  opj_image_destroy(p_j2k->m_private_image);
#line 9266
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 9268
  opj_image_destroy(p_j2k->m_output_image);
#line 9269
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 9271
  opj_thread_pool_destroy(p_j2k->m_tp);
#line 9272
  p_j2k->m_tp = (opj_thread_pool_t *)((void *)0);
#line 9274
  opj_free(p_j2k);
  }
  return;
}
}
#line 9277 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 9279
  if (p_cstr_ind) {
#line 9281
    if (p_cstr_ind->marker) {
      {
#line 9282
      opj_free(p_cstr_ind->marker);
#line 9283
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 9286
    if (p_cstr_ind->tile_index) {
#line 9287
      it_tile = (OPJ_UINT32 )0;
#line 9289
      it_tile = (OPJ_UINT32 )0;
      {
#line 9289
      while (1) {
        while_continue: /* CIL Label */ ;
#line 9289
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 9289
          goto while_break;
        }
#line 9291
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 9292
          opj_free((p_cstr_ind->tile_index + it_tile)->packet_index);
#line 9293
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 9296
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 9297
          opj_free((p_cstr_ind->tile_index + it_tile)->tp_index);
#line 9298
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 9301
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 9302
          opj_free((p_cstr_ind->tile_index + it_tile)->marker);
#line 9303
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 9289
        it_tile ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 9308
      opj_free(p_cstr_ind->tile_index);
#line 9309
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 9312
    opj_free(p_cstr_ind);
    }
  }
  return;
}
}
#line 9316 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  OPJ_UINT32 i ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i___0 ;

  {
#line 9318
  if (p_tcp == (opj_tcp_t *)0) {
#line 9319
    return;
  }
#line 9322
  if (p_tcp->ppt_markers != (opj_ppx *)0) {
#line 9324
    i = 0U;
    {
#line 9324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9324
      if (! (i < p_tcp->ppt_markers_count)) {
#line 9324
        goto while_break;
      }
#line 9325
      if ((p_tcp->ppt_markers + i)->m_data != (void *)0) {
        {
#line 9326
        opj_free((p_tcp->ppt_markers + i)->m_data);
        }
      }
#line 9324
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 9329
    p_tcp->ppt_markers_count = 0U;
#line 9330
    opj_free(p_tcp->ppt_markers);
#line 9331
    p_tcp->ppt_markers = (opj_ppx *)((void *)0);
    }
  }
#line 9334
  if (p_tcp->ppt_buffer != (OPJ_BYTE *)0) {
    {
#line 9335
    opj_free(p_tcp->ppt_buffer);
#line 9336
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 9339
  if (p_tcp->tccps != (opj_tccp_t *)0) {
    {
#line 9340
    opj_free(p_tcp->tccps);
#line 9341
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 9344
  if (p_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 9345
    opj_free(p_tcp->m_mct_coding_matrix);
#line 9346
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9349
  if (p_tcp->m_mct_decoding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 9350
    opj_free(p_tcp->m_mct_decoding_matrix);
#line 9351
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9354
  if (p_tcp->m_mcc_records) {
    {
#line 9355
    opj_free(p_tcp->m_mcc_records);
#line 9356
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 9357
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 9358
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 9361
  if (p_tcp->m_mct_records) {
#line 9362
    l_mct_data = p_tcp->m_mct_records;
#line 9365
    i___0 = (OPJ_UINT32 )0;
    {
#line 9365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9365
      if (! (i___0 < p_tcp->m_nb_mct_records)) {
#line 9365
        goto while_break___0;
      }
#line 9366
      if (l_mct_data->m_data) {
        {
#line 9367
        opj_free(l_mct_data->m_data);
#line 9368
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 9371
      l_mct_data ++;
#line 9365
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9374
    opj_free(p_tcp->m_mct_records);
#line 9375
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 9378
  if (p_tcp->mct_norms != (OPJ_FLOAT64 *)0) {
    {
#line 9379
    opj_free(p_tcp->mct_norms);
#line 9380
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 9383
  opj_j2k_tcp_data_destroy(p_tcp);
  }
  return;
}
}
#line 9387 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 9389
  if (p_tcp->m_data) {
    {
#line 9390
    opj_free(p_tcp->m_data);
#line 9391
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 9392
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
  return;
}
}
#line 9396 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;
  OPJ_UINT32 i___0 ;

  {
#line 9399
  l_current_tile = (opj_tcp_t *)0;
#line 9401
  if (p_cp == (opj_cp_t *)0) {
#line 9402
    return;
  }
#line 9404
  if (p_cp->tcps != (opj_tcp_t *)0) {
#line 9406
    l_current_tile = p_cp->tcps;
#line 9407
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 9409
    i = 0U;
    {
#line 9409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9409
      if (! (i < l_nb_tiles)) {
#line 9409
        goto while_break;
      }
      {
#line 9410
      opj_j2k_tcp_destroy(l_current_tile);
#line 9411
      l_current_tile ++;
      }
#line 9409
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 9413
    opj_free(p_cp->tcps);
#line 9414
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
#line 9416
  if (p_cp->ppm_markers != (opj_ppx *)0) {
#line 9418
    i___0 = 0U;
    {
#line 9418
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9418
      if (! (i___0 < p_cp->ppm_markers_count)) {
#line 9418
        goto while_break___0;
      }
#line 9419
      if ((p_cp->ppm_markers + i___0)->m_data != (void *)0) {
        {
#line 9420
        opj_free((p_cp->ppm_markers + i___0)->m_data);
        }
      }
#line 9418
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9423
    p_cp->ppm_markers_count = 0U;
#line 9424
    opj_free(p_cp->ppm_markers);
#line 9425
    p_cp->ppm_markers = (opj_ppx *)((void *)0);
    }
  }
  {
#line 9427
  opj_free(p_cp->ppm_buffer);
#line 9428
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 9429
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 9431
  opj_free(p_cp->comment);
#line 9432
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 9433
  if (! p_cp->m_is_decoder) {
    {
#line 9434
    opj_free(p_cp->m_specific_param.m_enc.m_matrice);
#line 9435
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
  return;
}
}
#line 9439 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_header_data[10] ;
  OPJ_OFF_T l_stream_pos_backup ;
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  OPJ_UINT32 l_tile_no ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_num_parts ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_SIZE_T __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 9450
  *p_correction_needed = 0;
#line 9452
  __cil_tmp13 = opj_stream_has_seek(p_stream);
  }
#line 9452
  if (! __cil_tmp13) {
#line 9454
    return (1);
  }
  {
#line 9457
  l_stream_pos_backup = opj_stream_tell(p_stream);
  }
#line 9458
  if (l_stream_pos_backup == -1L) {
#line 9460
    return (1);
  }
  {
#line 9463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9463
    if (! 1) {
#line 9463
      goto while_break;
    }
    {
#line 9465
    __cil_tmp15 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9465
    if (__cil_tmp15 != 2UL) {
      {
#line 9467
      __cil_tmp16 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9467
      if (! __cil_tmp16) {
#line 9468
        return (0);
      }
#line 9470
      return (1);
    }
    {
#line 9474
    opj_read_bytes_LE((OPJ_BYTE *)l_header_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 9476
    if (l_current_marker != 65424U) {
      {
#line 9478
      __cil_tmp17 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9478
      if (! __cil_tmp17) {
#line 9479
        return (0);
      }
#line 9481
      return (1);
    }
    {
#line 9485
    __cil_tmp18 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9485
    if (__cil_tmp18 != 2UL) {
      {
#line 9486
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 9487
      return (0);
    }
    {
#line 9491
    opj_read_bytes_LE((OPJ_BYTE *)l_header_data, & l_marker_size, (OPJ_UINT32 )2);
    }
#line 9494
    if (l_marker_size != 10U) {
      {
#line 9495
      opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
      }
#line 9496
      return (0);
    }
    {
#line 9498
    l_marker_size -= (unsigned int )2;
#line 9500
    __cil_tmp19 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )l_marker_size,
                                       p_manager);
    }
#line 9500
    if (__cil_tmp19 != (unsigned long )l_marker_size) {
      {
#line 9502
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 9503
      return (0);
    }
    {
#line 9506
    __cil_tmp20 = opj_j2k_get_sot_values((OPJ_BYTE *)l_header_data, l_marker_size,
                                         & l_tile_no, & l_tot_len, & l_current_part,
                                         & l_num_parts, p_manager);
    }
#line 9506
    if (! __cil_tmp20) {
#line 9508
      return (0);
    }
#line 9511
    if (l_tile_no == tile_no) {
#line 9513
      goto while_break;
    }
#line 9516
    if (l_tot_len < 14U) {
      {
#line 9519
      __cil_tmp21 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9519
      if (! __cil_tmp21) {
#line 9520
        return (0);
      }
#line 9522
      return (1);
    }
    {
#line 9524
    l_tot_len -= 12U;
#line 9526
    __cil_tmp22 = opj_stream_skip(p_stream, (OPJ_OFF_T )l_tot_len, p_manager);
    }
#line 9526
    if (__cil_tmp22 != (OPJ_OFF_T )l_tot_len) {
      {
#line 9529
      __cil_tmp23 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9529
      if (! __cil_tmp23) {
#line 9530
        return (0);
      }
#line 9532
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9537
  if (l_current_part == l_num_parts) {
#line 9538
    *p_correction_needed = 1;
  }
  {
#line 9541
  __cil_tmp24 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
  }
#line 9541
  if (! __cil_tmp24) {
#line 9542
    return (0);
  }
#line 9544
  return (1);
}
}
#line 9547 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;
  struct opj_dec_memory_marker_handler *__cil_tmp20 ;
  OPJ_BYTE *new_header_data ;
  OPJ_OFF_T __cil_tmp22 ;
  void *__cil_tmp23 ;
  OPJ_SIZE_T __cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;
  OPJ_OFF_T __cil_tmp26 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp29 ;
  OPJ_OFF_T __cil_tmp30 ;
  OPJ_SIZE_T __cil_tmp31 ;
  OPJ_OFF_T __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_BOOL l_correction_needed ;
  OPJ_BOOL __cil_tmp35 ;
  OPJ_UINT32 l_tile_no ;
  OPJ_SIZE_T __cil_tmp37 ;
  OPJ_UINT32 l_tile_no___0 ;
  OPJ_BOOL __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;

  {
#line 9557
  l_current_marker = (OPJ_UINT32 )65424;
#line 9559
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 9560
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9561
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 9569
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 9570
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 9573
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 9574
    return (0);
  }
  {
#line 9578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9578
    if (! (! p_j2k->m_specific_param.m_decoder.m_can_decode && l_current_marker != 65497U)) {
#line 9578
      goto while_break;
    }
    {
#line 9582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9582
      if (! (l_current_marker != 65427U)) {
#line 9582
        goto while_break___0;
      }
      {
#line 9584
      __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9584
      if (__cil_tmp17 == 0L) {
#line 9585
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9586
        goto while_break___0;
      }
      {
#line 9590
      __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 9590
      if (__cil_tmp18 != 2UL) {
        {
#line 9592
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 9593
        return (0);
      }
      {
#line 9597
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 9601
      if (l_marker_size < 2U) {
        {
#line 9602
        opj_event_msg(p_manager, 1, "Inconsistent marker size\ng\207~EV");
        }
#line 9603
        return (0);
      }
      {
#line 9607
      __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9607
      if (l_current_marker == 32896U) {
#line 9607
        if (__cil_tmp19 == 0L) {
#line 9609
          p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9610
          goto while_break___0;
        }
      }
#line 9614
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 9615
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 9617
      l_marker_size -= (unsigned int )2;
#line 9620
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 9623
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 9624
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 9626
        return (0);
      }
#line 9631
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 9632
        new_header_data = (OPJ_BYTE *)((void *)0);
#line 9635
        __cil_tmp22 = opj_stream_get_number_byte_left(p_stream);
        }
#line 9635
        if ((OPJ_OFF_T )l_marker_size > __cil_tmp22) {
          {
#line 9636
          opj_event_msg(p_manager, 1, "Marker size inconsistent with stream length\n");
          }
#line 9638
          return (0);
        }
        {
#line 9640
        __cil_tmp23 = opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data,
                                  (size_t )l_marker_size);
#line 9640
        new_header_data = (OPJ_BYTE *)__cil_tmp23;
        }
#line 9642
        if (! new_header_data) {
          {
#line 9643
          opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 9644
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 9645
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 9646
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
          }
#line 9647
          return (0);
        }
#line 9649
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 9650
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 9654
      __cil_tmp24 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 9654
      if (__cil_tmp24 != (unsigned long )l_marker_size) {
        {
#line 9657
        opj_event_msg(p_manager, 1, "Stream too short\nx\207~EV");
        }
#line 9658
        return (0);
      }
#line 9661
      if (! l_marker_handler->handler) {
        {
#line 9663
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n");
        }
#line 9664
        return (0);
      }
      {
#line 9667
      __cil_tmp25 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 9667
      if (! __cil_tmp25) {
        {
#line 9669
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 9671
        return (0);
      }
      {
#line 9675
      __cil_tmp26 = opj_stream_tell(p_stream);
#line 9675
      __cil_tmp27 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp26 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 9675
      if (0 == __cil_tmp27) {
        {
#line 9680
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 9681
        return (0);
      }
#line 9685
      if (l_marker_handler->id == 65424U) {
        {
#line 9686
        __cil_tmp29 = opj_stream_tell(p_stream);
#line 9686
        sot_pos = ((OPJ_UINT32 )__cil_tmp29 - l_marker_size) - 4U;
        }
#line 9688
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 9689
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 9693
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 9695
        __cil_tmp30 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 9695
        if (__cil_tmp30 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 9697
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 9698
          return (0);
        }
#line 9700
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 9703
        __cil_tmp31 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 9703
        if (__cil_tmp31 != 2UL) {
          {
#line 9705
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 9706
          return (0);
        }
        {
#line 9709
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9713
    __cil_tmp32 = opj_stream_get_number_byte_left(p_stream);
    }
#line 9713
    if (__cil_tmp32 == 0L) {
#line 9713
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9715
        goto while_break;
      }
    }
#line 9719
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 9721
      __cil_tmp33 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 9721
      if (! __cil_tmp33) {
#line 9722
        return (0);
      }
#line 9724
      if ((int )p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 9724
        if (! p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {
          {
#line 9729
          p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = (OPJ_BITFIELD )1;
#line 9730
          __cil_tmp35 = opj_j2k_need_nb_tile_parts_correction(p_stream, p_j2k->m_current_tile_number,
                                                              & l_correction_needed,
                                                              p_manager);
          }
#line 9730
          if (! __cil_tmp35) {
            {
#line 9732
            opj_event_msg(p_manager, 1, "opj_j2k_apply_nb_tile_parts_correction error\n");
            }
#line 9734
            return (0);
          }
#line 9736
          if (l_correction_needed) {
#line 9739
            p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9740
            p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = (OPJ_BITFIELD )1;
#line 9742
            l_tile_no = 0U;
            {
#line 9742
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 9742
              if (! (l_tile_no < l_nb_tiles)) {
#line 9742
                goto while_break___1;
              }
#line 9743
              if ((p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts != 0U) {
#line 9744
                (p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts += (unsigned int )1;
              }
#line 9742
              l_tile_no ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 9747
            opj_event_msg(p_manager, 2, "Non conformant codestream TPsot==TNsot.\n\220");
            }
          }
        }
      }
    } else {
#line 9753
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )0;
#line 9754
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9755
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
    }
#line 9758
    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
      {
#line 9760
      __cil_tmp37 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 9760
      if (__cil_tmp37 != 2UL) {
#line 9766
        if (p_j2k->m_current_tile_number + 1U == l_nb_tiles) {
#line 9768
          l_tile_no___0 = 0U;
          {
#line 9768
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 9768
            if (! (l_tile_no___0 < l_nb_tiles)) {
#line 9768
              goto while_break___2;
            }
#line 9769
            if ((p_j2k->m_cp.tcps + l_tile_no___0)->m_current_tile_part_number == 0) {
#line 9769
              if ((p_j2k->m_cp.tcps + l_tile_no___0)->m_nb_tile_parts == 0U) {
#line 9771
                goto while_break___2;
              }
            }
#line 9768
            l_tile_no___0 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 9774
          if (l_tile_no___0 < l_nb_tiles) {
            {
#line 9775
            opj_event_msg(p_manager, 4, "Tile %u has TPsot == 0 and TNsot == 0, but no other tile-parts were found. EOC is also missing.\n\230\001",
                          l_tile_no___0);
#line 9780
            p_j2k->m_current_tile_number = l_tile_no___0;
#line 9781
            l_current_marker = (OPJ_UINT32 )65497;
#line 9782
            p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
            }
#line 9783
            goto while_break;
          }
        }
        {
#line 9787
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 9788
        return (0);
      }
      {
#line 9792
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9798
  if (l_current_marker == 65497U) {
#line 9799
    if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
#line 9800
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 9801
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 9806
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 9807
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
    {
#line 9809
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 9809
      if (! (l_tcp->m_data == (OPJ_BYTE *)0 && p_j2k->m_current_tile_number < l_nb_tiles)) {
#line 9809
        goto while_break___3;
      }
#line 9810
      (p_j2k->m_current_tile_number) ++;
#line 9811
      l_tcp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 9814
    if (p_j2k->m_current_tile_number == l_nb_tiles) {
#line 9815
      *p_go_on = 0;
#line 9816
      return (1);
    }
  }
  {
#line 9820
  __cil_tmp39 = opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,
                                  p_manager);
  }
#line 9820
  if (! __cil_tmp39) {
    {
#line 9822
    opj_event_msg(p_manager, 1, "Failed to merge PPT data\n");
    }
#line 9823
    return (0);
  }
  {
#line 9826
  __cil_tmp40 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                         p_manager);
  }
#line 9826
  if (! __cil_tmp40) {
    {
#line 9828
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 9829
    return (0);
  }
  {
#line 9832
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 9835
  *p_tile_index = p_j2k->m_current_tile_number;
#line 9836
  *p_go_on = 1;
  }
#line 9837
  if (p_data_size) {
    {
#line 9840
    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd, 0);
    }
#line 9841
    if (*p_data_size == 4294967295U) {
#line 9842
      return (0);
    }
  }
#line 9845
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 9846
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 9847
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 9848
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 9849
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 9851
  p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )128;
#line 9853
  return (1);
}
}
#line 9856 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image_for_bounds ;
  opj_image_t *tmp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp18 ;

  {
#line 9873
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 9875
    return (0);
  } else
#line 9873
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 9875
    return (0);
  }
#line 9878
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 9879
  if (! l_tcp->m_data) {
    {
#line 9880
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 9881
    return (0);
  }
#line 9889
  if (p_j2k->m_output_image) {
#line 9889
    tmp = p_j2k->m_output_image;
  } else {
#line 9889
    tmp = p_j2k->m_private_image;
  }
  {
#line 9889
  l_image_for_bounds = tmp;
#line 9891
  __cil_tmp12 = opj_tcd_decode_tile(p_j2k->m_tcd, l_image_for_bounds->x0, l_image_for_bounds->y0,
                                    l_image_for_bounds->x1, l_image_for_bounds->y1,
                                    p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode,
                                    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode,
                                    l_tcp->m_data, l_tcp->m_data_size, p_tile_index,
                                    p_j2k->cstr_index, p_manager);
  }
#line 9891
  if (! __cil_tmp12) {
    {
#line 9902
    opj_j2k_tcp_destroy(l_tcp);
#line 9903
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
#line 9904
    opj_event_msg(p_manager, 1, "Failed to decode.\n\210~EV");
    }
#line 9905
    return (0);
  }
#line 9911
  if (p_data != (void *)0) {
    {
#line 9912
    __cil_tmp13 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
    }
#line 9912
    if (! __cil_tmp13) {
#line 9913
      return (0);
    }
    {
#line 9920
    opj_j2k_tcp_data_destroy(l_tcp);
    }
  }
  {
#line 9923
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9924
  p_j2k->m_specific_param.m_decoder.m_state &= ~ ((OPJ_UINT32 )128);
#line 9926
  __cil_tmp14 = opj_stream_get_number_byte_left(p_stream);
  }
#line 9926
  if (__cil_tmp14 == 0L) {
#line 9926
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9928
      return (1);
    }
  }
#line 9931
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 9932
    __cil_tmp15 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9932
    if (__cil_tmp15 != 2UL) {
#line 9933
      if (p_j2k->m_cp.strict) {
#line 9933
        tmp___0 = 1;
      } else {
#line 9933
        tmp___0 = 2;
      }
      {
#line 9933
      opj_event_msg(p_manager, tmp___0, "Stream too short\n\021\210~EV");
      }
#line 9935
      if (p_j2k->m_cp.strict) {
#line 9935
        tmp___1 = 0;
      } else {
#line 9935
        tmp___1 = 1;
      }
#line 9935
      return (tmp___1);
    }
    {
#line 9937
    opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 9939
    if (l_current_marker == 65497U) {
#line 9940
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 9941
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 9942
    if (l_current_marker != 65424U) {
      {
#line 9943
      __cil_tmp18 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9943
      if (__cil_tmp18 == 0L) {
        {
#line 9944
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9945
        opj_event_msg(p_manager, 2, "Stream does not end with EOC\nV");
        }
#line 9946
        return (1);
      }
      {
#line 9948
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
      }
#line 9949
      return (0);
    }
  }
#line 9953
  return (1);
}
}
#line 9956 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_SIZE_T l_start_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_SIZE_T l_start_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 res_x0 ;
  OPJ_INT32 res_x1 ;
  OPJ_INT32 res_y0 ;
  OPJ_INT32 res_y1 ;
  OPJ_UINT32 src_data_stride ;
  OPJ_INT32 *p_src_data ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_resolution_t *l_res___0 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_SIZE_T l_width ;
  OPJ_SIZE_T l_height ;
  void *__cil_tmp38 ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_UINT32 __cil_tmp40 ;

  {
#line 9968
  l_img_comp_src = (opj_image_comp_t *)0;
#line 9969
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 9971
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 9972
  l_image_src = (opj_image_t *)0;
#line 9975
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 9976
  l_image_src = p_tcd->image;
#line 9977
  l_img_comp_src = l_image_src->comps;
#line 9979
  l_img_comp_dest = p_output_image->comps;
#line 9981
  i = (OPJ_UINT32 )0;
  {
#line 9981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9981
    if (! (i < l_image_src->numcomps)) {
#line 9981
      goto while_break;
    }
#line 9988
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 9990
    if (p_tcd->whole_tile_decoding) {
#line 9991
      l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9993
      res_x0 = l_res->x0;
#line 9994
      res_y0 = l_res->y0;
#line 9995
      res_x1 = l_res->x1;
#line 9996
      res_y1 = l_res->y1;
#line 9997
      src_data_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0);
#line 10000
      p_src_data = l_tilec->data;
    } else {
#line 10002
      l_res___0 = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 10004
      res_x0 = (OPJ_INT32 )l_res___0->win_x0;
#line 10005
      res_y0 = (OPJ_INT32 )l_res___0->win_y0;
#line 10006
      res_x1 = (OPJ_INT32 )l_res___0->win_x1;
#line 10007
      res_y1 = (OPJ_INT32 )l_res___0->win_y1;
#line 10008
      src_data_stride = l_res___0->win_x1 - l_res___0->win_x0;
#line 10009
      p_src_data = l_tilec->data_win;
    }
#line 10012
    if (p_src_data == (void *)0) {
#line 10014
      goto while_continue;
    }
    {
#line 10017
    l_width_src = (OPJ_UINT32 )(res_x1 - res_x0);
#line 10018
    l_height_src = (OPJ_UINT32 )(res_y1 - res_y0);
#line 10029
    l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);
#line 10030
    l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);
#line 10031
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 10033
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 10049
    if (l_x0_dest < (OPJ_UINT32 )res_x0) {
#line 10050
      l_start_x_dest = (OPJ_UINT32 )res_x0 - l_x0_dest;
#line 10051
      l_offset_x0_src = 0;
#line 10053
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 10054
        l_width_dest = l_width_src;
#line 10055
        l_offset_x1_src = 0;
      } else {
#line 10057
        l_width_dest = l_x1_dest - (OPJ_UINT32 )res_x0;
#line 10058
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 10061
      l_start_x_dest = 0U;
#line 10062
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - res_x0;
#line 10064
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 10065
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 10066
        l_offset_x1_src = 0;
      } else {
#line 10068
        l_width_dest = l_img_comp_dest->w;
#line 10069
        l_offset_x1_src = res_x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 10073
    if (l_y0_dest < (OPJ_UINT32 )res_y0) {
#line 10074
      l_start_y_dest = (OPJ_UINT32 )res_y0 - l_y0_dest;
#line 10075
      l_offset_y0_src = 0;
#line 10077
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 10078
        l_height_dest = l_height_src;
#line 10079
        l_offset_y1_src = 0;
      } else {
#line 10081
        l_height_dest = l_y1_dest - (OPJ_UINT32 )res_y0;
#line 10082
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 10085
      l_start_y_dest = 0U;
#line 10086
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - res_y0;
#line 10088
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 10089
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 10090
        l_offset_y1_src = 0;
      } else {
#line 10092
        l_height_dest = l_img_comp_dest->h;
#line 10093
        l_offset_y1_src = res_y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 10097
    if (l_offset_x0_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_y0_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_x1_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_y1_src < 0) {
#line 10099
      return (0);
    }
#line 10102
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 10103
      return (0);
    } else
#line 10102
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 10103
      return (0);
    }
#line 10108
    l_start_offset_src = (OPJ_SIZE_T )l_offset_x0_src + (OPJ_SIZE_T )l_offset_y0_src * (OPJ_SIZE_T )src_data_stride;
#line 10112
    l_start_offset_dest = (OPJ_SIZE_T )l_start_x_dest + (OPJ_SIZE_T )l_start_y_dest * (OPJ_SIZE_T )l_img_comp_dest->w;
#line 10116
    if (l_img_comp_dest->data == (void *)0) {
#line 10116
      if (l_start_offset_src == 0UL) {
#line 10116
        if (l_start_offset_dest == 0UL) {
#line 10116
          if (src_data_stride == l_img_comp_dest->w) {
#line 10116
            if (l_width_dest == l_img_comp_dest->w) {
#line 10116
              if (l_height_dest == l_img_comp_dest->h) {
#line 10123
                if (p_tcd->whole_tile_decoding) {
#line 10124
                  l_img_comp_dest->data = l_tilec->data;
#line 10125
                  l_tilec->data = (OPJ_INT32 *)((void *)0);
                } else {
#line 10127
                  l_img_comp_dest->data = l_tilec->data_win;
#line 10128
                  l_tilec->data_win = (OPJ_INT32 *)((void *)0);
                }
#line 10130
                goto while_continue;
              } else {
#line 10116
                goto _L;
              }
            } else {
#line 10116
              goto _L;
            }
          } else {
#line 10116
            goto _L;
          }
        } else {
#line 10116
          goto _L;
        }
      } else {
#line 10116
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___31: /* CIL Label */ 
    _L___32: /* CIL Label */ 
    _L___33: /* CIL Label */ 
    _L___34: /* CIL Label */ 
#line 10131
    if (l_img_comp_dest->data == (void *)0) {
#line 10132
      l_width = (OPJ_SIZE_T )l_img_comp_dest->w;
#line 10133
      l_height = (OPJ_SIZE_T )l_img_comp_dest->h;
#line 10135
      if (l_height == 0UL) {
#line 10138
        return (0);
      } else
#line 10135
      if (l_width > 0xffffffffffffffffUL / l_height) {
#line 10138
        return (0);
      } else
#line 10135
      if (l_width * l_height > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
#line 10138
        return (0);
      }
      {
#line 10140
      __cil_tmp38 = opj_image_data_alloc((l_width * l_height) * sizeof(OPJ_INT32 ));
#line 10140
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp38;
      }
#line 10142
      if (! l_img_comp_dest->data) {
#line 10143
        return (0);
      }
#line 10146
      if (l_img_comp_dest->w != l_width_dest) {
        {
        {
#line 10148
        memset(l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
        }
      } else
#line 10146
      if (l_img_comp_dest->h != l_height_dest) {
        {
        {
#line 10148
        memset(l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
        }
      }
    }
#line 10154
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 10157
    l_src_ptr = p_src_data;
#line 10158
    l_src_ptr += l_start_offset_src;
#line 10160
    j = (OPJ_UINT32 )0;
    {
#line 10160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10160
      if (! (j < l_height_dest)) {
#line 10160
        goto while_break___0;
      }
      {
#line 10161
      memcpy(l_dest_ptr, l_src_ptr, (unsigned long )l_width_dest * sizeof(OPJ_INT32 ));
#line 10162
      l_dest_ptr += l_img_comp_dest->w;
#line 10163
      l_src_ptr += src_data_stride;
      }
#line 10160
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9982
    l_tilec ++;
#line 9982
    l_img_comp_src ++;
#line 9982
    l_img_comp_dest ++;
#line 9982
    __cil_tmp40 = i;
#line 9982
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10170
  return (1);
}
}
#line 10173 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  opj_image_comp_t *__cil_tmp17 ;

  {
#line 10178
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 10180
  l_img_comp = p_image->comps;
#line 10181
  it_comp = (OPJ_UINT32 )0;
  {
#line 10181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10181
    if (! (it_comp < p_image->numcomps)) {
#line 10181
      goto while_break;
    }
#line 10183
    if (p_image->x0 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->y0 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->x1 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->y1 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    }
    {
#line 10192
    __cil_tmp9 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 10192
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp9;
#line 10194
    __cil_tmp10 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 10194
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp10;
#line 10196
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 10197
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 10199
    __cil_tmp14 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 10199
    __cil_tmp13 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 10199
    l_w = __cil_tmp13 - __cil_tmp14;
    }
#line 10201
    if (l_w < 0) {
      {
#line 10202
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                    it_comp, l_w);
      }
#line 10205
      return (0);
    }
    {
#line 10207
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 10209
    __cil_tmp16 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 10209
    __cil_tmp15 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 10209
    l_h = __cil_tmp15 - __cil_tmp16;
    }
#line 10211
    if (l_h < 0) {
      {
#line 10212
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
                    it_comp, l_h);
      }
#line 10215
      return (0);
    }
#line 10217
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 10219
    l_img_comp ++;
#line 10181
    it_comp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10222
  return (1);
}
}
#line 10225 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BOOL *already_mapped ;
  void *__cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 10233
  if (p_j2k->m_private_image == (void *)0) {
    {
#line 10234
    opj_event_msg(p_manager, 1, "opj_read_header() should be called before opj_set_decoded_components().\n");
    }
#line 10237
    return (0);
  }
  {
#line 10240
  __cil_tmp7 = opj_calloc(sizeof(OPJ_BOOL ), (size_t )(p_j2k->m_private_image)->numcomps);
#line 10240
  already_mapped = (OPJ_BOOL *)__cil_tmp7;
  }
#line 10242
  if (already_mapped == (void *)0) {
#line 10243
    return (0);
  }
#line 10246
  i = (OPJ_UINT32 )0;
  {
#line 10246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10246
    if (! (i < numcomps)) {
#line 10246
      goto while_break;
    }
#line 10247
    if (*(comps_indices + i) >= (p_j2k->m_private_image)->numcomps) {
      {
#line 10248
      opj_event_msg(p_manager, 1, "Invalid component index: %u\n", *(comps_indices + i));
#line 10251
      opj_free(already_mapped);
      }
#line 10252
      return (0);
    }
#line 10254
    if (*(already_mapped + *(comps_indices + i))) {
      {
#line 10255
      opj_event_msg(p_manager, 1, "Component index %u used several times\n", *(comps_indices + i));
#line 10258
      opj_free(already_mapped);
      }
#line 10259
      return (0);
    }
#line 10261
    *(already_mapped + *(comps_indices + i)) = 1;
#line 10246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10263
  opj_free(already_mapped);
#line 10265
  opj_free(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode);
  }
#line 10266
  if (numcomps) {
    {
#line 10267
    __cil_tmp9 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 ));
#line 10267
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)__cil_tmp9;
    }
#line 10269
    if (p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode == (void *)0) {
#line 10270
      p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
#line 10271
      return (0);
    }
    {
#line 10273
    memcpy(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode, comps_indices,
           (unsigned long )numcomps * sizeof(OPJ_UINT32 ));
    }
  } else {
#line 10277
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)((void *)0);
  }
#line 10279
  p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = numcomps;
#line 10281
  return (1);
}
}
#line 10285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_BOOL ret ;
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 10291
  l_cp = & p_j2k->m_cp;
#line 10292
  l_image = p_j2k->m_private_image;
#line 10296
  if ((p_j2k->m_cp.tcps + 0)->m_data != (void *)0) {
#line 10296
    if (p_j2k->m_cp.tw == 1U) {
#line 10296
      if (! (p_j2k->m_cp.th == 1U)) {
#line 10296
        goto _L;
      }
    } else {
#line 10296
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 10302
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 10303
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream.\n\220");
    }
#line 10305
    return (0);
  }
#line 10310
  it_comp = (OPJ_UINT32 )0;
  {
#line 10310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10310
    if (! (it_comp < p_image->numcomps)) {
#line 10310
      goto while_break;
    }
#line 10311
    (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 10310
    it_comp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10314
  if (! p_start_x) {
#line 10314
    if (! p_start_y) {
#line 10314
      if (! p_end_x) {
#line 10314
        if (! p_end_y) {
          {
#line 10315
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\nEV");
#line 10318
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10319
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10320
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 10321
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 10323
          p_image->x0 = l_image->x0;
#line 10324
          p_image->y0 = l_image->y0;
#line 10325
          p_image->x1 = l_image->x1;
#line 10326
          p_image->y1 = l_image->y1;
#line 10328
          __cil_tmp12 = opj_j2k_update_image_dimensions(p_image, p_manager);
          }
#line 10328
          return (__cil_tmp12);
        }
      }
    }
  }
#line 10335
  if (p_start_x < 0) {
    {
#line 10336
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) should be >= 0.\n",
                  p_start_x);
    }
#line 10339
    return (0);
  } else
#line 10340
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 10341
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 10344
    return (0);
  } else
#line 10345
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 10346
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 10349
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10350
    p_image->x0 = l_image->x0;
    }
  } else {
#line 10352
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 10354
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 10358
  if (p_start_y < 0) {
    {
#line 10359
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) should be >= 0.\n",
                  p_start_y);
    }
#line 10362
    return (0);
  } else
#line 10363
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 10364
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\nEV",
                  p_start_y, l_image->y1);
    }
#line 10367
    return (0);
  } else
#line 10368
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 10369
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\nV",
                  p_start_y, l_image->y0);
#line 10372
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10373
    p_image->y0 = l_image->y0;
    }
  } else {
#line 10375
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 10377
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 10381
  if (p_end_x <= 0) {
    {
#line 10382
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) should be > 0.\n\232\210~EV",
                  p_end_x);
    }
#line 10385
    return (0);
  } else
#line 10386
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 10387
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 10390
    return (0);
  } else
#line 10391
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 10392
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 10395
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 10396
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 10398
    __cil_tmp13 = opj_int_ceildiv(p_end_x - (OPJ_INT32 )l_cp->tx0, (OPJ_INT32 )l_cp->tdx);
#line 10398
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp13;
#line 10400
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 10404
  if (p_end_y <= 0) {
    {
#line 10405
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) should be > 0.\n",
                  p_end_y);
    }
#line 10408
    return (0);
  } else
#line 10409
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 10410
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                  p_end_y, l_image->y0);
    }
#line 10413
    return (0);
  }
#line 10415
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 10416
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 10419
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 10420
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 10422
    __cil_tmp14 = opj_int_ceildiv(p_end_y - (OPJ_INT32 )l_cp->ty0, (OPJ_INT32 )l_cp->tdy);
#line 10422
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp14;
#line 10424
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
  {
#line 10428
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_BITFIELD )1;
#line 10430
  ret = opj_j2k_update_image_dimensions(p_image, p_manager);
  }
#line 10432
  if (ret) {
    {
#line 10433
    opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\n", p_image->x0,
                  p_image->y0, p_image->x1, p_image->y1);
    }
  }
#line 10437
  return (ret);
}
}
#line 10440 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  opj_codestream_index_t *__cil_tmp5 ;
  opj_procedure_list_t *__cil_tmp6 ;
  opj_procedure_list_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  opj_thread_pool_t *__cil_tmp9 ;
  opj_thread_pool_t *__cil_tmp10 ;

  {
  {
#line 10442
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 10442
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 10443
  if (! l_j2k) {
#line 10444
    return ((opj_j2k_t *)0);
  }
  {
#line 10447
  l_j2k->m_is_decoder = 1;
#line 10448
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )1;
#line 10451
  l_j2k->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )1;
#line 10454
  l_j2k->m_cp.strict = 1;
#line 10460
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcp_t ));
#line 10460
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 10462
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 10463
    opj_j2k_destroy(l_j2k);
    }
#line 10464
    return ((opj_j2k_t *)0);
  }
  {
#line 10467
  __cil_tmp4 = opj_calloc((size_t )1, (size_t )1000);
#line 10467
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 10469
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 10470
    opj_j2k_destroy(l_j2k);
    }
#line 10471
    return ((opj_j2k_t *)0);
  }
  {
#line 10474
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 10477
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = - 1;
#line 10479
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 10482
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
  }
#line 10483
  if (! l_j2k->cstr_index) {
    {
#line 10484
    opj_j2k_destroy(l_j2k);
    }
#line 10485
    return ((opj_j2k_t *)0);
  }
  {
#line 10489
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 10490
  if (! l_j2k->m_validation_list) {
    {
#line 10491
    opj_j2k_destroy(l_j2k);
    }
#line 10492
    return ((opj_j2k_t *)0);
  }
  {
#line 10496
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 10497
  if (! l_j2k->m_procedure_list) {
    {
#line 10498
    opj_j2k_destroy(l_j2k);
    }
#line 10499
    return ((opj_j2k_t *)0);
  }
  {
#line 10502
  __cil_tmp8 = opj_j2k_get_default_thread_count();
#line 10502
  __cil_tmp9 = opj_thread_pool_create(__cil_tmp8);
#line 10502
  l_j2k->m_tp = __cil_tmp9;
  }
#line 10503
  if (! l_j2k->m_tp) {
    {
#line 10504
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 10506
  if (! l_j2k->m_tp) {
    {
#line 10507
    opj_j2k_destroy(l_j2k);
    }
#line 10508
    return ((opj_j2k_t *)((void *)0));
  }
#line 10511
  return (l_j2k);
}
}
#line 10514 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 10516
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 10516
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 10518
  if (! cstr_index) {
#line 10519
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 10522
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 10523
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 10524
  __cil_tmp3 = opj_calloc((size_t )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 10524
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 10526
  if (! cstr_index->marker) {
    {
#line 10527
    opj_free(cstr_index);
    }
#line 10528
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 10531
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 10533
  return (cstr_index);
}
}
#line 10536 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 10540
  l_cp = (opj_cp_t *)0;
#line 10541
  l_tcp = (opj_tcp_t *)0;
#line 10542
  l_tccp = (opj_tccp_t *)0;
#line 10547
  l_cp = & p_j2k->m_cp;
#line 10548
  l_tcp = l_cp->tcps + p_tile_no;
#line 10549
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10555
  if (l_tccp->csty & 1U) {
#line 10556
    return (5U + l_tccp->numresolutions);
  } else {
#line 10558
    return ((OPJ_UINT32 )5);
  }
}
}
#line 10562 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;

  {
#line 10566
  l_cp = (opj_cp_t *)((void *)0);
#line 10567
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10568
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 10569
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 10574
  l_cp = & p_j2k->m_cp;
#line 10575
  l_tcp = l_cp->tcps + p_tile_no;
#line 10576
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 10577
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 10579
  if (l_tccp0->numresolutions != l_tccp1->numresolutions) {
#line 10580
    return (0);
  }
#line 10582
  if (l_tccp0->cblkw != l_tccp1->cblkw) {
#line 10583
    return (0);
  }
#line 10585
  if (l_tccp0->cblkh != l_tccp1->cblkh) {
#line 10586
    return (0);
  }
#line 10588
  if (l_tccp0->cblksty != l_tccp1->cblksty) {
#line 10589
    return (0);
  }
#line 10591
  if (l_tccp0->qmfbid != l_tccp1->qmfbid) {
#line 10592
    return (0);
  }
#line 10594
  if ((l_tccp0->csty & 1U) != (l_tccp1->csty & 1U)) {
#line 10595
    return (0);
  }
#line 10598
  i = 0U;
  {
#line 10598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10598
    if (! (i < l_tccp0->numresolutions)) {
#line 10598
      goto while_break;
    }
#line 10599
    if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {
#line 10600
      return (0);
    }
#line 10602
    if (l_tccp0->prch[i] != l_tccp1->prch[i]) {
#line 10603
      return (0);
    }
#line 10598
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10606
  return (1);
}
}
#line 10609 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 10617
  l_cp = (opj_cp_t *)0;
#line 10618
  l_tcp = (opj_tcp_t *)0;
#line 10619
  l_tccp = (opj_tccp_t *)0;
#line 10627
  l_cp = & p_j2k->m_cp;
#line 10628
  l_tcp = l_cp->tcps + p_tile_no;
#line 10629
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10635
  if (*p_header_size < 5U) {
    {
#line 10636
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n\211~EV");
    }
#line 10637
    return (0);
  }
  {
#line 10640
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 10641
  p_data ++;
#line 10643
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 10644
  p_data ++;
#line 10646
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 10647
  p_data ++;
#line 10649
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 10651
  p_data ++;
#line 10653
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 10655
  p_data ++;
#line 10657
  *p_header_size -= 5U;
  }
#line 10659
  if (l_tccp->csty & 1U) {
#line 10661
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 10662
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\n");
      }
#line 10663
      return (0);
    }
#line 10666
    i = (OPJ_UINT32 )0;
    {
#line 10666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10666
      if (! (i < l_tccp->numresolutions)) {
#line 10666
        goto while_break;
      }
      {
#line 10667
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 10669
      p_data ++;
      }
#line 10666
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 10672
    *p_header_size -= l_tccp->numresolutions;
  }
#line 10675
  return (1);
}
}
#line 10678 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  opj_tcp_t *tmp ;

  {
#line 10685
  l_cp = (opj_cp_t *)((void *)0);
#line 10686
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10687
  l_tccp = (opj_tccp_t *)((void *)0);
#line 10688
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 10695
  l_cp = & p_j2k->m_cp;
#line 10696
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 10696
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 10696
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10696
  l_tcp = tmp;
#line 10703
  l_tccp = l_tcp->tccps + compno;
#line 10704
  l_current_ptr = p_header_data;
#line 10707
  if (*p_header_size < 5U) {
    {
#line 10708
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n");
    }
#line 10709
    return (0);
  }
  {
#line 10713
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 10714
  (l_tccp->numresolutions) ++;
  }
#line 10715
  if (l_tccp->numresolutions > 33U) {
    {
#line 10716
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 10719
    return (0);
  }
#line 10721
  l_current_ptr ++;
#line 10724
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 10725
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove (%d) is greater or equal than the number of resolutions of this component (%d)\nModify the cp_reduce parameter.\n\n",
                  compno, l_cp->m_specific_param.m_dec.m_reduce, l_tccp->numresolutions);
#line 10730
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
    }
#line 10732
    return (0);
  }
  {
#line 10736
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 10737
  l_current_ptr ++;
#line 10738
  l_tccp->cblkw += (unsigned int )2;
#line 10741
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 10742
  l_current_ptr ++;
#line 10743
  l_tccp->cblkh += (unsigned int )2;
  }
#line 10745
  if (l_tccp->cblkw > 10U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  } else
#line 10745
  if (l_tccp->cblkh > 10U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  } else
#line 10745
  if (l_tccp->cblkw + l_tccp->cblkh > 12U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  }
  {
#line 10753
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 10754
  l_current_ptr ++;
  }
#line 10755
  if ((l_tccp->cblksty & 128U) != 0U) {
    {
#line 10757
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element. Unsupported Mixed HT code-block style found\n");
    }
#line 10759
    return (0);
  }
  {
#line 10763
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 10764
  l_current_ptr ++;
  }
#line 10766
  if (l_tccp->qmfbid > 1U) {
    {
#line 10767
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid transformation found\n\220");
    }
#line 10769
    return (0);
  }
#line 10772
  *p_header_size -= 5U;
#line 10775
  if (l_tccp->csty & 1U) {
#line 10776
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 10777
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\n\212~EV");
      }
#line 10778
      return (0);
    }
#line 10782
    i = (OPJ_UINT32 )0;
    {
#line 10782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10782
      if (! (i < l_tccp->numresolutions)) {
#line 10782
        goto while_break;
      }
      {
#line 10783
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 10784
      l_current_ptr ++;
      }
#line 10786
      if (i != 0U) {
#line 10786
        if ((l_tmp & 15U) == 0U) {
          {
          {
#line 10787
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
          }
#line 10788
          return (0);
        } else
#line 10786
        if (l_tmp >> 4 == 0U) {
          {
          {
#line 10787
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
          }
#line 10788
          return (0);
        }
      }
#line 10790
      l_tccp->prcw[i] = l_tmp & 15U;
#line 10791
      l_tccp->prch[i] = l_tmp >> 4;
#line 10782
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 10794
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 10797
    i = (OPJ_UINT32 )0;
    {
#line 10797
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10797
      if (! (i < l_tccp->numresolutions)) {
#line 10797
        goto while_break___0;
      }
#line 10798
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 10799
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 10797
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 10827
  return (1);
}
}
#line 10830 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp ;

  {
#line 10834
  l_cp = (opj_cp_t *)((void *)0);
#line 10835
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10836
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 10836
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 10842
  l_cp = & p_j2k->m_cp;
#line 10843
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 10843
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 10843
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10843
  l_tcp = tmp;
#line 10848
  l_ref_tccp = l_tcp->tccps + 0;
#line 10849
  l_copied_tccp = l_ref_tccp + 1;
#line 10850
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 10852
  i = (OPJ_UINT32 )1;
  {
#line 10852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10852
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 10852
      goto while_break;
    }
    {
#line 10853
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 10854
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 10855
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 10856
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 10857
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 10858
    memcpy((OPJ_UINT32 *)l_copied_tccp->prcw, (OPJ_UINT32 *)l_ref_tccp->prcw, (unsigned long )l_prc_size);
#line 10859
    memcpy((OPJ_UINT32 *)l_copied_tccp->prch, (OPJ_UINT32 *)l_ref_tccp->prch, (unsigned long )l_prc_size);
#line 10860
    l_copied_tccp ++;
    }
#line 10852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 10864 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp ;

  {
#line 10870
  l_cp = (opj_cp_t *)0;
#line 10871
  l_tcp = (opj_tcp_t *)0;
#line 10872
  l_tccp = (opj_tccp_t *)0;
#line 10877
  l_cp = & p_j2k->m_cp;
#line 10878
  l_tcp = l_cp->tcps + p_tile_no;
#line 10879
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10885
  if (l_tccp->qntsty == 1U) {
#line 10885
    tmp = (unsigned int )1;
  } else {
#line 10885
    tmp = l_tccp->numresolutions * 3U - 2U;
  }
#line 10885
  l_num_bands = tmp;
#line 10888
  if (l_tccp->qntsty == 0U) {
#line 10889
    return (1U + l_num_bands);
  } else {
#line 10891
    return (1U + 2U * l_num_bands);
  }
}
}
#line 10895 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;

  {
#line 10898
  l_cp = (opj_cp_t *)((void *)0);
#line 10899
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10900
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 10901
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 10907
  l_cp = & p_j2k->m_cp;
#line 10908
  l_tcp = l_cp->tcps + p_tile_no;
#line 10909
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 10910
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 10912
  if (l_tccp0->qntsty != l_tccp1->qntsty) {
#line 10913
    return (0);
  }
#line 10915
  if (l_tccp0->numgbits != l_tccp1->numgbits) {
#line 10916
    return (0);
  }
#line 10918
  if (l_tccp0->qntsty == 1U) {
#line 10919
    l_num_bands = 1U;
  } else {
#line 10921
    l_num_bands = l_tccp0->numresolutions * 3U - 2U;
#line 10922
    if (l_num_bands != l_tccp1->numresolutions * 3U - 2U) {
#line 10923
      return (0);
    }
  }
#line 10927
  l_band_no = (OPJ_UINT32 )0;
  {
#line 10927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10927
    if (! (l_band_no < l_num_bands)) {
#line 10927
      goto while_break;
    }
#line 10928
    if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {
#line 10929
      return (0);
    }
#line 10927
    l_band_no ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10932
  if (l_tccp0->qntsty != 0U) {
#line 10933
    l_band_no = (OPJ_UINT32 )0;
    {
#line 10933
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10933
      if (! (l_band_no < l_num_bands)) {
#line 10933
        goto while_break___0;
      }
#line 10934
      if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {
#line 10935
        return (0);
      }
#line 10933
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 10939
  return (1);
}
}
#line 10943 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp ;

  {
#line 10954
  l_cp = (opj_cp_t *)0;
#line 10955
  l_tcp = (opj_tcp_t *)0;
#line 10956
  l_tccp = (opj_tccp_t *)0;
#line 10964
  l_cp = & p_j2k->m_cp;
#line 10965
  l_tcp = l_cp->tcps + p_tile_no;
#line 10966
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10972
  if (l_tccp->qntsty == 1U) {
#line 10972
    tmp = (unsigned int )1;
  } else {
#line 10972
    tmp = l_tccp->numresolutions * 3U - 2U;
  }
#line 10972
  l_num_bands = tmp;
#line 10975
  if (l_tccp->qntsty == 0U) {
#line 10976
    l_header_size = 1U + l_num_bands;
#line 10978
    if (*p_header_size < l_header_size) {
      {
#line 10979
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10980
      return (0);
    }
    {
#line 10983
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 10985
    p_data ++;
#line 10987
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 10987
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10987
      if (! (l_band_no < l_num_bands)) {
#line 10987
        goto while_break;
      }
      {
#line 10988
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 10989
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 10990
      p_data ++;
      }
#line 10987
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 10993
    l_header_size = 1U + 2U * l_num_bands;
#line 10995
    if (*p_header_size < l_header_size) {
      {
#line 10996
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10997
      return (0);
    }
    {
#line 11000
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 11002
    p_data ++;
#line 11004
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 11004
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11004
      if (! (l_band_no < l_num_bands)) {
#line 11004
        goto while_break___0;
      }
      {
#line 11005
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 11006
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 11008
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 11009
      p_data += 2;
      }
#line 11004
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 11013
  *p_header_size -= l_header_size;
#line 11015
  return (1);
}
}
#line 11018 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 __cil_tmp18 ;

  {
#line 11027
  l_cp = (opj_cp_t *)0;
#line 11028
  l_tcp = (opj_tcp_t *)0;
#line 11029
  l_tccp = (opj_tccp_t *)0;
#line 11030
  l_current_ptr = (OPJ_BYTE *)0;
#line 11038
  l_cp = & p_j2k->m_cp;
#line 11040
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 11040
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 11040
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 11040
  l_tcp = tmp;
#line 11048
  l_tccp = l_tcp->tccps + p_comp_no;
#line 11049
  l_current_ptr = p_header_data;
#line 11051
  if (*p_header_size < 1U) {
    {
#line 11052
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 11053
    return (0);
  }
  {
#line 11055
  *p_header_size -= (unsigned int )1;
#line 11057
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 11058
  l_current_ptr ++;
#line 11060
  l_tccp->qntsty = l_tmp & 31U;
#line 11061
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 11062
  if (l_tccp->qntsty == 1U) {
#line 11063
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 11065
    if (l_tccp->qntsty == 0U) {
#line 11065
      tmp___0 = *p_header_size;
    } else {
#line 11065
      tmp___0 = *p_header_size / 2U;
    }
#line 11065
    l_num_band = tmp___0;
#line 11069
    if (l_num_band > 97U) {
      {
#line 11070
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 11101
  if (l_tccp->qntsty == 0U) {
#line 11102
    l_band_no = (OPJ_UINT32 )0;
    {
#line 11102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11102
      if (! (l_band_no < l_num_band)) {
#line 11102
        goto while_break;
      }
      {
#line 11103
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 11104
      l_current_ptr ++;
      }
#line 11105
      if (l_band_no < 97U) {
#line 11106
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 11107
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 11102
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 11110
    *p_header_size -= l_num_band;
  } else {
#line 11112
    l_band_no = (OPJ_UINT32 )0;
    {
#line 11112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11112
      if (! (l_band_no < l_num_band)) {
#line 11112
        goto while_break___0;
      }
      {
#line 11113
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 11114
      l_current_ptr += 2;
      }
#line 11115
      if (l_band_no < 97U) {
#line 11116
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 11117
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 11112
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11120
    *p_header_size -= 2U * l_num_band;
  }
#line 11124
  if (l_tccp->qntsty == 1U) {
#line 11125
    l_band_no = (OPJ_UINT32 )1;
    {
#line 11125
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 11125
      if (! (l_band_no < 97U)) {
#line 11125
        goto while_break___1;
      }
#line 11126
      if ((OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U) > 0) {
#line 11126
        tmp___1 = (OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U);
      } else {
#line 11126
        tmp___1 = 0;
      }
#line 11126
      l_tccp->stepsizes[l_band_no].expn = tmp___1;
#line 11130
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 11125
      l_band_no ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 11134
  return (1);
}
}
#line 11137 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp ;

  {
#line 11140
  l_cp = (opj_cp_t *)((void *)0);
#line 11141
  l_tcp = (opj_tcp_t *)((void *)0);
#line 11142
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 11143
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 11149
  l_cp = & p_j2k->m_cp;
#line 11150
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 11150
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 11150
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 11150
  l_tcp = tmp;
#line 11154
  l_ref_tccp = l_tcp->tccps + 0;
#line 11155
  l_copied_tccp = l_ref_tccp + 1;
#line 11156
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 11158
  i = (OPJ_UINT32 )1;
  {
#line 11158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11158
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 11158
      goto while_break;
    }
    {
#line 11159
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 11160
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 11161
    memcpy((opj_stepsize_t *)l_copied_tccp->stepsizes, (opj_stepsize_t *)l_ref_tccp->stepsizes,
           (unsigned long )l_size);
#line 11162
    l_copied_tccp ++;
    }
#line 11158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 11166 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps ,
                                   FILE *out_stream ) 
{ 
  OPJ_INT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  OPJ_UINT32 __cil_tmp9 ;
  int tmp ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;

  {
#line 11169
  if (l_default_tile) {
    {
#line 11172
    fprintf(out_stream, "\t default tile {\n");
#line 11173
    fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
#line 11174
    fprintf(out_stream, "\t\t prg=%#x\n~EV", (int )l_default_tile->prg);
#line 11175
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 11176
    fprintf(out_stream, "\t\t mct=%x\n\213~EV", l_default_tile->mct);
#line 11178
    compno = 0;
    }
    {
#line 11178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11178
      if (! (compno < numcomps)) {
#line 11178
        goto while_break;
      }
      {
#line 11179
      l_tccp = l_default_tile->tccps + compno;
#line 11184
      fprintf(out_stream, "\t\t comp %d {\nV", compno);
#line 11185
      fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
#line 11186
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 11187
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 11188
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 11189
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 11190
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 11192
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 11193
      resno = (OPJ_UINT32 )0;
      }
      {
#line 11193
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 11193
        if (! (resno < l_tccp->numresolutions)) {
#line 11193
          goto while_break___0;
        }
        {
#line 11194
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
        }
#line 11193
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 11196
      fprintf(out_stream, "\n@\213~EV");
#line 11199
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 11200
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 11201
      fprintf(out_stream, "\t\t\t stepsizes (m,e)=EV");
      }
#line 11202
      if (l_tccp->qntsty == 1U) {
#line 11202
        tmp = 1;
      } else {
#line 11202
        tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
      }
#line 11202
      numbands = tmp;
#line 11204
      bandno = 0;
      {
#line 11204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 11204
        if (! (bandno < numbands)) {
#line 11204
          goto while_break___1;
        }
        {
#line 11205
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
        }
#line 11204
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 11208
      fprintf(out_stream, "\n");
#line 11211
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 11213
      fprintf(out_stream, "\t\t }\nV");
      }
#line 11178
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 11215
    fprintf(out_stream, "\t }\n");
    }
  }
  return;
}
}
#line 11219 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;

  {
#line 11222
  if (flag & 128) {
    {
    {
#line 11223
    fprintf(out_stream, "Wrong flag\n~EV");
    }
    }
#line 11224
    return;
  } else
#line 11222
  if (flag & 256) {
    {
    {
#line 11223
    fprintf(out_stream, "Wrong flag\n~EV");
    }
    }
#line 11224
    return;
  }
#line 11228
  if (flag & 1) {
#line 11229
    if (p_j2k->m_private_image) {
      {
#line 11230
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 11235
  if (flag & 2) {
#line 11236
    if (p_j2k->m_private_image) {
      {
#line 11237
      opj_j2k_dump_MH_info(p_j2k, out_stream);
      }
    }
  }
#line 11241
  if (flag & 8) {
#line 11242
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 11244
    l_tcp = p_j2k->m_cp.tcps;
#line 11245
    if (p_j2k->m_private_image) {
#line 11246
      i = (OPJ_UINT32 )0;
      {
#line 11246
      while (1) {
        while_continue: /* CIL Label */ ;
#line 11246
        if (! (i < l_nb_tiles)) {
#line 11246
          goto while_break;
        }
        {
#line 11247
        opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                               out_stream);
#line 11249
        l_tcp ++;
        }
#line 11246
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 11255
  if (flag & 4) {

  }
#line 11260
  if (flag & 16) {
    {
#line 11261
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 11265
  if (flag & 32) {

  }
  return;
}
}
#line 11271 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 11273
  cstr_index = p_j2k->cstr_index;
#line 11276
  fprintf(out_stream, "Codestream index from main header: {\n");
#line 11278
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 11282
  fprintf(out_stream, "\t Marker list: {\n");
  }
#line 11284
  if (cstr_index->marker) {
#line 11285
    it_marker = (OPJ_UINT32 )0;
    {
#line 11285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11285
      if (! (it_marker < cstr_index->marknum)) {
#line 11285
        goto while_break;
      }
      {
#line 11286
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
      }
#line 11285
      it_marker ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 11293
  fprintf(out_stream, "\t }\n");
  }
#line 11295
  if (cstr_index->tile_index) {
#line 11298
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 11299
    it_tile = (OPJ_UINT32 )0;
    {
#line 11299
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11299
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 11299
        goto while_break___0;
      }
#line 11300
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 11299
      it_tile ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11303
    if (l_acc_nb_of_tile_part) {
      {
#line 11304
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 11306
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 11306
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 11306
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 11306
          goto while_break___1;
        }
        {
#line 11307
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 11309
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
        }
#line 11312
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 11313
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 11313
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 11313
            if (! (it_tile_part < nb_of_tile_part)) {
#line 11313
              goto while_break___2;
            }
            {
#line 11314
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
            }
#line 11313
            it_tile_part ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 11323
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 11324
          it_marker = (OPJ_UINT32 )0;
          {
#line 11324
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 11324
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 11324
              goto while_break___3;
            }
            {
#line 11326
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
            }
#line 11325
            it_marker ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 11306
        it_tile ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 11333
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 11337
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11342 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 


  {
  {
#line 11345
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 11347
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 11348
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 11349
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 11350
  opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                         out_stream);
#line 11352
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11355 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 11360
  if (dev_dump_flag) {
    {
#line 11361
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 11362
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 11364
    fprintf(out_stream, "Image info {\n");
#line 11365
    tab[0] = (char )'\t';
#line 11366
    tab[1] = (char )'\000';
    }
  }
  {
#line 11369
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", (char *)tab, img_header->x0, img_header->y0);
#line 11370
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", (char *)tab, img_header->x1, img_header->y1);
#line 11372
  fprintf(out_stream, "%s numcomps=%d\n", (char *)tab, img_header->numcomps);
  }
#line 11374
  if (img_header->comps) {
#line 11376
    compno = (OPJ_UINT32 )0;
    {
#line 11376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11376
      if (! (compno < img_header->numcomps)) {
#line 11376
        goto while_break;
      }
      {
#line 11377
      fprintf(out_stream, "%s\t component %d {\n", (char *)tab, compno);
#line 11378
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 11380
      fprintf(out_stream, "%s}\n", (char *)tab);
      }
#line 11376
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 11384
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11387 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 11392
  if (dev_dump_flag) {
    {
#line 11393
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 11394
    tab[0] = (char )'\000';
    }
  } else {
#line 11396
    tab[0] = (char )'\t';
#line 11397
    tab[1] = (char )'\t';
#line 11398
    tab[2] = (char )'\000';
  }
  {
#line 11401
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", (char *)tab, comp_header->dx, comp_header->dy);
#line 11402
  fprintf(out_stream, "%s prec=%d\n", (char *)tab, comp_header->prec);
#line 11403
  fprintf(out_stream, "%s sgnd=%d\n", (char *)tab, comp_header->sgnd);
  }
#line 11405
  if (dev_dump_flag) {
    {
#line 11406
    fprintf(out_stream, "}\n");
    }
  }
  return;
}
}
#line 11410 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;

  {
  {
#line 11413
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 11415
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_codestream_info_v2_t ));
#line 11415
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 11417
  if (! cstr_info) {
#line 11418
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 11421
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 11423
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 11424
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 11425
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 11426
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 11427
  cstr_info->tw = p_j2k->m_cp.tw;
#line 11428
  cstr_info->th = p_j2k->m_cp.th;
#line 11430
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 11432
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 11434
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 11435
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 11436
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 11437
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 11439
  __cil_tmp7 = opj_calloc((size_t )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 11439
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 11441
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 11442
    opj_destroy_cstr_info(& cstr_info);
    }
#line 11443
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 11446
  compno = (OPJ_UINT32 )0;
  {
#line 11446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11446
    if (! (compno < numcomps)) {
#line 11446
      goto while_break;
    }
#line 11447
    l_tccp = l_default_tile->tccps + compno;
#line 11448
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 11453
    l_tccp_info->csty = l_tccp->csty;
#line 11454
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 11455
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 11456
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 11457
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 11458
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 11459
    if (l_tccp->numresolutions < 33U) {
      {
#line 11460
      memcpy((OPJ_UINT32 *)l_tccp_info->prch, (OPJ_UINT32 *)l_tccp->prch, (unsigned long )l_tccp->numresolutions);
#line 11461
      memcpy((OPJ_UINT32 *)l_tccp_info->prcw, (OPJ_UINT32 *)l_tccp->prcw, (unsigned long )l_tccp->numresolutions);
      }
    }
#line 11465
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 11466
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 11468
    if (l_tccp->qntsty == 1U) {
#line 11468
      tmp = 1;
    } else {
#line 11468
      tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
    }
#line 11468
    numbands = tmp;
#line 11470
    if (numbands < 97) {
#line 11471
      bandno = 0;
      {
#line 11471
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 11471
        if (! (bandno < numbands)) {
#line 11471
          goto while_break___0;
        }
#line 11472
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 11474
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 11471
        bandno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 11480
    l_tccp_info->roishift = l_tccp->roishift;
#line 11446
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11483
  return (cstr_info);
}
}
#line 11486 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  OPJ_UINT32 __cil_tmp9 ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 11488
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 11488
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 11490
  if (! l_cstr_index) {
#line 11491
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 11494
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 11495
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 11496
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 11498
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 11499
  __cil_tmp4 = opj_malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 11499
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 11501
  if (! l_cstr_index->marker) {
    {
#line 11502
    opj_free(l_cstr_index);
    }
#line 11503
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11506
  if ((p_j2k->cstr_index)->marker) {
    {
#line 11507
    memcpy(l_cstr_index->marker, (p_j2k->cstr_index)->marker, (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 11510
    opj_free(l_cstr_index->marker);
#line 11511
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 11514
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 11515
  __cil_tmp5 = opj_calloc((size_t )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11515
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 11517
  if (! l_cstr_index->tile_index) {
    {
#line 11518
    opj_free(l_cstr_index->marker);
#line 11519
    opj_free(l_cstr_index);
    }
#line 11520
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11523
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 11524
    opj_free(l_cstr_index->tile_index);
#line 11525
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 11527
    it_tile = (OPJ_UINT32 )0;
#line 11528
    it_tile = (OPJ_UINT32 )0;
    {
#line 11528
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11528
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 11528
        goto while_break;
      }
      {
#line 11531
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 11534
      __cil_tmp7 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 11534
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 11538
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 11541
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 11541
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 11541
          if (! (it_tile_free < it_tile)) {
#line 11541
            goto while_break___0;
          }
          {
#line 11542
          opj_free((l_cstr_index->tile_index + it_tile_free)->marker);
          }
#line 11541
          it_tile_free ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 11545
        opj_free(l_cstr_index->tile_index);
#line 11546
        opj_free(l_cstr_index->marker);
#line 11547
        opj_free(l_cstr_index);
        }
#line 11548
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11551
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 11552
        memcpy((l_cstr_index->tile_index + it_tile)->marker, ((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 11556
        opj_free((l_cstr_index->tile_index + it_tile)->marker);
#line 11557
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 11561
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 11564
      __cil_tmp10 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 11564
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 11568
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 11571
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 11571
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 11571
          if (! (it_tile_free___0 < it_tile)) {
#line 11571
            goto while_break___1;
          }
          {
#line 11572
          opj_free((l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 11573
          opj_free((l_cstr_index->tile_index + it_tile_free___0)->tp_index);
          }
#line 11571
          it_tile_free___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 11576
        opj_free(l_cstr_index->tile_index);
#line 11577
        opj_free(l_cstr_index->marker);
#line 11578
        opj_free(l_cstr_index);
        }
#line 11579
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11582
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 11583
        memcpy((l_cstr_index->tile_index + it_tile)->tp_index, ((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 11587
        opj_free((l_cstr_index->tile_index + it_tile)->tp_index);
#line 11588
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 11592
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 11593
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 11528
      it_tile ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 11598
  return (l_cstr_index);
}
}
#line 11601 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;

  {
  {
#line 11603
  it_tile = (OPJ_UINT32 )0;
#line 11605
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 11606
  __cil_tmp3 = opj_calloc((size_t )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11606
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 11608
  if (! (p_j2k->cstr_index)->tile_index) {
#line 11609
    return (0);
  }
#line 11612
  it_tile = (OPJ_UINT32 )0;
  {
#line 11612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11612
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 11612
      goto while_break;
    }
    {
#line 11613
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 11614
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 11615
    __cil_tmp4 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                            sizeof(opj_marker_info_t ));
#line 11615
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 11618
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 11619
      return (0);
    }
#line 11612
    it_tile ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11623
  return (1);
}
}
#line 11626 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_are_all_used_components_decoded(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL decoded_all_used_components ;
  OPJ_UINT32 dec_compno ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 11630
  decoded_all_used_components = 1;
#line 11632
  if (p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 11633
    compno = (OPJ_UINT32 )0;
    {
#line 11633
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11633
      if (! (compno < p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11633
        goto while_break;
      }
#line 11635
      dec_compno = *(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode + compno);
#line 11637
      if (((p_j2k->m_output_image)->comps + dec_compno)->data == (void *)0) {
        {
#line 11638
        opj_event_msg(p_manager, 2, "Failed to decode component %d\n", dec_compno);
#line 11640
        decoded_all_used_components = 0;
        }
      }
#line 11634
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 11644
    compno = (OPJ_UINT32 )0;
    {
#line 11644
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11644
      if (! (compno < (p_j2k->m_output_image)->numcomps)) {
#line 11644
        goto while_break___0;
      }
#line 11645
      if (((p_j2k->m_output_image)->comps + compno)->data == (void *)0) {
        {
#line 11646
        opj_event_msg(p_manager, 2, "Failed to decode component %d\n", compno);
#line 11648
        decoded_all_used_components = 0;
        }
      }
#line 11644
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 11653
  if (decoded_all_used_components == 0) {
    {
#line 11654
    opj_event_msg(p_manager, 1, "Failed to decode all used components\n");
    }
#line 11655
    return (0);
  }
#line 11658
  return (1);
}
}
#line 11662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 nr_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;

  {
#line 11666
  l_go_on = 1;
#line 11670
  nr_tiles = (OPJ_UINT32 )0;
#line 11674
  if (p_j2k->m_cp.tw == 1U) {
#line 11674
    if (p_j2k->m_cp.th == 1U) {
#line 11674
      if (p_j2k->m_cp.tx0 == 0U) {
#line 11674
        if (p_j2k->m_cp.ty0 == 0U) {
#line 11674
          if ((p_j2k->m_output_image)->x0 == 0U) {
#line 11674
            if ((p_j2k->m_output_image)->y0 == 0U) {
#line 11674
              if ((p_j2k->m_output_image)->x1 == p_j2k->m_cp.tdx) {
#line 11674
                if ((p_j2k->m_output_image)->y1 == p_j2k->m_cp.tdy) {
                  {
#line 11681
                  __cil_tmp13 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no,
                                                         (OPJ_UINT32 *)((void *)0),
                                                         & l_tile_x0, & l_tile_y0,
                                                         & l_tile_x1, & l_tile_y1,
                                                         & l_nb_comps, & l_go_on,
                                                         p_stream, p_manager);
                  }
#line 11681
                  if (! __cil_tmp13) {
#line 11690
                    return (0);
                  }
                  {
#line 11693
                  __cil_tmp14 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                                    (OPJ_UINT32 )0, p_stream, p_manager);
                  }
#line 11693
                  if (! __cil_tmp14) {
                    {
#line 11695
                    opj_event_msg(p_manager, 1, "Failed to decode tile 1/1\n");
                    }
#line 11696
                    return (0);
                  }
#line 11700
                  i = (OPJ_UINT32 )0;
                  {
#line 11700
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 11700
                    if (! (i < (p_j2k->m_output_image)->numcomps)) {
#line 11700
                      goto while_break;
                    }
                    {
#line 11701
                    opj_image_data_free(((p_j2k->m_output_image)->comps + i)->data);
#line 11702
                    ((p_j2k->m_output_image)->comps + i)->data = ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data;
#line 11704
                    ((p_j2k->m_output_image)->comps + i)->resno_decoded = (((p_j2k->m_tcd)->image)->comps + i)->resno_decoded;
#line 11706
                    ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data = (OPJ_INT32 *)((void *)0);
                    }
#line 11700
                    i ++;
                  }
                  while_break: /* CIL Label */ ;
                  }
#line 11709
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 11712
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 11712
    if (! 1) {
#line 11712
      goto while_break___0;
    }
#line 11713
    if ((p_j2k->m_cp.tcps + 0)->m_data != (void *)0) {
#line 11713
      if (p_j2k->m_cp.tw == 1U) {
#line 11713
        if (p_j2k->m_cp.th == 1U) {
#line 11715
          l_current_tile_no = (OPJ_UINT32 )0;
#line 11716
          p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 11717
          p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )128;
        } else {
#line 11713
          goto _L;
        }
      } else {
#line 11713
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 11719
      __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                             & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                             & l_tile_y1, & l_nb_comps, & l_go_on,
                                             p_stream, p_manager);
      }
#line 11719
      if (! __cil_tmp16) {
#line 11728
        return (0);
      }
#line 11731
      if (! l_go_on) {
#line 11732
        goto while_break___0;
      }
    }
    {
#line 11736
    __cil_tmp17 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 11736
    if (! __cil_tmp17) {
      {
#line 11738
      opj_event_msg(p_manager, 1, "Failed to decode tile %d/%d\nEV", l_current_tile_no + 1U,
                    p_j2k->m_cp.th * p_j2k->m_cp.tw);
      }
#line 11740
      return (0);
    }
    {
#line 11743
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nV", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 11746
    __cil_tmp18 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 11746
    if (! __cil_tmp18) {
#line 11748
      return (0);
    }
#line 11751
    if (p_j2k->m_cp.tw == 1U) {
#line 11751
      if (p_j2k->m_cp.th == 1U) {
#line 11751
        if (! (! ((((p_j2k->m_output_image)->x0 == (p_j2k->m_private_image)->x0 && (p_j2k->m_output_image)->y0 == (p_j2k->m_private_image)->y0) && (p_j2k->m_output_image)->x1 == (p_j2k->m_private_image)->x1) && (p_j2k->m_output_image)->y1 == (p_j2k->m_private_image)->y1))) {
          {
          {
          {
#line 11758
          opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 11758
        opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 11758
      opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
      }
      }
      }
    }
    {
#line 11761
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
#line 11764
    __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
    }
#line 11764
    if (__cil_tmp19 == 0L) {
#line 11764
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 11766
        goto while_break___0;
      }
    }
#line 11768
    nr_tiles ++;
#line 11768
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 11769
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 11773
  __cil_tmp20 = opj_j2k_are_all_used_components_decoded(p_j2k, p_manager);
  }
#line 11773
  if (! __cil_tmp20) {
#line 11774
    return (0);
  }
#line 11777
  return (1);
}
}
#line 11783 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 11790
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_tiles),
                                                p_manager);
  }
#line 11790
  if (! __cil_tmp3) {
#line 11792
    return (0);
  }
#line 11796
  return (1);
}
}
#line 11802 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 11806
  l_go_on = 1;
#line 11815
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 11816
    __cil_tmp14 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 11816
    if (! __cil_tmp14) {
#line 11817
      return (0);
    }
  }
#line 11821
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 11823
  if ((p_j2k->cstr_index)->tile_index) {
#line 11824
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 11825
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 11828
        __cil_tmp15 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 11828
        if (! __cil_tmp15) {
          {
#line 11830
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
          }
#line 11831
          return (0);
        }
      } else {
        {
#line 11834
        __cil_tmp16 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 11834
        if (! __cil_tmp16) {
          {
#line 11837
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
          }
#line 11838
          return (0);
        }
      }
#line 11842
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 11843
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
#line 11851
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 11852
  i = (OPJ_UINT32 )0;
  {
#line 11852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11852
    if (! (i < l_nb_tiles)) {
#line 11852
      goto while_break;
    }
#line 11853
    (p_j2k->m_cp.tcps + i)->m_current_tile_part_number = - 1;
#line 11852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 11856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 11856
    if (! 1) {
#line 11856
      goto while_break___0;
    }
    {
#line 11857
    __cil_tmp17 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 11857
    if (! __cil_tmp17) {
#line 11866
      return (0);
    }
#line 11869
    if (! l_go_on) {
#line 11870
      goto while_break___0;
    }
    {
#line 11873
    __cil_tmp18 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 11873
    if (! __cil_tmp18) {
#line 11875
      return (0);
    }
    {
#line 11877
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nV", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 11880
    __cil_tmp19 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 11880
    if (! __cil_tmp19) {
#line 11882
      return (0);
    }
    {
#line 11884
    opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
#line 11886
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
    }
#line 11889
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 11891
      __cil_tmp20 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 11891
      if (! __cil_tmp20) {
        {
#line 11893
        opj_event_msg(p_manager, 1, "Problem with seek function\n");
        }
#line 11894
        return (0);
      }
#line 11896
      goto while_break___0;
    } else {
      {
#line 11898
      opj_event_msg(p_manager, 2, "Tile read, decoded and updated is not the desired one (%d vs %d).\n",
                    l_current_tile_no + 1U, l_tile_no_to_dec + 1U);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 11905
  __cil_tmp21 = opj_j2k_are_all_used_components_decoded(p_j2k, p_manager);
  }
#line 11905
  if (! __cil_tmp21) {
#line 11906
    return (0);
  }
#line 11909
  return (1);
}
}
#line 11915 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 11922
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_one_tile),
                                                p_manager);
  }
#line 11922
  if (! __cil_tmp3) {
#line 11924
    return (0);
  }
#line 11928
  return (1);
}
}
#line 11931 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_move_data_from_codec_to_output_image(opj_j2k_t *p_j2k , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *newcomps ;
  void *__cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 src_compno ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;

  {
#line 11937
  if (p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode > 0U) {
    {
#line 11938
    __cil_tmp5 = opj_malloc((unsigned long )p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode * sizeof(opj_image_comp_t ));
#line 11938
    newcomps = (opj_image_comp_t *)__cil_tmp5;
    }
#line 11942
    if (newcomps == (void *)0) {
      {
#line 11943
      opj_image_destroy(p_j2k->m_private_image);
#line 11944
      p_j2k->m_private_image = (opj_image_t *)((void *)0);
      }
#line 11945
      return (0);
    }
#line 11947
    compno = (OPJ_UINT32 )0;
    {
#line 11947
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11947
      if (! (compno < p_image->numcomps)) {
#line 11947
        goto while_break;
      }
      {
#line 11948
      opj_image_data_free((p_image->comps + compno)->data);
#line 11949
      (p_image->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11947
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 11951
    compno = (OPJ_UINT32 )0;
    {
#line 11951
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11951
      if (! (compno < p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11951
        goto while_break___0;
      }
      {
#line 11953
      src_compno = *(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode + compno);
#line 11955
      memcpy(newcomps + compno, (p_j2k->m_output_image)->comps + src_compno, sizeof(opj_image_comp_t ));
#line 11958
      (newcomps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + src_compno)->resno_decoded;
#line 11960
      (newcomps + compno)->data = ((p_j2k->m_output_image)->comps + src_compno)->data;
#line 11961
      ((p_j2k->m_output_image)->comps + src_compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11952
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11963
    compno = (OPJ_UINT32 )0;
    {
#line 11963
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 11963
      if (! (compno < p_image->numcomps)) {
#line 11963
        goto while_break___1;
      }
      {
#line 11965
      opj_image_data_free(((p_j2k->m_output_image)->comps + compno)->data);
#line 11966
      ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11963
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 11968
    p_image->numcomps = p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode;
#line 11969
    opj_free(p_image->comps);
#line 11970
    p_image->comps = newcomps;
    }
  } else {
#line 11972
    compno = (OPJ_UINT32 )0;
    {
#line 11972
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 11972
      if (! (compno < p_image->numcomps)) {
#line 11972
        goto while_break___2;
      }
      {
#line 11973
      (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 11975
      opj_image_data_free((p_image->comps + compno)->data);
#line 11976
      (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 11985
      ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11972
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 11988
  return (1);
}
}
#line 11991 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp6 ;
  opj_image_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 11996
  if (! p_image) {
#line 11997
    return (0);
  }
#line 12004
  if (p_j2k->m_private_image != (void *)0) {
#line 12004
    if (p_j2k->m_cp.m_specific_param.m_dec.m_reduce > 0U) {
#line 12004
      if ((p_j2k->m_private_image)->numcomps > 0U) {
#line 12004
        if (((p_j2k->m_private_image)->comps + 0)->factor == p_j2k->m_cp.m_specific_param.m_dec.m_reduce) {
#line 12004
          if (p_image->numcomps > 0U) {
#line 12004
            if ((p_image->comps + 0)->factor == 0U) {
#line 12004
              if ((p_image->comps + 0)->data == (void *)0) {
#line 12017
                it_comp = (OPJ_UINT32 )0;
                {
#line 12017
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 12017
                  if (! (it_comp < p_image->numcomps)) {
#line 12017
                    goto while_break;
                  }
#line 12018
                  (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 12017
                  it_comp ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 12020
                __cil_tmp6 = opj_j2k_update_image_dimensions(p_image, p_manager);
                }
#line 12020
                if (! __cil_tmp6) {
#line 12021
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 12025
  if (p_j2k->m_output_image == (void *)0) {
    {
#line 12026
    p_j2k->m_output_image = opj_image_create0();
    }
#line 12027
    if (! p_j2k->m_output_image) {
#line 12028
      return (0);
    }
  }
  {
#line 12031
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 12034
  __cil_tmp8 = opj_j2k_setup_decoding(p_j2k, p_manager);
  }
#line 12034
  if (! __cil_tmp8) {
#line 12035
    return (0);
  }
  {
#line 12039
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12039
  if (! __cil_tmp9) {
    {
#line 12040
    opj_image_destroy(p_j2k->m_private_image);
#line 12041
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 12042
    return (0);
  }
  {
#line 12046
  __cil_tmp10 = opj_j2k_move_data_from_codec_to_output_image(p_j2k, p_image);
  }
#line 12046
  return (__cil_tmp10);
}
}
#line 12049 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  opj_image_comp_t *__cil_tmp20 ;
  opj_image_t *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
#line 12059
  if (! p_image) {
    {
#line 12060
    opj_event_msg(p_manager, 1, "We need an image previously created.\n");
    }
#line 12061
    return (0);
  }
#line 12064
  if (p_image->numcomps < (p_j2k->m_private_image)->numcomps) {
    {
#line 12065
    opj_event_msg(p_manager, 1, "Image has less components than codestream.\n");
    }
#line 12067
    return (0);
  }
#line 12070
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 12071
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 12074
    return (0);
  }
#line 12078
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 12079
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 12081
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 12082
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 12083
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 12085
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 12086
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 12087
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 12090
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 12091
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 12092
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 12094
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 12095
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 12096
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 12099
  l_img_comp = p_image->comps;
#line 12100
  compno = (OPJ_UINT32 )0;
  {
#line 12100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12100
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 12100
      goto while_break;
    }
    {
#line 12103
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 12105
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 12105
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 12107
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 12107
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 12109
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 12110
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 12112
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 12112
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 12112
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 12115
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 12115
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 12115
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 12119
    l_img_comp ++;
    }
#line 12100
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12122
  if (p_image->numcomps > (p_j2k->m_private_image)->numcomps) {
#line 12126
    compno = (p_j2k->m_private_image)->numcomps;
    {
#line 12126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12126
      if (! (compno < p_image->numcomps)) {
#line 12126
        goto while_break___0;
      }
      {
#line 12128
      opj_image_data_free((p_image->comps + compno)->data);
#line 12129
      (p_image->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 12127
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 12131
    p_image->numcomps = (p_j2k->m_private_image)->numcomps;
  }
#line 12135
  if (p_j2k->m_output_image) {
    {
#line 12136
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 12140
  p_j2k->m_output_image = opj_image_create0();
  }
#line 12141
  if (! p_j2k->m_output_image) {
#line 12142
    return (0);
  }
  {
#line 12144
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 12146
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 12149
  __cil_tmp22 = opj_j2k_setup_decoding_tile(p_j2k, p_manager);
  }
#line 12149
  if (! __cil_tmp22) {
#line 12150
    return (0);
  }
  {
#line 12154
  __cil_tmp23 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12154
  if (! __cil_tmp23) {
    {
#line 12155
    opj_image_destroy(p_j2k->m_private_image);
#line 12156
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 12157
    return (0);
  }
  {
#line 12161
  __cil_tmp24 = opj_j2k_move_data_from_codec_to_output_image(p_j2k, p_image);
  }
#line 12161
  return (__cil_tmp24);
}
}
#line 12164 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 12170
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 12172
  if (p_j2k->m_private_image) {
#line 12173
    if ((p_j2k->m_private_image)->comps) {
#line 12174
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 12175
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 12176
          it_comp = (OPJ_UINT32 )0;
          {
#line 12176
          while (1) {
            while_continue: /* CIL Label */ ;
#line 12176
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 12176
              goto while_break;
            }
#line 12177
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 12179
            if (res_factor >= max_res) {
              {
#line 12180
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 12182
              return (0);
            }
#line 12184
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 12176
            it_comp ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 12186
          return (1);
        }
      }
    }
  }
#line 12192
  return (0);
}
}
#line 12197 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) 
{ 
  char const   * const  *p_option_iter ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  OPJ_UINT32 tileno ;
  opj_cp_t *cp ;
  int numgbits ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  OPJ_UINT32 i ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 12204
  if (p_options == (void *)0) {
#line 12205
    return (1);
  }
#line 12208
  p_option_iter = p_options;
  {
#line 12208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12208
    if (! (*p_option_iter != (void *)0)) {
#line 12208
      goto while_break;
    }
    {
#line 12209
    __cil_tmp5 = strncmp(*p_option_iter, "PLT=", (unsigned long )4);
    }
#line 12209
    if (__cil_tmp5 == 0) {
      {
#line 12210
      __cil_tmp6 = strcmp(*p_option_iter, "PLT=YES");
      }
#line 12210
      if (__cil_tmp6 == 0) {
#line 12211
        p_j2k->m_specific_param.m_encoder.m_PLT = 1;
      } else {
        {
#line 12212
        __cil_tmp7 = strcmp(*p_option_iter, "PLT=NO");
        }
#line 12212
        if (__cil_tmp7 == 0) {
#line 12213
          p_j2k->m_specific_param.m_encoder.m_PLT = 0;
        } else {
          {
#line 12215
          opj_event_msg(p_manager, 1, "Invalid value for option: %s.\n", *p_option_iter);
          }
#line 12217
          return (0);
        }
      }
    } else {
      {
#line 12219
      __cil_tmp8 = strncmp(*p_option_iter, "TLM=", (unsigned long )4);
      }
#line 12219
      if (__cil_tmp8 == 0) {
        {
#line 12220
        __cil_tmp9 = strcmp(*p_option_iter, "TLM=YES");
        }
#line 12220
        if (__cil_tmp9 == 0) {
#line 12221
          p_j2k->m_specific_param.m_encoder.m_TLM = 1;
        } else {
          {
#line 12222
          __cil_tmp10 = strcmp(*p_option_iter, "TLM=NO");
          }
#line 12222
          if (__cil_tmp10 == 0) {
#line 12223
            p_j2k->m_specific_param.m_encoder.m_TLM = 0;
          } else {
            {
#line 12225
            opj_event_msg(p_manager, 1, "Invalid value for option: %s.\n", *p_option_iter);
            }
#line 12227
            return (0);
          }
        }
      } else {
        {
#line 12229
        __cil_tmp11 = strlen("GUARD_BITS=");
#line 12229
        __cil_tmp12 = strncmp(*p_option_iter, "GUARD_BITS=", __cil_tmp11);
        }
#line 12229
        if (__cil_tmp12 == 0) {
          {
#line 12231
          cp = & p_j2k->m_cp;
#line 12231
          cp = cp;
#line 12233
          __cil_tmp16 = strlen("GUARD_BITS=");
#line 12233
          __cil_tmp17 = atoi(*p_option_iter + __cil_tmp16);
#line 12233
          numgbits = __cil_tmp17;
          }
#line 12234
          if (numgbits < 0) {
            {
            {
#line 12235
            opj_event_msg(p_manager, 1, "Invalid value for option: %s. Should be in [0,7]\n",
                          *p_option_iter);
            }
            }
#line 12237
            return (0);
          } else
#line 12234
          if (numgbits > 7) {
            {
            {
#line 12235
            opj_event_msg(p_manager, 1, "Invalid value for option: %s. Should be in [0,7]\n",
                          *p_option_iter);
            }
            }
#line 12237
            return (0);
          }
#line 12240
          tileno = (OPJ_UINT32 )0;
          {
#line 12240
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 12240
            if (! (tileno < cp->tw * cp->th)) {
#line 12240
              goto while_break___0;
            }
#line 12242
            tcp = cp->tcps + tileno;
#line 12243
            i = (OPJ_UINT32 )0;
            {
#line 12243
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 12243
              if (! (i < p_j2k->m_specific_param.m_encoder.m_nb_comps)) {
#line 12243
                goto while_break___1;
              }
#line 12244
              tccp = tcp->tccps + i;
#line 12245
              tccp->numgbits = (OPJ_UINT32 )numgbits;
#line 12243
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 12240
            tileno ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 12249
          opj_event_msg(p_manager, 1, "Invalid option: %s.\n", *p_option_iter);
          }
#line 12251
          return (0);
        }
      }
    }
#line 12208
    p_option_iter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12255
  return (1);
}
}
#line 12260 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_SIZE_T l_max_tile_size ;
  OPJ_SIZE_T l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_BOOL l_reuse_data ;
  opj_tcd_t *p_tcd ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp___0 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp17 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 12266
  l_max_tile_size = (OPJ_SIZE_T )0;
#line 12267
  l_current_data = (OPJ_BYTE *)0;
#line 12268
  l_reuse_data = 0;
#line 12269
  p_tcd = (opj_tcd_t *)0;
#line 12276
  p_tcd = p_j2k->m_tcd;
#line 12278
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 12279
  if (l_nb_tiles == 1U) {
#line 12280
    l_reuse_data = 1;
#line 12282
    j = (OPJ_UINT32 )0;
    {
#line 12282
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12282
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 12282
        goto while_break;
      }
#line 12283
      l_img_comp = (p_tcd->image)->comps + j;
#line 12284
      if (((size_t )l_img_comp->data & 15UL) != 0UL) {
#line 12286
        l_reuse_data = 0;
      }
#line 12282
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 12291
  i = (OPJ_UINT32 )0;
  {
#line 12291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 12291
    if (! (i < l_nb_tiles)) {
#line 12291
      goto while_break___0;
    }
    {
#line 12292
    __cil_tmp13 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 12292
    if (! __cil_tmp13) {
#line 12293
      if (l_current_data) {
        {
#line 12294
        opj_free(l_current_data);
        }
      }
#line 12296
      return (0);
    }
#line 12301
    j = (OPJ_UINT32 )0;
    {
#line 12301
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12301
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 12301
        goto while_break___1;
      }
#line 12302
      l_tilec = ((p_tcd->tcd_image)->tiles)->comps + j;
#line 12303
      if (l_reuse_data) {
#line 12304
        l_img_comp___0 = (p_tcd->image)->comps + j;
#line 12305
        l_tilec->data = l_img_comp___0->data;
#line 12306
        l_tilec->ownsData = 0;
      } else {
        {
#line 12308
        __cil_tmp16 = opj_alloc_tile_component_data(l_tilec);
        }
#line 12308
        if (! __cil_tmp16) {
          {
#line 12309
          opj_event_msg(p_manager, 1, "Error allocating tile component data.");
          }
#line 12310
          if (l_current_data) {
            {
#line 12311
            opj_free(l_current_data);
            }
          }
#line 12313
          return (0);
        }
      }
#line 12301
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 12317
    l_current_tile_size = opj_tcd_get_encoder_input_buffer_size(p_j2k->m_tcd);
    }
#line 12318
    if (! l_reuse_data) {
#line 12319
      if (l_current_tile_size > l_max_tile_size) {
        {
#line 12320
        __cil_tmp19 = opj_realloc(l_current_data, l_current_tile_size);
#line 12320
        l_new_current_data = (OPJ_BYTE *)__cil_tmp19;
        }
#line 12322
        if (! l_new_current_data) {
#line 12323
          if (l_current_data) {
            {
#line 12324
            opj_free(l_current_data);
            }
          }
          {
#line 12326
          opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
          }
#line 12327
          return (0);
        }
#line 12329
        l_current_data = l_new_current_data;
#line 12330
        l_max_tile_size = l_current_tile_size;
      }
#line 12332
      if (l_current_data == (void *)0) {
#line 12336
        return (0);
      }
      {
#line 12342
      opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 12345
      __cil_tmp20 = opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data, l_current_tile_size);
      }
#line 12345
      if (! __cil_tmp20) {
        {
#line 12347
        opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
#line 12349
        opj_free(l_current_data);
        }
#line 12350
        return (0);
      }
    }
    {
#line 12354
    __cil_tmp21 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 12354
    if (! __cil_tmp21) {
#line 12355
      if (l_current_data) {
        {
#line 12356
        opj_free(l_current_data);
        }
      }
#line 12358
      return (0);
    }
#line 12291
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 12362
  if (l_current_data) {
    {
#line 12363
    opj_free(l_current_data);
    }
  }
#line 12365
  return (1);
}
}
#line 12368 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 12373
  __cil_tmp4 = opj_j2k_setup_end_compress(p_j2k, p_manager);
  }
#line 12373
  if (! __cil_tmp4) {
#line 12374
    return (0);
  }
  {
#line 12377
  __cil_tmp5 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12377
  if (! __cil_tmp5) {
#line 12378
    return (0);
  }
#line 12381
  return (1);
}
}
#line 12384 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  opj_image_t *__cil_tmp5 ;
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 12394
  p_j2k->m_private_image = opj_image_create0();
  }
#line 12395
  if (! p_j2k->m_private_image) {
    {
#line 12396
    opj_event_msg(p_manager, 1, "Failed to allocate image header.\220");
    }
#line 12397
    return (0);
  }
  {
#line 12399
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 12402
  if (p_image->comps) {
#line 12404
    it_comp = (OPJ_UINT32 )0;
    {
#line 12404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12404
      if (! (it_comp < p_image->numcomps)) {
#line 12404
        goto while_break;
      }
#line 12405
      if ((p_image->comps + it_comp)->data) {
#line 12406
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 12407
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 12404
      it_comp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 12414
  __cil_tmp8 = opj_j2k_setup_encoding_validation(p_j2k, p_manager);
  }
#line 12414
  if (! __cil_tmp8) {
#line 12415
    return (0);
  }
  {
#line 12419
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 12419
  if (! __cil_tmp9) {
#line 12420
    return (0);
  }
  {
#line 12424
  __cil_tmp10 = opj_j2k_setup_header_writing(p_j2k, p_manager);
  }
#line 12424
  if (! __cil_tmp10) {
#line 12425
    return (0);
  }
  {
#line 12429
  __cil_tmp11 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12429
  if (! __cil_tmp11) {
#line 12430
    return (0);
  }
#line 12433
  return (1);
}
}
#line 12436 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 12442
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 12443
    opj_event_msg(p_manager, 1, "The given tile index does not match.");
    }
#line 12444
    return (0);
  }
  {
#line 12447
  opj_event_msg(p_manager, 4, "tile number %d / %d\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 12450
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 12451
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 12452
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12455
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                        p_manager);
  }
#line 12455
  if (! __cil_tmp5) {
#line 12457
    return (0);
  }
#line 12460
  return (1);
}
}
#line 12463 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) 
{ 
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 12476
  *l_size_comp = l_img_comp->prec >> 3;
#line 12477
  l_remaining = l_img_comp->prec & 7U;
#line 12478
  if (l_remaining) {
#line 12479
    *l_size_comp += (unsigned int )1;
  }
#line 12482
  if (*l_size_comp == 3U) {
#line 12483
    *l_size_comp = (OPJ_UINT32 )4;
  }
  {
#line 12486
  *l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 12487
  *l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 12488
  __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 12488
  *l_offset_x = (OPJ_UINT32 )__cil_tmp13;
#line 12490
  __cil_tmp14 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 12490
  *l_offset_y = (OPJ_UINT32 )__cil_tmp14;
#line 12492
  __cil_tmp15 = opj_int_ceildiv((OPJ_INT32 )l_image->x1 - (OPJ_INT32 )l_image->x0,
                                (OPJ_INT32 )l_img_comp->dx);
#line 12492
  *l_image_width = (OPJ_UINT32 )__cil_tmp15;
#line 12494
  *l_stride = *l_image_width - *l_width;
#line 12495
  *l_tile_offset = ((OPJ_UINT32 )l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32 )l_tilec->y0 - *l_offset_y) * *l_image_width;
  }
  return;
}
}
#line 12499 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_image_t *l_image ;
  OPJ_INT32 *l_src_ptr ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_tile_offset ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;

  {
#line 12501
  k = (OPJ_UINT32 )0;
#line 12503
  i = (OPJ_UINT32 )0;
  {
#line 12503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12503
    if (! (i < (p_tcd->image)->numcomps)) {
#line 12503
      goto while_break;
    }
    {
#line 12504
    l_image = p_tcd->image;
#line 12506
    l_tilec = ((p_tcd->tcd_image)->tiles)->comps + i;
#line 12507
    l_img_comp = l_image->comps + i;
#line 12511
    opj_get_tile_dimensions(l_image, l_tilec, l_img_comp, & l_size_comp, & l_width,
                            & l_height, & l_offset_x, & l_offset_y, & l_image_width,
                            & l_stride, & l_tile_offset);
#line 12523
    l_src_ptr = l_img_comp->data + l_tile_offset;
    }
    {
#line 12526
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 12526
      goto case_1;
    }
#line 12551
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 12551
      goto case_2;
    }
#line 12572
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 12572
      goto case_4;
    }
#line 12525
    goto switch_break;
    case_1: /* CIL Label */ 
#line 12527
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 12528
    if (l_img_comp->sgnd) {
#line 12529
      j = (OPJ_UINT32 )0;
      {
#line 12529
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 12529
        if (! (j < l_height)) {
#line 12529
          goto while_break___0;
        }
#line 12530
        k = (OPJ_UINT32 )0;
        {
#line 12530
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 12530
          if (! (k < l_width)) {
#line 12530
            goto while_break___1;
          }
#line 12531
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 12532
          l_dest_ptr ++;
#line 12533
          l_src_ptr ++;
#line 12530
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 12535
        l_src_ptr += l_stride;
#line 12529
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 12538
      j = (OPJ_UINT32 )0;
      {
#line 12538
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 12538
        if (! (j < l_height)) {
#line 12538
          goto while_break___2;
        }
#line 12539
        k = (OPJ_UINT32 )0;
        {
#line 12539
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 12539
          if (! (k < l_width)) {
#line 12539
            goto while_break___3;
          }
#line 12540
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 12541
          l_dest_ptr ++;
#line 12542
          l_src_ptr ++;
#line 12539
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 12544
        l_src_ptr += l_stride;
#line 12538
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 12548
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 12550
    goto switch_break;
    case_2: /* CIL Label */ 
#line 12552
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 12553
    if (l_img_comp->sgnd) {
#line 12554
      j = (OPJ_UINT32 )0;
      {
#line 12554
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 12554
        if (! (j < l_height)) {
#line 12554
          goto while_break___4;
        }
#line 12555
        k = (OPJ_UINT32 )0;
        {
#line 12555
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 12555
          if (! (k < l_width)) {
#line 12555
            goto while_break___5;
          }
#line 12556
          __cil_tmp21 = l_src_ptr;
#line 12556
          l_src_ptr ++;
#line 12556
          __cil_tmp20 = l_dest_ptr___0;
#line 12556
          l_dest_ptr___0 ++;
#line 12556
          *__cil_tmp20 = (OPJ_INT16 )*__cil_tmp21;
#line 12555
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 12558
        l_src_ptr += l_stride;
#line 12554
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 12561
      j = (OPJ_UINT32 )0;
      {
#line 12561
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 12561
        if (! (j < l_height)) {
#line 12561
          goto while_break___6;
        }
#line 12562
        k = (OPJ_UINT32 )0;
        {
#line 12562
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 12562
          if (! (k < l_width)) {
#line 12562
            goto while_break___7;
          }
#line 12563
          __cil_tmp23 = l_src_ptr;
#line 12563
          l_src_ptr ++;
#line 12563
          __cil_tmp22 = l_dest_ptr___0;
#line 12563
          l_dest_ptr___0 ++;
#line 12563
          *__cil_tmp22 = (OPJ_INT16 )(*__cil_tmp23 & 65535);
#line 12562
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 12565
        l_src_ptr += l_stride;
#line 12561
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 12569
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 12571
    goto switch_break;
    case_4: /* CIL Label */ 
#line 12573
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 12574
    j = (OPJ_UINT32 )0;
    {
#line 12574
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 12574
      if (! (j < l_height)) {
#line 12574
        goto while_break___8;
      }
#line 12575
      k = (OPJ_UINT32 )0;
      {
#line 12575
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 12575
        if (! (k < l_width)) {
#line 12575
          goto while_break___9;
        }
#line 12576
        __cil_tmp26 = l_src_ptr;
#line 12576
        l_src_ptr ++;
#line 12576
        __cil_tmp25 = l_dest_ptr___1;
#line 12576
        l_dest_ptr___1 ++;
#line 12576
        *__cil_tmp25 = *__cil_tmp26;
#line 12575
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 12578
      l_src_ptr += l_stride;
#line 12574
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 12581
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 12583
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 12503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 12588 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_SIZE_T __cil_tmp10 ;

  {
  {
#line 12593
  l_current_data = (OPJ_BYTE *)0;
#line 12594
  l_tile_size = (OPJ_UINT32 )0;
#line 12600
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 12601
  l_available_data = l_tile_size;
#line 12602
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 12604
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12605
  __cil_tmp8 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 12605
  if (! __cil_tmp8) {
#line 12607
    return (0);
  }
  {
#line 12609
  l_current_data += l_nb_bytes_written;
#line 12610
  l_available_data -= l_nb_bytes_written;
#line 12612
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12613
  __cil_tmp9 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                            l_available_data, p_stream, p_manager);
  }
#line 12613
  if (! __cil_tmp9) {
#line 12615
    return (0);
  }
  {
#line 12618
  l_available_data -= l_nb_bytes_written;
#line 12619
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 12621
  __cil_tmp10 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 12621
  if (__cil_tmp10 != (unsigned long )l_nb_bytes_written) {
#line 12624
    return (0);
  }
#line 12627
  (p_j2k->m_current_tile_number) ++;
#line 12629
  return (1);
}
}
#line 12632 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 12640
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_eoc),
                                                p_manager);
  }
#line 12640
  if (! __cil_tmp3) {
#line 12642
    return (0);
  }
#line 12645
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12646
    __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_updated_tlm),
                                                  p_manager);
    }
#line 12646
    if (! __cil_tmp4) {
#line 12648
      return (0);
    }
  }
  {
#line 12652
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_epc),
                                                p_manager);
  }
#line 12652
  if (! __cil_tmp5) {
#line 12654
    return (0);
  }
  {
#line 12656
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_end_encoding),
                                                p_manager);
  }
#line 12656
  if (! __cil_tmp6) {
#line 12658
    return (0);
  }
  {
#line 12660
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_destroy_header_memory),
                                                p_manager);
  }
#line 12660
  if (! __cil_tmp7) {
#line 12662
    return (0);
  }
#line 12664
  return (1);
}
}
#line 12667 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 12674
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_encoder),
                                                p_manager);
  }
#line 12674
  if (! __cil_tmp3) {
#line 12676
    return (0);
  }
  {
#line 12678
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_encoding_validation),
                                                p_manager);
  }
#line 12678
  if (! __cil_tmp4) {
#line 12680
    return (0);
  }
  {
#line 12684
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_mct_validation),
                                                p_manager);
  }
#line 12684
  if (! __cil_tmp5) {
#line 12686
    return (0);
  }
#line 12689
  return (1);
}
}
#line 12692 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;

  {
  {
#line 12699
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_init_info),
                                                p_manager);
  }
#line 12699
  if (! __cil_tmp3) {
#line 12701
    return (0);
  }
  {
#line 12703
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_soc),
                                                p_manager);
  }
#line 12703
  if (! __cil_tmp4) {
#line 12705
    return (0);
  }
  {
#line 12707
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_siz),
                                                p_manager);
  }
#line 12707
  if (! __cil_tmp5) {
#line 12709
    return (0);
  }
  {
#line 12711
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_cod),
                                                p_manager);
  }
#line 12711
  if (! __cil_tmp6) {
#line 12713
    return (0);
  }
  {
#line 12715
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_qcd),
                                                p_manager);
  }
#line 12715
  if (! __cil_tmp7) {
#line 12717
    return (0);
  }
  {
#line 12719
  __cil_tmp8 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_all_coc),
                                                p_manager);
  }
#line 12719
  if (! __cil_tmp8) {
#line 12721
    return (0);
  }
  {
#line 12723
  __cil_tmp9 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_all_qcc),
                                                p_manager);
  }
#line 12723
  if (! __cil_tmp9) {
#line 12725
    return (0);
  }
#line 12728
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12729
    __cil_tmp10 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_tlm),
                                                   p_manager);
    }
#line 12729
    if (! __cil_tmp10) {
#line 12731
      return (0);
    }
#line 12734
    if ((int )p_j2k->m_cp.rsiz == 4) {
      {
#line 12735
      __cil_tmp11 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_poc),
                                                     p_manager);
      }
#line 12735
      if (! __cil_tmp11) {
#line 12737
        return (0);
      }
    }
  }
  {
#line 12742
  __cil_tmp12 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_regions),
                                                 p_manager);
  }
#line 12742
  if (! __cil_tmp12) {
#line 12744
    return (0);
  }
#line 12747
  if (p_j2k->m_cp.comment != (OPJ_CHAR *)0) {
    {
#line 12748
    __cil_tmp13 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_com),
                                                   p_manager);
    }
#line 12748
    if (! __cil_tmp13) {
#line 12750
      return (0);
    }
  }
#line 12755
  if (((int )p_j2k->m_cp.rsiz & 33024) == 33024) {
    {
#line 12757
    __cil_tmp14 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_mct_data_group),
                                                   p_manager);
    }
#line 12757
    if (! __cil_tmp14) {
#line 12759
      return (0);
    }
  }
#line 12764
  if (p_j2k->cstr_index) {
    {
#line 12765
    __cil_tmp15 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_get_end_header),
                                                   p_manager);
    }
#line 12765
    if (! __cil_tmp15) {
#line 12767
      return (0);
    }
  }
  {
#line 12771
  __cil_tmp16 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_create_tcd),
                                                 p_manager);
  }
#line 12771
  if (! __cil_tmp16) {
#line 12773
    return (0);
  }
  {
#line 12775
  __cil_tmp17 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_update_rates),
                                                 p_manager);
  }
#line 12775
  if (! __cil_tmp17) {
#line 12777
    return (0);
  }
#line 12780
  return (1);
}
}
#line 12783 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 12790
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12792
  l_begin_data = (OPJ_BYTE *)0;
#line 12794
  l_tcd = (opj_tcd_t *)0;
#line 12795
  l_cp = (opj_cp_t *)0;
#line 12797
  l_tcd = p_j2k->m_tcd;
#line 12798
  l_cp = & p_j2k->m_cp;
#line 12800
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 12803
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12808
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12809
  l_begin_data = p_data;
#line 12810
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                  p_stream, p_manager);
  }
#line 12810
  if (! __cil_tmp12) {
#line 12813
    return (0);
  }
#line 12816
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 12817
  p_data += l_current_nb_bytes_written;
#line 12818
  total_data_size -= l_current_nb_bytes_written;
#line 12820
  if (! ((int )l_cp->rsiz >= 3 && (int )l_cp->rsiz <= 6)) {
#line 12838
    if ((l_cp->tcps + p_j2k->m_current_tile_number)->POC) {
      {
#line 12839
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12840
      opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 12842
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12843
      p_data += l_current_nb_bytes_written;
#line 12844
      total_data_size -= l_current_nb_bytes_written;
      }
    }
  }
  {
#line 12848
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12849
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  total_data_size, p_stream, p_manager);
  }
#line 12849
  if (! __cil_tmp13) {
#line 12851
    return (0);
  }
  {
#line 12854
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 12855
  *p_data_written = l_nb_bytes_written;
#line 12858
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 12861
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12862
    opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
    }
  }
#line 12865
  return (1);
}
}
#line 12868 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 12876
  tilepartno = (OPJ_UINT32 )0;
#line 12877
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12884
  l_tcp = (opj_tcp_t *)0;
#line 12885
  l_tcd = (opj_tcd_t *)0;
#line 12886
  l_cp = (opj_cp_t *)0;
#line 12888
  l_tcd = p_j2k->m_tcd;
#line 12889
  l_cp = & p_j2k->m_cp;
#line 12890
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 12893
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 12896
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12897
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 12897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12897
    if (! (tilepartno < tot_num_tp)) {
#line 12897
      goto while_break;
    }
    {
#line 12898
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12899
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12900
    l_part_tile_size = (OPJ_UINT32 )0;
#line 12901
    l_begin_data = p_data;
#line 12903
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                    p_stream, p_manager);
    }
#line 12903
    if (! __cil_tmp18) {
#line 12908
      return (0);
    }
    {
#line 12911
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 12912
    p_data += l_current_nb_bytes_written;
#line 12913
    total_data_size -= l_current_nb_bytes_written;
#line 12914
    l_part_tile_size += l_current_nb_bytes_written;
#line 12916
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12917
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    total_data_size, p_stream, p_manager);
    }
#line 12917
    if (! __cil_tmp19) {
#line 12919
      return (0);
    }
    {
#line 12922
    p_data += l_current_nb_bytes_written;
#line 12923
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 12924
    total_data_size -= l_current_nb_bytes_written;
#line 12925
    l_part_tile_size += l_current_nb_bytes_written;
#line 12928
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 12931
    if (p_j2k->m_specific_param.m_encoder.m_TLM) {
      {
#line 12932
      opj_j2k_update_tlm(p_j2k, l_part_tile_size);
      }
    }
#line 12935
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12897
    tilepartno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12938
  pino = (OPJ_UINT32 )1;
  {
#line 12938
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 12938
    if (! (pino <= l_tcp->numpocs)) {
#line 12938
      goto while_break___0;
    }
    {
#line 12939
    l_tcd->cur_pino = pino;
#line 12942
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 12943
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 12943
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12943
      if (! (tilepartno < tot_num_tp)) {
#line 12943
        goto while_break___1;
      }
      {
#line 12944
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12945
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12946
      l_part_tile_size = (OPJ_UINT32 )0;
#line 12947
      l_begin_data = p_data;
#line 12949
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 12949
      if (! __cil_tmp21) {
#line 12953
        return (0);
      }
      {
#line 12956
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12957
      p_data += l_current_nb_bytes_written;
#line 12958
      total_data_size -= l_current_nb_bytes_written;
#line 12959
      l_part_tile_size += l_current_nb_bytes_written;
#line 12961
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12963
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      total_data_size, p_stream, p_manager);
      }
#line 12963
      if (! __cil_tmp22) {
#line 12965
        return (0);
      }
      {
#line 12968
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12969
      p_data += l_current_nb_bytes_written;
#line 12970
      total_data_size -= l_current_nb_bytes_written;
#line 12971
      l_part_tile_size += l_current_nb_bytes_written;
#line 12974
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 12977
      if (p_j2k->m_specific_param.m_encoder.m_TLM) {
        {
#line 12978
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
#line 12981
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12943
      tilepartno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 12938
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 12985
  *p_data_written = l_nb_bytes_written;
#line 12987
  return (1);
}
}
#line 12990 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_UINT32 size_per_tile_part ;
  int tmp ;
  OPJ_OFF_T __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 13003
  if (p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte) {
#line 13003
    tmp = 5;
  } else {
#line 13003
    tmp = 6;
  }
  {
#line 13003
  size_per_tile_part = (OPJ_UINT32 )tmp;
#line 13004
  l_tlm_size = size_per_tile_part * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 13006
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 13007
  l_current_position = opj_stream_tell(p_stream);
#line 13009
  __cil_tmp10 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 13009
  if (! __cil_tmp10) {
#line 13010
    return (0);
  }
  {
#line 13013
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 13013
  if (__cil_tmp11 != (unsigned long )l_tlm_size) {
#line 13016
    return (0);
  }
  {
#line 13019
  __cil_tmp12 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 13019
  if (! __cil_tmp12) {
#line 13020
    return (0);
  }
#line 13023
  return (1);
}
}
#line 13026 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 13038
  opj_tcd_destroy(p_j2k->m_tcd);
#line 13039
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 13041
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 13042
    opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 13043
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 13044
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 13047
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 13048
    opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 13049
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 13052
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 13054
  return (1);
}
}
#line 13060 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 


  {
#line 13073
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 13074
    opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 13075
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 13078
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 13080
  return (1);
}
}
#line 13083 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 13087
  l_cstr_info = (opj_codestream_info_t *)0;
#line 13136
  __cil_tmp5 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 13136
  return (__cil_tmp5);
}
}
#line 13148 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_t *__cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 13160
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 13162
  if (! p_j2k->m_tcd) {
    {
#line 13163
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 13164
    return (0);
  }
  {
#line 13167
  __cil_tmp5 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 13167
  if (! __cil_tmp5) {
    {
#line 13169
    opj_tcd_destroy(p_j2k->m_tcd);
#line 13170
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 13171
    return (0);
  }
#line 13174
  return (1);
}
}
#line 13177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_UINT32 j ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 13184
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 13184
  if (! __cil_tmp7) {
    {
#line 13185
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 13187
    return (0);
  } else {
#line 13191
    j = (OPJ_UINT32 )0;
    {
#line 13191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 13191
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 13191
        goto while_break;
      }
      {
#line 13192
      l_tilec = (((p_j2k->m_tcd)->tcd_image)->tiles)->comps + j;
#line 13194
      __cil_tmp10 = opj_alloc_tile_component_data(l_tilec);
      }
#line 13194
      if (! __cil_tmp10) {
        {
#line 13195
        opj_event_msg(p_manager, 1, "Error allocating tile component data.");
        }
#line 13196
        return (0);
      }
#line 13191
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 13201
    __cil_tmp11 = opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, (OPJ_SIZE_T )p_data_size);
    }
#line 13201
    if (! __cil_tmp11) {
      {
#line 13202
      opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
      }
#line 13204
      return (0);
    }
    {
#line 13206
    __cil_tmp12 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 13206
    if (! __cil_tmp12) {
      {
#line 13207
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 13209
      return (0);
    }
  }
#line 13213
  return (1);
}
}
#line 37 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo ) ;
#line 44
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) ;
#line 54
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                          OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                          OPJ_FLOAT32 *p_swap_area ) ;
#line 70 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.c"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) 
{ 
  OPJ_BYTE *l_data ;
  OPJ_UINT32 l_permutation_size ;
  OPJ_UINT32 l_swap_size ;
  OPJ_UINT32 l_total_size ;
  OPJ_UINT32 *lPermutations ;
  OPJ_FLOAT32 *l_double_data ;
  void *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 74
  l_data = (OPJ_BYTE *)0;
#line 75
  l_permutation_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 76
  l_swap_size = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 77
  l_total_size = l_permutation_size + 3U * l_swap_size;
#line 78
  lPermutations = (OPJ_UINT32 *)0;
#line 79
  l_double_data = (OPJ_FLOAT32 *)0;
#line 81
  __cil_tmp10 = opj_malloc((size_t )l_total_size);
#line 81
  l_data = (OPJ_BYTE *)__cil_tmp10;
  }
#line 82
  if (l_data == (OPJ_BYTE *)0) {
#line 83
    return (0);
  }
  {
#line 85
  lPermutations = (OPJ_UINT32 *)l_data;
#line 86
  l_double_data = (OPJ_FLOAT32 *)(l_data + l_permutation_size);
#line 87
  memset(lPermutations, 0, (unsigned long )l_permutation_size);
#line 89
  __cil_tmp11 = opj_lupDecompose(pSrcMatrix, lPermutations, l_double_data, nb_compo);
  }
#line 89
  if (! __cil_tmp11) {
    {
#line 90
    opj_free(l_data);
    }
#line 91
    return (0);
  }
  {
#line 94
  opj_lupInvert(pSrcMatrix, pDestMatrix, nb_compo, lPermutations, l_double_data, l_double_data + nb_compo,
                l_double_data + 2U * nb_compo);
#line 96
  opj_free(l_data);
  }
#line 98
  return (1);
}
}
#line 107 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.c"
static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 *matrix , OPJ_UINT32 *permutations ,
                                 OPJ_FLOAT32 *p_swap_area , OPJ_UINT32 nb_compo ) 
{ 
  OPJ_UINT32 *tmpPermutations ;
  OPJ_UINT32 *dstPermutations ;
  OPJ_UINT32 k2 ;
  OPJ_UINT32 t ;
  OPJ_FLOAT32 temp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_FLOAT32 p ;
  OPJ_UINT32 lLastColum ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lColumnMatrix ;
  OPJ_FLOAT32 *lDestMatrix ;
  OPJ_UINT32 offset ;
  OPJ_UINT32 lStride ;
  OPJ_UINT32 *__cil_tmp21 ;
  OPJ_FLOAT32 tmp ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_FLOAT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;

  {
#line 112
  tmpPermutations = permutations;
#line 114
  k2 = (OPJ_UINT32 )0;
#line 118
  lLastColum = nb_compo - 1U;
#line 119
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 120
  lTmpMatrix = matrix;
#line 122
  offset = (OPJ_UINT32 )1;
#line 123
  lStride = nb_compo - 1U;
#line 126
  i = (OPJ_UINT32 )0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (i < nb_compo)) {
#line 126
      goto while_break;
    }
#line 127
    __cil_tmp21 = tmpPermutations;
#line 127
    tmpPermutations ++;
#line 127
    *__cil_tmp21 = i;
#line 126
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  tmpPermutations = permutations;
#line 131
  k = (OPJ_UINT32 )0;
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    if (! (k < lLastColum)) {
#line 131
      goto while_break___0;
    }
#line 132
    p = (OPJ_FLOAT32 )0.;
#line 135
    lColumnMatrix = lTmpMatrix + k;
#line 138
    i = k;
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 138
      if (! (i < nb_compo)) {
#line 138
        goto while_break___1;
      }
#line 139
      if (*lColumnMatrix > (float )0) {
#line 139
        tmp = *lColumnMatrix;
      } else {
#line 139
        tmp = - *lColumnMatrix;
      }
#line 139
      temp = tmp;
#line 140
      if (temp > p) {
#line 141
        p = temp;
#line 142
        k2 = i;
      }
#line 145
      lColumnMatrix += nb_compo;
#line 138
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 149
    if ((double )p == 0.) {
#line 150
      return (0);
    }
#line 154
    if (k2 != k) {
      {
#line 157
      dstPermutations = (tmpPermutations + k2) - k;
#line 159
      t = *tmpPermutations;
#line 160
      *tmpPermutations = *dstPermutations;
#line 161
      *dstPermutations = t;
#line 164
      lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
#line 165
      memcpy(p_swap_area, lColumnMatrix, (unsigned long )lSwapSize);
#line 166
      memcpy(lColumnMatrix, lTmpMatrix, (unsigned long )lSwapSize);
#line 167
      memcpy(lTmpMatrix, p_swap_area, (unsigned long )lSwapSize);
      }
    }
#line 171
    lDestMatrix = lTmpMatrix + k;
#line 172
    lColumnMatrix = lDestMatrix + nb_compo;
#line 174
    __cil_tmp23 = lDestMatrix;
#line 174
    lDestMatrix ++;
#line 174
    temp = *__cil_tmp23;
#line 177
    i = offset;
    {
#line 177
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 177
      if (! (i < nb_compo)) {
#line 177
        goto while_break___2;
      }
#line 183
      p = *lColumnMatrix / temp;
#line 184
      __cil_tmp24 = lColumnMatrix;
#line 184
      lColumnMatrix ++;
#line 184
      *__cil_tmp24 = p;
#line 186
      j = offset;
      {
#line 186
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 186
        if (! (j < nb_compo)) {
#line 186
          goto while_break___3;
        }
#line 188
        __cil_tmp26 = lDestMatrix;
#line 188
        lDestMatrix ++;
#line 188
        __cil_tmp25 = lColumnMatrix;
#line 188
        lColumnMatrix ++;
#line 188
        *__cil_tmp25 -= p * *__cil_tmp26;
#line 186
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 191
      lDestMatrix -= lStride;
#line 193
      lColumnMatrix += k;
#line 177
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 197
    offset ++;
#line 199
    lStride --;
#line 201
    lTmpMatrix += nb_compo;
#line 203
    tmpPermutations ++;
#line 131
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return (1);
}
}
#line 208 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.c"
static void opj_lupSolve(OPJ_FLOAT32 *pResult , OPJ_FLOAT32 *pMatrix , OPJ_FLOAT32 *pVector ,
                         OPJ_UINT32 *pPermutations , OPJ_UINT32 nb_compo , OPJ_FLOAT32 *p_intermediate_data ) 
{ 
  OPJ_INT32 k ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_FLOAT32 sum ;
  OPJ_FLOAT32 u ;
  OPJ_UINT32 lStride ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lIntermediatePtr ;
  OPJ_FLOAT32 *lDestPtr ;
  OPJ_FLOAT32 *lTmpMatrix ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_FLOAT32 *lBeginPtr ;
  OPJ_FLOAT32 *lGeneratedData ;
  OPJ_UINT32 *lCurrentPermutationPtr ;
  OPJ_FLOAT32 *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  OPJ_FLOAT32 *__cil_tmp23 ;
  OPJ_UINT32 *__cil_tmp24 ;
  OPJ_FLOAT32 *__cil_tmp25 ;
  OPJ_FLOAT32 *__cil_tmp26 ;
  OPJ_FLOAT32 *__cil_tmp27 ;
  OPJ_FLOAT32 *__cil_tmp28 ;
  OPJ_FLOAT32 *__cil_tmp29 ;
  OPJ_FLOAT32 *__cil_tmp30 ;

  {
#line 218
  lStride = nb_compo + 1U;
#line 223
  lLineMatrix = pMatrix;
#line 224
  lBeginPtr = (pResult + nb_compo) - 1;
#line 226
  lCurrentPermutationPtr = pPermutations;
#line 229
  lIntermediatePtr = p_intermediate_data;
#line 230
  lGeneratedData = (p_intermediate_data + nb_compo) - 1;
#line 232
  i = (OPJ_UINT32 )0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (i < nb_compo)) {
#line 232
      goto while_break;
    }
#line 233
    sum = (OPJ_FLOAT32 )0.;
#line 234
    lCurrentPtr = p_intermediate_data;
#line 235
    lTmpMatrix = lLineMatrix;
#line 236
    j = (OPJ_UINT32 )1;
    {
#line 236
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 236
      if (! (j <= i)) {
#line 236
        goto while_break___0;
      }
#line 238
      __cil_tmp22 = lCurrentPtr;
#line 238
      lCurrentPtr ++;
#line 238
      __cil_tmp21 = lTmpMatrix;
#line 238
      lTmpMatrix ++;
#line 238
      sum += *__cil_tmp21 * *__cil_tmp22;
#line 236
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    __cil_tmp24 = lCurrentPermutationPtr;
#line 241
    lCurrentPermutationPtr ++;
#line 241
    __cil_tmp23 = lIntermediatePtr;
#line 241
    lIntermediatePtr ++;
#line 241
    *__cil_tmp23 = *(pVector + *__cil_tmp24) - sum;
#line 242
    lLineMatrix += nb_compo;
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  lLineMatrix = (pMatrix + nb_compo * nb_compo) - 1;
#line 249
  lDestPtr = pResult + nb_compo;
#line 253
  k = (OPJ_INT32 )nb_compo - 1;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    if (! (k != -1)) {
#line 253
      goto while_break___1;
    }
#line 254
    sum = (OPJ_FLOAT32 )0.;
#line 255
    lTmpMatrix = lLineMatrix;
#line 256
    __cil_tmp25 = lTmpMatrix;
#line 256
    lTmpMatrix ++;
#line 256
    u = *__cil_tmp25;
#line 257
    __cil_tmp26 = lDestPtr;
#line 257
    lDestPtr --;
#line 257
    lCurrentPtr = __cil_tmp26;
#line 258
    j = (OPJ_UINT32 )(k + 1);
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 258
      if (! (j < nb_compo)) {
#line 258
        goto while_break___2;
      }
#line 260
      __cil_tmp28 = lCurrentPtr;
#line 260
      lCurrentPtr ++;
#line 260
      __cil_tmp27 = lTmpMatrix;
#line 260
      lTmpMatrix ++;
#line 260
      sum += *__cil_tmp27 * *__cil_tmp28;
#line 258
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 263
    __cil_tmp30 = lGeneratedData;
#line 263
    lGeneratedData --;
#line 263
    __cil_tmp29 = lBeginPtr;
#line 263
    lBeginPtr --;
#line 263
    *__cil_tmp29 = (*__cil_tmp30 - sum) / u;
#line 264
    lLineMatrix -= lStride;
#line 253
    k --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 269 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.c"
static void opj_lupInvert(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix , OPJ_UINT32 nb_compo ,
                          OPJ_UINT32 *pPermutations , OPJ_FLOAT32 *p_src_temp , OPJ_FLOAT32 *p_dest_temp ,
                          OPJ_FLOAT32 *p_swap_area ) 
{ 
  OPJ_UINT32 j ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 *lCurrentPtr ;
  OPJ_FLOAT32 *lLineMatrix ;
  OPJ_UINT32 lSwapSize ;
  OPJ_FLOAT32 *__cil_tmp13 ;

  {
#line 279
  lLineMatrix = pDestMatrix;
#line 280
  lSwapSize = nb_compo * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 282
  j = (OPJ_UINT32 )0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (j < nb_compo)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp13 = lLineMatrix;
#line 283
    lLineMatrix ++;
#line 283
    lCurrentPtr = __cil_tmp13;
#line 284
    memset(p_src_temp, 0, (unsigned long )lSwapSize);
#line 285
    *(p_src_temp + j) = (OPJ_FLOAT32 )1.;
#line 286
    opj_lupSolve(p_dest_temp, pSrcMatrix, p_src_temp, pPermutations, nb_compo, p_swap_area);
#line 289
    i = (OPJ_UINT32 )0;
    }
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 289
      if (! (i < nb_compo)) {
#line 289
        goto while_break___0;
      }
#line 290
      *lCurrentPtr = *(p_dest_temp + i);
#line 291
      lCurrentPtr += nb_compo;
#line 289
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 282
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 49 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  OPJ_OFF_T start_pos ;
  OPJ_OFF_T end_ph_pos ;
  OPJ_OFF_T end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___35 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___36 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___37 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___38 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___39 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___40 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 52
  stream = (FILE *)((void *)0);
#line 53
  total_disto = (double )0;
#line 65
  if (! cstr_info) {
#line 66
    return (1);
  }
  {
#line 69
  stream = fopen((char const   *)index___0, "w");
  }
#line 70
  if (! stream) {
    {
#line 71
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 72
    return (1);
  }
#line 75
  if ((cstr_info->tile + 0)->distotile > 0.) {
#line 76
    disto_on = (char )1;
  } else {
#line 78
    disto_on = (char )0;
  }
#line 81
  if ((cstr_info->tile + 0)->numpix) {
#line 82
    numpix_on = (char )1;
  } else {
#line 84
    numpix_on = (char )0;
  }
  {
#line 87
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 88
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 89
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 90
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 91
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 92
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 93
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 95
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (resno >= 0)) {
#line 95
      goto while_break;
    }
    {
#line 96
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 95
    __cil_tmp17 = resno;
#line 95
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  fprintf(stream, "\n");
#line 103
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 105
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 106
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 108
  fprintf(stream, "\nINFO ON TILES\n");
#line 109
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 110
  if (disto_on) {
    {
#line 111
    fprintf(stream, "         disto");
    }
  }
#line 113
  if (numpix_on) {
    {
#line 114
    fprintf(stream, "     nbpix");
    }
  }
#line 116
  if ((int )disto_on) {
#line 116
    if ((int )numpix_on) {
      {
#line 117
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 119
  fprintf(stream, "\n");
#line 121
  tileno = 0;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 128
    if (disto_on) {
      {
#line 129
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 131
    if (numpix_on) {
      {
#line 132
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 134
    if ((int )disto_on) {
#line 134
      if ((int )numpix_on) {
        {
#line 135
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 138
    fprintf(stream, "\n");
    }
#line 121
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  tileno = 0;
  {
#line 141
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 141
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 141
      goto while_break___1;
    }
#line 143
    disto = (double )0;
#line 144
    max_numdecompos = 0;
#line 145
    pack_nb = 0;
#line 147
    compno = 0;
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 147
      if (! (compno < cstr_info->numcomps)) {
#line 147
        goto while_break___2;
      }
#line 148
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 149
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 147
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 153
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 154
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 156
    tilepartno = 0;
    }
    {
#line 156
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 156
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 156
        goto while_break___3;
      }
      {
#line 157
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 156
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 166
    if ((int )cstr_info->prog == 0) {
      {
#line 167
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 169
      if (disto_on) {
        {
#line 170
        fprintf(stream, " disto");
        }
      }
      {
#line 172
      fprintf(stream, "\n");
#line 174
      layno = 0;
      }
      {
#line 174
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 174
        if (! (layno < cstr_info->numlayers)) {
#line 174
          goto while_break___4;
        }
#line 175
        resno = 0;
        {
#line 175
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 175
          if (! (resno < max_numdecompos + 1)) {
#line 175
            goto while_break___5;
          }
#line 176
          compno = 0;
          {
#line 176
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 176
            if (! (compno < cstr_info->numcomps)) {
#line 176
              goto while_break___6;
            }
#line 178
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 179
              goto while_break___6;
            }
#line 181
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 183
            precno = 0;
            {
#line 183
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 183
              if (! (precno < prec_max)) {
#line 183
                goto while_break___7;
              }
              {
#line 184
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 185
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 186
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 187
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 188
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6ld     %6ld %7ld", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 191
              if (disto_on) {
                {
#line 192
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 194
              fprintf(stream, "\n");
#line 195
              total_disto += disto;
#line 196
              pack_nb ++;
              }
#line 183
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 176
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 175
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 174
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 203
    if ((int )cstr_info->prog == 1) {
      {
#line 204
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 206
      if (disto_on) {
        {
#line 207
        fprintf(stream, " disto");
        }
      }
      {
#line 209
      fprintf(stream, "\n");
#line 211
      resno = 0;
      }
      {
#line 211
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 211
        if (! (resno < max_numdecompos + 1)) {
#line 211
          goto while_break___8;
        }
#line 212
        layno = 0;
        {
#line 212
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 212
          if (! (layno < cstr_info->numlayers)) {
#line 212
            goto while_break___9;
          }
#line 213
          compno = 0;
          {
#line 213
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 213
            if (! (compno < cstr_info->numcomps)) {
#line 213
              goto while_break___10;
            }
#line 215
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 216
              goto while_break___10;
            }
#line 218
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 220
            precno = 0;
            {
#line 220
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 220
              if (! (precno < prec_max___0)) {
#line 220
                goto while_break___11;
              }
              {
#line 221
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 222
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 223
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 224
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 225
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9ld   %9ld %7ld\230\001",
                      pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 227
              if (disto_on) {
                {
#line 228
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 230
              fprintf(stream, "\n");
#line 231
              total_disto += disto;
#line 232
              pack_nb ++;
              }
#line 220
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 213
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 212
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 211
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 239
    if ((int )cstr_info->prog == 2) {
      {
#line 241
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 243
      if (disto_on) {
        {
#line 244
        fprintf(stream, " disto");
        }
      }
      {
#line 246
      fprintf(stream, "\n");
#line 248
      resno = 0;
      }
      {
#line 248
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 248
        if (! (resno < max_numdecompos + 1)) {
#line 248
          goto while_break___12;
        }
#line 249
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 251
        precno = 0;
        {
#line 251
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 251
          if (! (precno < numprec)) {
#line 251
            goto while_break___13;
          }
          {
#line 253
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 253
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 255
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 255
          y0___35 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 257
          x1 = x0 + cstr_info->tile_x;
#line 258
          y1___36 = y0___35 + cstr_info->tile_y;
#line 259
          compno = 0;
          }
          {
#line 259
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 259
            if (! (compno < cstr_info->numcomps)) {
#line 259
              goto while_break___14;
            }
            {
#line 260
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 261
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 261
            pcx = (int )__cil_tmp47;
#line 263
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 263
            pcy = (int )__cil_tmp49;
#line 265
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 265
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 266
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 266
            precno_y = (int )__cil_tmp53;
            }
#line 267
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 268
              goto while_break___14;
            }
#line 270
            y = y0___35;
            {
#line 270
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 270
              if (! (y < y1___36)) {
#line 270
                goto while_break___15;
              }
#line 271
              if (precno_y * pcy == y) {
#line 272
                x = x0;
                {
#line 272
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 272
                  if (! (x < x1)) {
#line 272
                    goto while_break___16;
                  }
#line 273
                  if (precno_x * pcx == x) {
#line 274
                    layno = 0;
                    {
#line 274
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 274
                      if (! (layno < cstr_info->numlayers)) {
#line 274
                        goto while_break___17;
                      }
                      {
#line 275
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 276
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 277
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 278
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 279
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, resno, precno, compno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 281
                      if (disto_on) {
                        {
#line 282
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 284
                      fprintf(stream, "\n");
#line 285
                      total_disto += disto;
#line 286
                      pack_nb ++;
                      }
#line 274
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 272
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 270
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 259
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 251
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 248
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 297
    if ((int )cstr_info->prog == 3) {
      {
#line 299
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 299
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 301
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 301
      y0___37 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 303
      x1___0 = x0___0 + cstr_info->tile_x;
#line 304
      y1___38 = y0___37 + cstr_info->tile_y;
#line 307
      max_numprec = 0;
#line 308
      resno = 0;
      }
      {
#line 308
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 308
        if (! (resno < max_numdecompos + 1)) {
#line 308
          goto while_break___18;
        }
#line 309
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 311
        if (numprec___0 > max_numprec) {
#line 312
          max_numprec = numprec___0;
        }
#line 308
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 316
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 318
      if (disto_on) {
        {
#line 319
        fprintf(stream, " disto");
        }
      }
      {
#line 321
      fprintf(stream, "\n");
#line 323
      precno = 0;
      }
      {
#line 323
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 323
        if (! (precno < max_numprec)) {
#line 323
          goto while_break___19;
        }
#line 324
        compno = 0;
        {
#line 324
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 324
          if (! (compno < cstr_info->numcomps)) {
#line 324
            goto while_break___20;
          }
#line 325
          resno = 0;
          {
#line 325
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 325
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 325
              goto while_break___21;
            }
            {
#line 326
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 328
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 329
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 329
            pcx___0 = (int )__cil_tmp73;
#line 331
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 331
            pcy___0 = (int )__cil_tmp75;
#line 333
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 333
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 334
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 334
            precno_y___0 = (int )__cil_tmp79;
            }
#line 335
            if (precno >= numprec___1) {
#line 336
              goto while_continue___21;
            }
#line 338
            y = y0___37;
            {
#line 338
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 338
              if (! (y < y1___38)) {
#line 338
                goto while_break___22;
              }
#line 339
              if (precno_y___0 * pcy___0 == y) {
#line 340
                x = x0___0;
                {
#line 340
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 340
                  if (! (x < x1___0)) {
#line 340
                    goto while_break___23;
                  }
#line 341
                  if (precno_x___0 * pcx___0 == x) {
#line 342
                    layno = 0;
                    {
#line 342
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 342
                      if (! (layno < cstr_info->numlayers)) {
#line 342
                        goto while_break___24;
                      }
                      {
#line 343
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 344
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 345
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 346
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 347
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, precno, compno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 349
                      if (disto_on) {
                        {
#line 350
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 352
                      fprintf(stream, "\n");
#line 353
                      total_disto += disto;
#line 354
                      pack_nb ++;
                      }
#line 342
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 340
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 338
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 325
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 324
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 323
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 367
      max_numprec___0 = 0;
#line 368
      resno = 0;
      {
#line 368
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 368
        if (! (resno < max_numdecompos + 1)) {
#line 368
          goto while_break___25;
        }
#line 369
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 371
        if (numprec___2 > max_numprec___0) {
#line 372
          max_numprec___0 = numprec___2;
        }
#line 368
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 376
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 378
      if (disto_on) {
        {
#line 379
        fprintf(stream, " disto");
        }
      }
      {
#line 381
      fprintf(stream, "\n");
#line 383
      compno = 0;
      }
      {
#line 383
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 383
        if (! (compno < cstr_info->numcomps)) {
#line 383
          goto while_break___26;
        }
        {
#line 385
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 385
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 387
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 387
        y0___39 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 389
        x1___1 = x0___1 + cstr_info->tile_x;
#line 390
        y1___40 = y0___39 + cstr_info->tile_y;
#line 392
        precno = 0;
        }
        {
#line 392
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 392
          if (! (precno < max_numprec___0)) {
#line 392
            goto while_break___27;
          }
#line 393
          resno = 0;
          {
#line 393
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 393
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 393
              goto while_break___28;
            }
            {
#line 394
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 396
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 397
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 397
            pcx___1 = (int )__cil_tmp99;
#line 399
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 399
            pcy___1 = (int )__cil_tmp101;
#line 401
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 401
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 402
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 402
            precno_y___1 = (int )__cil_tmp105;
            }
#line 403
            if (precno >= numprec___3) {
#line 404
              goto while_continue___28;
            }
#line 407
            y = y0___39;
            {
#line 407
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 407
              if (! (y < y1___40)) {
#line 407
                goto while_break___29;
              }
#line 408
              if (precno_y___1 * pcy___1 == y) {
#line 409
                x = x0___1;
                {
#line 409
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 409
                  if (! (x < x1___1)) {
#line 409
                    goto while_break___30;
                  }
#line 410
                  if (precno_x___1 * pcx___1 == x) {
#line 411
                    layno = 0;
                    {
#line 411
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 411
                      if (! (layno < cstr_info->numlayers)) {
#line 411
                        goto while_break___31;
                      }
                      {
#line 412
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 413
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 414
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 415
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 416
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9ld   %9ld %7ld\230\001",
                              pack_nb, tileno, compno, precno, resno, layno, start_pos,
                              end_ph_pos, end_pos);
                      }
#line 418
                      if (disto_on) {
                        {
#line 419
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 421
                      fprintf(stream, "\n");
#line 422
                      total_disto += disto;
#line 423
                      pack_nb ++;
                      }
#line 411
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 409
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 407
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 393
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 392
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 383
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 141
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  if (disto_on) {
    {
#line 436
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 437
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 441
  if (cstr_info->marknum) {
    {
#line 442
    fprintf(stream, "\nMARKER LIST\n");
#line 443
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 444
    fprintf(stream, "type\tstart_pos    length\n");
#line 445
    x = 0;
    }
    {
#line 445
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 445
      if (! (x < cstr_info->marknum)) {
#line 445
        goto while_break___32;
      }
      {
#line 446
      fprintf(stream, "%X\t%9ld %9d\n\230\001", (int )(cstr_info->marker + x)->type,
              (cstr_info->marker + x)->pos, (cstr_info->marker + x)->len);
      }
#line 445
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 451
  fclose(stream);
#line 453
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 455
  return (0);
}
}
#line 34 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 36
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 36
  image = (opj_image_t *)__cil_tmp2;
  }
#line 37
  return (image);
}
}
#line 40 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;

  {
  {
#line 44
  image = (opj_image_t *)((void *)0);
#line 46
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 46
  image = (opj_image_t *)__cil_tmp6;
  }
#line 47
  if (image) {
    {
#line 48
    image->color_space = clrspc;
#line 49
    image->numcomps = numcmpts;
#line 51
    __cil_tmp7 = opj_calloc((size_t )image->numcomps, sizeof(opj_image_comp_t ));
#line 51
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 53
    if (! image->comps) {
      {
#line 56
      opj_image_destroy(image);
      }
#line 57
      return ((opj_image_t *)((void *)0));
    }
#line 60
    compno = (OPJ_UINT32 )0;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! (compno < numcmpts)) {
#line 60
        goto while_break;
      }
#line 61
      comp = image->comps + compno;
#line 62
      comp->dx = (cmptparms + compno)->dx;
#line 63
      comp->dy = (cmptparms + compno)->dy;
#line 64
      comp->w = (cmptparms + compno)->w;
#line 65
      comp->h = (cmptparms + compno)->h;
#line 66
      comp->x0 = (cmptparms + compno)->x0;
#line 67
      comp->y0 = (cmptparms + compno)->y0;
#line 68
      comp->prec = (cmptparms + compno)->prec;
#line 69
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 70
      if (comp->h != 0U) {
#line 70
        if ((OPJ_SIZE_T )comp->w > (0xffffffffffffffffUL / (unsigned long )comp->h) / sizeof(OPJ_INT32 )) {
          {
#line 73
          opj_image_destroy(image);
          }
#line 74
          return ((opj_image_t *)((void *)0));
        }
      }
      {
#line 76
      __cil_tmp9 = opj_image_data_alloc(((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
#line 76
      comp->data = (OPJ_INT32 *)__cil_tmp9;
      }
#line 78
      if (! comp->data) {
        {
#line 81
        opj_image_destroy(image);
        }
#line 82
        return ((opj_image_t *)((void *)0));
      }
      {
#line 84
      memset(comp->data, 0, ((size_t )comp->w * (unsigned long )comp->h) * sizeof(OPJ_INT32 ));
      }
#line 60
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 88
  return (image);
}
}
#line 91 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp4 ;

  {
#line 93
  if (image) {
#line 94
    if (image->comps) {
#line 98
      compno = (OPJ_UINT32 )0;
      {
#line 98
      while (1) {
        while_continue: /* CIL Label */ ;
#line 98
        if (! (compno < image->numcomps)) {
#line 98
          goto while_break;
        }
#line 99
        image_comp = image->comps + compno;
#line 100
        if (image_comp->data) {
          {
#line 101
          opj_image_data_free(image_comp->data);
          }
        }
#line 98
        compno ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 104
      opj_free(image->comps);
      }
    }
#line 107
    if (image->icc_profile_buf) {
      {
#line 108
      opj_free(image->icc_profile_buf);
      }
    }
    {
#line 111
    opj_free(image);
    }
  }
  return;
}
}
#line 121 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
void opj_image_comp_header_update(opj_image_t *p_image_header , struct opj_cp *p_cp ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_x0 ;
  OPJ_UINT32 l_y0 ;
  OPJ_UINT32 l_x1 ;
  OPJ_UINT32 l_y1 ;
  OPJ_UINT32 l_comp_x0 ;
  OPJ_UINT32 l_comp_y0 ;
  OPJ_UINT32 l_comp_x1 ;
  OPJ_UINT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
  {
#line 127
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 129
  l_x0 = opj_uint_max(p_cp->tx0, p_image_header->x0);
#line 130
  l_y0 = opj_uint_max(p_cp->ty0, p_image_header->y0);
#line 131
  l_x1 = p_cp->tx0 + (p_cp->tw - 1U) * p_cp->tdx;
#line 133
  l_y1 = p_cp->ty0 + (p_cp->th - 1U) * p_cp->tdy;
#line 134
  __cil_tmp17 = opj_uint_adds(l_x1, p_cp->tdx);
#line 134
  __cil_tmp18 = opj_uint_min(__cil_tmp17, p_image_header->x1);
#line 134
  l_x1 = __cil_tmp18;
#line 136
  __cil_tmp19 = opj_uint_adds(l_y1, p_cp->tdy);
#line 136
  __cil_tmp20 = opj_uint_min(__cil_tmp19, p_image_header->y1);
#line 136
  l_y1 = __cil_tmp20;
#line 139
  l_img_comp = p_image_header->comps;
#line 140
  i = (OPJ_UINT32 )0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < p_image_header->numcomps)) {
#line 140
      goto while_break;
    }
    {
#line 141
    l_comp_x0 = opj_uint_ceildiv(l_x0, l_img_comp->dx);
#line 142
    l_comp_y0 = opj_uint_ceildiv(l_y0, l_img_comp->dy);
#line 143
    l_comp_x1 = opj_uint_ceildiv(l_x1, l_img_comp->dx);
#line 144
    l_comp_y1 = opj_uint_ceildiv(l_y1, l_img_comp->dy);
#line 145
    l_width = opj_uint_ceildivpow2(l_comp_x1 - l_comp_x0, l_img_comp->factor);
#line 146
    l_height = opj_uint_ceildivpow2(l_comp_y1 - l_comp_y0, l_img_comp->factor);
#line 147
    l_img_comp->w = l_width;
#line 148
    l_img_comp->h = l_height;
#line 149
    l_img_comp->x0 = l_comp_x0;
#line 150
    l_img_comp->y0 = l_comp_y0;
#line 151
    l_img_comp ++;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 164 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *image_comp ;
  OPJ_UINT32 __cil_tmp5 ;
  void *__cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 173
  p_image_dest->x0 = p_image_src->x0;
#line 174
  p_image_dest->y0 = p_image_src->y0;
#line 175
  p_image_dest->x1 = p_image_src->x1;
#line 176
  p_image_dest->y1 = p_image_src->y1;
#line 178
  if (p_image_dest->comps) {
#line 179
    compno = (OPJ_UINT32 )0;
    {
#line 179
    while (1) {
      while_continue: /* CIL Label */ ;
#line 179
      if (! (compno < p_image_dest->numcomps)) {
#line 179
        goto while_break;
      }
#line 180
      image_comp = p_image_dest->comps + compno;
#line 181
      if (image_comp->data) {
        {
#line 182
        opj_image_data_free(image_comp->data);
        }
      }
#line 179
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 185
    opj_free(p_image_dest->comps);
#line 186
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
    }
  }
  {
#line 189
  p_image_dest->numcomps = p_image_src->numcomps;
#line 191
  __cil_tmp6 = opj_malloc((unsigned long )p_image_dest->numcomps * sizeof(opj_image_comp_t ));
#line 191
  p_image_dest->comps = (opj_image_comp_t *)__cil_tmp6;
  }
#line 193
  if (! p_image_dest->comps) {
#line 194
    p_image_dest->comps = (opj_image_comp_t *)((void *)0);
#line 195
    p_image_dest->numcomps = (OPJ_UINT32 )0;
#line 196
    return;
  }
#line 199
  compno = (OPJ_UINT32 )0;
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (! (compno < p_image_dest->numcomps)) {
#line 199
      goto while_break___0;
    }
    {
#line 200
    memcpy(p_image_dest->comps + compno, p_image_src->comps + compno, sizeof(opj_image_comp_t ));
#line 203
    (p_image_dest->comps + compno)->data = (OPJ_INT32 *)((void *)0);
    }
#line 199
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 206
  p_image_dest->color_space = p_image_src->color_space;
#line 207
  p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
#line 209
  if (p_image_dest->icc_profile_len) {
    {
#line 210
    __cil_tmp8 = opj_malloc((size_t )p_image_dest->icc_profile_len);
#line 210
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)__cil_tmp8;
    }
#line 212
    if (! p_image_dest->icc_profile_buf) {
#line 213
      p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
#line 214
      p_image_dest->icc_profile_len = (OPJ_UINT32 )0;
#line 215
      return;
    }
    {
#line 217
    memcpy(p_image_dest->icc_profile_buf, p_image_src->icc_profile_buf, (unsigned long )p_image_src->icc_profile_len);
    }
  } else {
#line 221
    p_image_dest->icc_profile_buf = (OPJ_BYTE *)((void *)0);
  }
#line 224
  return;
}
}
#line 227 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.c"
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 231
  image = (opj_image_t *)0;
#line 233
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_image_t ));
#line 233
  image = (opj_image_t *)__cil_tmp6;
  }
#line 234
  if (image) {
    {
#line 236
    image->color_space = clrspc;
#line 237
    image->numcomps = numcmpts;
#line 240
    __cil_tmp7 = opj_calloc((size_t )image->numcomps, sizeof(opj_image_comp_t ));
#line 240
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 242
    if (! image->comps) {
      {
#line 243
      opj_image_destroy(image);
      }
#line 244
      return ((opj_image_t *)0);
    }
#line 248
    compno = (OPJ_UINT32 )0;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (compno < numcmpts)) {
#line 248
        goto while_break;
      }
#line 249
      comp = image->comps + compno;
#line 250
      comp->dx = (cmptparms + compno)->dx;
#line 251
      comp->dy = (cmptparms + compno)->dy;
#line 252
      comp->w = (cmptparms + compno)->w;
#line 253
      comp->h = (cmptparms + compno)->h;
#line 254
      comp->x0 = (cmptparms + compno)->x0;
#line 255
      comp->y0 = (cmptparms + compno)->y0;
#line 256
      comp->prec = (cmptparms + compno)->prec;
#line 257
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 258
      comp->data = (OPJ_INT32 *)0;
#line 248
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 262
  return (image);
}
}
#line 1 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1_ht_luts.h"
static OPJ_UINT16 vlc_tbl0[1024]  = 
#line 1 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1_ht_luts.h"
  {      (OPJ_UINT16 )35,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )20,      (OPJ_UINT16 )55519, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )67,      (OPJ_UINT16 )62975, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )8318,      (OPJ_UINT16 )85,      (OPJ_UINT16 )20831, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )53,      (OPJ_UINT16 )67,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )50382,      (OPJ_UINT16 )20,      (OPJ_UINT16 )52431, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )58110,      (OPJ_UINT16 )67,      (OPJ_UINT16 )39423, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )150,      (OPJ_UINT16 )197,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )51406,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4575, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )67,      (OPJ_UINT16 )64767, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )158,      (OPJ_UINT16 )85,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )53,      (OPJ_UINT16 )67,      (OPJ_UINT16 )61951, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )20,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )67,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )197,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )20,      (OPJ_UINT16 )21727, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )67,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )8318,      (OPJ_UINT16 )85,      (OPJ_UINT16 )8831, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )53,      (OPJ_UINT16 )67,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )50382,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4543, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )58110,      (OPJ_UINT16 )67,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )150,      (OPJ_UINT16 )197,      (OPJ_UINT16 )8767, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )51406,      (OPJ_UINT16 )20,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )67,      (OPJ_UINT16 )47871, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )158,      (OPJ_UINT16 )85,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )53,      (OPJ_UINT16 )67,      (OPJ_UINT16 )59135, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )20,      (OPJ_UINT16 )41647, 
        (OPJ_UINT16 )35,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )67,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )197,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )197,      (OPJ_UINT16 )132,      (OPJ_UINT16 )8318, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )50382,      (OPJ_UINT16 )36,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )41726,      (OPJ_UINT16 )68,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )20,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )36,      (OPJ_UINT16 )4575, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )197,      (OPJ_UINT16 )132,      (OPJ_UINT16 )110, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )36,      (OPJ_UINT16 )35071, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )47358,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )20,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )58622,      (OPJ_UINT16 )132,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )36,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )68,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62,      (OPJ_UINT16 )20,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )197,      (OPJ_UINT16 )132,      (OPJ_UINT16 )8318, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )50382,      (OPJ_UINT16 )36,      (OPJ_UINT16 )61951, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )41726,      (OPJ_UINT16 )68,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4543, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )36,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )20,      (OPJ_UINT16 )8831, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )197,      (OPJ_UINT16 )132,      (OPJ_UINT16 )110, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )36,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )47358,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )20,      (OPJ_UINT16 )41647, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )58622,      (OPJ_UINT16 )132,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )36,      (OPJ_UINT16 )55519, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )68,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62,      (OPJ_UINT16 )20,      (OPJ_UINT16 )20831, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )85,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35038,      (OPJ_UINT16 )36,      (OPJ_UINT16 )13055, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4606,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )174,      (OPJ_UINT16 )20,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )12670,      (OPJ_UINT16 )132,      (OPJ_UINT16 )20830, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )36,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8430,      (OPJ_UINT16 )68,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )20,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )85,      (OPJ_UINT16 )132,      (OPJ_UINT16 )21598, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )36,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )20,      (OPJ_UINT16 )21855, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )29950,      (OPJ_UINT16 )132,      (OPJ_UINT16 )4414, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8382,      (OPJ_UINT16 )36,      (OPJ_UINT16 )29823, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )50398,      (OPJ_UINT16 )68,      (OPJ_UINT16 )63743, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )20,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )85,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35038,      (OPJ_UINT16 )36,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4606,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )174,      (OPJ_UINT16 )20,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )12670,      (OPJ_UINT16 )132,      (OPJ_UINT16 )20830, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )36,      (OPJ_UINT16 )51407, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8430,      (OPJ_UINT16 )68,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )20,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )85,      (OPJ_UINT16 )132,      (OPJ_UINT16 )21598, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )36,      (OPJ_UINT16 )53727, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )20,      (OPJ_UINT16 )8831, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )29950,      (OPJ_UINT16 )132,      (OPJ_UINT16 )4414, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8382,      (OPJ_UINT16 )36,      (OPJ_UINT16 )8895, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )50398,      (OPJ_UINT16 )68,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )20,      (OPJ_UINT16 )12863, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )62717,      (OPJ_UINT16 )64767, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )4414,      (OPJ_UINT16 )85,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )12990,      (OPJ_UINT16 )133,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )20830,      (OPJ_UINT16 )43774,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )17647, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )69,      (OPJ_UINT16 )41647, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )166,      (OPJ_UINT16 )21853,      (OPJ_UINT16 )39391, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )54,      (OPJ_UINT16 )62974,      (OPJ_UINT16 )25199, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )53726,      (OPJ_UINT16 )62717,      (OPJ_UINT16 )59135, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )85,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )133,      (OPJ_UINT16 )54751, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )17486,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )26239, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )21598,      (OPJ_UINT16 )69,      (OPJ_UINT16 )4511, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )21853,      (OPJ_UINT16 )51407, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )4382,      (OPJ_UINT16 )51438,      (OPJ_UINT16 )103, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )62717,      (OPJ_UINT16 )62463, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )4414,      (OPJ_UINT16 )85,      (OPJ_UINT16 )4543, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )12990,      (OPJ_UINT16 )133,      (OPJ_UINT16 )55519, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )20830,      (OPJ_UINT16 )43774,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )69,      (OPJ_UINT16 )39071, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )166,      (OPJ_UINT16 )21853,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )54,      (OPJ_UINT16 )62974,      (OPJ_UINT16 )17519, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )53726,      (OPJ_UINT16 )62717,      (OPJ_UINT16 )47615, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )85,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )34990,      (OPJ_UINT16 )133,      (OPJ_UINT16 )56543, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )17486,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )21598,      (OPJ_UINT16 )69,      (OPJ_UINT16 )29567, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )21853,      (OPJ_UINT16 )47295, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )4382,      (OPJ_UINT16 )51438,      (OPJ_UINT16 )12863, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )165,      (OPJ_UINT16 )132,      (OPJ_UINT16 )16510, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4318,      (OPJ_UINT16 )36,      (OPJ_UINT16 )4575, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )29438,      (OPJ_UINT16 )68,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43182,      (OPJ_UINT16 )20,      (OPJ_UINT16 )45759, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )36,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )51438,      (OPJ_UINT16 )68,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )20,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )165,      (OPJ_UINT16 )132,      (OPJ_UINT16 )110, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )36,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )37374,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )20,      (OPJ_UINT16 )43695, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )47358,      (OPJ_UINT16 )132,      (OPJ_UINT16 )94, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )190,      (OPJ_UINT16 )36,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17646,      (OPJ_UINT16 )68,      (OPJ_UINT16 )62719, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8766,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )165,      (OPJ_UINT16 )132,      (OPJ_UINT16 )16510, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4318,      (OPJ_UINT16 )36,      (OPJ_UINT16 )39423, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )29438,      (OPJ_UINT16 )68,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43182,      (OPJ_UINT16 )20,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )132,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )36,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )51438,      (OPJ_UINT16 )68,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )20,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )165,      (OPJ_UINT16 )132,      (OPJ_UINT16 )110, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )36,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )37374,      (OPJ_UINT16 )68,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )20,      (OPJ_UINT16 )17535, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )47358,      (OPJ_UINT16 )132,      (OPJ_UINT16 )94, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )190,      (OPJ_UINT16 )36,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17646,      (OPJ_UINT16 )68,      (OPJ_UINT16 )30463, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8766,      (OPJ_UINT16 )20,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )133,      (OPJ_UINT16 )55807, 
        (OPJ_UINT16 )62205,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )39359, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )37,      (OPJ_UINT16 )26351, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )86,      (OPJ_UINT16 )58094,      (OPJ_UINT16 )29567, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )39102,      (OPJ_UINT16 )69,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )63741,      (OPJ_UINT16 )102,      (OPJ_UINT16 )30462,      (OPJ_UINT16 )34975, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )21,      (OPJ_UINT16 )54751, 
        (OPJ_UINT16 )165,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )39134,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )133,      (OPJ_UINT16 )64767, 
        (OPJ_UINT16 )62205,      (OPJ_UINT16 )8814,      (OPJ_UINT16 )150,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )43694,      (OPJ_UINT16 )37,      (OPJ_UINT16 )53727, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )54,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )25711, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )43182,      (OPJ_UINT16 )69,      (OPJ_UINT16 )60143, 
        (OPJ_UINT16 )63741,      (OPJ_UINT16 )17502,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )29055, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )12862,      (OPJ_UINT16 )21,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )165,      (OPJ_UINT16 )64255,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )133,      (OPJ_UINT16 )30719, 
        (OPJ_UINT16 )62205,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )46015, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )37,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )86,      (OPJ_UINT16 )58094,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )39102,      (OPJ_UINT16 )69,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )63741,      (OPJ_UINT16 )102,      (OPJ_UINT16 )30462,      (OPJ_UINT16 )26239, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )21,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )165,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )39134,      (OPJ_UINT16 )13119, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )133,      (OPJ_UINT16 )30207, 
        (OPJ_UINT16 )62205,      (OPJ_UINT16 )8814,      (OPJ_UINT16 )150,      (OPJ_UINT16 )37279, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )43694,      (OPJ_UINT16 )37,      (OPJ_UINT16 )39391, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )54,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )20831, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )43182,      (OPJ_UINT16 )69,      (OPJ_UINT16 )60655, 
        (OPJ_UINT16 )63741,      (OPJ_UINT16 )17502,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )12862,      (OPJ_UINT16 )21,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )165,      (OPJ_UINT16 )62463,      (OPJ_UINT16 )35022,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )52431, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )37310,      (OPJ_UINT16 )69,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )62462,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )133,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )43183, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )166,      (OPJ_UINT16 )53,      (OPJ_UINT16 )51423, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )12606,      (OPJ_UINT16 )26366,      (OPJ_UINT16 )25711, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )51406,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )62975, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )102,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )47807, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )69,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )12862,      (OPJ_UINT16 )60158,      (OPJ_UINT16 )29567, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )133,      (OPJ_UINT16 )21983, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )86,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )4511, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )53,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )13118,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )25726,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )39359, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )37310,      (OPJ_UINT16 )69,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )62462,      (OPJ_UINT16 )26239, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )198,      (OPJ_UINT16 )133,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )39071, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )166,      (OPJ_UINT16 )53,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )12606,      (OPJ_UINT16 )26366,      (OPJ_UINT16 )8815, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )51406,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )47615, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )102,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )69,      (OPJ_UINT16 )53727, 
        (OPJ_UINT16 )37,      (OPJ_UINT16 )12862,      (OPJ_UINT16 )60158,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )133,      (OPJ_UINT16 )60655, 
        (OPJ_UINT16 )20,      (OPJ_UINT16 )86,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )53,      (OPJ_UINT16 )47295, 
        (OPJ_UINT16 )61949,      (OPJ_UINT16 )13118,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )21599, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )53726,      (OPJ_UINT16 )64253,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )22,      (OPJ_UINT16 )65533,      (OPJ_UINT16 )29823, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )62461,      (OPJ_UINT16 )46015, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )60143,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )5,      (OPJ_UINT16 )47295, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )247,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )62973,      (OPJ_UINT16 )30079, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )55519,      (OPJ_UINT16 )58094,      (OPJ_UINT16 )13119, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )64253,      (OPJ_UINT16 )35023, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )64511,      (OPJ_UINT16 )65533,      (OPJ_UINT16 )29567, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )110,      (OPJ_UINT16 )62461,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )26351,      (OPJ_UINT16 )63998,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )158,      (OPJ_UINT16 )5,      (OPJ_UINT16 )47807, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )65023,      (OPJ_UINT16 )63230,      (OPJ_UINT16 )103, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )38,      (OPJ_UINT16 )62973,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )56543,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )53726,      (OPJ_UINT16 )64253,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )22,      (OPJ_UINT16 )65533,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )62461,      (OPJ_UINT16 )39359, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )60655,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )71, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )5,      (OPJ_UINT16 )167, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )63487,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )87, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )62973,      (OPJ_UINT16 )151, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )54751,      (OPJ_UINT16 )58094,      (OPJ_UINT16 )55, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )64253,      (OPJ_UINT16 )199, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )65279,      (OPJ_UINT16 )65533,      (OPJ_UINT16 )26239, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )110,      (OPJ_UINT16 )62461,      (OPJ_UINT16 )43183, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )231,      (OPJ_UINT16 )63998,      (OPJ_UINT16 )12863, 
        (OPJ_UINT16 )61948,      (OPJ_UINT16 )158,      (OPJ_UINT16 )5,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )63740,      (OPJ_UINT16 )58607,      (OPJ_UINT16 )63230,      (OPJ_UINT16 )21599, 
        (OPJ_UINT16 )62716,      (OPJ_UINT16 )38,      (OPJ_UINT16 )62973,      (OPJ_UINT16 )135, 
        (OPJ_UINT16 )62204,      (OPJ_UINT16 )39391,      (OPJ_UINT16 )54494,      (OPJ_UINT16 )4383};
#line 132 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1_ht_luts.h"
static OPJ_UINT16 vlc_tbl1[1024]  = 
#line 132
  {      (OPJ_UINT16 )19,      (OPJ_UINT16 )101,      (OPJ_UINT16 )67,      (OPJ_UINT16 )222, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34957,      (OPJ_UINT16 )35,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )34990, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )53,      (OPJ_UINT16 )35,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )197,      (OPJ_UINT16 )67,      (OPJ_UINT16 )158, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )85,      (OPJ_UINT16 )35,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )149,      (OPJ_UINT16 )67,      (OPJ_UINT16 )126, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )4350,      (OPJ_UINT16 )35,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )101,      (OPJ_UINT16 )67,      (OPJ_UINT16 )35022, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34957,      (OPJ_UINT16 )35,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )94, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )53,      (OPJ_UINT16 )35,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )197,      (OPJ_UINT16 )67,      (OPJ_UINT16 )190, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )85,      (OPJ_UINT16 )35,      (OPJ_UINT16 )4607, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )149,      (OPJ_UINT16 )67,      (OPJ_UINT16 )62, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )16622,      (OPJ_UINT16 )35,      (OPJ_UINT16 )41647, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )101,      (OPJ_UINT16 )67,      (OPJ_UINT16 )222, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34957,      (OPJ_UINT16 )35,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )34990, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )53,      (OPJ_UINT16 )35,      (OPJ_UINT16 )17647, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )197,      (OPJ_UINT16 )67,      (OPJ_UINT16 )158, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )85,      (OPJ_UINT16 )35,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )149,      (OPJ_UINT16 )67,      (OPJ_UINT16 )126, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )4350,      (OPJ_UINT16 )35,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )101,      (OPJ_UINT16 )67,      (OPJ_UINT16 )35022, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )34957,      (OPJ_UINT16 )35,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )165,      (OPJ_UINT16 )67,      (OPJ_UINT16 )94, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )53,      (OPJ_UINT16 )35,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )197,      (OPJ_UINT16 )67,      (OPJ_UINT16 )190, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )85,      (OPJ_UINT16 )35,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )19,      (OPJ_UINT16 )149,      (OPJ_UINT16 )67,      (OPJ_UINT16 )62, 
        (OPJ_UINT16 )131,      (OPJ_UINT16 )16622,      (OPJ_UINT16 )35,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )150, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )198, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )53,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )16638, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )191, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )103, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )166, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )53,      (OPJ_UINT16 )1,      (OPJ_UINT16 )4415, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )207, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )150, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )198, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )239, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )53,      (OPJ_UINT16 )1,      (OPJ_UINT16 )12863, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )16638, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )175, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17663, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )95, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )166, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )127, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )223, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )53,      (OPJ_UINT16 )1,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )133,      (OPJ_UINT16 )1,      (OPJ_UINT16 )191, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )198,      (OPJ_UINT16 )1,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )63743, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )127, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )223, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )166,      (OPJ_UINT16 )1,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )133,      (OPJ_UINT16 )1,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17647, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )1,      (OPJ_UINT16 )103, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )20991, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )151, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )207, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )54,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8767, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )133,      (OPJ_UINT16 )1,      (OPJ_UINT16 )45759, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )16623, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )198,      (OPJ_UINT16 )1,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )29439, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )166,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )133,      (OPJ_UINT16 )1,      (OPJ_UINT16 )43183, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )1,      (OPJ_UINT16 )95, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )36,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17663, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )69,      (OPJ_UINT16 )1,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )20,      (OPJ_UINT16 )1,      (OPJ_UINT16 )43695, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )54,      (OPJ_UINT16 )1,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )36,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )182,      (OPJ_UINT16 )133,      (OPJ_UINT16 )26367, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )206,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )53,      (OPJ_UINT16 )43183, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )246,      (OPJ_UINT16 )36,      (OPJ_UINT16 )12606, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )69,      (OPJ_UINT16 )46015, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )20,      (OPJ_UINT16 )62975, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )102,      (OPJ_UINT16 )20862,      (OPJ_UINT16 )21599, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )36,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )133,      (OPJ_UINT16 )17647, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )20,      (OPJ_UINT16 )62719, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )118,      (OPJ_UINT16 )53,      (OPJ_UINT16 )17535, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )16606,      (OPJ_UINT16 )36,      (OPJ_UINT16 )12862, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )69,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35006,      (OPJ_UINT16 )20,      (OPJ_UINT16 )64255, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )36,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )182,      (OPJ_UINT16 )133,      (OPJ_UINT16 )51439, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )206,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )53,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )246,      (OPJ_UINT16 )36,      (OPJ_UINT16 )12606, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )69,      (OPJ_UINT16 )17631, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )45758,      (OPJ_UINT16 )20,      (OPJ_UINT16 )43263, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )102,      (OPJ_UINT16 )20862,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )36,      (OPJ_UINT16 )8750, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8878,      (OPJ_UINT16 )133,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )198,      (OPJ_UINT16 )20,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )118,      (OPJ_UINT16 )53,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )16606,      (OPJ_UINT16 )36,      (OPJ_UINT16 )12862, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )158,      (OPJ_UINT16 )69,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )35006,      (OPJ_UINT16 )20,      (OPJ_UINT16 )29695, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )13119, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8430, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )197,      (OPJ_UINT16 )1,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )13055, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )21,      (OPJ_UINT16 )1,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )37,      (OPJ_UINT16 )1,      (OPJ_UINT16 )175, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )166,      (OPJ_UINT16 )1,      (OPJ_UINT16 )95, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )197,      (OPJ_UINT16 )1,      (OPJ_UINT16 )52431, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )247, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )21,      (OPJ_UINT16 )1,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )37,      (OPJ_UINT16 )1,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )223, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )12542,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )8430, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )197,      (OPJ_UINT16 )1,      (OPJ_UINT16 )51407, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )4607, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )21,      (OPJ_UINT16 )1,      (OPJ_UINT16 )119, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )37,      (OPJ_UINT16 )1,      (OPJ_UINT16 )127, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )231, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )166,      (OPJ_UINT16 )1,      (OPJ_UINT16 )55, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )197,      (OPJ_UINT16 )1,      (OPJ_UINT16 )183, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )191, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )21,      (OPJ_UINT16 )1,      (OPJ_UINT16 )63, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )132,      (OPJ_UINT16 )1,      (OPJ_UINT16 )86, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )37,      (OPJ_UINT16 )1,      (OPJ_UINT16 )151, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )68,      (OPJ_UINT16 )1,      (OPJ_UINT16 )215, 
        (OPJ_UINT16 )1,      (OPJ_UINT16 )12542,      (OPJ_UINT16 )1,      (OPJ_UINT16 )4383, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )68,      (OPJ_UINT16 )34958, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )214,      (OPJ_UINT16 )197,      (OPJ_UINT16 )62463, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )37,      (OPJ_UINT16 )62, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )182,      (OPJ_UINT16 )85,      (OPJ_UINT16 )55519, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )68,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8318,      (OPJ_UINT16 )133,      (OPJ_UINT16 )39423, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )230,      (OPJ_UINT16 )245,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )21,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )68,      (OPJ_UINT16 )118, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )197,      (OPJ_UINT16 )30463, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )37,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )174,      (OPJ_UINT16 )85,      (OPJ_UINT16 )51407, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )133,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )245,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )21,      (OPJ_UINT16 )8751, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )68,      (OPJ_UINT16 )34958, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )214,      (OPJ_UINT16 )197,      (OPJ_UINT16 )64255, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )37,      (OPJ_UINT16 )62, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )182,      (OPJ_UINT16 )85,      (OPJ_UINT16 )4543, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )68,      (OPJ_UINT16 )102, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )8318,      (OPJ_UINT16 )133,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )230,      (OPJ_UINT16 )245,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )166,      (OPJ_UINT16 )21,      (OPJ_UINT16 )8831, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )68,      (OPJ_UINT16 )118, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )17614,      (OPJ_UINT16 )197,      (OPJ_UINT16 )54783, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )61950,      (OPJ_UINT16 )37,      (OPJ_UINT16 )17486, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )174,      (OPJ_UINT16 )85,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )68,      (OPJ_UINT16 )17502, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )4286,      (OPJ_UINT16 )133,      (OPJ_UINT16 )4575, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )245,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )150,      (OPJ_UINT16 )21,      (OPJ_UINT16 )20831, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )246,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )165,      (OPJ_UINT16 )54495, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )85,      (OPJ_UINT16 )30463, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )8766,      (OPJ_UINT16 )182,      (OPJ_UINT16 )43695, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )230,      (OPJ_UINT16 )20,      (OPJ_UINT16 )62975, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )102,      (OPJ_UINT16 )133,      (OPJ_UINT16 )52431, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )158,      (OPJ_UINT16 )197,      (OPJ_UINT16 )17647, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )54,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )12671, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )20,      (OPJ_UINT16 )61951, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )118,      (OPJ_UINT16 )165,      (OPJ_UINT16 )50383, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )8830,      (OPJ_UINT16 )85,      (OPJ_UINT16 )53727, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )17486,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )20831, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )214,      (OPJ_UINT16 )20,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )17502,      (OPJ_UINT16 )133,      (OPJ_UINT16 )8895, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )197,      (OPJ_UINT16 )51423, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )8815, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )246,      (OPJ_UINT16 )20,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )34958,      (OPJ_UINT16 )165,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )41646,      (OPJ_UINT16 )85,      (OPJ_UINT16 )13311, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )8766,      (OPJ_UINT16 )182,      (OPJ_UINT16 )43183, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )230,      (OPJ_UINT16 )20,      (OPJ_UINT16 )47615, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )102,      (OPJ_UINT16 )133,      (OPJ_UINT16 )43199, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )158,      (OPJ_UINT16 )197,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )54,      (OPJ_UINT16 )63742,      (OPJ_UINT16 )25711, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )59630,      (OPJ_UINT16 )20,      (OPJ_UINT16 )64767, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )118,      (OPJ_UINT16 )165,      (OPJ_UINT16 )51407, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )8830,      (OPJ_UINT16 )85,      (OPJ_UINT16 )60143, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )17486,      (OPJ_UINT16 )62718,      (OPJ_UINT16 )29823, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )214,      (OPJ_UINT16 )20,      (OPJ_UINT16 )64255, 
        (OPJ_UINT16 )68,      (OPJ_UINT16 )17502,      (OPJ_UINT16 )133,      (OPJ_UINT16 )45759, 
        (OPJ_UINT16 )3,      (OPJ_UINT16 )150,      (OPJ_UINT16 )197,      (OPJ_UINT16 )17631, 
        (OPJ_UINT16 )36,      (OPJ_UINT16 )8750,      (OPJ_UINT16 )62206,      (OPJ_UINT16 )12607, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )64254,      (OPJ_UINT16 )61949,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )12990,      (OPJ_UINT16 )117,      (OPJ_UINT16 )4575, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )58607, 
        (OPJ_UINT16 )213,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )29567, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )62462,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )150,      (OPJ_UINT16 )85,      (OPJ_UINT16 )45503, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )206,      (OPJ_UINT16 )181,      (OPJ_UINT16 )55519, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )102,      (OPJ_UINT16 )47614,      (OPJ_UINT16 )21599, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )30462,      (OPJ_UINT16 )61949,      (OPJ_UINT16 )38, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )166,      (OPJ_UINT16 )117,      (OPJ_UINT16 )159, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )174,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )63487, 
        (OPJ_UINT16 )213,      (OPJ_UINT16 )70,      (OPJ_UINT16 )62974,      (OPJ_UINT16 )29823, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )230,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )22, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )134,      (OPJ_UINT16 )85,      (OPJ_UINT16 )34959, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )198,      (OPJ_UINT16 )181,      (OPJ_UINT16 )58095, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )4415, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )64254,      (OPJ_UINT16 )61949,      (OPJ_UINT16 )54, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )12990,      (OPJ_UINT16 )117,      (OPJ_UINT16 )53727, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )21726,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )64511, 
        (OPJ_UINT16 )213,      (OPJ_UINT16 )29054,      (OPJ_UINT16 )64766,      (OPJ_UINT16 )17535, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )62462,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )4382, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )150,      (OPJ_UINT16 )85,      (OPJ_UINT16 )29311, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )206,      (OPJ_UINT16 )181,      (OPJ_UINT16 )8943, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )102,      (OPJ_UINT16 )47614,      (OPJ_UINT16 )17487, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )30462,      (OPJ_UINT16 )61949,      (OPJ_UINT16 )38, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )166,      (OPJ_UINT16 )117,      (OPJ_UINT16 )4543, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )174,      (OPJ_UINT16 )62205,      (OPJ_UINT16 )65535, 
        (OPJ_UINT16 )213,      (OPJ_UINT16 )70,      (OPJ_UINT16 )62974,      (OPJ_UINT16 )12863, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )230,      (OPJ_UINT16 )63741,      (OPJ_UINT16 )22, 
        (OPJ_UINT16 )4,      (OPJ_UINT16 )134,      (OPJ_UINT16 )85,      (OPJ_UINT16 )111, 
        (OPJ_UINT16 )243,      (OPJ_UINT16 )198,      (OPJ_UINT16 )181,      (OPJ_UINT16 )47295, 
        (OPJ_UINT16 )62717,      (OPJ_UINT16 )4446,      (OPJ_UINT16 )43246,      (OPJ_UINT16 )8751};
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
static OPJ_BOOL only_cleanup_pass_is_decoded  =    0;
#line 70 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 population_count(OPJ_UINT32 val ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 75
  __cil_tmp2 = __builtin_popcount(val);
  }
#line 75
  return ((OPJ_UINT32 )__cil_tmp2);
}
}
#line 95 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 count_leading_zeros(OPJ_UINT32 val ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 102
  __cil_tmp2 = __builtin_clz(val);
  }
#line 102
  return ((OPJ_UINT32 )__cil_tmp2);
}
}
#line 118 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 read_le_uint32(void const   *dataIn ) 
{ 


  {
#line 127
  return (*((OPJ_UINT32 *)dataIn));
}
}
#line 165 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void mel_read(dec_mel_t *melp ) 
{ 
  OPJ_UINT32 val ;
  int bits ;
  OPJ_UINT32 t ;
  OPJ_BOOL unstuff ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 m ;
  OPJ_UINT32 v ;
  int i ;
  OPJ_UINT32 v___41 ;
  OPJ_UINT8 *__cil_tmp11 ;
  OPJ_UINT32 m___42 ;
  OPJ_UINT8 *__cil_tmp13 ;

  {
#line 172
  if (melp->bits > 32) {
#line 173
    return;
  }
#line 176
  val = 4294967295U;
#line 177
  if (melp->size > 4) {
    {
#line 178
    val = read_le_uint32(melp->data);
#line 179
    melp->data += 4;
#line 180
    melp->size -= 4;
    }
  } else
#line 181
  if (melp->size > 0) {
#line 183
    i = 0;
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 184
      if (! (melp->size > 1)) {
#line 184
        goto while_break;
      }
#line 185
      __cil_tmp11 = melp->data;
#line 185
      (melp->data) ++;
#line 185
      v___41 = (OPJ_UINT32 )*__cil_tmp11;
#line 186
      m___42 = ~ (255U << i);
#line 187
      val = (val & m___42) | (v___41 << i);
#line 188
      (melp->size) --;
#line 189
      i += 8;
    }
    while_break: /* CIL Label */ ;
    }
#line 192
    __cil_tmp13 = melp->data;
#line 192
    (melp->data) ++;
#line 192
    v = (OPJ_UINT32 )*__cil_tmp13;
#line 193
    v |= (unsigned int )15;
#line 194
    m = ~ (255U << i);
#line 195
    val = (val & m) | (v << i);
#line 196
    (melp->size) --;
  }
#line 200
  bits = 32 - melp->unstuff;
#line 206
  t = val & 255U;
#line 207
  unstuff = (val & 255U) == 255U;
#line 208
  bits -= unstuff;
#line 209
  t <<= 8 - unstuff;
#line 212
  t |= (val >> 8) & 255U;
#line 213
  unstuff = ((val >> 8) & 255U) == 255U;
#line 214
  bits -= unstuff;
#line 215
  t <<= 8 - unstuff;
#line 217
  t |= (val >> 16) & 255U;
#line 218
  unstuff = ((val >> 16) & 255U) == 255U;
#line 219
  bits -= unstuff;
#line 220
  t <<= 8 - unstuff;
#line 222
  t |= (val >> 24) & 255U;
#line 223
  melp->unstuff = ((val >> 24) & 255U) == 255U;
#line 227
  melp->tmp |= (OPJ_UINT64 )t << ((64 - bits) - melp->bits);
#line 228
  melp->bits += bits;
  return;
}
}
#line 247 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void mel_decode(dec_mel_t *melp ) 
{ 
  static int const   mel_exp[13] ;
  int eval ;
  int run ;
  int __cil_tmp5 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp8 ;

  {
#line 249
  mel_exp[0] = 0;
#line 249
  mel_exp[1] = 0;
#line 249
  mel_exp[2] = 0;
#line 249
  mel_exp[3] = 1;
#line 249
  mel_exp[4] = 1;
#line 249
  mel_exp[5] = 1;
#line 249
  mel_exp[6] = 2;
#line 249
  mel_exp[7] = 2;
#line 249
  mel_exp[8] = 2;
#line 249
  mel_exp[9] = 3;
#line 249
  mel_exp[10] = 3;
#line 249
  mel_exp[11] = 4;
#line 249
  mel_exp[12] = 5;
#line 253
  if (melp->bits < 6) {
    {
#line 254
    mel_read(melp);
    }
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (melp->bits >= 6 && melp->num_runs < 8)) {
#line 260
      goto while_break;
    }
#line 261
    eval = mel_exp[melp->k];
#line 262
    run = 0;
#line 263
    if ((unsigned long long )melp->tmp & (1ULL << 63)) {
#line 265
      run = 1 << eval;
#line 266
      __cil_tmp5 = run;
#line 266
      run --;
#line 267
      if (melp->k + 1 < 12) {
#line 267
        tmp = melp->k + 1;
      } else {
#line 267
        tmp = 12;
      }
#line 267
      melp->k = tmp;
#line 268
      melp->tmp <<= 1;
#line 269
      (melp->bits) --;
#line 270
      run <<= 1;
    } else {
#line 273
      run = (int )(melp->tmp >> (63 - eval)) & ((1 << eval) - 1);
#line 274
      if (melp->k - 1 > 0) {
#line 274
        tmp___0 = melp->k - 1;
      } else {
#line 274
        tmp___0 = 0;
      }
#line 274
      melp->k = tmp___0;
#line 275
      melp->tmp <<= eval + 1;
#line 276
      melp->bits -= eval + 1;
#line 277
      run = (run << 1) + 1;
    }
#line 279
    eval = melp->num_runs * 7;
#line 280
    melp->runs &= ~ (63UL << eval);
#line 281
    melp->runs |= (OPJ_UINT64 )run << eval;
#line 282
    (melp->num_runs) ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 297 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_BOOL mel_init(dec_mel_t *melp , OPJ_UINT8 *bbuf , int lcup , int scup ) 
{ 
  int num ;
  int i ;
  OPJ_UINT64 d ;
  int d_bits ;
  int tmp ;
  int __cil_tmp10 ;

  {
#line 302
  melp->data = (bbuf + lcup) - scup;
#line 303
  melp->bits = 0;
#line 304
  melp->tmp = (OPJ_UINT64 )0;
#line 305
  melp->unstuff = 0;
#line 306
  melp->size = scup - 1;
#line 307
  melp->k = 0;
#line 308
  melp->num_runs = 0;
#line 309
  melp->runs = (OPJ_UINT64 )0;
#line 314
  num = 4 - (int )((intptr_t )melp->data & 3L);
#line 315
  i = 0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < num)) {
#line 315
      goto while_break;
    }
#line 319
    if (melp->unstuff == 1) {
#line 319
      if ((int )*(melp->data + 0) > 143) {
#line 320
        return (0);
      }
    }
#line 322
    if (melp->size > 0) {
#line 322
      tmp = (int )*(melp->data);
    } else {
#line 322
      tmp = 255;
    }
#line 322
    d = (OPJ_UINT64 )tmp;
#line 324
    if (melp->size == 1) {
#line 325
      d |= (unsigned long )15;
    }
#line 328
    __cil_tmp10 = melp->size;
#line 328
    (melp->size) --;
#line 328
    melp->data += __cil_tmp10 > 0;
#line 329
    d_bits = 8 - melp->unstuff;
#line 330
    melp->tmp = (melp->tmp << d_bits) | d;
#line 331
    melp->bits += d_bits;
#line 332
    melp->unstuff = (d & 255UL) == 255UL;
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  melp->tmp <<= 64 - melp->bits;
#line 337
  return (1);
}
}
#line 347 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static int mel_get_run(dec_mel_t *melp ) 
{ 
  int t ;
  int __cil_tmp3 ;

  {
#line 350
  if (melp->num_runs == 0) {
    {
#line 351
    mel_decode(melp);
    }
  }
#line 354
  t = (int )(melp->runs & 127UL);
#line 355
  melp->runs >>= 7;
#line 356
  __cil_tmp3 = melp->num_runs;
#line 356
  (melp->num_runs) --;
#line 357
  return (t);
}
}
#line 395 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void rev_read(rev_struct_t *vlcp ) 
{ 
  OPJ_UINT32 val ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 bits ;
  OPJ_BOOL unstuff ;
  OPJ_UINT32 __cil_tmp6 ;
  int i ;
  OPJ_UINT32 v ;
  OPJ_UINT8 *__cil_tmp9 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;

  {
#line 403
  if (vlcp->bits > 32U) {
#line 404
    return;
  }
#line 406
  val = (OPJ_UINT32 )0;
#line 408
  if (vlcp->size > 3) {
    {
#line 410
    val = read_le_uint32(vlcp->data - 3);
#line 411
    vlcp->data -= 4;
#line 412
    vlcp->size -= 4;
    }
  } else
#line 413
  if (vlcp->size > 0) {
#line 414
    i = 24;
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
#line 415
      if (! (vlcp->size > 0)) {
#line 415
        goto while_break;
      }
#line 416
      __cil_tmp9 = vlcp->data;
#line 416
      (vlcp->data) --;
#line 416
      v = (OPJ_UINT32 )*__cil_tmp9;
#line 417
      val |= v << i;
#line 418
      (vlcp->size) --;
#line 419
      i -= 8;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 424
  tmp = val >> 24;
#line 427
  if (vlcp->unstuff && ((val >> 24) & 127U) == 127U) {
#line 427
    tmp___43 = 1U;
  } else {
#line 427
    tmp___43 = 0U;
  }
#line 427
  bits = 8U - tmp___43;
#line 428
  unstuff = val >> 24 > 143U;
#line 430
  tmp |= ((val >> 16) & 255U) << bits;
#line 431
  if (unstuff && ((val >> 16) & 127U) == 127U) {
#line 431
    tmp___44 = 1U;
  } else {
#line 431
    tmp___44 = 0U;
  }
#line 431
  bits += 8U - tmp___44;
#line 432
  unstuff = ((val >> 16) & 255U) > 143U;
#line 434
  tmp |= ((val >> 8) & 255U) << bits;
#line 435
  if (unstuff && ((val >> 8) & 127U) == 127U) {
#line 435
    tmp___45 = 1U;
  } else {
#line 435
    tmp___45 = 0U;
  }
#line 435
  bits += 8U - tmp___45;
#line 436
  unstuff = ((val >> 8) & 255U) > 143U;
#line 438
  tmp |= (val & 255U) << bits;
#line 439
  if (unstuff && (val & 127U) == 127U) {
#line 439
    tmp___46 = 1U;
  } else {
#line 439
    tmp___46 = 0U;
  }
#line 439
  bits += 8U - tmp___46;
#line 440
  unstuff = (val & 255U) > 143U;
#line 443
  vlcp->tmp |= (OPJ_UINT64 )tmp << vlcp->bits;
#line 444
  vlcp->bits += bits;
#line 445
  vlcp->unstuff = unstuff;
  return;
}
}
#line 463 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void rev_init(rev_struct_t *vlcp , OPJ_UINT8 *data , int lcup , int scup ) 
{ 
  OPJ_UINT32 d ;
  int num ;
  int tnum ;
  int i ;
  OPJ_UINT8 *__cil_tmp9 ;
  int tmp ;
  OPJ_UINT64 d___47 ;
  OPJ_UINT32 d_bits ;
  OPJ_UINT8 *__cil_tmp13 ;
  unsigned int tmp___0 ;

  {
#line 469
  vlcp->data = (data + lcup) - 2;
#line 472
  vlcp->size = scup - 2;
#line 474
  __cil_tmp9 = vlcp->data;
#line 474
  (vlcp->data) --;
#line 474
  d = (OPJ_UINT32 )*__cil_tmp9;
#line 475
  vlcp->tmp = (OPJ_UINT64 )(d >> 4);
#line 476
  vlcp->bits = (OPJ_UINT32 )(4 - ((vlcp->tmp & 7UL) == 7UL));
#line 477
  vlcp->unstuff = (d | 15U) > 143U;
#line 484
  num = 1 + (int )((intptr_t )vlcp->data & 3L);
#line 485
  if (num < vlcp->size) {
#line 485
    tmp = num;
  } else {
#line 485
    tmp = vlcp->size;
  }
#line 485
  tnum = tmp;
#line 486
  i = 0;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! (i < tnum)) {
#line 486
      goto while_break;
    }
#line 489
    __cil_tmp13 = vlcp->data;
#line 489
    (vlcp->data) --;
#line 489
    d___47 = (OPJ_UINT64 )*__cil_tmp13;
#line 491
    if (vlcp->unstuff && (d___47 & 127UL) == 127UL) {
#line 491
      tmp___0 = 1U;
    } else {
#line 491
      tmp___0 = 0U;
    }
#line 491
    d_bits = 8U - tmp___0;
#line 492
    vlcp->tmp |= d___47 << vlcp->bits;
#line 493
    vlcp->bits += d_bits;
#line 494
    vlcp->unstuff = d___47 > 143UL;
#line 486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 496
  vlcp->size -= tnum;
#line 497
  rev_read(vlcp);
  }
  return;
}
}
#line 508 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 rev_fetch(rev_struct_t *vlcp ) 
{ 


  {
#line 510
  if (vlcp->bits < 32U) {
    {
#line 511
    rev_read(vlcp);
    }
#line 512
    if (vlcp->bits < 32U) {
      {
#line 513
      rev_read(vlcp);
      }
    }
  }
#line 516
  return ((OPJ_UINT32 )vlcp->tmp);
}
}
#line 526 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 rev_advance(rev_struct_t *vlcp , OPJ_UINT32 num_bits ) 
{ 


  {
#line 529
  vlcp->tmp >>= num_bits;
#line 530
  vlcp->bits -= num_bits;
#line 531
  return ((OPJ_UINT32 )vlcp->tmp);
}
}
#line 615 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void rev_init_mrp(rev_struct_t *mrp , OPJ_UINT8 *data , int lcup ,
                                  int len2 ) 
{ 
  int num ;
  int i ;
  OPJ_UINT64 d ;
  OPJ_UINT32 d_bits ;
  int __cil_tmp9 ;
  OPJ_UINT8 *__cil_tmp10 ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 619
  mrp->data = ((data + lcup) + len2) - 1;
#line 620
  mrp->size = len2;
#line 621
  mrp->unstuff = 1;
#line 622
  mrp->bits = (OPJ_UINT32 )0;
#line 623
  mrp->tmp = (OPJ_UINT64 )0;
#line 629
  num = 1 + (int )((intptr_t )mrp->data & 3L);
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < num)) {
#line 630
      goto while_break;
    }
#line 635
    __cil_tmp9 = mrp->size;
#line 635
    (mrp->size) --;
#line 635
    if (__cil_tmp9 > 0) {
#line 635
      __cil_tmp10 = mrp->data;
#line 635
      (mrp->data) --;
#line 635
      tmp = (int )*__cil_tmp10;
    } else {
#line 635
      tmp = 0;
    }
#line 635
    d = (OPJ_UINT64 )tmp;
#line 637
    if (mrp->unstuff && (d & 127UL) == 127UL) {
#line 637
      tmp___0 = 1U;
    } else {
#line 637
      tmp___0 = 0U;
    }
#line 637
    d_bits = 8U - tmp___0;
#line 638
    mrp->tmp |= d << mrp->bits;
#line 639
    mrp->bits += d_bits;
#line 640
    mrp->unstuff = d > 143UL;
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  rev_read(mrp);
  }
  return;
}
}
#line 691 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 decode_init_uvlc(OPJ_UINT32 vlc , OPJ_UINT32 mode , OPJ_UINT32 *u ) 
{ 
  static OPJ_UINT8 dec[8] ;
  OPJ_UINT32 consumed_bits ;
  OPJ_UINT32 d ;
  OPJ_UINT32 suffix_len ;
  OPJ_UINT32 tmp ;
  unsigned int tmp___0 ;
  OPJ_UINT32 d1 ;
  OPJ_UINT32 suffix_len___0 ;
  OPJ_UINT32 d2 ;
  OPJ_UINT32 suffix_len___1 ;
  OPJ_UINT32 d1___0 ;
  OPJ_UINT32 d2___0 ;
  OPJ_UINT32 suffix_len___2 ;

  {
#line 699
  dec[0] = (OPJ_UINT8 )((3 | (5 << 2)) | (5 << 5));
#line 699
  dec[1] = (OPJ_UINT8 )(1 | (1 << 5));
#line 699
  dec[2] = (OPJ_UINT8 )(2 | (2 << 5));
#line 699
  dec[3] = (OPJ_UINT8 )(1 | (1 << 5));
#line 699
  dec[4] = (OPJ_UINT8 )((3 | (1 << 2)) | (3 << 5));
#line 699
  dec[5] = (OPJ_UINT8 )(1 | (1 << 5));
#line 699
  dec[6] = (OPJ_UINT8 )(2 | (2 << 5));
#line 699
  dec[7] = (OPJ_UINT8 )(1 | (1 << 5));
#line 710
  consumed_bits = (OPJ_UINT32 )0;
#line 711
  if (mode == 0U) {
#line 712
    *(u + 1) = (OPJ_UINT32 )1;
#line 712
    *(u + 0) = *(u + 1);
  } else
#line 713
  if (mode <= 2U) {
#line 717
    d = (OPJ_UINT32 )dec[vlc & 7U];
#line 718
    vlc >>= d & 3U;
#line 719
    consumed_bits += d & 3U;
#line 721
    suffix_len = (d >> 2) & 7U;
#line 722
    consumed_bits += suffix_len;
#line 724
    d = (d >> 5) + (vlc & ((1U << suffix_len) - 1U));
#line 725
    if (mode == 1U) {
#line 725
      tmp = d + 1U;
    } else {
#line 725
      tmp = (unsigned int )1;
    }
#line 725
    *(u + 0) = tmp;
#line 726
    if (mode == 1U) {
#line 726
      tmp___0 = (unsigned int )1;
    } else {
#line 726
      tmp___0 = d + 1U;
    }
#line 726
    *(u + 1) = tmp___0;
  } else
#line 727
  if (mode == 3U) {
#line 728
    d1 = (OPJ_UINT32 )dec[vlc & 7U];
#line 729
    vlc >>= d1 & 3U;
#line 730
    consumed_bits += d1 & 3U;
#line 732
    if ((d1 & 3U) > 2U) {
#line 736
      *(u + 1) = ((vlc & 1U) + 1U) + 1U;
#line 737
      consumed_bits ++;
#line 738
      vlc >>= 1;
#line 740
      suffix_len___0 = (d1 >> 2) & 7U;
#line 741
      consumed_bits += suffix_len___0;
#line 742
      d1 = (d1 >> 5) + (vlc & ((1U << suffix_len___0) - 1U));
#line 743
      *(u + 0) = d1 + 1U;
    } else {
#line 748
      d2 = (OPJ_UINT32 )dec[vlc & 7U];
#line 749
      vlc >>= d2 & 3U;
#line 750
      consumed_bits += d2 & 3U;
#line 752
      suffix_len___1 = (d1 >> 2) & 7U;
#line 753
      consumed_bits += suffix_len___1;
#line 755
      d1 = (d1 >> 5) + (vlc & ((1U << suffix_len___1) - 1U));
#line 756
      *(u + 0) = d1 + 1U;
#line 757
      vlc >>= suffix_len___1;
#line 759
      suffix_len___1 = (d2 >> 2) & 7U;
#line 760
      consumed_bits += suffix_len___1;
#line 762
      d2 = (d2 >> 5) + (vlc & ((1U << suffix_len___1) - 1U));
#line 763
      *(u + 1) = d2 + 1U;
    }
  } else
#line 765
  if (mode == 4U) {
#line 770
    d1___0 = (OPJ_UINT32 )dec[vlc & 7U];
#line 771
    vlc >>= d1___0 & 3U;
#line 772
    consumed_bits += d1___0 & 3U;
#line 774
    d2___0 = (OPJ_UINT32 )dec[vlc & 7U];
#line 775
    vlc >>= d2___0 & 3U;
#line 776
    consumed_bits += d2___0 & 3U;
#line 778
    suffix_len___2 = (d1___0 >> 2) & 7U;
#line 779
    consumed_bits += suffix_len___2;
#line 781
    d1___0 = (d1___0 >> 5) + (vlc & ((1U << suffix_len___2) - 1U));
#line 782
    *(u + 0) = d1___0 + 3U;
#line 783
    vlc >>= suffix_len___2;
#line 785
    suffix_len___2 = (d2___0 >> 2) & 7U;
#line 786
    consumed_bits += suffix_len___2;
#line 788
    d2___0 = (d2___0 >> 5) + (vlc & ((1U << suffix_len___2) - 1U));
#line 789
    *(u + 1) = d2___0 + 3U;
  }
#line 791
  return (consumed_bits);
}
}
#line 804 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 decode_noninit_uvlc(OPJ_UINT32 vlc , OPJ_UINT32 mode ,
                                               OPJ_UINT32 *u ) 
{ 
  static OPJ_UINT8 dec[8] ;
  OPJ_UINT32 consumed_bits ;
  OPJ_UINT32 d ;
  OPJ_UINT32 suffix_len ;
  OPJ_UINT32 tmp ;
  unsigned int tmp___0 ;
  OPJ_UINT32 d1 ;
  OPJ_UINT32 d2 ;
  OPJ_UINT32 suffix_len___0 ;

  {
#line 812
  dec[0] = (OPJ_UINT8 )((3 | (5 << 2)) | (5 << 5));
#line 812
  dec[1] = (OPJ_UINT8 )(1 | (1 << 5));
#line 812
  dec[2] = (OPJ_UINT8 )(2 | (2 << 5));
#line 812
  dec[3] = (OPJ_UINT8 )(1 | (1 << 5));
#line 812
  dec[4] = (OPJ_UINT8 )((3 | (1 << 2)) | (3 << 5));
#line 812
  dec[5] = (OPJ_UINT8 )(1 | (1 << 5));
#line 812
  dec[6] = (OPJ_UINT8 )(2 | (2 << 5));
#line 812
  dec[7] = (OPJ_UINT8 )(1 | (1 << 5));
#line 823
  consumed_bits = (OPJ_UINT32 )0;
#line 824
  if (mode == 0U) {
#line 825
    *(u + 1) = (OPJ_UINT32 )1;
#line 825
    *(u + 0) = *(u + 1);
  } else
#line 826
  if (mode <= 2U) {
#line 830
    d = (OPJ_UINT32 )dec[vlc & 7U];
#line 831
    vlc >>= d & 3U;
#line 832
    consumed_bits += d & 3U;
#line 834
    suffix_len = (d >> 2) & 7U;
#line 835
    consumed_bits += suffix_len;
#line 837
    d = (d >> 5) + (vlc & ((1U << suffix_len) - 1U));
#line 838
    if (mode == 1U) {
#line 838
      tmp = d + 1U;
    } else {
#line 838
      tmp = (unsigned int )1;
    }
#line 838
    *(u + 0) = tmp;
#line 839
    if (mode == 1U) {
#line 839
      tmp___0 = (unsigned int )1;
    } else {
#line 839
      tmp___0 = d + 1U;
    }
#line 839
    *(u + 1) = tmp___0;
  } else
#line 840
  if (mode == 3U) {
#line 845
    d1 = (OPJ_UINT32 )dec[vlc & 7U];
#line 846
    vlc >>= d1 & 3U;
#line 847
    consumed_bits += d1 & 3U;
#line 849
    d2 = (OPJ_UINT32 )dec[vlc & 7U];
#line 850
    vlc >>= d2 & 3U;
#line 851
    consumed_bits += d2 & 3U;
#line 853
    suffix_len___0 = (d1 >> 2) & 7U;
#line 854
    consumed_bits += suffix_len___0;
#line 856
    d1 = (d1 >> 5) + (vlc & ((1U << suffix_len___0) - 1U));
#line 857
    *(u + 0) = d1 + 1U;
#line 858
    vlc >>= suffix_len___0;
#line 860
    suffix_len___0 = (d2 >> 2) & 7U;
#line 861
    consumed_bits += suffix_len___0;
#line 863
    d2 = (d2 >> 5) + (vlc & ((1U << suffix_len___0) - 1U));
#line 864
    *(u + 1) = d2 + 1U;
  }
#line 866
  return (consumed_bits);
}
}
#line 900 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void frwd_read(frwd_struct_t *msp ) 
{ 
  OPJ_UINT32 val ;
  OPJ_UINT32 bits ;
  OPJ_UINT32 t ;
  OPJ_BOOL unstuff ;
  OPJ_UINT32 __cil_tmp6 ;
  int i ;
  unsigned int tmp ;
  OPJ_UINT32 v ;
  OPJ_UINT8 *__cil_tmp10 ;
  OPJ_UINT32 m ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 909
  val = 0U;
#line 910
  if (msp->size > 3) {
    {
#line 911
    val = read_le_uint32(msp->data);
#line 912
    msp->data += 4;
#line 913
    msp->size -= 4;
    }
  } else
#line 914
  if (msp->size > 0) {
#line 915
    i = 0;
#line 916
    if (msp->X != 0U) {
#line 916
      tmp = 4294967295U;
    } else {
#line 916
      tmp = (unsigned int )0;
    }
#line 916
    val = tmp;
    {
#line 917
    while (1) {
      while_continue: /* CIL Label */ ;
#line 917
      if (! (msp->size > 0)) {
#line 917
        goto while_break;
      }
#line 918
      __cil_tmp10 = msp->data;
#line 918
      (msp->data) ++;
#line 918
      v = (OPJ_UINT32 )*__cil_tmp10;
#line 919
      m = ~ (255U << i);
#line 920
      val = (val & m) | (v << i);
#line 921
      (msp->size) --;
#line 922
      i += 8;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 925
    if (msp->X != 0U) {
#line 925
      tmp___0 = 4294967295U;
    } else {
#line 925
      tmp___0 = (unsigned int )0;
    }
#line 925
    val = tmp___0;
  }
#line 929
  if (msp->unstuff) {
#line 929
    tmp___1 = 1U;
  } else {
#line 929
    tmp___1 = 0U;
  }
#line 929
  bits = 8U - tmp___1;
#line 930
  t = val & 255U;
#line 931
  unstuff = (val & 255U) == 255U;
#line 933
  t |= ((val >> 8) & 255U) << bits;
#line 934
  if (unstuff) {
#line 934
    tmp___2 = 1U;
  } else {
#line 934
    tmp___2 = 0U;
  }
#line 934
  bits += 8U - tmp___2;
#line 935
  unstuff = ((val >> 8) & 255U) == 255U;
#line 937
  t |= ((val >> 16) & 255U) << bits;
#line 938
  if (unstuff) {
#line 938
    tmp___3 = 1U;
  } else {
#line 938
    tmp___3 = 0U;
  }
#line 938
  bits += 8U - tmp___3;
#line 939
  unstuff = ((val >> 16) & 255U) == 255U;
#line 941
  t |= ((val >> 24) & 255U) << bits;
#line 942
  if (unstuff) {
#line 942
    tmp___4 = 1U;
  } else {
#line 942
    tmp___4 = 0U;
  }
#line 942
  bits += 8U - tmp___4;
#line 943
  msp->unstuff = ((val >> 24) & 255U) == 255U;
#line 945
  msp->tmp |= (OPJ_UINT64 )t << msp->bits;
#line 946
  msp->bits += bits;
  return;
}
}
#line 959 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void frwd_init(frwd_struct_t *msp , OPJ_UINT8 *data , int size , OPJ_UINT32 X ) 
{ 
  int num ;
  int i ;
  OPJ_UINT64 d ;
  int __cil_tmp8 ;
  OPJ_UINT8 *__cil_tmp9 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 964
  msp->data = data;
#line 965
  msp->tmp = (OPJ_UINT64 )0;
#line 966
  msp->bits = (OPJ_UINT32 )0;
#line 967
  msp->unstuff = 0;
#line 968
  msp->size = size;
#line 969
  msp->X = X;
#line 976
  num = 4 - (int )((intptr_t )msp->data & 3L);
#line 977
  i = 0;
  {
#line 977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 977
    if (! (i < num)) {
#line 977
      goto while_break;
    }
#line 980
    __cil_tmp8 = msp->size;
#line 980
    (msp->size) --;
#line 980
    if (__cil_tmp8 > 0) {
#line 980
      (msp->data) ++;
#line 980
      tmp = (unsigned int )*(msp->data);
    } else {
#line 980
      tmp = msp->X;
    }
#line 980
    d = (OPJ_UINT64 )tmp;
#line 981
    msp->tmp |= d << msp->bits;
#line 982
    if (msp->unstuff) {
#line 982
      tmp___0 = 1U;
    } else {
#line 982
      tmp___0 = 0U;
    }
#line 982
    msp->bits += 8U - tmp___0;
#line 983
    msp->unstuff = (d & 255UL) == 255UL;
#line 977
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 985
  frwd_read(msp);
  }
  return;
}
}
#line 995 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static void frwd_advance(frwd_struct_t *msp , OPJ_UINT32 num_bits ) 
{ 


  {
#line 998
  msp->tmp >>= num_bits;
#line 999
  msp->bits -= num_bits;
  return;
}
}
#line 1008 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
__inline static OPJ_UINT32 frwd_fetch(frwd_struct_t *msp ) 
{ 


  {
#line 1010
  if (msp->bits < 32U) {
    {
#line 1011
    frwd_read(msp);
    }
#line 1012
    if (msp->bits < 32U) {
      {
#line 1013
      frwd_read(msp);
      }
    }
  }
#line 1016
  return ((OPJ_UINT32 )msp->tmp);
}
}
#line 1026 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
static OPJ_BOOL opj_t1_allocate_buffers(opj_t1_t *t1 , OPJ_UINT32 w , OPJ_UINT32 h ) 
{ 
  OPJ_UINT32 flagssize ;
  OPJ_UINT32 datasize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1041
  datasize = w * h;
#line 1043
  if (datasize > t1->datasize) {
    {
#line 1044
    opj_aligned_free(t1->data);
#line 1045
    __cil_tmp6 = opj_aligned_malloc((unsigned long )datasize * sizeof(OPJ_INT32 ));
#line 1045
    t1->data = (OPJ_INT32 *)__cil_tmp6;
    }
#line 1047
    if (! t1->data) {
#line 1049
      return (0);
    }
#line 1051
    t1->datasize = datasize;
  }
#line 1054
  if (t1->data != (void *)0) {
    {
#line 1055
    memset(t1->data, 0, (unsigned long )datasize * sizeof(OPJ_INT32 ));
    }
  }
#line 1062
  flagssize = (OPJ_UINT32 )((132UL * sizeof(OPJ_UINT32 )) * 4UL);
#line 1063
  flagssize += 528U;
#line 1066
  if (flagssize > t1->flagssize) {
    {
#line 1068
    opj_aligned_free(t1->flags);
#line 1069
    __cil_tmp7 = opj_aligned_malloc((unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1069
    t1->flags = (opj_flag_t *)__cil_tmp7;
    }
#line 1070
    if (! t1->flags) {
#line 1072
      return (0);
    }
  }
  {
#line 1075
  t1->flagssize = flagssize;
#line 1077
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(opj_flag_t ));
#line 1080
  t1->w = w;
#line 1081
  t1->h = h;
  }
#line 1083
  return (1);
}
}
#line 1097
OPJ_BOOL opj_t1_ht_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                               OPJ_UINT32 roishift , OPJ_UINT32 cblksty , opj_event_mgr_t *p_manager ,
                               opj_mutex_t *p_manager_mutex , OPJ_BOOL check_pterm ) ;
#line 1119 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/ht_dec.c"
OPJ_BOOL opj_t1_ht_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , OPJ_UINT32 orient ,
                               OPJ_UINT32 roishift , OPJ_UINT32 cblksty , opj_event_mgr_t *p_manager ,
                               opj_mutex_t *p_manager_mutex , OPJ_BOOL check_pterm ) 
{ 
  OPJ_BYTE *cblkdata ;
  OPJ_UINT8 *coded_data ;
  OPJ_UINT32 *decoded_data ;
  OPJ_UINT32 zero_bplanes ;
  OPJ_UINT32 num_passes ;
  OPJ_UINT32 lengths1 ;
  OPJ_UINT32 lengths2 ;
  OPJ_INT32 width ;
  OPJ_INT32 height ;
  OPJ_INT32 stride ;
  OPJ_UINT32 *pflags ;
  OPJ_UINT32 *sigma1 ;
  OPJ_UINT32 *sigma2 ;
  OPJ_UINT32 *mbr1 ;
  OPJ_UINT32 *mbr2 ;
  OPJ_UINT32 *sip ;
  OPJ_UINT32 sip_shift ;
  OPJ_UINT32 p ;
  OPJ_UINT32 zero_bplanes_p1 ;
  int lcup ;
  int scup ;
  dec_mel_t mel ;
  rev_struct_t vlc ;
  frwd_struct_t magsgn ;
  frwd_struct_t sigprop ;
  rev_struct_t magref ;
  OPJ_UINT8 *lsp ;
  OPJ_UINT8 *line_state ;
  int run ;
  OPJ_UINT32 vlc_val ;
  OPJ_UINT32 qinf[2] ;
  OPJ_UINT32 c_q ;
  OPJ_UINT32 *sp ;
  OPJ_INT32 x ;
  OPJ_INT32 y ;
  OPJ_BOOL stripe_causal ;
  OPJ_UINT32 cblk_len ;
  OPJ_BOOL __cil_tmp46 ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_UINT32 i___0 ;
  void *__cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  OPJ_BOOL __cil_tmp56 ;
  int __cil_tmp57 ;
  OPJ_UINT32 U_q[2] ;
  OPJ_UINT32 uvlc_mode ;
  OPJ_UINT32 consumed_bits ;
  OPJ_UINT32 m_n ;
  OPJ_UINT32 v_n ;
  OPJ_UINT32 ms_val ;
  OPJ_UINT32 locs ;
  OPJ_UINT32 __cil_tmp65 ;
  OPJ_UINT32 tmp___3 ;
  int __cil_tmp67 ;
  OPJ_UINT32 __cil_tmp68 ;
  OPJ_UINT32 tmp___4 ;
  int __cil_tmp70 ;
  OPJ_UINT32 __cil_tmp71 ;
  int tmp___5 ;
  int tmp___6 ;
  int __cil_tmp74 ;
  OPJ_UINT32 __cil_tmp75 ;
  OPJ_UINT32 __cil_tmp76 ;
  OPJ_UINT32 tmp___7 ;
  OPJ_UINT32 val ;
  OPJ_UINT32 __cil_tmp79 ;
  OPJ_UINT32 val___0 ;
  OPJ_UINT32 t ;
  OPJ_UINT32 __cil_tmp82 ;
  OPJ_UINT32 __cil_tmp83 ;
  OPJ_UINT32 tmp___8 ;
  OPJ_UINT32 val___1 ;
  OPJ_UINT32 __cil_tmp86 ;
  OPJ_UINT32 val___2 ;
  OPJ_UINT32 __cil_tmp88 ;
  OPJ_UINT32 __cil_tmp89 ;
  OPJ_UINT32 val___3 ;
  OPJ_UINT32 __cil_tmp91 ;
  OPJ_UINT32 val___4 ;
  OPJ_UINT32 t___0 ;
  OPJ_UINT32 __cil_tmp94 ;
  OPJ_UINT32 __cil_tmp95 ;
  OPJ_UINT32 tmp___9 ;
  OPJ_UINT32 val___5 ;
  OPJ_UINT32 __cil_tmp98 ;
  OPJ_UINT32 val___6 ;
  OPJ_UINT32 __cil_tmp100 ;
  OPJ_UINT32 __cil_tmp101 ;
  OPJ_UINT32 *sip___57 ;
  OPJ_UINT8 ls0 ;
  OPJ_INT32 x___58 ;
  OPJ_UINT32 *tmp___10 ;
  OPJ_UINT32 U_q___0[2] ;
  OPJ_UINT32 uvlc_mode___0 ;
  OPJ_UINT32 consumed_bits___0 ;
  OPJ_UINT32 m_n___0 ;
  OPJ_UINT32 v_n___0 ;
  OPJ_UINT32 ms_val___0 ;
  OPJ_UINT32 locs___0 ;
  OPJ_UINT32 __cil_tmp113 ;
  OPJ_UINT32 tmp___11 ;
  int __cil_tmp115 ;
  OPJ_UINT32 __cil_tmp116 ;
  OPJ_UINT32 tmp___12 ;
  int __cil_tmp118 ;
  OPJ_UINT32 __cil_tmp119 ;
  int tmp___13 ;
  OPJ_UINT32 __cil_tmp121 ;
  OPJ_UINT32 __cil_tmp122 ;
  OPJ_UINT32 E ;
  OPJ_UINT32 tmp___14 ;
  OPJ_UINT32 tmp___15 ;
  OPJ_UINT32 E___0 ;
  OPJ_UINT32 tmp___16 ;
  OPJ_UINT32 tmp___17 ;
  OPJ_UINT32 tmp___18 ;
  OPJ_UINT32 val___7 ;
  OPJ_UINT32 __cil_tmp131 ;
  OPJ_UINT32 val___8 ;
  OPJ_UINT32 t___1 ;
  OPJ_UINT32 __cil_tmp134 ;
  OPJ_UINT32 __cil_tmp135 ;
  OPJ_UINT32 tmp___19 ;
  OPJ_UINT32 val___9 ;
  OPJ_UINT32 __cil_tmp138 ;
  OPJ_UINT32 val___10 ;
  OPJ_UINT32 __cil_tmp140 ;
  OPJ_UINT32 __cil_tmp141 ;
  OPJ_UINT32 val___11 ;
  OPJ_UINT32 __cil_tmp143 ;
  OPJ_UINT32 val___12 ;
  OPJ_UINT32 t___2 ;
  OPJ_UINT32 __cil_tmp146 ;
  OPJ_UINT32 __cil_tmp147 ;
  OPJ_UINT32 tmp___20 ;
  OPJ_UINT32 val___13 ;
  OPJ_UINT32 __cil_tmp150 ;
  OPJ_UINT32 val___14 ;
  OPJ_UINT32 __cil_tmp152 ;
  OPJ_UINT32 __cil_tmp153 ;
  OPJ_UINT32 *cur_sig ;
  OPJ_UINT32 *tmp___21 ;
  OPJ_UINT32 *dpp ;
  OPJ_UINT32 half ;
  OPJ_INT32 i___1 ;
  OPJ_UINT32 cwd ;
  OPJ_UINT32 __cil_tmp160 ;
  OPJ_UINT32 sig ;
  OPJ_UINT32 *__cil_tmp162 ;
  OPJ_UINT32 col_mask ;
  OPJ_UINT32 *dp ;
  int j ;
  OPJ_UINT32 sample_mask ;
  OPJ_UINT32 sym ;
  OPJ_UINT32 sym___0 ;
  OPJ_UINT32 sym___1 ;
  OPJ_UINT32 sym___2 ;
  OPJ_UINT32 *__cil_tmp171 ;
  OPJ_UINT32 __cil_tmp172 ;
  OPJ_UINT32 *sig___0 ;
  OPJ_UINT32 *tmp___22 ;
  OPJ_UINT32 *mbr ;
  OPJ_UINT32 *tmp___23 ;
  OPJ_UINT32 prev ;
  OPJ_INT32 i___2 ;
  OPJ_UINT32 t___3 ;
  OPJ_UINT32 z ;
  OPJ_UINT32 *__cil_tmp181 ;
  OPJ_UINT32 *__cil_tmp182 ;
  OPJ_UINT32 *cur_sig___0 ;
  OPJ_UINT32 *cur_mbr ;
  OPJ_UINT32 *nxt_sig ;
  OPJ_UINT32 *nxt_mbr ;
  OPJ_UINT32 prev___0 ;
  OPJ_UINT32 val___15 ;
  OPJ_INT32 i___3 ;
  OPJ_UINT32 *tmp___24 ;
  OPJ_UINT32 *tmp___25 ;
  OPJ_UINT32 *tmp___26 ;
  OPJ_UINT32 t___4 ;
  OPJ_UINT32 *__cil_tmp194 ;
  OPJ_UINT32 *__cil_tmp195 ;
  OPJ_UINT32 *__cil_tmp196 ;
  OPJ_UINT32 *tmp___27 ;
  OPJ_UINT32 *tmp___28 ;
  OPJ_UINT32 *tmp___29 ;
  OPJ_UINT32 *tmp___30 ;
  OPJ_UINT32 ux ;
  OPJ_UINT32 tx ;
  OPJ_UINT32 mbr___0 ;
  OPJ_UINT32 new_sig ;
  OPJ_INT32 n ;
  OPJ_UINT32 col_mask___0 ;
  OPJ_UINT32 inv_sig ;
  OPJ_INT32 end ;
  OPJ_INT32 j___0 ;
  OPJ_UINT32 cwd___0 ;
  OPJ_UINT32 __cil_tmp211 ;
  OPJ_UINT32 cnt ;
  OPJ_UINT32 *dp___0 ;
  OPJ_INT32 tmp___31 ;
  OPJ_UINT32 sample_mask___0 ;
  OPJ_UINT32 t___5 ;
  OPJ_UINT32 t___6 ;
  OPJ_UINT32 t___7 ;
  OPJ_UINT32 t___8 ;
  OPJ_UINT32 col_mask___60 ;
  OPJ_INT32 j___61 ;
  OPJ_UINT32 *dp___62 ;
  OPJ_UINT32 sample_mask___1 ;
  OPJ_UINT32 t___9 ;
  OPJ_UINT32 *__cil_tmp225 ;
  OPJ_UINT32 *__cil_tmp226 ;
  OPJ_UINT32 *__cil_tmp227 ;
  OPJ_UINT32 *__cil_tmp228 ;
  OPJ_UINT32 *tmp___32 ;
  OPJ_INT32 st ;
  OPJ_INT32 y___63 ;
  OPJ_UINT32 *cur_sig___1 ;
  OPJ_UINT32 *tmp___33 ;
  OPJ_UINT32 *dpp___0 ;
  OPJ_UINT32 half___0 ;
  OPJ_INT32 i___4 ;
  OPJ_UINT32 cwd___1 ;
  OPJ_UINT32 __cil_tmp238 ;
  OPJ_UINT32 sig___1 ;
  OPJ_UINT32 *__cil_tmp240 ;
  OPJ_UINT32 col_mask___61 ;
  OPJ_UINT32 *dp___63 ;
  int j___62 ;
  OPJ_UINT32 sample_mask___2 ;
  OPJ_UINT32 sym___3 ;
  OPJ_UINT32 sym___4 ;
  OPJ_UINT32 sym___5 ;
  OPJ_UINT32 sym___6 ;
  OPJ_UINT32 *__cil_tmp249 ;
  OPJ_UINT32 __cil_tmp250 ;
  OPJ_UINT32 *sig___2 ;
  OPJ_UINT32 *tmp___34 ;
  OPJ_UINT32 *mbr___1 ;
  OPJ_UINT32 *tmp___35 ;
  OPJ_UINT32 prev___1 ;
  OPJ_INT32 i___5 ;
  OPJ_UINT32 t___10 ;
  OPJ_UINT32 z___0 ;
  OPJ_UINT32 *__cil_tmp259 ;
  OPJ_UINT32 *__cil_tmp260 ;
  OPJ_INT32 tmp___36 ;
  OPJ_UINT32 *cur_sig___2 ;
  OPJ_UINT32 *cur_mbr___0 ;
  OPJ_UINT32 *nxt_sig___0 ;
  OPJ_UINT32 *nxt_mbr___0 ;
  OPJ_UINT32 val___16 ;
  OPJ_INT32 i___6 ;
  OPJ_UINT32 pattern ;
  OPJ_UINT32 prev___2 ;
  OPJ_INT32 i___66 ;
  OPJ_UINT32 *tmp___37 ;
  OPJ_UINT32 *tmp___38 ;
  OPJ_UINT32 *tmp___39 ;
  OPJ_UINT32 t___11 ;
  OPJ_UINT32 *__cil_tmp275 ;
  OPJ_UINT32 *__cil_tmp276 ;
  OPJ_UINT32 *__cil_tmp277 ;
  OPJ_UINT32 *tmp___40 ;
  OPJ_UINT32 *tmp___41 ;
  OPJ_UINT32 *tmp___42 ;
  OPJ_UINT32 *tmp___43 ;
  OPJ_UINT32 mbr___2 ;
  OPJ_UINT32 new_sig___0 ;
  OPJ_UINT32 ux___0 ;
  OPJ_UINT32 tx___0 ;
  OPJ_INT32 n___0 ;
  OPJ_UINT32 col_mask___62 ;
  OPJ_UINT32 inv_sig___0 ;
  OPJ_INT32 end___0 ;
  OPJ_INT32 j___63 ;
  OPJ_UINT32 cwd___2 ;
  OPJ_UINT32 __cil_tmp292 ;
  OPJ_UINT32 cnt___0 ;
  OPJ_UINT32 *dp___64 ;
  OPJ_INT32 tmp___44 ;
  OPJ_UINT32 sample_mask___3 ;
  OPJ_UINT32 t___12 ;
  OPJ_UINT32 t___13 ;
  OPJ_UINT32 t___14 ;
  OPJ_UINT32 t___15 ;
  OPJ_UINT32 col_mask___67 ;
  OPJ_INT32 j___68 ;
  OPJ_UINT32 *dp___69 ;
  OPJ_UINT32 sample_mask___4 ;
  OPJ_UINT32 t___16 ;
  OPJ_UINT32 *__cil_tmp306 ;
  OPJ_UINT32 *__cil_tmp307 ;
  OPJ_UINT32 *__cil_tmp308 ;
  OPJ_UINT32 *__cil_tmp309 ;
  OPJ_INT32 x___70 ;
  OPJ_INT32 y___71 ;
  OPJ_INT32 *sp___72 ;
  OPJ_INT32 val___17 ;
  OPJ_INT32 tmp___45 ;

  {
#line 1128
  cblkdata = (OPJ_BYTE *)((void *)0);
#line 1154
  stripe_causal = (cblksty & 8U) != 0U;
#line 1155
  cblk_len = (OPJ_UINT32 )0;
#line 1162
  if (roishift != 0U) {
#line 1163
    if (p_manager_mutex) {
      {
#line 1164
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1166
    opj_event_msg(p_manager, 1, "We do not support ROI in decoding HT codeblocks\n");
    }
#line 1168
    if (p_manager_mutex) {
      {
#line 1169
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1171
    return (0);
  }
  {
#line 1174
  __cil_tmp46 = opj_t1_allocate_buffers(t1, (OPJ_UINT32 )(cblk->x1 - cblk->x0), (OPJ_UINT32 )(cblk->y1 - cblk->y0));
  }
#line 1174
  if (! __cil_tmp46) {
#line 1178
    return (0);
  }
#line 1181
  if (cblk->Mb == 0U) {
#line 1182
    return (1);
  }
#line 1186
  zero_bplanes = (cblk->Mb + 1U) - cblk->numbps;
#line 1189
  cblk_len = (OPJ_UINT32 )0;
#line 1192
  i = (OPJ_UINT32 )0;
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (i < cblk->numchunks)) {
#line 1192
      goto while_break;
    }
#line 1193
    cblk_len += (cblk->chunks + i)->len;
#line 1192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1197
  if (cblk->numchunks > 1U) {
    _L: /* CIL Label */ 
#line 1201
    if (cblk_len > t1->cblkdatabuffersize) {
      {
#line 1202
      __cil_tmp50 = opj_realloc(t1->cblkdatabuffer, (size_t )cblk_len);
#line 1202
      cblkdata = (OPJ_BYTE *)__cil_tmp50;
      }
#line 1204
      if (cblkdata == (void *)0) {
#line 1205
        return (0);
      }
#line 1207
      t1->cblkdatabuffer = cblkdata;
#line 1208
      t1->cblkdatabuffersize = cblk_len;
    }
#line 1212
    cblkdata = t1->cblkdatabuffer;
#line 1213
    cblk_len = (OPJ_UINT32 )0;
#line 1214
    i___0 = (OPJ_UINT32 )0;
    {
#line 1214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1214
      if (! (i___0 < cblk->numchunks)) {
#line 1214
        goto while_break___0;
      }
      {
#line 1215
      memcpy(cblkdata + cblk_len, (cblk->chunks + i___0)->data, (unsigned long )(cblk->chunks + i___0)->len);
#line 1216
      cblk_len += (cblk->chunks + i___0)->len;
      }
#line 1214
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1197
  if (t1->mustuse_cblkdatabuffer) {
#line 1197
    goto _L;
  } else
#line 1218
  if (cblk->numchunks == 1U) {
#line 1219
    cblkdata = (cblk->chunks + 0)->data;
  } else {
#line 1223
    return (1);
  }
#line 1227
  coded_data = cblkdata;
#line 1229
  decoded_data = (OPJ_UINT32 *)t1->data;
#line 1232
  if (cblk->numsegs > 0U) {
#line 1232
    tmp = (cblk->segs + 0)->real_num_passes;
  } else {
#line 1232
    tmp = (unsigned int )0;
  }
#line 1232
  num_passes = tmp;
#line 1233
  if (cblk->numsegs > 1U) {
#line 1233
    tmp___0 = (cblk->segs + 1)->real_num_passes;
  } else {
#line 1233
    tmp___0 = (unsigned int )0;
  }
#line 1233
  num_passes += tmp___0;
#line 1235
  if (num_passes > 0U) {
#line 1235
    tmp___1 = (cblk->segs + 0)->len;
  } else {
#line 1235
    tmp___1 = (unsigned int )0;
  }
#line 1235
  lengths1 = tmp___1;
#line 1237
  if (num_passes > 1U) {
#line 1237
    tmp___2 = (cblk->segs + 1)->len;
  } else {
#line 1237
    tmp___2 = (unsigned int )0;
  }
#line 1237
  lengths2 = tmp___2;
#line 1239
  width = cblk->x1 - cblk->x0;
#line 1241
  height = cblk->y1 - cblk->y0;
#line 1243
  stride = width;
#line 1259
  pflags = (OPJ_UINT32 *)t1->flags;
#line 1260
  sigma1 = pflags;
#line 1261
  sigma2 = sigma1 + 132;
#line 1264
  mbr1 = sigma2 + 132;
#line 1265
  mbr2 = mbr1 + 132;
#line 1267
  sip = sigma1;
#line 1268
  sip_shift = (OPJ_UINT32 )0;
#line 1270
  if (num_passes > 1U) {
#line 1270
    if (lengths2 == 0U) {
#line 1271
      if (p_manager_mutex) {
        {
#line 1272
        opj_mutex_lock(p_manager_mutex);
        }
      }
      {
#line 1274
      opj_event_msg(p_manager, 2, "A malformed codeblock that has more than one coding pass, but zero length for 2nd and potentially the 3rd pass in an HT codeblock.\n");
      }
#line 1277
      if (p_manager_mutex) {
        {
#line 1278
        opj_mutex_unlock(p_manager_mutex);
        }
      }
#line 1280
      num_passes = (OPJ_UINT32 )1;
    }
  }
#line 1282
  if (num_passes > 3U) {
#line 1283
    if (p_manager_mutex) {
      {
#line 1284
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1286
    opj_event_msg(p_manager, 1, "We do not support more than 3 coding passes in an HT codeblock; This codeblocks has %d passes.\n",
                  num_passes);
    }
#line 1289
    if (p_manager_mutex) {
      {
#line 1290
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1292
    return (0);
  }
#line 1295
  if (cblk->Mb > 30U) {
#line 1305
    if (p_manager_mutex) {
      {
#line 1306
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1308
    opj_event_msg(p_manager, 1, "32 bits are not enough to decode this codeblock, since the number of bitplane, %d, is larger than 30.\n",
                  cblk->Mb);
    }
#line 1311
    if (p_manager_mutex) {
      {
#line 1312
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1314
    return (0);
  }
#line 1316
  if (zero_bplanes > cblk->Mb) {
#line 1321
    if (p_manager_mutex) {
      {
#line 1322
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1324
    opj_event_msg(p_manager, 1, "Malformed HT codeblock. Decoding this codeblock is stopped. There are %d zero bitplanes in %d bitplanes.\n",
                  zero_bplanes, cblk->Mb);
    }
#line 1329
    if (p_manager_mutex) {
      {
#line 1330
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1332
    return (0);
  } else
#line 1333
  if (zero_bplanes == cblk->Mb) {
#line 1333
    if (num_passes > 1U) {
#line 1336
      if (only_cleanup_pass_is_decoded == 0) {
#line 1337
        if (p_manager_mutex) {
          {
#line 1338
          opj_mutex_lock(p_manager_mutex);
          }
        }
#line 1344
        if (only_cleanup_pass_is_decoded == 0) {
          {
#line 1345
          only_cleanup_pass_is_decoded = 1;
#line 1346
          opj_event_msg(p_manager, 2, "Malformed HT codeblock. When the number of zero planes bitplanes is equal to the number of bitplanes, only the cleanup pass makes sense, but we have %d passes in this codeblock. Therefore, only the cleanup pass will be decoded. This message will not be displayed again.\n",
                        num_passes);
          }
        }
#line 1354
        if (p_manager_mutex) {
          {
#line 1355
          opj_mutex_unlock(p_manager_mutex);
          }
        }
      }
#line 1358
      num_passes = (OPJ_UINT32 )1;
    }
  }
#line 1362
  p = cblk->numbps;
#line 1365
  zero_bplanes_p1 = zero_bplanes + 1U;
#line 1367
  if (lengths1 < 2U) {
    _L___52: /* CIL Label */ 
    _L___53: /* CIL Label */ 
#line 1369
    if (p_manager_mutex) {
      {
#line 1370
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1372
    opj_event_msg(p_manager, 1, "Malformed HT codeblock. Invalid codeblock length values.\n");
    }
#line 1375
    if (p_manager_mutex) {
      {
#line 1376
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1378
    return (0);
  } else
#line 1367
  if ((OPJ_UINT32 )lengths1 > cblk_len) {
#line 1367
    goto _L___52;
  } else
#line 1367
  if ((OPJ_UINT32 )(lengths1 + lengths2) > cblk_len) {
#line 1367
    goto _L___52;
  }
#line 1381
  lcup = (int )lengths1;
#line 1383
  scup = ((int )*(coded_data + (lcup - 1)) << 4) + ((int )*(coded_data + (lcup - 2)) & 15);
#line 1384
  if (scup < 2) {
    _L___54: /* CIL Label */ 
    _L___55: /* CIL Label */ 
#line 1386
    if (p_manager_mutex) {
      {
#line 1387
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1389
    opj_event_msg(p_manager, 1, "Malformed HT codeblock. One of the following condition is not met: 2 <= Scup <= min(Lcup, 4079)\n\220");
    }
#line 1393
    if (p_manager_mutex) {
      {
#line 1394
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1396
    return (0);
  } else
#line 1384
  if (scup > lcup) {
#line 1384
    goto _L___54;
  } else
#line 1384
  if (scup > 4079) {
#line 1384
    goto _L___54;
  }
  {
#line 1400
  __cil_tmp56 = mel_init(& mel, coded_data, lcup, scup);
  }
#line 1400
  if (__cil_tmp56 == 0) {
#line 1401
    if (p_manager_mutex) {
      {
#line 1402
      opj_mutex_lock(p_manager_mutex);
      }
    }
    {
#line 1404
    opj_event_msg(p_manager, 1, "Malformed HT codeblock. Incorrect MEL segment sequence.\n");
    }
#line 1406
    if (p_manager_mutex) {
      {
#line 1407
      opj_mutex_unlock(p_manager_mutex);
      }
    }
#line 1409
    return (0);
  }
  {
#line 1411
  rev_init(& vlc, coded_data, lcup, scup);
#line 1412
  frwd_init(& magsgn, coded_data, lcup - scup, (OPJ_UINT32 )255);
  }
#line 1413
  if (num_passes > 1U) {
    {
#line 1414
    frwd_init(& sigprop, coded_data + lengths1, (int )lengths2, (OPJ_UINT32 )0);
    }
  }
#line 1416
  if (num_passes > 2U) {
    {
#line 1417
    rev_init_mrp(& magref, coded_data, (int )lengths1, (int )lengths2);
    }
  }
  {
#line 1431
  line_state = (OPJ_UINT8 *)(mbr2 + 132);
#line 1435
  lsp = line_state;
#line 1436
  *(lsp + 0) = (OPJ_UINT8 )0;
#line 1437
  run = mel_get_run(& mel);
#line 1440
  qinf[1] = (OPJ_UINT32 )0;
#line 1440
  qinf[0] = qinf[1];
#line 1441
  c_q = (OPJ_UINT32 )0;
#line 1442
  sp = decoded_data;
#line 1445
  x = 0;
  }
  {
#line 1445
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1445
    if (! (x < width)) {
#line 1445
      goto while_break___1;
    }
    {
#line 1462
    vlc_val = rev_fetch(& vlc);
#line 1465
    qinf[0] = (OPJ_UINT32 )vlc_tbl0[(c_q << 7) | (vlc_val & 127U)];
    }
#line 1467
    if (c_q == 0U) {
#line 1468
      run -= 2;
#line 1473
      if (run == -1) {
#line 1473
        tmp___3 = qinf[0];
      } else {
#line 1473
        tmp___3 = (unsigned int )0;
      }
#line 1473
      qinf[0] = tmp___3;
#line 1476
      if (run < 0) {
        {
#line 1477
        run = mel_get_run(& mel);
        }
      }
    }
    {
#line 1482
    c_q = ((qinf[0] & 16U) >> 4) | ((qinf[0] & 224U) >> 5);
#line 1485
    vlc_val = rev_advance(& vlc, qinf[0] & 7U);
#line 1501
    *sip |= (((qinf[0] & 48U) >> 4) | ((qinf[0] & 192U) >> 2)) << sip_shift;
#line 1504
    qinf[1] = (OPJ_UINT32 )0;
    }
#line 1505
    if (x + 2 < width) {
#line 1507
      qinf[1] = (OPJ_UINT32 )vlc_tbl0[(c_q << 7) | (vlc_val & 127U)];
#line 1510
      if (c_q == 0U) {
#line 1511
        run -= 2;
#line 1514
        if (run == -1) {
#line 1514
          tmp___4 = qinf[1];
        } else {
#line 1514
          tmp___4 = (unsigned int )0;
        }
#line 1514
        qinf[1] = tmp___4;
#line 1516
        if (run < 0) {
          {
#line 1517
          run = mel_get_run(& mel);
          }
        }
      }
      {
#line 1522
      c_q = ((qinf[1] & 16U) >> 4) | ((qinf[1] & 224U) >> 5);
#line 1525
      vlc_val = rev_advance(& vlc, qinf[1] & 7U);
      }
    }
#line 1542
    *sip |= ((qinf[1] & 48U) | ((qinf[1] & 192U) << 2)) << (4U + sip_shift);
#line 1544
    if (x & 7) {
#line 1544
      tmp___5 = 1;
    } else {
#line 1544
      tmp___5 = 0;
    }
#line 1544
    sip += tmp___5;
#line 1545
    sip_shift ^= (unsigned int )16;
#line 1551
    uvlc_mode = ((qinf[0] & 8U) >> 3) | ((qinf[1] & 8U) >> 2);
#line 1552
    if (uvlc_mode == 3U) {
#line 1554
      run -= 2;
#line 1555
      if (run == -1) {
#line 1555
        tmp___6 = 1;
      } else {
#line 1555
        tmp___6 = 0;
      }
#line 1555
      uvlc_mode += (unsigned int )tmp___6;
#line 1556
      if (run < 0) {
        {
#line 1557
        run = mel_get_run(& mel);
        }
      }
    }
    {
#line 1561
    consumed_bits = decode_init_uvlc(vlc_val, uvlc_mode, (OPJ_UINT32 *)U_q);
    }
#line 1562
    if (U_q[0] > zero_bplanes_p1) {
      _L___56: /* CIL Label */ 
#line 1563
      if (p_manager_mutex) {
        {
#line 1564
        opj_mutex_lock(p_manager_mutex);
        }
      }
      {
#line 1566
      opj_event_msg(p_manager, 1, "Malformed HT codeblock. Decoding this codeblock is stopped. U_q is larger than zero bitplanes + 1 \n");
      }
#line 1569
      if (p_manager_mutex) {
        {
#line 1570
        opj_mutex_unlock(p_manager_mutex);
        }
      }
#line 1572
      return (0);
    } else
#line 1562
    if (U_q[1] > zero_bplanes_p1) {
#line 1562
      goto _L___56;
    }
    {
#line 1576
    vlc_val = rev_advance(& vlc, consumed_bits);
#line 1582
    locs = (OPJ_UINT32 )255;
    }
#line 1583
    if (x + 4 > width) {
#line 1584
      locs >>= ((x + 4) - width) << 1;
    }
#line 1586
    if (height > 1) {
#line 1586
      tmp___7 = locs;
    } else {
#line 1586
      tmp___7 = locs & 85U;
    }
#line 1586
    locs = tmp___7;
#line 1588
    if ((((qinf[0] & 240U) >> 4) | (qinf[1] & 240U)) & ~ locs) {
#line 1589
      if (p_manager_mutex) {
        {
#line 1590
        opj_mutex_lock(p_manager_mutex);
        }
      }
      {
#line 1592
      opj_event_msg(p_manager, 1, "Malformed HT codeblock. VLC code produces significant samples outside the codeblock area.\n");
      }
#line 1595
      if (p_manager_mutex) {
        {
#line 1596
        opj_mutex_unlock(p_manager_mutex);
        }
      }
#line 1598
      return (0);
    }
#line 1602
    if (qinf[0] & 16U) {
      {
#line 1605
      ms_val = frwd_fetch(& magsgn);
#line 1606
      m_n = U_q[0] - ((qinf[0] >> 12) & 1U);
#line 1608
      frwd_advance(& magsgn, m_n);
#line 1609
      val = ms_val << 31;
#line 1610
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1611
      v_n |= ((qinf[0] & 256U) >> 8) << m_n;
#line 1612
      v_n |= (unsigned int )1;
#line 1615
      *(sp + 0) = val | ((v_n + 2U) << (p - 1U));
      }
    } else
#line 1616
    if (locs & 1U) {
#line 1617
      *(sp + 0) = (OPJ_UINT32 )0;
    }
#line 1620
    if (qinf[0] & 32U) {
      {
#line 1623
      ms_val = frwd_fetch(& magsgn);
#line 1624
      m_n = U_q[0] - ((qinf[0] >> 13) & 1U);
#line 1625
      frwd_advance(& magsgn, m_n);
#line 1626
      val___0 = ms_val << 31;
#line 1627
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1628
      v_n |= ((qinf[0] & 512U) >> 9) << m_n;
#line 1629
      v_n |= (unsigned int )1;
#line 1632
      *(sp + stride) = val___0 | ((v_n + 2U) << (p - 1U));
#line 1635
      t = (OPJ_UINT32 )((int )*(lsp + 0) & 127);
#line 1636
      __cil_tmp83 = count_leading_zeros(v_n);
#line 1636
      v_n = 32U - __cil_tmp83;
      }
#line 1637
      if (t > v_n) {
#line 1637
        tmp___8 = t;
      } else {
#line 1637
        tmp___8 = v_n;
      }
#line 1637
      *(lsp + 0) = (OPJ_UINT8 )(128U | tmp___8);
    } else
#line 1638
    if (locs & 2U) {
#line 1639
      *(sp + stride) = (OPJ_UINT32 )0;
    }
#line 1642
    lsp ++;
#line 1643
    sp ++;
#line 1646
    if (qinf[0] & 64U) {
      {
#line 1649
      ms_val = frwd_fetch(& magsgn);
#line 1650
      m_n = U_q[0] - ((qinf[0] >> 14) & 1U);
#line 1651
      frwd_advance(& magsgn, m_n);
#line 1652
      val___1 = ms_val << 31;
#line 1653
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1654
      v_n |= ((qinf[0] & 1024U) >> 10) << m_n;
#line 1655
      v_n |= (unsigned int )1;
#line 1656
      *(sp + 0) = val___1 | ((v_n + 2U) << (p - 1U));
      }
    } else
#line 1657
    if (locs & 4U) {
#line 1658
      *(sp + 0) = (OPJ_UINT32 )0;
    }
#line 1661
    *(lsp + 0) = (OPJ_UINT8 )0;
#line 1662
    if (qinf[0] & 128U) {
      {
#line 1664
      ms_val = frwd_fetch(& magsgn);
#line 1665
      m_n = U_q[0] - ((qinf[0] >> 15) & 1U);
#line 1666
      frwd_advance(& magsgn, m_n);
#line 1667
      val___2 = ms_val << 31;
#line 1668
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1669
      v_n |= ((qinf[0] & 2048U) >> 11) << m_n;
#line 1670
      v_n |= (unsigned int )1;
#line 1671
      *(sp + stride) = val___2 | ((v_n + 2U) << (p - 1U));
#line 1674
      __cil_tmp89 = count_leading_zeros(v_n);
#line 1674
      *(lsp + 0) = (OPJ_UINT8 )(128U | (32U - __cil_tmp89));
      }
    } else
#line 1675
    if (locs & 8U) {
#line 1676
      *(sp + stride) = (OPJ_UINT32 )0;
    }
#line 1679
    sp ++;
#line 1682
    if (qinf[1] & 16U) {
      {
#line 1685
      ms_val = frwd_fetch(& magsgn);
#line 1686
      m_n = U_q[1] - ((qinf[1] >> 12) & 1U);
#line 1687
      frwd_advance(& magsgn, m_n);
#line 1688
      val___3 = ms_val << 31;
#line 1689
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1690
      v_n |= ((qinf[1] & 256U) >> 8) << m_n;
#line 1691
      v_n |= (unsigned int )1;
#line 1692
      *(sp + 0) = val___3 | ((v_n + 2U) << (p - 1U));
      }
    } else
#line 1693
    if (locs & 16U) {
#line 1694
      *(sp + 0) = (OPJ_UINT32 )0;
    }
#line 1697
    if (qinf[1] & 32U) {
      {
#line 1700
      ms_val = frwd_fetch(& magsgn);
#line 1701
      m_n = U_q[1] - ((qinf[1] >> 13) & 1U);
#line 1702
      frwd_advance(& magsgn, m_n);
#line 1703
      val___4 = ms_val << 31;
#line 1704
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1705
      v_n |= ((qinf[1] & 512U) >> 9) << m_n;
#line 1706
      v_n |= (unsigned int )1;
#line 1707
      *(sp + stride) = val___4 | ((v_n + 2U) << (p - 1U));
#line 1710
      t___0 = (OPJ_UINT32 )((int )*(lsp + 0) & 127);
#line 1711
      __cil_tmp95 = count_leading_zeros(v_n);
#line 1711
      v_n = 32U - __cil_tmp95;
      }
#line 1712
      if (t___0 > v_n) {
#line 1712
        tmp___9 = t___0;
      } else {
#line 1712
        tmp___9 = v_n;
      }
#line 1712
      *(lsp + 0) = (OPJ_UINT8 )(128U | tmp___9);
    } else
#line 1713
    if (locs & 32U) {
#line 1714
      *(sp + stride) = (OPJ_UINT32 )0;
    }
#line 1717
    lsp ++;
#line 1718
    sp ++;
#line 1720
    if (qinf[1] & 64U) {
      {
#line 1723
      ms_val = frwd_fetch(& magsgn);
#line 1724
      m_n = U_q[1] - ((qinf[1] >> 14) & 1U);
#line 1725
      frwd_advance(& magsgn, m_n);
#line 1726
      val___5 = ms_val << 31;
#line 1727
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1728
      v_n |= ((qinf[1] & 1024U) >> 10) << m_n;
#line 1729
      v_n |= (unsigned int )1;
#line 1730
      *(sp + 0) = val___5 | ((v_n + 2U) << (p - 1U));
      }
    } else
#line 1731
    if (locs & 64U) {
#line 1732
      *(sp + 0) = (OPJ_UINT32 )0;
    }
#line 1735
    *(lsp + 0) = (OPJ_UINT8 )0;
#line 1736
    if (qinf[1] & 128U) {
      {
#line 1739
      ms_val = frwd_fetch(& magsgn);
#line 1740
      m_n = U_q[1] - ((qinf[1] >> 15) & 1U);
#line 1741
      frwd_advance(& magsgn, m_n);
#line 1742
      val___6 = ms_val << 31;
#line 1743
      v_n = ms_val & ((1U << m_n) - 1U);
#line 1744
      v_n |= ((qinf[1] & 2048U) >> 11) << m_n;
#line 1745
      v_n |= (unsigned int )1;
#line 1746
      *(sp + stride) = val___6 | ((v_n + 2U) << (p - 1U));
#line 1749
      __cil_tmp101 = count_leading_zeros(v_n);
#line 1749
      *(lsp + 0) = (OPJ_UINT8 )(128U | (32U - __cil_tmp101));
      }
    } else
#line 1750
    if (locs & 128U) {
#line 1751
      *(sp + stride) = (OPJ_UINT32 )0;
    }
#line 1754
    sp ++;
#line 1445
    x += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1759
  y = 2;
  {
#line 1759
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1759
    if (! (y < height)) {
#line 1759
      goto while_break___2;
    }
#line 1764
    sip_shift ^= (unsigned int )2;
#line 1765
    sip_shift &= 4294967279U;
#line 1766
    if (y & 4) {
#line 1766
      tmp___10 = sigma2;
    } else {
#line 1766
      tmp___10 = sigma1;
    }
#line 1766
    sip___57 = tmp___10;
#line 1768
    lsp = line_state;
#line 1769
    ls0 = *(lsp + 0);
#line 1770
    *(lsp + 0) = (OPJ_UINT8 )0;
#line 1771
    sp = decoded_data + y * stride;
#line 1772
    c_q = (OPJ_UINT32 )0;
#line 1773
    x___58 = 0;
    {
#line 1773
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1773
      if (! (x___58 < width)) {
#line 1773
        goto while_break___3;
      }
      {
#line 1786
      c_q |= (unsigned int )((int )ls0 >> 7);
#line 1787
      c_q |= (unsigned int )(((int )*(lsp + 1) >> 5) & 4);
#line 1791
      vlc_val = rev_fetch(& vlc);
#line 1792
      qinf[0] = (OPJ_UINT32 )vlc_tbl1[(c_q << 7) | (vlc_val & 127U)];
      }
#line 1793
      if (c_q == 0U) {
#line 1794
        run -= 2;
#line 1795
        if (run == -1) {
#line 1795
          tmp___11 = qinf[0];
        } else {
#line 1795
          tmp___11 = (unsigned int )0;
        }
#line 1795
        qinf[0] = tmp___11;
#line 1796
        if (run < 0) {
          {
#line 1797
          run = mel_get_run(& mel);
          }
        }
      }
      {
#line 1801
      c_q = ((qinf[0] & 64U) >> 5) | ((qinf[0] & 128U) >> 6);
#line 1804
      vlc_val = rev_advance(& vlc, qinf[0] & 7U);
#line 1815
      *sip___57 |= (((qinf[0] & 48U) >> 4) | ((qinf[0] & 192U) >> 2)) << sip_shift;
#line 1818
      qinf[1] = (OPJ_UINT32 )0;
      }
#line 1819
      if (x___58 + 2 < width) {
#line 1820
        c_q |= (unsigned int )((int )*(lsp + 1) >> 7);
#line 1821
        c_q |= (unsigned int )(((int )*(lsp + 2) >> 5) & 4);
#line 1822
        qinf[1] = (OPJ_UINT32 )vlc_tbl1[(c_q << 7) | (vlc_val & 127U)];
#line 1823
        if (c_q == 0U) {
#line 1824
          run -= 2;
#line 1825
          if (run == -1) {
#line 1825
            tmp___12 = qinf[1];
          } else {
#line 1825
            tmp___12 = (unsigned int )0;
          }
#line 1825
          qinf[1] = tmp___12;
#line 1826
          if (run < 0) {
            {
#line 1827
            run = mel_get_run(& mel);
            }
          }
        }
        {
#line 1831
        c_q = ((qinf[1] & 64U) >> 5) | ((qinf[1] & 128U) >> 6);
#line 1833
        vlc_val = rev_advance(& vlc, qinf[1] & 7U);
        }
      }
#line 1837
      *sip___57 |= ((qinf[1] & 48U) | ((qinf[1] & 192U) << 2)) << (4U + sip_shift);
#line 1839
      if (x___58 & 7) {
#line 1839
        tmp___13 = 1;
      } else {
#line 1839
        tmp___13 = 0;
      }
      {
#line 1839
      sip___57 += tmp___13;
#line 1840
      sip_shift ^= (unsigned int )16;
#line 1844
      uvlc_mode___0 = ((qinf[0] & 8U) >> 3) | ((qinf[1] & 8U) >> 2);
#line 1845
      consumed_bits___0 = decode_noninit_uvlc(vlc_val, uvlc_mode___0, (OPJ_UINT32 *)U_q___0);
#line 1846
      vlc_val = rev_advance(& vlc, consumed_bits___0);
      }
#line 1849
      if ((qinf[0] & 240U) & ((qinf[0] & 240U) - 1U)) {
#line 1850
        E = (unsigned int )ls0 & 127U;
#line 1851
        if (E > ((unsigned int )*(lsp + 1) & 127U)) {
#line 1851
          tmp___14 = E;
        } else {
#line 1851
          tmp___14 = (unsigned int )*(lsp + 1) & 127U;
        }
#line 1851
        E = tmp___14;
#line 1853
        if (E > 2U) {
#line 1853
          tmp___15 = E - 2U;
        } else {
#line 1853
          tmp___15 = (unsigned int )0;
        }
#line 1853
        U_q___0[0] += tmp___15;
      }
#line 1856
      if ((qinf[1] & 240U) & ((qinf[1] & 240U) - 1U)) {
#line 1857
        E___0 = (unsigned int )*(lsp + 1) & 127U;
#line 1858
        if (E___0 > ((unsigned int )*(lsp + 2) & 127U)) {
#line 1858
          tmp___16 = E___0;
        } else {
#line 1858
          tmp___16 = (unsigned int )*(lsp + 2) & 127U;
        }
#line 1858
        E___0 = tmp___16;
#line 1860
        if (E___0 > 2U) {
#line 1860
          tmp___17 = E___0 - 2U;
        } else {
#line 1860
          tmp___17 = (unsigned int )0;
        }
#line 1860
        U_q___0[1] += tmp___17;
      }
#line 1863
      if (U_q___0[0] > zero_bplanes_p1) {
        _L___59: /* CIL Label */ 
#line 1864
        if (p_manager_mutex) {
          {
#line 1865
          opj_mutex_lock(p_manager_mutex);
          }
        }
        {
#line 1867
        opj_event_msg(p_manager, 1, "Malformed HT codeblock. Decoding this codeblock is stopped. U_q islarger than bitplanes + 1 \n");
        }
#line 1870
        if (p_manager_mutex) {
          {
#line 1871
          opj_mutex_unlock(p_manager_mutex);
          }
        }
#line 1873
        return (0);
      } else
#line 1863
      if (U_q___0[1] > zero_bplanes_p1) {
#line 1863
        goto _L___59;
      }
#line 1876
      ls0 = *(lsp + 2);
#line 1877
      *(lsp + 2) = (OPJ_UINT8 )0;
#line 1877
      *(lsp + 1) = *(lsp + 2);
#line 1883
      locs___0 = (OPJ_UINT32 )255;
#line 1884
      if (x___58 + 4 > width) {
#line 1885
        locs___0 >>= ((x___58 + 4) - width) << 1;
      }
#line 1887
      if (y + 2 <= height) {
#line 1887
        tmp___18 = locs___0;
      } else {
#line 1887
        tmp___18 = locs___0 & 85U;
      }
#line 1887
      locs___0 = tmp___18;
#line 1889
      if ((((qinf[0] & 240U) >> 4) | (qinf[1] & 240U)) & ~ locs___0) {
#line 1890
        if (p_manager_mutex) {
          {
#line 1891
          opj_mutex_lock(p_manager_mutex);
          }
        }
        {
#line 1893
        opj_event_msg(p_manager, 1, "Malformed HT codeblock. VLC code produces significant samples outside the codeblock area.\n");
        }
#line 1896
        if (p_manager_mutex) {
          {
#line 1897
          opj_mutex_unlock(p_manager_mutex);
          }
        }
#line 1899
        return (0);
      }
#line 1904
      if (qinf[0] & 16U) {
        {
#line 1907
        ms_val___0 = frwd_fetch(& magsgn);
#line 1908
        m_n___0 = U_q___0[0] - ((qinf[0] >> 12) & 1U);
#line 1909
        frwd_advance(& magsgn, m_n___0);
#line 1910
        val___7 = ms_val___0 << 31;
#line 1911
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 1912
        v_n___0 |= ((qinf[0] & 256U) >> 8) << m_n___0;
#line 1913
        v_n___0 |= (unsigned int )1;
#line 1914
        *(sp + 0) = val___7 | ((v_n___0 + 2U) << (p - 1U));
        }
      } else
#line 1915
      if (locs___0 & 1U) {
#line 1916
        *(sp + 0) = (OPJ_UINT32 )0;
      }
#line 1919
      if (qinf[0] & 32U) {
        {
#line 1922
        ms_val___0 = frwd_fetch(& magsgn);
#line 1923
        m_n___0 = U_q___0[0] - ((qinf[0] >> 13) & 1U);
#line 1924
        frwd_advance(& magsgn, m_n___0);
#line 1925
        val___8 = ms_val___0 << 31;
#line 1926
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 1927
        v_n___0 |= ((qinf[0] & 512U) >> 9) << m_n___0;
#line 1928
        v_n___0 |= (unsigned int )1;
#line 1929
        *(sp + stride) = val___8 | ((v_n___0 + 2U) << (p - 1U));
#line 1932
        t___1 = (OPJ_UINT32 )((int )*(lsp + 0) & 127);
#line 1933
        __cil_tmp135 = count_leading_zeros(v_n___0);
#line 1933
        v_n___0 = 32U - __cil_tmp135;
        }
#line 1934
        if (t___1 > v_n___0) {
#line 1934
          tmp___19 = t___1;
        } else {
#line 1934
          tmp___19 = v_n___0;
        }
#line 1934
        *(lsp + 0) = (OPJ_UINT8 )(128U | tmp___19);
      } else
#line 1935
      if (locs___0 & 2U) {
#line 1936
        *(sp + stride) = (OPJ_UINT32 )0;
      }
#line 1939
      lsp ++;
#line 1940
      sp ++;
#line 1942
      if (qinf[0] & 64U) {
        {
#line 1945
        ms_val___0 = frwd_fetch(& magsgn);
#line 1946
        m_n___0 = U_q___0[0] - ((qinf[0] >> 14) & 1U);
#line 1947
        frwd_advance(& magsgn, m_n___0);
#line 1948
        val___9 = ms_val___0 << 31;
#line 1949
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 1950
        v_n___0 |= ((qinf[0] & 1024U) >> 10) << m_n___0;
#line 1951
        v_n___0 |= (unsigned int )1;
#line 1952
        *(sp + 0) = val___9 | ((v_n___0 + 2U) << (p - 1U));
        }
      } else
#line 1953
      if (locs___0 & 4U) {
#line 1954
        *(sp + 0) = (OPJ_UINT32 )0;
      }
#line 1957
      if (qinf[0] & 128U) {
        {
#line 1960
        ms_val___0 = frwd_fetch(& magsgn);
#line 1961
        m_n___0 = U_q___0[0] - ((qinf[0] >> 15) & 1U);
#line 1962
        frwd_advance(& magsgn, m_n___0);
#line 1963
        val___10 = ms_val___0 << 31;
#line 1964
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 1965
        v_n___0 |= ((qinf[0] & 2048U) >> 11) << m_n___0;
#line 1966
        v_n___0 |= (unsigned int )1;
#line 1967
        *(sp + stride) = val___10 | ((v_n___0 + 2U) << (p - 1U));
#line 1970
        __cil_tmp141 = count_leading_zeros(v_n___0);
#line 1970
        *(lsp + 0) = (OPJ_UINT8 )(128U | (32U - __cil_tmp141));
        }
      } else
#line 1971
      if (locs___0 & 8U) {
#line 1972
        *(sp + stride) = (OPJ_UINT32 )0;
      }
#line 1975
      sp ++;
#line 1977
      if (qinf[1] & 16U) {
        {
#line 1980
        ms_val___0 = frwd_fetch(& magsgn);
#line 1981
        m_n___0 = U_q___0[1] - ((qinf[1] >> 12) & 1U);
#line 1982
        frwd_advance(& magsgn, m_n___0);
#line 1983
        val___11 = ms_val___0 << 31;
#line 1984
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 1985
        v_n___0 |= ((qinf[1] & 256U) >> 8) << m_n___0;
#line 1986
        v_n___0 |= (unsigned int )1;
#line 1987
        *(sp + 0) = val___11 | ((v_n___0 + 2U) << (p - 1U));
        }
      } else
#line 1988
      if (locs___0 & 16U) {
#line 1989
        *(sp + 0) = (OPJ_UINT32 )0;
      }
#line 1992
      if (qinf[1] & 32U) {
        {
#line 1995
        ms_val___0 = frwd_fetch(& magsgn);
#line 1996
        m_n___0 = U_q___0[1] - ((qinf[1] >> 13) & 1U);
#line 1997
        frwd_advance(& magsgn, m_n___0);
#line 1998
        val___12 = ms_val___0 << 31;
#line 1999
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 2000
        v_n___0 |= ((qinf[1] & 512U) >> 9) << m_n___0;
#line 2001
        v_n___0 |= (unsigned int )1;
#line 2002
        *(sp + stride) = val___12 | ((v_n___0 + 2U) << (p - 1U));
#line 2005
        t___2 = (OPJ_UINT32 )((int )*(lsp + 0) & 127);
#line 2006
        __cil_tmp147 = count_leading_zeros(v_n___0);
#line 2006
        v_n___0 = 32U - __cil_tmp147;
        }
#line 2007
        if (t___2 > v_n___0) {
#line 2007
          tmp___20 = t___2;
        } else {
#line 2007
          tmp___20 = v_n___0;
        }
#line 2007
        *(lsp + 0) = (OPJ_UINT8 )(128U | tmp___20);
      } else
#line 2008
      if (locs___0 & 32U) {
#line 2009
        *(sp + stride) = (OPJ_UINT32 )0;
      }
#line 2012
      lsp ++;
#line 2013
      sp ++;
#line 2015
      if (qinf[1] & 64U) {
        {
#line 2018
        ms_val___0 = frwd_fetch(& magsgn);
#line 2019
        m_n___0 = U_q___0[1] - ((qinf[1] >> 14) & 1U);
#line 2020
        frwd_advance(& magsgn, m_n___0);
#line 2021
        val___13 = ms_val___0 << 31;
#line 2022
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 2023
        v_n___0 |= ((qinf[1] & 1024U) >> 10) << m_n___0;
#line 2024
        v_n___0 |= (unsigned int )1;
#line 2025
        *(sp + 0) = val___13 | ((v_n___0 + 2U) << (p - 1U));
        }
      } else
#line 2026
      if (locs___0 & 64U) {
#line 2027
        *(sp + 0) = (OPJ_UINT32 )0;
      }
#line 2030
      if (qinf[1] & 128U) {
        {
#line 2033
        ms_val___0 = frwd_fetch(& magsgn);
#line 2034
        m_n___0 = U_q___0[1] - ((qinf[1] >> 15) & 1U);
#line 2035
        frwd_advance(& magsgn, m_n___0);
#line 2036
        val___14 = ms_val___0 << 31;
#line 2037
        v_n___0 = ms_val___0 & ((1U << m_n___0) - 1U);
#line 2038
        v_n___0 |= ((qinf[1] & 2048U) >> 11) << m_n___0;
#line 2039
        v_n___0 |= (unsigned int )1;
#line 2040
        *(sp + stride) = val___14 | ((v_n___0 + 2U) << (p - 1U));
#line 2043
        __cil_tmp153 = count_leading_zeros(v_n___0);
#line 2043
        *(lsp + 0) = (OPJ_UINT8 )(128U | (32U - __cil_tmp153));
        }
      } else
#line 2044
      if (locs___0 & 128U) {
#line 2045
        *(sp + stride) = (OPJ_UINT32 )0;
      }
#line 2048
      sp ++;
#line 1773
      x___58 += 4;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2051
    y += 2;
#line 2052
    if (num_passes > 1U) {
#line 2052
      if ((y & 3) == 0) {
#line 2055
        if (num_passes > 2U) {
#line 2057
          if (y & 4) {
#line 2057
            tmp___21 = sigma1;
          } else {
#line 2057
            tmp___21 = sigma2;
          }
#line 2057
          cur_sig = tmp___21;
#line 2059
          dpp = decoded_data + (y - 4) * stride;
#line 2060
          half = 1U << (p - 2U);
#line 2062
          i___1 = 0;
          {
#line 2062
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2062
            if (! (i___1 < width)) {
#line 2062
              goto while_break___4;
            }
            {
#line 2066
            __cil_tmp160 = rev_fetch(& magref);
#line 2066
            cwd = __cil_tmp160;
#line 2067
            __cil_tmp162 = cur_sig;
#line 2067
            cur_sig ++;
#line 2067
            sig = *__cil_tmp162;
#line 2068
            col_mask = 15U;
#line 2069
            dp = dpp + i___1;
            }
#line 2070
            if (sig) {
#line 2072
              j = 0;
              {
#line 2072
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 2072
                if (! (j < 8)) {
#line 2072
                  goto while_break___5;
                }
#line 2073
                if (sig & col_mask) {
#line 2074
                  sample_mask = 286331153U & col_mask;
#line 2076
                  if (sig & sample_mask) {
#line 2080
                    sym = cwd & 1U;
#line 2082
                    *(dp + 0) ^= (1U - sym) << (p - 1U);
#line 2083
                    *(dp + 0) |= half;
#line 2084
                    cwd >>= 1;
                  }
#line 2086
                  sample_mask += sample_mask;
#line 2088
                  if (sig & sample_mask) {
#line 2092
                    sym___0 = cwd & 1U;
#line 2093
                    *(dp + stride) ^= (1U - sym___0) << (p - 1U);
#line 2094
                    *(dp + stride) |= half;
#line 2095
                    cwd >>= 1;
                  }
#line 2097
                  sample_mask += sample_mask;
#line 2099
                  if (sig & sample_mask) {
#line 2103
                    sym___1 = cwd & 1U;
#line 2104
                    *(dp + 2 * stride) ^= (1U - sym___1) << (p - 1U);
#line 2105
                    *(dp + 2 * stride) |= half;
#line 2106
                    cwd >>= 1;
                  }
#line 2108
                  sample_mask += sample_mask;
#line 2110
                  if (sig & sample_mask) {
#line 2114
                    sym___2 = cwd & 1U;
#line 2115
                    *(dp + 3 * stride) ^= (1U - sym___2) << (p - 1U);
#line 2116
                    *(dp + 3 * stride) |= half;
#line 2117
                    cwd >>= 1;
                  }
#line 2119
                  sample_mask += sample_mask;
                }
#line 2121
                col_mask <<= 4;
#line 2072
                __cil_tmp171 = dp;
#line 2072
                dp ++;
#line 2072
                j ++;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
            {
#line 2125
            __cil_tmp172 = population_count(sig);
#line 2125
            rev_advance(& magref, __cil_tmp172);
            }
#line 2062
            i___1 += 8;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 2129
        if (y >= 4) {
#line 2131
          if (y & 4) {
#line 2131
            tmp___22 = sigma1;
          } else {
#line 2131
            tmp___22 = sigma2;
          }
#line 2131
          sig___0 = tmp___22;
#line 2132
          if (y & 4) {
#line 2132
            tmp___23 = mbr1;
          } else {
#line 2132
            tmp___23 = mbr2;
          }
#line 2132
          mbr = tmp___23;
#line 2138
          prev = (OPJ_UINT32 )0;
#line 2140
          i___2 = 0;
          {
#line 2140
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2140
            if (! (i___2 < width)) {
#line 2140
              goto while_break___6;
            }
#line 2143
            *(mbr + 0) = *(sig___0 + 0);
#line 2144
            *(mbr + 0) |= prev >> 28;
#line 2145
            *(mbr + 0) |= *(sig___0 + 0) << 4;
#line 2146
            *(mbr + 0) |= *(sig___0 + 0) >> 4;
#line 2147
            *(mbr + 0) |= *(sig___0 + 1) << 28;
#line 2148
            prev = *(sig___0 + 0);
#line 2151
            z = *(mbr + 0);
#line 2151
            t___3 = *(mbr + 0);
#line 2152
            z |= (t___3 & 2004318071U) << 1;
#line 2153
            z |= (t___3 & 4008636142U) >> 1;
#line 2154
            *(mbr + 0) = z & ~ *(sig___0 + 0);
#line 2140
            __cil_tmp182 = sig___0;
#line 2140
            sig___0 ++;
#line 2140
            __cil_tmp181 = mbr;
#line 2140
            mbr ++;
#line 2140
            i___2 += 8;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 2158
        if (y >= 8) {
#line 2165
          if (y & 4) {
#line 2165
            tmp___24 = sigma2;
          } else {
#line 2165
            tmp___24 = sigma1;
          }
#line 2165
          cur_sig___0 = tmp___24;
#line 2166
          if (y & 4) {
#line 2166
            tmp___25 = mbr2;
          } else {
#line 2166
            tmp___25 = mbr1;
          }
#line 2166
          cur_mbr = tmp___25;
#line 2167
          if (y & 4) {
#line 2167
            tmp___26 = sigma1;
          } else {
#line 2167
            tmp___26 = sigma2;
          }
#line 2167
          nxt_sig = tmp___26;
#line 2168
          prev___0 = (OPJ_UINT32 )0;
#line 2169
          i___3 = 0;
          {
#line 2169
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2169
            if (! (i___3 < width)) {
#line 2169
              goto while_break___7;
            }
#line 2170
            t___4 = *(nxt_sig + 0);
#line 2171
            t___4 |= prev___0 >> 28;
#line 2172
            t___4 |= *(nxt_sig + 0) << 4;
#line 2173
            t___4 |= *(nxt_sig + 0) >> 4;
#line 2174
            t___4 |= *(nxt_sig + 1) << 28;
#line 2175
            prev___0 = *(nxt_sig + 0);
#line 2177
            if (! stripe_causal) {
#line 2178
              *(cur_mbr + 0) |= (t___4 & 286331153U) << 3;
            }
#line 2180
            *(cur_mbr + 0) &= ~ *(cur_sig___0 + 0);
#line 2169
            __cil_tmp196 = nxt_sig;
#line 2169
            nxt_sig ++;
#line 2169
            __cil_tmp195 = cur_sig___0;
#line 2169
            cur_sig___0 ++;
#line 2169
            __cil_tmp194 = cur_mbr;
#line 2169
            cur_mbr ++;
#line 2169
            i___3 += 8;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2184
          if (y & 4) {
#line 2184
            tmp___27 = sigma2;
          } else {
#line 2184
            tmp___27 = sigma1;
          }
#line 2184
          cur_sig___0 = tmp___27;
#line 2185
          if (y & 4) {
#line 2185
            tmp___28 = mbr2;
          } else {
#line 2185
            tmp___28 = mbr1;
          }
#line 2185
          cur_mbr = tmp___28;
#line 2186
          if (y & 4) {
#line 2186
            tmp___29 = sigma1;
          } else {
#line 2186
            tmp___29 = sigma2;
          }
#line 2186
          nxt_sig = tmp___29;
#line 2187
          if (y & 4) {
#line 2187
            tmp___30 = mbr1;
          } else {
#line 2187
            tmp___30 = mbr2;
          }
#line 2187
          nxt_mbr = tmp___30;
#line 2188
          val___15 = 3U << (p - 2U);
#line 2190
          i___3 = 0;
          {
#line 2190
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2190
            if (! (i___3 < width)) {
#line 2190
              goto while_break___8;
            }
#line 2193
            mbr___0 = *cur_mbr;
#line 2194
            new_sig = (OPJ_UINT32 )0;
#line 2195
            if (mbr___0) {
#line 2197
              n = 0;
              {
#line 2197
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 2197
                if (! (n < 8)) {
#line 2197
                  goto while_break___9;
                }
                {
#line 2203
                __cil_tmp211 = frwd_fetch(& sigprop);
#line 2203
                cwd___0 = __cil_tmp211;
#line 2204
                cnt = (OPJ_UINT32 )0;
#line 2206
                dp___0 = decoded_data + (y - 8) * stride;
#line 2207
                dp___0 += i___3 + n;
#line 2209
                col_mask___0 = 15U << 4 * n;
#line 2211
                inv_sig = ~ *(cur_sig___0 + 0);
                }
#line 2214
                if ((n + 4) + i___3 < width) {
#line 2214
                  tmp___31 = n + 4;
                } else {
#line 2214
                  tmp___31 = width - i___3;
                }
#line 2214
                end = tmp___31;
#line 2216
                j___0 = n;
                {
#line 2216
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 2216
                  if (! (j___0 < end)) {
#line 2216
                    goto while_break___10;
                  }
#line 2219
                  if ((col_mask___0 & mbr___0) == 0U) {
#line 2220
                    goto while_continue___10;
                  }
#line 2224
                  sample_mask___0 = 286331153U & col_mask___0;
#line 2225
                  if (mbr___0 & sample_mask___0) {
#line 2227
                    if (cwd___0 & 1U) {
#line 2230
                      new_sig |= sample_mask___0;
#line 2231
                      t___5 = 50U << j___0 * 4;
#line 2232
                      mbr___0 |= t___5 & inv_sig;
                    }
#line 2234
                    cwd___0 >>= 1;
#line 2235
                    cnt ++;
                  }
#line 2239
                  sample_mask___0 += sample_mask___0;
#line 2240
                  if (mbr___0 & sample_mask___0) {
#line 2242
                    if (cwd___0 & 1U) {
#line 2244
                      new_sig |= sample_mask___0;
#line 2245
                      t___6 = 116U << j___0 * 4;
#line 2246
                      mbr___0 |= t___6 & inv_sig;
                    }
#line 2248
                    cwd___0 >>= 1;
#line 2249
                    cnt ++;
                  }
#line 2252
                  sample_mask___0 += sample_mask___0;
#line 2253
                  if (mbr___0 & sample_mask___0) {
#line 2255
                    if (cwd___0 & 1U) {
#line 2257
                      new_sig |= sample_mask___0;
#line 2258
                      t___7 = 232U << j___0 * 4;
#line 2259
                      mbr___0 |= t___7 & inv_sig;
                    }
#line 2261
                    cwd___0 >>= 1;
#line 2262
                    cnt ++;
                  }
#line 2265
                  sample_mask___0 += sample_mask___0;
#line 2266
                  if (mbr___0 & sample_mask___0) {
#line 2268
                    if (cwd___0 & 1U) {
#line 2270
                      new_sig |= sample_mask___0;
#line 2271
                      t___8 = 192U << j___0 * 4;
#line 2272
                      mbr___0 |= t___8 & inv_sig;
                    }
#line 2274
                    cwd___0 >>= 1;
#line 2275
                    cnt ++;
                  }
#line 2216
                  col_mask___0 <<= 4;
#line 2216
                  dp___0 ++;
#line 2216
                  j___0 ++;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 2280
                if (new_sig & (65535U << 4 * n)) {
#line 2283
                  dp___62 = decoded_data + (y - 8) * stride;
#line 2284
                  dp___62 += i___3 + n;
#line 2285
                  col_mask___60 = 15U << 4 * n;
#line 2287
                  j___61 = n;
                  {
#line 2287
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 2287
                    if (! (j___61 < end)) {
#line 2287
                      goto while_break___11;
                    }
#line 2290
                    if ((col_mask___60 & new_sig) == 0U) {
#line 2291
                      goto while_continue___11;
                    }
#line 2295
                    sample_mask___1 = 286331153U & col_mask___60;
#line 2296
                    if (new_sig & sample_mask___1) {
#line 2298
                      *(dp___62 + 0) |= ((cwd___0 & 1U) << 31) | val___15;
#line 2299
                      cwd___0 >>= 1;
#line 2300
                      cnt ++;
                    }
#line 2304
                    sample_mask___1 += sample_mask___1;
#line 2305
                    if (new_sig & sample_mask___1) {
#line 2307
                      *(dp___62 + stride) |= ((cwd___0 & 1U) << 31) | val___15;
#line 2308
                      cwd___0 >>= 1;
#line 2309
                      cnt ++;
                    }
#line 2312
                    sample_mask___1 += sample_mask___1;
#line 2313
                    if (new_sig & sample_mask___1) {
#line 2315
                      *(dp___62 + 2 * stride) |= ((cwd___0 & 1U) << 31) | val___15;
#line 2316
                      cwd___0 >>= 1;
#line 2317
                      cnt ++;
                    }
#line 2320
                    sample_mask___1 += sample_mask___1;
#line 2321
                    if (new_sig & sample_mask___1) {
#line 2323
                      *(dp___62 + 3 * stride) |= ((cwd___0 & 1U) << 31) | val___15;
#line 2324
                      cwd___0 >>= 1;
#line 2325
                      cnt ++;
                    }
#line 2287
                    col_mask___60 <<= 4;
#line 2287
                    dp___62 ++;
#line 2287
                    j___61 ++;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                }
                {
#line 2330
                frwd_advance(& sigprop, cnt);
#line 2331
                cnt = (OPJ_UINT32 )0;
                }
#line 2334
                if (n == 4) {
#line 2336
                  t___9 = new_sig >> 28;
#line 2337
                  t___9 |= ((t___9 & 14U) >> 1) | ((t___9 & 7U) << 1);
#line 2338
                  *(cur_mbr + 1) |= t___9 & ~ *(cur_sig___0 + 1);
                }
#line 2197
                n += 4;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
#line 2343
            new_sig |= *(cur_sig___0 + 0);
#line 2344
            ux = (new_sig & 2290649224U) >> 3;
#line 2345
            tx = (ux | (ux << 4)) | (ux >> 4);
#line 2346
            if (i___3 > 0) {
#line 2347
              *(nxt_mbr + - 1) |= (ux << 28) & ~ *(nxt_sig + -1);
            }
#line 2349
            *(nxt_mbr + 0) |= tx & ~ *(nxt_sig + 0);
#line 2350
            *(nxt_mbr + 1) |= (ux >> 28) & ~ *(nxt_sig + 1);
#line 2191
            __cil_tmp228 = nxt_mbr;
#line 2191
            nxt_mbr ++;
#line 2191
            __cil_tmp227 = nxt_sig;
#line 2191
            nxt_sig ++;
#line 2191
            __cil_tmp226 = cur_mbr;
#line 2191
            cur_mbr ++;
#line 2191
            __cil_tmp225 = cur_sig___0;
#line 2191
            cur_sig___0 ++;
#line 2191
            i___3 += 8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 2355
          if (y & 4) {
#line 2355
            tmp___32 = sigma2;
          } else {
#line 2355
            tmp___32 = sigma1;
          }
          {
#line 2355
          cur_sig___0 = tmp___32;
#line 2356
          memset(cur_sig___0, 0, (unsigned long )(((((OPJ_UINT32 )width + 7U) >> 3) + 1U) << 2));
          }
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2362
  if (num_passes > 1U) {
#line 2365
    if (num_passes > 2U) {
#line 2365
      if ((height & 3) == 1) {
        _L___64: /* CIL Label */ 
#line 2367
        if (height & 4) {
#line 2367
          tmp___33 = sigma2;
        } else {
#line 2367
          tmp___33 = sigma1;
        }
#line 2367
        cur_sig___1 = tmp___33;
#line 2368
        dpp___0 = decoded_data + (height & 16777212) * stride;
#line 2369
        half___0 = 1U << (p - 2U);
#line 2371
        i___4 = 0;
        {
#line 2371
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2371
          if (! (i___4 < width)) {
#line 2371
            goto while_break___12;
          }
          {
#line 2372
          __cil_tmp238 = rev_fetch(& magref);
#line 2372
          cwd___1 = __cil_tmp238;
#line 2373
          __cil_tmp240 = cur_sig___1;
#line 2373
          cur_sig___1 ++;
#line 2373
          sig___1 = *__cil_tmp240;
#line 2374
          col_mask___61 = (OPJ_UINT32 )15;
#line 2375
          dp___63 = dpp___0 + i___4;
          }
#line 2376
          if (sig___1) {
#line 2378
            j___62 = 0;
            {
#line 2378
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 2378
              if (! (j___62 < 8)) {
#line 2378
                goto while_break___13;
              }
#line 2379
              if (sig___1 & col_mask___61) {
#line 2380
                sample_mask___2 = 286331153U & col_mask___61;
#line 2382
                if (sig___1 & sample_mask___2) {
#line 2385
                  sym___3 = cwd___1 & 1U;
#line 2386
                  *(dp___63 + 0) ^= (1U - sym___3) << (p - 1U);
#line 2387
                  *(dp___63 + 0) |= half___0;
#line 2388
                  cwd___1 >>= 1;
                }
#line 2390
                sample_mask___2 += sample_mask___2;
#line 2392
                if (sig___1 & sample_mask___2) {
#line 2395
                  sym___4 = cwd___1 & 1U;
#line 2396
                  *(dp___63 + stride) ^= (1U - sym___4) << (p - 1U);
#line 2397
                  *(dp___63 + stride) |= half___0;
#line 2398
                  cwd___1 >>= 1;
                }
#line 2400
                sample_mask___2 += sample_mask___2;
#line 2402
                if (sig___1 & sample_mask___2) {
#line 2405
                  sym___5 = cwd___1 & 1U;
#line 2406
                  *(dp___63 + 2 * stride) ^= (1U - sym___5) << (p - 1U);
#line 2407
                  *(dp___63 + 2 * stride) |= half___0;
#line 2408
                  cwd___1 >>= 1;
                }
#line 2410
                sample_mask___2 += sample_mask___2;
#line 2412
                if (sig___1 & sample_mask___2) {
#line 2415
                  sym___6 = cwd___1 & 1U;
#line 2416
                  *(dp___63 + 3 * stride) ^= (1U - sym___6) << (p - 1U);
#line 2417
                  *(dp___63 + 3 * stride) |= half___0;
#line 2418
                  cwd___1 >>= 1;
                }
#line 2420
                sample_mask___2 += sample_mask___2;
              }
#line 2422
              col_mask___61 <<= 4;
#line 2378
              __cil_tmp249 = dp___63;
#line 2378
              dp___63 ++;
#line 2378
              j___62 ++;
            }
            while_break___13: /* CIL Label */ ;
            }
          }
          {
#line 2425
          __cil_tmp250 = population_count(sig___1);
#line 2425
          rev_advance(& magref, __cil_tmp250);
          }
#line 2371
          i___4 += 8;
        }
        while_break___12: /* CIL Label */ ;
        }
      } else
#line 2365
      if ((height & 3) == 2) {
#line 2365
        goto _L___64;
      }
    }
#line 2432
    if ((height & 3) == 1) {
      _L___65: /* CIL Label */ 
#line 2434
      if (height & 4) {
#line 2434
        tmp___34 = sigma2;
      } else {
#line 2434
        tmp___34 = sigma1;
      }
#line 2434
      sig___2 = tmp___34;
#line 2435
      if (height & 4) {
#line 2435
        tmp___35 = mbr2;
      } else {
#line 2435
        tmp___35 = mbr1;
      }
#line 2435
      mbr___1 = tmp___35;
#line 2437
      prev___1 = (OPJ_UINT32 )0;
#line 2439
      i___5 = 0;
      {
#line 2439
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2439
        if (! (i___5 < width)) {
#line 2439
          goto while_break___14;
        }
#line 2442
        *(mbr___1 + 0) = *(sig___2 + 0);
#line 2443
        *(mbr___1 + 0) |= prev___1 >> 28;
#line 2444
        *(mbr___1 + 0) |= *(sig___2 + 0) << 4;
#line 2445
        *(mbr___1 + 0) |= *(sig___2 + 0) >> 4;
#line 2446
        *(mbr___1 + 0) |= *(sig___2 + 1) << 28;
#line 2447
        prev___1 = *(sig___2 + 0);
#line 2450
        z___0 = *(mbr___1 + 0);
#line 2450
        t___10 = *(mbr___1 + 0);
#line 2451
        z___0 |= (t___10 & 2004318071U) << 1;
#line 2452
        z___0 |= (t___10 & 4008636142U) >> 1;
#line 2453
        *(mbr___1 + 0) = z___0 & ~ *(sig___2 + 0);
#line 2439
        __cil_tmp260 = sig___2;
#line 2439
        sig___2 ++;
#line 2439
        __cil_tmp259 = mbr___1;
#line 2439
        mbr___1 ++;
#line 2439
        i___5 += 8;
      }
      while_break___14: /* CIL Label */ ;
      }
    } else
#line 2432
    if ((height & 3) == 2) {
#line 2432
      goto _L___65;
    }
#line 2457
    st = height;
#line 2458
    if (height > 6) {
#line 2458
      tmp___36 = ((height + 1) & 3) + 3;
    } else {
#line 2458
      tmp___36 = height;
    }
#line 2458
    st -= tmp___36;
#line 2459
    y___63 = st;
    {
#line 2459
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 2459
      if (! (y___63 < height)) {
#line 2459
        goto while_break___15;
      }
#line 2464
      pattern = 4294967295U;
#line 2465
      if (height - y___63 == 3) {
#line 2466
        pattern = 2004318071U;
      } else
#line 2467
      if (height - y___63 == 2) {
#line 2468
        pattern = 858993459U;
      } else
#line 2469
      if (height - y___63 == 1) {
#line 2470
        pattern = 286331153U;
      }
#line 2474
      if (height - y___63 > 4) {
#line 2475
        prev___2 = (OPJ_UINT32 )0;
#line 2477
        if (y___63 & 4) {
#line 2477
          tmp___37 = sigma2;
        } else {
#line 2477
          tmp___37 = sigma1;
        }
#line 2477
        cur_sig___2 = tmp___37;
#line 2478
        if (y___63 & 4) {
#line 2478
          tmp___38 = mbr2;
        } else {
#line 2478
          tmp___38 = mbr1;
        }
#line 2478
        cur_mbr___0 = tmp___38;
#line 2479
        if (y___63 & 4) {
#line 2479
          tmp___39 = sigma1;
        } else {
#line 2479
          tmp___39 = sigma2;
        }
#line 2479
        nxt_sig___0 = tmp___39;
#line 2480
        i___66 = 0;
        {
#line 2480
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 2480
          if (! (i___66 < width)) {
#line 2480
            goto while_break___16;
          }
#line 2481
          t___11 = *(nxt_sig___0 + 0);
#line 2482
          t___11 |= prev___2 >> 28;
#line 2483
          t___11 |= *(nxt_sig___0 + 0) << 4;
#line 2484
          t___11 |= *(nxt_sig___0 + 0) >> 4;
#line 2485
          t___11 |= *(nxt_sig___0 + 1) << 28;
#line 2486
          prev___2 = *(nxt_sig___0 + 0);
#line 2488
          if (! stripe_causal) {
#line 2489
            *(cur_mbr___0 + 0) |= (t___11 & 286331153U) << 3;
          }
#line 2492
          *(cur_mbr___0 + 0) &= ~ *(cur_sig___2 + 0);
#line 2480
          __cil_tmp277 = nxt_sig___0;
#line 2480
          nxt_sig___0 ++;
#line 2480
          __cil_tmp276 = cur_sig___2;
#line 2480
          cur_sig___2 ++;
#line 2480
          __cil_tmp275 = cur_mbr___0;
#line 2480
          cur_mbr___0 ++;
#line 2480
          i___66 += 8;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 2497
      if (y___63 & 4) {
#line 2497
        tmp___40 = sigma2;
      } else {
#line 2497
        tmp___40 = sigma1;
      }
#line 2497
      cur_sig___2 = tmp___40;
#line 2498
      if (y___63 & 4) {
#line 2498
        tmp___41 = mbr2;
      } else {
#line 2498
        tmp___41 = mbr1;
      }
#line 2498
      cur_mbr___0 = tmp___41;
#line 2499
      if (y___63 & 4) {
#line 2499
        tmp___42 = sigma1;
      } else {
#line 2499
        tmp___42 = sigma2;
      }
#line 2499
      nxt_sig___0 = tmp___42;
#line 2500
      if (y___63 & 4) {
#line 2500
        tmp___43 = mbr1;
      } else {
#line 2500
        tmp___43 = mbr2;
      }
#line 2500
      nxt_mbr___0 = tmp___43;
#line 2501
      val___16 = 3U << (p - 2U);
#line 2502
      i___6 = 0;
      {
#line 2502
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2502
        if (! (i___6 < width)) {
#line 2502
          goto while_break___17;
        }
#line 2504
        mbr___2 = *cur_mbr___0 & pattern;
#line 2505
        new_sig___0 = (OPJ_UINT32 )0;
#line 2507
        if (mbr___2) {
#line 2509
          n___0 = 0;
          {
#line 2509
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 2509
            if (! (n___0 < 8)) {
#line 2509
              goto while_break___18;
            }
            {
#line 2515
            __cil_tmp292 = frwd_fetch(& sigprop);
#line 2515
            cwd___2 = __cil_tmp292;
#line 2516
            cnt___0 = (OPJ_UINT32 )0;
#line 2518
            dp___64 = decoded_data + y___63 * stride;
#line 2519
            dp___64 += i___6 + n___0;
#line 2521
            col_mask___62 = 15U << 4 * n___0;
#line 2523
            inv_sig___0 = ~ *(cur_sig___2 + 0) & pattern;
            }
#line 2525
            if ((n___0 + 4) + i___6 < width) {
#line 2525
              tmp___44 = n___0 + 4;
            } else {
#line 2525
              tmp___44 = width - i___6;
            }
#line 2525
            end___0 = tmp___44;
#line 2526
            j___63 = n___0;
            {
#line 2526
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 2526
              if (! (j___63 < end___0)) {
#line 2526
                goto while_break___19;
              }
#line 2529
              if ((col_mask___62 & mbr___2) == 0U) {
#line 2530
                goto while_continue___19;
              }
#line 2534
              sample_mask___3 = 286331153U & col_mask___62;
#line 2535
              if (mbr___2 & sample_mask___3) {
#line 2537
                if (cwd___2 & 1U) {
#line 2539
                  new_sig___0 |= sample_mask___3;
#line 2540
                  t___12 = 50U << j___63 * 4;
#line 2541
                  mbr___2 |= t___12 & inv_sig___0;
                }
#line 2543
                cwd___2 >>= 1;
#line 2544
                cnt___0 ++;
              }
#line 2547
              sample_mask___3 += sample_mask___3;
#line 2548
              if (mbr___2 & sample_mask___3) {
#line 2550
                if (cwd___2 & 1U) {
#line 2552
                  new_sig___0 |= sample_mask___3;
#line 2553
                  t___13 = 116U << j___63 * 4;
#line 2554
                  mbr___2 |= t___13 & inv_sig___0;
                }
#line 2556
                cwd___2 >>= 1;
#line 2557
                cnt___0 ++;
              }
#line 2560
              sample_mask___3 += sample_mask___3;
#line 2561
              if (mbr___2 & sample_mask___3) {
#line 2563
                if (cwd___2 & 1U) {
#line 2565
                  new_sig___0 |= sample_mask___3;
#line 2566
                  t___14 = 232U << j___63 * 4;
#line 2567
                  mbr___2 |= t___14 & inv_sig___0;
                }
#line 2569
                cwd___2 >>= 1;
#line 2570
                cnt___0 ++;
              }
#line 2573
              sample_mask___3 += sample_mask___3;
#line 2574
              if (mbr___2 & sample_mask___3) {
#line 2576
                if (cwd___2 & 1U) {
#line 2578
                  new_sig___0 |= sample_mask___3;
#line 2579
                  t___15 = 192U << j___63 * 4;
#line 2580
                  mbr___2 |= t___15 & inv_sig___0;
                }
#line 2582
                cwd___2 >>= 1;
#line 2583
                cnt___0 ++;
              }
#line 2526
              col_mask___62 <<= 4;
#line 2526
              dp___64 ++;
#line 2526
              j___63 ++;
            }
            while_break___19: /* CIL Label */ ;
            }
#line 2588
            if (new_sig___0 & (65535U << 4 * n___0)) {
#line 2591
              dp___69 = decoded_data + y___63 * stride;
#line 2592
              dp___69 += i___6 + n___0;
#line 2593
              col_mask___67 = 15U << 4 * n___0;
#line 2595
              j___68 = n___0;
              {
#line 2595
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 2595
                if (! (j___68 < end___0)) {
#line 2595
                  goto while_break___20;
                }
#line 2597
                if ((col_mask___67 & new_sig___0) == 0U) {
#line 2598
                  goto while_continue___20;
                }
#line 2602
                sample_mask___4 = 286331153U & col_mask___67;
#line 2603
                if (new_sig___0 & sample_mask___4) {
#line 2605
                  *(dp___69 + 0) |= ((cwd___2 & 1U) << 31) | val___16;
#line 2606
                  cwd___2 >>= 1;
#line 2607
                  cnt___0 ++;
                }
#line 2610
                sample_mask___4 += sample_mask___4;
#line 2611
                if (new_sig___0 & sample_mask___4) {
#line 2613
                  *(dp___69 + stride) |= ((cwd___2 & 1U) << 31) | val___16;
#line 2614
                  cwd___2 >>= 1;
#line 2615
                  cnt___0 ++;
                }
#line 2618
                sample_mask___4 += sample_mask___4;
#line 2619
                if (new_sig___0 & sample_mask___4) {
#line 2621
                  *(dp___69 + 2 * stride) |= ((cwd___2 & 1U) << 31) | val___16;
#line 2622
                  cwd___2 >>= 1;
#line 2623
                  cnt___0 ++;
                }
#line 2626
                sample_mask___4 += sample_mask___4;
#line 2627
                if (new_sig___0 & sample_mask___4) {
#line 2629
                  *(dp___69 + 3 * stride) |= ((cwd___2 & 1U) << 31) | val___16;
#line 2630
                  cwd___2 >>= 1;
#line 2631
                  cnt___0 ++;
                }
#line 2595
                col_mask___67 <<= 4;
#line 2595
                dp___69 ++;
#line 2595
                j___68 ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
            {
#line 2636
            frwd_advance(& sigprop, cnt___0);
#line 2637
            cnt___0 = (OPJ_UINT32 )0;
            }
#line 2640
            if (n___0 == 4) {
#line 2642
              t___16 = new_sig___0 >> 28;
#line 2643
              t___16 |= ((t___16 & 14U) >> 1) | ((t___16 & 7U) << 1);
#line 2644
              *(cur_mbr___0 + 1) |= t___16 & ~ *(cur_sig___2 + 1);
            }
#line 2509
            n___0 += 4;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
#line 2649
        new_sig___0 |= *(cur_sig___2 + 0);
#line 2650
        ux___0 = (new_sig___0 & 2290649224U) >> 3;
#line 2651
        tx___0 = (ux___0 | (ux___0 << 4)) | (ux___0 >> 4);
#line 2652
        if (i___6 > 0) {
#line 2653
          *(nxt_mbr___0 + - 1) |= (ux___0 << 28) & ~ *(nxt_sig___0 + -1);
        }
#line 2655
        *(nxt_mbr___0 + 0) |= tx___0 & ~ *(nxt_sig___0 + 0);
#line 2656
        *(nxt_mbr___0 + 1) |= (ux___0 >> 28) & ~ *(nxt_sig___0 + 1);
#line 2502
        __cil_tmp309 = nxt_mbr___0;
#line 2502
        nxt_mbr___0 ++;
#line 2502
        __cil_tmp308 = nxt_sig___0;
#line 2502
        nxt_sig___0 ++;
#line 2502
        __cil_tmp307 = cur_mbr___0;
#line 2502
        cur_mbr___0 ++;
#line 2502
        __cil_tmp306 = cur_sig___2;
#line 2502
        cur_sig___2 ++;
#line 2502
        i___6 += 8;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2459
      y___63 += 4;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
#line 2663
  y___71 = 0;
  {
#line 2663
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2663
    if (! (y___71 < height)) {
#line 2663
      goto while_break___21;
    }
#line 2664
    sp___72 = (OPJ_INT32 *)decoded_data + y___71 * stride;
#line 2665
    x___70 = 0;
    {
#line 2665
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 2665
      if (! (x___70 < width)) {
#line 2665
        goto while_break___22;
      }
#line 2666
      val___17 = *sp___72 & 2147483647;
#line 2667
      if ((OPJ_UINT32 )*sp___72 & 2147483648U) {
#line 2667
        tmp___45 = - val___17;
      } else {
#line 2667
        tmp___45 = val___17;
      }
#line 2667
      *sp___72 = tmp___45;
#line 2665
      sp___72 ++;
#line 2665
      x___70 ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 2663
    y___71 ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2672
  return (1);
}
}
#line 39 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
opj_procedure_list_t *opj_procedure_list_create(void) 
{ 
  opj_procedure_list_t *l_validation ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_procedure_list_t ));
#line 42
  l_validation = (opj_procedure_list_t *)__cil_tmp2;
  }
#line 44
  if (! l_validation) {
#line 45
    return ((opj_procedure_list_t *)0);
  }
  {
#line 48
  l_validation->m_nb_max_procedures = (OPJ_UINT32 )10;
#line 49
  __cil_tmp3 = opj_calloc((size_t )10, sizeof(opj_procedure ));
#line 49
  l_validation->m_procedures = (opj_procedure *)__cil_tmp3;
  }
#line 51
  if (! l_validation->m_procedures) {
    {
#line 52
    opj_free(l_validation);
    }
#line 53
    return ((opj_procedure_list_t *)0);
  }
#line 55
  return (l_validation);
}
}
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) 
{ 


  {
#line 60
  if (! p_list) {
#line 61
    return;
  }
#line 64
  if (p_list->m_procedures) {
    {
#line 65
    opj_free(p_list->m_procedures);
    }
  }
  {
#line 67
  opj_free(p_list);
  }
  return;
}
}
#line 70 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          opj_procedure p_procedure , opj_event_mgr_t *p_manager ) 
{ 
  opj_procedure *new_procedures ;
  void *__cil_tmp5 ;

  {
#line 76
  if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures) {
    {
#line 80
    p_validation_list->m_nb_max_procedures += (unsigned int )10;
#line 81
    __cil_tmp5 = opj_realloc(p_validation_list->m_procedures, (unsigned long )p_validation_list->m_nb_max_procedures * sizeof(opj_procedure ));
#line 81
    new_procedures = (opj_procedure *)__cil_tmp5;
    }
#line 84
    if (! new_procedures) {
      {
#line 85
      opj_free(p_validation_list->m_procedures);
#line 86
      p_validation_list->m_nb_max_procedures = (OPJ_UINT32 )0;
#line 87
      p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
#line 88
      opj_event_msg(p_manager, 1, "Not enough memory to add a new validation procedure\n");
      }
#line 90
      return (0);
    } else {
#line 92
      p_validation_list->m_procedures = new_procedures;
    }
  }
#line 95
  *(p_validation_list->m_procedures + p_validation_list->m_nb_procedures) = p_procedure;
#line 97
  (p_validation_list->m_nb_procedures) ++;
#line 99
  return (1);
}
}
#line 102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 105
  return (p_validation_list->m_nb_procedures);
}
}
#line 108 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 111
  return (p_validation_list->m_procedures);
}
}
#line 114 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.c"
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) 
{ 


  {
#line 116
  p_validation_list->m_nb_procedures = (OPJ_UINT32 )0;
  return;
}
}
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.c"
static void opj_default_callback(char const   *msg , void *client_data ) 
{ 


  {
  return;
}
}
#line 91 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.c"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *p_event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) 
{ 
  opj_msg_callback msg_handler ;
  void *l_data ;
  va_list arg ;
  char message[512] ;

  {
#line 95
  msg_handler = (opj_msg_callback )0;
#line 96
  l_data = (void *)0;
#line 98
  if (p_event_mgr != (opj_event_mgr_t *)0) {
    {
#line 100
    if (event_type == 1) {
#line 100
      goto case_1;
    }
#line 104
    if (event_type == 2) {
#line 104
      goto case_2;
    }
#line 108
    if (event_type == 4) {
#line 108
      goto case_4;
    }
#line 112
    goto switch_default;
    case_1: /* CIL Label */ 
#line 101
    msg_handler = p_event_mgr->error_handler;
#line 102
    l_data = p_event_mgr->m_error_data;
#line 103
    goto switch_break;
    case_2: /* CIL Label */ 
#line 105
    msg_handler = p_event_mgr->warning_handler;
#line 106
    l_data = p_event_mgr->m_warning_data;
#line 107
    goto switch_break;
    case_4: /* CIL Label */ 
#line 109
    msg_handler = p_event_mgr->info_handler;
#line 110
    l_data = p_event_mgr->m_info_data;
#line 111
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 115
    if (msg_handler == (opj_msg_callback )0) {
#line 116
      return (0);
    }
  } else {
#line 119
    return (0);
  }
#line 122
  if (fmt != (char const   *)0) {
#line 122
    if (p_event_mgr != (opj_event_mgr_t *)0) {
      {
#line 125
      memset((char *)message, 0, (unsigned long )512);
#line 127
      __builtin_va_start((void *)arg, fmt);
#line 129
      vsnprintf((char *)message, (unsigned long )512, fmt, (void *)arg);
#line 131
      message[511] = (char )'\000';
#line 133
      __builtin_va_end((void *)arg);
#line 136
      (*msg_handler)((char const   *)((char *)message), l_data);
      }
    }
  }
#line 139
  return (1);
}
}
#line 142 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.c"
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) 
{ 


  {
#line 144
  p_manager->m_error_data = (void *)0;
#line 145
  p_manager->m_warning_data = (void *)0;
#line 146
  p_manager->m_info_data = (void *)0;
#line 147
  p_manager->error_handler = & opj_default_callback;
#line 148
  p_manager->info_handler = & opj_default_callback;
#line 149
  p_manager->warning_handler = & opj_default_callback;
  return;
}
}
#line 281 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern char const   *TIFFGetVersion(void) ;
#line 283
extern TIFFCodec *TIFFFindCODEC(uint16  ) ;
#line 284
extern TIFFCodec *TIFFRegisterCODEC(uint16  , char const   * , TIFFInitMethod  ) ;
#line 285
extern void TIFFUnRegisterCODEC(TIFFCodec * ) ;
#line 286
extern int TIFFIsCODECConfigured(uint16  ) ;
#line 287
extern TIFFCodec *TIFFGetConfiguredCODECs(void) ;
#line 293
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 294
extern void *_TIFFcalloc(tmsize_t nmemb , tmsize_t siz ) ;
#line 295
extern void *_TIFFrealloc(void *p , tmsize_t s ) ;
#line 296
extern void _TIFFmemset(void *p , int v , tmsize_t c ) ;
#line 297
extern void _TIFFmemcpy(void *d , void const   *s , tmsize_t c ) ;
#line 298
extern int _TIFFmemcmp(void const   *p1 , void const   *p2 , tmsize_t c ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 304
extern int TIFFGetTagListCount(TIFF * ) ;
#line 305
extern uint32 TIFFGetTagListEntry(TIFF * , int tag_index ) ;
#line 317
extern TIFFField *TIFFFindField(TIFF * , uint32  , TIFFDataType  ) ;
#line 318
extern TIFFField *TIFFFieldWithTag(TIFF * , uint32  ) ;
#line 319
extern TIFFField *TIFFFieldWithName(TIFF * , char const   * ) ;
#line 321
extern uint32 TIFFFieldTag(TIFFField * ) ;
#line 322
extern char const   *TIFFFieldName(TIFFField * ) ;
#line 323
extern TIFFDataType TIFFFieldDataType(TIFFField * ) ;
#line 324
extern int TIFFFieldPassCount(TIFFField * ) ;
#line 325
extern int TIFFFieldReadCount(TIFFField * ) ;
#line 326
extern int TIFFFieldWriteCount(TIFFField * ) ;
#line 338
extern TIFFTagMethods *TIFFAccessTagMethods(TIFF * ) ;
#line 339
extern void *TIFFGetClientInfo(TIFF * , char const   * ) ;
#line 340
extern void TIFFSetClientInfo(TIFF * , void * , char const   * ) ;
#line 342
extern void TIFFCleanup(TIFF *tif ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 344
extern int TIFFFlush(TIFF *tif ) ;
#line 345
extern int TIFFFlushData(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 347
extern int TIFFVGetField(TIFF *tif , uint32 tag , va_list ap ) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 349
extern int TIFFVGetFieldDefaulted(TIFF *tif , uint32 tag , va_list ap ) ;
#line 350
extern int TIFFReadDirectory(TIFF *tif ) ;
#line 351
extern int TIFFReadCustomDirectory(TIFF *tif , toff_t diroff , TIFFFieldArray *infoarray ) ;
#line 352
extern int TIFFReadEXIFDirectory(TIFF *tif , toff_t diroff ) ;
#line 353
extern uint64 TIFFScanlineSize64(TIFF *tif ) ;
#line 354
extern tmsize_t TIFFScanlineSize(TIFF *tif ) ;
#line 355
extern uint64 TIFFRasterScanlineSize64(TIFF *tif ) ;
#line 356
extern tmsize_t TIFFRasterScanlineSize(TIFF *tif ) ;
#line 357
extern uint64 TIFFStripSize64(TIFF *tif ) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 359
extern uint64 TIFFRawStripSize64(TIFF *tif , uint32 strip ) ;
#line 360
extern tmsize_t TIFFRawStripSize(TIFF *tif , uint32 strip ) ;
#line 361
extern uint64 TIFFVStripSize64(TIFF *tif , uint32 nrows ) ;
#line 362
extern tmsize_t TIFFVStripSize(TIFF *tif , uint32 nrows ) ;
#line 363
extern uint64 TIFFTileRowSize64(TIFF *tif ) ;
#line 364
extern tmsize_t TIFFTileRowSize(TIFF *tif ) ;
#line 365
extern uint64 TIFFTileSize64(TIFF *tif ) ;
#line 366
extern tmsize_t TIFFTileSize(TIFF *tif ) ;
#line 367
extern uint64 TIFFVTileSize64(TIFF *tif , uint32 nrows ) ;
#line 368
extern tmsize_t TIFFVTileSize(TIFF *tif , uint32 nrows ) ;
#line 369
extern uint32 TIFFDefaultStripSize(TIFF *tif , uint32 request ) ;
#line 370
extern void TIFFDefaultTileSize(TIFF * , uint32 * , uint32 * ) ;
#line 371
extern int TIFFFileno(TIFF * ) ;
#line 372
extern int TIFFSetFileno(TIFF * , int  ) ;
#line 373
extern thandle_t TIFFClientdata(TIFF * ) ;
#line 374
extern thandle_t TIFFSetClientdata(TIFF * , thandle_t  ) ;
#line 375
extern int TIFFGetMode(TIFF * ) ;
#line 376
extern int TIFFSetMode(TIFF * , int  ) ;
#line 377
extern int TIFFIsTiled(TIFF * ) ;
#line 378
extern int TIFFIsByteSwapped(TIFF * ) ;
#line 379
extern int TIFFIsUpSampled(TIFF * ) ;
#line 380
extern int TIFFIsMSB2LSB(TIFF * ) ;
#line 381
extern int TIFFIsBigEndian(TIFF * ) ;
#line 382
extern TIFFReadWriteProc TIFFGetReadProc(TIFF * ) ;
#line 383
extern TIFFReadWriteProc TIFFGetWriteProc(TIFF * ) ;
#line 384
extern TIFFSeekProc TIFFGetSeekProc(TIFF * ) ;
#line 385
extern TIFFCloseProc TIFFGetCloseProc(TIFF * ) ;
#line 386
extern TIFFSizeProc TIFFGetSizeProc(TIFF * ) ;
#line 387
extern TIFFMapFileProc TIFFGetMapFileProc(TIFF * ) ;
#line 388
extern TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF * ) ;
#line 389
extern uint32 TIFFCurrentRow(TIFF * ) ;
#line 390
extern uint16 TIFFCurrentDirectory(TIFF * ) ;
#line 391
extern uint16 TIFFNumberOfDirectories(TIFF * ) ;
#line 392
extern uint64 TIFFCurrentDirOffset(TIFF * ) ;
#line 393
extern uint32 TIFFCurrentStrip(TIFF * ) ;
#line 394
extern uint32 TIFFCurrentTile(TIFF *tif ) ;
#line 395
extern int TIFFReadBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 396
extern int TIFFWriteBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 397
extern int TIFFSetupStrips(TIFF * ) ;
#line 398
extern int TIFFWriteCheck(TIFF * , int  , char const   * ) ;
#line 399
extern void TIFFFreeDirectory(TIFF * ) ;
#line 400
extern int TIFFCreateDirectory(TIFF * ) ;
#line 401
extern int TIFFCreateCustomDirectory(TIFF * , TIFFFieldArray * ) ;
#line 402
extern int TIFFCreateEXIFDirectory(TIFF * ) ;
#line 403
extern int TIFFLastDirectory(TIFF * ) ;
#line 404
extern int TIFFSetDirectory(TIFF * , uint16  ) ;
#line 405
extern int TIFFSetSubDirectory(TIFF * , uint64  ) ;
#line 406
extern int TIFFUnlinkDirectory(TIFF * , uint16  ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 408
extern int TIFFVSetField(TIFF * , uint32  , va_list  ) ;
#line 409
extern int TIFFUnsetField(TIFF * , uint32  ) ;
#line 410
extern int TIFFWriteDirectory(TIFF * ) ;
#line 411
extern int TIFFWriteCustomDirectory(TIFF * , uint64 * ) ;
#line 412
extern int TIFFCheckpointDirectory(TIFF * ) ;
#line 413
extern int TIFFRewriteDirectory(TIFF * ) ;
#line 414
extern int TIFFDeferStrileArrayWriting(TIFF * ) ;
#line 415
extern int TIFFForceStrileArrayWriting(TIFF * ) ;
#line 425
extern void TIFFPrintDirectory(TIFF * , FILE * , long  ) ;
#line 426
extern int TIFFReadScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 427
extern int TIFFWriteScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 428
extern int TIFFReadRGBAImage(TIFF * , uint32  , uint32  , uint32 * , int  ) ;
#line 429
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 432
extern int TIFFReadRGBAStrip(TIFF * , uint32  , uint32 * ) ;
#line 433
extern int TIFFReadRGBATile(TIFF * , uint32  , uint32  , uint32 * ) ;
#line 434
extern int TIFFReadRGBAStripExt(TIFF * , uint32  , uint32 * , int stop_on_error ) ;
#line 435
extern int TIFFReadRGBATileExt(TIFF * , uint32  , uint32  , uint32 * , int stop_on_error ) ;
#line 436
extern int TIFFRGBAImageOK(TIFF * , char [1024] ) ;
#line 437
extern int TIFFRGBAImageBegin(TIFFRGBAImage * , TIFF * , int  , char [1024] ) ;
#line 438
extern int TIFFRGBAImageGet(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
#line 439
extern void TIFFRGBAImageEnd(TIFFRGBAImage * ) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 444
extern TIFF *TIFFFdOpen(int  , char const   * , char const   * ) ;
#line 445
extern TIFF *TIFFClientOpen(char const   * , char const   * , thandle_t  , TIFFReadWriteProc  ,
                            TIFFReadWriteProc  , TIFFSeekProc  , TIFFCloseProc  ,
                            TIFFSizeProc  , TIFFMapFileProc  , TIFFUnmapFileProc  ) ;
#line 451
extern char const   *TIFFFileName(TIFF * ) ;
#line 452
extern char const   *TIFFSetFileName(TIFF * , char const   * ) ;
#line 453
extern void TIFFError(char const   * , char const   *  , ...) ;
#line 454
extern void TIFFErrorExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 455
extern void TIFFWarning(char const   * , char const   *  , ...) ;
#line 456
extern void TIFFWarningExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 457
extern TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler  ) ;
#line 458
extern TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt  ) ;
#line 459
extern TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler  ) ;
#line 460
extern TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt  ) ;
#line 461
extern TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc  ) ;
#line 462
extern uint32 TIFFComputeTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 463
extern int TIFFCheckTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 464
extern uint32 TIFFNumberOfTiles(TIFF * ) ;
#line 465
extern tmsize_t TIFFReadTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                             uint16 s ) ;
#line 466
extern tmsize_t TIFFWriteTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                              uint16 s ) ;
#line 467
extern uint32 TIFFComputeStrip(TIFF * , uint32  , uint16  ) ;
#line 468
extern uint32 TIFFNumberOfStrips(TIFF * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 470
extern tmsize_t TIFFReadRawStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 471
extern tmsize_t TIFFReadEncodedTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 472
extern tmsize_t TIFFReadRawTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 473
extern int TIFFReadFromUserBuffer(TIFF *tif , uint32 strile , void *inbuf , tmsize_t insize ,
                                  void *outbuf , tmsize_t outsize ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 477
extern tmsize_t TIFFWriteRawStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 478
extern tmsize_t TIFFWriteEncodedTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 479
extern tmsize_t TIFFWriteRawTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 480
extern int TIFFDataWidth(TIFFDataType  ) ;
#line 481
extern void TIFFSetWriteOffset(TIFF *tif , toff_t off ) ;
#line 482
extern void TIFFSwabShort(uint16 * ) ;
#line 483
extern void TIFFSwabLong(uint32 * ) ;
#line 484
extern void TIFFSwabLong8(uint64 * ) ;
#line 485
extern void TIFFSwabFloat(float * ) ;
#line 486
extern void TIFFSwabDouble(double * ) ;
#line 487
extern void TIFFSwabArrayOfShort(uint16 *wp , tmsize_t n ) ;
#line 488
extern void TIFFSwabArrayOfTriples(uint8 *tp , tmsize_t n ) ;
#line 489
extern void TIFFSwabArrayOfLong(uint32 *lp , tmsize_t n ) ;
#line 490
extern void TIFFSwabArrayOfLong8(uint64 *lp , tmsize_t n ) ;
#line 491
extern void TIFFSwabArrayOfFloat(float *fp , tmsize_t n ) ;
#line 492
extern void TIFFSwabArrayOfDouble(double *dp , tmsize_t n ) ;
#line 493
extern void TIFFReverseBits(uint8 *cp , tmsize_t n ) ;
#line 494
extern unsigned char const   *TIFFGetBitRevTable(int  ) ;
#line 496
extern uint64 TIFFGetStrileOffset(TIFF *tif , uint32 strile ) ;
#line 497
extern uint64 TIFFGetStrileByteCount(TIFF *tif , uint32 strile ) ;
#line 498
extern uint64 TIFFGetStrileOffsetWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 499
extern uint64 TIFFGetStrileByteCountWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 505
extern double LogL16toY(int  ) ;
#line 506
extern double LogL10toY(int  ) ;
#line 507
extern void XYZtoRGB24(float * , uint8 * ) ;
#line 508
extern int uv_decode(double * , double * , int  ) ;
#line 509
extern void LogLuv24toXYZ(uint32  , float * ) ;
#line 510
extern void LogLuv32toXYZ(uint32  , float * ) ;
#line 518
extern int LogL16fromY(double  , int  ) ;
#line 519
extern int LogL10fromY(double  , int  ) ;
#line 520
extern int uv_encode(double  , double  , int  ) ;
#line 521
extern uint32 LogLuv24fromXYZ(float * , int  ) ;
#line 522
extern uint32 LogLuv32fromXYZ(float * , int  ) ;
#line 526
extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB * , TIFFDisplay * , float * ) ;
#line 527
extern void TIFFCIELabToXYZ(TIFFCIELabToRGB * , uint32  , int32  , int32  , float * ,
                            float * , float * ) ;
#line 529
extern void TIFFXYZToRGB(TIFFCIELabToRGB * , float  , float  , float  , uint32 * ,
                         uint32 * , uint32 * ) ;
#line 532
extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB * , float * , float * ) ;
#line 533
extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB * , uint32  , int32  , int32  , uint32 * ,
                           uint32 * , uint32 * ) ;
#line 553
extern int TIFFMergeFieldInfo(TIFF * , TIFFFieldInfo [] , uint32  ) ;
#line 88 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto3u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;

  {
#line 93
  i = (OPJ_SIZE_T )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 93
      goto while_break;
    }
#line 94
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 95
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 96
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 97
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 98
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 99
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 100
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 101
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 103
    __cil_tmp13 = pDst;
#line 103
    pDst ++;
#line 103
    *__cil_tmp13 = (OPJ_BYTE )(((src0 << 5) | (src1 << 2)) | (src2 >> 1));
#line 104
    __cil_tmp14 = pDst;
#line 104
    pDst ++;
#line 104
    *__cil_tmp14 = (OPJ_BYTE )((((src2 << 7) | (src3 << 4)) | (src4 << 1)) | (src5 >> 2));
#line 105
    __cil_tmp15 = pDst;
#line 105
    pDst ++;
#line 105
    *__cil_tmp15 = (OPJ_BYTE )(((src5 << 6) | (src6 << 3)) | src7);
#line 93
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (length & 7UL) {
#line 109
    trailing = 0U;
#line 110
    remaining = (int )8U;
#line 111
    length &= (unsigned long )7U;
#line 112
    if (3 >= remaining) {
#line 112
      trailing <<= remaining;
#line 112
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (3 - remaining));
#line 112
      __cil_tmp18 = pDst;
#line 112
      pDst ++;
#line 112
      *__cil_tmp18 = (OPJ_BYTE )trailing;
#line 112
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (3 - remaining)) - 1U));
#line 112
      if (3 >= remaining + 8) {
#line 112
        __cil_tmp19 = pDst;
#line 112
        pDst ++;
#line 112
        *__cil_tmp19 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 112
        trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 112
        remaining += 13;
      } else {
#line 112
        remaining += 5;
      }
    } else {
#line 112
      trailing <<= 3;
#line 112
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i));
#line 112
      remaining -= 3;
    }
#line 113
    if (length > 1UL) {
#line 114
      if (3 >= remaining) {
#line 114
        trailing <<= remaining;
#line 114
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (3 - remaining));
#line 114
        __cil_tmp20 = pDst;
#line 114
        pDst ++;
#line 114
        *__cil_tmp20 = (OPJ_BYTE )trailing;
#line 114
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (3 - remaining)) - 1U));
#line 114
        if (3 >= remaining + 8) {
#line 114
          __cil_tmp21 = pDst;
#line 114
          pDst ++;
#line 114
          *__cil_tmp21 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 114
          trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 114
          remaining += 13;
        } else {
#line 114
          remaining += 5;
        }
      } else {
#line 114
        trailing <<= 3;
#line 114
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)));
#line 114
        remaining -= 3;
      }
#line 115
      if (length > 2UL) {
#line 116
        if (3 >= remaining) {
#line 116
          trailing <<= remaining;
#line 116
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (3 - remaining));
#line 116
          __cil_tmp22 = pDst;
#line 116
          pDst ++;
#line 116
          *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 116
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (3 - remaining)) - 1U));
#line 116
          if (3 >= remaining + 8) {
#line 116
            __cil_tmp23 = pDst;
#line 116
            pDst ++;
#line 116
            *__cil_tmp23 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 116
            trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 116
            remaining += 13;
          } else {
#line 116
            remaining += 5;
          }
        } else {
#line 116
          trailing <<= 3;
#line 116
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)));
#line 116
          remaining -= 3;
        }
#line 117
        if (length > 3UL) {
#line 118
          if (3 >= remaining) {
#line 118
            trailing <<= remaining;
#line 118
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (3 - remaining));
#line 118
            __cil_tmp24 = pDst;
#line 118
            pDst ++;
#line 118
            *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 118
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (3 - remaining)) - 1U));
#line 118
            if (3 >= remaining + 8) {
#line 118
              __cil_tmp25 = pDst;
#line 118
              pDst ++;
#line 118
              *__cil_tmp25 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 118
              trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 118
              remaining += 13;
            } else {
#line 118
              remaining += 5;
            }
          } else {
#line 118
            trailing <<= 3;
#line 118
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)));
#line 118
            remaining -= 3;
          }
#line 119
          if (length > 4UL) {
#line 120
            if (3 >= remaining) {
#line 120
              trailing <<= remaining;
#line 120
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (3 - remaining));
#line 120
              __cil_tmp26 = pDst;
#line 120
              pDst ++;
#line 120
              *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 120
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (3 - remaining)) - 1U));
#line 120
              if (3 >= remaining + 8) {
#line 120
                __cil_tmp27 = pDst;
#line 120
                pDst ++;
#line 120
                *__cil_tmp27 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 120
                trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 120
                remaining += 13;
              } else {
#line 120
                remaining += 5;
              }
            } else {
#line 120
              trailing <<= 3;
#line 120
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)));
#line 120
              remaining -= 3;
            }
#line 121
            if (length > 5UL) {
#line 122
              if (3 >= remaining) {
#line 122
                trailing <<= remaining;
#line 122
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (3 - remaining));
#line 122
                __cil_tmp28 = pDst;
#line 122
                pDst ++;
#line 122
                *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 122
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (3 - remaining)) - 1U));
#line 122
                if (3 >= remaining + 8) {
#line 122
                  __cil_tmp29 = pDst;
#line 122
                  pDst ++;
#line 122
                  *__cil_tmp29 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 122
                  trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 122
                  remaining += 13;
                } else {
#line 122
                  remaining += 5;
                }
              } else {
#line 122
                trailing <<= 3;
#line 122
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)));
#line 122
                remaining -= 3;
              }
#line 123
              if (length > 6UL) {
#line 124
                if (3 >= remaining) {
#line 124
                  trailing <<= remaining;
#line 124
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (3 - remaining));
#line 124
                  __cil_tmp30 = pDst;
#line 124
                  pDst ++;
#line 124
                  *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 124
                  trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (3 - remaining)) - 1U));
#line 124
                  if (3 >= remaining + 8) {
#line 124
                    __cil_tmp31 = pDst;
#line 124
                    pDst ++;
#line 124
                    *__cil_tmp31 = (OPJ_BYTE )(trailing >> (3 - (remaining + 8)));
#line 124
                    trailing &= (unsigned int )((1U << (3 - (remaining + 8))) - 1U);
#line 124
                    remaining += 13;
                  } else {
#line 124
                    remaining += 5;
                  }
                } else {
#line 124
                  trailing <<= 3;
#line 124
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)));
#line 124
                  remaining -= 3;
                }
              }
            }
          }
        }
      }
    }
#line 131
    if (remaining != 8) {
#line 131
      trailing <<= remaining;
#line 131
      __cil_tmp32 = pDst;
#line 131
      pDst ++;
#line 131
      *__cil_tmp32 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 135 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto5u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;

  {
#line 140
  i = (OPJ_SIZE_T )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 140
      goto while_break;
    }
#line 141
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 142
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 143
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 144
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 145
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 146
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 147
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 148
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 150
    __cil_tmp13 = pDst;
#line 150
    pDst ++;
#line 150
    *__cil_tmp13 = (OPJ_BYTE )((src0 << 3) | (src1 >> 2));
#line 151
    __cil_tmp14 = pDst;
#line 151
    pDst ++;
#line 151
    *__cil_tmp14 = (OPJ_BYTE )(((src1 << 6) | (src2 << 1)) | (src3 >> 4));
#line 152
    __cil_tmp15 = pDst;
#line 152
    pDst ++;
#line 152
    *__cil_tmp15 = (OPJ_BYTE )((src3 << 4) | (src4 >> 1));
#line 153
    __cil_tmp16 = pDst;
#line 153
    pDst ++;
#line 153
    *__cil_tmp16 = (OPJ_BYTE )(((src4 << 7) | (src5 << 2)) | (src6 >> 3));
#line 154
    __cil_tmp17 = pDst;
#line 154
    pDst ++;
#line 154
    *__cil_tmp17 = (OPJ_BYTE )((src6 << 5) | src7);
#line 140
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (length & 7UL) {
#line 159
    trailing = 0U;
#line 160
    remaining = (int )8U;
#line 161
    length &= (unsigned long )7U;
#line 162
    if (5 >= remaining) {
#line 162
      trailing <<= remaining;
#line 162
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (5 - remaining));
#line 162
      __cil_tmp20 = pDst;
#line 162
      pDst ++;
#line 162
      *__cil_tmp20 = (OPJ_BYTE )trailing;
#line 162
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (5 - remaining)) - 1U));
#line 162
      if (5 >= remaining + 8) {
#line 162
        __cil_tmp21 = pDst;
#line 162
        pDst ++;
#line 162
        *__cil_tmp21 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 162
        trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 162
        remaining += 11;
      } else {
#line 162
        remaining += 3;
      }
    } else {
#line 162
      trailing <<= 5;
#line 162
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i));
#line 162
      remaining -= 5;
    }
#line 163
    if (length > 1UL) {
#line 164
      if (5 >= remaining) {
#line 164
        trailing <<= remaining;
#line 164
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (5 - remaining));
#line 164
        __cil_tmp22 = pDst;
#line 164
        pDst ++;
#line 164
        *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 164
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (5 - remaining)) - 1U));
#line 164
        if (5 >= remaining + 8) {
#line 164
          __cil_tmp23 = pDst;
#line 164
          pDst ++;
#line 164
          *__cil_tmp23 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 164
          trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 164
          remaining += 11;
        } else {
#line 164
          remaining += 3;
        }
      } else {
#line 164
        trailing <<= 5;
#line 164
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)));
#line 164
        remaining -= 5;
      }
#line 165
      if (length > 2UL) {
#line 166
        if (5 >= remaining) {
#line 166
          trailing <<= remaining;
#line 166
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (5 - remaining));
#line 166
          __cil_tmp24 = pDst;
#line 166
          pDst ++;
#line 166
          *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 166
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (5 - remaining)) - 1U));
#line 166
          if (5 >= remaining + 8) {
#line 166
            __cil_tmp25 = pDst;
#line 166
            pDst ++;
#line 166
            *__cil_tmp25 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 166
            trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 166
            remaining += 11;
          } else {
#line 166
            remaining += 3;
          }
        } else {
#line 166
          trailing <<= 5;
#line 166
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)));
#line 166
          remaining -= 5;
        }
#line 167
        if (length > 3UL) {
#line 168
          if (5 >= remaining) {
#line 168
            trailing <<= remaining;
#line 168
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (5 - remaining));
#line 168
            __cil_tmp26 = pDst;
#line 168
            pDst ++;
#line 168
            *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 168
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (5 - remaining)) - 1U));
#line 168
            if (5 >= remaining + 8) {
#line 168
              __cil_tmp27 = pDst;
#line 168
              pDst ++;
#line 168
              *__cil_tmp27 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 168
              trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 168
              remaining += 11;
            } else {
#line 168
              remaining += 3;
            }
          } else {
#line 168
            trailing <<= 5;
#line 168
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)));
#line 168
            remaining -= 5;
          }
#line 169
          if (length > 4UL) {
#line 170
            if (5 >= remaining) {
#line 170
              trailing <<= remaining;
#line 170
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (5 - remaining));
#line 170
              __cil_tmp28 = pDst;
#line 170
              pDst ++;
#line 170
              *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 170
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (5 - remaining)) - 1U));
#line 170
              if (5 >= remaining + 8) {
#line 170
                __cil_tmp29 = pDst;
#line 170
                pDst ++;
#line 170
                *__cil_tmp29 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 170
                trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 170
                remaining += 11;
              } else {
#line 170
                remaining += 3;
              }
            } else {
#line 170
              trailing <<= 5;
#line 170
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)));
#line 170
              remaining -= 5;
            }
#line 171
            if (length > 5UL) {
#line 172
              if (5 >= remaining) {
#line 172
                trailing <<= remaining;
#line 172
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (5 - remaining));
#line 172
                __cil_tmp30 = pDst;
#line 172
                pDst ++;
#line 172
                *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 172
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (5 - remaining)) - 1U));
#line 172
                if (5 >= remaining + 8) {
#line 172
                  __cil_tmp31 = pDst;
#line 172
                  pDst ++;
#line 172
                  *__cil_tmp31 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 172
                  trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 172
                  remaining += 11;
                } else {
#line 172
                  remaining += 3;
                }
              } else {
#line 172
                trailing <<= 5;
#line 172
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)));
#line 172
                remaining -= 5;
              }
#line 173
              if (length > 6UL) {
#line 174
                if (5 >= remaining) {
#line 174
                  trailing <<= remaining;
#line 174
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (5 - remaining));
#line 174
                  __cil_tmp32 = pDst;
#line 174
                  pDst ++;
#line 174
                  *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 174
                  trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (5 - remaining)) - 1U));
#line 174
                  if (5 >= remaining + 8) {
#line 174
                    __cil_tmp33 = pDst;
#line 174
                    pDst ++;
#line 174
                    *__cil_tmp33 = (OPJ_BYTE )(trailing >> (5 - (remaining + 8)));
#line 174
                    trailing &= (unsigned int )((1U << (5 - (remaining + 8))) - 1U);
#line 174
                    remaining += 11;
                  } else {
#line 174
                    remaining += 3;
                  }
                } else {
#line 174
                  trailing <<= 5;
#line 174
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)));
#line 174
                  remaining -= 5;
                }
              }
            }
          }
        }
      }
    }
#line 181
    if (remaining != 8) {
#line 181
      trailing <<= remaining;
#line 181
      __cil_tmp34 = pDst;
#line 181
      pDst ++;
#line 181
      *__cil_tmp34 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 185 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto7u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;

  {
#line 190
  i = (OPJ_SIZE_T )0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 190
      goto while_break;
    }
#line 191
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 192
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 193
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 194
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 195
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 196
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 197
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 198
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 200
    __cil_tmp13 = pDst;
#line 200
    pDst ++;
#line 200
    *__cil_tmp13 = (OPJ_BYTE )((src0 << 1) | (src1 >> 6));
#line 201
    __cil_tmp14 = pDst;
#line 201
    pDst ++;
#line 201
    *__cil_tmp14 = (OPJ_BYTE )((src1 << 2) | (src2 >> 5));
#line 202
    __cil_tmp15 = pDst;
#line 202
    pDst ++;
#line 202
    *__cil_tmp15 = (OPJ_BYTE )((src2 << 3) | (src3 >> 4));
#line 203
    __cil_tmp16 = pDst;
#line 203
    pDst ++;
#line 203
    *__cil_tmp16 = (OPJ_BYTE )((src3 << 4) | (src4 >> 3));
#line 204
    __cil_tmp17 = pDst;
#line 204
    pDst ++;
#line 204
    *__cil_tmp17 = (OPJ_BYTE )((src4 << 5) | (src5 >> 2));
#line 205
    __cil_tmp18 = pDst;
#line 205
    pDst ++;
#line 205
    *__cil_tmp18 = (OPJ_BYTE )((src5 << 6) | (src6 >> 1));
#line 206
    __cil_tmp19 = pDst;
#line 206
    pDst ++;
#line 206
    *__cil_tmp19 = (OPJ_BYTE )((src6 << 7) | src7);
#line 190
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (length & 7UL) {
#line 210
    trailing = 0U;
#line 211
    remaining = (int )8U;
#line 212
    length &= (unsigned long )7U;
#line 213
    if (7 >= remaining) {
#line 213
      trailing <<= remaining;
#line 213
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (7 - remaining));
#line 213
      __cil_tmp22 = pDst;
#line 213
      pDst ++;
#line 213
      *__cil_tmp22 = (OPJ_BYTE )trailing;
#line 213
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (7 - remaining)) - 1U));
#line 213
      if (7 >= remaining + 8) {
#line 213
        __cil_tmp23 = pDst;
#line 213
        pDst ++;
#line 213
        *__cil_tmp23 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 213
        trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 213
        remaining += 9;
      } else {
#line 213
        remaining ++;
      }
    } else {
#line 213
      trailing <<= 7;
#line 213
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i));
#line 213
      remaining -= 7;
    }
#line 214
    if (length > 1UL) {
#line 215
      if (7 >= remaining) {
#line 215
        trailing <<= remaining;
#line 215
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (7 - remaining));
#line 215
        __cil_tmp24 = pDst;
#line 215
        pDst ++;
#line 215
        *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 215
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (7 - remaining)) - 1U));
#line 215
        if (7 >= remaining + 8) {
#line 215
          __cil_tmp25 = pDst;
#line 215
          pDst ++;
#line 215
          *__cil_tmp25 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 215
          trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 215
          remaining += 9;
        } else {
#line 215
          remaining ++;
        }
      } else {
#line 215
        trailing <<= 7;
#line 215
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)));
#line 215
        remaining -= 7;
      }
#line 216
      if (length > 2UL) {
#line 217
        if (7 >= remaining) {
#line 217
          trailing <<= remaining;
#line 217
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (7 - remaining));
#line 217
          __cil_tmp26 = pDst;
#line 217
          pDst ++;
#line 217
          *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 217
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (7 - remaining)) - 1U));
#line 217
          if (7 >= remaining + 8) {
#line 217
            __cil_tmp27 = pDst;
#line 217
            pDst ++;
#line 217
            *__cil_tmp27 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 217
            trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 217
            remaining += 9;
          } else {
#line 217
            remaining ++;
          }
        } else {
#line 217
          trailing <<= 7;
#line 217
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)));
#line 217
          remaining -= 7;
        }
#line 218
        if (length > 3UL) {
#line 219
          if (7 >= remaining) {
#line 219
            trailing <<= remaining;
#line 219
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (7 - remaining));
#line 219
            __cil_tmp28 = pDst;
#line 219
            pDst ++;
#line 219
            *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 219
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (7 - remaining)) - 1U));
#line 219
            if (7 >= remaining + 8) {
#line 219
              __cil_tmp29 = pDst;
#line 219
              pDst ++;
#line 219
              *__cil_tmp29 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 219
              trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 219
              remaining += 9;
            } else {
#line 219
              remaining ++;
            }
          } else {
#line 219
            trailing <<= 7;
#line 219
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)));
#line 219
            remaining -= 7;
          }
#line 220
          if (length > 4UL) {
#line 221
            if (7 >= remaining) {
#line 221
              trailing <<= remaining;
#line 221
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (7 - remaining));
#line 221
              __cil_tmp30 = pDst;
#line 221
              pDst ++;
#line 221
              *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 221
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (7 - remaining)) - 1U));
#line 221
              if (7 >= remaining + 8) {
#line 221
                __cil_tmp31 = pDst;
#line 221
                pDst ++;
#line 221
                *__cil_tmp31 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 221
                trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 221
                remaining += 9;
              } else {
#line 221
                remaining ++;
              }
            } else {
#line 221
              trailing <<= 7;
#line 221
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)));
#line 221
              remaining -= 7;
            }
#line 222
            if (length > 5UL) {
#line 223
              if (7 >= remaining) {
#line 223
                trailing <<= remaining;
#line 223
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (7 - remaining));
#line 223
                __cil_tmp32 = pDst;
#line 223
                pDst ++;
#line 223
                *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 223
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (7 - remaining)) - 1U));
#line 223
                if (7 >= remaining + 8) {
#line 223
                  __cil_tmp33 = pDst;
#line 223
                  pDst ++;
#line 223
                  *__cil_tmp33 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 223
                  trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 223
                  remaining += 9;
                } else {
#line 223
                  remaining ++;
                }
              } else {
#line 223
                trailing <<= 7;
#line 223
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)));
#line 223
                remaining -= 7;
              }
#line 224
              if (length > 6UL) {
#line 225
                if (7 >= remaining) {
#line 225
                  trailing <<= remaining;
#line 225
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (7 - remaining));
#line 225
                  __cil_tmp34 = pDst;
#line 225
                  pDst ++;
#line 225
                  *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 225
                  trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (7 - remaining)) - 1U));
#line 225
                  if (7 >= remaining + 8) {
#line 225
                    __cil_tmp35 = pDst;
#line 225
                    pDst ++;
#line 225
                    *__cil_tmp35 = (OPJ_BYTE )(trailing >> (7 - (remaining + 8)));
#line 225
                    trailing &= (unsigned int )((1U << (7 - (remaining + 8))) - 1U);
#line 225
                    remaining += 9;
                  } else {
#line 225
                    remaining ++;
                  }
                } else {
#line 225
                  trailing <<= 7;
#line 225
                  trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)));
#line 225
                  remaining -= 7;
                }
              }
            }
          }
        }
      }
    }
#line 232
    if (remaining != 8) {
#line 232
      trailing <<= remaining;
#line 232
      __cil_tmp36 = pDst;
#line 232
      pDst ++;
#line 232
      *__cil_tmp36 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto9u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;

  {
#line 241
  i = (OPJ_SIZE_T )0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 241
      goto while_break;
    }
#line 242
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 243
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 244
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 245
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 246
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 247
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 248
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 249
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 251
    __cil_tmp13 = pDst;
#line 251
    pDst ++;
#line 251
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 1);
#line 252
    __cil_tmp14 = pDst;
#line 252
    pDst ++;
#line 252
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 7) | (src1 >> 2));
#line 253
    __cil_tmp15 = pDst;
#line 253
    pDst ++;
#line 253
    *__cil_tmp15 = (OPJ_BYTE )((src1 << 6) | (src2 >> 3));
#line 254
    __cil_tmp16 = pDst;
#line 254
    pDst ++;
#line 254
    *__cil_tmp16 = (OPJ_BYTE )((src2 << 5) | (src3 >> 4));
#line 255
    __cil_tmp17 = pDst;
#line 255
    pDst ++;
#line 255
    *__cil_tmp17 = (OPJ_BYTE )((src3 << 4) | (src4 >> 5));
#line 256
    __cil_tmp18 = pDst;
#line 256
    pDst ++;
#line 256
    *__cil_tmp18 = (OPJ_BYTE )((src4 << 3) | (src5 >> 6));
#line 257
    __cil_tmp19 = pDst;
#line 257
    pDst ++;
#line 257
    *__cil_tmp19 = (OPJ_BYTE )((src5 << 2) | (src6 >> 7));
#line 258
    __cil_tmp20 = pDst;
#line 258
    pDst ++;
#line 258
    *__cil_tmp20 = (OPJ_BYTE )((src6 << 1) | (src7 >> 8));
#line 259
    __cil_tmp21 = pDst;
#line 259
    pDst ++;
#line 259
    *__cil_tmp21 = (OPJ_BYTE )src7;
#line 241
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if (length & 7UL) {
#line 263
    trailing = 0U;
#line 264
    remaining = (int )8U;
#line 265
    length &= (unsigned long )7U;
#line 266
    trailing <<= remaining;
#line 266
    trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (9 - remaining));
#line 266
    __cil_tmp24 = pDst;
#line 266
    pDst ++;
#line 266
    *__cil_tmp24 = (OPJ_BYTE )trailing;
#line 266
    trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (9 - remaining)) - 1U));
#line 266
    if (9 >= remaining + 8) {
#line 266
      __cil_tmp25 = pDst;
#line 266
      pDst ++;
#line 266
      *__cil_tmp25 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 266
      trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 266
      remaining += 7;
    } else {
#line 266
      remaining --;
    }
#line 267
    if (length > 1UL) {
#line 268
      trailing <<= remaining;
#line 268
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (9 - remaining));
#line 268
      __cil_tmp26 = pDst;
#line 268
      pDst ++;
#line 268
      *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 268
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (9 - remaining)) - 1U));
#line 268
      if (9 >= remaining + 8) {
#line 268
        __cil_tmp27 = pDst;
#line 268
        pDst ++;
#line 268
        *__cil_tmp27 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 268
        trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 268
        remaining += 7;
      } else {
#line 268
        remaining --;
      }
#line 269
      if (length > 2UL) {
#line 270
        trailing <<= remaining;
#line 270
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (9 - remaining));
#line 270
        __cil_tmp28 = pDst;
#line 270
        pDst ++;
#line 270
        *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 270
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (9 - remaining)) - 1U));
#line 270
        if (9 >= remaining + 8) {
#line 270
          __cil_tmp29 = pDst;
#line 270
          pDst ++;
#line 270
          *__cil_tmp29 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 270
          trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 270
          remaining += 7;
        } else {
#line 270
          remaining --;
        }
#line 271
        if (length > 3UL) {
#line 272
          trailing <<= remaining;
#line 272
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (9 - remaining));
#line 272
          __cil_tmp30 = pDst;
#line 272
          pDst ++;
#line 272
          *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 272
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (9 - remaining)) - 1U));
#line 272
          if (9 >= remaining + 8) {
#line 272
            __cil_tmp31 = pDst;
#line 272
            pDst ++;
#line 272
            *__cil_tmp31 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 272
            trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 272
            remaining += 7;
          } else {
#line 272
            remaining --;
          }
#line 273
          if (length > 4UL) {
#line 274
            trailing <<= remaining;
#line 274
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (9 - remaining));
#line 274
            __cil_tmp32 = pDst;
#line 274
            pDst ++;
#line 274
            *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 274
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (9 - remaining)) - 1U));
#line 274
            if (9 >= remaining + 8) {
#line 274
              __cil_tmp33 = pDst;
#line 274
              pDst ++;
#line 274
              *__cil_tmp33 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 274
              trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 274
              remaining += 7;
            } else {
#line 274
              remaining --;
            }
#line 275
            if (length > 5UL) {
#line 276
              trailing <<= remaining;
#line 276
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (9 - remaining));
#line 276
              __cil_tmp34 = pDst;
#line 276
              pDst ++;
#line 276
              *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 276
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (9 - remaining)) - 1U));
#line 276
              if (9 >= remaining + 8) {
#line 276
                __cil_tmp35 = pDst;
#line 276
                pDst ++;
#line 276
                *__cil_tmp35 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 276
                trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 276
                remaining += 7;
              } else {
#line 276
                remaining --;
              }
#line 277
              if (length > 6UL) {
#line 278
                trailing <<= remaining;
#line 278
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (9 - remaining));
#line 278
                __cil_tmp36 = pDst;
#line 278
                pDst ++;
#line 278
                *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 278
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (9 - remaining)) - 1U));
#line 278
                if (9 >= remaining + 8) {
#line 278
                  __cil_tmp37 = pDst;
#line 278
                  pDst ++;
#line 278
                  *__cil_tmp37 = (OPJ_BYTE )(trailing >> (9 - (remaining + 8)));
#line 278
                  trailing &= (unsigned int )((1U << (9 - (remaining + 8))) - 1U);
#line 278
                  remaining += 7;
                } else {
#line 278
                  remaining --;
                }
              }
            }
          }
        }
      }
    }
#line 285
    if (remaining != 8) {
#line 285
      trailing <<= remaining;
#line 285
      __cil_tmp38 = pDst;
#line 285
      pDst ++;
#line 285
      *__cil_tmp38 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 289 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto10u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;

  {
#line 293
  i = (OPJ_SIZE_T )0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 293
      goto while_break;
    }
#line 294
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 295
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 296
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 297
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 299
    __cil_tmp9 = pDst;
#line 299
    pDst ++;
#line 299
    *__cil_tmp9 = (OPJ_BYTE )(src0 >> 2);
#line 300
    __cil_tmp10 = pDst;
#line 300
    pDst ++;
#line 300
    *__cil_tmp10 = (OPJ_BYTE )(((src0 & 3U) << 6) | (src1 >> 4));
#line 301
    __cil_tmp11 = pDst;
#line 301
    pDst ++;
#line 301
    *__cil_tmp11 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 6));
#line 302
    __cil_tmp12 = pDst;
#line 302
    pDst ++;
#line 302
    *__cil_tmp12 = (OPJ_BYTE )(((src2 & 63U) << 2) | (src3 >> 8));
#line 303
    __cil_tmp13 = pDst;
#line 303
    pDst ++;
#line 303
    *__cil_tmp13 = (OPJ_BYTE )src3;
#line 293
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (length & 3UL) {
#line 307
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 308
    src1___0 = 0U;
#line 309
    src2___0 = 0U;
#line 310
    length &= 3UL;
#line 312
    if (length > 1UL) {
#line 313
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 314
      if (length > 2UL) {
#line 315
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 318
    __cil_tmp17 = pDst;
#line 318
    pDst ++;
#line 318
    *__cil_tmp17 = (OPJ_BYTE )(src0___0 >> 2);
#line 319
    __cil_tmp18 = pDst;
#line 319
    pDst ++;
#line 319
    *__cil_tmp18 = (OPJ_BYTE )(((src0___0 & 3U) << 6) | (src1___0 >> 4));
#line 320
    if (length > 1UL) {
#line 321
      __cil_tmp19 = pDst;
#line 321
      pDst ++;
#line 321
      *__cil_tmp19 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 6));
#line 322
      if (length > 2UL) {
#line 323
        __cil_tmp20 = pDst;
#line 323
        pDst ++;
#line 323
        *__cil_tmp20 = (OPJ_BYTE )((src2___0 & 63U) << 2);
      }
    }
  }
  return;
}
}
#line 328 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto11u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;

  {
#line 333
  i = (OPJ_SIZE_T )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 333
      goto while_break;
    }
#line 334
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 335
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 336
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 337
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 338
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 339
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 340
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 341
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 343
    __cil_tmp13 = pDst;
#line 343
    pDst ++;
#line 343
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 3);
#line 344
    __cil_tmp14 = pDst;
#line 344
    pDst ++;
#line 344
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 5) | (src1 >> 6));
#line 345
    __cil_tmp15 = pDst;
#line 345
    pDst ++;
#line 345
    *__cil_tmp15 = (OPJ_BYTE )((src1 << 2) | (src2 >> 9));
#line 346
    __cil_tmp16 = pDst;
#line 346
    pDst ++;
#line 346
    *__cil_tmp16 = (OPJ_BYTE )(src2 >> 1);
#line 347
    __cil_tmp17 = pDst;
#line 347
    pDst ++;
#line 347
    *__cil_tmp17 = (OPJ_BYTE )((src2 << 7) | (src3 >> 4));
#line 348
    __cil_tmp18 = pDst;
#line 348
    pDst ++;
#line 348
    *__cil_tmp18 = (OPJ_BYTE )((src3 << 4) | (src4 >> 7));
#line 349
    __cil_tmp19 = pDst;
#line 349
    pDst ++;
#line 349
    *__cil_tmp19 = (OPJ_BYTE )((src4 << 1) | (src5 >> 10));
#line 350
    __cil_tmp20 = pDst;
#line 350
    pDst ++;
#line 350
    *__cil_tmp20 = (OPJ_BYTE )(src5 >> 2);
#line 351
    __cil_tmp21 = pDst;
#line 351
    pDst ++;
#line 351
    *__cil_tmp21 = (OPJ_BYTE )((src5 << 6) | (src6 >> 5));
#line 352
    __cil_tmp22 = pDst;
#line 352
    pDst ++;
#line 352
    *__cil_tmp22 = (OPJ_BYTE )((src6 << 3) | (src7 >> 8));
#line 353
    __cil_tmp23 = pDst;
#line 353
    pDst ++;
#line 353
    *__cil_tmp23 = (OPJ_BYTE )src7;
#line 333
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  if (length & 7UL) {
#line 357
    trailing = 0U;
#line 358
    remaining = (int )8U;
#line 359
    length &= (unsigned long )7U;
#line 360
    trailing <<= remaining;
#line 360
    trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (11 - remaining));
#line 360
    __cil_tmp26 = pDst;
#line 360
    pDst ++;
#line 360
    *__cil_tmp26 = (OPJ_BYTE )trailing;
#line 360
    trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (11 - remaining)) - 1U));
#line 360
    if (11 >= remaining + 8) {
#line 360
      __cil_tmp27 = pDst;
#line 360
      pDst ++;
#line 360
      *__cil_tmp27 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 360
      trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 360
      remaining += 5;
    } else {
#line 360
      remaining += -3;
    }
#line 361
    if (length > 1UL) {
#line 362
      trailing <<= remaining;
#line 362
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (11 - remaining));
#line 362
      __cil_tmp28 = pDst;
#line 362
      pDst ++;
#line 362
      *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 362
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (11 - remaining)) - 1U));
#line 362
      if (11 >= remaining + 8) {
#line 362
        __cil_tmp29 = pDst;
#line 362
        pDst ++;
#line 362
        *__cil_tmp29 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 362
        trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 362
        remaining += 5;
      } else {
#line 362
        remaining += -3;
      }
#line 363
      if (length > 2UL) {
#line 364
        trailing <<= remaining;
#line 364
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (11 - remaining));
#line 364
        __cil_tmp30 = pDst;
#line 364
        pDst ++;
#line 364
        *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 364
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (11 - remaining)) - 1U));
#line 364
        if (11 >= remaining + 8) {
#line 364
          __cil_tmp31 = pDst;
#line 364
          pDst ++;
#line 364
          *__cil_tmp31 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 364
          trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 364
          remaining += 5;
        } else {
#line 364
          remaining += -3;
        }
#line 365
        if (length > 3UL) {
#line 366
          trailing <<= remaining;
#line 366
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (11 - remaining));
#line 366
          __cil_tmp32 = pDst;
#line 366
          pDst ++;
#line 366
          *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 366
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (11 - remaining)) - 1U));
#line 366
          if (11 >= remaining + 8) {
#line 366
            __cil_tmp33 = pDst;
#line 366
            pDst ++;
#line 366
            *__cil_tmp33 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 366
            trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 366
            remaining += 5;
          } else {
#line 366
            remaining += -3;
          }
#line 367
          if (length > 4UL) {
#line 368
            trailing <<= remaining;
#line 368
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (11 - remaining));
#line 368
            __cil_tmp34 = pDst;
#line 368
            pDst ++;
#line 368
            *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 368
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (11 - remaining)) - 1U));
#line 368
            if (11 >= remaining + 8) {
#line 368
              __cil_tmp35 = pDst;
#line 368
              pDst ++;
#line 368
              *__cil_tmp35 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 368
              trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 368
              remaining += 5;
            } else {
#line 368
              remaining += -3;
            }
#line 369
            if (length > 5UL) {
#line 370
              trailing <<= remaining;
#line 370
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (11 - remaining));
#line 370
              __cil_tmp36 = pDst;
#line 370
              pDst ++;
#line 370
              *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 370
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (11 - remaining)) - 1U));
#line 370
              if (11 >= remaining + 8) {
#line 370
                __cil_tmp37 = pDst;
#line 370
                pDst ++;
#line 370
                *__cil_tmp37 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 370
                trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 370
                remaining += 5;
              } else {
#line 370
                remaining += -3;
              }
#line 371
              if (length > 6UL) {
#line 372
                trailing <<= remaining;
#line 372
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (11 - remaining));
#line 372
                __cil_tmp38 = pDst;
#line 372
                pDst ++;
#line 372
                *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 372
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (11 - remaining)) - 1U));
#line 372
                if (11 >= remaining + 8) {
#line 372
                  __cil_tmp39 = pDst;
#line 372
                  pDst ++;
#line 372
                  *__cil_tmp39 = (OPJ_BYTE )(trailing >> (11 - (remaining + 8)));
#line 372
                  trailing &= (unsigned int )((1U << (11 - (remaining + 8))) - 1U);
#line 372
                  remaining += 5;
                } else {
#line 372
                  remaining += -3;
                }
              }
            }
          }
        }
      }
    }
#line 379
    if (remaining != 8) {
#line 379
      trailing <<= remaining;
#line 379
      __cil_tmp40 = pDst;
#line 379
      pDst ++;
#line 379
      *__cil_tmp40 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 382 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto12u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_UINT32 src0___0 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;

  {
#line 386
  i = (OPJ_SIZE_T )0;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 386
      goto while_break;
    }
#line 387
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 388
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 390
    __cil_tmp7 = pDst;
#line 390
    pDst ++;
#line 390
    *__cil_tmp7 = (OPJ_BYTE )(src0 >> 4);
#line 391
    __cil_tmp8 = pDst;
#line 391
    pDst ++;
#line 391
    *__cil_tmp8 = (OPJ_BYTE )(((src0 & 15U) << 4) | (src1 >> 8));
#line 392
    __cil_tmp9 = pDst;
#line 392
    pDst ++;
#line 392
    *__cil_tmp9 = (OPJ_BYTE )src1;
#line 386
    i += (unsigned long )2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  if (length & 1UL) {
#line 396
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 397
    __cil_tmp11 = pDst;
#line 397
    pDst ++;
#line 397
    *__cil_tmp11 = (OPJ_BYTE )(src0___0 >> 4);
#line 398
    __cil_tmp12 = pDst;
#line 398
    pDst ++;
#line 398
    *__cil_tmp12 = (OPJ_BYTE )((src0___0 & 15U) << 4);
  }
  return;
}
}
#line 401 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto13u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_BYTE *__cil_tmp29 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  OPJ_BYTE *__cil_tmp41 ;
  OPJ_BYTE *__cil_tmp42 ;

  {
#line 406
  i = (OPJ_SIZE_T )0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 406
      goto while_break;
    }
#line 407
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 408
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 409
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 410
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 411
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 412
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 413
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 414
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 416
    __cil_tmp13 = pDst;
#line 416
    pDst ++;
#line 416
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 5);
#line 417
    __cil_tmp14 = pDst;
#line 417
    pDst ++;
#line 417
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 3) | (src1 >> 10));
#line 418
    __cil_tmp15 = pDst;
#line 418
    pDst ++;
#line 418
    *__cil_tmp15 = (OPJ_BYTE )(src1 >> 2);
#line 419
    __cil_tmp16 = pDst;
#line 419
    pDst ++;
#line 419
    *__cil_tmp16 = (OPJ_BYTE )((src1 << 6) | (src2 >> 7));
#line 420
    __cil_tmp17 = pDst;
#line 420
    pDst ++;
#line 420
    *__cil_tmp17 = (OPJ_BYTE )((src2 << 1) | (src3 >> 12));
#line 421
    __cil_tmp18 = pDst;
#line 421
    pDst ++;
#line 421
    *__cil_tmp18 = (OPJ_BYTE )(src3 >> 4);
#line 422
    __cil_tmp19 = pDst;
#line 422
    pDst ++;
#line 422
    *__cil_tmp19 = (OPJ_BYTE )((src3 << 4) | (src4 >> 9));
#line 423
    __cil_tmp20 = pDst;
#line 423
    pDst ++;
#line 423
    *__cil_tmp20 = (OPJ_BYTE )(src4 >> 1);
#line 424
    __cil_tmp21 = pDst;
#line 424
    pDst ++;
#line 424
    *__cil_tmp21 = (OPJ_BYTE )((src4 << 7) | (src5 >> 6));
#line 425
    __cil_tmp22 = pDst;
#line 425
    pDst ++;
#line 425
    *__cil_tmp22 = (OPJ_BYTE )((src5 << 2) | (src6 >> 11));
#line 426
    __cil_tmp23 = pDst;
#line 426
    pDst ++;
#line 426
    *__cil_tmp23 = (OPJ_BYTE )(src6 >> 3);
#line 427
    __cil_tmp24 = pDst;
#line 427
    pDst ++;
#line 427
    *__cil_tmp24 = (OPJ_BYTE )((src6 << 5) | (src7 >> 8));
#line 428
    __cil_tmp25 = pDst;
#line 428
    pDst ++;
#line 428
    *__cil_tmp25 = (OPJ_BYTE )src7;
#line 406
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if (length & 7UL) {
#line 432
    trailing = 0U;
#line 433
    remaining = (int )8U;
#line 434
    length &= (unsigned long )7U;
#line 435
    trailing <<= remaining;
#line 435
    trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (13 - remaining));
#line 435
    __cil_tmp28 = pDst;
#line 435
    pDst ++;
#line 435
    *__cil_tmp28 = (OPJ_BYTE )trailing;
#line 435
    trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (13 - remaining)) - 1U));
#line 435
    if (13 >= remaining + 8) {
#line 435
      __cil_tmp29 = pDst;
#line 435
      pDst ++;
#line 435
      *__cil_tmp29 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 435
      trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 435
      remaining += 3;
    } else {
#line 435
      remaining += -5;
    }
#line 436
    if (length > 1UL) {
#line 437
      trailing <<= remaining;
#line 437
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (13 - remaining));
#line 437
      __cil_tmp30 = pDst;
#line 437
      pDst ++;
#line 437
      *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 437
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (13 - remaining)) - 1U));
#line 437
      if (13 >= remaining + 8) {
#line 437
        __cil_tmp31 = pDst;
#line 437
        pDst ++;
#line 437
        *__cil_tmp31 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 437
        trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 437
        remaining += 3;
      } else {
#line 437
        remaining += -5;
      }
#line 438
      if (length > 2UL) {
#line 439
        trailing <<= remaining;
#line 439
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (13 - remaining));
#line 439
        __cil_tmp32 = pDst;
#line 439
        pDst ++;
#line 439
        *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 439
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (13 - remaining)) - 1U));
#line 439
        if (13 >= remaining + 8) {
#line 439
          __cil_tmp33 = pDst;
#line 439
          pDst ++;
#line 439
          *__cil_tmp33 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 439
          trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 439
          remaining += 3;
        } else {
#line 439
          remaining += -5;
        }
#line 440
        if (length > 3UL) {
#line 441
          trailing <<= remaining;
#line 441
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (13 - remaining));
#line 441
          __cil_tmp34 = pDst;
#line 441
          pDst ++;
#line 441
          *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 441
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (13 - remaining)) - 1U));
#line 441
          if (13 >= remaining + 8) {
#line 441
            __cil_tmp35 = pDst;
#line 441
            pDst ++;
#line 441
            *__cil_tmp35 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 441
            trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 441
            remaining += 3;
          } else {
#line 441
            remaining += -5;
          }
#line 442
          if (length > 4UL) {
#line 443
            trailing <<= remaining;
#line 443
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (13 - remaining));
#line 443
            __cil_tmp36 = pDst;
#line 443
            pDst ++;
#line 443
            *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 443
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (13 - remaining)) - 1U));
#line 443
            if (13 >= remaining + 8) {
#line 443
              __cil_tmp37 = pDst;
#line 443
              pDst ++;
#line 443
              *__cil_tmp37 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 443
              trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 443
              remaining += 3;
            } else {
#line 443
              remaining += -5;
            }
#line 444
            if (length > 5UL) {
#line 445
              trailing <<= remaining;
#line 445
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (13 - remaining));
#line 445
              __cil_tmp38 = pDst;
#line 445
              pDst ++;
#line 445
              *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 445
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (13 - remaining)) - 1U));
#line 445
              if (13 >= remaining + 8) {
#line 445
                __cil_tmp39 = pDst;
#line 445
                pDst ++;
#line 445
                *__cil_tmp39 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 445
                trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 445
                remaining += 3;
              } else {
#line 445
                remaining += -5;
              }
#line 446
              if (length > 6UL) {
#line 447
                trailing <<= remaining;
#line 447
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (13 - remaining));
#line 447
                __cil_tmp40 = pDst;
#line 447
                pDst ++;
#line 447
                *__cil_tmp40 = (OPJ_BYTE )trailing;
#line 447
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (13 - remaining)) - 1U));
#line 447
                if (13 >= remaining + 8) {
#line 447
                  __cil_tmp41 = pDst;
#line 447
                  pDst ++;
#line 447
                  *__cil_tmp41 = (OPJ_BYTE )(trailing >> (13 - (remaining + 8)));
#line 447
                  trailing &= (unsigned int )((1U << (13 - (remaining + 8))) - 1U);
#line 447
                  remaining += 3;
                } else {
#line 447
                  remaining += -5;
                }
              }
            }
          }
        }
      }
    }
#line 454
    if (remaining != 8) {
#line 454
      trailing <<= remaining;
#line 454
      __cil_tmp42 = pDst;
#line 454
      pDst ++;
#line 454
      *__cil_tmp42 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 457 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto14u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;

  {
#line 461
  i = (OPJ_SIZE_T )0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 461
      goto while_break;
    }
#line 462
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 463
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 464
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 465
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 467
    __cil_tmp9 = pDst;
#line 467
    pDst ++;
#line 467
    *__cil_tmp9 = (OPJ_BYTE )(src0 >> 6);
#line 468
    __cil_tmp10 = pDst;
#line 468
    pDst ++;
#line 468
    *__cil_tmp10 = (OPJ_BYTE )(((src0 & 63U) << 2) | (src1 >> 12));
#line 469
    __cil_tmp11 = pDst;
#line 469
    pDst ++;
#line 469
    *__cil_tmp11 = (OPJ_BYTE )(src1 >> 4);
#line 470
    __cil_tmp12 = pDst;
#line 470
    pDst ++;
#line 470
    *__cil_tmp12 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 10));
#line 471
    __cil_tmp13 = pDst;
#line 471
    pDst ++;
#line 471
    *__cil_tmp13 = (OPJ_BYTE )(src2 >> 2);
#line 472
    __cil_tmp14 = pDst;
#line 472
    pDst ++;
#line 472
    *__cil_tmp14 = (OPJ_BYTE )(((src2 & 3U) << 6) | (src3 >> 8));
#line 473
    __cil_tmp15 = pDst;
#line 473
    pDst ++;
#line 473
    *__cil_tmp15 = (OPJ_BYTE )src3;
#line 461
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  if (length & 3UL) {
#line 477
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 478
    src1___0 = 0U;
#line 479
    src2___0 = 0U;
#line 480
    length &= 3UL;
#line 482
    if (length > 1UL) {
#line 483
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 484
      if (length > 2UL) {
#line 485
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 488
    __cil_tmp19 = pDst;
#line 488
    pDst ++;
#line 488
    *__cil_tmp19 = (OPJ_BYTE )(src0___0 >> 6);
#line 489
    __cil_tmp20 = pDst;
#line 489
    pDst ++;
#line 489
    *__cil_tmp20 = (OPJ_BYTE )(((src0___0 & 63U) << 2) | (src1___0 >> 12));
#line 490
    if (length > 1UL) {
#line 491
      __cil_tmp21 = pDst;
#line 491
      pDst ++;
#line 491
      *__cil_tmp21 = (OPJ_BYTE )(src1___0 >> 4);
#line 492
      __cil_tmp22 = pDst;
#line 492
      pDst ++;
#line 492
      *__cil_tmp22 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 10));
#line 493
      if (length > 2UL) {
#line 494
        __cil_tmp23 = pDst;
#line 494
        pDst ++;
#line 494
        *__cil_tmp23 = (OPJ_BYTE )(src2___0 >> 2);
#line 495
        __cil_tmp24 = pDst;
#line 495
        pDst ++;
#line 495
        *__cil_tmp24 = (OPJ_BYTE )((src2___0 & 3U) << 6);
      }
    }
  }
  return;
}
}
#line 500 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto15u(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_BYTE *__cil_tmp21 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_BYTE *__cil_tmp25 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_BYTE *__cil_tmp27 ;
  unsigned int trailing ;
  int remaining ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_BYTE *__cil_tmp33 ;
  OPJ_BYTE *__cil_tmp34 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  OPJ_BYTE *__cil_tmp37 ;
  OPJ_BYTE *__cil_tmp38 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  OPJ_BYTE *__cil_tmp41 ;
  OPJ_BYTE *__cil_tmp42 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;

  {
#line 505
  i = (OPJ_SIZE_T )0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 505
      goto while_break;
    }
#line 506
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 507
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 508
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 509
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 510
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 511
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 512
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 513
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 515
    __cil_tmp13 = pDst;
#line 515
    pDst ++;
#line 515
    *__cil_tmp13 = (OPJ_BYTE )(src0 >> 7);
#line 516
    __cil_tmp14 = pDst;
#line 516
    pDst ++;
#line 516
    *__cil_tmp14 = (OPJ_BYTE )((src0 << 1) | (src1 >> 14));
#line 517
    __cil_tmp15 = pDst;
#line 517
    pDst ++;
#line 517
    *__cil_tmp15 = (OPJ_BYTE )(src1 >> 6);
#line 518
    __cil_tmp16 = pDst;
#line 518
    pDst ++;
#line 518
    *__cil_tmp16 = (OPJ_BYTE )((src1 << 2) | (src2 >> 13));
#line 519
    __cil_tmp17 = pDst;
#line 519
    pDst ++;
#line 519
    *__cil_tmp17 = (OPJ_BYTE )(src2 >> 5);
#line 520
    __cil_tmp18 = pDst;
#line 520
    pDst ++;
#line 520
    *__cil_tmp18 = (OPJ_BYTE )((src2 << 3) | (src3 >> 12));
#line 521
    __cil_tmp19 = pDst;
#line 521
    pDst ++;
#line 521
    *__cil_tmp19 = (OPJ_BYTE )(src3 >> 4);
#line 522
    __cil_tmp20 = pDst;
#line 522
    pDst ++;
#line 522
    *__cil_tmp20 = (OPJ_BYTE )((src3 << 4) | (src4 >> 11));
#line 523
    __cil_tmp21 = pDst;
#line 523
    pDst ++;
#line 523
    *__cil_tmp21 = (OPJ_BYTE )(src4 >> 3);
#line 524
    __cil_tmp22 = pDst;
#line 524
    pDst ++;
#line 524
    *__cil_tmp22 = (OPJ_BYTE )((src4 << 5) | (src5 >> 10));
#line 525
    __cil_tmp23 = pDst;
#line 525
    pDst ++;
#line 525
    *__cil_tmp23 = (OPJ_BYTE )(src5 >> 2);
#line 526
    __cil_tmp24 = pDst;
#line 526
    pDst ++;
#line 526
    *__cil_tmp24 = (OPJ_BYTE )((src5 << 6) | (src6 >> 9));
#line 527
    __cil_tmp25 = pDst;
#line 527
    pDst ++;
#line 527
    *__cil_tmp25 = (OPJ_BYTE )(src6 >> 1);
#line 528
    __cil_tmp26 = pDst;
#line 528
    pDst ++;
#line 528
    *__cil_tmp26 = (OPJ_BYTE )((src6 << 7) | (src7 >> 8));
#line 529
    __cil_tmp27 = pDst;
#line 529
    pDst ++;
#line 529
    *__cil_tmp27 = (OPJ_BYTE )src7;
#line 505
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  if (length & 7UL) {
#line 533
    trailing = 0U;
#line 534
    remaining = (int )8U;
#line 535
    length &= (unsigned long )7U;
#line 536
    trailing <<= remaining;
#line 536
    trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + i) >> (15 - remaining));
#line 536
    __cil_tmp30 = pDst;
#line 536
    pDst ++;
#line 536
    *__cil_tmp30 = (OPJ_BYTE )trailing;
#line 536
    trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + i) & ((1U << (15 - remaining)) - 1U));
#line 536
    if (15 >= remaining + 8) {
#line 536
      __cil_tmp31 = pDst;
#line 536
      pDst ++;
#line 536
      *__cil_tmp31 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 536
      trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 536
      remaining ++;
    } else {
#line 536
      remaining += -7;
    }
#line 537
    if (length > 1UL) {
#line 538
      trailing <<= remaining;
#line 538
      trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) >> (15 - remaining));
#line 538
      __cil_tmp32 = pDst;
#line 538
      pDst ++;
#line 538
      *__cil_tmp32 = (OPJ_BYTE )trailing;
#line 538
      trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 1UL)) & ((1U << (15 - remaining)) - 1U));
#line 538
      if (15 >= remaining + 8) {
#line 538
        __cil_tmp33 = pDst;
#line 538
        pDst ++;
#line 538
        *__cil_tmp33 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 538
        trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 538
        remaining ++;
      } else {
#line 538
        remaining += -7;
      }
#line 539
      if (length > 2UL) {
#line 540
        trailing <<= remaining;
#line 540
        trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) >> (15 - remaining));
#line 540
        __cil_tmp34 = pDst;
#line 540
        pDst ++;
#line 540
        *__cil_tmp34 = (OPJ_BYTE )trailing;
#line 540
        trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 2UL)) & ((1U << (15 - remaining)) - 1U));
#line 540
        if (15 >= remaining + 8) {
#line 540
          __cil_tmp35 = pDst;
#line 540
          pDst ++;
#line 540
          *__cil_tmp35 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 540
          trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 540
          remaining ++;
        } else {
#line 540
          remaining += -7;
        }
#line 541
        if (length > 3UL) {
#line 542
          trailing <<= remaining;
#line 542
          trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) >> (15 - remaining));
#line 542
          __cil_tmp36 = pDst;
#line 542
          pDst ++;
#line 542
          *__cil_tmp36 = (OPJ_BYTE )trailing;
#line 542
          trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 3UL)) & ((1U << (15 - remaining)) - 1U));
#line 542
          if (15 >= remaining + 8) {
#line 542
            __cil_tmp37 = pDst;
#line 542
            pDst ++;
#line 542
            *__cil_tmp37 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 542
            trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 542
            remaining ++;
          } else {
#line 542
            remaining += -7;
          }
#line 543
          if (length > 4UL) {
#line 544
            trailing <<= remaining;
#line 544
            trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) >> (15 - remaining));
#line 544
            __cil_tmp38 = pDst;
#line 544
            pDst ++;
#line 544
            *__cil_tmp38 = (OPJ_BYTE )trailing;
#line 544
            trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 4UL)) & ((1U << (15 - remaining)) - 1U));
#line 544
            if (15 >= remaining + 8) {
#line 544
              __cil_tmp39 = pDst;
#line 544
              pDst ++;
#line 544
              *__cil_tmp39 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 544
              trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 544
              remaining ++;
            } else {
#line 544
              remaining += -7;
            }
#line 545
            if (length > 5UL) {
#line 546
              trailing <<= remaining;
#line 546
              trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) >> (15 - remaining));
#line 546
              __cil_tmp40 = pDst;
#line 546
              pDst ++;
#line 546
              *__cil_tmp40 = (OPJ_BYTE )trailing;
#line 546
              trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 5UL)) & ((1U << (15 - remaining)) - 1U));
#line 546
              if (15 >= remaining + 8) {
#line 546
                __cil_tmp41 = pDst;
#line 546
                pDst ++;
#line 546
                *__cil_tmp41 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 546
                trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 546
                remaining ++;
              } else {
#line 546
                remaining += -7;
              }
#line 547
              if (length > 6UL) {
#line 548
                trailing <<= remaining;
#line 548
                trailing |= (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) >> (15 - remaining));
#line 548
                __cil_tmp42 = pDst;
#line 548
                pDst ++;
#line 548
                *__cil_tmp42 = (OPJ_BYTE )trailing;
#line 548
                trailing = (unsigned int )((OPJ_UINT32 )*(pSrc + (i + 6UL)) & ((1U << (15 - remaining)) - 1U));
#line 548
                if (15 >= remaining + 8) {
#line 548
                  __cil_tmp43 = pDst;
#line 548
                  pDst ++;
#line 548
                  *__cil_tmp43 = (OPJ_BYTE )(trailing >> (15 - (remaining + 8)));
#line 548
                  trailing &= (unsigned int )((1U << (15 - (remaining + 8))) - 1U);
#line 548
                  remaining ++;
                } else {
#line 548
                  remaining += -7;
                }
              }
            }
          }
        }
      }
    }
#line 555
    if (remaining != 8) {
#line 555
      trailing <<= remaining;
#line 555
      __cil_tmp44 = pDst;
#line 555
      pDst ++;
#line 555
      *__cil_tmp44 = (OPJ_BYTE )trailing;
    }
  }
  return;
}
}
#line 558 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_32sto16u(OPJ_INT32 *pSrc , OPJ_UINT16 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 562
  i = (OPJ_SIZE_T )0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i < length)) {
#line 562
      goto while_break;
    }
#line 563
    *(pDst + i) = (OPJ_UINT16 )*(pSrc + i);
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 567 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  TIFF *tif ;
  tdata_t buf ;
  uint32_t width ;
  uint32_t height ;
  uint16_t bps ;
  uint16_t tiPhoto ;
  int adjust ;
  int sgnd ;
  int64_t strip_size ;
  int64_t rowStride ;
  int64_t TIFF_MAX ;
  OPJ_UINT32 i ;
  OPJ_UINT32 numcomps ;
  OPJ_INT32 *buffer32s ;
  OPJ_INT32 *planes[4] ;
  convert_32s_PXCX cvtPxToCx ;
  convert_32sXXx_C1R cvt32sToTif ;
  TIFF *__cil_tmp20 ;
  int tmp ;
  tmsize_t __cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
#line 576
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 578
  cvtPxToCx = (convert_32s_PXCX )((void *)0);
#line 579
  cvt32sToTif = (convert_32sXXx_C1R )((void *)0);
#line 581
  bps = (uint16_t )(image->comps + 0)->prec;
#line 582
  planes[0] = (image->comps + 0)->data;
#line 584
  numcomps = image->numcomps;
#line 586
  if ((int )image->color_space == 5) {
#line 587
    if (numcomps < 4U) {
      {
#line 588
      fprintf(stderr, "imagetotif: CMYK images shall be composed of at least 4 planes.\n\220");
#line 590
      fprintf(stderr, "\tAborting\n");
      }
#line 591
      return (1);
    }
#line 593
    tiPhoto = (uint16_t )5;
#line 594
    if (numcomps > 4U) {
#line 595
      numcomps = 4U;
    }
  } else
#line 597
  if (numcomps > 2U) {
#line 598
    tiPhoto = (uint16_t )2;
#line 599
    if (numcomps > 4U) {
#line 600
      numcomps = 4U;
    }
  } else {
#line 603
    tiPhoto = (uint16_t )1;
  }
#line 605
  i = 1U;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < numcomps)) {
#line 605
      goto while_break;
    }
#line 606
    if ((image->comps + 0)->dx != (image->comps + i)->dx) {
#line 607
      goto while_break;
    }
#line 609
    if ((image->comps + 0)->dy != (image->comps + i)->dy) {
#line 610
      goto while_break;
    }
#line 612
    if ((image->comps + 0)->prec != (image->comps + i)->prec) {
#line 613
      goto while_break;
    }
#line 615
    if ((image->comps + 0)->sgnd != (image->comps + i)->sgnd) {
#line 616
      goto while_break;
    }
#line 618
    planes[i] = (image->comps + i)->data;
#line 619
    if (planes[i] == (void *)0) {
      {
#line 620
      fprintf(stderr, "imagetotif: planes[%d] == NULL.\n\230\001", i);
#line 622
      fprintf(stderr, "\tAborting\n");
      }
#line 623
      return (1);
    }
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 626
  if (i != numcomps) {
    {
#line 627
    fprintf(stderr, "imagetotif: All components shall have the same subsampling, same bit depth.\n");
#line 629
    fprintf(stderr, "\tAborting\n");
    }
#line 630
    return (1);
  }
#line 633
  if ((int )bps > 16) {
#line 634
    bps = (uint16_t )0;
  }
#line 636
  if ((int )bps == 0) {
    {
#line 637
    fprintf(stderr, "imagetotif: Bits=%d, Only 1 to 16 bits implemented\n", (int )bps);
#line 638
    fprintf(stderr, "\tAborting\n");
    }
#line 639
    return (1);
  }
  {
#line 641
  tif = TIFFOpen(outfile, "wb");
  }
#line 642
  if (! tif) {
    {
#line 643
    fprintf(stderr, "imagetotif:failed to open %s for writing\n", outfile);
    }
#line 644
    return (1);
  }
#line 646
  i = 0U;
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 646
    if (! (i < numcomps)) {
#line 646
      goto while_break___0;
    }
    {
#line 647
    clip_component(image->comps + i, (image->comps + 0)->prec);
    }
#line 646
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 649
  cvtPxToCx = convert_32s_PXCX_LUT[numcomps];
  {
#line 655
  if ((int )bps == 8) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 6) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 4) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 2) {
#line 655
    goto case_8;
  }
#line 655
  if ((int )bps == 1) {
#line 655
    goto case_8;
  }
#line 658
  if ((int )bps == 3) {
#line 658
    goto case_3;
  }
#line 661
  if ((int )bps == 5) {
#line 661
    goto case_5;
  }
#line 664
  if ((int )bps == 7) {
#line 664
    goto case_7;
  }
#line 667
  if ((int )bps == 9) {
#line 667
    goto case_9;
  }
#line 670
  if ((int )bps == 10) {
#line 670
    goto case_10;
  }
#line 673
  if ((int )bps == 11) {
#line 673
    goto case_11;
  }
#line 676
  if ((int )bps == 12) {
#line 676
    goto case_12;
  }
#line 679
  if ((int )bps == 13) {
#line 679
    goto case_13;
  }
#line 682
  if ((int )bps == 14) {
#line 682
    goto case_14;
  }
#line 685
  if ((int )bps == 15) {
#line 685
    goto case_15;
  }
#line 688
  if ((int )bps == 16) {
#line 688
    goto case_16;
  }
#line 691
  goto switch_default;
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 656
  cvt32sToTif = convert_32sXXu_C1R_LUT[bps];
#line 657
  goto switch_break;
  case_3: /* CIL Label */ 
#line 659
  cvt32sToTif = & tif_32sto3u;
#line 660
  goto switch_break;
  case_5: /* CIL Label */ 
#line 662
  cvt32sToTif = & tif_32sto5u;
#line 663
  goto switch_break;
  case_7: /* CIL Label */ 
#line 665
  cvt32sToTif = & tif_32sto7u;
#line 666
  goto switch_break;
  case_9: /* CIL Label */ 
#line 668
  cvt32sToTif = & tif_32sto9u;
#line 669
  goto switch_break;
  case_10: /* CIL Label */ 
#line 671
  cvt32sToTif = & tif_32sto10u;
#line 672
  goto switch_break;
  case_11: /* CIL Label */ 
#line 674
  cvt32sToTif = & tif_32sto11u;
#line 675
  goto switch_break;
  case_12: /* CIL Label */ 
#line 677
  cvt32sToTif = & tif_32sto12u;
#line 678
  goto switch_break;
  case_13: /* CIL Label */ 
#line 680
  cvt32sToTif = & tif_32sto13u;
#line 681
  goto switch_break;
  case_14: /* CIL Label */ 
#line 683
  cvt32sToTif = & tif_32sto14u;
#line 684
  goto switch_break;
  case_15: /* CIL Label */ 
#line 686
  cvt32sToTif = & tif_32sto15u;
#line 687
  goto switch_break;
  case_16: /* CIL Label */ 
#line 689
  cvt32sToTif = (convert_32sXXx_C1R )(& tif_32sto16u);
#line 690
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 693
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 695
  sgnd = (int )(image->comps + 0)->sgnd;
#line 696
  if (sgnd) {
#line 696
    tmp = (int )(1 << ((image->comps + 0)->prec - 1U));
  } else {
#line 696
    tmp = 0;
  }
  {
#line 696
  adjust = tmp;
#line 697
  width = (uint32_t )(image->comps + 0)->w;
#line 698
  height = (uint32_t )(image->comps + 0)->h;
#line 700
  TIFFSetField(tif, (uint32 )256, width);
#line 701
  TIFFSetField(tif, (uint32 )257, height);
#line 702
  TIFFSetField(tif, (uint32 )277, (int )((uint16_t )numcomps));
#line 703
  TIFFSetField(tif, (uint32 )258, (int )bps);
#line 704
  TIFFSetField(tif, (uint32 )274, 1);
#line 705
  TIFFSetField(tif, (uint32 )284, 1);
#line 706
  TIFFSetField(tif, (uint32 )262, (int )tiPhoto);
#line 707
  TIFFSetField(tif, (uint32 )278, 1);
  }
#line 708
  if (sizeof(tsize_t ) == 4UL) {
#line 709
    TIFF_MAX = (int64_t )2147483647;
  } else {
#line 711
    TIFF_MAX = (int64_t )4294967295U;
  }
  {
#line 713
  __cil_tmp22 = TIFFStripSize(tif);
#line 713
  strip_size = (int64_t )__cil_tmp22;
  }
#line 715
  if ((int64_t )width > (int64_t )(TIFF_MAX / (long )numcomps)) {
    {
    {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 720
    TIFFClose(tif);
    }
    }
    }
#line 721
    return (1);
  } else
#line 715
  if ((int64_t )(width * numcomps) > (int64_t )(TIFF_MAX / (long )bps)) {
    {
    {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 720
    TIFFClose(tif);
    }
    }
    }
#line 721
    return (1);
  } else
#line 715
  if ((int64_t )(width * numcomps) > (int64_t )(TIFF_MAX / (int64_t )sizeof(OPJ_INT32 ))) {
    {
    {
    {
#line 719
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 720
    TIFFClose(tif);
    }
    }
    }
#line 721
    return (1);
  }
#line 723
  rowStride = (int64_t )(((width * numcomps) * (unsigned int )bps + 7U) / 8U);
#line 724
  if (rowStride != strip_size) {
    {
#line 725
    fprintf(stderr, "Invalid TIFF strip size\n\220");
#line 726
    TIFFClose(tif);
    }
#line 727
    return (1);
  }
  {
#line 729
  buf = malloc((OPJ_SIZE_T )strip_size);
  }
#line 730
  if (buf == (void *)0) {
    {
#line 731
    TIFFClose(tif);
    }
#line 732
    return (1);
  }
  {
#line 734
  __cil_tmp24 = malloc((sizeof(OPJ_INT32 ) * (unsigned long )width) * (unsigned long )numcomps);
#line 734
  buffer32s = (OPJ_INT32 *)__cil_tmp24;
  }
#line 735
  if (buffer32s == (void *)0) {
    {
#line 736
    _TIFFfree(buf);
#line 737
    TIFFClose(tif);
    }
#line 738
    return (1);
  }
#line 741
  i = (OPJ_UINT32 )0;
  {
#line 741
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 741
    if (! (i < (image->comps + 0)->h)) {
#line 741
      goto while_break___1;
    }
    {
#line 742
    (*cvtPxToCx)((OPJ_INT32 * const  *)((OPJ_INT32 **)planes), buffer32s, (OPJ_SIZE_T )width,
                 adjust);
#line 743
    (*cvt32sToTif)(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T )width * (unsigned long )numcomps);
#line 744
    TIFFWriteEncodedStrip(tif, i, (void *)buf, (tsize_t )strip_size);
#line 745
    planes[0] += width;
#line 746
    planes[1] += width;
#line 747
    planes[2] += width;
#line 748
    planes[3] += width;
    }
#line 741
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 750
  _TIFFfree((void *)buf);
#line 751
  TIFFClose(tif);
#line 752
  free(buffer32s);
  }
#line 754
  return (0);
}
}
#line 776 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_3uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;

  {
#line 780
  i = (OPJ_SIZE_T )0;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 780
      goto while_break;
    }
#line 781
    __cil_tmp6 = pSrc;
#line 781
    pSrc ++;
#line 781
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 782
    __cil_tmp8 = pSrc;
#line 782
    pSrc ++;
#line 782
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 783
    __cil_tmp10 = pSrc;
#line 783
    pSrc ++;
#line 783
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 785
    *(pDst + i) = (OPJ_INT32 )(val0 >> 5);
#line 786
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val0 & 31U) >> 2);
#line 787
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val0 & 3U) << 1) | (val1 >> 7));
#line 788
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((val1 & 127U) >> 4);
#line 789
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((val1 & 15U) >> 1);
#line 790
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val1 & 1U) << 2) | (val2 >> 6));
#line 791
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((val2 & 63U) >> 3);
#line 792
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val2 & 7U);
#line 780
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  if (length & 7UL) {
#line 797
    available = 0;
#line 799
    length &= 7UL;
#line 801
    needed = 3;
#line 801
    dst = 0U;
#line 801
    if (available == 0) {
#line 801
      __cil_tmp15 = pSrc;
#line 801
      pSrc ++;
#line 801
      val = (unsigned int )*__cil_tmp15;
#line 801
      available = 8;
    }
    {
#line 801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 801
      if (! (needed > available)) {
#line 801
        goto while_break___0;
      }
#line 801
      dst |= val & ((1U << available) - 1U);
#line 801
      needed -= available;
#line 801
      dst <<= needed;
#line 801
      __cil_tmp16 = pSrc;
#line 801
      pSrc ++;
#line 801
      val = (unsigned int )*__cil_tmp16;
#line 801
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 801
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 801
    available -= needed;
#line 801
    *(pDst + i) = (OPJ_INT32 )dst;
#line 803
    if (length > 1UL) {
#line 804
      needed___0 = 3;
#line 804
      dst___0 = 0U;
#line 804
      if (available == 0) {
#line 804
        __cil_tmp19 = pSrc;
#line 804
        pSrc ++;
#line 804
        val = (unsigned int )*__cil_tmp19;
#line 804
        available = 8;
      }
      {
#line 804
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 804
        if (! (needed___0 > available)) {
#line 804
          goto while_break___1;
        }
#line 804
        dst___0 |= val & ((1U << available) - 1U);
#line 804
        needed___0 -= available;
#line 804
        dst___0 <<= needed___0;
#line 804
        __cil_tmp20 = pSrc;
#line 804
        pSrc ++;
#line 804
        val = (unsigned int )*__cil_tmp20;
#line 804
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 804
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 804
      available -= needed___0;
#line 804
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 805
      if (length > 2UL) {
#line 806
        needed___1 = 3;
#line 806
        dst___1 = 0U;
#line 806
        if (available == 0) {
#line 806
          __cil_tmp23 = pSrc;
#line 806
          pSrc ++;
#line 806
          val = (unsigned int )*__cil_tmp23;
#line 806
          available = 8;
        }
        {
#line 806
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 806
          if (! (needed___1 > available)) {
#line 806
            goto while_break___2;
          }
#line 806
          dst___1 |= val & ((1U << available) - 1U);
#line 806
          needed___1 -= available;
#line 806
          dst___1 <<= needed___1;
#line 806
          __cil_tmp24 = pSrc;
#line 806
          pSrc ++;
#line 806
          val = (unsigned int )*__cil_tmp24;
#line 806
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 806
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 806
        available -= needed___1;
#line 806
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 807
        if (length > 3UL) {
#line 808
          needed___2 = 3;
#line 808
          dst___2 = 0U;
#line 808
          if (available == 0) {
#line 808
            __cil_tmp27 = pSrc;
#line 808
            pSrc ++;
#line 808
            val = (unsigned int )*__cil_tmp27;
#line 808
            available = 8;
          }
          {
#line 808
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 808
            if (! (needed___2 > available)) {
#line 808
              goto while_break___3;
            }
#line 808
            dst___2 |= val & ((1U << available) - 1U);
#line 808
            needed___2 -= available;
#line 808
            dst___2 <<= needed___2;
#line 808
            __cil_tmp28 = pSrc;
#line 808
            pSrc ++;
#line 808
            val = (unsigned int )*__cil_tmp28;
#line 808
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 808
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 808
          available -= needed___2;
#line 808
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 809
          if (length > 4UL) {
#line 810
            needed___3 = 3;
#line 810
            dst___3 = 0U;
#line 810
            if (available == 0) {
#line 810
              __cil_tmp31 = pSrc;
#line 810
              pSrc ++;
#line 810
              val = (unsigned int )*__cil_tmp31;
#line 810
              available = 8;
            }
            {
#line 810
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 810
              if (! (needed___3 > available)) {
#line 810
                goto while_break___4;
              }
#line 810
              dst___3 |= val & ((1U << available) - 1U);
#line 810
              needed___3 -= available;
#line 810
              dst___3 <<= needed___3;
#line 810
              __cil_tmp32 = pSrc;
#line 810
              pSrc ++;
#line 810
              val = (unsigned int )*__cil_tmp32;
#line 810
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 810
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 810
            available -= needed___3;
#line 810
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 811
            if (length > 5UL) {
#line 812
              needed___4 = 3;
#line 812
              dst___4 = 0U;
#line 812
              if (available == 0) {
#line 812
                __cil_tmp35 = pSrc;
#line 812
                pSrc ++;
#line 812
                val = (unsigned int )*__cil_tmp35;
#line 812
                available = 8;
              }
              {
#line 812
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 812
                if (! (needed___4 > available)) {
#line 812
                  goto while_break___5;
                }
#line 812
                dst___4 |= val & ((1U << available) - 1U);
#line 812
                needed___4 -= available;
#line 812
                dst___4 <<= needed___4;
#line 812
                __cil_tmp36 = pSrc;
#line 812
                pSrc ++;
#line 812
                val = (unsigned int )*__cil_tmp36;
#line 812
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 812
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 812
              available -= needed___4;
#line 812
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 813
              if (length > 6UL) {
#line 814
                needed___5 = 3;
#line 814
                dst___5 = 0U;
#line 814
                if (available == 0) {
#line 814
                  __cil_tmp39 = pSrc;
#line 814
                  pSrc ++;
#line 814
                  val = (unsigned int )*__cil_tmp39;
#line 814
                  available = 8;
                }
                {
#line 814
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 814
                  if (! (needed___5 > available)) {
#line 814
                    goto while_break___6;
                  }
#line 814
                  dst___5 |= val & ((1U << available) - 1U);
#line 814
                  needed___5 -= available;
#line 814
                  dst___5 <<= needed___5;
#line 814
                  __cil_tmp40 = pSrc;
#line 814
                  pSrc ++;
#line 814
                  val = (unsigned int )*__cil_tmp40;
#line 814
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 814
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 814
                available -= needed___5;
#line 814
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 823 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_5uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp19 ;
  OPJ_BYTE *__cil_tmp20 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;

  {
#line 827
  i = (OPJ_SIZE_T )0;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 827
      goto while_break;
    }
#line 828
    __cil_tmp6 = pSrc;
#line 828
    pSrc ++;
#line 828
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 829
    __cil_tmp8 = pSrc;
#line 829
    pSrc ++;
#line 829
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 830
    __cil_tmp10 = pSrc;
#line 830
    pSrc ++;
#line 830
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 831
    __cil_tmp12 = pSrc;
#line 831
    pSrc ++;
#line 831
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 832
    __cil_tmp14 = pSrc;
#line 832
    pSrc ++;
#line 832
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 834
    *(pDst + i) = (OPJ_INT32 )(val0 >> 3);
#line 835
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 7U) << 2) | (val1 >> 6));
#line 836
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val1 & 63U) >> 1);
#line 837
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val1 & 1U) << 4) | (val2 >> 4));
#line 838
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val2 & 15U) << 1) | (val3 >> 7));
#line 839
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((val3 & 127U) >> 2);
#line 840
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val3 & 3U) << 3) | (val4 >> 5));
#line 841
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val4 & 31U);
#line 827
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 844
  if (length & 7UL) {
#line 846
    available = 0;
#line 848
    length &= 7UL;
#line 850
    needed = 5;
#line 850
    dst = 0U;
#line 850
    if (available == 0) {
#line 850
      __cil_tmp19 = pSrc;
#line 850
      pSrc ++;
#line 850
      val = (unsigned int )*__cil_tmp19;
#line 850
      available = 8;
    }
    {
#line 850
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 850
      if (! (needed > available)) {
#line 850
        goto while_break___0;
      }
#line 850
      dst |= val & ((1U << available) - 1U);
#line 850
      needed -= available;
#line 850
      dst <<= needed;
#line 850
      __cil_tmp20 = pSrc;
#line 850
      pSrc ++;
#line 850
      val = (unsigned int )*__cil_tmp20;
#line 850
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 850
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 850
    available -= needed;
#line 850
    *(pDst + i) = (OPJ_INT32 )dst;
#line 852
    if (length > 1UL) {
#line 853
      needed___0 = 5;
#line 853
      dst___0 = 0U;
#line 853
      if (available == 0) {
#line 853
        __cil_tmp23 = pSrc;
#line 853
        pSrc ++;
#line 853
        val = (unsigned int )*__cil_tmp23;
#line 853
        available = 8;
      }
      {
#line 853
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 853
        if (! (needed___0 > available)) {
#line 853
          goto while_break___1;
        }
#line 853
        dst___0 |= val & ((1U << available) - 1U);
#line 853
        needed___0 -= available;
#line 853
        dst___0 <<= needed___0;
#line 853
        __cil_tmp24 = pSrc;
#line 853
        pSrc ++;
#line 853
        val = (unsigned int )*__cil_tmp24;
#line 853
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 853
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 853
      available -= needed___0;
#line 853
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 854
      if (length > 2UL) {
#line 855
        needed___1 = 5;
#line 855
        dst___1 = 0U;
#line 855
        if (available == 0) {
#line 855
          __cil_tmp27 = pSrc;
#line 855
          pSrc ++;
#line 855
          val = (unsigned int )*__cil_tmp27;
#line 855
          available = 8;
        }
        {
#line 855
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 855
          if (! (needed___1 > available)) {
#line 855
            goto while_break___2;
          }
#line 855
          dst___1 |= val & ((1U << available) - 1U);
#line 855
          needed___1 -= available;
#line 855
          dst___1 <<= needed___1;
#line 855
          __cil_tmp28 = pSrc;
#line 855
          pSrc ++;
#line 855
          val = (unsigned int )*__cil_tmp28;
#line 855
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 855
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 855
        available -= needed___1;
#line 855
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 856
        if (length > 3UL) {
#line 857
          needed___2 = 5;
#line 857
          dst___2 = 0U;
#line 857
          if (available == 0) {
#line 857
            __cil_tmp31 = pSrc;
#line 857
            pSrc ++;
#line 857
            val = (unsigned int )*__cil_tmp31;
#line 857
            available = 8;
          }
          {
#line 857
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 857
            if (! (needed___2 > available)) {
#line 857
              goto while_break___3;
            }
#line 857
            dst___2 |= val & ((1U << available) - 1U);
#line 857
            needed___2 -= available;
#line 857
            dst___2 <<= needed___2;
#line 857
            __cil_tmp32 = pSrc;
#line 857
            pSrc ++;
#line 857
            val = (unsigned int )*__cil_tmp32;
#line 857
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 857
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 857
          available -= needed___2;
#line 857
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 858
          if (length > 4UL) {
#line 859
            needed___3 = 5;
#line 859
            dst___3 = 0U;
#line 859
            if (available == 0) {
#line 859
              __cil_tmp35 = pSrc;
#line 859
              pSrc ++;
#line 859
              val = (unsigned int )*__cil_tmp35;
#line 859
              available = 8;
            }
            {
#line 859
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 859
              if (! (needed___3 > available)) {
#line 859
                goto while_break___4;
              }
#line 859
              dst___3 |= val & ((1U << available) - 1U);
#line 859
              needed___3 -= available;
#line 859
              dst___3 <<= needed___3;
#line 859
              __cil_tmp36 = pSrc;
#line 859
              pSrc ++;
#line 859
              val = (unsigned int )*__cil_tmp36;
#line 859
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 859
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 859
            available -= needed___3;
#line 859
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 860
            if (length > 5UL) {
#line 861
              needed___4 = 5;
#line 861
              dst___4 = 0U;
#line 861
              if (available == 0) {
#line 861
                __cil_tmp39 = pSrc;
#line 861
                pSrc ++;
#line 861
                val = (unsigned int )*__cil_tmp39;
#line 861
                available = 8;
              }
              {
#line 861
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 861
                if (! (needed___4 > available)) {
#line 861
                  goto while_break___5;
                }
#line 861
                dst___4 |= val & ((1U << available) - 1U);
#line 861
                needed___4 -= available;
#line 861
                dst___4 <<= needed___4;
#line 861
                __cil_tmp40 = pSrc;
#line 861
                pSrc ++;
#line 861
                val = (unsigned int )*__cil_tmp40;
#line 861
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 861
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 861
              available -= needed___4;
#line 861
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 862
              if (length > 6UL) {
#line 863
                needed___5 = 5;
#line 863
                dst___5 = 0U;
#line 863
                if (available == 0) {
#line 863
                  __cil_tmp43 = pSrc;
#line 863
                  pSrc ++;
#line 863
                  val = (unsigned int )*__cil_tmp43;
#line 863
                  available = 8;
                }
                {
#line 863
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 863
                  if (! (needed___5 > available)) {
#line 863
                    goto while_break___6;
                  }
#line 863
                  dst___5 |= val & ((1U << available) - 1U);
#line 863
                  needed___5 -= available;
#line 863
                  dst___5 <<= needed___5;
#line 863
                  __cil_tmp44 = pSrc;
#line 863
                  pSrc ++;
#line 863
                  val = (unsigned int )*__cil_tmp44;
#line 863
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 863
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 863
                available -= needed___5;
#line 863
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 872 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_7uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp23 ;
  OPJ_BYTE *__cil_tmp24 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;

  {
#line 876
  i = (OPJ_SIZE_T )0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 876
      goto while_break;
    }
#line 877
    __cil_tmp6 = pSrc;
#line 877
    pSrc ++;
#line 877
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 878
    __cil_tmp8 = pSrc;
#line 878
    pSrc ++;
#line 878
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 879
    __cil_tmp10 = pSrc;
#line 879
    pSrc ++;
#line 879
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 880
    __cil_tmp12 = pSrc;
#line 880
    pSrc ++;
#line 880
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 881
    __cil_tmp14 = pSrc;
#line 881
    pSrc ++;
#line 881
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 882
    __cil_tmp16 = pSrc;
#line 882
    pSrc ++;
#line 882
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 883
    __cil_tmp18 = pSrc;
#line 883
    pSrc ++;
#line 883
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 885
    *(pDst + i) = (OPJ_INT32 )(val0 >> 1);
#line 886
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 1U) << 6) | (val1 >> 2));
#line 887
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1 & 3U) << 5) | (val2 >> 3));
#line 888
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val2 & 7U) << 4) | (val3 >> 4));
#line 889
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val3 & 15U) << 3) | (val4 >> 5));
#line 890
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val4 & 31U) << 2) | (val5 >> 6));
#line 891
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val5 & 63U) << 1) | (val6 >> 7));
#line 892
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val6 & 127U);
#line 876
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 895
  if (length & 7UL) {
#line 897
    available = 0;
#line 899
    length &= 7UL;
#line 901
    needed = 7;
#line 901
    dst = 0U;
#line 901
    if (available == 0) {
#line 901
      __cil_tmp23 = pSrc;
#line 901
      pSrc ++;
#line 901
      val = (unsigned int )*__cil_tmp23;
#line 901
      available = 8;
    }
    {
#line 901
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 901
      if (! (needed > available)) {
#line 901
        goto while_break___0;
      }
#line 901
      dst |= val & ((1U << available) - 1U);
#line 901
      needed -= available;
#line 901
      dst <<= needed;
#line 901
      __cil_tmp24 = pSrc;
#line 901
      pSrc ++;
#line 901
      val = (unsigned int )*__cil_tmp24;
#line 901
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 901
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 901
    available -= needed;
#line 901
    *(pDst + i) = (OPJ_INT32 )dst;
#line 903
    if (length > 1UL) {
#line 904
      needed___0 = 7;
#line 904
      dst___0 = 0U;
#line 904
      if (available == 0) {
#line 904
        __cil_tmp27 = pSrc;
#line 904
        pSrc ++;
#line 904
        val = (unsigned int )*__cil_tmp27;
#line 904
        available = 8;
      }
      {
#line 904
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 904
        if (! (needed___0 > available)) {
#line 904
          goto while_break___1;
        }
#line 904
        dst___0 |= val & ((1U << available) - 1U);
#line 904
        needed___0 -= available;
#line 904
        dst___0 <<= needed___0;
#line 904
        __cil_tmp28 = pSrc;
#line 904
        pSrc ++;
#line 904
        val = (unsigned int )*__cil_tmp28;
#line 904
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 904
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 904
      available -= needed___0;
#line 904
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 905
      if (length > 2UL) {
#line 906
        needed___1 = 7;
#line 906
        dst___1 = 0U;
#line 906
        if (available == 0) {
#line 906
          __cil_tmp31 = pSrc;
#line 906
          pSrc ++;
#line 906
          val = (unsigned int )*__cil_tmp31;
#line 906
          available = 8;
        }
        {
#line 906
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 906
          if (! (needed___1 > available)) {
#line 906
            goto while_break___2;
          }
#line 906
          dst___1 |= val & ((1U << available) - 1U);
#line 906
          needed___1 -= available;
#line 906
          dst___1 <<= needed___1;
#line 906
          __cil_tmp32 = pSrc;
#line 906
          pSrc ++;
#line 906
          val = (unsigned int )*__cil_tmp32;
#line 906
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 906
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 906
        available -= needed___1;
#line 906
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 907
        if (length > 3UL) {
#line 908
          needed___2 = 7;
#line 908
          dst___2 = 0U;
#line 908
          if (available == 0) {
#line 908
            __cil_tmp35 = pSrc;
#line 908
            pSrc ++;
#line 908
            val = (unsigned int )*__cil_tmp35;
#line 908
            available = 8;
          }
          {
#line 908
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 908
            if (! (needed___2 > available)) {
#line 908
              goto while_break___3;
            }
#line 908
            dst___2 |= val & ((1U << available) - 1U);
#line 908
            needed___2 -= available;
#line 908
            dst___2 <<= needed___2;
#line 908
            __cil_tmp36 = pSrc;
#line 908
            pSrc ++;
#line 908
            val = (unsigned int )*__cil_tmp36;
#line 908
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 908
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 908
          available -= needed___2;
#line 908
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 909
          if (length > 4UL) {
#line 910
            needed___3 = 7;
#line 910
            dst___3 = 0U;
#line 910
            if (available == 0) {
#line 910
              __cil_tmp39 = pSrc;
#line 910
              pSrc ++;
#line 910
              val = (unsigned int )*__cil_tmp39;
#line 910
              available = 8;
            }
            {
#line 910
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 910
              if (! (needed___3 > available)) {
#line 910
                goto while_break___4;
              }
#line 910
              dst___3 |= val & ((1U << available) - 1U);
#line 910
              needed___3 -= available;
#line 910
              dst___3 <<= needed___3;
#line 910
              __cil_tmp40 = pSrc;
#line 910
              pSrc ++;
#line 910
              val = (unsigned int )*__cil_tmp40;
#line 910
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 910
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 910
            available -= needed___3;
#line 910
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 911
            if (length > 5UL) {
#line 912
              needed___4 = 7;
#line 912
              dst___4 = 0U;
#line 912
              if (available == 0) {
#line 912
                __cil_tmp43 = pSrc;
#line 912
                pSrc ++;
#line 912
                val = (unsigned int )*__cil_tmp43;
#line 912
                available = 8;
              }
              {
#line 912
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 912
                if (! (needed___4 > available)) {
#line 912
                  goto while_break___5;
                }
#line 912
                dst___4 |= val & ((1U << available) - 1U);
#line 912
                needed___4 -= available;
#line 912
                dst___4 <<= needed___4;
#line 912
                __cil_tmp44 = pSrc;
#line 912
                pSrc ++;
#line 912
                val = (unsigned int )*__cil_tmp44;
#line 912
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 912
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 912
              available -= needed___4;
#line 912
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 913
              if (length > 6UL) {
#line 914
                needed___5 = 7;
#line 914
                dst___5 = 0U;
#line 914
                if (available == 0) {
#line 914
                  __cil_tmp47 = pSrc;
#line 914
                  pSrc ++;
#line 914
                  val = (unsigned int )*__cil_tmp47;
#line 914
                  available = 8;
                }
                {
#line 914
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 914
                  if (! (needed___5 > available)) {
#line 914
                    goto while_break___6;
                  }
#line 914
                  dst___5 |= val & ((1U << available) - 1U);
#line 914
                  needed___5 -= available;
#line 914
                  dst___5 <<= needed___5;
#line 914
                  __cil_tmp48 = pSrc;
#line 914
                  pSrc ++;
#line 914
                  val = (unsigned int )*__cil_tmp48;
#line 914
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 914
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 914
                available -= needed___5;
#line 914
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 923 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_9uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp27 ;
  OPJ_BYTE *__cil_tmp28 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;

  {
#line 927
  i = (OPJ_SIZE_T )0;
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 927
      goto while_break;
    }
#line 928
    __cil_tmp6 = pSrc;
#line 928
    pSrc ++;
#line 928
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 929
    __cil_tmp8 = pSrc;
#line 929
    pSrc ++;
#line 929
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 930
    __cil_tmp10 = pSrc;
#line 930
    pSrc ++;
#line 930
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 931
    __cil_tmp12 = pSrc;
#line 931
    pSrc ++;
#line 931
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 932
    __cil_tmp14 = pSrc;
#line 932
    pSrc ++;
#line 932
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 933
    __cil_tmp16 = pSrc;
#line 933
    pSrc ++;
#line 933
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 934
    __cil_tmp18 = pSrc;
#line 934
    pSrc ++;
#line 934
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 935
    __cil_tmp20 = pSrc;
#line 935
    pSrc ++;
#line 935
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 936
    __cil_tmp22 = pSrc;
#line 936
    pSrc ++;
#line 936
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 938
    *(pDst + i) = (OPJ_INT32 )((val0 << 1) | (val1 >> 7));
#line 939
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 127U) << 2) | (val2 >> 6));
#line 940
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2 & 63U) << 3) | (val3 >> 5));
#line 941
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val3 & 31U) << 4) | (val4 >> 4));
#line 942
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val4 & 15U) << 5) | (val5 >> 3));
#line 943
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val5 & 7U) << 6) | (val6 >> 2));
#line 944
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val6 & 3U) << 7) | (val7 >> 1));
#line 945
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val7 & 1U) << 8) | val8);
#line 927
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  if (length & 7UL) {
#line 950
    available = 0;
#line 952
    length &= 7UL;
#line 954
    needed = 9;
#line 954
    dst = 0U;
#line 954
    if (available == 0) {
#line 954
      __cil_tmp27 = pSrc;
#line 954
      pSrc ++;
#line 954
      val = (unsigned int )*__cil_tmp27;
#line 954
      available = 8;
    }
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 954
      if (! (needed > available)) {
#line 954
        goto while_break___0;
      }
#line 954
      dst |= val & ((1U << available) - 1U);
#line 954
      needed -= available;
#line 954
      dst <<= needed;
#line 954
      __cil_tmp28 = pSrc;
#line 954
      pSrc ++;
#line 954
      val = (unsigned int )*__cil_tmp28;
#line 954
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 954
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 954
    available -= needed;
#line 954
    *(pDst + i) = (OPJ_INT32 )dst;
#line 956
    if (length > 1UL) {
#line 957
      needed___0 = 9;
#line 957
      dst___0 = 0U;
#line 957
      if (available == 0) {
#line 957
        __cil_tmp31 = pSrc;
#line 957
        pSrc ++;
#line 957
        val = (unsigned int )*__cil_tmp31;
#line 957
        available = 8;
      }
      {
#line 957
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 957
        if (! (needed___0 > available)) {
#line 957
          goto while_break___1;
        }
#line 957
        dst___0 |= val & ((1U << available) - 1U);
#line 957
        needed___0 -= available;
#line 957
        dst___0 <<= needed___0;
#line 957
        __cil_tmp32 = pSrc;
#line 957
        pSrc ++;
#line 957
        val = (unsigned int )*__cil_tmp32;
#line 957
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 957
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 957
      available -= needed___0;
#line 957
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 958
      if (length > 2UL) {
#line 959
        needed___1 = 9;
#line 959
        dst___1 = 0U;
#line 959
        if (available == 0) {
#line 959
          __cil_tmp35 = pSrc;
#line 959
          pSrc ++;
#line 959
          val = (unsigned int )*__cil_tmp35;
#line 959
          available = 8;
        }
        {
#line 959
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 959
          if (! (needed___1 > available)) {
#line 959
            goto while_break___2;
          }
#line 959
          dst___1 |= val & ((1U << available) - 1U);
#line 959
          needed___1 -= available;
#line 959
          dst___1 <<= needed___1;
#line 959
          __cil_tmp36 = pSrc;
#line 959
          pSrc ++;
#line 959
          val = (unsigned int )*__cil_tmp36;
#line 959
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 959
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 959
        available -= needed___1;
#line 959
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 960
        if (length > 3UL) {
#line 961
          needed___2 = 9;
#line 961
          dst___2 = 0U;
#line 961
          if (available == 0) {
#line 961
            __cil_tmp39 = pSrc;
#line 961
            pSrc ++;
#line 961
            val = (unsigned int )*__cil_tmp39;
#line 961
            available = 8;
          }
          {
#line 961
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 961
            if (! (needed___2 > available)) {
#line 961
              goto while_break___3;
            }
#line 961
            dst___2 |= val & ((1U << available) - 1U);
#line 961
            needed___2 -= available;
#line 961
            dst___2 <<= needed___2;
#line 961
            __cil_tmp40 = pSrc;
#line 961
            pSrc ++;
#line 961
            val = (unsigned int )*__cil_tmp40;
#line 961
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 961
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 961
          available -= needed___2;
#line 961
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 962
          if (length > 4UL) {
#line 963
            needed___3 = 9;
#line 963
            dst___3 = 0U;
#line 963
            if (available == 0) {
#line 963
              __cil_tmp43 = pSrc;
#line 963
              pSrc ++;
#line 963
              val = (unsigned int )*__cil_tmp43;
#line 963
              available = 8;
            }
            {
#line 963
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 963
              if (! (needed___3 > available)) {
#line 963
                goto while_break___4;
              }
#line 963
              dst___3 |= val & ((1U << available) - 1U);
#line 963
              needed___3 -= available;
#line 963
              dst___3 <<= needed___3;
#line 963
              __cil_tmp44 = pSrc;
#line 963
              pSrc ++;
#line 963
              val = (unsigned int )*__cil_tmp44;
#line 963
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 963
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 963
            available -= needed___3;
#line 963
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 964
            if (length > 5UL) {
#line 965
              needed___4 = 9;
#line 965
              dst___4 = 0U;
#line 965
              if (available == 0) {
#line 965
                __cil_tmp47 = pSrc;
#line 965
                pSrc ++;
#line 965
                val = (unsigned int )*__cil_tmp47;
#line 965
                available = 8;
              }
              {
#line 965
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 965
                if (! (needed___4 > available)) {
#line 965
                  goto while_break___5;
                }
#line 965
                dst___4 |= val & ((1U << available) - 1U);
#line 965
                needed___4 -= available;
#line 965
                dst___4 <<= needed___4;
#line 965
                __cil_tmp48 = pSrc;
#line 965
                pSrc ++;
#line 965
                val = (unsigned int )*__cil_tmp48;
#line 965
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 965
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 965
              available -= needed___4;
#line 965
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 966
              if (length > 6UL) {
#line 967
                needed___5 = 9;
#line 967
                dst___5 = 0U;
#line 967
                if (available == 0) {
#line 967
                  __cil_tmp51 = pSrc;
#line 967
                  pSrc ++;
#line 967
                  val = (unsigned int )*__cil_tmp51;
#line 967
                  available = 8;
                }
                {
#line 967
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 967
                  if (! (needed___5 > available)) {
#line 967
                    goto while_break___6;
                  }
#line 967
                  dst___5 |= val & ((1U << available) - 1U);
#line 967
                  needed___5 -= available;
#line 967
                  dst___5 <<= needed___5;
#line 967
                  __cil_tmp52 = pSrc;
#line 967
                  pSrc ++;
#line 967
                  val = (unsigned int )*__cil_tmp52;
#line 967
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 967
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 967
                available -= needed___5;
#line 967
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 976 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_10uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val3___0 ;
  OPJ_BYTE *__cil_tmp22 ;

  {
#line 980
  i = (OPJ_SIZE_T )0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 980
      goto while_break;
    }
#line 981
    __cil_tmp6 = pSrc;
#line 981
    pSrc ++;
#line 981
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 982
    __cil_tmp8 = pSrc;
#line 982
    pSrc ++;
#line 982
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 983
    __cil_tmp10 = pSrc;
#line 983
    pSrc ++;
#line 983
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 984
    __cil_tmp12 = pSrc;
#line 984
    pSrc ++;
#line 984
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 985
    __cil_tmp14 = pSrc;
#line 985
    pSrc ++;
#line 985
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 987
    *(pDst + i) = (OPJ_INT32 )((val0 << 2) | (val1 >> 6));
#line 988
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 63U) << 4) | (val2 >> 4));
#line 989
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2 & 15U) << 6) | (val3 >> 2));
#line 990
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val3 & 3U) << 8) | val4);
#line 980
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  if (length & 3UL) {
#line 994
    __cil_tmp16 = pSrc;
#line 994
    pSrc ++;
#line 994
    val0___0 = (OPJ_UINT32 )*__cil_tmp16;
#line 995
    __cil_tmp18 = pSrc;
#line 995
    pSrc ++;
#line 995
    val1___0 = (OPJ_UINT32 )*__cil_tmp18;
#line 996
    length &= 3UL;
#line 997
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 2) | (val1___0 >> 6));
#line 999
    if (length > 1UL) {
#line 1000
      __cil_tmp20 = pSrc;
#line 1000
      pSrc ++;
#line 1000
      val2___0 = (OPJ_UINT32 )*__cil_tmp20;
#line 1001
      *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1___0 & 63U) << 4) | (val2___0 >> 4));
#line 1002
      if (length > 2UL) {
#line 1003
        __cil_tmp22 = pSrc;
#line 1003
        pSrc ++;
#line 1003
        val3___0 = (OPJ_UINT32 )*__cil_tmp22;
#line 1004
        *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val2___0 & 15U) << 6) | (val3___0 >> 2));
      }
    }
  }
  return;
}
}
#line 1009 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_11uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp31 ;
  OPJ_BYTE *__cil_tmp32 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;

  {
#line 1013
  i = (OPJ_SIZE_T )0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1013
      goto while_break;
    }
#line 1014
    __cil_tmp6 = pSrc;
#line 1014
    pSrc ++;
#line 1014
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1015
    __cil_tmp8 = pSrc;
#line 1015
    pSrc ++;
#line 1015
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1016
    __cil_tmp10 = pSrc;
#line 1016
    pSrc ++;
#line 1016
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1017
    __cil_tmp12 = pSrc;
#line 1017
    pSrc ++;
#line 1017
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1018
    __cil_tmp14 = pSrc;
#line 1018
    pSrc ++;
#line 1018
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1019
    __cil_tmp16 = pSrc;
#line 1019
    pSrc ++;
#line 1019
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1020
    __cil_tmp18 = pSrc;
#line 1020
    pSrc ++;
#line 1020
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1021
    __cil_tmp20 = pSrc;
#line 1021
    pSrc ++;
#line 1021
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1022
    __cil_tmp22 = pSrc;
#line 1022
    pSrc ++;
#line 1022
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1023
    __cil_tmp24 = pSrc;
#line 1023
    pSrc ++;
#line 1023
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1024
    __cil_tmp26 = pSrc;
#line 1024
    pSrc ++;
#line 1024
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1026
    *(pDst + i) = (OPJ_INT32 )((val0 << 3) | (val1 >> 5));
#line 1027
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 31U) << 6) | (val2 >> 2));
#line 1028
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val2 & 3U) << 9) | (val3 << 1)) | (val4 >> 7));
#line 1029
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val4 & 127U) << 4) | (val5 >> 4));
#line 1030
    *(pDst + (i + 4UL)) = (OPJ_INT32 )(((val5 & 15U) << 7) | (val6 >> 1));
#line 1031
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((((val6 & 1U) << 10) | (val7 << 2)) | (val8 >> 6));
#line 1032
    *(pDst + (i + 6UL)) = (OPJ_INT32 )(((val8 & 63U) << 5) | (val9 >> 3));
#line 1033
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val9 & 7U) << 8) | val10);
#line 1013
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  if (length & 7UL) {
#line 1038
    available = 0;
#line 1040
    length &= 7UL;
#line 1042
    needed = 11;
#line 1042
    dst = 0U;
#line 1042
    if (available == 0) {
#line 1042
      __cil_tmp31 = pSrc;
#line 1042
      pSrc ++;
#line 1042
      val = (unsigned int )*__cil_tmp31;
#line 1042
      available = 8;
    }
    {
#line 1042
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1042
      if (! (needed > available)) {
#line 1042
        goto while_break___0;
      }
#line 1042
      dst |= val & ((1U << available) - 1U);
#line 1042
      needed -= available;
#line 1042
      dst <<= needed;
#line 1042
      __cil_tmp32 = pSrc;
#line 1042
      pSrc ++;
#line 1042
      val = (unsigned int )*__cil_tmp32;
#line 1042
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1042
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1042
    available -= needed;
#line 1042
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1044
    if (length > 1UL) {
#line 1045
      needed___0 = 11;
#line 1045
      dst___0 = 0U;
#line 1045
      if (available == 0) {
#line 1045
        __cil_tmp35 = pSrc;
#line 1045
        pSrc ++;
#line 1045
        val = (unsigned int )*__cil_tmp35;
#line 1045
        available = 8;
      }
      {
#line 1045
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1045
        if (! (needed___0 > available)) {
#line 1045
          goto while_break___1;
        }
#line 1045
        dst___0 |= val & ((1U << available) - 1U);
#line 1045
        needed___0 -= available;
#line 1045
        dst___0 <<= needed___0;
#line 1045
        __cil_tmp36 = pSrc;
#line 1045
        pSrc ++;
#line 1045
        val = (unsigned int )*__cil_tmp36;
#line 1045
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1045
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1045
      available -= needed___0;
#line 1045
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1046
      if (length > 2UL) {
#line 1047
        needed___1 = 11;
#line 1047
        dst___1 = 0U;
#line 1047
        if (available == 0) {
#line 1047
          __cil_tmp39 = pSrc;
#line 1047
          pSrc ++;
#line 1047
          val = (unsigned int )*__cil_tmp39;
#line 1047
          available = 8;
        }
        {
#line 1047
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1047
          if (! (needed___1 > available)) {
#line 1047
            goto while_break___2;
          }
#line 1047
          dst___1 |= val & ((1U << available) - 1U);
#line 1047
          needed___1 -= available;
#line 1047
          dst___1 <<= needed___1;
#line 1047
          __cil_tmp40 = pSrc;
#line 1047
          pSrc ++;
#line 1047
          val = (unsigned int )*__cil_tmp40;
#line 1047
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1047
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1047
        available -= needed___1;
#line 1047
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1048
        if (length > 3UL) {
#line 1049
          needed___2 = 11;
#line 1049
          dst___2 = 0U;
#line 1049
          if (available == 0) {
#line 1049
            __cil_tmp43 = pSrc;
#line 1049
            pSrc ++;
#line 1049
            val = (unsigned int )*__cil_tmp43;
#line 1049
            available = 8;
          }
          {
#line 1049
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1049
            if (! (needed___2 > available)) {
#line 1049
              goto while_break___3;
            }
#line 1049
            dst___2 |= val & ((1U << available) - 1U);
#line 1049
            needed___2 -= available;
#line 1049
            dst___2 <<= needed___2;
#line 1049
            __cil_tmp44 = pSrc;
#line 1049
            pSrc ++;
#line 1049
            val = (unsigned int )*__cil_tmp44;
#line 1049
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1049
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1049
          available -= needed___2;
#line 1049
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1050
          if (length > 4UL) {
#line 1051
            needed___3 = 11;
#line 1051
            dst___3 = 0U;
#line 1051
            if (available == 0) {
#line 1051
              __cil_tmp47 = pSrc;
#line 1051
              pSrc ++;
#line 1051
              val = (unsigned int )*__cil_tmp47;
#line 1051
              available = 8;
            }
            {
#line 1051
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1051
              if (! (needed___3 > available)) {
#line 1051
                goto while_break___4;
              }
#line 1051
              dst___3 |= val & ((1U << available) - 1U);
#line 1051
              needed___3 -= available;
#line 1051
              dst___3 <<= needed___3;
#line 1051
              __cil_tmp48 = pSrc;
#line 1051
              pSrc ++;
#line 1051
              val = (unsigned int )*__cil_tmp48;
#line 1051
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1051
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1051
            available -= needed___3;
#line 1051
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1052
            if (length > 5UL) {
#line 1053
              needed___4 = 11;
#line 1053
              dst___4 = 0U;
#line 1053
              if (available == 0) {
#line 1053
                __cil_tmp51 = pSrc;
#line 1053
                pSrc ++;
#line 1053
                val = (unsigned int )*__cil_tmp51;
#line 1053
                available = 8;
              }
              {
#line 1053
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 1053
                if (! (needed___4 > available)) {
#line 1053
                  goto while_break___5;
                }
#line 1053
                dst___4 |= val & ((1U << available) - 1U);
#line 1053
                needed___4 -= available;
#line 1053
                dst___4 <<= needed___4;
#line 1053
                __cil_tmp52 = pSrc;
#line 1053
                pSrc ++;
#line 1053
                val = (unsigned int )*__cil_tmp52;
#line 1053
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 1053
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1053
              available -= needed___4;
#line 1053
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1054
              if (length > 6UL) {
#line 1055
                needed___5 = 11;
#line 1055
                dst___5 = 0U;
#line 1055
                if (available == 0) {
#line 1055
                  __cil_tmp55 = pSrc;
#line 1055
                  pSrc ++;
#line 1055
                  val = (unsigned int )*__cil_tmp55;
#line 1055
                  available = 8;
                }
                {
#line 1055
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 1055
                  if (! (needed___5 > available)) {
#line 1055
                    goto while_break___6;
                  }
#line 1055
                  dst___5 |= val & ((1U << available) - 1U);
#line 1055
                  needed___5 -= available;
#line 1055
                  dst___5 <<= needed___5;
#line 1055
                  __cil_tmp56 = pSrc;
#line 1055
                  pSrc ++;
#line 1055
                  val = (unsigned int )*__cil_tmp56;
#line 1055
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 1055
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1055
                available -= needed___5;
#line 1055
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 1064 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_12uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp14 ;

  {
#line 1068
  i = (OPJ_SIZE_T )0;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 1068
      goto while_break;
    }
#line 1069
    __cil_tmp6 = pSrc;
#line 1069
    pSrc ++;
#line 1069
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1070
    __cil_tmp8 = pSrc;
#line 1070
    pSrc ++;
#line 1070
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1071
    __cil_tmp10 = pSrc;
#line 1071
    pSrc ++;
#line 1071
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1073
    *(pDst + i) = (OPJ_INT32 )((val0 << 4) | (val1 >> 4));
#line 1074
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val1 & 15U) << 8) | val2);
#line 1068
    i += (unsigned long )2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  if (length & 1UL) {
#line 1077
    __cil_tmp12 = pSrc;
#line 1077
    pSrc ++;
#line 1077
    val0___0 = (OPJ_UINT32 )*__cil_tmp12;
#line 1078
    __cil_tmp14 = pSrc;
#line 1078
    pSrc ++;
#line 1078
    val1___0 = (OPJ_UINT32 )*__cil_tmp14;
#line 1079
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 4) | (val1___0 >> 4));
  }
  return;
}
}
#line 1082 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_13uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val11 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val12 ;
  OPJ_BYTE *__cil_tmp30 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp35 ;
  OPJ_BYTE *__cil_tmp36 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp59 ;
  OPJ_BYTE *__cil_tmp60 ;

  {
#line 1086
  i = (OPJ_SIZE_T )0;
  {
#line 1086
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1086
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1086
      goto while_break;
    }
#line 1087
    __cil_tmp6 = pSrc;
#line 1087
    pSrc ++;
#line 1087
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1088
    __cil_tmp8 = pSrc;
#line 1088
    pSrc ++;
#line 1088
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1089
    __cil_tmp10 = pSrc;
#line 1089
    pSrc ++;
#line 1089
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1090
    __cil_tmp12 = pSrc;
#line 1090
    pSrc ++;
#line 1090
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1091
    __cil_tmp14 = pSrc;
#line 1091
    pSrc ++;
#line 1091
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1092
    __cil_tmp16 = pSrc;
#line 1092
    pSrc ++;
#line 1092
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1093
    __cil_tmp18 = pSrc;
#line 1093
    pSrc ++;
#line 1093
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1094
    __cil_tmp20 = pSrc;
#line 1094
    pSrc ++;
#line 1094
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1095
    __cil_tmp22 = pSrc;
#line 1095
    pSrc ++;
#line 1095
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1096
    __cil_tmp24 = pSrc;
#line 1096
    pSrc ++;
#line 1096
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1097
    __cil_tmp26 = pSrc;
#line 1097
    pSrc ++;
#line 1097
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1098
    __cil_tmp28 = pSrc;
#line 1098
    pSrc ++;
#line 1098
    val11 = (OPJ_UINT32 )*__cil_tmp28;
#line 1099
    __cil_tmp30 = pSrc;
#line 1099
    pSrc ++;
#line 1099
    val12 = (OPJ_UINT32 )*__cil_tmp30;
#line 1101
    *(pDst + i) = (OPJ_INT32 )((val0 << 5) | (val1 >> 3));
#line 1102
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 7U) << 10) | (val2 << 2)) | (val3 >> 6));
#line 1103
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val3 & 63U) << 7) | (val4 >> 1));
#line 1104
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((((val4 & 1U) << 12) | (val5 << 4)) | (val6 >> 4));
#line 1105
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((((val6 & 15U) << 9) | (val7 << 1)) | (val8 >> 7));
#line 1106
    *(pDst + (i + 5UL)) = (OPJ_INT32 )(((val8 & 127U) << 6) | (val9 >> 2));
#line 1107
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((((val9 & 3U) << 11) | (val10 << 3)) | (val11 >> 5));
#line 1108
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val11 & 31U) << 8) | val12);
#line 1086
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1111
  if (length & 7UL) {
#line 1113
    available = 0;
#line 1115
    length &= 7UL;
#line 1117
    needed = 13;
#line 1117
    dst = 0U;
#line 1117
    if (available == 0) {
#line 1117
      __cil_tmp35 = pSrc;
#line 1117
      pSrc ++;
#line 1117
      val = (unsigned int )*__cil_tmp35;
#line 1117
      available = 8;
    }
    {
#line 1117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1117
      if (! (needed > available)) {
#line 1117
        goto while_break___0;
      }
#line 1117
      dst |= val & ((1U << available) - 1U);
#line 1117
      needed -= available;
#line 1117
      dst <<= needed;
#line 1117
      __cil_tmp36 = pSrc;
#line 1117
      pSrc ++;
#line 1117
      val = (unsigned int )*__cil_tmp36;
#line 1117
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1117
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1117
    available -= needed;
#line 1117
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1119
    if (length > 1UL) {
#line 1120
      needed___0 = 13;
#line 1120
      dst___0 = 0U;
#line 1120
      if (available == 0) {
#line 1120
        __cil_tmp39 = pSrc;
#line 1120
        pSrc ++;
#line 1120
        val = (unsigned int )*__cil_tmp39;
#line 1120
        available = 8;
      }
      {
#line 1120
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1120
        if (! (needed___0 > available)) {
#line 1120
          goto while_break___1;
        }
#line 1120
        dst___0 |= val & ((1U << available) - 1U);
#line 1120
        needed___0 -= available;
#line 1120
        dst___0 <<= needed___0;
#line 1120
        __cil_tmp40 = pSrc;
#line 1120
        pSrc ++;
#line 1120
        val = (unsigned int )*__cil_tmp40;
#line 1120
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1120
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1120
      available -= needed___0;
#line 1120
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1121
      if (length > 2UL) {
#line 1122
        needed___1 = 13;
#line 1122
        dst___1 = 0U;
#line 1122
        if (available == 0) {
#line 1122
          __cil_tmp43 = pSrc;
#line 1122
          pSrc ++;
#line 1122
          val = (unsigned int )*__cil_tmp43;
#line 1122
          available = 8;
        }
        {
#line 1122
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1122
          if (! (needed___1 > available)) {
#line 1122
            goto while_break___2;
          }
#line 1122
          dst___1 |= val & ((1U << available) - 1U);
#line 1122
          needed___1 -= available;
#line 1122
          dst___1 <<= needed___1;
#line 1122
          __cil_tmp44 = pSrc;
#line 1122
          pSrc ++;
#line 1122
          val = (unsigned int )*__cil_tmp44;
#line 1122
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1122
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1122
        available -= needed___1;
#line 1122
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1123
        if (length > 3UL) {
#line 1124
          needed___2 = 13;
#line 1124
          dst___2 = 0U;
#line 1124
          if (available == 0) {
#line 1124
            __cil_tmp47 = pSrc;
#line 1124
            pSrc ++;
#line 1124
            val = (unsigned int )*__cil_tmp47;
#line 1124
            available = 8;
          }
          {
#line 1124
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1124
            if (! (needed___2 > available)) {
#line 1124
              goto while_break___3;
            }
#line 1124
            dst___2 |= val & ((1U << available) - 1U);
#line 1124
            needed___2 -= available;
#line 1124
            dst___2 <<= needed___2;
#line 1124
            __cil_tmp48 = pSrc;
#line 1124
            pSrc ++;
#line 1124
            val = (unsigned int )*__cil_tmp48;
#line 1124
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1124
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1124
          available -= needed___2;
#line 1124
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1125
          if (length > 4UL) {
#line 1126
            needed___3 = 13;
#line 1126
            dst___3 = 0U;
#line 1126
            if (available == 0) {
#line 1126
              __cil_tmp51 = pSrc;
#line 1126
              pSrc ++;
#line 1126
              val = (unsigned int )*__cil_tmp51;
#line 1126
              available = 8;
            }
            {
#line 1126
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1126
              if (! (needed___3 > available)) {
#line 1126
                goto while_break___4;
              }
#line 1126
              dst___3 |= val & ((1U << available) - 1U);
#line 1126
              needed___3 -= available;
#line 1126
              dst___3 <<= needed___3;
#line 1126
              __cil_tmp52 = pSrc;
#line 1126
              pSrc ++;
#line 1126
              val = (unsigned int )*__cil_tmp52;
#line 1126
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1126
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1126
            available -= needed___3;
#line 1126
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1127
            if (length > 5UL) {
#line 1128
              needed___4 = 13;
#line 1128
              dst___4 = 0U;
#line 1128
              if (available == 0) {
#line 1128
                __cil_tmp55 = pSrc;
#line 1128
                pSrc ++;
#line 1128
                val = (unsigned int )*__cil_tmp55;
#line 1128
                available = 8;
              }
              {
#line 1128
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 1128
                if (! (needed___4 > available)) {
#line 1128
                  goto while_break___5;
                }
#line 1128
                dst___4 |= val & ((1U << available) - 1U);
#line 1128
                needed___4 -= available;
#line 1128
                dst___4 <<= needed___4;
#line 1128
                __cil_tmp56 = pSrc;
#line 1128
                pSrc ++;
#line 1128
                val = (unsigned int )*__cil_tmp56;
#line 1128
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 1128
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1128
              available -= needed___4;
#line 1128
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1129
              if (length > 6UL) {
#line 1130
                needed___5 = 13;
#line 1130
                dst___5 = 0U;
#line 1130
                if (available == 0) {
#line 1130
                  __cil_tmp59 = pSrc;
#line 1130
                  pSrc ++;
#line 1130
                  val = (unsigned int )*__cil_tmp59;
#line 1130
                  available = 8;
                }
                {
#line 1130
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 1130
                  if (! (needed___5 > available)) {
#line 1130
                    goto while_break___6;
                  }
#line 1130
                  dst___5 |= val & ((1U << available) - 1U);
#line 1130
                  needed___5 -= available;
#line 1130
                  dst___5 <<= needed___5;
#line 1130
                  __cil_tmp60 = pSrc;
#line 1130
                  pSrc ++;
#line 1130
                  val = (unsigned int )*__cil_tmp60;
#line 1130
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 1130
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1130
                available -= needed___5;
#line 1130
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 1139 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_14uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val3___0 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val4___0 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val5___0 ;
  OPJ_BYTE *__cil_tmp30 ;

  {
#line 1143
  i = (OPJ_SIZE_T )0;
  {
#line 1143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1143
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 1143
      goto while_break;
    }
#line 1144
    __cil_tmp6 = pSrc;
#line 1144
    pSrc ++;
#line 1144
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1145
    __cil_tmp8 = pSrc;
#line 1145
    pSrc ++;
#line 1145
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1146
    __cil_tmp10 = pSrc;
#line 1146
    pSrc ++;
#line 1146
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1147
    __cil_tmp12 = pSrc;
#line 1147
    pSrc ++;
#line 1147
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1148
    __cil_tmp14 = pSrc;
#line 1148
    pSrc ++;
#line 1148
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1149
    __cil_tmp16 = pSrc;
#line 1149
    pSrc ++;
#line 1149
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1150
    __cil_tmp18 = pSrc;
#line 1150
    pSrc ++;
#line 1150
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1152
    *(pDst + i) = (OPJ_INT32 )((val0 << 6) | (val1 >> 2));
#line 1153
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 3U) << 12) | (val2 << 4)) | (val3 >> 4));
#line 1154
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3 & 15U) << 10) | (val4 << 2)) | (val5 >> 6));
#line 1155
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(((val5 & 63U) << 8) | val6);
#line 1143
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1158
  if (length & 3UL) {
#line 1159
    __cil_tmp20 = pSrc;
#line 1159
    pSrc ++;
#line 1159
    val0___0 = (OPJ_UINT32 )*__cil_tmp20;
#line 1160
    __cil_tmp22 = pSrc;
#line 1160
    pSrc ++;
#line 1160
    val1___0 = (OPJ_UINT32 )*__cil_tmp22;
#line 1161
    length &= 3UL;
#line 1162
    *(pDst + i) = (OPJ_INT32 )((val0___0 << 6) | (val1___0 >> 2));
#line 1164
    if (length > 1UL) {
#line 1165
      __cil_tmp24 = pSrc;
#line 1165
      pSrc ++;
#line 1165
      val2___0 = (OPJ_UINT32 )*__cil_tmp24;
#line 1166
      __cil_tmp26 = pSrc;
#line 1166
      pSrc ++;
#line 1166
      val3___0 = (OPJ_UINT32 )*__cil_tmp26;
#line 1167
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1___0 & 3U) << 12) | (val2___0 << 4)) | (val3___0 >> 4));
#line 1168
      if (length > 2UL) {
#line 1169
        __cil_tmp28 = pSrc;
#line 1169
        pSrc ++;
#line 1169
        val4___0 = (OPJ_UINT32 )*__cil_tmp28;
#line 1170
        __cil_tmp30 = pSrc;
#line 1170
        pSrc ++;
#line 1170
        val5___0 = (OPJ_UINT32 )*__cil_tmp30;
#line 1171
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3___0 & 15U) << 10) | (val4___0 << 2)) | (val5___0 >> 6));
      }
    }
  }
  return;
}
}
#line 1176 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_15uto32s(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val3 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val4 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val5 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_UINT32 val6 ;
  OPJ_BYTE *__cil_tmp18 ;
  OPJ_UINT32 val7 ;
  OPJ_BYTE *__cil_tmp20 ;
  OPJ_UINT32 val8 ;
  OPJ_BYTE *__cil_tmp22 ;
  OPJ_UINT32 val9 ;
  OPJ_BYTE *__cil_tmp24 ;
  OPJ_UINT32 val10 ;
  OPJ_BYTE *__cil_tmp26 ;
  OPJ_UINT32 val11 ;
  OPJ_BYTE *__cil_tmp28 ;
  OPJ_UINT32 val12 ;
  OPJ_BYTE *__cil_tmp30 ;
  OPJ_UINT32 val13 ;
  OPJ_BYTE *__cil_tmp32 ;
  OPJ_UINT32 val14 ;
  OPJ_BYTE *__cil_tmp34 ;
  unsigned int val ;
  int available ;
  int needed ;
  unsigned int dst ;
  OPJ_BYTE *__cil_tmp39 ;
  OPJ_BYTE *__cil_tmp40 ;
  int needed___0 ;
  unsigned int dst___0 ;
  OPJ_BYTE *__cil_tmp43 ;
  OPJ_BYTE *__cil_tmp44 ;
  int needed___1 ;
  unsigned int dst___1 ;
  OPJ_BYTE *__cil_tmp47 ;
  OPJ_BYTE *__cil_tmp48 ;
  int needed___2 ;
  unsigned int dst___2 ;
  OPJ_BYTE *__cil_tmp51 ;
  OPJ_BYTE *__cil_tmp52 ;
  int needed___3 ;
  unsigned int dst___3 ;
  OPJ_BYTE *__cil_tmp55 ;
  OPJ_BYTE *__cil_tmp56 ;
  int needed___4 ;
  unsigned int dst___4 ;
  OPJ_BYTE *__cil_tmp59 ;
  OPJ_BYTE *__cil_tmp60 ;
  int needed___5 ;
  unsigned int dst___5 ;
  OPJ_BYTE *__cil_tmp63 ;
  OPJ_BYTE *__cil_tmp64 ;

  {
#line 1180
  i = (OPJ_SIZE_T )0;
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1180
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 1180
      goto while_break;
    }
#line 1181
    __cil_tmp6 = pSrc;
#line 1181
    pSrc ++;
#line 1181
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 1182
    __cil_tmp8 = pSrc;
#line 1182
    pSrc ++;
#line 1182
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 1183
    __cil_tmp10 = pSrc;
#line 1183
    pSrc ++;
#line 1183
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 1184
    __cil_tmp12 = pSrc;
#line 1184
    pSrc ++;
#line 1184
    val3 = (OPJ_UINT32 )*__cil_tmp12;
#line 1185
    __cil_tmp14 = pSrc;
#line 1185
    pSrc ++;
#line 1185
    val4 = (OPJ_UINT32 )*__cil_tmp14;
#line 1186
    __cil_tmp16 = pSrc;
#line 1186
    pSrc ++;
#line 1186
    val5 = (OPJ_UINT32 )*__cil_tmp16;
#line 1187
    __cil_tmp18 = pSrc;
#line 1187
    pSrc ++;
#line 1187
    val6 = (OPJ_UINT32 )*__cil_tmp18;
#line 1188
    __cil_tmp20 = pSrc;
#line 1188
    pSrc ++;
#line 1188
    val7 = (OPJ_UINT32 )*__cil_tmp20;
#line 1189
    __cil_tmp22 = pSrc;
#line 1189
    pSrc ++;
#line 1189
    val8 = (OPJ_UINT32 )*__cil_tmp22;
#line 1190
    __cil_tmp24 = pSrc;
#line 1190
    pSrc ++;
#line 1190
    val9 = (OPJ_UINT32 )*__cil_tmp24;
#line 1191
    __cil_tmp26 = pSrc;
#line 1191
    pSrc ++;
#line 1191
    val10 = (OPJ_UINT32 )*__cil_tmp26;
#line 1192
    __cil_tmp28 = pSrc;
#line 1192
    pSrc ++;
#line 1192
    val11 = (OPJ_UINT32 )*__cil_tmp28;
#line 1193
    __cil_tmp30 = pSrc;
#line 1193
    pSrc ++;
#line 1193
    val12 = (OPJ_UINT32 )*__cil_tmp30;
#line 1194
    __cil_tmp32 = pSrc;
#line 1194
    pSrc ++;
#line 1194
    val13 = (OPJ_UINT32 )*__cil_tmp32;
#line 1195
    __cil_tmp34 = pSrc;
#line 1195
    pSrc ++;
#line 1195
    val14 = (OPJ_UINT32 )*__cil_tmp34;
#line 1197
    *(pDst + i) = (OPJ_INT32 )((val0 << 7) | (val1 >> 1));
#line 1198
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((((val1 & 1U) << 14) | (val2 << 6)) | (val3 >> 2));
#line 1199
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((((val3 & 3U) << 13) | (val4 << 5)) | (val5 >> 3));
#line 1200
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((((val5 & 7U) << 12) | (val6 << 4)) | (val7 >> 4));
#line 1201
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((((val7 & 15U) << 11) | (val8 << 3)) | (val9 >> 5));
#line 1202
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((((val9 & 31U) << 10) | (val10 << 2)) | (val11 >> 6));
#line 1203
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((((val11 & 63U) << 9) | (val12 << 1)) | (val13 >> 7));
#line 1204
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(((val13 & 127U) << 8) | val14);
#line 1180
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  if (length & 7UL) {
#line 1209
    available = 0;
#line 1211
    length &= 7UL;
#line 1213
    needed = 15;
#line 1213
    dst = 0U;
#line 1213
    if (available == 0) {
#line 1213
      __cil_tmp39 = pSrc;
#line 1213
      pSrc ++;
#line 1213
      val = (unsigned int )*__cil_tmp39;
#line 1213
      available = 8;
    }
    {
#line 1213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1213
      if (! (needed > available)) {
#line 1213
        goto while_break___0;
      }
#line 1213
      dst |= val & ((1U << available) - 1U);
#line 1213
      needed -= available;
#line 1213
      dst <<= needed;
#line 1213
      __cil_tmp40 = pSrc;
#line 1213
      pSrc ++;
#line 1213
      val = (unsigned int )*__cil_tmp40;
#line 1213
      available = 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1213
    dst |= (val >> (available - needed)) & ((1U << needed) - 1U);
#line 1213
    available -= needed;
#line 1213
    *(pDst + i) = (OPJ_INT32 )dst;
#line 1215
    if (length > 1UL) {
#line 1216
      needed___0 = 15;
#line 1216
      dst___0 = 0U;
#line 1216
      if (available == 0) {
#line 1216
        __cil_tmp43 = pSrc;
#line 1216
        pSrc ++;
#line 1216
        val = (unsigned int )*__cil_tmp43;
#line 1216
        available = 8;
      }
      {
#line 1216
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1216
        if (! (needed___0 > available)) {
#line 1216
          goto while_break___1;
        }
#line 1216
        dst___0 |= val & ((1U << available) - 1U);
#line 1216
        needed___0 -= available;
#line 1216
        dst___0 <<= needed___0;
#line 1216
        __cil_tmp44 = pSrc;
#line 1216
        pSrc ++;
#line 1216
        val = (unsigned int )*__cil_tmp44;
#line 1216
        available = 8;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1216
      dst___0 |= (val >> (available - needed___0)) & ((1U << needed___0) - 1U);
#line 1216
      available -= needed___0;
#line 1216
      *(pDst + (i + 1UL)) = (OPJ_INT32 )dst___0;
#line 1217
      if (length > 2UL) {
#line 1218
        needed___1 = 15;
#line 1218
        dst___1 = 0U;
#line 1218
        if (available == 0) {
#line 1218
          __cil_tmp47 = pSrc;
#line 1218
          pSrc ++;
#line 1218
          val = (unsigned int )*__cil_tmp47;
#line 1218
          available = 8;
        }
        {
#line 1218
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1218
          if (! (needed___1 > available)) {
#line 1218
            goto while_break___2;
          }
#line 1218
          dst___1 |= val & ((1U << available) - 1U);
#line 1218
          needed___1 -= available;
#line 1218
          dst___1 <<= needed___1;
#line 1218
          __cil_tmp48 = pSrc;
#line 1218
          pSrc ++;
#line 1218
          val = (unsigned int )*__cil_tmp48;
#line 1218
          available = 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1218
        dst___1 |= (val >> (available - needed___1)) & ((1U << needed___1) - 1U);
#line 1218
        available -= needed___1;
#line 1218
        *(pDst + (i + 2UL)) = (OPJ_INT32 )dst___1;
#line 1219
        if (length > 3UL) {
#line 1220
          needed___2 = 15;
#line 1220
          dst___2 = 0U;
#line 1220
          if (available == 0) {
#line 1220
            __cil_tmp51 = pSrc;
#line 1220
            pSrc ++;
#line 1220
            val = (unsigned int )*__cil_tmp51;
#line 1220
            available = 8;
          }
          {
#line 1220
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1220
            if (! (needed___2 > available)) {
#line 1220
              goto while_break___3;
            }
#line 1220
            dst___2 |= val & ((1U << available) - 1U);
#line 1220
            needed___2 -= available;
#line 1220
            dst___2 <<= needed___2;
#line 1220
            __cil_tmp52 = pSrc;
#line 1220
            pSrc ++;
#line 1220
            val = (unsigned int )*__cil_tmp52;
#line 1220
            available = 8;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1220
          dst___2 |= (val >> (available - needed___2)) & ((1U << needed___2) - 1U);
#line 1220
          available -= needed___2;
#line 1220
          *(pDst + (i + 3UL)) = (OPJ_INT32 )dst___2;
#line 1221
          if (length > 4UL) {
#line 1222
            needed___3 = 15;
#line 1222
            dst___3 = 0U;
#line 1222
            if (available == 0) {
#line 1222
              __cil_tmp55 = pSrc;
#line 1222
              pSrc ++;
#line 1222
              val = (unsigned int )*__cil_tmp55;
#line 1222
              available = 8;
            }
            {
#line 1222
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1222
              if (! (needed___3 > available)) {
#line 1222
                goto while_break___4;
              }
#line 1222
              dst___3 |= val & ((1U << available) - 1U);
#line 1222
              needed___3 -= available;
#line 1222
              dst___3 <<= needed___3;
#line 1222
              __cil_tmp56 = pSrc;
#line 1222
              pSrc ++;
#line 1222
              val = (unsigned int )*__cil_tmp56;
#line 1222
              available = 8;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1222
            dst___3 |= (val >> (available - needed___3)) & ((1U << needed___3) - 1U);
#line 1222
            available -= needed___3;
#line 1222
            *(pDst + (i + 4UL)) = (OPJ_INT32 )dst___3;
#line 1223
            if (length > 5UL) {
#line 1224
              needed___4 = 15;
#line 1224
              dst___4 = 0U;
#line 1224
              if (available == 0) {
#line 1224
                __cil_tmp59 = pSrc;
#line 1224
                pSrc ++;
#line 1224
                val = (unsigned int )*__cil_tmp59;
#line 1224
                available = 8;
              }
              {
#line 1224
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 1224
                if (! (needed___4 > available)) {
#line 1224
                  goto while_break___5;
                }
#line 1224
                dst___4 |= val & ((1U << available) - 1U);
#line 1224
                needed___4 -= available;
#line 1224
                dst___4 <<= needed___4;
#line 1224
                __cil_tmp60 = pSrc;
#line 1224
                pSrc ++;
#line 1224
                val = (unsigned int )*__cil_tmp60;
#line 1224
                available = 8;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 1224
              dst___4 |= (val >> (available - needed___4)) & ((1U << needed___4) - 1U);
#line 1224
              available -= needed___4;
#line 1224
              *(pDst + (i + 5UL)) = (OPJ_INT32 )dst___4;
#line 1225
              if (length > 6UL) {
#line 1226
                needed___5 = 15;
#line 1226
                dst___5 = 0U;
#line 1226
                if (available == 0) {
#line 1226
                  __cil_tmp63 = pSrc;
#line 1226
                  pSrc ++;
#line 1226
                  val = (unsigned int )*__cil_tmp63;
#line 1226
                  available = 8;
                }
                {
#line 1226
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 1226
                  if (! (needed___5 > available)) {
#line 1226
                    goto while_break___6;
                  }
#line 1226
                  dst___5 |= val & ((1U << available) - 1U);
#line 1226
                  needed___5 -= available;
#line 1226
                  dst___5 <<= needed___5;
#line 1226
                  __cil_tmp64 = pSrc;
#line 1226
                  pSrc ++;
#line 1226
                  val = (unsigned int )*__cil_tmp64;
#line 1226
                  available = 8;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 1226
                dst___5 |= (val >> (available - needed___5)) & ((1U << needed___5) - 1U);
#line 1226
                available -= needed___5;
#line 1226
                *(pDst + (i + 6UL)) = (OPJ_INT32 )dst___5;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 1237 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
static void tif_16uto32s(OPJ_UINT16 *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T __cil_tmp5 ;

  {
#line 1241
  i = (OPJ_SIZE_T )0;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (i < length)) {
#line 1241
      goto while_break;
    }
#line 1242
    *(pDst + i) = (OPJ_INT32 )*(pSrc + i);
#line 1241
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1250 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/converttif.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters , unsigned int target_bitdepth ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  int64_t strip_size ;
  int64_t rowStride ;
  int64_t TIFF_MAX ;
  int j ;
  int currentPlane ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  uint16_t tiBps ;
  uint16_t tiPhoto ;
  uint16_t tiSf ;
  uint16_t tiSpp ;
  uint16_t tiPC ;
  uint32_t tiWidth ;
  uint32_t tiHeight ;
  OPJ_BOOL is_cinema ;
  convert_XXx32s_C1R cvtTifTo32s ;
  convert_32s_CXPX cvtCxToPx ;
  OPJ_INT32 *buffer32s ;
  OPJ_INT32 *planes[4] ;
  TIFF *__cil_tmp32 ;
  int __cil_tmp33 ;
  opj_image_t *__cil_tmp34 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 tmp___0 ;
  int __cil_tmp37 ;
  tmsize_t __cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  uint32 __cil_tmp41 ;
  OPJ_UINT8 *dat8 ;
  int64_t ssize ;
  tmsize_t __cil_tmp44 ;
  int __cil_tmp45 ;
  tstrip_t __cil_tmp46 ;
  int __cil_tmp47 ;

  {
  {
#line 1253
  subsampling_dx = parameters->subsampling_dx;
#line 1254
  subsampling_dy = parameters->subsampling_dy;
#line 1259
  numcomps = 0;
#line 1260
  color_space = (OPJ_COLOR_SPACE )-1;
#line 1262
  image = (opj_image_t *)((void *)0);
#line 1265
  is_cinema = (int )parameters->rsiz >= 3 && (int )parameters->rsiz <= 6;
#line 1266
  cvtTifTo32s = (convert_XXx32s_C1R )((void *)0);
#line 1267
  cvtCxToPx = (convert_32s_CXPX )((void *)0);
#line 1268
  buffer32s = (OPJ_INT32 *)((void *)0);
#line 1271
  tif = TIFFOpen(filename, "r");
  }
#line 1273
  if (! tif) {
    {
#line 1274
    fprintf(stderr, "tiftoimage:Failed to open %s for reading\n", filename);
    }
#line 1275
    return ((opj_image_t *)0);
  }
  {
#line 1277
  tiPC = (uint16_t )0;
#line 1277
  tiSpp = tiPC;
#line 1277
  tiSf = tiSpp;
#line 1277
  tiPhoto = tiSf;
#line 1277
  tiBps = tiPhoto;
#line 1278
  tiHeight = (uint32_t )0;
#line 1278
  tiWidth = tiHeight;
#line 1280
  TIFFGetField(tif, (uint32 )256, & tiWidth);
#line 1281
  TIFFGetField(tif, (uint32 )257, & tiHeight);
#line 1282
  TIFFGetField(tif, (uint32 )258, & tiBps);
#line 1283
  TIFFGetField(tif, (uint32 )339, & tiSf);
#line 1284
  TIFFGetField(tif, (uint32 )277, & tiSpp);
#line 1285
  TIFFGetField(tif, (uint32 )262, & tiPhoto);
#line 1286
  TIFFGetField(tif, (uint32 )284, & tiPC);
  }
#line 1288
  if ((int )tiSpp == 0) {
    {
    {
#line 1289
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
    }
    {
#line 1291
    TIFFClose(tif);
    }
    }
#line 1292
    return ((opj_image_t *)((void *)0));
  } else
#line 1288
  if ((int )tiSpp > 4) {
    {
    {
#line 1289
    fprintf(stderr, "tiftoimage: Bad value for samples per pixel == %d.\n\tAborting.\n",
            (int )tiSpp);
    }
    {
#line 1291
    TIFFClose(tif);
    }
    }
#line 1292
    return ((opj_image_t *)((void *)0));
  }
#line 1294
  if ((unsigned int )tiBps > 16U) {
    {
    {
#line 1295
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
    }
    {
#line 1297
    TIFFClose(tif);
    }
    }
#line 1298
    return ((opj_image_t *)((void *)0));
  } else
#line 1294
  if ((int )tiBps == 0) {
    {
    {
#line 1295
    fprintf(stderr, "tiftoimage: Bad values for Bits == %d.\n\tMax. 16 Bits are allowed here.\n\tAborting.\n",
            (int )tiBps);
    }
    {
#line 1297
    TIFFClose(tif);
    }
    }
#line 1298
    return ((opj_image_t *)((void *)0));
  }
#line 1300
  if ((int )tiPhoto != 1) {
#line 1300
    if ((int )tiPhoto != 2) {
      {
#line 1301
      fprintf(stderr, "tiftoimage: Bad color format %d.\n\tOnly RGB(A) and GRAY(A) has been implemented\n\tAborting.\n",
              (int )tiPhoto);
#line 1304
      TIFFClose(tif);
      }
#line 1305
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1307
  if (tiWidth == 0U) {
    {
    {
#line 1308
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
    }
    {
#line 1310
    TIFFClose(tif);
    }
    }
#line 1311
    return ((opj_image_t *)((void *)0));
  } else
#line 1307
  if (tiHeight == 0U) {
    {
    {
#line 1308
    fprintf(stderr, "tiftoimage: Bad values for width(%u) and/or height(%u)\n\tAborting.\n",
            tiWidth, tiHeight);
    }
    {
#line 1310
    TIFFClose(tif);
    }
    }
#line 1311
    return ((opj_image_t *)((void *)0));
  }
#line 1313
  w = (int )tiWidth;
#line 1314
  h = (int )tiHeight;
  {
#line 1321
  if ((int )tiBps == 8) {
#line 1321
    goto case_8;
  }
#line 1321
  if ((int )tiBps == 6) {
#line 1321
    goto case_8;
  }
#line 1321
  if ((int )tiBps == 4) {
#line 1321
    goto case_8;
  }
#line 1321
  if ((int )tiBps == 2) {
#line 1321
    goto case_8;
  }
#line 1321
  if ((int )tiBps == 1) {
#line 1321
    goto case_8;
  }
#line 1325
  if ((int )tiBps == 3) {
#line 1325
    goto case_3;
  }
#line 1328
  if ((int )tiBps == 5) {
#line 1328
    goto case_5;
  }
#line 1331
  if ((int )tiBps == 7) {
#line 1331
    goto case_7;
  }
#line 1334
  if ((int )tiBps == 9) {
#line 1334
    goto case_9;
  }
#line 1337
  if ((int )tiBps == 10) {
#line 1337
    goto case_10;
  }
#line 1340
  if ((int )tiBps == 11) {
#line 1340
    goto case_11;
  }
#line 1343
  if ((int )tiBps == 12) {
#line 1343
    goto case_12;
  }
#line 1346
  if ((int )tiBps == 13) {
#line 1346
    goto case_13;
  }
#line 1349
  if ((int )tiBps == 14) {
#line 1349
    goto case_14;
  }
#line 1352
  if ((int )tiBps == 15) {
#line 1352
    goto case_15;
  }
#line 1355
  if ((int )tiBps == 16) {
#line 1355
    goto case_16;
  }
#line 1358
  goto switch_default;
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1322
  cvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];
#line 1323
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1326
  cvtTifTo32s = & tif_3uto32s;
#line 1327
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1329
  cvtTifTo32s = & tif_5uto32s;
#line 1330
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1332
  cvtTifTo32s = & tif_7uto32s;
#line 1333
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1335
  cvtTifTo32s = & tif_9uto32s;
#line 1336
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1338
  cvtTifTo32s = & tif_10uto32s;
#line 1339
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1341
  cvtTifTo32s = & tif_11uto32s;
#line 1342
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1344
  cvtTifTo32s = & tif_12uto32s;
#line 1345
  goto switch_break;
  case_13: /* CIL Label */ 
#line 1347
  cvtTifTo32s = & tif_13uto32s;
#line 1348
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1350
  cvtTifTo32s = & tif_14uto32s;
#line 1351
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1353
  cvtTifTo32s = & tif_15uto32s;
#line 1354
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1356
  cvtTifTo32s = (convert_XXx32s_C1R )(& tif_16uto32s);
#line 1357
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1360
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1364
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
  }
#line 1366
  if ((int )tiPhoto == 2) {
#line 1366
    if (is_cinema) {
#line 1366
      if ((unsigned int )tiBps != 12U) {
        {
#line 1367
        fprintf(stdout, "WARNING:\nInput image bitdepth is %d bits\nTIF conversion has automatically rescaled to 12-bits\nto comply with cinema profiles.\n",
                (int )tiBps);
        }
      } else {
#line 1373
        is_cinema = (OPJ_BOOL )0U;
      }
    } else {
#line 1373
      is_cinema = (OPJ_BOOL )0U;
    }
  } else {
#line 1373
    is_cinema = (OPJ_BOOL )0U;
  }
#line 1376
  numcomps = (int )tiSpp;
#line 1377
  if ((int )tiPhoto == 2) {
#line 1378
    color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 1379
  if ((int )tiPhoto == 1) {
#line 1380
    color_space = (OPJ_COLOR_SPACE )2;
  }
#line 1383
  cvtCxToPx = convert_32s_CXPX_LUT[numcomps];
#line 1384
  if ((int )tiPC == 2) {
#line 1385
    cvtCxToPx = convert_32s_CXPX_LUT[1];
#line 1386
    tiSpp = (uint16_t )1U;
  }
#line 1389
  j = 0;
  {
#line 1389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1389
    if (! (j < numcomps)) {
#line 1389
      goto while_break;
    }
#line 1390
    cmptparm[j].prec = (OPJ_UINT32 )tiBps;
#line 1391
    cmptparm[j].dx = (OPJ_UINT32 )subsampling_dx;
#line 1392
    cmptparm[j].dy = (OPJ_UINT32 )subsampling_dy;
#line 1393
    cmptparm[j].w = (OPJ_UINT32 )w;
#line 1394
    cmptparm[j].h = (OPJ_UINT32 )h;
#line 1389
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1397
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1398
  if (! image) {
    {
#line 1399
    TIFFClose(tif);
    }
#line 1400
    return ((opj_image_t *)((void *)0));
  }
#line 1403
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1404
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1405
  if (! image->x0) {
#line 1405
    tmp = (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 1405
    tmp = (image->x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 1405
  image->x1 = tmp;
#line 1407
  if (image->x1 <= image->x0) {
    {
#line 1408
    fprintf(stderr, "tiftoimage: Bad value for image->x1(%d) vs. image->x0(%d)\n\tAborting.\n",
            image->x1, image->x0);
#line 1410
    TIFFClose(tif);
#line 1411
    opj_image_destroy(image);
    }
#line 1412
    return ((opj_image_t *)((void *)0));
  }
#line 1414
  if (! image->y0) {
#line 1414
    tmp___0 = (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 1414
    tmp___0 = (image->y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 1414
  image->y1 = tmp___0;
#line 1416
  if (image->y1 <= image->y0) {
    {
#line 1417
    fprintf(stderr, "tiftoimage: Bad value for image->y1(%d) vs. image->y0(%d)\n\tAborting.\n",
            image->y1, image->y0);
#line 1419
    TIFFClose(tif);
#line 1420
    opj_image_destroy(image);
    }
#line 1421
    return ((opj_image_t *)((void *)0));
  }
#line 1424
  j = 0;
  {
#line 1424
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1424
    if (! (j < numcomps)) {
#line 1424
      goto while_break___0;
    }
#line 1425
    planes[j] = (image->comps + j)->data;
#line 1424
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1427
  (image->comps + (numcomps - 1))->alpha = (OPJ_UINT16 )(1 - (numcomps & 1));
#line 1429
  __cil_tmp38 = TIFFStripSize(tif);
#line 1429
  strip_size = (int64_t )__cil_tmp38;
#line 1431
  buf = malloc((OPJ_SIZE_T )strip_size);
  }
#line 1432
  if (buf == (void *)0) {
    {
#line 1433
    TIFFClose(tif);
#line 1434
    opj_image_destroy(image);
    }
#line 1435
    return ((opj_image_t *)((void *)0));
  }
#line 1437
  if (sizeof(tsize_t ) == 4UL) {
#line 1438
    TIFF_MAX = (int64_t )2147483647;
  } else {
#line 1440
    TIFF_MAX = (int64_t )4294967295U;
  }
#line 1442
  if ((int64_t )tiWidth > (int64_t )(TIFF_MAX / (long )tiSpp)) {
    {
    {
    {
#line 1445
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 1446
    _TIFFfree(buf);
    }
    }
    {
    {
#line 1447
    TIFFClose(tif);
    }
    }
    {
    {
#line 1448
    opj_image_destroy(image);
    }
    }
    }
#line 1449
    return ((opj_image_t *)((void *)0));
  } else
#line 1442
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > (int64_t )(TIFF_MAX / (long )tiBps)) {
    {
    {
    {
#line 1445
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 1446
    _TIFFfree(buf);
    }
    }
    {
    {
#line 1447
    TIFFClose(tif);
    }
    }
    {
    {
#line 1448
    opj_image_destroy(image);
    }
    }
    }
#line 1449
    return ((opj_image_t *)((void *)0));
  } else
#line 1442
  if ((int64_t )(tiWidth * (unsigned int )tiSpp) > (int64_t )(TIFF_MAX / (int64_t )sizeof(OPJ_INT32 ))) {
    {
    {
    {
#line 1445
    fprintf(stderr, "Buffer overflow\n\220");
    }
    }
    {
    {
#line 1446
    _TIFFfree(buf);
    }
    }
    {
    {
#line 1447
    TIFFClose(tif);
    }
    }
    {
    {
#line 1448
    opj_image_destroy(image);
    }
    }
    }
#line 1449
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1452
  rowStride = (int64_t )(((tiWidth * (unsigned int )tiSpp) * (unsigned int )tiBps + 7U) / 8U);
#line 1453
  __cil_tmp40 = malloc((sizeof(OPJ_INT32 ) * (unsigned long )tiWidth) * (unsigned long )tiSpp);
#line 1453
  buffer32s = (OPJ_INT32 *)__cil_tmp40;
  }
#line 1454
  if (buffer32s == (void *)0) {
    {
#line 1455
    _TIFFfree(buf);
#line 1456
    TIFFClose(tif);
#line 1457
    opj_image_destroy(image);
    }
#line 1458
    return ((opj_image_t *)((void *)0));
  }
#line 1461
  strip = (tstrip_t )0;
#line 1462
  currentPlane = 0;
  {
#line 1463
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1464
    planes[0] = (image->comps + currentPlane)->data;
#line 1465
    h = (int )tiHeight;
    {
#line 1467
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1467
      if (! (h > 0 && strip < __cil_tmp41)) {
#line 1467
        goto while_break___2;
      }
      {
#line 1471
      __cil_tmp44 = TIFFReadEncodedStrip(tif, strip, buf, (tsize_t )strip_size);
#line 1471
      ssize = (int64_t )__cil_tmp44;
      }
#line 1473
      if (ssize < 1L) {
        {
        {
#line 1474
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size);
        }
        {
#line 1476
        _TIFFfree(buf);
        }
        {
#line 1477
        _TIFFfree(buffer32s);
        }
        {
#line 1478
        TIFFClose(tif);
        }
        {
#line 1479
        opj_image_destroy(image);
        }
        }
#line 1480
        return ((opj_image_t *)((void *)0));
      } else
#line 1473
      if (ssize > strip_size) {
        {
        {
#line 1474
        fprintf(stderr, "tiftoimage: Bad value for ssize(%ld) vs. strip_size(%ld).\n\tAborting.\n",
                ssize, strip_size);
        }
        {
#line 1476
        _TIFFfree(buf);
        }
        {
#line 1477
        _TIFFfree(buffer32s);
        }
        {
#line 1478
        TIFFClose(tif);
        }
        {
#line 1479
        opj_image_destroy(image);
        }
        }
#line 1480
        return ((opj_image_t *)((void *)0));
      }
#line 1482
      dat8 = (OPJ_UINT8 *)buf;
      {
#line 1484
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1484
        if (! (ssize >= rowStride)) {
#line 1484
          goto while_break___3;
        }
        {
#line 1485
        (*cvtTifTo32s)(dat8, buffer32s, (OPJ_SIZE_T )w * (unsigned long )tiSpp);
#line 1486
        (*cvtCxToPx)(buffer32s, (OPJ_INT32 * const  *)((OPJ_INT32 **)planes), (OPJ_SIZE_T )w);
#line 1487
        planes[0] += w;
#line 1488
        planes[1] += w;
#line 1489
        planes[2] += w;
#line 1490
        planes[3] += w;
#line 1491
        dat8 += rowStride;
#line 1492
        ssize -= rowStride;
#line 1493
        __cil_tmp45 = h;
#line 1493
        h --;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1467
      strip ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1496
    currentPlane ++;
#line 1463
    if (! ((int )tiPC == 2 && currentPlane < numcomps)) {
#line 1463
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1499
  free(buffer32s);
#line 1500
  _TIFFfree(buf);
#line 1501
  TIFFClose(tif);
  }
#line 1503
  if (is_cinema) {
#line 1504
    j = 0;
    {
#line 1504
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1504
      if (! (j < numcomps)) {
#line 1504
        goto while_break___4;
      }
      {
#line 1505
      scale_component(image->comps + j, (OPJ_UINT32 )12);
      }
#line 1504
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1508
  if (target_bitdepth > 0U) {
#line 1508
    if (target_bitdepth != (unsigned int )tiBps) {
#line 1509
      j = 0;
      {
#line 1509
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1509
        if (! (j < numcomps)) {
#line 1509
          goto while_break___5;
        }
        {
#line 1510
        scale_component(image->comps + j, target_bitdepth);
        }
#line 1509
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 1513
  return (image);
}
}
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 57
  l = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (a > 1)) {
#line 57
      goto while_break;
    }
#line 58
    a >>= 1;
#line 57
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (l);
}
}
#line 64 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
void clip_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_UINT32 umax ;
  OPJ_INT32 *l_data ;
  OPJ_INT32 max ;
  OPJ_INT32 min ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 68
  umax = (OPJ_UINT32 )((OPJ_INT32 )(- 1));
#line 70
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 71
  if (precision < 32U) {
#line 72
    umax = (1U << precision) - 1U;
  }
#line 75
  if (component->sgnd) {
#line 76
    l_data = component->data;
#line 77
    max = (OPJ_INT32 )(umax / 2U);
#line 78
    min = - max - 1;
#line 79
    i = (OPJ_SIZE_T )0;
    {
#line 79
    while (1) {
      while_continue: /* CIL Label */ ;
#line 79
      if (! (i < len)) {
#line 79
        goto while_break;
      }
#line 80
      if (*(l_data + i) > max) {
#line 81
        *(l_data + i) = max;
      } else
#line 82
      if (*(l_data + i) < min) {
#line 83
        *(l_data + i) = min;
      }
#line 79
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 87
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 88
    i = (OPJ_SIZE_T )0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (i < len)) {
#line 88
        goto while_break___0;
      }
#line 89
      if (*(l_data___0 + i) > umax) {
#line 90
        *(l_data___0 + i) = umax;
      }
#line 88
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 94
  component->prec = precision;
  return;
}
}
#line 98 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void scale_component_up(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_INT64 newMax ;
  OPJ_INT64 oldMax ;
  OPJ_INT32 *l_data ;
  OPJ_UINT64 newMax___0 ;
  OPJ_UINT64 oldMax___0 ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 103
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 104
  if (component->sgnd) {
#line 105
    newMax = (OPJ_INT64 )(1U << (precision - 1U));
#line 106
    oldMax = (OPJ_INT64 )(1U << (component->prec - 1U));
#line 107
    l_data = component->data;
#line 108
    i = (OPJ_SIZE_T )0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (! (i < len)) {
#line 108
        goto while_break;
      }
#line 109
      *(l_data + i) = (OPJ_INT32 )(((OPJ_INT64 )*(l_data + i) * newMax) / oldMax);
#line 108
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 112
    newMax___0 = (OPJ_UINT64 )((1U << precision) - 1U);
#line 113
    oldMax___0 = (OPJ_UINT64 )((1U << component->prec) - 1U);
#line 114
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 115
    i = (OPJ_SIZE_T )0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (i < len)) {
#line 115
        goto while_break___0;
      }
#line 116
      *(l_data___0 + i) = (OPJ_UINT32 )(((OPJ_UINT64 )*(l_data___0 + i) * newMax___0) / oldMax___0);
#line 115
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 119
  component->prec = precision;
  return;
}
}
#line 121 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
void scale_component(opj_image_comp_t *component , OPJ_UINT32 precision ) 
{ 
  int shift ;
  OPJ_SIZE_T i ;
  OPJ_SIZE_T len ;
  OPJ_INT32 *l_data ;
  OPJ_UINT32 *l_data___0 ;

  {
#line 126
  if (component->prec == precision) {
#line 127
    return;
  }
#line 129
  if (component->prec < precision) {
    {
#line 130
    scale_component_up(component, precision);
    }
#line 131
    return;
  }
#line 133
  shift = (int )(component->prec - precision);
#line 134
  len = (OPJ_SIZE_T )component->w * (OPJ_SIZE_T )component->h;
#line 135
  if (component->sgnd) {
#line 136
    l_data = component->data;
#line 137
    i = (OPJ_SIZE_T )0;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! (i < len)) {
#line 137
        goto while_break;
      }
#line 138
      *(l_data + i) >>= shift;
#line 137
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 141
    l_data___0 = (OPJ_UINT32 *)component->data;
#line 142
    i = (OPJ_SIZE_T )0;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! (i < len)) {
#line 142
        goto while_break___0;
      }
#line 143
      *(l_data___0 + i) >>= shift;
#line 142
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 146
  component->prec = precision;
  return;
}
}
#line 152 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_C1P1(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 


  {
  {
#line 155
  memcpy(*(pDst + 0), pSrc, length * sizeof(OPJ_INT32 ));
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_C2P2(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;
  OPJ_SIZE_T __cil_tmp7 ;

  {
#line 161
  pDst0 = *(pDst + 0);
#line 162
  pDst1 = *(pDst + 1);
#line 164
  i = (OPJ_SIZE_T )0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < length)) {
#line 164
      goto while_break;
    }
#line 165
    *(pDst0 + i) = *(pSrc + 2UL * i);
#line 166
    *(pDst1 + i) = *(pSrc + (2UL * i + 1UL));
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 169 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_C3P3(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;
  OPJ_INT32 *pDst2 ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
#line 173
  pDst0 = *(pDst + 0);
#line 174
  pDst1 = *(pDst + 1);
#line 175
  pDst2 = *(pDst + 2);
#line 177
  i = (OPJ_SIZE_T )0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < length)) {
#line 177
      goto while_break;
    }
#line 178
    *(pDst0 + i) = *(pSrc + 3UL * i);
#line 179
    *(pDst1 + i) = *(pSrc + (3UL * i + 1UL));
#line 180
    *(pDst2 + i) = *(pSrc + (3UL * i + 2UL));
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 183 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_C4P4(OPJ_INT32 *pSrc , OPJ_INT32 * const  *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pDst0 ;
  OPJ_INT32 *pDst1 ;
  OPJ_INT32 *pDst2 ;
  OPJ_INT32 *pDst3 ;
  OPJ_SIZE_T __cil_tmp9 ;

  {
#line 187
  pDst0 = *(pDst + 0);
#line 188
  pDst1 = *(pDst + 1);
#line 189
  pDst2 = *(pDst + 2);
#line 190
  pDst3 = *(pDst + 3);
#line 192
  i = (OPJ_SIZE_T )0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < length)) {
#line 192
      goto while_break;
    }
#line 193
    *(pDst0 + i) = *(pSrc + 4UL * i);
#line 194
    *(pDst1 + i) = *(pSrc + (4UL * i + 1UL));
#line 195
    *(pDst2 + i) = *(pSrc + (4UL * i + 2UL));
#line 196
    *(pDst3 + i) = *(pSrc + (4UL * i + 3UL));
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 199 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
convert_32s_CXPX convert_32s_CXPX_LUT[5]  = {      (convert_32s_CXPX )((void *)0),      & convert_32s_C1P1,      & convert_32s_C2P2,      & convert_32s_C3P3, 
        & convert_32s_C4P4};
#line 207 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_P1C1(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_SIZE_T __cil_tmp7 ;

  {
#line 211
  pSrc0 = *(pSrc + 0);
#line 213
  i = (OPJ_SIZE_T )0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < length)) {
#line 213
      goto while_break;
    }
#line 214
    *(pDst + i) = *(pSrc0 + i) + adjust;
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 217 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_P2C2(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;
  OPJ_SIZE_T __cil_tmp8 ;

  {
#line 221
  pSrc0 = *(pSrc + 0);
#line 222
  pSrc1 = *(pSrc + 1);
#line 224
  i = (OPJ_SIZE_T )0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < length)) {
#line 224
      goto while_break;
    }
#line 225
    *(pDst + 2UL * i) = *(pSrc0 + i) + adjust;
#line 226
    *(pDst + (2UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 229 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_P3C3(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;
  OPJ_INT32 *pSrc2 ;
  OPJ_SIZE_T __cil_tmp9 ;

  {
#line 233
  pSrc0 = *(pSrc + 0);
#line 234
  pSrc1 = *(pSrc + 1);
#line 235
  pSrc2 = *(pSrc + 2);
#line 237
  i = (OPJ_SIZE_T )0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < length)) {
#line 237
      goto while_break;
    }
#line 238
    *(pDst + 3UL * i) = *(pSrc0 + i) + adjust;
#line 239
    *(pDst + (3UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 240
    *(pDst + (3UL * i + 2UL)) = *(pSrc2 + i) + adjust;
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 243 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s_P4C4(OPJ_INT32 * const  *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ,
                             OPJ_INT32 adjust ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_INT32 *pSrc0 ;
  OPJ_INT32 *pSrc1 ;
  OPJ_INT32 *pSrc2 ;
  OPJ_INT32 *pSrc3 ;
  OPJ_SIZE_T __cil_tmp10 ;

  {
#line 247
  pSrc0 = *(pSrc + 0);
#line 248
  pSrc1 = *(pSrc + 1);
#line 249
  pSrc2 = *(pSrc + 2);
#line 250
  pSrc3 = *(pSrc + 3);
#line 252
  i = (OPJ_SIZE_T )0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < length)) {
#line 252
      goto while_break;
    }
#line 253
    *(pDst + 4UL * i) = *(pSrc0 + i) + adjust;
#line 254
    *(pDst + (4UL * i + 1UL)) = *(pSrc1 + i) + adjust;
#line 255
    *(pDst + (4UL * i + 2UL)) = *(pSrc2 + i) + adjust;
#line 256
    *(pDst + (4UL * i + 3UL)) = *(pSrc3 + i) + adjust;
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 259 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
convert_32s_PXCX convert_32s_PXCX_LUT[5]  = {      (convert_32s_PXCX )((void *)0),      & convert_32s_P1C1,      & convert_32s_P2C2,      & convert_32s_P3C3, 
        & convert_32s_P4C4};
#line 269 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_1u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 273
  i = (OPJ_SIZE_T )0;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 273
      goto while_break;
    }
#line 274
    __cil_tmp6 = pSrc;
#line 274
    pSrc ++;
#line 274
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 275
    *(pDst + i) = (OPJ_INT32 )(val >> 7);
#line 276
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val >> 6) & 1U);
#line 277
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val >> 5) & 1U);
#line 278
    *(pDst + (i + 3UL)) = (OPJ_INT32 )((val >> 4) & 1U);
#line 279
    *(pDst + (i + 4UL)) = (OPJ_INT32 )((val >> 3) & 1U);
#line 280
    *(pDst + (i + 5UL)) = (OPJ_INT32 )((val >> 2) & 1U);
#line 281
    *(pDst + (i + 6UL)) = (OPJ_INT32 )((val >> 1) & 1U);
#line 282
    *(pDst + (i + 7UL)) = (OPJ_INT32 )(val & 1U);
#line 273
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  if (length & 7UL) {
#line 285
    __cil_tmp8 = pSrc;
#line 285
    pSrc ++;
#line 285
    val___0 = (OPJ_UINT32 )*__cil_tmp8;
#line 286
    length &= 7UL;
#line 287
    *(pDst + i) = (OPJ_INT32 )(val___0 >> 7);
#line 289
    if (length > 1UL) {
#line 290
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((val___0 >> 6) & 1U);
#line 291
      if (length > 2UL) {
#line 292
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((val___0 >> 5) & 1U);
#line 293
        if (length > 3UL) {
#line 294
          *(pDst + (i + 3UL)) = (OPJ_INT32 )((val___0 >> 4) & 1U);
#line 295
          if (length > 4UL) {
#line 296
            *(pDst + (i + 4UL)) = (OPJ_INT32 )((val___0 >> 3) & 1U);
#line 297
            if (length > 5UL) {
#line 298
              *(pDst + (i + 5UL)) = (OPJ_INT32 )((val___0 >> 2) & 1U);
#line 299
              if (length > 6UL) {
#line 300
                *(pDst + (i + 6UL)) = (OPJ_INT32 )((val___0 >> 1) & 1U);
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 309 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_2u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 313
  i = (OPJ_SIZE_T )0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 313
      goto while_break;
    }
#line 314
    __cil_tmp6 = pSrc;
#line 314
    pSrc ++;
#line 314
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 315
    *(pDst + i) = (OPJ_INT32 )(val >> 6);
#line 316
    *(pDst + (i + 1UL)) = (OPJ_INT32 )((val >> 4) & 3U);
#line 317
    *(pDst + (i + 2UL)) = (OPJ_INT32 )((val >> 2) & 3U);
#line 318
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(val & 3U);
#line 313
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  if (length & 3UL) {
#line 321
    __cil_tmp8 = pSrc;
#line 321
    pSrc ++;
#line 321
    val___0 = (OPJ_UINT32 )*__cil_tmp8;
#line 322
    length &= 3UL;
#line 323
    *(pDst + i) = (OPJ_INT32 )(val___0 >> 6);
#line 325
    if (length > 1UL) {
#line 326
      *(pDst + (i + 1UL)) = (OPJ_INT32 )((val___0 >> 4) & 3U);
#line 327
      if (length > 2UL) {
#line 328
        *(pDst + (i + 2UL)) = (OPJ_INT32 )((val___0 >> 2) & 3U);
      }
    }
  }
  return;
}
}
#line 334 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_4u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT8 val___0 ;
  OPJ_BYTE *__cil_tmp8 ;

  {
#line 338
  i = (OPJ_SIZE_T )0;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 338
      goto while_break;
    }
#line 339
    __cil_tmp6 = pSrc;
#line 339
    pSrc ++;
#line 339
    val = (OPJ_UINT32 )*__cil_tmp6;
#line 340
    *(pDst + i) = (OPJ_INT32 )(val >> 4);
#line 341
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(val & 15U);
#line 338
    i += (unsigned long )2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (length & 1UL) {
#line 344
    __cil_tmp8 = pSrc;
#line 344
    pSrc ++;
#line 344
    val___0 = *__cil_tmp8;
#line 345
    *(pDst + i) = (OPJ_INT32 )((int )val___0 >> 4);
  }
  return;
}
}
#line 348 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_6u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 val0 ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_UINT32 val1 ;
  OPJ_BYTE *__cil_tmp8 ;
  OPJ_UINT32 val2 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_UINT32 val0___0 ;
  OPJ_BYTE *__cil_tmp12 ;
  OPJ_UINT32 val1___0 ;
  OPJ_BYTE *__cil_tmp14 ;
  OPJ_UINT32 val2___0 ;
  OPJ_BYTE *__cil_tmp16 ;

  {
#line 352
  i = (OPJ_SIZE_T )0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 352
      goto while_break;
    }
#line 353
    __cil_tmp6 = pSrc;
#line 353
    pSrc ++;
#line 353
    val0 = (OPJ_UINT32 )*__cil_tmp6;
#line 354
    __cil_tmp8 = pSrc;
#line 354
    pSrc ++;
#line 354
    val1 = (OPJ_UINT32 )*__cil_tmp8;
#line 355
    __cil_tmp10 = pSrc;
#line 355
    pSrc ++;
#line 355
    val2 = (OPJ_UINT32 )*__cil_tmp10;
#line 356
    *(pDst + i) = (OPJ_INT32 )(val0 >> 2);
#line 357
    *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0 & 3U) << 4) | (val1 >> 4));
#line 358
    *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1 & 15U) << 2) | (val2 >> 6));
#line 359
    *(pDst + (i + 3UL)) = (OPJ_INT32 )(val2 & 63U);
#line 352
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if (length & 3UL) {
#line 363
    __cil_tmp12 = pSrc;
#line 363
    pSrc ++;
#line 363
    val0___0 = (OPJ_UINT32 )*__cil_tmp12;
#line 364
    length &= 3UL;
#line 365
    *(pDst + i) = (OPJ_INT32 )(val0___0 >> 2);
#line 367
    if (length > 1UL) {
#line 368
      __cil_tmp14 = pSrc;
#line 368
      pSrc ++;
#line 368
      val1___0 = (OPJ_UINT32 )*__cil_tmp14;
#line 369
      *(pDst + (i + 1UL)) = (OPJ_INT32 )(((val0___0 & 3U) << 4) | (val1___0 >> 4));
#line 370
      if (length > 2UL) {
#line 371
        __cil_tmp16 = pSrc;
#line 371
        pSrc ++;
#line 371
        val2___0 = (OPJ_UINT32 )*__cil_tmp16;
#line 372
        *(pDst + (i + 2UL)) = (OPJ_INT32 )(((val1___0 & 15U) << 2) | (val2___0 >> 6));
      }
    }
  }
  return;
}
}
#line 377 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_8u32s_C1R(OPJ_BYTE *pSrc , OPJ_INT32 *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_SIZE_T __cil_tmp5 ;

  {
#line 381
  i = (OPJ_SIZE_T )0;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < length)) {
#line 381
      goto while_break;
    }
#line 382
    *(pDst + i) = (OPJ_INT32 )*(pSrc + i);
#line 381
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 385 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9]  = 
#line 385
  {      (convert_XXx32s_C1R )((void *)0),      & convert_1u32s_C1R,      & convert_2u32s_C1R,      (convert_XXx32s_C1R )((void *)0), 
        & convert_4u32s_C1R,      (convert_XXx32s_C1R )((void *)0),      & convert_6u32s_C1R,      (convert_XXx32s_C1R )((void *)0), 
        & convert_8u32s_C1R};
#line 398 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s1u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_UINT32 src4 ;
  OPJ_UINT32 src5 ;
  OPJ_UINT32 src6 ;
  OPJ_UINT32 src7 ;
  OPJ_BYTE *__cil_tmp13 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_UINT32 src3___0 ;
  OPJ_UINT32 src4___0 ;
  OPJ_UINT32 src5___0 ;
  OPJ_UINT32 src6___0 ;
  OPJ_BYTE *__cil_tmp21 ;

  {
#line 402
  i = (OPJ_SIZE_T )0;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < (length & 0xfffffffffffffff8UL))) {
#line 402
      goto while_break;
    }
#line 403
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 404
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 405
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 406
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 407
    src4 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 408
    src5 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 409
    src6 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
#line 410
    src7 = (OPJ_UINT32 )*(pSrc + (i + 7UL));
#line 412
    __cil_tmp13 = pDst;
#line 412
    pDst ++;
#line 412
    *__cil_tmp13 = (OPJ_BYTE )((((((((src0 << 7) | (src1 << 6)) | (src2 << 5)) | (src3 << 4)) | (src4 << 3)) | (src5 << 2)) | (src6 << 1)) | src7);
#line 402
    i += (unsigned long )8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  if (length & 7UL) {
#line 417
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 418
    src1___0 = 0U;
#line 419
    src2___0 = 0U;
#line 420
    src3___0 = 0U;
#line 421
    src4___0 = 0U;
#line 422
    src5___0 = 0U;
#line 423
    src6___0 = 0U;
#line 424
    length &= 7UL;
#line 426
    if (length > 1UL) {
#line 427
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 428
      if (length > 2UL) {
#line 429
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 430
        if (length > 3UL) {
#line 431
          src3___0 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 432
          if (length > 4UL) {
#line 433
            src4___0 = (OPJ_UINT32 )*(pSrc + (i + 4UL));
#line 434
            if (length > 5UL) {
#line 435
              src5___0 = (OPJ_UINT32 )*(pSrc + (i + 5UL));
#line 436
              if (length > 6UL) {
#line 437
                src6___0 = (OPJ_UINT32 )*(pSrc + (i + 6UL));
              }
            }
          }
        }
      }
    }
#line 444
    __cil_tmp21 = pDst;
#line 444
    pDst ++;
#line 444
    *__cil_tmp21 = (OPJ_BYTE )(((((((src0___0 << 7) | (src1___0 << 6)) | (src2___0 << 5)) | (src3___0 << 4)) | (src4___0 << 3)) | (src5___0 << 2)) | (src6___0 << 1));
  }
  return;
}
}
#line 449 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s2u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp13 ;

  {
#line 453
  i = (OPJ_SIZE_T )0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 453
      goto while_break;
    }
#line 454
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 455
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 456
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 457
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 459
    __cil_tmp9 = pDst;
#line 459
    pDst ++;
#line 459
    *__cil_tmp9 = (OPJ_BYTE )((((src0 << 6) | (src1 << 4)) | (src2 << 2)) | src3);
#line 453
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (length & 3UL) {
#line 463
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 464
    src1___0 = 0U;
#line 465
    src2___0 = 0U;
#line 466
    length &= 3UL;
#line 468
    if (length > 1UL) {
#line 469
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 470
      if (length > 2UL) {
#line 471
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 474
    __cil_tmp13 = pDst;
#line 474
    pDst ++;
#line 474
    *__cil_tmp13 = (OPJ_BYTE )(((src0___0 << 6) | (src1___0 << 4)) | (src2___0 << 2));
  }
  return;
}
}
#line 478 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s4u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_BYTE *__cil_tmp7 ;
  OPJ_UINT32 src0___0 ;
  OPJ_BYTE *__cil_tmp9 ;

  {
#line 482
  i = (OPJ_SIZE_T )0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < (length & 0xfffffffffffffffeUL))) {
#line 482
      goto while_break;
    }
#line 483
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 484
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 486
    __cil_tmp7 = pDst;
#line 486
    pDst ++;
#line 486
    *__cil_tmp7 = (OPJ_BYTE )((src0 << 4) | src1);
#line 482
    i += (unsigned long )2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if (length & 1UL) {
#line 490
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 491
    __cil_tmp9 = pDst;
#line 491
    pDst ++;
#line 491
    *__cil_tmp9 = (OPJ_BYTE )(src0___0 << 4);
  }
  return;
}
}
#line 495 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s6u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;
  OPJ_UINT32 src0 ;
  OPJ_UINT32 src1 ;
  OPJ_UINT32 src2 ;
  OPJ_UINT32 src3 ;
  OPJ_BYTE *__cil_tmp9 ;
  OPJ_BYTE *__cil_tmp10 ;
  OPJ_BYTE *__cil_tmp11 ;
  OPJ_UINT32 src0___0 ;
  OPJ_UINT32 src1___0 ;
  OPJ_UINT32 src2___0 ;
  OPJ_BYTE *__cil_tmp15 ;
  OPJ_BYTE *__cil_tmp16 ;
  OPJ_BYTE *__cil_tmp17 ;

  {
#line 499
  i = (OPJ_SIZE_T )0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < (length & 0xfffffffffffffffcUL))) {
#line 499
      goto while_break;
    }
#line 500
    src0 = (OPJ_UINT32 )*(pSrc + i);
#line 501
    src1 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 502
    src2 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
#line 503
    src3 = (OPJ_UINT32 )*(pSrc + (i + 3UL));
#line 505
    __cil_tmp9 = pDst;
#line 505
    pDst ++;
#line 505
    *__cil_tmp9 = (OPJ_BYTE )((src0 << 2) | (src1 >> 4));
#line 506
    __cil_tmp10 = pDst;
#line 506
    pDst ++;
#line 506
    *__cil_tmp10 = (OPJ_BYTE )(((src1 & 15U) << 4) | (src2 >> 2));
#line 507
    __cil_tmp11 = pDst;
#line 507
    pDst ++;
#line 507
    *__cil_tmp11 = (OPJ_BYTE )(((src2 & 3U) << 6) | src3);
#line 499
    i += (unsigned long )4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  if (length & 3UL) {
#line 511
    src0___0 = (OPJ_UINT32 )*(pSrc + i);
#line 512
    src1___0 = 0U;
#line 513
    src2___0 = 0U;
#line 514
    length &= 3UL;
#line 516
    if (length > 1UL) {
#line 517
      src1___0 = (OPJ_UINT32 )*(pSrc + (i + 1UL));
#line 518
      if (length > 2UL) {
#line 519
        src2___0 = (OPJ_UINT32 )*(pSrc + (i + 2UL));
      }
    }
#line 522
    __cil_tmp15 = pDst;
#line 522
    pDst ++;
#line 522
    *__cil_tmp15 = (OPJ_BYTE )((src0___0 << 2) | (src1___0 >> 4));
#line 523
    if (length > 1UL) {
#line 524
      __cil_tmp16 = pDst;
#line 524
      pDst ++;
#line 524
      *__cil_tmp16 = (OPJ_BYTE )(((src1___0 & 15U) << 4) | (src2___0 >> 2));
#line 525
      if (length > 2UL) {
#line 526
        __cil_tmp17 = pDst;
#line 526
        pDst ++;
#line 526
        *__cil_tmp17 = (OPJ_BYTE )((src2___0 & 3U) << 6);
      }
    }
  }
  return;
}
}
#line 531 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void convert_32s8u_C1R(OPJ_INT32 *pSrc , OPJ_BYTE *pDst , OPJ_SIZE_T length ) 
{ 
  OPJ_SIZE_T i ;

  {
#line 535
  i = (OPJ_SIZE_T )0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < length)) {
#line 535
      goto while_break;
    }
#line 536
    *(pDst + i) = (OPJ_BYTE )*(pSrc + i);
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 539 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9]  = 
#line 539
  {      (convert_32sXXx_C1R )((void *)0),      & convert_32s1u_C1R,      & convert_32s2u_C1R,      (convert_32sXXx_C1R )((void *)0), 
        & convert_32s4u_C1R,      (convert_32sXXx_C1R )((void *)0),      & convert_32s6u_C1R,      (convert_32sXXx_C1R )((void *)0), 
        & convert_32s8u_C1R};
#line 582 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static unsigned short get_tga_ushort(unsigned char const   *data ) 
{ 


  {
#line 584
  return ((unsigned short )((int )*(data + 0) | ((int )*(data + 1) << 8)));
}
}
#line 589 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char tga[18] ;
  unsigned char id_len ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned long __cil_tmp16 ;
  unsigned short __cil_tmp17 ;
  unsigned short __cil_tmp18 ;
  unsigned short __cil_tmp19 ;
  unsigned char *id ;
  void *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;

  {
#line 599
  if (! bits_per_pixel) {
#line 600
    return (0);
  } else
#line 599
  if (! width) {
#line 600
    return (0);
  } else
#line 599
  if (! height) {
#line 600
    return (0);
  } else
#line 599
  if (! flip_image) {
#line 600
    return (0);
  }
  {
#line 603
  __cil_tmp16 = fread((unsigned char *)tga, (unsigned long )18, (unsigned long )1,
                      fp);
  }
#line 603
  if (__cil_tmp16 != 1UL) {
    {
#line 604
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 606
    return (0);
  }
  {
#line 608
  id_len = tga[0];
#line 610
  image_type = tga[2];
#line 612
  cmap_len = get_tga_ushort((unsigned char const   *)(& tga[5]));
#line 613
  cmap_entry_size = (unsigned short )tga[7];
#line 620
  image_w = get_tga_ushort((unsigned char const   *)(& tga[12]));
#line 621
  image_h = get_tga_ushort((unsigned char const   *)(& tga[14]));
#line 622
  pixel_depth = tga[16];
#line 623
  image_desc = tga[17];
#line 625
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 626
  *width = (unsigned int )image_w;
#line 627
  *height = (unsigned int )image_h;
  }
#line 630
  if (id_len) {
    {
#line 631
    __cil_tmp21 = malloc((unsigned long )id_len);
#line 631
    id = (unsigned char *)__cil_tmp21;
    }
#line 632
    if (id == (unsigned char *)0) {
      {
#line 633
      fprintf(stderr, "tga_readheader: memory out\n");
      }
#line 634
      return (0);
    }
    {
#line 636
    __cil_tmp22 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 636
    if (! __cil_tmp22) {
      {
#line 637
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 639
      free(id);
      }
#line 640
      return (0);
    }
    {
#line 642
    free(id);
    }
  }
#line 648
  if ((int )image_type > 8) {
    {
#line 649
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 650
    return (0);
  }
#line 653
  *flip_image = ! ((int )image_desc & 32);
#line 656
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 658
  if (palette_size > 0) {
    {
#line 659
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 660
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 662
  return (1);
}
}
#line 674 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           OPJ_BOOL flip_image ) 
{ 
  OPJ_UINT16 image_w ;
  OPJ_UINT16 image_h ;
  OPJ_UINT16 us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 681
  if (! bits_per_pixel) {
#line 682
    return (0);
  } else
#line 681
  if (! width) {
#line 682
    return (0);
  } else
#line 681
  if (! height) {
#line 682
    return (0);
  }
#line 685
  pixel_depth = (unsigned char )0;
#line 687
  if (bits_per_pixel < 256) {
#line 688
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 690
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerV");
    }
#line 691
    return (0);
  }
  {
#line 693
  uc0 = (unsigned char )0;
#line 695
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 695
  if (__cil_tmp13 != 1UL) {
#line 696
    goto fails;
  }
  {
#line 698
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 698
  if (__cil_tmp14 != 1UL) {
#line 699
    goto fails;
  }
  {
#line 702
  image_type = (unsigned char )2;
#line 703
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 703
  if (__cil_tmp15 != 1UL) {
#line 704
    goto fails;
  }
  {
#line 707
  us0 = (OPJ_UINT16 )0;
#line 708
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 708
  if (__cil_tmp16 != 1UL) {
#line 709
    goto fails;
  }
  {
#line 711
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 711
  if (__cil_tmp17 != 1UL) {
#line 712
    goto fails;
  }
  {
#line 714
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 714
  if (__cil_tmp18 != 1UL) {
#line 715
    goto fails;
  }
  {
#line 718
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 718
  if (__cil_tmp19 != 1UL) {
#line 719
    goto fails;
  }
  {
#line 721
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 721
  if (__cil_tmp20 != 1UL) {
#line 722
    goto fails;
  }
  {
#line 725
  image_w = (unsigned short )width;
#line 726
  image_h = (unsigned short )height;
#line 729
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 729
  if (__cil_tmp21 != 1UL) {
#line 730
    goto fails;
  }
  {
#line 732
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 732
  if (__cil_tmp22 != 1UL) {
#line 733
    goto fails;
  }
  {
#line 746
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 746
  if (__cil_tmp23 != 1UL) {
#line 747
    goto fails;
  }
#line 750
  image_desc = (unsigned char )8;
#line 752
  if (flip_image) {
#line 753
    image_desc |= 32;
  }
  {
#line 755
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 755
  if (__cil_tmp24 != 1UL) {
#line 756
    goto fails;
  }
#line 759
  return (1);
  fails: 
  {
#line 762
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 763
  return (0);
}
}
#line 766 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  OPJ_BOOL mono ;
  OPJ_BOOL save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  char ch ;
  OPJ_UINT64 expected_file_size ;
  long curpos ;
  long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  opj_image_t *__cil_tmp29 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  int index___0 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned int __cil_tmp40 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  unsigned long __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;

  {
  {
#line 772
  flip_image = 0;
#line 781
  f = fopen(filename, "rb\t\177EV");
  }
#line 782
  if (! f) {
    {
#line 783
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 784
    return ((opj_image_t *)0);
  }
  {
#line 787
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 787
  if (! __cil_tmp20) {
    {
#line 789
    fclose(f);
    }
#line 790
    return ((opj_image_t *)((void *)0));
  }
#line 794
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
    {
#line 795
    fclose(f);
    }
#line 796
    return ((opj_image_t *)((void *)0));
  }
  {
#line 800
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 802
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 804
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 807
  if (mono) {
#line 808
    color_space = (OPJ_COLOR_SPACE )2;
#line 809
    if (save_alpha) {
#line 809
      tmp = 2;
    } else {
#line 809
      tmp = 1;
    }
#line 809
    numcomps = tmp;
  } else {
#line 811
    if (save_alpha) {
#line 811
      tmp___0 = 4;
    } else {
#line 811
      tmp___0 = 3;
    }
#line 811
    numcomps = tmp___0;
#line 812
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 817
  if (image_height != 0U) {
#line 817
    if (image_width > (10000000U / image_height) / (OPJ_UINT32 )numcomps) {
      {
#line 820
      expected_file_size = ((OPJ_UINT64 )image_width * (unsigned long )image_height) * (unsigned long )((OPJ_UINT32 )numcomps);
#line 822
      __cil_tmp26 = ftell(f);
#line 822
      curpos = __cil_tmp26;
      }
#line 823
      if (expected_file_size > 2147483647UL) {
#line 824
        expected_file_size = (OPJ_UINT64 )2147483647;
      }
      {
#line 826
      fseek(f, (long )expected_file_size - 1L, 0);
#line 827
      __cil_tmp27 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
      }
#line 827
      if (__cil_tmp27 != 1UL) {
        {
#line 828
        fclose(f);
        }
#line 829
        return ((opj_image_t *)((void *)0));
      }
      {
#line 831
      fseek(f, curpos, 0);
      }
    }
  }
#line 834
  subsampling_dx = parameters->subsampling_dx;
#line 835
  subsampling_dy = parameters->subsampling_dy;
#line 837
  i = 0;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    if (! (i < numcomps)) {
#line 837
      goto while_break;
    }
#line 838
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 839
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 840
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 841
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 842
    cmptparm[i].w = image_width;
#line 843
    cmptparm[i].h = image_height;
#line 837
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 849
  if (! image) {
    {
#line 850
    fclose(f);
    }
#line 851
    return ((opj_image_t *)((void *)0));
  }
#line 856
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 857
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 858
  if (! image->x0) {
#line 858
    tmp___1 = (OPJ_UINT32 )(image_width - 1U) * (OPJ_UINT32 )subsampling_dx + 1U;
  } else {
#line 858
    tmp___1 = (image->x0 + (OPJ_UINT32 )(image_width - 1U) * (OPJ_UINT32 )subsampling_dx) + 1U;
  }
#line 858
  image->x1 = tmp___1;
#line 861
  if (! image->y0) {
#line 861
    tmp___2 = (OPJ_UINT32 )(image_height - 1U) * (OPJ_UINT32 )subsampling_dy + 1U;
  } else {
#line 861
    tmp___2 = (image->y0 + (OPJ_UINT32 )(image_height - 1U) * (OPJ_UINT32 )subsampling_dy) + 1U;
  }
#line 861
  image->y1 = tmp___2;
#line 866
  y = (unsigned int )0;
  {
#line 866
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 866
    if (! (y < image_height)) {
#line 866
      goto while_break___0;
    }
#line 869
    if (flip_image) {
#line 870
      index___0 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 872
      index___0 = (int )(y * image_width);
    }
#line 875
    if (numcomps == 3) {
#line 876
      x = (unsigned int )0;
      {
#line 876
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 876
        if (! (x < image_width)) {
#line 876
          goto while_break___1;
        }
        {
#line 879
        __cil_tmp36 = fread(& b, (unsigned long )1, (unsigned long )1, f);
        }
#line 879
        if (! __cil_tmp36) {
          {
#line 880
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 882
          opj_image_destroy(image);
#line 883
          fclose(f);
          }
#line 884
          return ((opj_image_t *)((void *)0));
        }
        {
#line 886
        __cil_tmp37 = fread(& g, (unsigned long )1, (unsigned long )1, f);
        }
#line 886
        if (! __cil_tmp37) {
          {
#line 887
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 889
          opj_image_destroy(image);
#line 890
          fclose(f);
          }
#line 891
          return ((opj_image_t *)((void *)0));
        }
        {
#line 893
        __cil_tmp38 = fread(& r, (unsigned long )1, (unsigned long )1, f);
        }
#line 893
        if (! __cil_tmp38) {
          {
#line 894
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 896
          opj_image_destroy(image);
#line 897
          fclose(f);
          }
#line 898
          return ((opj_image_t *)((void *)0));
        }
#line 901
        *((image->comps + 0)->data + index___0) = (OPJ_INT32 )r;
#line 902
        *((image->comps + 1)->data + index___0) = (OPJ_INT32 )g;
#line 903
        *((image->comps + 2)->data + index___0) = (OPJ_INT32 )b;
#line 904
        index___0 ++;
#line 876
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 906
    if (numcomps == 4) {
#line 907
      x = (unsigned int )0;
      {
#line 907
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 907
        if (! (x < image_width)) {
#line 907
          goto while_break___2;
        }
        {
#line 909
        __cil_tmp45 = fread(& b___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 909
        if (! __cil_tmp45) {
          {
#line 910
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 912
          opj_image_destroy(image);
#line 913
          fclose(f);
          }
#line 914
          return ((opj_image_t *)((void *)0));
        }
        {
#line 916
        __cil_tmp46 = fread(& g___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 916
        if (! __cil_tmp46) {
          {
#line 917
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 919
          opj_image_destroy(image);
#line 920
          fclose(f);
          }
#line 921
          return ((opj_image_t *)((void *)0));
        }
        {
#line 923
        __cil_tmp47 = fread(& r___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 923
        if (! __cil_tmp47) {
          {
#line 924
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 926
          opj_image_destroy(image);
#line 927
          fclose(f);
          }
#line 928
          return ((opj_image_t *)((void *)0));
        }
        {
#line 930
        __cil_tmp48 = fread(& a, (unsigned long )1, (unsigned long )1, f);
        }
#line 930
        if (! __cil_tmp48) {
          {
#line 931
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 933
          opj_image_destroy(image);
#line 934
          fclose(f);
          }
#line 935
          return ((opj_image_t *)((void *)0));
        }
#line 938
        *((image->comps + 0)->data + index___0) = (OPJ_INT32 )r___0;
#line 939
        *((image->comps + 1)->data + index___0) = (OPJ_INT32 )g___0;
#line 940
        *((image->comps + 2)->data + index___0) = (OPJ_INT32 )b___0;
#line 941
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )a;
#line 942
        index___0 ++;
#line 907
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 945
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 866
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 948
  fclose(f);
  }
#line 949
  return (image);
}
}
#line 952 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  OPJ_BOOL write_alpha ;
  unsigned int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int fails ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  FILE *__cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___0 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 957
  adjustG = 0;
  {
#line 957
  adjustB = 0;
#line 964
  fails = 1;
#line 966
  fdest = fopen(outfile, "wbg\177EV");
  }
#line 967
  if (! fdest) {
    {
#line 968
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 969
    return (1);
  }
#line 972
  i = (unsigned int )0;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! (i < image->numcomps - 1U)) {
#line 972
      goto while_break;
    }
#line 973
    if ((image->comps + 0)->dx != (image->comps + (i + 1U))->dx) {
      {
      {
      {
      {
#line 977
      fclose(fdest);
      }
      }
      }
      {
      {
      {
#line 978
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
      }
      }
      }
#line 980
      return (1);
    } else
#line 973
    if ((image->comps + 0)->dy != (image->comps + (i + 1U))->dy) {
      {
      {
      {
      {
#line 977
      fclose(fdest);
      }
      }
      }
      {
      {
      {
#line 978
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
      }
      }
      }
#line 980
      return (1);
    } else
#line 973
    if ((image->comps + 0)->prec != (image->comps + (i + 1U))->prec) {
      {
      {
      {
      {
#line 977
      fclose(fdest);
      }
      }
      }
      {
      {
      {
#line 978
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
      }
      }
      }
#line 980
      return (1);
    } else
#line 973
    if ((image->comps + 0)->sgnd != (image->comps + (i + 1U))->sgnd) {
      {
      {
      {
      {
#line 977
      fclose(fdest);
      }
      }
      }
      {
      {
      {
#line 978
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.\n\220");
      }
      }
      }
      }
#line 980
      return (1);
    }
#line 972
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 984
  width = (int )(image->comps + 0)->w;
#line 985
  height = (int )(image->comps + 0)->h;
#line 988
  write_alpha = image->numcomps == 2U || image->numcomps == 4U;
#line 991
  if (write_alpha) {
#line 991
    tmp = 32;
  } else {
#line 991
    tmp = 24;
  }
  {
#line 991
  bpp = tmp;
#line 993
  __cil_tmp26 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 993
  if (! __cil_tmp26) {
#line 994
    goto fin;
  }
#line 997
  alpha_channel = image->numcomps - 1U;
#line 999
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 1001
  if ((image->comps + 0)->sgnd) {
#line 1001
    tmp___0 = 1 << ((image->comps + 0)->prec - 1U);
  } else {
#line 1001
    tmp___0 = 0;
  }
#line 1001
  adjustR = tmp___0;
#line 1002
  if (image->numcomps >= 3U) {
#line 1003
    if ((image->comps + 1)->sgnd) {
#line 1003
      tmp___1 = 1 << ((image->comps + 1)->prec - 1U);
    } else {
#line 1003
      tmp___1 = 0;
    }
#line 1003
    adjustG = tmp___1;
#line 1004
    if ((image->comps + 2)->sgnd) {
#line 1004
      tmp___2 = 1 << ((image->comps + 2)->prec - 1U);
    } else {
#line 1004
      tmp___2 = 0;
    }
#line 1004
    adjustB = tmp___2;
  }
#line 1007
  y = 0;
  {
#line 1007
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1007
    if (! (y < height)) {
#line 1007
      goto while_break___0;
    }
#line 1008
    index___0 = (unsigned int )(y * width);
#line 1010
    x = 0;
    {
#line 1010
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1010
      if (! (x < width)) {
#line 1010
        goto while_break___1;
      }
#line 1011
      r = (float )(*((image->comps + 0)->data + index___0) + adjustR);
#line 1013
      if (image->numcomps > 2U) {
#line 1014
        g = (float )(*((image->comps + 1)->data + index___0) + adjustG);
#line 1015
        b = (float )(*((image->comps + 2)->data + index___0) + adjustB);
      } else {
#line 1018
        g = r;
#line 1019
        b = r;
      }
#line 1023
      if ((double )b > 255.) {
#line 1024
        b = (float )255.;
      } else
#line 1025
      if ((double )b < 0.) {
#line 1026
        b = (float )0.;
      }
      {
#line 1028
      value = (unsigned char )(b * scale);
#line 1029
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 1031
      if (res < 1UL) {
        {
#line 1032
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1033
        goto fin;
      }
#line 1035
      if ((double )g > 255.) {
#line 1036
        g = (float )255.;
      } else
#line 1037
      if ((double )g < 0.) {
#line 1038
        g = (float )0.;
      }
      {
#line 1040
      value = (unsigned char )(g * scale);
#line 1041
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 1043
      if (res < 1UL) {
        {
#line 1044
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1045
        goto fin;
      }
#line 1047
      if ((double )r > 255.) {
#line 1048
        r = (float )255.;
      } else
#line 1049
      if ((double )r < 0.) {
#line 1050
        r = (float )0.;
      }
      {
#line 1052
      value = (unsigned char )(r * scale);
#line 1053
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 1055
      if (res < 1UL) {
        {
#line 1056
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 1057
        goto fin;
      }
#line 1060
      if (write_alpha) {
#line 1061
        a = (float )*((image->comps + alpha_channel)->data + index___0);
#line 1062
        if ((double )a > 255.) {
#line 1063
          a = (float )255.;
        } else
#line 1064
        if ((double )a < 0.) {
#line 1065
          a = (float )0.;
        }
        {
#line 1067
        value = (unsigned char )(a * scale);
#line 1068
        res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1070
        if (res < 1UL) {
          {
#line 1071
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 1072
          goto fin;
        }
      }
#line 1010
      __cil_tmp36 = index___0;
#line 1010
      index___0 ++;
#line 1010
      __cil_tmp35 = x;
#line 1010
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1007
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1077
  fails = 0;
  fin: 
  {
#line 1079
  fclose(fdest);
  }
#line 1081
  return (fails);
}
}
#line 1091 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1094
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1094
  if (! __cil_tmp3) {
    {
#line 1095
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1097
    return ((unsigned char )0);
  }
#line 1099
  return (c1);
}
}
#line 1102 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1105
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1105
  if (! __cil_tmp5) {
    {
#line 1106
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1108
    return ((unsigned short )0);
  }
  {
#line 1110
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1110
  if (! __cil_tmp6) {
    {
#line 1111
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1113
    return ((unsigned short )0);
  }
#line 1115
  if (bigendian) {
#line 1116
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1118
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1122 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1125
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1125
  if (! __cil_tmp7) {
    {
#line 1126
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1128
    return ((unsigned int )0);
  }
  {
#line 1130
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1130
  if (! __cil_tmp8) {
    {
#line 1131
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1133
    return ((unsigned int )0);
  }
  {
#line 1135
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1135
  if (! __cil_tmp9) {
    {
#line 1136
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1138
    return ((unsigned int )0);
  }
  {
#line 1140
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1140
  if (! __cil_tmp10) {
    {
#line 1141
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1143
    return ((unsigned int )0);
  }
#line 1145
  if (bigendian) {
#line 1146
    return ((((unsigned int )((int )c1 << 24) + (unsigned int )((int )c2 << 16)) + (unsigned int )((int )c3 << 8)) + (unsigned int )c4);
  } else {
#line 1149
    return ((((unsigned int )((int )c4 << 24) + (unsigned int )((int )c3 << 16)) + (unsigned int )((int )c2 << 8)) + (unsigned int )c1);
  }
}
}
#line 1154 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  OPJ_UINT64 expected_file_size ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int tmp ;
  int tmp___0 ;
  char ch ;
  long curpos ;
  long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  OPJ_UINT32 tmp___1 ;
  OPJ_UINT32 tmp___2 ;
  opj_image_t *__cil_tmp36 ;
  int v ;
  unsigned char __cil_tmp38 ;
  unsigned char __cil_tmp39 ;
  unsigned char __cil_tmp40 ;
  unsigned short __cil_tmp41 ;
  unsigned short __cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;

  {
  {
#line 1156
  f = (FILE *)((void *)0);
#line 1161
  image = (opj_image_t *)((void *)0);
#line 1170
  comp = (opj_image_comp_t *)((void *)0);
#line 1172
  numcomps = 1;
#line 1173
  color_space = (OPJ_COLOR_SPACE )2;
#line 1175
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1177
  max = 0;
#line 1179
  f = fopen(filename, "rb");
  }
#line 1180
  if (! f) {
    {
#line 1181
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1182
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1185
  fseek(f, (long )0, 0);
#line 1186
  __cil_tmp26 = fscanf(f, "PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d", (char *)temp,
                       & endian1, & endian2, (char *)signtmp, & prec, (char *)temp,
                       & w, (char *)temp, & h);
  }
#line 1186
  if (__cil_tmp26 != 9) {
    {
#line 1188
    fclose(f);
#line 1189
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1191
    return ((opj_image_t *)((void *)0));
  }
#line 1194
  i = 0;
#line 1195
  sign = (char )'+';
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! ((int )signtmp[i] != 0)) {
#line 1196
      goto while_break;
    }
#line 1197
    if ((int )signtmp[i] == 45) {
#line 1198
      sign = (char )'-';
    }
#line 1200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1203
  fgetc(f);
  }
#line 1204
  if ((int )endian1 == 77) {
#line 1204
    if ((int )endian2 == 76) {
#line 1205
      bigendian = 1;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1206
  if ((int )endian2 == 77) {
#line 1206
    if ((int )endian1 == 76) {
#line 1207
      bigendian = 0;
    } else {
      {
      {
#line 1209
      fclose(f);
      }
      {
#line 1210
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      }
#line 1211
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1209
    fclose(f);
    }
    {
#line 1210
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
#line 1211
    return ((opj_image_t *)((void *)0));
  }
#line 1214
  if (w < 1) {
    {
    {
    {
    {
#line 1215
    fclose(f);
    }
    }
    }
    {
    {
    {
#line 1216
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
    }
    }
#line 1217
    return ((opj_image_t *)((void *)0));
  } else
#line 1214
  if (h < 1) {
    {
    {
    {
    {
#line 1215
    fclose(f);
    }
    }
    }
    {
    {
    {
#line 1216
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
    }
    }
#line 1217
    return ((opj_image_t *)((void *)0));
  } else
#line 1214
  if (prec < 1) {
    {
    {
    {
    {
#line 1215
    fclose(f);
    }
    }
    }
    {
    {
    {
#line 1216
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
    }
    }
#line 1217
    return ((opj_image_t *)((void *)0));
  } else
#line 1214
  if (prec > 31) {
    {
    {
    {
    {
#line 1215
    fclose(f);
    }
    }
    }
    {
    {
    {
#line 1216
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
    }
    }
#line 1217
    return ((opj_image_t *)((void *)0));
  }
#line 1220
  if (prec > 16) {
#line 1220
    tmp___0 = 4;
  } else {
#line 1220
    if (prec > 8) {
#line 1220
      tmp = 2;
    } else {
#line 1220
      tmp = 1;
    }
#line 1220
    tmp___0 = tmp;
  }
#line 1220
  expected_file_size = ((OPJ_UINT64 )w * (OPJ_UINT64 )h) * (unsigned long )tmp___0;
#line 1222
  if (expected_file_size > 10000000UL) {
    {
#line 1224
    __cil_tmp32 = ftell(f);
#line 1224
    curpos = __cil_tmp32;
    }
#line 1225
    if (expected_file_size > 2147483647UL) {
#line 1226
      expected_file_size = (OPJ_UINT64 )2147483647;
    }
    {
#line 1228
    fseek(f, (long )expected_file_size - 1L, 0);
#line 1229
    __cil_tmp33 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
    }
#line 1229
    if (__cil_tmp33 != 1UL) {
      {
#line 1230
      fprintf(stderr, "File too short\n");
#line 1231
      fclose(f);
      }
#line 1232
      return ((opj_image_t *)((void *)0));
    }
    {
#line 1234
    fseek(f, curpos, 0);
    }
  }
#line 1239
  cmptparm.x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1240
  cmptparm.y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1241
  if (! cmptparm.x0) {
#line 1241
    tmp___1 = (OPJ_UINT32 )((w - 1) * parameters->subsampling_dx + 1);
  } else {
#line 1241
    tmp___1 = (cmptparm.x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
  }
#line 1241
  cmptparm.w = tmp___1;
#line 1244
  if (! cmptparm.y0) {
#line 1244
    tmp___2 = (OPJ_UINT32 )((h - 1) * parameters->subsampling_dy + 1);
  } else {
#line 1244
    tmp___2 = (cmptparm.y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
  }
#line 1244
  cmptparm.h = tmp___2;
#line 1248
  if ((int )sign == 45) {
#line 1249
    cmptparm.sgnd = (OPJ_UINT32 )1;
  } else {
#line 1251
    cmptparm.sgnd = (OPJ_UINT32 )0;
  }
#line 1253
  if (prec < 8) {
#line 1254
    force8 = 1;
#line 1255
    ushift = 8 - prec;
#line 1256
    dshift = prec - ushift;
#line 1257
    if (cmptparm.sgnd) {
#line 1258
      adjustS = 1 << (prec - 1);
    } else {
#line 1260
      adjustS = 0;
    }
#line 1262
    cmptparm.sgnd = (OPJ_UINT32 )0;
#line 1263
    prec = 8;
  } else {
#line 1265
    adjustS = 0;
#line 1265
    force8 = adjustS;
#line 1265
    dshift = force8;
#line 1265
    ushift = dshift;
  }
  {
#line 1268
  cmptparm.prec = (OPJ_UINT32 )prec;
#line 1269
  cmptparm.dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 1270
  cmptparm.dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 1273
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm, color_space);
  }
#line 1274
  if (! image) {
    {
#line 1275
    fclose(f);
    }
#line 1276
    return ((opj_image_t *)((void *)0));
  }
#line 1279
  image->x0 = cmptparm.x0;
#line 1280
  image->y0 = cmptparm.x0;
#line 1281
  image->x1 = cmptparm.w;
#line 1282
  image->y1 = cmptparm.h;
#line 1286
  comp = image->comps + 0;
#line 1288
  i = 0;
  {
#line 1288
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1288
    if (! (i < w * h)) {
#line 1288
      goto while_break___0;
    }
#line 1290
    if (force8) {
      {
#line 1291
      __cil_tmp38 = readuchar(f);
#line 1291
      v = (int )__cil_tmp38 + adjustS;
#line 1292
      v = (v << ushift) + (v >> dshift);
#line 1293
      *(comp->data + i) = (OPJ_INT32 )((unsigned char )v);
      }
#line 1295
      if (v > max) {
#line 1296
        max = v;
      }
#line 1299
      goto while_continue___0;
    }
#line 1301
    if (comp->prec == 8U) {
#line 1302
      if (! comp->sgnd) {
        {
#line 1303
        __cil_tmp39 = readuchar(f);
#line 1303
        v = (int )__cil_tmp39;
        }
      } else {
        {
#line 1305
        __cil_tmp40 = readuchar(f);
#line 1305
        v = (int )((char )__cil_tmp40);
        }
      }
    } else
#line 1307
    if (comp->prec <= 16U) {
#line 1308
      if (! comp->sgnd) {
        {
#line 1309
        __cil_tmp41 = readushort(f, bigendian);
#line 1309
        v = (int )__cil_tmp41;
        }
      } else {
        {
#line 1311
        __cil_tmp42 = readushort(f, bigendian);
#line 1311
        v = (int )((short )__cil_tmp42);
        }
      }
    } else
#line 1314
    if (! comp->sgnd) {
      {
#line 1315
      __cil_tmp43 = readuint(f, bigendian);
#line 1315
      v = (int )__cil_tmp43;
      }
    } else {
      {
#line 1317
      __cil_tmp44 = readuint(f, bigendian);
#line 1317
      v = (int )__cil_tmp44;
      }
    }
#line 1320
    if (v > max) {
#line 1321
      max = v;
    }
#line 1323
    *(comp->data + i) = v;
#line 1288
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1325
  fclose(f);
#line 1326
  __cil_tmp46 = int_floorlog2(max);
#line 1326
  comp->prec = (OPJ_UINT32 )__cil_tmp46 + 1U;
  }
#line 1328
  return (image);
}
}
#line 1333 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
__inline static int clamp(int value , int prec , int sgnd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1335
  if (sgnd) {
#line 1336
    if (prec <= 8) {
#line 1337
      if (value < -128) {
#line 1337
        tmp___0 = - 128;
      } else {
#line 1337
        if (value > 127) {
#line 1337
          tmp = 127;
        } else {
#line 1337
          tmp = value;
        }
#line 1337
        tmp___0 = tmp;
      }
#line 1337
      return (tmp___0);
    } else
#line 1338
    if (prec <= 16) {
#line 1339
      if (value < -32768) {
#line 1339
        tmp___2 = - 32768;
      } else {
#line 1339
        if (value > 32767) {
#line 1339
          tmp___1 = 32767;
        } else {
#line 1339
          tmp___1 = value;
        }
#line 1339
        tmp___2 = tmp___1;
      }
#line 1339
      return (tmp___2);
    } else {
#line 1341
      if (value < (-0x7FFFFFFF-1)) {
#line 1341
        tmp___4 = (-0x7FFFFFFF-1);
      } else {
#line 1341
        if (value > 2147483647) {
#line 1341
          tmp___3 = 2147483647;
        } else {
#line 1341
          tmp___3 = value;
        }
#line 1341
        tmp___4 = tmp___3;
      }
#line 1341
      return (tmp___4);
    }
  } else
#line 1344
  if (prec <= 8) {
#line 1345
    if (value < 0) {
#line 1345
      tmp___6 = 0;
    } else {
#line 1345
      if (value > 255) {
#line 1345
        tmp___5 = 255;
      } else {
#line 1345
        tmp___5 = value;
      }
#line 1345
      tmp___6 = tmp___5;
    }
#line 1345
    return (tmp___6);
  } else
#line 1346
  if (prec <= 16) {
#line 1347
    if (value < 0) {
#line 1347
      tmp___8 = 0;
    } else {
#line 1347
      if (value > 65535) {
#line 1347
        tmp___7 = 65535;
      } else {
#line 1347
        tmp___7 = value;
      }
#line 1347
      tmp___8 = tmp___7;
    }
#line 1347
    return (tmp___8);
  } else {
#line 1349
    return (value);
  }
}
}
#line 1354 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int fails ;
  unsigned int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp16 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp19 ;
  FILE *__cil_tmp20 ;
  int tmp ;
  unsigned char *line_buffer ;
  void *__cil_tmp23 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int val ;
  int __cil_tmp32 ;
  int v ;
  unsigned char byte ;
  unsigned long __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  unsigned int __cil_tmp38 ;

  {
#line 1357
  fails = 1;
#line 1359
  fdest = (FILE *)((void *)0);
#line 1361
  compno = (unsigned int )0;
  {
#line 1361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1361
    if (! (compno < image->numcomps)) {
#line 1361
      goto while_break;
    }
    {
#line 1362
    comp = image->comps + compno;
#line 1364
    name = (char *)bname;
#line 1365
    nbytes = 0;
#line 1367
    __cil_tmp16 = strlen(outfile);
#line 1367
    olen = __cil_tmp16;
#line 1368
    dotpos = olen - 4UL;
#line 1369
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1371
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1373
      fprintf(stderr, "ERROR -> Impossible happen.");
      }
#line 1374
      goto fin;
    }
#line 1376
    if (total > 256UL) {
      {
#line 1377
      __cil_tmp19 = malloc(total + 1UL);
#line 1377
      name = (char *)__cil_tmp19;
      }
#line 1378
      if (name == (void *)0) {
        {
#line 1379
        fprintf(stderr, "imagetopgx: memory out\n");
        }
#line 1380
        goto fin;
      }
    }
    {
#line 1383
    memcpy(name, outfile, dotpos);
#line 1384
    sprintf(name + dotpos, "_%u.pgx", compno);
#line 1385
    fdest = fopen((char const   *)name, "wbh\177EV");
    }
#line 1388
    if (! fdest) {
      {
#line 1390
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1391
      if (total > 256UL) {
        {
#line 1392
        free(name);
        }
      }
#line 1394
      goto fin;
    }
#line 1397
    w = (int )(image->comps + compno)->w;
#line 1398
    h = (int )(image->comps + compno)->h;
#line 1400
    if (comp->sgnd) {
#line 1400
      tmp = '-';
    } else {
#line 1400
      tmp = '+';
    }
    {
#line 1400
    fprintf(fdest, "PG ML %c %d %d %d\nh\177EV", tmp, comp->prec, w, h);
    }
#line 1403
    if (comp->prec <= 8U) {
#line 1404
      nbytes = 1;
    } else
#line 1405
    if (comp->prec <= 16U) {
#line 1406
      nbytes = 2;
    } else {
#line 1408
      nbytes = 4;
    }
#line 1411
    if (nbytes == 1) {
      {
#line 1412
      __cil_tmp23 = malloc((size_t )w);
#line 1412
      line_buffer = __cil_tmp23;
      }
#line 1413
      if (line_buffer == (void *)0) {
        {
#line 1414
        fprintf(stderr, "Out of memory");
        }
#line 1415
        if (total > 256UL) {
          {
#line 1416
          free(name);
          }
        }
#line 1418
        goto fin;
      }
#line 1420
      j = 0;
      {
#line 1420
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1420
        if (! (j < h)) {
#line 1420
          goto while_break___0;
        }
#line 1421
        if (comp->prec == 8U) {
#line 1421
          if (comp->sgnd == 0U) {
#line 1422
            i = 0;
            {
#line 1422
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1422
              if (! (i < w)) {
#line 1422
                goto while_break___1;
              }
#line 1423
              if (*((image->comps + compno)->data + (j * w + i)) < 0) {
#line 1423
                tmp___1 = 0;
              } else {
#line 1423
                if (*((image->comps + compno)->data + (j * w + i)) > 255) {
#line 1423
                  tmp___0 = 255;
                } else {
#line 1423
                  tmp___0 = *((image->comps + compno)->data + (j * w + i));
                }
#line 1423
                tmp___1 = tmp___0;
              }
#line 1423
              *(line_buffer + i) = (unsigned char )tmp___1;
#line 1422
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
#line 1421
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1427
          i = 0;
          {
#line 1427
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1427
            if (! (i < w)) {
#line 1427
              goto while_break___2;
            }
            {
#line 1428
            __cil_tmp27 = clamp(*((image->comps + compno)->data + (j * w + i)), (int )comp->prec,
                                (int )comp->sgnd);
#line 1428
            *(line_buffer + i) = (unsigned char )__cil_tmp27;
            }
#line 1427
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1433
        res = fwrite(line_buffer, (unsigned long )1, (size_t )w, fdest);
        }
#line 1434
        if (res != (size_t )w) {
          {
#line 1435
          fprintf(stderr, "failed to write %d bytes for %s\n\230\001", w, name);
          }
#line 1436
          if (total > 256UL) {
            {
#line 1437
            free(name);
            }
          }
          {
#line 1439
          free(line_buffer);
          }
#line 1440
          goto fin;
        }
#line 1420
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1443
      free(line_buffer);
      }
    } else {
#line 1446
      i = 0;
      {
#line 1446
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1446
        if (! (i < w * h)) {
#line 1446
          goto while_break___3;
        }
        {
#line 1448
        __cil_tmp32 = clamp(*((image->comps + compno)->data + i), (int )comp->prec,
                            (int )comp->sgnd);
#line 1448
        val = __cil_tmp32;
#line 1451
        j = nbytes - 1;
        }
        {
#line 1451
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1451
          if (! (j >= 0)) {
#line 1451
            goto while_break___4;
          }
          {
#line 1452
          v = (int )(val >> j * 8);
#line 1453
          byte = (unsigned char )v;
#line 1454
          res = fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
          }
#line 1456
          if (res < 1UL) {
            {
#line 1457
            fprintf(stderr, "failed to write 1 byte for %s\n", name);
            }
#line 1458
            if (total > 256UL) {
              {
#line 1459
              free(name);
              }
            }
#line 1461
            goto fin;
          }
#line 1451
          __cil_tmp36 = j;
#line 1451
          j --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1446
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1467
    if (total > 256UL) {
      {
#line 1468
      free(name);
      }
    }
    {
#line 1470
    fclose(fdest);
#line 1471
    fdest = (FILE *)((void *)0);
    }
#line 1361
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  fails = 0;
  fin: 
#line 1475
  if (fdest) {
    {
#line 1476
    fclose(fdest);
    }
  }
#line 1479
  return (fails);
}
}
#line 1494 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
#line 1496
  if (s != (void *)0) {
    {
#line 1497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1497
      if (! *s) {
#line 1497
        goto while_break;
      }
#line 1498
      if ((int )*s == 10) {
#line 1499
        return ((char *)((void *)0));
      } else
#line 1498
      if ((int )*s == 13) {
#line 1499
        return ((char *)((void *)0));
      }
      {
#line 1501
      __cil_tmp2 = __ctype_b_loc();
      }
#line 1501
      if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1502
        s ++;
#line 1503
        goto while_continue;
      }
#line 1505
      return (s);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1508
  return ((char *)((void *)0));
}
}
#line 1511 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1516
  *out_n = 0;
#line 1518
  s = skip_white(start);
  }
#line 1519
  if (s == (void *)0) {
#line 1520
    return ((char *)((void *)0));
  }
#line 1522
  start = s;
  {
#line 1524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1524
    if (! *s) {
#line 1524
      goto while_break;
    }
    {
#line 1525
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1525
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1526
      goto while_break;
    }
#line 1528
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  c = *s;
#line 1531
  *s = (char )0;
#line 1532
  *out_n = atoi((char const   *)start);
#line 1533
  *s = c;
  }
#line 1534
  return (s);
}
}
#line 1537 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static char *skip_idf(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1542
  s = skip_white(start);
  }
#line 1543
  if (s == (void *)0) {
#line 1544
    return ((char *)((void *)0));
  }
#line 1546
  start = s;
  {
#line 1548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1548
    if (! *s) {
#line 1548
      goto while_break;
    }
    {
#line 1549
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1549
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1550
      s ++;
#line 1551
      goto while_continue;
    } else
#line 1549
    if ((int )*s == 95) {
#line 1550
      s ++;
#line 1551
      goto while_continue;
    }
#line 1553
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1555
  c = *s;
#line 1556
  *s = (char )0;
#line 1557
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1558
  *s = c;
  }
#line 1559
  return (s);
}
}
#line 1562 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  int format ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *s ;
  int allow_null ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1568
  __cil_tmp9 = fgets((char *)line, 250, reader);
  }
#line 1568
  if (__cil_tmp9 == (void *)0) {
    {
#line 1569
    fprintf(stderr, "\nWARNING: fgets return a NULL value\177EV");
    }
#line 1570
    return;
  }
#line 1573
  if ((int )line[0] != 80) {
    {
#line 1574
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\nEV");
    }
#line 1575
    return;
  }
  {
#line 1577
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1578
  if (format < 1) {
    {
    {
#line 1579
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1580
    return;
  } else
#line 1578
  if (format > 7) {
    {
    {
#line 1579
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1580
    return;
  }
#line 1582
  ph->format = format;
#line 1583
  end = 0;
#line 1583
  ttype = end;
  {
#line 1585
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1585
    __cil_tmp11 = fgets((char *)line, 250, reader);
    }
#line 1585
    if (! __cil_tmp11) {
#line 1585
      goto while_break;
    }
#line 1587
    allow_null = 0;
#line 1589
    if ((int )*((char *)line) == 35) {
#line 1590
      goto while_continue;
    }
#line 1593
    s = (char *)line;
#line 1595
    if (format == 7) {
      {
#line 1596
      s = skip_idf(s, (char *)idf);
      }
#line 1598
      if (s == (void *)0) {
#line 1599
        return;
      } else
#line 1598
      if ((int )*s == 0) {
#line 1599
        return;
      }
      {
#line 1602
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1602
      if (__cil_tmp15 == 0) {
#line 1603
        end = 1;
#line 1604
        goto while_break;
      }
      {
#line 1606
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHV");
      }
#line 1606
      if (__cil_tmp16 == 0) {
        {
#line 1607
        s = skip_int(s, & ph->width);
        }
#line 1608
        if (s == (void *)0) {
#line 1609
          return;
        } else
#line 1608
        if ((int )*s == 0) {
#line 1609
          return;
        }
#line 1612
        goto while_continue;
      }
      {
#line 1614
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1614
      if (__cil_tmp18 == 0) {
        {
#line 1615
        s = skip_int(s, & ph->height);
        }
#line 1616
        if (s == (void *)0) {
#line 1617
          return;
        } else
#line 1616
        if ((int )*s == 0) {
#line 1617
          return;
        }
#line 1620
        goto while_continue;
      }
      {
#line 1622
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTH");
      }
#line 1622
      if (__cil_tmp20 == 0) {
        {
#line 1623
        s = skip_int(s, & ph->depth);
        }
#line 1624
        if (s == (void *)0) {
#line 1625
          return;
        } else
#line 1624
        if ((int )*s == 0) {
#line 1625
          return;
        }
#line 1628
        goto while_continue;
      }
      {
#line 1630
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1630
      if (__cil_tmp22 == 0) {
        {
#line 1631
        s = skip_int(s, & ph->maxval);
        }
#line 1632
        if (s == (void *)0) {
#line 1633
          return;
        } else
#line 1632
        if ((int )*s == 0) {
#line 1633
          return;
        }
#line 1636
        goto while_continue;
      }
      {
#line 1638
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1638
      if (__cil_tmp24 == 0) {
        {
#line 1639
        s = skip_idf(s, (char *)type);
        }
#line 1640
        if (s == (void *)0) {
#line 1641
          return;
        } else
#line 1640
        if ((int )*s == 0) {
#line 1641
          return;
        }
        {
#line 1644
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1644
        if (__cil_tmp26 == 0) {
#line 1645
          ph->bw = (char )1;
#line 1646
          ttype = 1;
#line 1647
          goto while_continue;
        }
        {
#line 1649
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE\313h\177EV");
        }
#line 1649
        if (__cil_tmp27 == 0) {
#line 1650
          ph->gray = (char )1;
#line 1651
          ttype = 1;
#line 1652
          goto while_continue;
        }
        {
#line 1654
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1654
        if (__cil_tmp28 == 0) {
#line 1655
          ph->graya = (char )1;
#line 1656
          ttype = 1;
#line 1657
          goto while_continue;
        }
        {
#line 1659
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB\177EV");
        }
#line 1659
        if (__cil_tmp29 == 0) {
#line 1660
          ph->rgb = (char )1;
#line 1661
          ttype = 1;
#line 1662
          goto while_continue;
        }
        {
#line 1664
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\303h\177EV");
        }
#line 1664
        if (__cil_tmp30 == 0) {
#line 1665
          ph->rgba = (char )1;
#line 1666
          ttype = 1;
#line 1667
          goto while_continue;
        }
        {
#line 1669
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1670
        return;
      }
      {
#line 1672
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\nh\177EV", (char *)idf);
      }
#line 1673
      return;
    }
#line 1677
    if (ph->width == 0) {
      {
#line 1678
      s = skip_int(s, & ph->width);
      }
#line 1679
      if (s == (void *)0) {
#line 1680
        return;
      } else
#line 1679
      if ((int )*s == 0) {
#line 1680
        return;
      } else
#line 1679
      if (ph->width < 1) {
#line 1680
        return;
      }
#line 1682
      allow_null = 1;
    }
#line 1684
    if (ph->height == 0) {
      {
#line 1685
      s = skip_int(s, & ph->height);
      }
#line 1686
      if (s == (void *)0) {
#line 1686
        if (allow_null) {
#line 1687
          goto while_continue;
        }
      }
#line 1689
      if (s == (void *)0) {
#line 1690
        return;
      } else
#line 1689
      if ((int )*s == 0) {
#line 1690
        return;
      } else
#line 1689
      if (ph->height < 1) {
#line 1690
        return;
      }
#line 1692
      if (format == 1) {
#line 1693
        goto while_break;
      } else
#line 1692
      if (format == 4) {
#line 1693
        goto while_break;
      }
#line 1695
      allow_null = 1;
    }
    {
#line 1698
    s = skip_int(s, & ph->maxval);
    }
#line 1699
    if (s == (void *)0) {
#line 1699
      if (allow_null) {
#line 1700
        goto while_continue;
      }
    }
#line 1702
    if (s == (void *)0) {
#line 1703
      return;
    } else
#line 1702
    if ((int )*s == 0) {
#line 1703
      return;
    }
#line 1705
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1707
  if (format == 2) {
    _L: /* CIL Label */ 
    _L___73: /* CIL Label */ 
#line 1708
    if (ph->maxval < 1) {
#line 1709
      return;
    } else
#line 1708
    if (ph->maxval > 65535) {
#line 1709
      return;
    }
  } else
#line 1707
  if (format == 3) {
#line 1707
    goto _L;
  } else
#line 1707
  if (format > 4) {
#line 1707
    goto _L;
  }
#line 1712
  if (ph->width < 1) {
#line 1713
    return;
  } else
#line 1712
  if (ph->height < 1) {
#line 1713
    return;
  }
#line 1716
  if (format == 7) {
#line 1717
    if (! end) {
      {
#line 1718
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1719
      return;
    }
#line 1721
    if (ph->depth < 1) {
#line 1722
      return;
    } else
#line 1721
    if (ph->depth > 4) {
#line 1722
      return;
    }
#line 1725
    if (ttype) {
#line 1726
      ph->ok = (char )1;
    }
  } else {
#line 1729
    ph->ok = (char )1;
#line 1730
    if (format == 1) {
#line 1731
      ph->maxval = 255;
    } else
#line 1730
    if (format == 4) {
#line 1731
      ph->maxval = 255;
    }
  }
  return;
}
}
#line 1736 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1738
  if (val < 2) {
#line 1739
    return (1);
  }
#line 1741
  if (val < 4) {
#line 1742
    return (2);
  }
#line 1744
  if (val < 8) {
#line 1745
    return (3);
  }
#line 1747
  if (val < 16) {
#line 1748
    return (4);
  }
#line 1750
  if (val < 32) {
#line 1751
    return (5);
  }
#line 1753
  if (val < 64) {
#line 1754
    return (6);
  }
#line 1756
  if (val < 128) {
#line 1757
    return (7);
  }
#line 1759
  if (val < 256) {
#line 1760
    return (8);
  }
#line 1762
  if (val < 512) {
#line 1763
    return (9);
  }
#line 1765
  if (val < 1024) {
#line 1766
    return (10);
  }
#line 1768
  if (val < 2048) {
#line 1769
    return (11);
  }
#line 1771
  if (val < 4096) {
#line 1772
    return (12);
  }
#line 1774
  if (val < 8192) {
#line 1775
    return (13);
  }
#line 1777
  if (val < 16384) {
#line 1778
    return (14);
  }
#line 1780
  if (val < 32768) {
#line 1781
    return (15);
  }
#line 1783
  return (16);
}
}
#line 1786 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  FILE *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned int index___0 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int index___1 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int x ;
  int y ;
  int bit ;
  int uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1788
  subsampling_dx = parameters->subsampling_dx;
#line 1789
  subsampling_dy = parameters->subsampling_dy;
#line 1791
  fp = (FILE *)((void *)0);
#line 1795
  image = (opj_image_t *)((void *)0);
#line 1798
  fp = fopen(filename, "rb");
  }
#line 1798
  if (fp == (void *)0) {
    {
#line 1799
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1800
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1802
  memset(& header_info, 0, sizeof(struct pnm_header ));
#line 1804
  read_pnm_header(fp, & header_info);
  }
#line 1806
  if (! header_info.ok) {
    {
#line 1807
    fclose(fp);
    }
#line 1808
    return ((opj_image_t *)((void *)0));
  }
#line 1811
  if (header_info.width == 0) {
    {
    {
    {
#line 1814
    fclose(fp);
    }
    }
    }
#line 1815
    return ((opj_image_t *)((void *)0));
  } else
#line 1811
  if (header_info.height == 0) {
    {
    {
    {
#line 1814
    fclose(fp);
    }
    }
    }
#line 1815
    return ((opj_image_t *)((void *)0));
  } else
#line 1811
  if (header_info.format == 7) {
#line 1811
    if (header_info.depth == 0) {
      {
      {
      {
#line 1814
      fclose(fp);
      }
      }
      }
#line 1815
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1819
  if (header_info.height != 0) {
#line 1819
    if (header_info.width > 2147483647 / header_info.height) {
      {
#line 1821
      fprintf(stderr, "pnmtoimage:Image %dx%d too big!\n\230\001", header_info.width,
              header_info.height);
#line 1823
      fclose(fp);
      }
#line 1824
      return ((opj_image_t *)((void *)0));
    }
  }
#line 1827
  format = header_info.format;
  {
#line 1831
  if (format == 4) {
#line 1831
    goto case_4;
  }
#line 1831
  if (format == 1) {
#line 1831
    goto case_4;
  }
#line 1836
  if (format == 5) {
#line 1836
    goto case_5;
  }
#line 1836
  if (format == 2) {
#line 1836
    goto case_5;
  }
#line 1841
  if (format == 6) {
#line 1841
    goto case_6;
  }
#line 1841
  if (format == 3) {
#line 1841
    goto case_6;
  }
#line 1845
  if (format == 7) {
#line 1845
    goto case_7;
  }
#line 1849
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1832
  numcomps = 1;
#line 1833
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1837
  numcomps = 1;
#line 1838
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1842
  numcomps = 3;
#line 1843
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1846
  numcomps = header_info.depth;
#line 1847
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1850
  fclose(fp);
  }
#line 1851
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1853
  if (numcomps < 3) {
#line 1854
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1856
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1859
  prec = has_prec(header_info.maxval);
  }
#line 1861
  if (prec < 8) {
#line 1862
    prec = 8;
  }
  {
#line 1865
  w = header_info.width;
#line 1866
  h = header_info.height;
#line 1867
  subsampling_dx = parameters->subsampling_dx;
#line 1868
  subsampling_dy = parameters->subsampling_dy;
#line 1870
  memset(& cmptparm[0], 0, (size_t )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1872
  i = 0;
  }
  {
#line 1872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1872
    if (! (i < numcomps)) {
#line 1872
      goto while_break;
    }
#line 1873
    cmptparm[i].prec = (OPJ_UINT32 )prec;
#line 1874
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 1875
    cmptparm[i].dx = (OPJ_UINT32 )subsampling_dx;
#line 1876
    cmptparm[i].dy = (OPJ_UINT32 )subsampling_dy;
#line 1877
    cmptparm[i].w = (OPJ_UINT32 )w;
#line 1878
    cmptparm[i].h = (OPJ_UINT32 )h;
#line 1872
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1880
  image = opj_image_create((OPJ_UINT32 )numcomps, & cmptparm[0], color_space);
  }
#line 1882
  if (! image) {
    {
#line 1883
    fclose(fp);
    }
#line 1884
    return ((opj_image_t *)((void *)0));
  }
#line 1888
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 1889
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 1890
  image->x1 = (OPJ_UINT32 )((parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1);
#line 1892
  image->y1 = (OPJ_UINT32 )((parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1);
#line 1895
  if (format == 2) {
    _L___76: /* CIL Label */ 
#line 1898
    i = 0;
    {
#line 1898
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1898
      if (! (i < w * h)) {
#line 1898
        goto while_break___0;
      }
#line 1899
      compno = 0;
      {
#line 1899
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1899
        if (! (compno < numcomps)) {
#line 1899
          goto while_break___1;
        }
        {
#line 1900
        index___0 = (unsigned int )0;
#line 1901
        __cil_tmp22 = fscanf(fp, "%u", & index___0);
        }
#line 1901
        if (__cil_tmp22 != 1) {
          {
#line 1902
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1903
          opj_image_destroy(image);
#line 1904
          fclose(fp);
          }
#line 1905
          return ((opj_image_t *)((void *)0));
        }
#line 1908
        *((image->comps + compno)->data + i) = (OPJ_INT32 )(index___0 * 255U) / header_info.maxval;
#line 1899
        compno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1898
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1895
  if (format == 3) {
#line 1895
    goto _L___76;
  } else
#line 1911
  if (format == 5) {
    _L: /* CIL Label */ 
    _L___75: /* CIL Label */ 
#line 1918
    one = (unsigned char )(prec < 9);
#line 1920
    i = 0;
    {
#line 1920
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1920
      if (! (i < w * h)) {
#line 1920
        goto while_break___2;
      }
#line 1921
      compno = 0;
      {
#line 1921
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1921
        if (! (compno < numcomps)) {
#line 1921
          goto while_break___3;
        }
        {
#line 1922
        __cil_tmp28 = fread(& c0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1922
        if (! __cil_tmp28) {
          {
#line 1923
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1924
          opj_image_destroy(image);
#line 1925
          fclose(fp);
          }
#line 1926
          return ((opj_image_t *)((void *)0));
        }
#line 1928
        if (one) {
#line 1929
          *((image->comps + compno)->data + i) = (OPJ_INT32 )c0;
        } else {
          {
#line 1931
          __cil_tmp29 = fread(& c1, (unsigned long )1, (unsigned long )1, fp);
          }
#line 1931
          if (! __cil_tmp29) {
            {
#line 1932
            fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1933
            opj_image_destroy(image);
#line 1934
            fclose(fp);
            }
#line 1935
            return ((opj_image_t *)((void *)0));
          }
#line 1938
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1921
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1920
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1911
  if (format == 6) {
#line 1911
    goto _L;
  } else
#line 1911
  if (format == 7) {
#line 1911
    if ((int )header_info.gray) {
#line 1911
      goto _L;
    } else
#line 1911
    if ((int )header_info.graya) {
#line 1911
      goto _L;
    } else
#line 1911
    if ((int )header_info.rgb) {
#line 1911
      goto _L;
    } else
#line 1911
    if ((int )header_info.rgba) {
#line 1911
      goto _L;
    } else {
#line 1911
      goto _L___74;
    }
  } else
  _L___74: /* CIL Label */ 
#line 1942
  if (format == 1) {
#line 1943
    i = 0;
    {
#line 1943
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1943
      if (! (i < w * h)) {
#line 1943
        goto while_break___4;
      }
      {
#line 1946
      __cil_tmp33 = fscanf(fp, "%u", & index___1);
      }
#line 1946
      if (__cil_tmp33 != 1) {
        {
#line 1947
        fprintf(stderr, "Missing data. Quitting.\n");
#line 1948
        opj_image_destroy(image);
#line 1949
        fclose(fp);
        }
#line 1950
        return ((opj_image_t *)((void *)0));
      }
#line 1953
      if (index___1) {
#line 1953
        tmp = 0;
      } else {
#line 1953
        tmp = 255;
      }
#line 1953
      *((image->comps + 0)->data + i) = tmp;
#line 1943
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1955
  if (format == 4) {
#line 1959
    i = 0;
#line 1960
    y = 0;
    {
#line 1960
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1960
      if (! (y < h)) {
#line 1960
        goto while_break___5;
      }
#line 1961
      bit = - 1;
#line 1962
      uc = 0;
#line 1964
      x = 0;
      {
#line 1964
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1964
        if (! (x < w)) {
#line 1964
          goto while_break___6;
        }
#line 1965
        if (bit == -1) {
          {
#line 1966
          bit = 7;
#line 1967
          uc = getc(fp);
          }
#line 1968
          if (uc == -1) {
            {
#line 1969
            fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1970
            opj_image_destroy(image);
#line 1971
            fclose(fp);
            }
#line 1972
            return ((opj_image_t *)((void *)0));
          }
        }
#line 1975
        if (((int )((unsigned char )uc) >> bit) & 1) {
#line 1975
          tmp___0 = 0;
        } else {
#line 1975
          tmp___0 = 255;
        }
#line 1975
        *((image->comps + 0)->data + i) = tmp___0;
#line 1976
        bit --;
#line 1977
        i ++;
#line 1964
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1960
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1980
  if (format == 7) {
#line 1980
    if ((int )header_info.bw) {
#line 1983
      i = 0;
      {
#line 1983
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1983
        if (! (i < w * h)) {
#line 1983
          goto while_break___7;
        }
        {
#line 1984
        __cil_tmp43 = fread(& uc___0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1984
        if (! __cil_tmp43) {
          {
#line 1985
          fprintf(stderr, "Missing data. Quitting.\n\220");
#line 1986
          opj_image_destroy(image);
#line 1987
          fclose(fp);
          }
#line 1988
          return ((opj_image_t *)((void *)0));
        }
#line 1990
        if ((int )uc___0 & 1) {
#line 1990
          tmp___1 = 0;
        } else {
#line 1990
          tmp___1 = 255;
        }
#line 1990
        *((image->comps + 0)->data + i) = tmp___1;
#line 1983
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 1993
  fclose(fp);
  }
#line 1995
  return (image);
}
}
#line 1998 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int are_comps_similar(opj_image_t *image ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp3 ;

  {
#line 2001
  i = (unsigned int )1;
  {
#line 2001
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2001
    if (! (i < image->numcomps)) {
#line 2001
      goto while_break;
    }
#line 2002
    if ((image->comps + 0)->dx != (image->comps + i)->dx) {
#line 2007
      return (0);
    } else
#line 2002
    if ((image->comps + 0)->dy != (image->comps + i)->dy) {
#line 2007
      return (0);
    } else
#line 2002
    if (i <= 2U) {
#line 2002
      if ((image->comps + 0)->prec != (image->comps + i)->prec) {
#line 2007
        return (0);
      } else
#line 2002
      if ((image->comps + 0)->sgnd != (image->comps + i)->sgnd) {
#line 2007
        return (0);
      }
    }
#line 2001
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return (1);
}
}
#line 2014 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile , int force_split ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  unsigned int compno ;
  unsigned int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  int __cil_tmp28 ;
  FILE *__cil_tmp29 ;
  int __cil_tmp30 ;
  char const   *tt ;
  char const   *tmp___77 ;
  char const   *__cil_tmp33 ;
  int tmp___78 ;
  char const   *__cil_tmp35 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int *__cil_tmp39 ;
  int *__cil_tmp40 ;
  int *__cil_tmp41 ;
  int *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  void *__cil_tmp44 ;
  size_t olen ;
  unsigned long __cil_tmp46 ;
  size_t dotpos ;
  FILE *__cil_tmp48 ;
  char const   *__cil_tmp49 ;
  int tmp___82 ;
  int *__cil_tmp51 ;
  int __cil_tmp52 ;
  unsigned int __cil_tmp53 ;

  {
#line 2023
  fdest = (FILE *)((void *)0);
#line 2024
  tmp = outfile;
#line 2027
  alpha = (int *)((void *)0);
#line 2029
  prec = (int )(image->comps + 0)->prec;
#line 2029
  if (prec > 16) {
    {
#line 2030
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n\204j\177EV",
            "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c", 2031, prec);
    }
#line 2032
    return (1);
  }
#line 2034
  has_alpha = 0;
#line 2034
  two = has_alpha;
#line 2035
  fails = 1;
#line 2036
  ncomp = image->numcomps;
  {
#line 2038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2038
    if (! *tmp) {
#line 2038
      goto while_break;
    }
#line 2039
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2041
  tmp -= 2;
#line 2042
  want_gray = (int )*tmp == 103 || (int )*tmp == 71;
#line 2043
  ncomp = image->numcomps;
#line 2045
  if (want_gray) {
#line 2046
    ncomp = (unsigned int )1;
  }
  {
#line 2049
  __cil_tmp28 = are_comps_similar(image);
  }
#line 2049
  if (force_split == 0) {
#line 2049
    if (ncomp >= 2U) {
#line 2049
      if (__cil_tmp28) {
        {
#line 2051
        fdest = fopen(outfile, "wbj\177EV");
        }
#line 2053
        if (! fdest) {
          {
#line 2054
          fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
          }
#line 2055
          return (fails);
        }
#line 2057
        two = prec > 8;
#line 2058
        triple = ncomp > 2U;
#line 2059
        wr = (int )(image->comps + 0)->w;
#line 2060
        hr = (int )(image->comps + 0)->h;
#line 2061
        max = (1 << prec) - 1;
#line 2062
        has_alpha = ncomp == 4U || ncomp == 2U;
#line 2064
        red = (image->comps + 0)->data;
#line 2065
        if (red == (void *)0) {
          {
#line 2066
          fprintf(stderr, "imagetopnm: planes[%d] == NULL.\n\251", 0);
#line 2068
          fprintf(stderr, "\tAborting\nj\177EV");
#line 2069
          fclose(fdest);
          }
#line 2070
          return (fails);
        }
#line 2073
        if (triple) {
#line 2074
          green = (image->comps + 1)->data;
#line 2075
          blue = (image->comps + 2)->data;
#line 2076
          i = 1;
          {
#line 2076
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2076
            if (! (i <= 2)) {
#line 2076
              goto while_break___0;
            }
#line 2077
            if ((image->comps + i)->data == (void *)0) {
              {
#line 2078
              fprintf(stderr, "imagetopnm: planes[%d] == NULL.\n\230\001", i);
#line 2080
              fprintf(stderr, "\tAborting\n");
#line 2081
              fclose(fdest);
              }
#line 2082
              return (fails);
            }
#line 2076
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 2086
          blue = (int *)((void *)0);
#line 2086
          green = blue;
        }
#line 2089
        if (has_alpha) {
#line 2090
          if (triple) {
#line 2090
            tmp___77 = "RGB_ALPHA";
          } else {
#line 2090
            tmp___77 = "GRAYSCALE_ALPHA";
          }
          {
#line 2090
          tt = tmp___77;
#line 2092
          __cil_tmp33 = opj_version();
#line 2092
          fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %u\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
                  __cil_tmp33, wr, hr, ncomp, max, tt);
#line 2095
          alpha = (image->comps + (ncomp - 1U))->data;
          }
#line 2096
          if ((image->comps + (ncomp - 1U))->sgnd) {
#line 2096
            tmp___78 = 1 << ((image->comps + (ncomp - 1U))->prec - 1U);
          } else {
#line 2096
            tmp___78 = 0;
          }
#line 2096
          adjustA = tmp___78;
        } else {
          {
#line 2099
          __cil_tmp35 = opj_version();
#line 2099
          fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\nj\177EV", __cil_tmp35, wr,
                  hr, max);
#line 2101
          adjustA = 0;
          }
        }
#line 2103
        if ((image->comps + 0)->sgnd) {
#line 2103
          tmp___79 = 1 << ((image->comps + 0)->prec - 1U);
        } else {
#line 2103
          tmp___79 = 0;
        }
#line 2103
        adjustR = tmp___79;
#line 2105
        if (triple) {
#line 2106
          if ((image->comps + 1)->sgnd) {
#line 2106
            tmp___80 = 1 << ((image->comps + 1)->prec - 1U);
          } else {
#line 2106
            tmp___80 = 0;
          }
#line 2106
          adjustG = tmp___80;
#line 2107
          if ((image->comps + 2)->sgnd) {
#line 2107
            tmp___81 = 1 << ((image->comps + 2)->prec - 1U);
          } else {
#line 2107
            tmp___81 = 0;
          }
#line 2107
          adjustB = tmp___81;
        } else {
#line 2109
          adjustB = 0;
#line 2109
          adjustG = adjustB;
        }
#line 2112
        i = 0;
        {
#line 2112
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2112
          if (! (i < wr * hr)) {
#line 2112
            goto while_break___1;
          }
#line 2113
          if (two) {
#line 2114
            v = *red + adjustR;
#line 2115
            red ++;
#line 2116
            if (v > 65535) {
#line 2117
              v = 65535;
            } else
#line 2118
            if (v < 0) {
#line 2119
              v = 0;
            }
            {
#line 2123
            fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
            }
#line 2125
            if (triple) {
#line 2126
              v = *green + adjustG;
#line 2127
              green ++;
#line 2128
              if (v > 65535) {
#line 2129
                v = 65535;
              } else
#line 2130
              if (v < 0) {
#line 2131
                v = 0;
              }
              {
#line 2135
              fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 2137
              v = *blue + adjustB;
#line 2138
              blue ++;
              }
#line 2139
              if (v > 65535) {
#line 2140
                v = 65535;
              } else
#line 2141
              if (v < 0) {
#line 2142
                v = 0;
              }
              {
#line 2146
              fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
              }
            }
#line 2150
            if (has_alpha) {
#line 2151
              v = *alpha + adjustA;
#line 2152
              alpha ++;
#line 2153
              if (v > 65535) {
#line 2154
                v = 65535;
              } else
#line 2155
              if (v < 0) {
#line 2156
                v = 0;
              }
              {
#line 2160
              fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
              }
            }
#line 2162
            goto while_continue___1;
          }
#line 2167
          __cil_tmp39 = red;
#line 2167
          red ++;
#line 2167
          v = *__cil_tmp39;
#line 2168
          if (v > 255) {
#line 2169
            v = 255;
          } else
#line 2170
          if (v < 0) {
#line 2171
            v = 0;
          }
          {
#line 2174
          fprintf(fdest, "%cj\177EV", (int )((unsigned char )v));
          }
#line 2175
          if (triple) {
#line 2176
            __cil_tmp40 = green;
#line 2176
            green ++;
#line 2176
            v = *__cil_tmp40;
#line 2177
            if (v > 255) {
#line 2178
              v = 255;
            } else
#line 2179
            if (v < 0) {
#line 2180
              v = 0;
            }
            {
#line 2183
            fprintf(fdest, "%c", (int )((unsigned char )v));
#line 2184
            __cil_tmp41 = blue;
#line 2184
            blue ++;
#line 2184
            v = *__cil_tmp41;
            }
#line 2185
            if (v > 255) {
#line 2186
              v = 255;
            } else
#line 2187
            if (v < 0) {
#line 2188
              v = 0;
            }
            {
#line 2191
            fprintf(fdest, "%ci\177EV", (int )((unsigned char )v));
            }
          }
#line 2193
          if (has_alpha) {
#line 2194
            __cil_tmp42 = alpha;
#line 2194
            alpha ++;
#line 2194
            v = *__cil_tmp42;
#line 2195
            if (v > 255) {
#line 2196
              v = 255;
            } else
#line 2197
            if (v < 0) {
#line 2198
              v = 0;
            }
            {
#line 2201
            fprintf(fdest, "%c", (int )((unsigned char )v));
            }
          }
#line 2112
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2205
        fclose(fdest);
        }
#line 2206
        return (0);
      }
    }
  }
#line 2211
  if (image->numcomps > ncomp) {
    {
#line 2212
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2213
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2215
  __cil_tmp43 = strlen(outfile);
#line 2215
  __cil_tmp44 = malloc(__cil_tmp43 + 8UL);
#line 2215
  destname = (char *)__cil_tmp44;
  }
#line 2216
  if (destname == (void *)0) {
    {
#line 2217
    fprintf(stderr, "imagetopnm: memory out\n");
    }
#line 2218
    return (1);
  }
#line 2220
  compno = (unsigned int )0;
  {
#line 2220
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2220
    if (! (compno < ncomp)) {
#line 2220
      goto while_break___2;
    }
#line 2221
    if (ncomp > 1U) {
      {
#line 2223
      __cil_tmp46 = strlen(outfile);
#line 2223
      olen = __cil_tmp46;
#line 2224
      dotpos = olen - 4UL;
#line 2226
      memcpy(destname, outfile, dotpos);
#line 2227
      sprintf(destname + dotpos, "_%u.pgm", compno);
      }
    } else {
      {
#line 2229
      sprintf(destname, "%s", outfile);
      }
    }
    {
#line 2232
    fdest = fopen((char const   *)destname, "wb");
    }
#line 2233
    if (! fdest) {
      {
#line 2234
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2235
      free(destname);
      }
#line 2236
      return (1);
    }
    {
#line 2238
    wr = (int )(image->comps + compno)->w;
#line 2239
    hr = (int )(image->comps + compno)->h;
#line 2240
    prec = (int )(image->comps + compno)->prec;
#line 2241
    max = (1 << prec) - 1;
#line 2243
    __cil_tmp49 = opj_version();
#line 2243
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp49, wr, hr, max);
#line 2246
    red = (image->comps + compno)->data;
    }
#line 2247
    if (! red) {
      {
#line 2248
      fclose(fdest);
      }
#line 2249
      goto while_continue___2;
    }
#line 2252
    if ((image->comps + compno)->sgnd) {
#line 2252
      tmp___82 = 1 << ((image->comps + compno)->prec - 1U);
    } else {
#line 2252
      tmp___82 = 0;
    }
#line 2252
    adjustR = tmp___82;
#line 2255
    if (prec > 8) {
#line 2256
      i = 0;
      {
#line 2256
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2256
        if (! (i < wr * hr)) {
#line 2256
          goto while_break___3;
        }
#line 2257
        v = *red + adjustR;
#line 2258
        red ++;
#line 2259
        if (v > 65535) {
#line 2260
          v = 65535;
        } else
#line 2261
        if (v < 0) {
#line 2262
          v = 0;
        }
        {
#line 2266
        fprintf(fdest, "%c%cEV", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2268
        if (has_alpha) {
#line 2269
          __cil_tmp51 = alpha;
#line 2269
          alpha ++;
#line 2269
          v = *__cil_tmp51;
#line 2270
          if (v > 65535) {
#line 2271
            v = 65535;
          } else
#line 2272
          if (v < 0) {
#line 2273
            v = 0;
          }
          {
#line 2277
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2256
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 2281
      i = 0;
      {
#line 2281
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2281
        if (! (i < wr * hr)) {
#line 2281
          goto while_break___4;
        }
#line 2282
        v = *red + adjustR;
#line 2283
        red ++;
#line 2284
        if (v > 255) {
#line 2285
          v = 255;
        } else
#line 2286
        if (v < 0) {
#line 2287
          v = 0;
        }
        {
#line 2290
        fprintf(fdest, "%c", (int )((unsigned char )v));
        }
#line 2281
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 2293
    fclose(fdest);
    }
#line 2220
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2295
  free(destname);
  }
#line 2297
  return (0);
}
}
#line 2305 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static opj_image_t *rawtoimage_common(char const   *filename , opj_cparameters_t *parameters ,
                                      raw_cparameters_t *raw_cp , OPJ_BOOL big_endian ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned char value ;
  int nloop ;
  unsigned long __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned short value___0 ;
  int nloop___0 ;
  unsigned char temp1 ;
  unsigned char temp2 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int tmp___0 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;

  {
#line 2308
  subsampling_dx = parameters->subsampling_dx;
#line 2309
  subsampling_dy = parameters->subsampling_dy;
#line 2311
  f = (FILE *)((void *)0);
#line 2315
  image = (opj_image_t *)((void *)0);
#line 2318
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2320
    fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 2321
    fprintf(stderr, "Please use the Format option -F:\n");
#line 2322
    fprintf(stderr, "-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\n");
#line 2324
    fprintf(stderr, "If subsampling is omitted, 1x1 is assumed for all components\n");
#line 2326
    fprintf(stderr, "Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\n\220");
#line 2328
    fprintf(stderr, "         for raw 512x512 image with 4:2:0 subsampling\n");
#line 2329
    fprintf(stderr, "Aborting.\n");
    }
#line 2330
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2333
  f = fopen(filename, "rb");
  }
#line 2334
  if (! f) {
    {
#line 2335
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
#line 2336
    fprintf(stderr, "Aborting\n");
    }
#line 2337
    return ((opj_image_t *)((void *)0));
  }
#line 2339
  numcomps = raw_cp->rawComp;
#line 2342
  if (numcomps == 1) {
#line 2343
    color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 2344
  if (numcomps >= 3) {
#line 2344
    if ((int )parameters->tcp_mct == 0) {
#line 2345
      color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 2344
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2346
  if (numcomps >= 3) {
#line 2346
    if ((int )parameters->tcp_mct != 2) {
#line 2347
      color_space = (OPJ_COLOR_SPACE )1;
    } else {
#line 2349
      color_space = (OPJ_COLOR_SPACE )-1;
    }
  } else {
#line 2349
    color_space = (OPJ_COLOR_SPACE )-1;
  }
  {
#line 2351
  w = raw_cp->rawWidth;
#line 2352
  h = raw_cp->rawHeight;
#line 2353
  __cil_tmp18 = calloc((unsigned long )((OPJ_UINT32 )numcomps), sizeof(opj_image_cmptparm_t ));
#line 2353
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp18;
  }
#line 2355
  if (! cmptparm) {
    {
#line 2356
    fprintf(stderr, "Failed to allocate image components parameters !!\n");
#line 2357
    fprintf(stderr, "Aborting\nDk\177EV");
#line 2358
    fclose(f);
    }
#line 2359
    return ((opj_image_t *)((void *)0));
  }
#line 2362
  i = 0;
  {
#line 2362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2362
    if (! (i < numcomps)) {
#line 2362
      goto while_break;
    }
#line 2363
    (cmptparm + i)->prec = (OPJ_UINT32 )raw_cp->rawBitDepth;
#line 2364
    (cmptparm + i)->sgnd = (OPJ_UINT32 )raw_cp->rawSigned;
#line 2365
    (cmptparm + i)->dx = (OPJ_UINT32 )(subsampling_dx * (raw_cp->rawComps + i)->dx);
#line 2366
    (cmptparm + i)->dy = (OPJ_UINT32 )(subsampling_dy * (raw_cp->rawComps + i)->dy);
#line 2367
    (cmptparm + i)->w = (OPJ_UINT32 )w;
#line 2368
    (cmptparm + i)->h = (OPJ_UINT32 )h;
#line 2362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2371
  image = opj_image_create((OPJ_UINT32 )numcomps, cmptparm + 0, color_space);
#line 2372
  free(cmptparm);
  }
#line 2373
  if (! image) {
    {
#line 2374
    fclose(f);
    }
#line 2375
    return ((opj_image_t *)((void *)0));
  }
#line 2378
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 2379
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 2380
  image->x1 = ((OPJ_UINT32 )parameters->image_offset_x0 + (OPJ_UINT32 )(w - 1) * (OPJ_UINT32 )subsampling_dx) + 1U;
#line 2382
  image->y1 = ((OPJ_UINT32 )parameters->image_offset_y0 + (OPJ_UINT32 )(h - 1) * (OPJ_UINT32 )subsampling_dy) + 1U;
#line 2385
  if (raw_cp->rawBitDepth <= 8) {
#line 2386
    value = (unsigned char )0;
#line 2387
    compno = 0;
    {
#line 2387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2387
      if (! (compno < numcomps)) {
#line 2387
        goto while_break___0;
      }
#line 2388
      nloop = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 2390
      i = 0;
      {
#line 2390
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2390
        if (! (i < nloop)) {
#line 2390
          goto while_break___1;
        }
        {
#line 2391
        __cil_tmp23 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 2391
        if (! __cil_tmp23) {
          {
#line 2392
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2393
          opj_image_destroy(image);
#line 2394
          fclose(f);
          }
#line 2395
          return ((opj_image_t *)((void *)0));
        }
#line 2397
        if (raw_cp->rawSigned) {
#line 2397
          tmp = (int )((char )value);
        } else {
#line 2397
          tmp = (int )value;
        }
#line 2397
        *((image->comps + compno)->data + i) = tmp;
#line 2390
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2387
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 2400
  if (raw_cp->rawBitDepth <= 16) {
#line 2402
    compno = 0;
    {
#line 2402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2402
      if (! (compno < numcomps)) {
#line 2402
        goto while_break___2;
      }
#line 2403
      nloop___0 = (w * h) / ((raw_cp->rawComps + compno)->dx * (raw_cp->rawComps + compno)->dy);
#line 2405
      i = 0;
      {
#line 2405
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2405
        if (! (i < nloop___0)) {
#line 2405
          goto while_break___3;
        }
        {
#line 2408
        __cil_tmp31 = fread(& temp1, (unsigned long )1, (unsigned long )1, f);
        }
#line 2408
        if (! __cil_tmp31) {
          {
#line 2409
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2410
          opj_image_destroy(image);
#line 2411
          fclose(f);
          }
#line 2412
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2414
        __cil_tmp32 = fread(& temp2, (unsigned long )1, (unsigned long )1, f);
        }
#line 2414
        if (! __cil_tmp32) {
          {
#line 2415
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2416
          opj_image_destroy(image);
#line 2417
          fclose(f);
          }
#line 2418
          return ((opj_image_t *)((void *)0));
        }
#line 2420
        if (big_endian) {
#line 2421
          value___0 = (unsigned short )(((int )temp1 << 8) + (int )temp2);
        } else {
#line 2423
          value___0 = (unsigned short )(((int )temp2 << 8) + (int )temp1);
        }
#line 2425
        if (raw_cp->rawSigned) {
#line 2425
          tmp___0 = (int )((short )value___0);
        } else {
#line 2425
          tmp___0 = (int )value___0;
        }
#line 2425
        *((image->comps + compno)->data + i) = tmp___0;
#line 2405
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2402
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 2429
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\nk\177EV");
#line 2431
    opj_image_destroy(image);
#line 2432
    fclose(f);
    }
#line 2433
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2436
  __cil_tmp36 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 2436
  if (__cil_tmp36) {
    {
#line 2437
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\nk\177EV");
    }
  }
  {
#line 2439
  fclose(f);
  }
#line 2441
  return (image);
}
}
#line 2444 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
opj_image_t *rawltoimage(char const   *filename , opj_cparameters_t *parameters ,
                         raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2447
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 0);
  }
#line 2447
  return (__cil_tmp4);
}
}
#line 2450 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  opj_image_t *__cil_tmp4 ;

  {
  {
#line 2453
  __cil_tmp4 = rawtoimage_common(filename, parameters, raw_cp, 1);
  }
#line 2453
  return (__cil_tmp4);
}
}
#line 2456 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
static int imagetoraw_common(opj_image_t *image , char const   *outfile , OPJ_BOOL big_endian ) 
{ 
  FILE *rawFile ;
  size_t res ;
  unsigned int compno ;
  unsigned int numcomps ;
  int w ;
  int h ;
  int fails ;
  int line ;
  int row ;
  int curr ;
  int mask ;
  int *ptr ;
  unsigned char uc ;
  FILE *__cil_tmp17 ;
  char const   *tmp ;
  unsigned long __cil_tmp19 ;
  int *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  union __anonunion_176 uc16 ;
  unsigned long __cil_tmp28 ;
  int *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  union __anonunion_177 uc16___0 ;
  unsigned long __cil_tmp33 ;
  int *__cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;

  {
#line 2459
  rawFile = (FILE *)((void *)0);
#line 2468
  if ((image->numcomps * image->x1) * image->y1 == 0U) {
    {
#line 2469
    fprintf(stderr, "\nError: invalid raw image parameters\nV");
    }
#line 2470
    return (1);
  }
#line 2473
  numcomps = image->numcomps;
#line 2475
  if (numcomps > 4U) {
#line 2476
    numcomps = (unsigned int )4;
  }
#line 2479
  compno = (unsigned int )1;
  {
#line 2479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2479
    if (! (compno < numcomps)) {
#line 2479
      goto while_break;
    }
#line 2480
    if ((image->comps + 0)->dx != (image->comps + compno)->dx) {
#line 2481
      goto while_break;
    }
#line 2483
    if ((image->comps + 0)->dy != (image->comps + compno)->dy) {
#line 2484
      goto while_break;
    }
#line 2486
    if ((image->comps + 0)->prec != (image->comps + compno)->prec) {
#line 2487
      goto while_break;
    }
#line 2489
    if ((image->comps + 0)->sgnd != (image->comps + compno)->sgnd) {
#line 2490
      goto while_break;
    }
#line 2479
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2493
  if (compno != numcomps) {
    {
#line 2494
    fprintf(stderr, "imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\n");
#line 2496
    fprintf(stderr, "\tAborting\n");
    }
#line 2497
    return (1);
  }
  {
#line 2500
  rawFile = fopen(outfile, "wbk\177EV");
  }
#line 2501
  if (! rawFile) {
    {
#line 2502
    fprintf(stderr, "Failed to open %s for writing !!\n|k\177EV", outfile);
    }
#line 2503
    return (1);
  }
  {
#line 2506
  fails = 1;
#line 2507
  fprintf(stdout, "Raw image characteristics: %d components\n", image->numcomps);
#line 2509
  compno = (unsigned int )0;
  }
  {
#line 2509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2509
    if (! (compno < image->numcomps)) {
#line 2509
      goto while_break___0;
    }
#line 2510
    if ((image->comps + compno)->sgnd == 1U) {
#line 2510
      tmp = "signed";
    } else {
#line 2510
      tmp = "unsigned\220";
    }
    {
#line 2510
    fprintf(stdout, "Component %u characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 2515
    w = (int )(image->comps + compno)->w;
#line 2516
    h = (int )(image->comps + compno)->h;
    }
#line 2518
    if ((image->comps + compno)->prec <= 8U) {
#line 2519
      if ((image->comps + compno)->sgnd == 1U) {
#line 2520
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2521
        ptr = (image->comps + compno)->data;
#line 2522
        line = 0;
        {
#line 2522
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2522
          if (! (line < h)) {
#line 2522
            goto while_break___1;
          }
#line 2523
          row = 0;
          {
#line 2523
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2523
            if (! (row < w)) {
#line 2523
              goto while_break___2;
            }
#line 2524
            curr = *ptr;
#line 2525
            if (curr > 127) {
#line 2526
              curr = 127;
            } else
#line 2527
            if (curr < -128) {
#line 2528
              curr = - 128;
            }
            {
#line 2530
            uc = (unsigned char )(curr & mask);
#line 2531
            res = fwrite(& uc, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2532
            if (res < 1UL) {
              {
#line 2533
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2534
              goto fin;
            }
#line 2536
            ptr ++;
#line 2523
            row ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2522
          line ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 2539
      if ((image->comps + compno)->sgnd == 0U) {
#line 2540
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2541
        ptr = (image->comps + compno)->data;
#line 2542
        line = 0;
        {
#line 2542
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2542
          if (! (line < h)) {
#line 2542
            goto while_break___3;
          }
#line 2543
          row = 0;
          {
#line 2543
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2543
            if (! (row < w)) {
#line 2543
              goto while_break___4;
            }
#line 2544
            curr = *ptr;
#line 2545
            if (curr > 255) {
#line 2546
              curr = 255;
            } else
#line 2547
            if (curr < 0) {
#line 2548
              curr = 0;
            }
            {
#line 2550
            uc = (unsigned char )(curr & mask);
#line 2551
            res = fwrite(& uc, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2552
            if (res < 1UL) {
              {
#line 2553
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2554
              goto fin;
            }
#line 2556
            ptr ++;
#line 2543
            row ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2542
          line ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else
#line 2560
    if ((image->comps + compno)->prec <= 16U) {
#line 2561
      if ((image->comps + compno)->sgnd == 1U) {
#line 2566
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2567
        ptr = (image->comps + compno)->data;
#line 2568
        line = 0;
        {
#line 2568
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2568
          if (! (line < h)) {
#line 2568
            goto while_break___5;
          }
#line 2569
          row = 0;
          {
#line 2569
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2569
            if (! (row < w)) {
#line 2569
              goto while_break___6;
            }
#line 2570
            curr = *ptr;
#line 2571
            if (curr > 32767) {
#line 2572
              curr = 32767;
            } else
#line 2573
            if (curr < -32768) {
#line 2574
              curr = - 32768;
            }
            {
#line 2576
            uc16.val = (short )(curr & mask);
#line 2577
            res = fwrite((signed char *)uc16.vals, (unsigned long )1, (unsigned long )2,
                         rawFile);
            }
#line 2578
            if (res < 2UL) {
              {
#line 2579
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
              }
#line 2580
              goto fin;
            }
#line 2582
            ptr ++;
#line 2569
            row ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 2568
          line ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 2585
      if ((image->comps + compno)->sgnd == 0U) {
#line 2590
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2591
        ptr = (image->comps + compno)->data;
#line 2592
        line = 0;
        {
#line 2592
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2592
          if (! (line < h)) {
#line 2592
            goto while_break___7;
          }
#line 2593
          row = 0;
          {
#line 2593
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2593
            if (! (row < w)) {
#line 2593
              goto while_break___8;
            }
#line 2594
            curr = *ptr;
#line 2595
            if (curr > 65535) {
#line 2596
              curr = 65535;
            } else
#line 2597
            if (curr < 0) {
#line 2598
              curr = 0;
            }
            {
#line 2600
            uc16___0.val = (unsigned short )(curr & mask);
#line 2601
            res = fwrite((unsigned char *)uc16___0.vals, (unsigned long )1, (unsigned long )2,
                         rawFile);
            }
#line 2602
            if (res < 2UL) {
              {
#line 2603
              fprintf(stderr, "failed to write 2 byte for %s\n", outfile);
              }
#line 2604
              goto fin;
            }
#line 2606
            ptr ++;
#line 2593
            row ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 2592
          line ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else
#line 2610
    if ((image->comps + compno)->prec <= 32U) {
      {
#line 2611
      fprintf(stderr, "More than 16 bits per component not handled yet\n\220");
      }
#line 2612
      goto fin;
    } else {
      {
#line 2614
      fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
      }
#line 2615
      goto fin;
    }
#line 2509
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2618
  fails = 0;
  fin: 
  {
#line 2620
  fclose(rawFile);
  }
#line 2621
  return (fails);
}
}
#line 2624 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 2626
  __cil_tmp3 = imagetoraw_common(image, outfile, 1);
  }
#line 2626
  return (__cil_tmp3);
}
}
#line 2629 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convert.c"
int imagetorawl(opj_image_t *image , char const   *outfile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 2631
  __cil_tmp3 = imagetoraw_common(image, outfile, 0);
  }
#line 2631
  return (__cil_tmp3);
}
}
#line 83 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1R(OPJ_UINT8 *pSrc , OPJ_INT32 srcStride , OPJ_INT32 *pDst ,
                                     OPJ_INT32 dstStride , OPJ_UINT8 *pLUT , OPJ_UINT32 width ,
                                     OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 y ;
  OPJ_UINT32 x ;
  OPJ_UINT32 __cil_tmp10 ;

  {
#line 91
  y = height;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (y != 0U)) {
#line 91
      goto while_break;
    }
#line 94
    x = (OPJ_UINT32 )0;
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 94
      if (! (x < width)) {
#line 94
        goto while_break___0;
      }
#line 95
      *(pDst + x) = (OPJ_INT32 )*(pLUT + *(pSrc + x));
#line 94
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    pSrc += srcStride;
#line 98
    pDst += dstStride;
#line 91
    y --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 102 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void opj_applyLUT8u_8u32s_C1P3R(OPJ_UINT8 *pSrc , OPJ_INT32 srcStride , OPJ_INT32 * const  *pDst ,
                                       OPJ_INT32 *pDstStride , OPJ_UINT8 * const  *pLUT ,
                                       OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 y ;
  OPJ_INT32 *pR ;
  OPJ_INT32 *pG ;
  OPJ_INT32 *pB ;
  OPJ_UINT8 *pLUT_R ;
  OPJ_UINT8 *pLUT_G ;
  OPJ_UINT8 *pLUT_B ;
  OPJ_UINT32 x ;
  OPJ_UINT8 idx ;
  OPJ_UINT32 __cil_tmp17 ;

  {
#line 109
  pR = *(pDst + 0);
#line 110
  pG = *(pDst + 1);
#line 111
  pB = *(pDst + 2);
#line 112
  pLUT_R = *(pLUT + 0);
#line 113
  pLUT_G = *(pLUT + 1);
#line 114
  pLUT_B = *(pLUT + 2);
#line 116
  y = height;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (y != 0U)) {
#line 116
      goto while_break;
    }
#line 119
    x = (OPJ_UINT32 )0;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! (x < width)) {
#line 119
        goto while_break___0;
      }
#line 120
      idx = *(pSrc + x);
#line 121
      *(pR + x) = (OPJ_INT32 )*(pLUT_R + idx);
#line 122
      *(pG + x) = (OPJ_INT32 )*(pLUT_G + idx);
#line 123
      *(pB + x) = (OPJ_INT32 )*(pLUT_B + idx);
#line 119
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    pSrc += srcStride;
#line 126
    pR += *(pDstStride + 0);
#line 127
    pG += *(pDstStride + 1);
#line 128
    pB += *(pDstStride + 2);
#line 116
    y --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 132 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void bmp24toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;
  int __cil_tmp10 ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;

  {
#line 138
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 140
  width = (image->comps + 0)->w;
#line 141
  height = (image->comps + 0)->h;
#line 143
  index___0 = 0;
#line 144
  pSrc = pData + (height - 1U) * stride;
#line 145
  y = (OPJ_UINT32 )0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (y < height)) {
#line 145
      goto while_break;
    }
#line 146
    x = (OPJ_UINT32 )0;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (! (x < width)) {
#line 146
        goto while_break___0;
      }
#line 147
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )*(pSrc + (3U * x + 2U));
#line 148
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )*(pSrc + (3U * x + 1U));
#line 149
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )*(pSrc + 3U * x);
#line 150
      index___0 ++;
#line 146
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 152
    pSrc -= stride;
#line 145
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 156 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask , OPJ_UINT32 *shift , OPJ_UINT32 *prec ) 
{ 
  OPJ_UINT32 l_shift ;
  OPJ_UINT32 l_prec ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 161
  l_prec = 0U;
#line 161
  l_shift = l_prec;
#line 163
  if (mask != 0U) {
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      if (! ((mask & 1U) == 0U)) {
#line 164
        goto while_break;
      }
#line 165
      mask >>= 1;
#line 166
      l_shift ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! (mask & 1U)) {
#line 168
        goto while_break___0;
      }
#line 169
      mask >>= 1;
#line 170
      l_prec ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 173
  *shift = l_shift;
#line 174
  *prec = l_prec;
  return;
}
}
#line 177 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void bmpmask32toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                             OPJ_UINT32 redMask , OPJ_UINT32 greenMask , OPJ_UINT32 blueMask ,
                             OPJ_UINT32 alphaMask ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;
  OPJ_BOOL hasAlpha ;
  OPJ_UINT32 redShift ;
  OPJ_UINT32 redPrec ;
  OPJ_UINT32 greenShift ;
  OPJ_UINT32 greenPrec ;
  OPJ_UINT32 blueShift ;
  OPJ_UINT32 bluePrec ;
  OPJ_UINT32 alphaShift ;
  OPJ_UINT32 alphaPrec ;
  OPJ_UINT32 value ;
  int __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
  {
#line 184
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 191
  width = (image->comps + 0)->w;
#line 192
  height = (image->comps + 0)->h;
#line 194
  hasAlpha = image->numcomps > 3U;
#line 196
  bmp_mask_get_shift_and_prec(redMask, & redShift, & redPrec);
#line 197
  bmp_mask_get_shift_and_prec(greenMask, & greenShift, & greenPrec);
#line 198
  bmp_mask_get_shift_and_prec(blueMask, & blueShift, & bluePrec);
#line 199
  bmp_mask_get_shift_and_prec(alphaMask, & alphaShift, & alphaPrec);
#line 201
  (image->comps + 0)->prec = redPrec;
#line 202
  (image->comps + 1)->prec = greenPrec;
#line 203
  (image->comps + 2)->prec = bluePrec;
  }
#line 204
  if (hasAlpha) {
#line 205
    (image->comps + 3)->prec = alphaPrec;
  }
#line 208
  index___0 = 0;
#line 209
  pSrc = pData + (height - 1U) * stride;
#line 210
  y = (OPJ_UINT32 )0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (y < height)) {
#line 210
      goto while_break;
    }
#line 211
    x = (OPJ_UINT32 )0;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (x < width)) {
#line 211
        goto while_break___0;
      }
#line 212
      value = 0U;
#line 214
      value |= (OPJ_UINT32 )*(pSrc + 4U * x);
#line 215
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 1U)) << 8;
#line 216
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 2U)) << 16;
#line 217
      value |= (OPJ_UINT32 )*(pSrc + (4U * x + 3U)) << 24;
#line 219
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )((value & redMask) >> redShift);
#line 221
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )((value & greenMask) >> greenShift);
#line 223
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )((value & blueMask) >> blueShift);
#line 225
      if (hasAlpha) {
#line 226
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )((value & alphaMask) >> alphaShift);
      }
#line 229
      index___0 ++;
#line 211
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 231
    pSrc -= stride;
#line 210
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 235 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static void bmpmask16toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                             OPJ_UINT32 redMask , OPJ_UINT32 greenMask , OPJ_UINT32 blueMask ,
                             OPJ_UINT32 alphaMask ) 
{ 
  int index___0 ;
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT8 *pSrc ;
  OPJ_BOOL hasAlpha ;
  OPJ_UINT32 redShift ;
  OPJ_UINT32 redPrec ;
  OPJ_UINT32 greenShift ;
  OPJ_UINT32 greenPrec ;
  OPJ_UINT32 blueShift ;
  OPJ_UINT32 bluePrec ;
  OPJ_UINT32 alphaShift ;
  OPJ_UINT32 alphaPrec ;
  OPJ_UINT32 value ;
  int __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;

  {
  {
#line 242
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 249
  width = (image->comps + 0)->w;
#line 250
  height = (image->comps + 0)->h;
#line 252
  hasAlpha = image->numcomps > 3U;
#line 254
  bmp_mask_get_shift_and_prec(redMask, & redShift, & redPrec);
#line 255
  bmp_mask_get_shift_and_prec(greenMask, & greenShift, & greenPrec);
#line 256
  bmp_mask_get_shift_and_prec(blueMask, & blueShift, & bluePrec);
#line 257
  bmp_mask_get_shift_and_prec(alphaMask, & alphaShift, & alphaPrec);
#line 259
  (image->comps + 0)->prec = redPrec;
#line 260
  (image->comps + 1)->prec = greenPrec;
#line 261
  (image->comps + 2)->prec = bluePrec;
  }
#line 262
  if (hasAlpha) {
#line 263
    (image->comps + 3)->prec = alphaPrec;
  }
#line 266
  index___0 = 0;
#line 267
  pSrc = pData + (height - 1U) * stride;
#line 268
  y = (OPJ_UINT32 )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (y < height)) {
#line 268
      goto while_break;
    }
#line 269
    x = (OPJ_UINT32 )0;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! (x < width)) {
#line 269
        goto while_break___0;
      }
#line 270
      value = 0U;
#line 272
      value |= (OPJ_UINT32 )*(pSrc + 2U * x);
#line 273
      value |= (OPJ_UINT32 )*(pSrc + (2U * x + 1U)) << 8;
#line 275
      *((image->comps + 0)->data + index___0) = (OPJ_INT32 )((value & redMask) >> redShift);
#line 277
      *((image->comps + 1)->data + index___0) = (OPJ_INT32 )((value & greenMask) >> greenShift);
#line 279
      *((image->comps + 2)->data + index___0) = (OPJ_INT32 )((value & blueMask) >> blueShift);
#line 281
      if (hasAlpha) {
#line 282
        *((image->comps + 3)->data + index___0) = (OPJ_INT32 )((value & alphaMask) >> alphaShift);
      }
#line 285
      index___0 ++;
#line 269
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    pSrc -= stride;
#line 268
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 291 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static opj_image_t *bmp8toimage(OPJ_UINT8 *pData , OPJ_UINT32 stride , opj_image_t *image ,
                                OPJ_UINT8 * const  *pLUT ) 
{ 
  OPJ_UINT32 width ;
  OPJ_UINT32 height ;
  OPJ_UINT8 *pSrc ;
  OPJ_INT32 *pDst[3] ;
  OPJ_INT32 pDstStride[3] ;

  {
#line 295
  pSrc = (OPJ_UINT8 *)((void *)0);
#line 297
  width = (image->comps + 0)->w;
#line 298
  height = (image->comps + 0)->h;
#line 300
  pSrc = pData + (height - 1U) * stride;
#line 301
  if (image->numcomps == 1U) {
    {
#line 302
    opj_applyLUT8u_8u32s_C1R(pSrc, - ((OPJ_INT32 )stride), (image->comps + 0)->data,
                             (OPJ_INT32 )width, *(pLUT + 0), width, height);
    }
  } else {
    {
#line 308
    pDst[0] = (image->comps + 0)->data;
#line 309
    pDst[1] = (image->comps + 1)->data;
#line 310
    pDst[2] = (image->comps + 2)->data;
#line 311
    pDstStride[0] = (OPJ_INT32 )width;
#line 312
    pDstStride[1] = (OPJ_INT32 )width;
#line 313
    pDstStride[2] = (OPJ_INT32 )width;
#line 314
    opj_applyLUT8u_8u32s_C1P3R(pSrc, - ((OPJ_INT32 )stride), (OPJ_INT32 * const  *)((OPJ_INT32 **)pDst),
                               (OPJ_INT32 *)pDstStride, pLUT, width, height);
    }
  }
#line 317
  return (image);
}
}
#line 320 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_file_header(FILE *IN , OPJ_BITMAPFILEHEADER *header ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 322
  __cil_tmp3 = getc(IN);
#line 322
  header->bfType = (OPJ_UINT16 )__cil_tmp3;
#line 323
  __cil_tmp4 = getc(IN);
  }
#line 323
  header->bfType |= (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp4 << 8));
#line 325
  if ((int )header->bfType != 19778) {
    {
#line 326
    fprintf(stderr, "Error, not a BMP file!\n");
    }
#line 327
    return (0);
  }
  {
#line 332
  __cil_tmp5 = getc(IN);
#line 332
  header->bfSize = (OPJ_UINT32 )__cil_tmp5;
#line 333
  __cil_tmp6 = getc(IN);
  }
  {
#line 333
  header->bfSize |= (OPJ_UINT32 )__cil_tmp6 << 8;
#line 334
  __cil_tmp7 = getc(IN);
  }
  {
#line 334
  header->bfSize |= (OPJ_UINT32 )__cil_tmp7 << 16;
#line 335
  __cil_tmp8 = getc(IN);
  }
  {
#line 335
  header->bfSize |= (OPJ_UINT32 )__cil_tmp8 << 24;
#line 337
  __cil_tmp9 = getc(IN);
#line 337
  header->bfReserved1 = (OPJ_UINT16 )__cil_tmp9;
#line 338
  __cil_tmp10 = getc(IN);
  }
  {
#line 338
  header->bfReserved1 |= (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp10 << 8));
#line 340
  __cil_tmp11 = getc(IN);
#line 340
  header->bfReserved2 = (OPJ_UINT16 )__cil_tmp11;
#line 341
  __cil_tmp12 = getc(IN);
  }
  {
#line 341
  header->bfReserved2 |= (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp12 << 8));
#line 343
  __cil_tmp13 = getc(IN);
#line 343
  header->bfOffBits = (OPJ_UINT32 )__cil_tmp13;
#line 344
  __cil_tmp14 = getc(IN);
  }
  {
#line 344
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp14 << 8;
#line 345
  __cil_tmp15 = getc(IN);
  }
  {
#line 345
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp15 << 16;
#line 346
  __cil_tmp16 = getc(IN);
  }
#line 346
  header->bfOffBits |= (OPJ_UINT32 )__cil_tmp16 << 24;
#line 347
  return (1);
}
}
#line 349 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_info_header(FILE *IN , OPJ_BITMAPINFOHEADER *header ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;

  {
  {
#line 351
  memset(header, 0, sizeof(*header));
#line 354
  __cil_tmp3 = getc(IN);
#line 354
  header->biSize = (OPJ_UINT32 )__cil_tmp3;
#line 355
  __cil_tmp4 = getc(IN);
  }
  {
#line 355
  header->biSize |= (OPJ_UINT32 )__cil_tmp4 << 8;
#line 356
  __cil_tmp5 = getc(IN);
  }
  {
#line 356
  header->biSize |= (OPJ_UINT32 )__cil_tmp5 << 16;
#line 357
  __cil_tmp6 = getc(IN);
  }
#line 357
  header->biSize |= (OPJ_UINT32 )__cil_tmp6 << 24;
  {
#line 365
  if (header->biSize == 124U) {
#line 365
    goto case_124;
  }
#line 365
  if (header->biSize == 108U) {
#line 365
    goto case_124;
  }
#line 365
  if (header->biSize == 56U) {
#line 365
    goto case_124;
  }
#line 365
  if (header->biSize == 52U) {
#line 365
    goto case_124;
  }
#line 365
  if (header->biSize == 40U) {
#line 365
    goto case_124;
  }
#line 365
  if (header->biSize == 12U) {
#line 365
    goto case_124;
  }
#line 367
  goto switch_default;
  case_124: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 366
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 368
  fprintf(stderr, "Error, unknown BMP header size %d\n", header->biSize);
  }
#line 369
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 372
  __cil_tmp7 = getc(IN);
#line 372
  header->biWidth = (OPJ_UINT32 )__cil_tmp7;
#line 373
  __cil_tmp8 = getc(IN);
  }
  {
#line 373
  header->biWidth |= (OPJ_UINT32 )__cil_tmp8 << 8;
#line 374
  __cil_tmp9 = getc(IN);
  }
  {
#line 374
  header->biWidth |= (OPJ_UINT32 )__cil_tmp9 << 16;
#line 375
  __cil_tmp10 = getc(IN);
  }
  {
#line 375
  header->biWidth |= (OPJ_UINT32 )__cil_tmp10 << 24;
#line 377
  __cil_tmp11 = getc(IN);
#line 377
  header->biHeight = (OPJ_UINT32 )__cil_tmp11;
#line 378
  __cil_tmp12 = getc(IN);
  }
  {
#line 378
  header->biHeight |= (OPJ_UINT32 )__cil_tmp12 << 8;
#line 379
  __cil_tmp13 = getc(IN);
  }
  {
#line 379
  header->biHeight |= (OPJ_UINT32 )__cil_tmp13 << 16;
#line 380
  __cil_tmp14 = getc(IN);
  }
  {
#line 380
  header->biHeight |= (OPJ_UINT32 )__cil_tmp14 << 24;
#line 382
  __cil_tmp15 = getc(IN);
#line 382
  header->biPlanes = (OPJ_UINT16 )__cil_tmp15;
#line 383
  __cil_tmp16 = getc(IN);
  }
  {
#line 383
  header->biPlanes |= (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp16 << 8));
#line 385
  __cil_tmp17 = getc(IN);
#line 385
  header->biBitCount = (OPJ_UINT16 )__cil_tmp17;
#line 386
  __cil_tmp18 = getc(IN);
  }
#line 386
  header->biBitCount |= (int )((OPJ_UINT16 )((OPJ_UINT32 )__cil_tmp18 << 8));
#line 387
  if ((int )header->biBitCount == 0) {
    {
#line 388
    fprintf(stderr, "Error, invalid biBitCount %d\n", 0);
    }
#line 389
    return (0);
  }
#line 392
  if (header->biSize >= 40U) {
    {
#line 393
    __cil_tmp19 = getc(IN);
#line 393
    header->biCompression = (OPJ_UINT32 )__cil_tmp19;
#line 394
    __cil_tmp20 = getc(IN);
    }
    {
#line 394
    header->biCompression |= (OPJ_UINT32 )__cil_tmp20 << 8;
#line 395
    __cil_tmp21 = getc(IN);
    }
    {
#line 395
    header->biCompression |= (OPJ_UINT32 )__cil_tmp21 << 16;
#line 396
    __cil_tmp22 = getc(IN);
    }
    {
#line 396
    header->biCompression |= (OPJ_UINT32 )__cil_tmp22 << 24;
#line 398
    __cil_tmp23 = getc(IN);
#line 398
    header->biSizeImage = (OPJ_UINT32 )__cil_tmp23;
#line 399
    __cil_tmp24 = getc(IN);
    }
    {
#line 399
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp24 << 8;
#line 400
    __cil_tmp25 = getc(IN);
    }
    {
#line 400
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp25 << 16;
#line 401
    __cil_tmp26 = getc(IN);
    }
    {
#line 401
    header->biSizeImage |= (OPJ_UINT32 )__cil_tmp26 << 24;
#line 403
    __cil_tmp27 = getc(IN);
#line 403
    header->biXpelsPerMeter = (OPJ_UINT32 )__cil_tmp27;
#line 404
    __cil_tmp28 = getc(IN);
    }
    {
#line 404
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp28 << 8;
#line 405
    __cil_tmp29 = getc(IN);
    }
    {
#line 405
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp29 << 16;
#line 406
    __cil_tmp30 = getc(IN);
    }
    {
#line 406
    header->biXpelsPerMeter |= (OPJ_UINT32 )__cil_tmp30 << 24;
#line 408
    __cil_tmp31 = getc(IN);
#line 408
    header->biYpelsPerMeter = (OPJ_UINT32 )__cil_tmp31;
#line 409
    __cil_tmp32 = getc(IN);
    }
    {
#line 409
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp32 << 8;
#line 410
    __cil_tmp33 = getc(IN);
    }
    {
#line 410
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp33 << 16;
#line 411
    __cil_tmp34 = getc(IN);
    }
    {
#line 411
    header->biYpelsPerMeter |= (OPJ_UINT32 )__cil_tmp34 << 24;
#line 413
    __cil_tmp35 = getc(IN);
#line 413
    header->biClrUsed = (OPJ_UINT32 )__cil_tmp35;
#line 414
    __cil_tmp36 = getc(IN);
    }
    {
#line 414
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp36 << 8;
#line 415
    __cil_tmp37 = getc(IN);
    }
    {
#line 415
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp37 << 16;
#line 416
    __cil_tmp38 = getc(IN);
    }
    {
#line 416
    header->biClrUsed |= (OPJ_UINT32 )__cil_tmp38 << 24;
#line 418
    __cil_tmp39 = getc(IN);
#line 418
    header->biClrImportant = (OPJ_UINT32 )__cil_tmp39;
#line 419
    __cil_tmp40 = getc(IN);
    }
    {
#line 419
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp40 << 8;
#line 420
    __cil_tmp41 = getc(IN);
    }
    {
#line 420
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp41 << 16;
#line 421
    __cil_tmp42 = getc(IN);
    }
#line 421
    header->biClrImportant |= (OPJ_UINT32 )__cil_tmp42 << 24;
  }
#line 424
  if (header->biSize >= 56U) {
    {
#line 425
    __cil_tmp43 = getc(IN);
#line 425
    header->biRedMask = (OPJ_UINT32 )__cil_tmp43;
#line 426
    __cil_tmp44 = getc(IN);
    }
    {
#line 426
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp44 << 8;
#line 427
    __cil_tmp45 = getc(IN);
    }
    {
#line 427
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp45 << 16;
#line 428
    __cil_tmp46 = getc(IN);
    }
#line 428
    header->biRedMask |= (OPJ_UINT32 )__cil_tmp46 << 24;
#line 430
    if (! header->biRedMask) {
      {
#line 431
      fprintf(stderr, "Error, invalid red mask value %d\n", header->biRedMask);
      }
#line 432
      return (0);
    }
    {
#line 435
    __cil_tmp47 = getc(IN);
#line 435
    header->biGreenMask = (OPJ_UINT32 )__cil_tmp47;
#line 436
    __cil_tmp48 = getc(IN);
    }
    {
#line 436
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp48 << 8;
#line 437
    __cil_tmp49 = getc(IN);
    }
    {
#line 437
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp49 << 16;
#line 438
    __cil_tmp50 = getc(IN);
    }
#line 438
    header->biGreenMask |= (OPJ_UINT32 )__cil_tmp50 << 24;
#line 440
    if (! header->biGreenMask) {
      {
#line 441
      fprintf(stderr, "Error, invalid green mask value %d\n", header->biGreenMask);
      }
#line 442
      return (0);
    }
    {
#line 445
    __cil_tmp51 = getc(IN);
#line 445
    header->biBlueMask = (OPJ_UINT32 )__cil_tmp51;
#line 446
    __cil_tmp52 = getc(IN);
    }
    {
#line 446
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp52 << 8;
#line 447
    __cil_tmp53 = getc(IN);
    }
    {
#line 447
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp53 << 16;
#line 448
    __cil_tmp54 = getc(IN);
    }
#line 448
    header->biBlueMask |= (OPJ_UINT32 )__cil_tmp54 << 24;
#line 450
    if (! header->biBlueMask) {
      {
#line 451
      fprintf(stderr, "Error, invalid blue mask value %d\n", header->biBlueMask);
      }
#line 452
      return (0);
    }
    {
#line 455
    __cil_tmp55 = getc(IN);
#line 455
    header->biAlphaMask = (OPJ_UINT32 )__cil_tmp55;
#line 456
    __cil_tmp56 = getc(IN);
    }
    {
#line 456
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp56 << 8;
#line 457
    __cil_tmp57 = getc(IN);
    }
    {
#line 457
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp57 << 16;
#line 458
    __cil_tmp58 = getc(IN);
    }
#line 458
    header->biAlphaMask |= (OPJ_UINT32 )__cil_tmp58 << 24;
  }
#line 461
  if (header->biSize >= 108U) {
    {
#line 462
    __cil_tmp59 = getc(IN);
#line 462
    header->biColorSpaceType = (OPJ_UINT32 )__cil_tmp59;
#line 463
    __cil_tmp60 = getc(IN);
    }
    {
#line 463
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp60 << 8;
#line 464
    __cil_tmp61 = getc(IN);
    }
    {
#line 464
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp61 << 16;
#line 465
    __cil_tmp62 = getc(IN);
    }
    {
#line 465
    header->biColorSpaceType |= (OPJ_UINT32 )__cil_tmp62 << 24;
#line 467
    __cil_tmp63 = fread(& header->biColorSpaceEP, (unsigned long )1U, sizeof(header->biColorSpaceEP),
                        IN);
    }
#line 467
    if (__cil_tmp63 != sizeof(header->biColorSpaceEP)) {
      {
#line 469
      fprintf(stderr, "Error, can\'t  read BMP header\n");
      }
#line 470
      return (0);
    }
    {
#line 473
    __cil_tmp64 = getc(IN);
#line 473
    header->biRedGamma = (OPJ_UINT32 )__cil_tmp64;
#line 474
    __cil_tmp65 = getc(IN);
    }
    {
#line 474
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp65 << 8;
#line 475
    __cil_tmp66 = getc(IN);
    }
    {
#line 475
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp66 << 16;
#line 476
    __cil_tmp67 = getc(IN);
    }
    {
#line 476
    header->biRedGamma |= (OPJ_UINT32 )__cil_tmp67 << 24;
#line 478
    __cil_tmp68 = getc(IN);
#line 478
    header->biGreenGamma = (OPJ_UINT32 )__cil_tmp68;
#line 479
    __cil_tmp69 = getc(IN);
    }
    {
#line 479
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp69 << 8;
#line 480
    __cil_tmp70 = getc(IN);
    }
    {
#line 480
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp70 << 16;
#line 481
    __cil_tmp71 = getc(IN);
    }
    {
#line 481
    header->biGreenGamma |= (OPJ_UINT32 )__cil_tmp71 << 24;
#line 483
    __cil_tmp72 = getc(IN);
#line 483
    header->biBlueGamma = (OPJ_UINT32 )__cil_tmp72;
#line 484
    __cil_tmp73 = getc(IN);
    }
    {
#line 484
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp73 << 8;
#line 485
    __cil_tmp74 = getc(IN);
    }
    {
#line 485
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp74 << 16;
#line 486
    __cil_tmp75 = getc(IN);
    }
#line 486
    header->biBlueGamma |= (OPJ_UINT32 )__cil_tmp75 << 24;
  }
#line 489
  if (header->biSize >= 124U) {
    {
#line 490
    __cil_tmp76 = getc(IN);
#line 490
    header->biIntent = (OPJ_UINT32 )__cil_tmp76;
#line 491
    __cil_tmp77 = getc(IN);
    }
    {
#line 491
    header->biIntent |= (OPJ_UINT32 )__cil_tmp77 << 8;
#line 492
    __cil_tmp78 = getc(IN);
    }
    {
#line 492
    header->biIntent |= (OPJ_UINT32 )__cil_tmp78 << 16;
#line 493
    __cil_tmp79 = getc(IN);
    }
    {
#line 493
    header->biIntent |= (OPJ_UINT32 )__cil_tmp79 << 24;
#line 495
    __cil_tmp80 = getc(IN);
#line 495
    header->biIccProfileData = (OPJ_UINT32 )__cil_tmp80;
#line 496
    __cil_tmp81 = getc(IN);
    }
    {
#line 496
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp81 << 8;
#line 497
    __cil_tmp82 = getc(IN);
    }
    {
#line 497
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp82 << 16;
#line 498
    __cil_tmp83 = getc(IN);
    }
    {
#line 498
    header->biIccProfileData |= (OPJ_UINT32 )__cil_tmp83 << 24;
#line 500
    __cil_tmp84 = getc(IN);
#line 500
    header->biIccProfileSize = (OPJ_UINT32 )__cil_tmp84;
#line 501
    __cil_tmp85 = getc(IN);
    }
    {
#line 501
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp85 << 8;
#line 502
    __cil_tmp86 = getc(IN);
    }
    {
#line 502
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp86 << 16;
#line 503
    __cil_tmp87 = getc(IN);
    }
    {
#line 503
    header->biIccProfileSize |= (OPJ_UINT32 )__cil_tmp87 << 24;
#line 505
    __cil_tmp88 = getc(IN);
#line 505
    header->biReserved = (OPJ_UINT32 )__cil_tmp88;
#line 506
    __cil_tmp89 = getc(IN);
    }
    {
#line 506
    header->biReserved |= (OPJ_UINT32 )__cil_tmp89 << 8;
#line 507
    __cil_tmp90 = getc(IN);
    }
    {
#line 507
    header->biReserved |= (OPJ_UINT32 )__cil_tmp90 << 16;
#line 508
    __cil_tmp91 = getc(IN);
    }
#line 508
    header->biReserved |= (OPJ_UINT32 )__cil_tmp91 << 24;
  }
#line 510
  return (1);
}
}
#line 513 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_raw_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                  OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  unsigned long __cil_tmp6 ;

  {
  {
#line 518
  __cil_tmp6 = fread(pData, sizeof(OPJ_UINT8 ), (unsigned long )(stride * height),
                     IN);
  }
#line 518
  if (__cil_tmp6 != (unsigned long )(stride * height)) {
    {
#line 519
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 521
    return (0);
  }
#line 523
  return (1);
}
}
#line 526 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle8_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                   OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT32 written ;
  OPJ_UINT8 *pix ;
  OPJ_UINT8 *beyond ;
  int c ;
  int __cil_tmp12 ;
  int j ;
  int c1_int ;
  OPJ_UINT8 c1 ;
  int __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;
  int __cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT8 *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int j___0 ;
  int c1_int___0 ;
  OPJ_UINT8 c1___0 ;
  int __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  int __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT8 *__cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 533
  beyond = pData + stride * height;
#line 534
  pix = pData;
#line 536
  written = 0U;
#line 536
  y = written;
#line 536
  x = y;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! (y < height)) {
#line 537
      goto while_break;
    }
    {
#line 538
    __cil_tmp12 = getc(IN);
#line 538
    c = __cil_tmp12;
    }
#line 539
    if (c == -1) {
#line 540
      return (0);
    }
#line 543
    if (c) {
      {
#line 547
      c1_int = getc(IN);
      }
#line 548
      if (c1_int == -1) {
#line 549
        return (0);
      }
#line 551
      c1 = (OPJ_UINT8 )c1_int;
#line 553
      j = 0;
      {
#line 553
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 553
        if (! ((j < c && x < width) && (OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 553
          goto while_break___0;
        }
#line 555
        *pix = c1;
#line 556
        written ++;
#line 554
        __cil_tmp20 = pix;
#line 554
        pix ++;
#line 554
        __cil_tmp19 = x;
#line 554
        x ++;
#line 554
        __cil_tmp18 = j;
#line 554
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 559
      c = getc(IN);
      }
#line 560
      if (c == -1) {
#line 561
        return (0);
      }
#line 564
      if (c == 0) {
#line 565
        x = (OPJ_UINT32 )0;
#line 566
        y ++;
#line 567
        pix = (pData + y * stride) + x;
      } else
#line 568
      if (c == 1) {
#line 569
        goto while_break;
      } else
#line 570
      if (c == 2) {
        {
#line 571
        c = getc(IN);
        }
#line 572
        if (c == -1) {
#line 573
          return (0);
        }
        {
#line 575
        x += (OPJ_UINT32 )c;
#line 576
        c = getc(IN);
        }
#line 577
        if (c == -1) {
#line 578
          return (0);
        }
#line 580
        y += (OPJ_UINT32 )c;
#line 581
        pix = (pData + y * stride) + x;
      } else {
#line 584
        j___0 = 0;
        {
#line 584
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 584
          if (! ((j___0 < c && x < width) && (OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 584
            goto while_break___1;
          }
          {
#line 588
          c1_int___0 = getc(IN);
          }
#line 589
          if (c1_int___0 == -1) {
#line 590
            return (0);
          }
#line 592
          c1___0 = (OPJ_UINT8 )c1_int___0;
#line 593
          *pix = c1___0;
#line 594
          written ++;
#line 585
          __cil_tmp31 = pix;
#line 585
          pix ++;
#line 585
          __cil_tmp30 = x;
#line 585
          x ++;
#line 585
          __cil_tmp29 = j___0;
#line 585
          j___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 596
        if ((OPJ_UINT32 )c & 1U) {
          {
#line 597
          c = getc(IN);
          }
#line 598
          if (c == -1) {
#line 599
            return (0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  if (written != width * height) {
    {
#line 607
    fprintf(stderr, "warning, image\'s actual size does not match advertized one\n");
    }
#line 608
    return (0);
  }
#line 611
  return (1);
}
}
#line 614 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
static OPJ_BOOL bmp_read_rle4_data(FILE *IN , OPJ_UINT8 *pData , OPJ_UINT32 stride ,
                                   OPJ_UINT32 width , OPJ_UINT32 height ) 
{ 
  OPJ_UINT32 x ;
  OPJ_UINT32 y ;
  OPJ_UINT32 written ;
  OPJ_UINT8 *pix ;
  OPJ_UINT8 *beyond ;
  int c ;
  int __cil_tmp12 ;
  int j ;
  int c1_int ;
  OPJ_UINT8 c1 ;
  int __cil_tmp16 ;
  unsigned int tmp ;
  OPJ_UINT32 __cil_tmp18 ;
  int __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT8 *__cil_tmp21 ;
  int __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int j___0 ;
  OPJ_UINT8 c1___0 ;
  int c1_int___0 ;
  int __cil_tmp29 ;
  unsigned int tmp___0 ;
  OPJ_UINT32 __cil_tmp31 ;
  int __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT8 *__cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 621
  beyond = pData + stride * height;
#line 622
  pix = pData;
#line 623
  written = 0U;
#line 623
  y = written;
#line 623
  x = y;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (y < height)) {
#line 624
      goto while_break;
    }
    {
#line 625
    __cil_tmp12 = getc(IN);
#line 625
    c = __cil_tmp12;
    }
#line 626
    if (c == -1) {
#line 627
      return (0);
    }
#line 630
    if (c) {
      {
#line 634
      c1_int = getc(IN);
      }
#line 635
      if (c1_int == -1) {
#line 636
        return (0);
      }
#line 638
      c1 = (OPJ_UINT8 )c1_int;
#line 640
      j = 0;
      {
#line 640
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 640
        if (! ((j < c && x < width) && (OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 640
          goto while_break___0;
        }
#line 642
        if (j & 1) {
#line 642
          tmp = (unsigned int )c1 & 15U;
        } else {
#line 642
          tmp = (unsigned int )((int )c1 >> 4) & 15U;
        }
#line 642
        *pix = (OPJ_UINT8 )tmp;
#line 643
        written ++;
#line 641
        __cil_tmp21 = pix;
#line 641
        pix ++;
#line 641
        __cil_tmp20 = x;
#line 641
        x ++;
#line 641
        __cil_tmp19 = j;
#line 641
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 646
      c = getc(IN);
      }
#line 647
      if (c == -1) {
#line 648
        return (0);
      }
#line 651
      if (c == 0) {
#line 652
        x = (OPJ_UINT32 )0;
#line 653
        y ++;
#line 654
        pix = pData + y * stride;
      } else
#line 655
      if (c == 1) {
#line 656
        goto while_break;
      } else
#line 657
      if (c == 2) {
        {
#line 658
        c = getc(IN);
        }
#line 659
        if (c == -1) {
#line 660
          return (0);
        }
        {
#line 662
        x += (OPJ_UINT32 )c;
#line 663
        c = getc(IN);
        }
#line 664
        if (c == -1) {
#line 665
          return (0);
        }
#line 667
        y += (OPJ_UINT32 )c;
#line 668
        pix = (pData + y * stride) + x;
      } else {
#line 671
        c1___0 = (OPJ_UINT8 )0U;
#line 673
        j___0 = 0;
        {
#line 673
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 673
          if (! ((j___0 < c && x < width) && (OPJ_SIZE_T )pix < (OPJ_SIZE_T )beyond)) {
#line 673
            goto while_break___1;
          }
#line 675
          if ((j___0 & 1) == 0) {
            {
#line 677
            c1_int___0 = getc(IN);
            }
#line 678
            if (c1_int___0 == -1) {
#line 679
              return (0);
            }
#line 681
            c1___0 = (OPJ_UINT8 )c1_int___0;
          }
#line 683
          if (j___0 & 1) {
#line 683
            tmp___0 = (unsigned int )c1___0 & 15U;
          } else {
#line 683
            tmp___0 = (unsigned int )((int )c1___0 >> 4) & 15U;
          }
#line 683
          *pix = (OPJ_UINT8 )tmp___0;
#line 684
          written ++;
#line 674
          __cil_tmp34 = pix;
#line 674
          pix ++;
#line 674
          __cil_tmp33 = x;
#line 674
          x ++;
#line 674
          __cil_tmp32 = j___0;
#line 674
          j___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 686
        if ((c & 3) == 1) {
          _L: /* CIL Label */ 
          {
#line 687
          c = getc(IN);
          }
#line 688
          if (c == -1) {
#line 689
            return (0);
          }
        } else
#line 686
        if ((c & 3) == 2) {
#line 686
          goto _L;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 695
  if (written != width * height) {
    {
#line 696
    fprintf(stderr, "warning, image\'s actual size does not match advertized one\n\177EV");
    }
#line 697
    return (0);
  }
#line 699
  return (1);
}
}
#line 702 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  opj_image_cmptparm_t cmptparm[4] ;
  OPJ_UINT8 lut_R[256] ;
  OPJ_UINT8 lut_G[256] ;
  OPJ_UINT8 lut_B[256] ;
  OPJ_UINT8 *pLUT[3] ;
  opj_image_t *image ;
  FILE *IN ;
  OPJ_BITMAPFILEHEADER File_h ;
  OPJ_BITMAPINFOHEADER Info_h ;
  OPJ_UINT32 i ;
  OPJ_UINT32 palette_len ;
  OPJ_UINT32 numcmpts ;
  OPJ_BOOL l_result ;
  OPJ_UINT8 *pData ;
  OPJ_UINT32 stride ;
  FILE *__cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_UINT8 has_color ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  void *__cil_tmp27 ;
  OPJ_BOOL __cil_tmp28 ;
  OPJ_BOOL __cil_tmp29 ;
  OPJ_BOOL __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  int tmp ;
  opj_image_t *__cil_tmp33 ;

  {
  {
#line 707
  image = (opj_image_t *)((void *)0);
#line 711
  numcmpts = 1U;
#line 712
  l_result = 0;
#line 713
  pData = (OPJ_UINT8 *)((void *)0);
#line 716
  pLUT[0] = (OPJ_UINT8 *)lut_R;
#line 717
  pLUT[1] = (OPJ_UINT8 *)lut_G;
#line 718
  pLUT[2] = (OPJ_UINT8 *)lut_B;
#line 720
  IN = fopen(filename, "rb");
  }
#line 721
  if (! IN) {
    {
#line 722
    fprintf(stderr, "Failed to open %s for reading !!\n3|\177EV", filename);
    }
#line 723
    return ((opj_image_t *)((void *)0));
  }
  {
#line 726
  __cil_tmp19 = bmp_read_file_header(IN, & File_h);
  }
#line 726
  if (! __cil_tmp19) {
    {
#line 727
    fclose(IN);
    }
#line 728
    return ((opj_image_t *)((void *)0));
  }
  {
#line 730
  __cil_tmp20 = bmp_read_info_header(IN, & Info_h);
  }
#line 730
  if (! __cil_tmp20) {
    {
#line 731
    fclose(IN);
    }
#line 732
    return ((opj_image_t *)((void *)0));
  }
#line 736
  if ((unsigned int )Info_h.biBitCount <= 8U) {
    {
#line 737
    memset(& lut_R[0], 0, sizeof(lut_R));
#line 738
    memset(& lut_G[0], 0, sizeof(lut_G));
#line 739
    memset(& lut_B[0], 0, sizeof(lut_B));
#line 741
    palette_len = Info_h.biClrUsed;
    }
#line 742
    if (palette_len == 0U) {
#line 742
      if ((unsigned int )Info_h.biBitCount <= 8U) {
#line 743
        palette_len = 1U << (int )Info_h.biBitCount;
      }
    }
#line 745
    if (palette_len > 256U) {
#line 746
      palette_len = 256U;
    }
#line 748
    if (palette_len > 0U) {
#line 749
      has_color = (OPJ_UINT8 )0U;
#line 750
      i = 0U;
      {
#line 750
      while (1) {
        while_continue: /* CIL Label */ ;
#line 750
        if (! (i < palette_len)) {
#line 750
          goto while_break;
        }
        {
#line 751
        __cil_tmp22 = getc(IN);
#line 751
        lut_B[i] = (OPJ_UINT8 )__cil_tmp22;
#line 752
        __cil_tmp23 = getc(IN);
#line 752
        lut_G[i] = (OPJ_UINT8 )__cil_tmp23;
#line 753
        __cil_tmp24 = getc(IN);
#line 753
        lut_R[i] = (OPJ_UINT8 )__cil_tmp24;
#line 754
        getc(IN);
#line 755
        has_color |= ((int )lut_B[i] ^ (int )lut_G[i]) | ((int )lut_G[i] ^ (int )lut_R[i]);
        }
#line 750
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 757
      if (has_color) {
#line 758
        numcmpts = 3U;
      }
    }
  } else {
#line 762
    numcmpts = 3U;
#line 763
    if (Info_h.biCompression == 3U) {
#line 763
      if (Info_h.biAlphaMask != 0U) {
#line 764
        numcmpts ++;
      }
    }
  }
#line 768
  if (Info_h.biWidth == 0U) {
    {
    {
#line 769
    fclose(IN);
    }
    }
#line 770
    return ((opj_image_t *)((void *)0));
  } else
#line 768
  if (Info_h.biHeight == 0U) {
    {
    {
#line 769
    fclose(IN);
    }
    }
#line 770
    return ((opj_image_t *)((void *)0));
  }
#line 773
  if ((unsigned int )Info_h.biBitCount > 4294967264U / Info_h.biWidth) {
    {
#line 774
    fclose(IN);
    }
#line 775
    return ((opj_image_t *)((void *)0));
  }
#line 777
  stride = ((Info_h.biWidth * (unsigned int )Info_h.biBitCount + 31U) / 32U) * 4U;
#line 779
  if ((int )Info_h.biBitCount == 4) {
#line 779
    if (Info_h.biCompression == 2U) {
#line 781
      if (8U > 4294967264U / Info_h.biWidth) {
        {
#line 782
        fclose(IN);
        }
#line 783
        return ((opj_image_t *)((void *)0));
      }
#line 785
      stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
    }
  }
#line 788
  if ((unsigned long )stride > (4294967295UL / sizeof(OPJ_UINT8 )) / (unsigned long )Info_h.biHeight) {
    {
#line 789
    fclose(IN);
    }
#line 790
    return ((opj_image_t *)((void *)0));
  }
  {
#line 792
  __cil_tmp27 = calloc((unsigned long )1, (sizeof(OPJ_UINT8 ) * (unsigned long )stride) * (unsigned long )Info_h.biHeight);
#line 792
  pData = (OPJ_UINT8 *)__cil_tmp27;
  }
#line 793
  if (pData == (void *)0) {
    {
#line 794
    fclose(IN);
    }
#line 795
    return ((opj_image_t *)((void *)0));
  }
  {
#line 798
  fseek(IN, (long )0, 0);
#line 799
  fseek(IN, (long )File_h.bfOffBits, 0);
  }
  {
#line 803
  if (Info_h.biCompression == (OPJ_UINT32 )3) {
#line 803
    goto case_3;
  }
#line 803
  if (Info_h.biCompression == (OPJ_UINT32 )0) {
#line 803
    goto case_3;
  }
#line 808
  if (Info_h.biCompression == (OPJ_UINT32 )1) {
#line 808
    goto case_1;
  }
#line 813
  if (Info_h.biCompression == (OPJ_UINT32 )2) {
#line 813
    goto case_2;
  }
#line 818
  goto switch_default;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 805
  l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 807
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 810
  l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 812
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 815
  l_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);
  }
#line 817
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 819
  fprintf(stderr, "Unsupported BMP compression\n");
  }
#line 820
  l_result = 0;
#line 821
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 823
  if (! l_result) {
    {
#line 824
    free(pData);
#line 825
    fclose(IN);
    }
#line 826
    return ((opj_image_t *)((void *)0));
  }
  {
#line 830
  memset(& cmptparm[0], 0, sizeof(cmptparm));
#line 831
  i = (OPJ_UINT32 )0;
  }
  {
#line 831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 831
    if (! (i < 4U)) {
#line 831
      goto while_break___0;
    }
#line 832
    cmptparm[i].prec = (OPJ_UINT32 )8;
#line 833
    cmptparm[i].sgnd = (OPJ_UINT32 )0;
#line 834
    cmptparm[i].dx = (OPJ_UINT32 )parameters->subsampling_dx;
#line 835
    cmptparm[i].dy = (OPJ_UINT32 )parameters->subsampling_dy;
#line 836
    cmptparm[i].w = Info_h.biWidth;
#line 837
    cmptparm[i].h = Info_h.biHeight;
#line 831
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 840
  if (numcmpts == 1U) {
#line 840
    tmp = 2;
  } else {
#line 840
    tmp = 1;
  }
  {
#line 840
  __cil_tmp33 = opj_image_create(numcmpts, & cmptparm[0], (OPJ_COLOR_SPACE )tmp);
#line 840
  image = __cil_tmp33;
  }
#line 842
  if (! image) {
    {
#line 843
    fclose(IN);
#line 844
    free(pData);
    }
#line 845
    return ((opj_image_t *)((void *)0));
  }
#line 847
  if (numcmpts == 4U) {
#line 848
    (image->comps + 3)->alpha = (OPJ_UINT16 )1;
  }
#line 852
  image->x0 = (OPJ_UINT32 )parameters->image_offset_x0;
#line 853
  image->y0 = (OPJ_UINT32 )parameters->image_offset_y0;
#line 854
  image->x1 = (image->x0 + (Info_h.biWidth - 1U) * (OPJ_UINT32 )parameters->subsampling_dx) + 1U;
#line 856
  image->y1 = (image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32 )parameters->subsampling_dy) + 1U;
#line 860
  if ((int )Info_h.biBitCount == 24) {
#line 860
    if (Info_h.biCompression == 0U) {
      {
#line 861
      bmp24toimage(pData, stride, image);
      }
    } else {
#line 860
      goto _L___88;
    }
  } else
  _L___88: /* CIL Label */ 
#line 862
  if ((int )Info_h.biBitCount == 8) {
#line 862
    if (Info_h.biCompression == 0U) {
      {
#line 864
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)((OPJ_UINT8 **)pLUT));
      }
    } else {
#line 862
      goto _L___87;
    }
  } else
  _L___87: /* CIL Label */ 
#line 865
  if ((int )Info_h.biBitCount == 8) {
#line 865
    if (Info_h.biCompression == 1U) {
      {
#line 866
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)((OPJ_UINT8 **)pLUT));
      }
    } else {
#line 865
      goto _L___86;
    }
  } else
  _L___86: /* CIL Label */ 
#line 867
  if ((int )Info_h.biBitCount == 4) {
#line 867
    if (Info_h.biCompression == 2U) {
      {
#line 868
      bmp8toimage(pData, stride, image, (OPJ_UINT8 * const  *)((OPJ_UINT8 **)pLUT));
      }
    } else {
#line 867
      goto _L___85;
    }
  } else
  _L___85: /* CIL Label */ 
#line 870
  if ((int )Info_h.biBitCount == 32) {
#line 870
    if (Info_h.biCompression == 0U) {
      {
#line 871
      bmpmask32toimage(pData, stride, image, 16711680U, 65280U, 255U, 0U);
      }
    } else {
#line 870
      goto _L___84;
    }
  } else
  _L___84: /* CIL Label */ 
#line 873
  if ((int )Info_h.biBitCount == 32) {
#line 873
    if (Info_h.biCompression == 3U) {
#line 874
      if (Info_h.biRedMask == 0U) {
#line 874
        if (Info_h.biGreenMask == 0U) {
#line 874
          if (Info_h.biBlueMask == 0U) {
#line 876
            Info_h.biRedMask = 16711680U;
#line 877
            Info_h.biGreenMask = 65280U;
#line 878
            Info_h.biBlueMask = 255U;
          }
        }
      }
      {
#line 880
      bmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
#line 873
      goto _L___83;
    }
  } else
  _L___83: /* CIL Label */ 
#line 882
  if ((int )Info_h.biBitCount == 16) {
#line 882
    if (Info_h.biCompression == 0U) {
      {
#line 883
      bmpmask16toimage(pData, stride, image, 31744U, 992U, 31U, 0U);
      }
    } else {
#line 882
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 884
  if ((int )Info_h.biBitCount == 16) {
#line 884
    if (Info_h.biCompression == 3U) {
#line 885
      if (Info_h.biRedMask == 0U) {
#line 885
        if (Info_h.biGreenMask == 0U) {
#line 885
          if (Info_h.biBlueMask == 0U) {
#line 887
            Info_h.biRedMask = 63488U;
#line 888
            Info_h.biGreenMask = 2016U;
#line 889
            Info_h.biBlueMask = 31U;
          }
        }
      }
      {
#line 891
      bmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask,
                       Info_h.biBlueMask, Info_h.biAlphaMask);
      }
    } else {
      {
      {
#line 894
      opj_image_destroy(image);
      }
#line 895
      image = (opj_image_t *)((void *)0);
      {
#line 896
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
  } else {
    {
    {
#line 894
    opj_image_destroy(image);
    }
#line 895
    image = (opj_image_t *)((void *)0);
    {
#line 896
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
    }
  }
  {
#line 900
  free(pData);
#line 901
  fclose(IN);
  }
#line 902
  return (image);
}
}
#line 905 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/jp2/convertbmp.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  OPJ_UINT8 rc ;
  OPJ_UINT8 gc ;
  OPJ_UINT8 bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 909
  fdest = (FILE *)((void *)0);
#line 912
  if ((image->comps + 0)->prec < 8U) {
    {
#line 913
    fprintf(stderr, "imagetobmp: Unsupported precision: %d\n", (image->comps + 0)->prec);
    }
#line 915
    return (1);
  }
#line 917
  if (image->numcomps >= 3U) {
#line 917
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 917
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 917
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 917
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 917
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 917
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 917
                if ((image->comps + 0)->sgnd == (image->comps + 1)->sgnd) {
#line 917
                  if ((image->comps + 1)->sgnd == (image->comps + 2)->sgnd) {
                    {
#line 930
                    fdest = fopen(outfile, "wb");
                    }
#line 931
                    if (! fdest) {
                      {
#line 932
                      fprintf(stderr, "ERROR -> failed to open %s for writing\n",
                              outfile);
                      }
#line 933
                      return (1);
                    }
                    {
#line 936
                    w = (int )(image->comps + 0)->w;
#line 937
                    h = (int )(image->comps + 0)->h;
#line 939
                    fprintf(fdest, "BM~\177EV");
#line 943
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                            (int )((OPJ_UINT8 )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 948
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 950
                    fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                            (54 >> 24) & 255);
#line 955
                    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                            (40 >> 24) & 255);
#line 957
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w & 255)),
                            (int )((OPJ_UINT8 )(w >> 8)) & 255, (int )((OPJ_UINT8 )(w >> 16)) & 255,
                            (int )((OPJ_UINT8 )(w >> 24)) & 255);
#line 961
                    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h & 255)),
                            (int )((OPJ_UINT8 )(h >> 8)) & 255, (int )((OPJ_UINT8 )(h >> 16)) & 255,
                            (int )((OPJ_UINT8 )(h >> 24)) & 255);
#line 965
                    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 966
                    fprintf(fdest, "%c%cEV", 24, (24 >> 8) & 255);
#line 967
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 969
                    fprintf(fdest, "%c%c%c%c\251", (int )((OPJ_UINT8 )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                            (int )((OPJ_UINT8 )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 973
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 975
                    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                            (7834 >> 24) & 255);
#line 977
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 979
                    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                    }
#line 982
                    if ((image->comps + 0)->prec > 8U) {
                      {
#line 983
                      adjustR = (int )(image->comps + 0)->prec - 8;
#line 984
                      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                             (image->comps + 0)->prec);
                      }
                    } else {
#line 987
                      adjustR = 0;
                    }
#line 989
                    if ((image->comps + 1)->prec > 8U) {
                      {
#line 990
                      adjustG = (int )(image->comps + 1)->prec - 8;
#line 991
                      printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                             (image->comps + 1)->prec);
                      }
                    } else {
#line 994
                      adjustG = 0;
                    }
#line 996
                    if ((image->comps + 2)->prec > 8U) {
                      {
#line 997
                      adjustB = (int )(image->comps + 2)->prec - 8;
#line 998
                      printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                             (image->comps + 2)->prec);
                      }
                    } else {
#line 1001
                      adjustB = 0;
                    }
#line 1004
                    i = 0;
                    {
#line 1004
                    while (1) {
                      while_continue: /* CIL Label */ ;
#line 1004
                      if (! (i < w * h)) {
#line 1004
                        goto while_break;
                      }
#line 1008
                      r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1009
                      if ((image->comps + 0)->sgnd) {
#line 1009
                        tmp = 1 << ((image->comps + 0)->prec - 1U);
                      } else {
#line 1009
                        tmp = 0;
                      }
#line 1009
                      r += tmp;
#line 1010
                      if (adjustR > 0) {
#line 1011
                        r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
                      }
#line 1013
                      if (r > 255) {
#line 1014
                        r = 255;
                      } else
#line 1015
                      if (r < 0) {
#line 1016
                        r = 0;
                      }
#line 1018
                      rc = (OPJ_UINT8 )r;
#line 1020
                      g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1021
                      if ((image->comps + 1)->sgnd) {
#line 1021
                        tmp___0 = 1 << ((image->comps + 1)->prec - 1U);
                      } else {
#line 1021
                        tmp___0 = 0;
                      }
#line 1021
                      g += tmp___0;
#line 1022
                      if (adjustG > 0) {
#line 1023
                        g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
                      }
#line 1025
                      if (g > 255) {
#line 1026
                        g = 255;
                      } else
#line 1027
                      if (g < 0) {
#line 1028
                        g = 0;
                      }
#line 1030
                      gc = (OPJ_UINT8 )g;
#line 1032
                      b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1033
                      if ((image->comps + 2)->sgnd) {
#line 1033
                        tmp___1 = 1 << ((image->comps + 2)->prec - 1U);
                      } else {
#line 1033
                        tmp___1 = 0;
                      }
#line 1033
                      b += tmp___1;
#line 1034
                      if (adjustB > 0) {
#line 1035
                        b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
                      }
#line 1037
                      if (b > 255) {
#line 1038
                        b = 255;
                      } else
#line 1039
                      if (b < 0) {
#line 1040
                        b = 0;
                      }
                      {
#line 1042
                      bc = (OPJ_UINT8 )b;
#line 1044
                      fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                      }
#line 1046
                      if ((i + 1) % w == 0) {
#line 1047
                        if ((3 * w) % 4) {
#line 1047
                          tmp___2 = 4 - (3 * w) % 4;
                        } else {
#line 1047
                          tmp___2 = 0;
                        }
#line 1047
                        pad = tmp___2;
                        {
#line 1047
                        while (1) {
                          while_continue___0: /* CIL Label */ ;
#line 1047
                          if (! (pad > 0)) {
#line 1047
                            goto while_break___0;
                          }
                          {
#line 1048
                          fprintf(fdest, "%c\377\377", 0);
                          }
#line 1047
                          __cil_tmp22 = pad;
#line 1047
                          pad --;
                        }
                        while_break___0: /* CIL Label */ ;
                        }
                      }
#line 1004
                      i ++;
                    }
                    while_break: /* CIL Label */ ;
                    }
                    {
#line 1052
                    fclose(fdest);
                    }
                  } else {
#line 917
                    goto _L;
                  }
                } else {
#line 917
                  goto _L;
                }
              } else {
#line 917
                goto _L;
              }
            } else {
#line 917
              goto _L;
            }
          } else {
#line 917
            goto _L;
          }
        } else {
#line 917
          goto _L;
        }
      } else {
#line 917
        goto _L;
      }
    } else {
#line 917
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___89: /* CIL Label */ 
    _L___90: /* CIL Label */ 
    _L___91: /* CIL Label */ 
    _L___92: /* CIL Label */ 
    _L___93: /* CIL Label */ 
    _L___94: /* CIL Label */ 
    _L___95: /* CIL Label */ 
    {
#line 1059
    fdest = fopen(outfile, "wb~\177EV");
    }
#line 1060
    if (! fdest) {
      {
#line 1061
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1062
      return (1);
    }
#line 1064
    if (image->numcomps > 1U) {
      {
#line 1065
      fprintf(stderr, "imagetobmp: only first component of %d is used.\n\230\001",
              image->numcomps);
      }
    }
    {
#line 1068
    w = (int )(image->comps + 0)->w;
#line 1069
    h = (int )(image->comps + 0)->h;
#line 1071
    fprintf(fdest, "BM");
#line 1075
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1079
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1081
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1087
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1089
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(w & 255)), (int )((OPJ_UINT8 )(w >> 8)) & 255,
            (int )((OPJ_UINT8 )(w >> 16)) & 255, (int )((OPJ_UINT8 )(w >> 24)) & 255);
#line 1093
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h & 255)), (int )((OPJ_UINT8 )(h >> 8)) & 255,
            (int )((OPJ_UINT8 )(h >> 16)) & 255, (int )((OPJ_UINT8 )(h >> 24)) & 255);
#line 1097
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1098
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 1099
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1101
    fprintf(fdest, "%c%c%c%c\230\001", (int )((OPJ_UINT8 )(h * w + h * (w % 2))) & 255,
            (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 8)) & 255, (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((OPJ_UINT8 )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1105
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1107
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1109
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1111
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1114
    if ((image->comps + 0)->prec > 8U) {
      {
#line 1115
      adjustR = (int )(image->comps + 0)->prec - 8;
#line 1116
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1119
      adjustR = 0;
    }
#line 1122
    i = 0;
    {
#line 1122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1122
      if (! (i < 256)) {
#line 1122
        goto while_break___1;
      }
      {
#line 1123
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 1122
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1126
    i = 0;
    {
#line 1126
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1126
      if (! (i < w * h)) {
#line 1126
        goto while_break___2;
      }
#line 1129
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1130
      if ((image->comps + 0)->sgnd) {
#line 1130
        tmp___3 = 1 << ((image->comps + 0)->prec - 1U);
      } else {
#line 1130
        tmp___3 = 0;
      }
#line 1130
      r___0 += tmp___3;
#line 1131
      if (adjustR > 0) {
#line 1132
        r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
      }
#line 1134
      if (r___0 > 255) {
#line 1135
        r___0 = 255;
      } else
#line 1136
      if (r___0 < 0) {
#line 1137
        r___0 = 0;
      }
      {
#line 1140
      fprintf(fdest, "%c", (int )((OPJ_UINT8 )r___0));
      }
#line 1142
      if ((i + 1) % w == 0) {
#line 1143
        if (w % 4) {
#line 1143
          tmp___4 = 4 - w % 4;
        } else {
#line 1143
          tmp___4 = 0;
        }
#line 1143
        pad = tmp___4;
        {
#line 1143
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1143
          if (! (pad > 0)) {
#line 1143
            goto while_break___3;
          }
          {
#line 1144
          fprintf(fdest, "%c", 0);
          }
#line 1143
          __cil_tmp29 = pad;
#line 1143
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1126
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1148
    fclose(fdest);
    }
  }
#line 1151
  return (0);
}
}
#line 41 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 42
extern void color_apply_icc_profile(opj_image_t *image ) ;
#line 43
extern void color_cielab_to_rgb(opj_image_t *image ) ;
#line 45
void color_cmyk_to_rgb(opj_image_t *image ) ;
#line 46
void color_esycc_to_rgb(opj_image_t *image ) ;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 79
  cb -= offset;
#line 80
  cr -= offset;
#line 81
  r = y + (int )(1.402 * (double )((float )cr));
#line 82
  if (r < 0) {
#line 83
    r = 0;
  } else
#line 84
  if (r > upb) {
#line 85
    r = upb;
  }
#line 87
  *out_r = r;
#line 89
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 90
  if (g < 0) {
#line 91
    g = 0;
  } else
#line 92
  if (g > upb) {
#line 93
    g = upb;
  }
#line 95
  *out_g = g;
#line 97
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 98
  if (b < 0) {
#line 99
    b = 0;
  } else
#line 100
  if (b > upb) {
#line 101
    b = upb;
  }
#line 103
  *out_b = b;
  return;
}
}
#line 106 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  size_t maxw ;
  size_t maxh ;
  size_t max ;
  size_t i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 113
  upb = (int )(img->comps + 0)->prec;
#line 114
  offset = 1 << (upb - 1);
#line 115
  upb = (1 << upb) - 1;
#line 117
  maxw = (size_t )(img->comps + 0)->w;
#line 118
  maxh = (size_t )(img->comps + 0)->h;
#line 119
  max = maxw * maxh;
#line 121
  y = (int const   *)(img->comps + 0)->data;
#line 122
  cb = (int const   *)(img->comps + 1)->data;
#line 123
  cr = (int const   *)(img->comps + 2)->data;
#line 125
  __cil_tmp17 = opj_image_data_alloc(sizeof(int ) * max);
#line 125
  r = (int *)__cil_tmp17;
#line 125
  d0 = r;
#line 126
  __cil_tmp18 = opj_image_data_alloc(sizeof(int ) * max);
#line 126
  g = (int *)__cil_tmp18;
#line 126
  d1 = g;
#line 127
  __cil_tmp19 = opj_image_data_alloc(sizeof(int ) * max);
#line 127
  b = (int *)__cil_tmp19;
#line 127
  d2 = b;
  }
#line 129
  if (r == (void *)0) {
#line 130
    goto fails;
  } else
#line 129
  if (g == (void *)0) {
#line 130
    goto fails;
  } else
#line 129
  if (b == (void *)0) {
#line 130
    goto fails;
  }
#line 133
  i = (size_t )0U;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < max)) {
#line 133
      goto while_break;
    }
    {
#line 134
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 135
    y ++;
#line 136
    cb ++;
#line 137
    cr ++;
#line 138
    r ++;
#line 139
    g ++;
#line 140
    b ++;
    }
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  opj_image_data_free((img->comps + 0)->data);
#line 143
  (img->comps + 0)->data = d0;
#line 144
  opj_image_data_free((img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  opj_image_data_free((img->comps + 2)->data);
#line 147
  (img->comps + 2)->data = d2;
#line 148
  img->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 149
  return;
  fails: 
  {
#line 152
  opj_image_data_free(r);
  }
  {
#line 153
  opj_image_data_free(g);
#line 154
  opj_image_data_free(b);
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  size_t maxw ;
  size_t maxh ;
  size_t max ;
  size_t offx ;
  size_t loopmaxw ;
  int offset ;
  int upb ;
  size_t i ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  size_t j ;

  {
  {
#line 165
  upb = (int )(img->comps + 0)->prec;
#line 166
  offset = 1 << (upb - 1);
#line 167
  upb = (1 << upb) - 1;
#line 169
  maxw = (size_t )(img->comps + 0)->w;
#line 170
  maxh = (size_t )(img->comps + 0)->h;
#line 171
  max = maxw * maxh;
#line 173
  y = (int const   *)(img->comps + 0)->data;
#line 174
  cb = (int const   *)(img->comps + 1)->data;
#line 175
  cr = (int const   *)(img->comps + 2)->data;
#line 177
  __cil_tmp19 = opj_image_data_alloc(sizeof(int ) * max);
#line 177
  r = (int *)__cil_tmp19;
#line 177
  d0 = r;
#line 178
  __cil_tmp20 = opj_image_data_alloc(sizeof(int ) * max);
#line 178
  g = (int *)__cil_tmp20;
#line 178
  d1 = g;
#line 179
  __cil_tmp21 = opj_image_data_alloc(sizeof(int ) * max);
#line 179
  b = (int *)__cil_tmp21;
#line 179
  d2 = b;
  }
#line 181
  if (r == (void *)0) {
#line 182
    goto fails;
  } else
#line 181
  if (g == (void *)0) {
#line 182
    goto fails;
  } else
#line 181
  if (b == (void *)0) {
#line 182
    goto fails;
  }
#line 186
  offx = (size_t )(img->x0 & 1U);
#line 187
  loopmaxw = maxw - offx;
#line 189
  i = (size_t )0U;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < maxh)) {
#line 189
      goto while_break;
    }
#line 192
    if (offx > 0UL) {
      {
#line 193
      sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
#line 194
      y ++;
#line 195
      r ++;
#line 196
      g ++;
#line 197
      b ++;
      }
    }
#line 200
    j = (size_t )0U;
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! (j < (loopmaxw & 0xfffffffffffffffeUL))) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 202
      y ++;
#line 203
      r ++;
#line 204
      g ++;
#line 205
      b ++;
#line 206
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 207
      y ++;
#line 208
      r ++;
#line 209
      g ++;
#line 210
      b ++;
#line 211
      cb ++;
#line 212
      cr ++;
      }
#line 200
      j += (unsigned long )2U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    if (j < loopmaxw) {
      {
#line 215
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 216
      y ++;
#line 217
      r ++;
#line 218
      g ++;
#line 219
      b ++;
#line 220
      cb ++;
#line 221
      cr ++;
      }
    }
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  opj_image_data_free((img->comps + 0)->data);
#line 226
  (img->comps + 0)->data = d0;
#line 227
  opj_image_data_free((img->comps + 1)->data);
#line 228
  (img->comps + 1)->data = d1;
#line 229
  opj_image_data_free((img->comps + 2)->data);
#line 230
  (img->comps + 2)->data = d2;
#line 232
  (img->comps + 2)->w = (img->comps + 0)->w;
#line 232
  (img->comps + 1)->w = (img->comps + 2)->w;
#line 233
  (img->comps + 2)->h = (img->comps + 0)->h;
#line 233
  (img->comps + 1)->h = (img->comps + 2)->h;
#line 234
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 234
  (img->comps + 1)->dx = (img->comps + 2)->dx;
#line 235
  (img->comps + 2)->dy = (img->comps + 0)->dy;
#line 235
  (img->comps + 1)->dy = (img->comps + 2)->dy;
#line 236
  img->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 237
  return;
  fails: 
  {
#line 240
  opj_image_data_free(r);
  }
  {
#line 241
  opj_image_data_free(g);
#line 242
  opj_image_data_free(b);
  }
  return;
}
}
#line 245 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  size_t maxw ;
  size_t maxh ;
  size_t max ;
  size_t offx ;
  size_t loopmaxw ;
  size_t offy ;
  size_t loopmaxh ;
  int offset ;
  int upb ;
  size_t i ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  size_t j ;
  size_t j___0 ;
  size_t j___1 ;

  {
  {
#line 253
  upb = (int )(img->comps + 0)->prec;
#line 254
  offset = 1 << (upb - 1);
#line 255
  upb = (1 << upb) - 1;
#line 257
  maxw = (size_t )(img->comps + 0)->w;
#line 258
  maxh = (size_t )(img->comps + 0)->h;
#line 259
  max = maxw * maxh;
#line 261
  y = (int const   *)(img->comps + 0)->data;
#line 262
  cb = (int const   *)(img->comps + 1)->data;
#line 263
  cr = (int const   *)(img->comps + 2)->data;
#line 265
  __cil_tmp25 = opj_image_data_alloc(sizeof(int ) * max);
#line 265
  r = (int *)__cil_tmp25;
#line 265
  d0 = r;
#line 266
  __cil_tmp26 = opj_image_data_alloc(sizeof(int ) * max);
#line 266
  g = (int *)__cil_tmp26;
#line 266
  d1 = g;
#line 267
  __cil_tmp27 = opj_image_data_alloc(sizeof(int ) * max);
#line 267
  b = (int *)__cil_tmp27;
#line 267
  d2 = b;
  }
#line 269
  if (r == (void *)0) {
#line 270
    goto fails;
  } else
#line 269
  if (g == (void *)0) {
#line 270
    goto fails;
  } else
#line 269
  if (b == (void *)0) {
#line 270
    goto fails;
  }
#line 274
  offx = (size_t )(img->x0 & 1U);
#line 275
  loopmaxw = maxw - offx;
#line 277
  offy = (size_t )(img->y0 & 1U);
#line 278
  loopmaxh = maxh - offy;
#line 280
  if (offy > 0UL) {
#line 283
    j = (size_t )0;
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;
#line 283
      if (! (j < maxw)) {
#line 283
        goto while_break;
      }
      {
#line 284
      sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
#line 285
      y ++;
#line 286
      r ++;
#line 287
      g ++;
#line 288
      b ++;
      }
#line 283
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 292
  i = (size_t )0U;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! (i < (loopmaxh & 0xfffffffffffffffeUL))) {
#line 292
      goto while_break___0;
    }
#line 295
    ny = y + maxw;
#line 296
    nr = r + maxw;
#line 297
    ng = g + maxw;
#line 298
    nb = b + maxw;
#line 300
    if (offx > 0UL) {
      {
#line 301
      sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
#line 302
      y ++;
#line 303
      r ++;
#line 304
      g ++;
#line 305
      b ++;
#line 306
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 307
      ny ++;
#line 308
      nr ++;
#line 309
      ng ++;
#line 310
      nb ++;
      }
    }
#line 313
    j___0 = (size_t )0;
    {
#line 313
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 313
      if (! (j___0 < (loopmaxw & 0xfffffffffffffffeUL))) {
#line 313
        goto while_break___1;
      }
      {
#line 314
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 315
      y ++;
#line 316
      r ++;
#line 317
      g ++;
#line 318
      b ++;
#line 319
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 320
      y ++;
#line 321
      r ++;
#line 322
      g ++;
#line 323
      b ++;
#line 325
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 326
      ny ++;
#line 327
      nr ++;
#line 328
      ng ++;
#line 329
      nb ++;
#line 330
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 331
      ny ++;
#line 332
      nr ++;
#line 333
      ng ++;
#line 334
      nb ++;
#line 335
      cb ++;
#line 336
      cr ++;
      }
#line 313
      j___0 += (unsigned long )2U;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    if (j___0 < loopmaxw) {
      {
#line 339
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 340
      y ++;
#line 341
      r ++;
#line 342
      g ++;
#line 343
      b ++;
#line 345
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 346
      ny ++;
#line 347
      nr ++;
#line 348
      ng ++;
#line 349
      nb ++;
#line 350
      cb ++;
#line 351
      cr ++;
      }
    }
#line 353
    y += maxw;
#line 354
    r += maxw;
#line 355
    g += maxw;
#line 356
    b += maxw;
#line 292
    i += (unsigned long )2U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  if (i < loopmaxh) {
#line 361
    j___1 = (size_t )0U;
    {
#line 361
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 361
      if (! (j___1 < (maxw & 0xfffffffffffffffeUL))) {
#line 361
        goto while_break___2;
      }
      {
#line 362
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 364
      y ++;
#line 365
      r ++;
#line 366
      g ++;
#line 367
      b ++;
#line 369
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 371
      y ++;
#line 372
      r ++;
#line 373
      g ++;
#line 374
      b ++;
#line 375
      cb ++;
#line 376
      cr ++;
      }
#line 361
      j___1 += (unsigned long )2U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 378
    if (j___1 < maxw) {
      {
#line 379
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
      }
    }
  }
  {
#line 383
  opj_image_data_free((img->comps + 0)->data);
#line 384
  (img->comps + 0)->data = d0;
#line 385
  opj_image_data_free((img->comps + 1)->data);
#line 386
  (img->comps + 1)->data = d1;
#line 387
  opj_image_data_free((img->comps + 2)->data);
#line 388
  (img->comps + 2)->data = d2;
#line 390
  (img->comps + 2)->w = (img->comps + 0)->w;
#line 390
  (img->comps + 1)->w = (img->comps + 2)->w;
#line 391
  (img->comps + 2)->h = (img->comps + 0)->h;
#line 391
  (img->comps + 1)->h = (img->comps + 2)->h;
#line 392
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 392
  (img->comps + 1)->dx = (img->comps + 2)->dx;
#line 393
  (img->comps + 2)->dy = (img->comps + 0)->dy;
#line 393
  (img->comps + 1)->dy = (img->comps + 2)->dy;
#line 394
  img->color_space = (OPJ_COLOR_SPACE )1;
  }
#line 395
  return;
  fails: 
  {
#line 398
  opj_image_data_free(r);
  }
  {
#line 399
  opj_image_data_free(g);
#line 400
  opj_image_data_free(b);
  }
  return;
}
}
#line 403 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 405
  if (img->numcomps < 3U) {
#line 406
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 407
    return;
  }
#line 410
  if ((img->comps + 0)->dx == 1U) {
#line 410
    if ((img->comps + 1)->dx == 2U) {
#line 410
      if ((img->comps + 2)->dx == 2U) {
#line 410
        if ((img->comps + 0)->dy == 1U) {
#line 410
          if ((img->comps + 1)->dy == 2U) {
#line 410
            if ((img->comps + 2)->dy == 2U) {
              {
#line 416
              sycc420_to_rgb(img);
              }
            } else {
#line 410
              goto _L___100;
            }
          } else {
#line 410
            goto _L___100;
          }
        } else {
#line 410
          goto _L___100;
        }
      } else {
#line 410
        goto _L___100;
      }
    } else {
#line 410
      goto _L___100;
    }
  } else
  _L___100: /* CIL Label */ 
  _L___101: /* CIL Label */ 
  _L___102: /* CIL Label */ 
  _L___103: /* CIL Label */ 
  _L___104: /* CIL Label */ 
#line 417
  if ((img->comps + 0)->dx == 1U) {
#line 417
    if ((img->comps + 1)->dx == 2U) {
#line 417
      if ((img->comps + 2)->dx == 2U) {
#line 417
        if ((img->comps + 0)->dy == 1U) {
#line 417
          if ((img->comps + 1)->dy == 1U) {
#line 417
            if ((img->comps + 2)->dy == 1U) {
              {
#line 423
              sycc422_to_rgb(img);
              }
            } else {
#line 417
              goto _L;
            }
          } else {
#line 417
            goto _L;
          }
        } else {
#line 417
          goto _L;
        }
      } else {
#line 417
        goto _L;
      }
    } else {
#line 417
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___96: /* CIL Label */ 
  _L___97: /* CIL Label */ 
  _L___98: /* CIL Label */ 
  _L___99: /* CIL Label */ 
#line 424
  if ((img->comps + 0)->dx == 1U) {
#line 424
    if ((img->comps + 1)->dx == 1U) {
#line 424
      if ((img->comps + 2)->dx == 1U) {
#line 424
        if ((img->comps + 0)->dy == 1U) {
#line 424
          if ((img->comps + 1)->dy == 1U) {
#line 424
            if ((img->comps + 2)->dy == 1U) {
              {
#line 430
              sycc444_to_rgb(img);
              }
            } else {
              {
              {
              {
              {
              {
              {
#line 432
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
                      433);
              }
              }
              }
              }
              }
              }
#line 434
              return;
            }
          } else {
            {
            {
            {
            {
            {
            {
#line 432
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
                    433);
            }
            }
            }
            }
            }
            }
#line 434
            return;
          }
        } else {
          {
          {
          {
          {
          {
          {
#line 432
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
                  433);
          }
          }
          }
          }
          }
          }
#line 434
          return;
        }
      } else {
        {
        {
        {
        {
        {
        {
#line 432
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
                433);
        }
        }
        }
        }
        }
        }
#line 434
        return;
      }
    } else {
      {
      {
      {
      {
      {
      {
#line 432
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
              433);
      }
      }
      }
      }
      }
      }
#line 434
      return;
    }
  } else {
    {
    {
    {
    {
    {
    {
#line 432
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            433);
    }
    }
    }
    }
    }
    }
#line 434
    return;
  }
  return;
}
}
#line 1004 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
void color_cmyk_to_rgb(opj_image_t *image ) 
{ 
  float C ;
  float M ;
  float Y ;
  float K ;
  float sC ;
  float sM ;
  float sY ;
  float sK ;
  unsigned int w ;
  unsigned int h ;
  unsigned int max ;
  unsigned int i ;

  {
#line 1010
  w = (image->comps + 0)->w;
#line 1011
  h = (image->comps + 0)->h;
#line 1013
  if (image->numcomps < 4U) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dx != (image->comps + 3)->dx) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  } else
#line 1013
  if ((image->comps + 0)->dy != (image->comps + 3)->dy) {
    {
    {
    {
    {
    {
    {
    {
#line 1022
    fprintf(stderr, "%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1023);
    }
    }
    }
    }
    }
    }
    }
#line 1024
    return;
  }
#line 1027
  max = w * h;
#line 1029
  sC = 1.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 1030
  sM = 1.f / (float )((1 << (image->comps + 1)->prec) - 1);
#line 1031
  sY = 1.f / (float )((1 << (image->comps + 2)->prec) - 1);
#line 1032
  sK = 1.f / (float )((1 << (image->comps + 3)->prec) - 1);
#line 1034
  i = (unsigned int )0;
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1034
    if (! (i < max)) {
#line 1034
      goto while_break;
    }
#line 1036
    C = (float )*((image->comps + 0)->data + i) * sC;
#line 1037
    M = (float )*((image->comps + 1)->data + i) * sM;
#line 1038
    Y = (float )*((image->comps + 2)->data + i) * sY;
#line 1039
    K = (float )*((image->comps + 3)->data + i) * sK;
#line 1042
    C = 1.f - C;
#line 1043
    M = 1.f - M;
#line 1044
    Y = 1.f - Y;
#line 1045
    K = 1.f - K;
#line 1048
    *((image->comps + 0)->data + i) = (int )((255.f * C) * K);
#line 1049
    *((image->comps + 1)->data + i) = (int )((255.f * M) * K);
#line 1050
    *((image->comps + 2)->data + i) = (int )((255.f * Y) * K);
#line 1034
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1053
  opj_image_data_free((image->comps + 3)->data);
#line 1054
  (image->comps + 3)->data = (OPJ_INT32 *)((void *)0);
#line 1055
  (image->comps + 0)->prec = (OPJ_UINT32 )8;
#line 1056
  (image->comps + 1)->prec = (OPJ_UINT32 )8;
#line 1057
  (image->comps + 2)->prec = (OPJ_UINT32 )8;
#line 1058
  image->numcomps -= (unsigned int )1;
#line 1059
  image->color_space = (OPJ_COLOR_SPACE )1;
#line 1061
  i = (unsigned int )3;
  }
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1061
    if (! (i < image->numcomps)) {
#line 1061
      goto while_break___0;
    }
    {
#line 1062
    memcpy(image->comps + i, image->comps + (i + 1U), sizeof(*(image->comps + i)));
    }
#line 1061
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 1070 "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c"
void color_esycc_to_rgb(opj_image_t *image ) 
{ 
  int y ;
  int cb ;
  int cr ;
  int sign1 ;
  int sign2 ;
  int val ;
  unsigned int w ;
  unsigned int h ;
  unsigned int max ;
  unsigned int i ;
  int flip_value ;
  int max_value ;

  {
#line 1074
  flip_value = 1 << ((image->comps + 0)->prec - 1U);
#line 1075
  max_value = (1 << (image->comps + 0)->prec) - 1;
#line 1077
  if (image->numcomps < 3U) {
    {
    {
    {
    {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1085);
    }
    }
    }
    }
    }
#line 1086
    return;
  } else
#line 1077
  if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
    {
    {
    {
    {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1085);
    }
    }
    }
    }
    }
#line 1086
    return;
  } else
#line 1077
  if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
    {
    {
    {
    {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1085);
    }
    }
    }
    }
    }
#line 1086
    return;
  } else
#line 1077
  if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
    {
    {
    {
    {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1085);
    }
    }
    }
    }
    }
#line 1086
    return;
  } else
#line 1077
  if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
    {
    {
    {
    {
    {
#line 1084
    fprintf(stderr, "%s:%d:color_esycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c0cb119c/src/bin/common/color.c\251",
            1085);
    }
    }
    }
    }
    }
#line 1086
    return;
  }
#line 1089
  w = (image->comps + 0)->w;
#line 1090
  h = (image->comps + 0)->h;
#line 1092
  sign1 = (int )(image->comps + 1)->sgnd;
#line 1093
  sign2 = (int )(image->comps + 2)->sgnd;
#line 1095
  max = w * h;
#line 1097
  i = (unsigned int )0;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    if (! (i < max)) {
#line 1097
      goto while_break;
    }
#line 1099
    y = *((image->comps + 0)->data + i);
#line 1100
    cb = *((image->comps + 1)->data + i);
#line 1101
    cr = *((image->comps + 2)->data + i);
#line 1103
    if (! sign1) {
#line 1104
      cb -= flip_value;
    }
#line 1106
    if (! sign2) {
#line 1107
      cr -= flip_value;
    }
#line 1110
    val = (int )((((float )y - (float )3.68000000001e-05 * (float )cb) + (float )1.40199000001 * (float )cr) + (float )0.5);
#line 1114
    if (val > max_value) {
#line 1115
      val = max_value;
    } else
#line 1116
    if (val < 0) {
#line 1117
      val = 0;
    }
#line 1119
    *((image->comps + 0)->data + i) = val;
#line 1121
    val = (int )((((float )1.0003 * (float )y - (float )0.344125000001 * (float )cb) - (float )0.7141128 * (float )cr) + (float )0.5);
#line 1125
    if (val > max_value) {
#line 1126
      val = max_value;
    } else
#line 1127
    if (val < 0) {
#line 1128
      val = 0;
    }
#line 1130
    *((image->comps + 1)->data + i) = val;
#line 1132
    val = (int )((((float )0.999823000001 * (float )y + (float )1.77204000001 * (float )cb) - (float )8e-06 * (float )cr) + (float )0.5);
#line 1136
    if (val > max_value) {
#line 1137
      val = max_value;
    } else
#line 1138
    if (val < 0) {
#line 1139
      val = 0;
    }
#line 1141
    *((image->comps + 2)->data + i) = val;
#line 1097
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1143
  image->color_space = (OPJ_COLOR_SPACE )1;
  return;
}
}
#line 47 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 50
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_UINT32 )) - p_nb_bytes;
#line 55
  memcpy(p_buffer, l_data_ptr, (unsigned long )p_nb_bytes);
  }
  return;
}
}
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_BYTE *__cil_tmp7 ;

  {
#line 61
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + p_nb_bytes) - 1;
#line 66
  i = (OPJ_UINT32 )0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < p_nb_bytes)) {
#line 66
      goto while_break;
    }
#line 67
    __cil_tmp7 = l_data_ptr;
#line 67
    l_data_ptr --;
#line 67
    __cil_tmp6 = p_buffer;
#line 67
    p_buffer ++;
#line 67
    *__cil_tmp6 = *__cil_tmp7;
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 71 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 74
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 78
  *p_value = (OPJ_UINT32 )0;
#line 79
  memcpy((l_data_ptr + sizeof(OPJ_UINT32 )) - p_nb_bytes, p_buffer, (unsigned long )p_nb_bytes);
  }
  return;
}
}
#line 82 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp6 ;
  OPJ_BYTE *__cil_tmp7 ;

  {
#line 85
  l_data_ptr = ((OPJ_BYTE *)p_value + p_nb_bytes) - 1;
#line 90
  *p_value = (OPJ_UINT32 )0;
#line 91
  i = (OPJ_UINT32 )0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < p_nb_bytes)) {
#line 91
      goto while_break;
    }
#line 92
    __cil_tmp7 = p_buffer;
#line 92
    p_buffer ++;
#line 92
    __cil_tmp6 = l_data_ptr;
#line 92
    l_data_ptr --;
#line 92
    *__cil_tmp6 = *__cil_tmp7;
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 96 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 98
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 99
  memcpy(p_buffer, l_data_ptr, sizeof(OPJ_FLOAT64 ));
  }
  return;
}
}
#line 102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 104
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT64 )) - 1;
#line 107
  i = (OPJ_UINT32 )0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 107
      goto while_break;
    }
#line 108
    __cil_tmp6 = l_data_ptr;
#line 108
    l_data_ptr --;
#line 108
    __cil_tmp5 = p_buffer;
#line 108
    p_buffer ++;
#line 108
    *__cil_tmp5 = *__cil_tmp6;
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 114
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 115
  memcpy(l_data_ptr, p_buffer, sizeof(OPJ_FLOAT64 ));
  }
  return;
}
}
#line 118 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 120
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT64 )) - 1;
#line 122
  i = (OPJ_UINT32 )0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT64 ))) {
#line 122
      goto while_break;
    }
#line 123
    __cil_tmp6 = p_buffer;
#line 123
    p_buffer ++;
#line 123
    __cil_tmp5 = l_data_ptr;
#line 123
    l_data_ptr --;
#line 123
    *__cil_tmp5 = *__cil_tmp6;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 129
  l_data_ptr = (OPJ_BYTE *)(& p_value);
#line 130
  memcpy(p_buffer, l_data_ptr, sizeof(OPJ_FLOAT32 ));
  }
  return;
}
}
#line 133 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 135
  l_data_ptr = ((OPJ_BYTE *)(& p_value) + sizeof(OPJ_FLOAT32 )) - 1;
#line 138
  i = (OPJ_UINT32 )0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 138
      goto while_break;
    }
#line 139
    __cil_tmp6 = l_data_ptr;
#line 139
    l_data_ptr --;
#line 139
    __cil_tmp5 = p_buffer;
#line 139
    p_buffer ++;
#line 139
    *__cil_tmp5 = *__cil_tmp6;
#line 138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 143 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;

  {
  {
#line 145
  l_data_ptr = (OPJ_BYTE *)p_value;
#line 146
  memcpy(l_data_ptr, p_buffer, sizeof(OPJ_FLOAT32 ));
  }
  return;
}
}
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) 
{ 
  OPJ_BYTE *l_data_ptr ;
  OPJ_UINT32 i ;
  OPJ_BYTE *__cil_tmp5 ;
  OPJ_BYTE *__cil_tmp6 ;

  {
#line 151
  l_data_ptr = ((OPJ_BYTE *)p_value + sizeof(OPJ_FLOAT32 )) - 1;
#line 153
  i = (OPJ_UINT32 )0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned long )i < sizeof(OPJ_FLOAT32 ))) {
#line 153
      goto while_break;
    }
#line 154
    __cil_tmp6 = p_buffer;
#line 154
    p_buffer ++;
#line 154
    __cil_tmp5 = l_data_ptr;
#line 154
    l_data_ptr --;
#line 154
    *__cil_tmp5 = *__cil_tmp6;
#line 153
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 158 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL l_is_input ) 
{ 
  opj_stream_private_t *l_stream ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 161
  l_stream = (opj_stream_private_t *)0;
#line 162
  __cil_tmp4 = opj_calloc((size_t )1, sizeof(opj_stream_private_t ));
#line 162
  l_stream = (opj_stream_private_t *)__cil_tmp4;
  }
#line 163
  if (! l_stream) {
#line 164
    return ((opj_stream_t *)0);
  }
  {
#line 167
  l_stream->m_buffer_size = p_buffer_size;
#line 168
  __cil_tmp5 = opj_malloc(p_buffer_size);
#line 168
  l_stream->m_stored_data = (OPJ_BYTE *)__cil_tmp5;
  }
#line 169
  if (! l_stream->m_stored_data) {
    {
#line 170
    opj_free(l_stream);
    }
#line 171
    return ((opj_stream_t *)0);
  }
#line 174
  l_stream->m_current_data = l_stream->m_stored_data;
#line 176
  if (l_is_input) {
#line 177
    l_stream->m_status |= 2U;
#line 178
    l_stream->m_opj_skip = & opj_stream_read_skip;
#line 179
    l_stream->m_opj_seek = & opj_stream_read_seek;
  } else {
#line 181
    l_stream->m_status |= 1U;
#line 182
    l_stream->m_opj_skip = & opj_stream_write_skip;
#line 183
    l_stream->m_opj_seek = & opj_stream_write_seek;
  }
#line 186
  l_stream->m_read_fn = & opj_stream_default_read;
#line 187
  l_stream->m_write_fn = & opj_stream_default_write;
#line 188
  l_stream->m_skip_fn = & opj_stream_default_skip;
#line 189
  l_stream->m_seek_fn = & opj_stream_default_seek;
#line 191
  return ((opj_stream_t *)l_stream);
}
}
#line 194 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
opj_stream_t *opj_stream_default_create(OPJ_BOOL l_is_input ) 
{ 
  opj_stream_t *__cil_tmp2 ;

  {
  {
#line 196
  __cil_tmp2 = opj_stream_create((OPJ_SIZE_T )1048576, l_is_input);
  }
#line 196
  return (__cil_tmp2);
}
}
#line 199 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_destroy(opj_stream_t *p_stream ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 201
  l_stream = (opj_stream_private_t *)p_stream;
#line 203
  if (l_stream) {
#line 204
    if (l_stream->m_free_user_data_fn) {
      {
#line 205
      (*(l_stream->m_free_user_data_fn))(l_stream->m_user_data);
      }
    }
    {
#line 207
    opj_free(l_stream->m_stored_data);
#line 208
    l_stream->m_stored_data = (OPJ_BYTE *)0;
#line 209
    opj_free(l_stream);
    }
  }
  return;
}
}
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_read_function(opj_stream_t *p_stream , opj_stream_read_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 216
  l_stream = (opj_stream_private_t *)p_stream;
#line 218
  if (! l_stream) {
#line 219
    return;
  } else
#line 218
  if (! (l_stream->m_status & 2U)) {
#line 219
    return;
  }
#line 222
  l_stream->m_read_fn = p_function;
  return;
}
}
#line 225 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_seek_function(opj_stream_t *p_stream , opj_stream_seek_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 228
  l_stream = (opj_stream_private_t *)p_stream;
#line 230
  if (! l_stream) {
#line 231
    return;
  }
#line 233
  l_stream->m_seek_fn = p_function;
  return;
}
}
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_write_function(opj_stream_t *p_stream , opj_stream_write_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 239
  l_stream = (opj_stream_private_t *)p_stream;
#line 241
  if (! l_stream) {
#line 242
    return;
  } else
#line 241
  if (! (l_stream->m_status & 1U)) {
#line 242
    return;
  }
#line 245
  l_stream->m_write_fn = p_function;
  return;
}
}
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_skip_function(opj_stream_t *p_stream , opj_stream_skip_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 251
  l_stream = (opj_stream_private_t *)p_stream;
#line 253
  if (! l_stream) {
#line 254
    return;
  }
#line 257
  l_stream->m_skip_fn = p_function;
  return;
}
}
#line 260 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , opj_stream_free_user_data_fn p_function ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 263
  l_stream = (opj_stream_private_t *)p_stream;
#line 264
  if (! l_stream) {
#line 265
    return;
  }
#line 267
  l_stream->m_user_data = p_data;
#line 268
  l_stream->m_free_user_data_fn = p_function;
  return;
}
}
#line 271 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) 
{ 
  opj_stream_private_t *l_stream ;

  {
#line 274
  l_stream = (opj_stream_private_t *)p_stream;
#line 275
  if (! l_stream) {
#line 276
    return;
  }
#line 278
  l_stream->m_user_data_length = data_length;
  return;
}
}
#line 281 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_read_nb_bytes ;
  OPJ_SIZE_T tmp ;
  OPJ_SIZE_T __cil_tmp7 ;
  OPJ_SIZE_T tmp___0 ;
  OPJ_SIZE_T __cil_tmp9 ;
  OPJ_SIZE_T tmp___1 ;

  {
#line 284
  l_read_nb_bytes = (OPJ_SIZE_T )0;
#line 285
  if (p_stream->m_bytes_in_buffer >= p_size) {
    {
#line 286
    memcpy(p_buffer, p_stream->m_current_data, p_size);
#line 287
    p_stream->m_current_data += p_size;
#line 288
    p_stream->m_bytes_in_buffer -= p_size;
#line 289
    l_read_nb_bytes += p_size;
#line 290
    p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
    }
#line 291
    return (l_read_nb_bytes);
  }
#line 295
  if (p_stream->m_status & 4U) {
    {
#line 296
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 297
    memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 298
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 299
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 300
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
#line 301
    if (l_read_nb_bytes) {
#line 301
      tmp = l_read_nb_bytes;
    } else {
#line 301
      tmp = (OPJ_SIZE_T )(- 1);
    }
#line 301
    return (tmp);
  }
#line 305
  if (p_stream->m_bytes_in_buffer) {
    {
#line 306
    l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 307
    memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 308
    p_stream->m_current_data = p_stream->m_stored_data;
#line 309
    p_buffer += p_stream->m_bytes_in_buffer;
#line 310
    p_size -= p_stream->m_bytes_in_buffer;
#line 311
    p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 312
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
    }
  } else {
#line 317
    p_stream->m_current_data = p_stream->m_stored_data;
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! 1) {
#line 320
      goto while_break;
    }
#line 322
    if (p_size < p_stream->m_buffer_size) {
      {
#line 324
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))(p_stream->m_stored_data,
                                                             p_stream->m_buffer_size,
                                                             p_stream->m_user_data);
      }
#line 327
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 329
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 331
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 332
        p_stream->m_status |= 4U;
        }
#line 334
        if (l_read_nb_bytes) {
#line 334
          tmp___0 = l_read_nb_bytes;
        } else {
#line 334
          tmp___0 = (OPJ_SIZE_T )(- 1);
        }
#line 334
        return (tmp___0);
      } else
#line 335
      if (p_stream->m_bytes_in_buffer < p_size) {
        {
#line 337
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 338
        memcpy(p_buffer, p_stream->m_current_data, p_stream->m_bytes_in_buffer);
#line 339
        p_stream->m_current_data = p_stream->m_stored_data;
#line 340
        p_buffer += p_stream->m_bytes_in_buffer;
#line 341
        p_size -= p_stream->m_bytes_in_buffer;
#line 342
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 343
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
        }
      } else {
        {
#line 345
        l_read_nb_bytes += p_size;
#line 346
        memcpy(p_buffer, p_stream->m_current_data, p_size);
#line 347
        p_stream->m_current_data += p_size;
#line 348
        p_stream->m_bytes_in_buffer -= p_size;
#line 349
        p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
        }
#line 350
        return (l_read_nb_bytes);
      }
    } else {
      {
#line 354
      p_stream->m_bytes_in_buffer = (*(p_stream->m_read_fn))(p_buffer, p_size, p_stream->m_user_data);
      }
#line 357
      if (p_stream->m_bytes_in_buffer == 0xffffffffffffffffUL) {
        {
#line 359
        opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n");
#line 361
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 362
        p_stream->m_status |= 4U;
        }
#line 364
        if (l_read_nb_bytes) {
#line 364
          tmp___1 = l_read_nb_bytes;
        } else {
#line 364
          tmp___1 = (OPJ_SIZE_T )(- 1);
        }
#line 364
        return (tmp___1);
      } else
#line 365
      if (p_stream->m_bytes_in_buffer < p_size) {
#line 367
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 368
        p_stream->m_current_data = p_stream->m_stored_data;
#line 369
        p_buffer += p_stream->m_bytes_in_buffer;
#line 370
        p_size -= p_stream->m_bytes_in_buffer;
#line 371
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 372
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
      } else {
#line 375
        l_read_nb_bytes += p_stream->m_bytes_in_buffer;
#line 376
        p_stream->m_byte_offset += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 377
        p_stream->m_current_data = p_stream->m_stored_data;
#line 378
        p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 379
        return (l_read_nb_bytes);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 385 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_remaining_bytes ;
  OPJ_SIZE_T l_write_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 390
  l_remaining_bytes = (OPJ_SIZE_T )0;
#line 391
  l_write_nb_bytes = (OPJ_SIZE_T )0;
#line 393
  if (p_stream->m_status & 8U) {
#line 394
    return ((OPJ_SIZE_T )(- 1));
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! 1) {
#line 397
      goto while_break;
    }
#line 398
    l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
#line 401
    if (l_remaining_bytes >= p_size) {
      {
#line 402
      memcpy(p_stream->m_current_data, p_buffer, p_size);
#line 404
      p_stream->m_current_data += p_size;
#line 405
      p_stream->m_bytes_in_buffer += p_size;
#line 406
      l_write_nb_bytes += p_size;
#line 407
      p_stream->m_byte_offset += (OPJ_OFF_T )p_size;
      }
#line 409
      return (l_write_nb_bytes);
    }
#line 413
    if (l_remaining_bytes) {
      {
#line 414
      l_write_nb_bytes += l_remaining_bytes;
#line 416
      memcpy(p_stream->m_current_data, p_buffer, l_remaining_bytes);
#line 418
      p_stream->m_current_data = p_stream->m_stored_data;
#line 420
      p_buffer += l_remaining_bytes;
#line 421
      p_size -= l_remaining_bytes;
#line 422
      p_stream->m_bytes_in_buffer += l_remaining_bytes;
#line 423
      p_stream->m_byte_offset += (OPJ_OFF_T )l_remaining_bytes;
      }
    }
    {
#line 426
    __cil_tmp7 = opj_stream_flush(p_stream, p_event_mgr);
    }
#line 426
    if (! __cil_tmp7) {
#line 427
      return ((OPJ_SIZE_T )(- 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 433 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_SIZE_T l_current_write_nb_bytes ;
  OPJ_SIZE_T __cil_tmp4 ;

  {
#line 437
  l_current_write_nb_bytes = (OPJ_SIZE_T )0;
#line 439
  p_stream->m_current_data = p_stream->m_stored_data;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! p_stream->m_bytes_in_buffer) {
#line 441
      goto while_break;
    }
    {
#line 443
    l_current_write_nb_bytes = (*(p_stream->m_write_fn))(p_stream->m_current_data,
                                                         p_stream->m_bytes_in_buffer,
                                                         p_stream->m_user_data);
    }
#line 447
    if (l_current_write_nb_bytes == 0xffffffffffffffffUL) {
      {
#line 448
      p_stream->m_status |= 8U;
#line 449
      opj_event_msg(p_event_mgr, 4, "Error on writing stream!\n8\263\177EV");
      }
#line 451
      return (0);
    }
#line 454
    p_stream->m_current_data += l_current_write_nb_bytes;
#line 455
    p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  p_stream->m_current_data = p_stream->m_stored_data;
#line 460
  return (1);
}
}
#line 463 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T tmp ;
  OPJ_OFF_T tmp___0 ;
  OPJ_OFF_T __cil_tmp8 ;
  OPJ_OFF_T tmp___1 ;

  {
#line 466
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 467
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 471
  if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T )p_size) {
#line 472
    p_stream->m_current_data += p_size;
#line 475
    p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T )p_size;
#line 476
    l_skip_nb_bytes += p_size;
#line 477
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 478
    return (l_skip_nb_bytes);
  }
#line 482
  if (p_stream->m_status & 4U) {
#line 483
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 484
    p_stream->m_current_data += p_stream->m_bytes_in_buffer;
#line 485
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 486
    p_stream->m_byte_offset += l_skip_nb_bytes;
#line 487
    if (l_skip_nb_bytes) {
#line 487
      tmp = l_skip_nb_bytes;
    } else {
#line 487
      tmp = (OPJ_OFF_T )(- 1);
    }
#line 487
    return (tmp);
  }
#line 491
  if (p_stream->m_bytes_in_buffer) {
#line 492
    l_skip_nb_bytes += (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 493
    p_stream->m_current_data = p_stream->m_stored_data;
#line 494
    p_size -= (OPJ_OFF_T )p_stream->m_bytes_in_buffer;
#line 495
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (p_size > 0L)) {
#line 498
      goto while_break;
    }
#line 503
    if ((OPJ_UINT64 )((p_stream->m_byte_offset + l_skip_nb_bytes) + p_size) > p_stream->m_user_data_length) {
      {
#line 505
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n(\263\177EV");
#line 507
      p_stream->m_byte_offset += l_skip_nb_bytes;
#line 508
      l_skip_nb_bytes = (OPJ_OFF_T )(p_stream->m_user_data_length - (OPJ_UINT64 )p_stream->m_byte_offset);
#line 511
      opj_stream_read_seek(p_stream, (OPJ_OFF_T )p_stream->m_user_data_length, p_event_mgr);
#line 513
      p_stream->m_status |= 4U;
      }
#line 516
      if (l_skip_nb_bytes) {
#line 516
        tmp___0 = l_skip_nb_bytes;
      } else {
#line 516
        tmp___0 = (OPJ_OFF_T )(- 1);
      }
#line 516
      return (tmp___0);
    }
    {
#line 520
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 521
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 522
      opj_event_msg(p_event_mgr, 4, "Stream reached its end !\n!\263\177EV");
#line 524
      p_stream->m_status |= 4U;
#line 525
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 527
      if (l_skip_nb_bytes) {
#line 527
        tmp___1 = l_skip_nb_bytes;
      } else {
#line 527
        tmp___1 = (OPJ_OFF_T )(- 1);
      }
#line 527
      return (tmp___1);
    }
#line 529
    p_size -= l_current_skip_nb_bytes;
#line 530
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 535
  return (l_skip_nb_bytes);
}
}
#line 538 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL l_is_written ;
  OPJ_OFF_T l_current_skip_nb_bytes ;
  OPJ_OFF_T l_skip_nb_bytes ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_OFF_T __cil_tmp8 ;
  OPJ_OFF_T tmp ;

  {
#line 541
  l_is_written = 0;
#line 542
  l_current_skip_nb_bytes = (OPJ_OFF_T )0;
#line 543
  l_skip_nb_bytes = (OPJ_OFF_T )0;
#line 545
  if (p_stream->m_status & 8U) {
#line 546
    return ((OPJ_OFF_T )(- 1));
  }
  {
#line 550
  l_is_written = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 551
  if (! l_is_written) {
#line 552
    p_stream->m_status |= 8U;
#line 553
    p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 554
    return ((OPJ_OFF_T )(- 1));
  }
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (p_size > 0L)) {
#line 558
      goto while_break;
    }
    {
#line 560
    l_current_skip_nb_bytes = (*(p_stream->m_skip_fn))(p_size, p_stream->m_user_data);
    }
#line 562
    if (l_current_skip_nb_bytes == -1L) {
      {
#line 563
      opj_event_msg(p_event_mgr, 4, "Stream error!\n");
#line 565
      p_stream->m_status |= 8U;
#line 566
      p_stream->m_byte_offset += l_skip_nb_bytes;
      }
#line 568
      if (l_skip_nb_bytes) {
#line 568
        tmp = l_skip_nb_bytes;
      } else {
#line 568
        tmp = (OPJ_OFF_T )(- 1);
      }
#line 568
      return (tmp);
    }
#line 570
    p_size -= l_current_skip_nb_bytes;
#line 571
    l_skip_nb_bytes += l_current_skip_nb_bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 574
  p_stream->m_byte_offset += l_skip_nb_bytes;
#line 576
  return (l_skip_nb_bytes);
}
}
#line 579 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) 
{ 


  {
#line 581
  return (p_stream->m_byte_offset);
}
}
#line 584 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) 
{ 
  OPJ_OFF_T tmp ;

  {
#line 588
  if (p_stream->m_user_data_length) {
#line 588
    tmp = (OPJ_OFF_T )p_stream->m_user_data_length - p_stream->m_byte_offset;
  } else {
#line 588
    tmp = (long )0;
  }
#line 588
  return (tmp);
}
}
#line 593 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_OFF_T __cil_tmp4 ;

  {
  {
#line 597
  __cil_tmp4 = (*(p_stream->m_opj_skip))(p_stream, p_size, p_event_mgr);
  }
#line 597
  return (__cil_tmp4);
}
}
#line 600 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 604
  p_stream->m_current_data = p_stream->m_stored_data;
#line 605
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 607
  __cil_tmp4 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 607
  if (! __cil_tmp4) {
#line 608
    p_stream->m_status |= 4U;
#line 609
    return (0);
  } else {
#line 612
    p_stream->m_status &= ~ 4U;
#line 613
    p_stream->m_byte_offset = p_size;
  }
#line 617
  return (1);
}
}
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               opj_event_mgr_t *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 623
  __cil_tmp4 = opj_stream_flush(p_stream, p_event_mgr);
  }
#line 623
  if (! __cil_tmp4) {
#line 624
    p_stream->m_status |= 8U;
#line 625
    return (0);
  }
  {
#line 628
  p_stream->m_current_data = p_stream->m_stored_data;
#line 629
  p_stream->m_bytes_in_buffer = (OPJ_SIZE_T )0;
#line 631
  __cil_tmp5 = (*(p_stream->m_seek_fn))(p_size, p_stream->m_user_data);
  }
#line 631
  if (! __cil_tmp5) {
#line 632
    p_stream->m_status |= 8U;
#line 633
    return (0);
  } else {
#line 635
    p_stream->m_byte_offset = p_size;
  }
#line 638
  return (1);
}
}
#line 641 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 645
  __cil_tmp4 = (*(p_stream->m_opj_seek))(p_stream, p_size, p_event_mgr);
  }
#line 645
  return (__cil_tmp4);
}
}
#line 648 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) 
{ 


  {
#line 650
  return (p_stream->m_seek_fn != & opj_stream_default_seek);
}
}
#line 653 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 659
  return ((OPJ_SIZE_T )(- 1));
}
}
#line 662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 668
  return ((OPJ_SIZE_T )(- 1));
}
}
#line 671 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 675
  return ((OPJ_OFF_T )(- 1));
}
}
#line 678 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.c"
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) 
{ 


  {
#line 682
  return (0);
}
}
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 57
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 63
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 75 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 77
  bio->buf = (bio->buf << 8) & 65535U;
#line 78
  if (bio->buf == 65280U) {
#line 78
    tmp = 7;
  } else {
#line 78
    tmp = 8;
  }
#line 78
  bio->ct = (OPJ_UINT32 )tmp;
#line 79
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 80
    return (0);
  }
#line 82
  __cil_tmp3 = bio->bp;
#line 82
  (bio->bp) ++;
#line 82
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 83
  return (1);
}
}
#line 86 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 88
  bio->buf = (bio->buf << 8) & 65535U;
#line 89
  if (bio->buf == 65280U) {
#line 89
    tmp = 7;
  } else {
#line 89
    tmp = 8;
  }
#line 89
  bio->ct = (OPJ_UINT32 )tmp;
#line 90
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 91
    return (0);
  }
#line 93
  __cil_tmp3 = bio->bp;
#line 93
  (bio->bp) ++;
#line 93
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 94
  return (1);
}
}
#line 97 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 99
  if (bio->ct == 0U) {
    {
#line 100
    opj_bio_bytein(bio);
    }
  }
#line 103
  __cil_tmp2 = bio->ct;
#line 103
  (bio->ct) --;
#line 104
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 113 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 115
  __cil_tmp2 = opj_malloc(sizeof(opj_bio_t ));
#line 115
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 116
  return (bio);
}
}
#line 119 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 121
  if (bio) {
    {
#line 122
    opj_free(bio);
    }
  }
  return;
}
}
#line 126 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 128
  return (bio->bp - bio->start);
}
}
#line 131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (OPJ_UINT32 )0;
#line 137
  bio->ct = (OPJ_UINT32 )8;
  return;
}
}
#line 140 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 142
  bio->start = bp;
#line 143
  bio->end = bp + len;
#line 144
  bio->bp = bp;
#line 145
  bio->buf = (OPJ_UINT32 )0;
#line 146
  bio->ct = (OPJ_UINT32 )0;
  return;
}
}
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 151
  if (bio->ct == 0U) {
    {
#line 152
    opj_bio_byteout(bio);
    }
  }
#line 155
  __cil_tmp3 = bio->ct;
#line 155
  (bio->ct) --;
#line 156
  bio->buf |= b << bio->ct;
  return;
}
}
#line 159 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 __cil_tmp5 ;

  {
#line 164
  i = (OPJ_INT32 )n - 1;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i >= 0)) {
#line 164
      goto while_break;
    }
    {
#line 165
    opj_bio_putbit(bio, (v >> i) & 1U);
    }
#line 164
    __cil_tmp5 = i;
#line 164
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 169 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_INT32 __cil_tmp6 ;

  {
#line 181
  v = 0U;
#line 182
  i = (OPJ_INT32 )n - 1;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i >= 0)) {
#line 182
      goto while_break;
    }
    {
#line 183
    __cil_tmp5 = opj_bio_getbit(bio);
    }
#line 183
    v |= __cil_tmp5 << i;
#line 182
    __cil_tmp6 = i;
#line 182
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (v);
}
}
#line 189 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 191
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 191
  if (! __cil_tmp2) {
#line 192
    return (0);
  }
#line 194
  if (bio->ct == 7U) {
    {
#line 195
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 195
    if (! __cil_tmp3) {
#line 196
      return (0);
    }
  }
#line 199
  return (1);
}
}
#line 202 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 204
  if ((bio->buf & 255U) == 255U) {
    {
#line 205
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 205
    if (! __cil_tmp2) {
#line 206
      return (0);
    }
  }
#line 209
  bio->ct = (OPJ_UINT32 )0;
#line 210
  return (1);
}
}
