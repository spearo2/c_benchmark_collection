/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_0 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_0 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_1 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_1 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_2 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_2 lldiv_t;
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_3 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_3 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__4 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_6 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_5 {
   int __count ;
   union __anonunion_6 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_5 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 99 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 118 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 127
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 132 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 137
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 144 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 149
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 154 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 159
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 164 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 169
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 173 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 186 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 197 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 204 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 216 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 239 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 244 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   int tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   int jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
};
#line 368 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 373 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   int jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
};
#line 422 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 439 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   int is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 445 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 447 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 452 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   int is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 461 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   int is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 465 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 484 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 501 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 512 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 537 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 542 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
};
#line 557 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 562 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 581 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 592 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 601 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 606 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 617 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 622 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 651 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 657 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 664 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 670 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 717 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 100 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 58 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 62 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 67 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
};
#line 90 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 95 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 99 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 73 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 47 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 48 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
union __anonunion_8 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_8 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 853 "/usr/include/math.h"
enum __anonenum__4___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___1 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___1 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___2 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___2 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___3 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___3 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___4 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___4 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___5 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___5 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___6 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___6 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___7 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___7 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___8 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___8 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 28 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef __suseconds_t suseconds_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_10 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_10 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_11 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_11 fd_set;
#line 89 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_12 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_13 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_14 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_15 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_16 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_17 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_18 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_19 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_20 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_21 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_22 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_23 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_24 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_25 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_12  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_13  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_14  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_15  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_16  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_17  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_18  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_19  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_20  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_21  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_22  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_23  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_24  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_25  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef __id_t id_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__29 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__32 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___9 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___9 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 237 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[4] ;
};
#line 240 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1592 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1599 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 853 "/usr/include/math.h"
enum __anonenum__4___10 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___10 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___11 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___11 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___12 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___12 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__4___13 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___13 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__37 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__37 idtype_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_44 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_43 {
   unsigned long long __wseq ;
   struct __anonstruct_44 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_46 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_45 {
   unsigned long long __g1_start ;
   struct __anonstruct_46 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_43  ;
   unsigned long long __wseq ;
   struct __anonstruct_44 __wseq32 ;
   union __anonunion_45  ;
   unsigned long long __g1_start ;
   struct __anonstruct_46 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_47 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_47 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_48 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_48 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_49 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_49 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_50 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_50 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_51 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_51 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_52 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_52 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_53 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_53 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_54 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_54 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__55 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 6 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.h"
struct option {
   char *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.h"
typedef struct option option_t;
#line 36 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   int rawSigned ;
};
#line 48 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__56 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 64 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 69 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
typedef struct dircnt dircnt_t;
#line 72 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
struct img_folder {
   char *imgdirpath ;
   char *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 82 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
typedef struct img_folder img_fol_t;
#line 65 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef signed char int8;
#line 67 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef unsigned char uint8;
#line 69 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef short int16;
#line 71 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef unsigned short uint16;
#line 74 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef int int32;
#line 76 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef unsigned int uint32;
#line 85
enum TIFFIgnoreSense {
    TIS_STORE = 0,
    TIS_EXTRACT = 1,
    TIS_EMPTY = 2
} ;
#line 95 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
struct __anonstruct_75 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint32 tiff_diroff ;
};
#line 102 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef struct __anonstruct_75 TIFFHeader;
#line 116 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
struct __anonstruct_76 {
   uint16 tdir_tag ;
   uint16 tdir_type ;
   uint32 tdir_count ;
   uint32 tdir_offset ;
};
#line 121 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef struct __anonstruct_76 TIFFDirEntry;
#line 137
enum __anonenum__77 {
    TIFF_NOTYPE = 0,
    TIFF_BYTE = 1,
    TIFF_ASCII = 2,
    TIFF_SHORT = 3,
    TIFF_LONG = 4,
    TIFF_RATIONAL = 5,
    TIFF_SBYTE = 6,
    TIFF_UNDEFINED = 7,
    TIFF_SSHORT = 8,
    TIFF_SLONG = 9,
    TIFF_SRATIONAL = 10,
    TIFF_FLOAT = 11,
    TIFF_DOUBLE = 12,
    TIFF_IFD = 13
} ;
#line 152 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiff.h"
typedef enum __anonenum__77 TIFFDataType;
#line 40 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct tiff ;
#line 40 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct tiff TIFF;
#line 61 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint32 ttag_t;
#line 62 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint16 tdir_t;
#line 63 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint16 tsample_t;
#line 64 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint32 tstrip_t;
#line 65 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint32 ttile_t;
#line 66 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int32 tsize_t;
#line 67 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void *tdata_t;
#line 68 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef uint32 toff_t;
#line 96 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void *thandle_t;
#line 132 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef unsigned char TIFFRGBValue;
#line 134 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_78 {
   float d_mat[3][3] ;
   float d_YCR ;
   float d_YCG ;
   float d_YCB ;
   uint32 d_Vrwr ;
   uint32 d_Vrwg ;
   uint32 d_Vrwb ;
   float d_Y0R ;
   float d_Y0G ;
   float d_Y0B ;
   float d_gammaR ;
   float d_gammaG ;
   float d_gammaB ;
};
#line 148 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_78 TIFFDisplay;
#line 150 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_79 {
   TIFFRGBValue *clamptab ;
   int *Cr_r_tab ;
   int *Cb_b_tab ;
   int32 *Cr_g_tab ;
   int32 *Cb_g_tab ;
   int32 *Y_tab ;
};
#line 157 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_79 TIFFYCbCrToRGB;
#line 159 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_80 {
   int range ;
   float rstep ;
   float gstep ;
   float bstep ;
   float X0 ;
   float Y0 ;
   float Z0 ;
   TIFFDisplay display ;
   float Yr2r[1501] ;
   float Yg2g[1501] ;
   float Yb2b[1501] ;
};
#line 168 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_80 TIFFCIELabToRGB;
#line 173
struct _TIFFRGBAImage ;
#line 173 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct _TIFFRGBAImage TIFFRGBAImage;
#line 184 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*tileContigRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                  uint32  , uint32  , int32  , int32  , unsigned char * );
#line 187 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*tileSeparateRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                    uint32  , uint32  , int32  , int32  , unsigned char * ,
                                    unsigned char * , unsigned char * , unsigned char * );
#line 210 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
union __anonunion_81 {
   void (*any)(TIFFRGBAImage * ) ;
   tileContigRoutine contig ;
   tileSeparateRoutine separate ;
};
#line 193 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct _TIFFRGBAImage {
   TIFF *tif ;
   int stoponerr ;
   int isContig ;
   int alpha ;
   uint32 width ;
   uint32 height ;
   uint16 bitspersample ;
   uint16 samplesperpixel ;
   uint16 orientation ;
   uint16 req_orientation ;
   uint16 photometric ;
   uint16 *redcmap ;
   uint16 *greencmap ;
   uint16 *bluecmap ;
   int (*get)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
   union __anonunion_81 put ;
   TIFFRGBValue *Map ;
   uint32 **BWmap ;
   uint32 **PALmap ;
   TIFFYCbCrToRGB *ycbcr ;
   TIFFCIELabToRGB *cielab ;
   int row_offset ;
   int col_offset ;
};
#line 241 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int (*TIFFInitMethod)(TIFF * , int  );
#line 242 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_82 {
   char *name ;
   uint16 scheme ;
   TIFFInitMethod init ;
};
#line 246 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_82 TIFFCodec;
#line 259 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*TIFFErrorHandler)(char const   * , char const   * , va_list  );
#line 260 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*TIFFErrorHandlerExt)(thandle_t  , char const   * , char const   * ,
                                    va_list  );
#line 261 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef tsize_t (*TIFFReadWriteProc)(thandle_t  , tdata_t  , tsize_t  );
#line 262 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef toff_t (*TIFFSeekProc)(thandle_t  , toff_t  , int  );
#line 263 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int (*TIFFCloseProc)(thandle_t  );
#line 264 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef toff_t (*TIFFSizeProc)(thandle_t  );
#line 265 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int (*TIFFMapFileProc)(thandle_t  , tdata_t * , toff_t * );
#line 266 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*TIFFUnmapFileProc)(thandle_t  , tdata_t  , toff_t  );
#line 267 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*TIFFExtendProc)(TIFF * );
#line 301 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_83 {
   ttag_t field_tag ;
   short field_readcount ;
   short field_writecount ;
   TIFFDataType field_type ;
   unsigned short field_bit ;
   unsigned char field_oktochange ;
   unsigned char field_passcount ;
   char *field_name ;
};
#line 310 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_83 TIFFFieldInfo;
#line 312 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct _TIFFTagValue {
   TIFFFieldInfo *info ;
   int count ;
   void *value ;
};
#line 316 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct _TIFFTagValue TIFFTagValue;
#line 325 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int (*TIFFVSetMethod)(TIFF * , ttag_t  , va_list  );
#line 326 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef int (*TIFFVGetMethod)(TIFF * , ttag_t  , va_list  );
#line 327 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef void (*TIFFPrintMethod)(TIFF * , FILE * , long  );
#line 329 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
struct __anonstruct_84 {
   TIFFVSetMethod vsetfield ;
   TIFFVGetMethod vgetfield ;
   TIFFPrintMethod printdir ;
};
#line 333 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
typedef struct __anonstruct_84 TIFFTagMethods;
#line 79 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
struct tga_header {
   uint8 id_length ;
   uint8 colour_map_type ;
   uint8 image_type ;
   uint16 colour_map_index ;
   uint16 colour_map_length ;
   uint8 colour_map_entry_size ;
   uint16 x_origin ;
   uint16 y_origin ;
   uint16 image_width ;
   uint16 image_height ;
   uint8 pixel_depth ;
   uint8 image_desc ;
};
#line 99 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef struct tga_header tga_header;
#line 371 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef unsigned short WORD;
#line 374 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef unsigned long DWORD;
#line 376 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
struct __anonstruct_85 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 382 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef struct __anonstruct_85 BITMAPFILEHEADER_t;
#line 384 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
struct __anonstruct_86 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 396 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef struct __anonstruct_86 BITMAPINFOHEADER_t;
#line 1403 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
struct tiff_infoheader {
   DWORD tiWidth ;
   DWORD tiHeight ;
   DWORD tiPhoto ;
   WORD tiBps ;
   WORD tiSf ;
   WORD tiSpp ;
   WORD tiPC ;
};
#line 1411 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
typedef struct tiff_infoheader tiff_infoheader_t;
#line 853 "/usr/include/math.h"
enum __anonenum__87 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 784
extern int system(char const   *__command ) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 577
__inline extern char *gets(char *__str )  __attribute__((__gnu_inline__)) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 229
extern char *__gets_chk(char *__str , size_t  ) ;
#line 230
extern char *__gets_warn(char *__str ) ;
#line 235
__inline extern char *gets(char *__str )  __attribute__((__gnu_inline__)) ;
#line 235 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *gets(char *__str ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 237
  __cil_tmp2 = __builtin_object_size(__str, 1);
  }
#line 237
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 238
    __cil_tmp3 = __builtin_object_size(__str, 1);
#line 238
    __cil_tmp4 = __gets_chk(__str, __cil_tmp3);
    }
#line 238
    return (__cil_tmp4);
  }
  {
#line 239
  __cil_tmp5 = __gets_warn(__str);
  }
#line 239
  return (__cil_tmp5);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 730 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 745
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 751
void opj_image_destroy(opj_image_t *image ) ;
#line 770
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 776
void opj_cio_close(opj_cio_t *cio ) ;
#line 783
int cio_tell(opj_cio_t *cio ) ;
#line 789
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 797
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 809
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 814
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 819
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 826
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 833
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 842
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 848
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 853
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 875
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 882
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 891
int opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) ;
#line 900
int opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                         opj_codestream_info_t *cstr_info ) ;
#line 905
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/event.h"
int opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt  , ...) ;
#line 52 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 58
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 66
unsigned int cio_write(opj_cio_t *cio , unsigned int v , int n ) ;
#line 73
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 79
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
int j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 109 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 116
int jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 122
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 127
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 134
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 142
opj_image_t *jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 148
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 153
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 161
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 170
int jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 82 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 87
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 93
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 99
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 107
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 113
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 125
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 130
void mqc_flush(opj_mqc_t *mqc ) ;
#line 137
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 145
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 152
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 157
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 163
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 168
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 173
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 178
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 185
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 191
int mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 67 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 74 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 123
int pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                     int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 132
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 141
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 148
int pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
int tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 272
int tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno , opj_codestream_info_t *cstr_info ) ;
#line 277
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 278
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 73 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 82
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 91
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 96
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (l);
}
}
#line 56 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 40 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) 
{ 
  int nplh[32] ;
  int nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *parentnode ;
  opj_tgt_node_t *parentnode0 ;
  opj_tgt_tree_t *tree ;
  int i ;
  int j ;
  int k ;
  int numlvls ;
  int n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 43
  node = (opj_tgt_node_t *)((void *)0);
#line 44
  parentnode = (opj_tgt_node_t *)((void *)0);
#line 45
  parentnode0 = (opj_tgt_node_t *)((void *)0);
#line 46
  tree = (opj_tgt_tree_t *)((void *)0);
#line 51
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 51
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 52
  if (! tree) {
#line 52
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 53
  tree->numleafsh = numleafsh;
#line 54
  tree->numleafsv = numleafsv;
#line 56
  numlvls = 0;
#line 57
  nplh[0] = numleafsh;
#line 58
  nplv[0] = numleafsv;
#line 59
  tree->numnodes = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    n = nplh[numlvls] * nplv[numlvls];
#line 62
    nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
#line 63
    nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
#line 64
    tree->numnodes += n;
#line 65
    numlvls ++;
#line 60
    if (! (n > 1)) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (tree->numnodes == 0) {
    {
#line 70
    free(tree);
    }
#line 71
    return ((opj_tgt_tree_t *)((void *)0));
  }
  {
#line 74
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 74
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 75
  if (! tree->nodes) {
    {
#line 76
    free(tree);
    }
#line 77
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 80
  node = tree->nodes;
#line 81
  parentnode = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 82
  parentnode0 = parentnode;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < numlvls - 1)) {
#line 84
      goto while_break___0;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! (j < nplv[i])) {
#line 85
        goto while_break___1;
      }
#line 86
      k = nplh[i];
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        k --;
#line 87
        if (! (k >= 0)) {
#line 87
          goto while_break___2;
        }
#line 88
        node->parent = parentnode;
#line 89
        node ++;
#line 90
        k --;
#line 90
        if (k >= 0) {
#line 91
          node->parent = parentnode;
#line 92
          node ++;
        }
#line 94
        parentnode ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 96
      if (j & 1) {
#line 97
        parentnode0 = parentnode;
      } else
#line 96
      if (j == nplv[i] - 1) {
#line 97
        parentnode0 = parentnode;
      } else {
#line 99
        parentnode = parentnode0;
#line 100
        parentnode0 += nplh[i];
      }
#line 85
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 84
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  node->parent = (struct opj_tgt_node *)0;
#line 106
  tgt_reset(tree);
  }
#line 108
  return (tree);
}
}
#line 111 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
void tgt_destroy(opj_tgt_tree_t *tree ) 
{ 


  {
  {
#line 112
  free(tree->nodes);
#line 113
  free(tree);
  }
  return;
}
}
#line 116 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
void tgt_reset(opj_tgt_tree_t *tree ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 119
  if ((void *)0 == tree) {
#line 120
    return;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < tree->numnodes)) {
#line 122
      goto while_break;
    }
#line 123
    (tree->nodes + i)->value = 999;
#line 124
    (tree->nodes + i)->low = 0;
#line 125
    (tree->nodes + i)->known = 0;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 129 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 131
  node = tree->nodes + leafno;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (node && node->value > value)) {
#line 132
      goto while_break;
    }
#line 133
    node->value = value;
#line 134
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 138 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 144
  stkptr = (opj_tgt_node_t **)stk;
#line 145
  node = tree->nodes + leafno;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! node->parent) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp9 = stkptr;
#line 147
    stkptr ++;
#line 147
    *__cil_tmp9 = node;
#line 148
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  low = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! 1) {
#line 152
      goto while_break___0;
    }
#line 153
    if (low > node->low) {
#line 154
      node->low = low;
    } else {
#line 156
      low = node->low;
    }
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (low < threshold)) {
#line 159
        goto while_break___1;
      }
#line 160
      if (low >= node->value) {
#line 161
        if (! node->known) {
          {
#line 162
          bio_write(bio, 1, 1);
#line 163
          node->known = 1;
          }
        }
#line 165
        goto while_break___1;
      }
      {
#line 167
      bio_write(bio, 0, 1);
#line 168
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    node->low = low;
#line 172
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 173
      goto while_break___0;
    }
#line 174
    stkptr --;
#line 174
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 178 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tgt.c"
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 184
  stkptr = (opj_tgt_node_t **)stk;
#line 185
  node = tree->nodes + leafno;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! node->parent) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp9 = stkptr;
#line 187
    stkptr ++;
#line 187
    *__cil_tmp9 = node;
#line 188
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  low = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! 1) {
#line 192
      goto while_break___0;
    }
#line 193
    if (low > node->low) {
#line 194
      node->low = low;
    } else {
#line 196
      low = node->low;
    }
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (low < threshold && low < node->value)) {
#line 198
        goto while_break___1;
      }
      {
#line 199
      __cil_tmp10 = bio_read(bio, 1);
      }
#line 199
      if (__cil_tmp10) {
#line 200
        node->value = low;
      } else {
#line 202
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    node->low = low;
#line 206
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 207
      goto while_break___0;
    }
#line 209
    stkptr --;
#line 209
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  if (node->value < threshold) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 35 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 38
  fprintf(fd, "image {\n\220");
#line 39
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 42
  tileno = 0;
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (tileno < img->th * img->tw)) {
#line 42
      goto while_break;
    }
    {
#line 43
    tile = (tcd->tcd_image)->tiles + tileno;
#line 44
    fprintf(fd, "  tile {\n");
#line 45
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n\032V", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 47
    compno = 0;
    }
    {
#line 47
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 47
      if (! (compno < tile->numcomps)) {
#line 47
        goto while_break___0;
      }
      {
#line 48
      tilec = tile->comps + compno;
#line 49
      fprintf(fd, "    tilec {\n");
#line 50
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 53
      resno = 0;
      }
      {
#line 53
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 53
        if (! (resno < tilec->numresolutions)) {
#line 53
          goto while_break___1;
        }
        {
#line 54
        res = tilec->resolutions + resno;
#line 55
        fprintf(fd, "\n   res {\n");
#line 56
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 59
        bandno = 0;
        }
        {
#line 59
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 59
          if (! (bandno < res->numbands)) {
#line 59
            goto while_break___2;
          }
          {
#line 60
          band = & res->bands[bandno];
#line 61
          fprintf(fd, "        band {\n");
#line 62
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 65
          precno = 0;
          }
          {
#line 65
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 65
            if (! (precno < res->pw * res->ph)) {
#line 65
              goto while_break___3;
            }
            {
#line 66
            prec = band->precincts + precno;
#line 67
            fprintf(fd, "          prec {\n");
#line 68
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 81
            fprintf(fd, "          }\n");
            }
#line 65
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 83
          fprintf(fd, "        }\n");
          }
#line 59
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 85
        fprintf(fd, "      }\n\220");
        }
#line 53
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 87
      fprintf(fd, "    }\n");
      }
#line 47
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    fprintf(fd, "  }\n");
    }
#line 42
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 99 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 101
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 101
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 102
  if (! tcd) {
#line 102
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 103
  tcd->cinfo = cinfo;
#line 104
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 104
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 105
  if (! tcd->tcd_image) {
    {
#line 106
    free(tcd);
    }
#line 107
    return ((opj_tcd_t *)((void *)0));
  }
#line 110
  return (tcd);
}
}
#line 116 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 117
  if (tcd) {
    {
#line 118
    free(tcd->tcd_image);
#line 119
    free(tcd);
    }
  }
  return;
}
}
#line 125 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int __cil_tmp88 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;

  {
  {
#line 128
  tcd->image = image;
#line 129
  tcd->cp = cp;
#line 130
  (tcd->tcd_image)->tw = cp->tw;
#line 131
  (tcd->tcd_image)->th = cp->th;
#line 132
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 132
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 134
  tileno = 0;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (tileno < 1)) {
#line 134
      goto while_break;
    }
    {
#line 135
    tcp = cp->tcps + curtileno;
#line 139
    p = curtileno % cp->tw;
#line 140
    q = curtileno / cp->tw;
#line 143
    tile = (tcd->tcd_image)->tiles;
#line 146
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 147
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 148
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 149
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 150
    tile->numcomps = image->numcomps;
#line 154
    j = 0;
    }
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (j < tcp->numlayers)) {
#line 154
        goto while_break___0;
      }
#line 155
      if (tcp->rates[j]) {
#line 155
        if ((int )cp->tp_on) {
#line 155
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 155
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 155
        tmp___0 = tmp;
      } else {
#line 155
        tmp___0 = (float )0;
      }
#line 155
      tcp->rates[j] = tmp___0;
#line 170
      if (tcp->rates[j]) {
#line 171
        if (j) {
#line 171
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 172
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 171
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 174
        if (! j) {
#line 174
          if (tcp->rates[j] < (float )30) {
#line 175
            tcp->rates[j] = (float )30;
          }
        }
#line 178
        if (j == tcp->numlayers - 1) {
#line 179
          tcp->rates[j] -= (float )2;
        }
      }
#line 154
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 185
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 185
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 186
    compno = 0;
    }
    {
#line 186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 186
      if (! (compno < tile->numcomps)) {
#line 186
        goto while_break___1;
      }
      {
#line 187
      tccp = tcp->tccps + compno;
#line 189
      tilec = tile->comps + compno;
#line 192
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 193
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 194
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 195
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 197
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 197
      tilec->data = (int *)__cil_tmp31;
#line 198
      tilec->numresolutions = tccp->numresolutions;
#line 200
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 200
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 202
      resno = 0;
      }
      {
#line 202
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 202
        if (! (resno < tilec->numresolutions)) {
#line 202
          goto while_break___2;
        }
        {
#line 204
        levelno = (tilec->numresolutions - 1) - resno;
#line 210
        res = tilec->resolutions + resno;
#line 213
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 214
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 215
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 216
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 218
        if (resno == 0) {
#line 218
          tmp___1 = 1;
        } else {
#line 218
          tmp___1 = 3;
        }
#line 218
        res->numbands = tmp___1;
#line 220
        if (tccp->csty & 1) {
#line 221
          pdx = tccp->prcw[resno];
#line 222
          pdy = tccp->prch[resno];
        } else {
#line 224
          pdx = 15;
#line 225
          pdy = 15;
        }
        {
#line 228
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 228
        tlprcxstart = __cil_tmp54 << pdx;
#line 229
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 229
        tlprcystart = __cil_tmp55 << pdy;
#line 231
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 231
        brprcxend = __cil_tmp56 << pdx;
#line 232
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 232
        brprcyend = __cil_tmp57 << pdy;
#line 234
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 235
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 237
        if (resno == 0) {
#line 238
          tlcbgxstart = tlprcxstart;
#line 239
          tlcbgystart = tlprcystart;
#line 240
          brcbgxend = brprcxend;
#line 241
          brcbgyend = brprcyend;
#line 242
          cbgwidthexpn = pdx;
#line 243
          cbgheightexpn = pdy;
        } else {
          {
#line 245
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 246
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 247
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 248
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 249
          cbgwidthexpn = pdx - 1;
#line 250
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 253
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 254
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 256
        bandno = 0;
        }
        {
#line 256
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 256
          if (! (bandno < res->numbands)) {
#line 256
            goto while_break___3;
          }
#line 259
          ss = (opj_stepsize_t *)((void *)0);
#line 261
          band = & res->bands[bandno];
#line 263
          if (resno == 0) {
#line 263
            tmp___2 = 0;
          } else {
#line 263
            tmp___2 = bandno + 1;
          }
#line 263
          band->bandno = tmp___2;
#line 264
          if (band->bandno == 1 || band->bandno == 3) {
#line 264
            tmp___3 = 1;
          } else {
#line 264
            tmp___3 = 0;
          }
#line 264
          x0b = tmp___3;
#line 265
          if (band->bandno == 2 || band->bandno == 3) {
#line 265
            tmp___4 = 1;
          } else {
#line 265
            tmp___4 = 0;
          }
#line 265
          y0b = tmp___4;
#line 267
          if (band->bandno == 0) {
            {
#line 269
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 270
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 271
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 272
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 275
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 276
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 277
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 278
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 281
          if (resno == 0) {
#line 281
            tmp___5 = 0;
          } else {
#line 281
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 281
          ss = & tccp->stepsizes[tmp___5];
#line 282
          if (tccp->qmfbid == 0) {
            {
#line 282
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 282
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 282
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 282
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 282
          gain = tmp___6;
#line 283
          numbps = (image->comps + compno)->prec + gain;
#line 285
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 285
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 286
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 288
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 288
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 290
          i = 0;
          }
          {
#line 290
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 290
            if (! (i < (res->pw * res->ph) * 3)) {
#line 290
              goto while_break___4;
            }
#line 291
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 292
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 290
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 295
          precno = 0;
          {
#line 295
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 295
            if (! (precno < res->pw * res->ph)) {
#line 295
              goto while_break___5;
            }
            {
#line 298
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 299
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 300
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 301
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 303
            prc = band->precincts + precno;
#line 306
            prc->x0 = int_max(cbgxstart, band->x0);
#line 307
            prc->y0 = int_max(cbgystart, band->y0);
#line 308
            prc->x1 = int_min(cbgxend, band->x1);
#line 309
            prc->y1 = int_min(cbgyend, band->y1);
#line 311
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 311
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 312
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 312
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 313
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 313
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 314
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 314
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 315
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 316
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 318
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 318
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 319
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 320
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 322
            cblkno = 0;
            }
            {
#line 322
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 322
              if (! (cblkno < prc->cw * prc->ch)) {
#line 322
                goto while_break___6;
              }
              {
#line 323
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 324
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 325
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 326
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 328
              cblk = prc->cblks.enc + cblkno;
#line 331
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 332
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 333
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 334
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 335
              __cil_tmp118 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 335
              cblk->data = (unsigned char *)__cil_tmp118;
#line 337
              cblk->data += 2;
#line 338
              __cil_tmp119 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 338
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 339
              __cil_tmp120 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 339
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
              }
#line 322
              cblkno ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 295
            precno ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 256
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 202
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 186
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 134
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 350 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 353
  tileno = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (tileno < 1)) {
#line 353
      goto while_break;
    }
#line 354
    tile = (tcd->tcd_image)->tiles;
#line 356
    compno = 0;
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      if (! (compno < tile->numcomps)) {
#line 356
        goto while_break___0;
      }
#line 357
      tilec = tile->comps + compno;
#line 359
      resno = 0;
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 359
        if (! (resno < tilec->numresolutions)) {
#line 359
          goto while_break___1;
        }
#line 360
        res = tilec->resolutions + resno;
#line 362
        bandno = 0;
        {
#line 362
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 362
          if (! (bandno < res->numbands)) {
#line 362
            goto while_break___2;
          }
#line 363
          band = & res->bands[bandno];
#line 365
          precno = 0;
          {
#line 365
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 365
            if (! (precno < res->pw * res->ph)) {
#line 365
              goto while_break___3;
            }
#line 366
            prc = band->precincts + precno;
#line 368
            if (prc->incltree != (void *)0) {
              {
#line 369
              tgt_destroy(prc->incltree);
#line 370
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 372
            if (prc->imsbtree != (void *)0) {
              {
#line 373
              tgt_destroy(prc->imsbtree);
#line 374
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 376
            cblkno = 0;
            {
#line 376
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 376
              if (! (cblkno < prc->cw * prc->ch)) {
#line 376
                goto while_break___4;
              }
              {
#line 377
              free((prc->cblks.enc + cblkno)->data - 2);
#line 378
              free((prc->cblks.enc + cblkno)->layers);
#line 379
              free((prc->cblks.enc + cblkno)->passes);
              }
#line 376
              cblkno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 381
            free(prc->cblks.enc);
            }
#line 365
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 383
          free(band->precincts);
#line 384
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
          }
#line 362
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 359
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 387
      free(tilec->resolutions);
#line 388
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
      }
#line 356
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 390
    free(tile->comps);
#line 391
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
#line 353
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 393
  free((tcd->tcd_image)->tiles);
#line 394
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
  return;
}
}
#line 397 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp22 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  opj_tgt_tree_t *__cil_tmp101 ;
  opj_tgt_tree_t *__cil_tmp102 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;

  {
#line 400
  tileno = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (tileno < 1)) {
#line 400
      goto while_break;
    }
    {
#line 401
    tcp = cp->tcps + curtileno;
#line 404
    p = curtileno % cp->tw;
#line 405
    q = curtileno / cp->tw;
#line 407
    tile = (tcd->tcd_image)->tiles;
#line 410
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 411
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 412
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 413
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 415
    tile->numcomps = image->numcomps;
#line 419
    j = 0;
    }
    {
#line 419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 419
      if (! (j < tcp->numlayers)) {
#line 419
        goto while_break___0;
      }
#line 420
      if (tcp->rates[j]) {
#line 420
        if ((int )cp->tp_on) {
#line 420
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 420
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 420
        tmp___0 = tmp;
      } else {
#line 420
        tmp___0 = (float )0;
      }
#line 420
      tcp->rates[j] = tmp___0;
#line 435
      if (tcp->rates[j]) {
#line 436
        if (j) {
#line 436
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 437
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 436
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 439
        if (! j) {
#line 439
          if (tcp->rates[j] < (float )30) {
#line 440
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 419
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    compno = 0;
    {
#line 447
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 447
      if (! (compno < tile->numcomps)) {
#line 447
        goto while_break___1;
      }
      {
#line 448
      tccp = tcp->tccps + compno;
#line 450
      tilec = tile->comps + compno;
#line 453
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 454
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 455
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 456
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 458
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 458
      tilec->data = (int *)__cil_tmp29;
#line 459
      tilec->numresolutions = tccp->numresolutions;
#line 461
      resno = 0;
      }
      {
#line 461
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 461
        if (! (resno < tilec->numresolutions)) {
#line 461
          goto while_break___2;
        }
        {
#line 464
        levelno = (tilec->numresolutions - 1) - resno;
#line 470
        res = tilec->resolutions + resno;
#line 473
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 474
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 475
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 476
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 477
        if (resno == 0) {
#line 477
          tmp___1 = 1;
        } else {
#line 477
          tmp___1 = 3;
        }
#line 477
        res->numbands = tmp___1;
#line 480
        if (tccp->csty & 1) {
#line 481
          pdx = tccp->prcw[resno];
#line 482
          pdy = tccp->prch[resno];
        } else {
#line 484
          pdx = 15;
#line 485
          pdy = 15;
        }
        {
#line 488
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 488
        tlprcxstart = __cil_tmp51 << pdx;
#line 489
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 489
        tlprcystart = __cil_tmp52 << pdy;
#line 490
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 490
        brprcxend = __cil_tmp53 << pdx;
#line 491
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 491
        brprcyend = __cil_tmp54 << pdy;
#line 493
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 494
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 496
        if (resno == 0) {
#line 497
          tlcbgxstart = tlprcxstart;
#line 498
          tlcbgystart = tlprcystart;
#line 499
          brcbgxend = brprcxend;
#line 500
          brcbgyend = brprcyend;
#line 501
          cbgwidthexpn = pdx;
#line 502
          cbgheightexpn = pdy;
        } else {
          {
#line 504
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 505
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 506
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 507
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 508
          cbgwidthexpn = pdx - 1;
#line 509
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 512
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 513
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 515
        bandno = 0;
        }
        {
#line 515
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 515
          if (! (bandno < res->numbands)) {
#line 515
            goto while_break___3;
          }
#line 518
          ss = (opj_stepsize_t *)((void *)0);
#line 520
          band = & res->bands[bandno];
#line 522
          if (resno == 0) {
#line 522
            tmp___2 = 0;
          } else {
#line 522
            tmp___2 = bandno + 1;
          }
#line 522
          band->bandno = tmp___2;
#line 523
          if (band->bandno == 1 || band->bandno == 3) {
#line 523
            tmp___3 = 1;
          } else {
#line 523
            tmp___3 = 0;
          }
#line 523
          x0b = tmp___3;
#line 524
          if (band->bandno == 2 || band->bandno == 3) {
#line 524
            tmp___4 = 1;
          } else {
#line 524
            tmp___4 = 0;
          }
#line 524
          y0b = tmp___4;
#line 526
          if (band->bandno == 0) {
            {
#line 528
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 529
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 530
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 531
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 533
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 534
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 535
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 536
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 539
          if (resno == 0) {
#line 539
            tmp___5 = 0;
          } else {
#line 539
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 539
          ss = & tccp->stepsizes[tmp___5];
#line 540
          if (tccp->qmfbid == 0) {
            {
#line 540
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 540
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 540
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 540
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 540
          gain = tmp___6;
#line 541
          numbps = (image->comps + compno)->prec + gain;
#line 542
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 542
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 543
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 545
          precno = 0;
          }
          {
#line 545
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 545
            if (! (precno < res->pw * res->ph)) {
#line 545
              goto while_break___4;
            }
            {
#line 548
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 549
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 550
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 551
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 553
            prc = band->precincts + precno;
#line 556
            prc->x0 = int_max(cbgxstart, band->x0);
#line 557
            prc->y0 = int_max(cbgystart, band->y0);
#line 558
            prc->x1 = int_min(cbgxend, band->x1);
#line 559
            prc->y1 = int_min(cbgyend, band->y1);
#line 561
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 561
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 562
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 562
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 563
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 563
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 564
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 564
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 565
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 566
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 568
            free(prc->cblks.enc);
#line 569
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 569
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 571
            if (prc->incltree != (void *)0) {
              {
#line 572
              tgt_destroy(prc->incltree);
              }
            }
#line 574
            if (prc->imsbtree != (void *)0) {
              {
#line 575
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 578
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 579
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 581
            cblkno = 0;
            }
            {
#line 581
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 581
              if (! (cblkno < prc->cw * prc->ch)) {
#line 581
                goto while_break___5;
              }
              {
#line 582
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 583
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 584
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 585
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 587
              cblk = prc->cblks.enc + cblkno;
#line 590
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 591
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 592
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 593
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 594
              __cil_tmp112 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 594
              cblk->data = (unsigned char *)__cil_tmp112;
#line 596
              cblk->data += 2;
#line 597
              __cil_tmp113 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 597
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 598
              __cil_tmp114 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 598
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
              }
#line 581
              cblkno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 545
            precno ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 515
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 461
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 447
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 400
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 609 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
#line 611
  x0 = (unsigned int )0;
#line 611
  y0___0 = (unsigned int )0;
#line 611
  x1 = (unsigned int )0;
  {
#line 611
  y1___0 = (unsigned int )0;
#line 613
  tcd->image = image;
#line 614
  (tcd->tcd_image)->tw = cp->tw;
#line 615
  (tcd->tcd_image)->th = cp->th;
#line 616
  __cil_tmp15 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tcd_tile_t ));
#line 616
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 623
  j = 0;
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (j < cp->tileno_size)) {
#line 623
      goto while_break;
    }
    {
#line 626
    tileno = *(cp->tileno + j);
#line 627
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 628
    tile->numcomps = image->numcomps;
#line 629
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 629
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
    }
#line 623
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  i = 0;
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! (i < image->numcomps)) {
#line 632
      goto while_break___0;
    }
#line 633
    j = 0;
    {
#line 633
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 633
      if (! (j < cp->tileno_size)) {
#line 633
        goto while_break___1;
      }
      {
#line 639
      tileno = *(cp->tileno + j);
#line 641
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 642
      tilec = tile___0->comps + i;
#line 644
      p = tileno % cp->tw;
#line 645
      q = tileno / cp->tw;
#line 648
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 649
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 650
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 651
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 653
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 654
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 655
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 656
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 658
      if (j == 0) {
#line 658
        tmp = tilec->x0;
      } else {
        {
#line 658
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 658
        tmp = __cil_tmp29;
        }
      }
#line 658
      x0 = (unsigned int )tmp;
#line 659
      if (j == 0) {
#line 659
        tmp___0 = tilec->y0;
      } else {
        {
#line 659
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->x0));
#line 659
        tmp___0 = __cil_tmp31;
        }
      }
#line 659
      y0___0 = (unsigned int )tmp___0;
#line 660
      if (j == 0) {
#line 660
        tmp___1 = tilec->x1;
      } else {
        {
#line 660
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 660
        tmp___1 = __cil_tmp33;
        }
      }
#line 660
      x1 = (unsigned int )tmp___1;
#line 661
      if (j == 0) {
#line 661
        tmp___2 = tilec->y1;
      } else {
        {
#line 661
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 661
        tmp___2 = __cil_tmp35;
        }
      }
#line 661
      y1___0 = (unsigned int )tmp___2;
#line 633
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 664
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 664
    w = (unsigned int )__cil_tmp38;
#line 665
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 665
    h = (unsigned int )__cil_tmp39;
#line 667
    (image->comps + i)->w = (int )w;
#line 668
    (image->comps + i)->h = (int )h;
#line 669
    (image->comps + i)->x0 = (int )x0;
#line 670
    (image->comps + i)->y0 = (int )y0___0;
    }
#line 632
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 674 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tgt_tree_t *__cil_tmp94 ;
  opj_tgt_tree_t *__cil_tmp95 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 679
  tcd->cp = cp;
#line 681
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 682
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 684
  tileno = *(cp->tileno + tileno);
#line 686
  compno = 0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (compno < tile->numcomps)) {
#line 686
      goto while_break;
    }
    {
#line 687
    tccp = tcp->tccps + compno;
#line 688
    tilec = tile->comps + compno;
#line 691
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 692
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 693
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 694
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 696
    tilec->numresolutions = tccp->numresolutions;
#line 697
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 697
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 699
    resno = 0;
    }
    {
#line 699
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 699
      if (! (resno < tilec->numresolutions)) {
#line 699
        goto while_break___0;
      }
      {
#line 701
      levelno = (tilec->numresolutions - 1) - resno;
#line 707
      res = tilec->resolutions + resno;
#line 710
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 711
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 712
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 713
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 714
      if (resno == 0) {
#line 714
        tmp = 1;
      } else {
#line 714
        tmp = 3;
      }
#line 714
      res->numbands = tmp;
#line 717
      if (tccp->csty & 1) {
#line 718
        pdx = tccp->prcw[resno];
#line 719
        pdy = tccp->prch[resno];
      } else {
#line 721
        pdx = 15;
#line 722
        pdy = 15;
      }
      {
#line 726
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 726
      tlprcxstart = __cil_tmp41 << pdx;
#line 727
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 727
      tlprcystart = __cil_tmp42 << pdy;
#line 728
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 728
      brprcxend = __cil_tmp43 << pdx;
#line 729
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 729
      brprcyend = __cil_tmp44 << pdy;
      }
#line 731
      if (res->x0 == res->x1) {
#line 731
        tmp___0 = 0;
      } else {
#line 731
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 731
      res->pw = tmp___0;
#line 732
      if (res->y0 == res->y1) {
#line 732
        tmp___1 = 0;
      } else {
#line 732
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 732
      res->ph = tmp___1;
#line 734
      if (resno == 0) {
#line 735
        tlcbgxstart = tlprcxstart;
#line 736
        tlcbgystart = tlprcystart;
#line 737
        brcbgxend = brprcxend;
#line 738
        brcbgyend = brprcyend;
#line 739
        cbgwidthexpn = pdx;
#line 740
        cbgheightexpn = pdy;
      } else {
        {
#line 742
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 743
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 744
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 745
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 746
        cbgwidthexpn = pdx - 1;
#line 747
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 750
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 751
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 753
      bandno = 0;
      }
      {
#line 753
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 753
        if (! (bandno < res->numbands)) {
#line 753
          goto while_break___1;
        }
#line 756
        ss = (opj_stepsize_t *)((void *)0);
#line 758
        band = & res->bands[bandno];
#line 759
        if (resno == 0) {
#line 759
          tmp___2 = 0;
        } else {
#line 759
          tmp___2 = bandno + 1;
        }
#line 759
        band->bandno = tmp___2;
#line 760
        if (band->bandno == 1 || band->bandno == 3) {
#line 760
          tmp___3 = 1;
        } else {
#line 760
          tmp___3 = 0;
        }
#line 760
        x0b = tmp___3;
#line 761
        if (band->bandno == 2 || band->bandno == 3) {
#line 761
          tmp___4 = 1;
        } else {
#line 761
          tmp___4 = 0;
        }
#line 761
        y0b = tmp___4;
#line 763
        if (band->bandno == 0) {
          {
#line 765
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 766
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 767
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 768
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 771
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 772
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 773
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 774
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 777
        if (resno == 0) {
#line 777
          tmp___5 = 0;
        } else {
#line 777
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 777
        ss = & tccp->stepsizes[tmp___5];
#line 778
        if (tccp->qmfbid == 0) {
          {
#line 778
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 778
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 778
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 778
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 778
        gain = tmp___6;
#line 779
        numbps = (image->comps + compno)->prec + gain;
#line 780
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 780
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 781
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 783
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 783
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 785
        precno = 0;
        }
        {
#line 785
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 785
          if (! (precno < res->pw * res->ph)) {
#line 785
            goto while_break___2;
          }
          {
#line 787
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 788
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 789
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 790
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 792
          prc = band->precincts + precno;
#line 794
          prc->x0 = int_max(cbgxstart, band->x0);
#line 795
          prc->y0 = int_max(cbgystart, band->y0);
#line 796
          prc->x1 = int_min(cbgxend, band->x1);
#line 797
          prc->y1 = int_min(cbgyend, band->y1);
#line 799
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 799
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 800
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 800
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 801
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 801
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 802
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 802
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 803
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 804
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 806
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 806
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 808
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 809
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 811
          cblkno = 0;
          }
          {
#line 811
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 811
            if (! (cblkno < prc->cw * prc->ch)) {
#line 811
              goto while_break___3;
            }
            {
#line 812
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 813
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 814
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 815
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 817
            cblk = prc->cblks.dec + cblkno;
#line 818
            cblk->data = (unsigned char *)((void *)0);
#line 819
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 821
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 822
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 823
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 824
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 825
            cblk->numsegs = 0;
            }
#line 811
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 785
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 753
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 699
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 834 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 840
  cp = tcd->cp;
#line 841
  tcd_tile = tcd->tcd_tile;
#line 842
  tcd_tcp = tcd->tcp;
#line 846
  compno = 0;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (compno < tcd_tile->numcomps)) {
#line 846
      goto while_break;
    }
#line 847
    tilec = tcd_tile->comps + compno;
#line 848
    i = 0;
    {
#line 848
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 848
      if (! (i < tcd_tcp->numlayers)) {
#line 848
        goto while_break___0;
      }
#line 849
      j = 0;
      {
#line 849
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 849
        if (! (j < tilec->numresolutions)) {
#line 849
          goto while_break___1;
        }
#line 850
        k = 0;
        {
#line 850
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 850
          if (! (k < 3)) {
#line 850
            goto while_break___2;
          }
#line 851
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 850
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 849
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 848
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 858
    resno = 0;
    {
#line 858
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 858
      if (! (resno < tilec->numresolutions)) {
#line 858
        goto while_break___3;
      }
#line 859
      res = tilec->resolutions + resno;
#line 860
      bandno = 0;
      {
#line 860
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 860
        if (! (bandno < res->numbands)) {
#line 860
          goto while_break___4;
        }
#line 861
        band = & res->bands[bandno];
#line 862
        precno = 0;
        {
#line 862
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 862
          if (! (precno < res->pw * res->ph)) {
#line 862
            goto while_break___5;
          }
#line 863
          prc = band->precincts + precno;
#line 864
          cblkno = 0;
          {
#line 864
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 864
            if (! (cblkno < prc->cw * prc->ch)) {
#line 864
              goto while_break___6;
            }
#line 865
            cblk = prc->cblks.enc + cblkno;
#line 866
            layer = cblk->layers + layno;
#line 868
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 870
            if (layno == 0) {
#line 871
              value = matrice[layno][resno][bandno];
#line 872
              if (imsb >= value) {
#line 873
                value = 0;
              } else {
#line 875
                value -= imsb;
              }
            } else {
#line 878
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 879
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 880
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 881
                if (value < 0) {
#line 882
                  value = 0;
                }
              }
            }
#line 887
            if (layno == 0) {
#line 888
              cblk->numpassesinlayers = 0;
            }
#line 891
            n = cblk->numpassesinlayers;
#line 892
            if (cblk->numpassesinlayers == 0) {
#line 893
              if (value != 0) {
#line 894
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 896
                n = cblk->numpassesinlayers;
              }
            } else {
#line 899
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 902
            layer->numpasses = n - cblk->numpassesinlayers;
#line 904
            if (! layer->numpasses) {
#line 905
              goto while_continue___6;
            }
#line 907
            if (cblk->numpassesinlayers == 0) {
#line 908
              layer->len = (cblk->passes + (n - 1))->rate;
#line 909
              layer->data = cblk->data;
            } else {
#line 911
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 912
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 914
            if (final) {
#line 915
              cblk->numpassesinlayers = n;
            }
#line 864
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 862
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 860
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 858
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 846
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 923 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;
  int __cil_tmp3 ;

  {
#line 925
  layno = 0;
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 925
      goto while_break;
    }
    {
#line 926
    tcd_makelayer_fixed(tcd, layno, 1);
    }
#line 925
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 930 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
#line 933
  tcd_tile = tcd->tcd_tile;
#line 935
  tcd_tile->distolayer[layno] = (double )0;
#line 937
  compno = 0;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (! (compno < tcd_tile->numcomps)) {
#line 937
      goto while_break;
    }
#line 938
    tilec = tcd_tile->comps + compno;
#line 939
    resno = 0;
    {
#line 939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 939
      if (! (resno < tilec->numresolutions)) {
#line 939
        goto while_break___0;
      }
#line 940
      res = tilec->resolutions + resno;
#line 941
      bandno = 0;
      {
#line 941
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 941
        if (! (bandno < res->numbands)) {
#line 941
          goto while_break___1;
        }
#line 942
        band = & res->bands[bandno];
#line 943
        precno = 0;
        {
#line 943
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 943
          if (! (precno < res->pw * res->ph)) {
#line 943
            goto while_break___2;
          }
#line 944
          prc = band->precincts + precno;
#line 945
          cblkno = 0;
          {
#line 945
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 945
            if (! (cblkno < prc->cw * prc->ch)) {
#line 945
              goto while_break___3;
            }
#line 946
            cblk = prc->cblks.enc + cblkno;
#line 947
            layer = cblk->layers + layno;
#line 950
            if (layno == 0) {
#line 951
              cblk->numpassesinlayers = 0;
            }
#line 953
            n = cblk->numpassesinlayers;
#line 954
            passno = cblk->numpassesinlayers;
            {
#line 954
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 954
              if (! (passno < cblk->totalpasses)) {
#line 954
                goto while_break___4;
              }
#line 957
              pass = cblk->passes + passno;
#line 958
              if (n == 0) {
#line 959
                dr = pass->rate;
#line 960
                dd = pass->distortiondec;
              } else {
#line 962
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 963
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 965
              if (! dr) {
#line 966
                if (dd != (double )0) {
#line 967
                  n = passno + 1;
                }
#line 968
                goto while_continue___4;
              }
#line 970
              if (dd / (double )dr >= thresh) {
#line 971
                n = passno + 1;
              }
#line 954
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 973
            layer->numpasses = n - cblk->numpassesinlayers;
#line 975
            if (! layer->numpasses) {
#line 976
              layer->disto = (double )0;
#line 977
              goto while_continue___3;
            }
#line 979
            if (cblk->numpassesinlayers == 0) {
#line 980
              layer->len = (cblk->passes + (n - 1))->rate;
#line 981
              layer->data = cblk->data;
#line 982
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 984
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 985
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 986
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 989
            tcd_tile->distolayer[layno] += layer->disto;
#line 991
            if (final) {
#line 992
              cblk->numpassesinlayers = n;
            }
#line 945
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 943
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 941
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 939
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 937
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1000 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
int tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  int __cil_tmp54 ;
  double tmp___0 ;
  double tmp___1 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double tmp___2 ;
  double tmp___3 ;
  int __cil_tmp61 ;

  {
#line 1004
  K = (double )1;
#line 1005
  maxSE = (double )0;
#line 1007
  cp = tcd->cp;
#line 1008
  tcd_tile = tcd->tcd_tile;
#line 1009
  tcd_tcp = tcd->tcp;
#line 1011
  min = (double )1.79769313487e+308L;
#line 1012
  max = (double )0;
#line 1014
  tcd_tile->numpix = 0;
#line 1016
  compno = 0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! (compno < tcd_tile->numcomps)) {
#line 1016
      goto while_break;
    }
#line 1017
    tilec = tcd_tile->comps + compno;
#line 1018
    tilec->numpix = 0;
#line 1020
    resno = 0;
    {
#line 1020
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1020
      if (! (resno < tilec->numresolutions)) {
#line 1020
        goto while_break___0;
      }
#line 1021
      res = tilec->resolutions + resno;
#line 1023
      bandno = 0;
      {
#line 1023
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1023
        if (! (bandno < res->numbands)) {
#line 1023
          goto while_break___1;
        }
#line 1024
        band = & res->bands[bandno];
#line 1026
        precno = 0;
        {
#line 1026
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1026
          if (! (precno < res->pw * res->ph)) {
#line 1026
            goto while_break___2;
          }
#line 1027
          prc = band->precincts + precno;
#line 1029
          cblkno = 0;
          {
#line 1029
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1029
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1029
              goto while_break___3;
            }
#line 1030
            cblk = prc->cblks.enc + cblkno;
#line 1032
            passno = 0;
            {
#line 1032
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1032
              if (! (passno < cblk->totalpasses)) {
#line 1032
                goto while_break___4;
              }
#line 1033
              pass = cblk->passes + passno;
#line 1036
              if (passno == 0) {
#line 1037
                dr = pass->rate;
#line 1038
                dd = pass->distortiondec;
              } else {
#line 1040
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1041
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1043
              if (dr == 0) {
#line 1044
                goto while_continue___4;
              }
#line 1046
              rdslope = dd / (double )dr;
#line 1047
              if (rdslope < min) {
#line 1048
                min = rdslope;
              }
#line 1050
              if (rdslope > max) {
#line 1051
                max = rdslope;
              }
#line 1032
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1056
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1057
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1029
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1026
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1023
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1020
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1063
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1016
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  if (cstr_info) {
    {
#line 1070
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1071
    tile_info->numpix = tcd_tile->numpix;
#line 1072
    tile_info->distotile = tcd_tile->distotile;
#line 1073
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1073
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1076
  layno = 0;
  {
#line 1076
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1076
    if (! (layno < tcd_tcp->numlayers)) {
#line 1076
      goto while_break___5;
    }
#line 1077
    lo = min;
#line 1078
    hi = max;
#line 1079
    success = 0;
#line 1080
    if (tcd_tcp->rates[layno]) {
      {
#line 1080
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1080
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1080
      tmp = __cil_tmp42;
      }
    } else {
#line 1080
      tmp = len;
    }
    {
#line 1080
    maxlen = tmp;
#line 1081
    goodthresh = (double )0;
#line 1082
    stable_thresh = (double )0;
#line 1087
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1087
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp48;
    }
#line 1093
    if (cp->disto_alloc == 1) {
#line 1093
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: /* CIL Label */ 
        {
#line 1094
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1094
        t2 = __cil_tmp50;
#line 1095
        thresh = (double )0;
#line 1097
        i = 0;
        }
        {
#line 1097
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1097
          if (! (i < 32)) {
#line 1097
            goto while_break___6;
          }
          {
#line 1098
          l = 0;
#line 1099
          distoachieved = (double )0;
#line 1100
          thresh = (lo + hi) / (double )2;
#line 1102
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1104
          if (cp->fixed_quality) {
#line 1105
            if (cp->cinema) {
              {
#line 1106
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1107
              if (l == -999) {
#line 1108
                lo = thresh;
#line 1109
                goto while_continue___6;
              } else {
#line 1111
                if (layno == 0) {
#line 1111
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1111
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1111
                distoachieved = tmp___0;
#line 1113
                if (distoachieved < distotarget) {
#line 1114
                  hi = thresh;
#line 1115
                  stable_thresh = thresh;
#line 1116
                  goto while_continue___6;
                } else {
#line 1118
                  lo = thresh;
                }
              }
            } else {
#line 1122
              if (layno == 0) {
#line 1122
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1122
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1122
              distoachieved = tmp___1;
#line 1124
              if (distoachieved < distotarget) {
#line 1125
                hi = thresh;
#line 1126
                stable_thresh = thresh;
#line 1127
                goto while_continue___6;
              }
#line 1129
              lo = thresh;
            }
          } else {
            {
#line 1132
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1135
            if (l == -999) {
#line 1136
              lo = thresh;
#line 1137
              goto while_continue___6;
            }
#line 1139
            hi = thresh;
#line 1140
            stable_thresh = thresh;
          }
#line 1097
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1143
        success = 1;
#line 1144
        if (stable_thresh == (double )0) {
#line 1144
          tmp___2 = thresh;
        } else {
#line 1144
          tmp___2 = stable_thresh;
        }
        {
#line 1144
        goodthresh = tmp___2;
#line 1145
        t2_destroy(t2);
        }
      } else {
#line 1093
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1093
    if (cp->fixed_quality == 1) {
#line 1093
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1093
        goto _L;
      } else {
#line 1147
        success = 1;
#line 1148
        goodthresh = min;
      }
    } else {
#line 1147
      success = 1;
#line 1148
      goodthresh = min;
    }
#line 1151
    if (! success) {
#line 1152
      return (0);
    }
#line 1155
    if (cstr_info) {
#line 1156
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1158
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1161
    if (layno == 0) {
#line 1161
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1161
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1161
    cumdisto[layno] = tmp___3;
#line 1076
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1164
  return (1);
}
}
#line 1167 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int __cil_tmp50 ;
  opj_t1_t *__cil_tmp51 ;
  opj_t2_t *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  int __cil_tmp56 ;

  {
#line 1169
  numpacks = 0;
#line 1170
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1171
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1172
  cp = (opj_cp_t *)((void *)0);
#line 1174
  tcp = (tcd->cp)->tcps + 0;
#line 1175
  tccp = tcp->tccps + 0;
#line 1176
  image = tcd->image;
#line 1178
  t1 = (opj_t1_t *)((void *)0);
#line 1179
  t2 = (opj_t2_t *)((void *)0);
#line 1181
  tcd->tcd_tileno = tileno;
#line 1182
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1183
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1185
  tile = tcd->tcd_tile;
#line 1186
  tcd_tcp = tcd->tcp;
#line 1187
  cp = tcd->cp;
#line 1189
  if (tcd->cur_tp_num == 0) {
    {
#line 1190
    tcd->encoding_time = opj_clock();
    }
#line 1192
    if (cstr_info) {
#line 1193
      tilec_idx = tile->comps + 0;
#line 1194
      i = 0;
      {
#line 1194
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1194
        if (! (i < tilec_idx->numresolutions)) {
#line 1194
          goto while_break;
        }
#line 1195
        res_idx = tilec_idx->resolutions + i;
#line 1197
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1198
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1200
        numpacks += res_idx->pw * res_idx->ph;
#line 1202
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1203
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1194
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1205
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1205
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1211
    compno = 0;
    {
#line 1211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1211
      if (! (compno < tile->numcomps)) {
#line 1211
        goto while_break___0;
      }
#line 1214
      if ((image->comps + compno)->sgnd) {
#line 1214
        tmp = 0;
      } else {
#line 1214
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1214
      adjust = tmp;
#line 1215
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1215
      offset_x = __cil_tmp28;
#line 1216
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1216
      offset_y = __cil_tmp30;
#line 1218
      tilec = tile->comps + compno;
#line 1219
      tw = tilec->x1 - tilec->x0;
#line 1220
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1220
      w = __cil_tmp34;
      }
#line 1224
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1225
        y = tilec->y0;
        {
#line 1225
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1225
          if (! (y < tilec->y1)) {
#line 1225
            goto while_break___1;
          }
#line 1227
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1229
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1230
          x = tilec->x0;
          {
#line 1230
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1230
            if (! (x < tilec->x1)) {
#line 1230
              goto while_break___2;
            }
#line 1231
            __cil_tmp38 = data;
#line 1231
            data ++;
#line 1231
            __cil_tmp37 = tile_data;
#line 1231
            tile_data ++;
#line 1231
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1230
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1225
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1234
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1235
        y = tilec->y0;
        {
#line 1235
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1235
          if (! (y < tilec->y1)) {
#line 1235
            goto while_break___3;
          }
#line 1237
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1239
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1240
          x = tilec->x0;
          {
#line 1240
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1240
            if (! (x < tilec->x1)) {
#line 1240
              goto while_break___4;
            }
#line 1241
            __cil_tmp44 = data___0;
#line 1241
            data___0 ++;
#line 1241
            __cil_tmp43 = tile_data___0;
#line 1241
            tile_data___0 ++;
#line 1241
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1240
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1235
          y ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1211
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1249
    if (tcd_tcp->mct) {
#line 1250
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1251
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1252
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1254
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1260
    compno = 0;
    {
#line 1260
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1260
      if (! (compno < tile->numcomps)) {
#line 1260
        goto while_break___5;
      }
#line 1261
      tilec___0 = tile->comps + compno;
#line 1262
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1263
        dwt_encode(tilec___0);
        }
      } else
#line 1264
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1265
        dwt_encode_real(tilec___0);
        }
      }
#line 1260
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1270
    t1 = t1_create(tcd->cinfo);
#line 1271
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1272
    t1_destroy(t1);
    }
#line 1277
    if (cstr_info) {
#line 1278
      cstr_info->index_write = 0;
    }
#line 1280
    if (cp->disto_alloc) {
      {
      {
#line 1282
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else
#line 1280
    if (cp->fixed_quality) {
      {
      {
#line 1282
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else {
      {
#line 1285
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1291
  if (cstr_info) {
#line 1292
    cstr_info->index_write = 1;
  }
  {
#line 1295
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1296
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1297
  t2_destroy(t2);
  }
#line 1302
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1303
    __cil_tmp54 = opj_clock();
#line 1303
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1304
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1307
    compno = 0;
    }
    {
#line 1307
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1307
      if (! (compno < tile->numcomps)) {
#line 1307
        goto while_break___6;
      }
      {
#line 1308
      tilec___1 = tile->comps + compno;
#line 1309
      free(tilec___1->data);
      }
#line 1307
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1313
  return (l);
}
}
#line 1316 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
int tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno , opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp15 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  opj_t2_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  opj_t1_t *__cil_tmp29 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int offset_x ;
  int __cil_tmp51 ;
  int offset_y ;
  int __cil_tmp53 ;
  int i ;
  int j ;
  void *__cil_tmp56 ;
  int v ;
  int __cil_tmp58 ;
  float tmp___2 ;
  int v___0 ;
  long __cil_tmp61 ;
  int __cil_tmp62 ;
  double __cil_tmp63 ;

  {
  {
#line 1319
  eof = 0;
#line 1321
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1323
  t1 = (opj_t1_t *)((void *)0);
#line 1324
  t2 = (opj_t2_t *)((void *)0);
#line 1326
  tcd->tcd_tileno = tileno;
#line 1327
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1328
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1329
  tile = tcd->tcd_tile;
#line 1331
  tile_time = opj_clock();
#line 1332
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1335
  if (cstr_info) {
#line 1336
    numprec = 0;
#line 1337
    compno___1 = 0;
    {
#line 1337
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1337
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1337
        goto while_break;
      }
#line 1338
      tcp = (tcd->cp)->tcps + 0;
#line 1339
      tccp = tcp->tccps + compno___1;
#line 1340
      tilec_idx = tile->comps + compno___1;
#line 1341
      resno = 0;
      {
#line 1341
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1341
        if (! (resno < tilec_idx->numresolutions)) {
#line 1341
          goto while_break___0;
        }
#line 1342
        res_idx = tilec_idx->resolutions + resno;
#line 1343
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1344
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1345
        numprec += res_idx->pw * res_idx->ph;
#line 1346
        if (tccp->csty & 1) {
#line 1347
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1348
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1351
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1352
          (cstr_info->tile + tileno)->pdx[resno] = 15;
        }
#line 1341
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1337
      compno___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1356
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1356
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1357
    cstr_info->packno = 0;
    }
  }
  {
#line 1363
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1364
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1365
  t2_destroy(t2);
  }
#line 1367
  if (l == -999) {
    {
#line 1368
    eof = 1;
#line 1369
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
  }
  {
#line 1374
  t1_time = opj_clock();
#line 1375
  t1 = t1_create(tcd->cinfo);
#line 1376
  compno = 0;
  }
  {
#line 1376
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1376
    if (! (compno < tile->numcomps)) {
#line 1376
      goto while_break___1;
    }
    {
#line 1377
    tilec = tile->comps + compno;
#line 1379
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1379
    tilec->data = (int *)__cil_tmp31;
#line 1380
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
    }
#line 1376
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1382
  t1_destroy(t1);
#line 1383
  __cil_tmp32 = opj_clock();
#line 1383
  t1_time = __cil_tmp32 - t1_time;
#line 1384
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n", t1_time);
#line 1388
  dwt_time = opj_clock();
#line 1389
  compno = 0;
  }
  {
#line 1389
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1389
    if (! (compno < tile->numcomps)) {
#line 1389
      goto while_break___2;
    }
#line 1390
    tilec___0 = tile->comps + compno;
#line 1393
    if ((tcd->cp)->reduce != 0) {
#line 1394
      ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
#line 1396
      if (((tcd->image)->comps + compno)->resno_decoded < 0) {
        {
#line 1397
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1399
        return (0);
      }
    }
#line 1403
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1404
    if (numres2decode > 0) {
#line 1405
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1406
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1408
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1389
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1412
  __cil_tmp37 = opj_clock();
#line 1412
  dwt_time = __cil_tmp37 - dwt_time;
#line 1413
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1417
  if ((tcd->tcp)->mct) {
#line 1418
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1419
    if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
      {
#line 1420
      mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                 n);
      }
    } else {
      {
#line 1426
      mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                      (float *)(tile->comps + 2)->data, n);
      }
    }
  }
#line 1436
  compno = 0;
  {
#line 1436
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1436
    if (! (compno < tile->numcomps)) {
#line 1436
      goto while_break___3;
    }
#line 1437
    tilec___1 = tile->comps + compno;
#line 1438
    imagec = (tcd->image)->comps + compno;
#line 1439
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1440
    if (imagec->sgnd) {
#line 1440
      tmp = 0;
    } else {
#line 1440
      tmp = 1 << (imagec->prec - 1);
    }
#line 1440
    adjust = tmp;
#line 1441
    if (imagec->sgnd) {
#line 1441
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1441
      tmp___0 = 0;
    }
#line 1441
    min = tmp___0;
#line 1442
    if (imagec->sgnd) {
#line 1442
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1442
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1442
    max = tmp___1;
#line 1444
    tw = tilec___1->x1 - tilec___1->x0;
#line 1445
    w = imagec->w;
#line 1447
    __cil_tmp51 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1447
    offset_x = __cil_tmp51;
#line 1448
    __cil_tmp53 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1448
    offset_y = __cil_tmp53;
    }
#line 1451
    if (! imagec->data) {
      {
#line 1452
      __cil_tmp56 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1452
      imagec->data = (int *)__cil_tmp56;
      }
    }
#line 1454
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1455
      j = res->y0;
      {
#line 1455
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1455
        if (! (j < res->y1)) {
#line 1455
          goto while_break___4;
        }
#line 1456
        i = res->x0;
        {
#line 1456
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1456
          if (! (i < res->x1)) {
#line 1456
            goto while_break___5;
          }
          {
#line 1457
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1458
          v += adjust;
#line 1459
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
          }
#line 1456
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1455
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1463
      j = res->y0;
      {
#line 1463
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1463
        if (! (j < res->y1)) {
#line 1463
          goto while_break___6;
        }
#line 1464
        i = res->x0;
        {
#line 1464
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1464
          if (! (i < res->x1)) {
#line 1464
            goto while_break___7;
          }
          {
#line 1465
          tmp___2 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1466
          __cil_tmp61 = lrintf(tmp___2);
#line 1466
          v___0 = (int )__cil_tmp61;
#line 1467
          v___0 += adjust;
#line 1468
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
          }
#line 1464
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1463
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1472
    free(tilec___1->data);
    }
#line 1436
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1475
  __cil_tmp63 = opj_clock();
#line 1475
  tile_time = __cil_tmp63 - tile_time;
#line 1476
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1478
  if (eof) {
#line 1479
    return (0);
  }
#line 1482
  return (1);
}
}
#line 1485 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;

  {
  {
#line 1486
  tcd_image = tcd->tcd_image;
#line 1487
  free(tcd_image->tiles);
  }
  return;
}
}
#line 1490 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 1493
  tcd_image = tcd->tcd_image;
#line 1495
  tile = tcd_image->tiles + tileno;
#line 1496
  compno = 0;
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! (compno < tile->numcomps)) {
#line 1496
      goto while_break;
    }
#line 1497
    tilec = tile->comps + compno;
#line 1498
    resno = 0;
    {
#line 1498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1498
      if (! (resno < tilec->numresolutions)) {
#line 1498
        goto while_break___0;
      }
#line 1499
      res = tilec->resolutions + resno;
#line 1500
      bandno = 0;
      {
#line 1500
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1500
        if (! (bandno < res->numbands)) {
#line 1500
          goto while_break___1;
        }
#line 1501
        band = & res->bands[bandno];
#line 1502
        precno = 0;
        {
#line 1502
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1502
          if (! (precno < res->ph * res->pw)) {
#line 1502
            goto while_break___2;
          }
#line 1503
          prec = band->precincts + precno;
#line 1504
          if (prec->imsbtree != (void *)0) {
            {
#line 1504
            tgt_destroy(prec->imsbtree);
            }
          }
#line 1505
          if (prec->incltree != (void *)0) {
            {
#line 1505
            tgt_destroy(prec->incltree);
            }
          }
#line 1502
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1507
        free(band->precincts);
        }
#line 1500
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1498
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1510
    free(tilec->resolutions);
    }
#line 1496
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1512
  free(tile->comps);
  }
  return;
}
}
#line 40 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) ;
#line 41
static int t2_getcommacode(opj_bio_t *bio ) ;
#line 47
static void t2_putnumpasses(opj_bio_t *bio , int n ) ;
#line 48
static int t2_getnumpasses(opj_bio_t *bio ) ;
#line 60
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) ;
#line 66
static void t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty , int first ) ;
#line 77
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) ;
#line 88 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) 
{ 


  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    n --;
#line 89
    if (! (n >= 0)) {
#line 89
      goto while_break;
    }
    {
#line 90
    bio_write(bio, 1, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  bio_write(bio, 0, 1);
  }
  return;
}
}
#line 95 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static int t2_getcommacode(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 97
  n = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! __cil_tmp3) {
#line 97
      goto while_break;
    }

#line 97
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (n);
}
}
#line 103 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static void t2_putnumpasses(opj_bio_t *bio , int n ) 
{ 


  {
#line 104
  if (n == 1) {
    {
#line 105
    bio_write(bio, 0, 1);
    }
  } else
#line 106
  if (n == 2) {
    {
#line 107
    bio_write(bio, 2, 2);
    }
  } else
#line 108
  if (n <= 5) {
    {
#line 109
    bio_write(bio, 12 | (n - 3), 4);
    }
  } else
#line 110
  if (n <= 36) {
    {
#line 111
    bio_write(bio, 480 | (n - 6), 9);
    }
  } else
#line 112
  if (n <= 164) {
    {
#line 113
    bio_write(bio, 65408 | (n - 37), 16);
    }
  }
  return;
}
}
#line 117 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static int t2_getnumpasses(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 119
  __cil_tmp3 = bio_read(bio, 1);
  }
#line 119
  if (! __cil_tmp3) {
#line 120
    return (1);
  }
  {
#line 121
  __cil_tmp4 = bio_read(bio, 1);
  }
#line 121
  if (! __cil_tmp4) {
#line 122
    return (2);
  }
  {
#line 123
  n = bio_read(bio, 2);
  }
#line 123
  if (n != 3) {
#line 124
    return (3 + n);
  }
  {
#line 125
  n = bio_read(bio, 5);
  }
#line 125
  if (n != 31) {
#line 126
    return (6 + n);
  }
  {
#line 127
  __cil_tmp7 = bio_read(bio, 7);
  }
#line 127
  return (37 + __cil_tmp7);
}
}
#line 130 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  opj_bio_t *__cil_tmp23 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_cblk_enc_t *cblk___0 ;
  opj_tcd_layer_t *layer ;
  int __cil_tmp28 ;
  opj_tcd_cblk_enc_t *cblk___1 ;
  opj_tcd_layer_t *layer___0 ;
  int increment ;
  int nump ;
  int len ;
  int passno ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_enc_t *cblk___2 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;

  {
#line 132
  c = dest;
#line 134
  compno = pi->compno;
#line 135
  resno = pi->resno;
#line 136
  precno = pi->precno;
#line 137
  layno = pi->layno;
#line 139
  tilec = tile->comps + compno;
#line 140
  res = tilec->resolutions + resno;
#line 142
  bio = (opj_bio_t *)((void *)0);
#line 145
  if (tcp->csty & 2) {
#line 146
    *(c + 0) = (unsigned char )255;
#line 147
    *(c + 1) = (unsigned char )145;
#line 148
    *(c + 2) = (unsigned char )0;
#line 149
    *(c + 3) = (unsigned char )4;
#line 150
    *(c + 4) = (unsigned char )((tile->packno % 65536) / 256);
#line 151
    *(c + 5) = (unsigned char )((tile->packno % 65536) % 256);
#line 152
    c += 6;
  }
#line 156
  if (! layno) {
#line 157
    bandno = 0;
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 157
      if (! (bandno < res->numbands)) {
#line 157
        goto while_break;
      }
      {
#line 158
      band = & res->bands[bandno];
#line 159
      prc = band->precincts + precno;
#line 160
      tgt_reset(prc->incltree);
#line 161
      tgt_reset(prc->imsbtree);
#line 162
      cblkno = 0;
      }
      {
#line 162
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 162
        if (! (cblkno < prc->cw * prc->ch)) {
#line 162
          goto while_break___0;
        }
        {
#line 163
        cblk = prc->cblks.enc + cblkno;
#line 164
        cblk->numpasses = 0;
#line 165
        tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
        }
#line 162
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 157
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 170
  bio = bio_create();
#line 171
  bio_init_enc(bio, c, length);
#line 172
  bio_write(bio, 1, 1);
#line 175
  bandno = 0;
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! (bandno < res->numbands)) {
#line 175
      goto while_break___1;
    }
#line 176
    band___0 = & res->bands[bandno];
#line 177
    prc___0 = band___0->precincts + precno;
#line 178
    cblkno = 0;
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 178
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 178
        goto while_break___2;
      }
#line 179
      cblk___0 = prc___0->cblks.enc + cblkno;
#line 180
      layer = cblk___0->layers + layno;
#line 181
      if (! cblk___0->numpasses) {
#line 181
        if (layer->numpasses) {
          {
#line 182
          tgt_setvalue(prc___0->incltree, cblkno, layno);
          }
        }
      }
#line 178
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 185
    cblkno = 0;
    {
#line 185
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 185
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 185
        goto while_break___3;
      }
#line 186
      cblk___1 = prc___0->cblks.enc + cblkno;
#line 187
      layer___0 = cblk___1->layers + layno;
#line 188
      increment = 0;
#line 189
      nump = 0;
#line 190
      len = 0;
#line 192
      if (! cblk___1->numpasses) {
        {
#line 193
        tgt_encode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 195
        bio_write(bio, layer___0->numpasses != 0, 1);
        }
      }
#line 198
      if (! layer___0->numpasses) {
#line 199
        goto while_continue___3;
      }
#line 202
      if (! cblk___1->numpasses) {
        {
#line 203
        cblk___1->numlenbits = 3;
#line 204
        tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 207
      t2_putnumpasses(bio, layer___0->numpasses);
#line 210
      passno = cblk___1->numpasses;
      }
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 210
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 210
          goto while_break___4;
        }
#line 211
        pass = cblk___1->passes + passno;
#line 212
        nump ++;
#line 213
        len += pass->len;
#line 214
        if (pass->term) {
          _L: /* CIL Label */ 
          {
#line 215
          __cil_tmp38 = int_floorlog2(nump);
          }
          {
#line 215
          __cil_tmp37 = int_floorlog2(len);
#line 215
          __cil_tmp39 = int_max(increment, (__cil_tmp37 + 1) - (cblk___1->numlenbits + __cil_tmp38));
#line 215
          increment = __cil_tmp39;
#line 216
          len = 0;
#line 217
          nump = 0;
          }
        } else
#line 214
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
#line 214
          goto _L;
        }
#line 210
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 220
      t2_putcommacode(bio, increment);
#line 223
      cblk___1->numlenbits += increment;
#line 226
      passno = cblk___1->numpasses;
      }
      {
#line 226
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 226
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 226
          goto while_break___5;
        }
#line 227
        pass___0 = cblk___1->passes + passno;
#line 228
        nump ++;
#line 229
        len += pass___0->len;
#line 230
        if (pass___0->term) {
          {
          {
#line 231
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 231
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 232
          len = 0;
#line 233
          nump = 0;
          }
        } else
#line 230
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
          {
          {
#line 231
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 231
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 232
          len = 0;
#line 233
          nump = 0;
          }
        }
#line 226
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 185
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 175
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 239
  __cil_tmp47 = bio_flush(bio);
  }
#line 239
  if (__cil_tmp47) {
    {
#line 240
    bio_destroy(bio);
    }
#line 241
    return (- 999);
  }
  {
#line 244
  __cil_tmp48 = bio_numbytes(bio);
  }
  {
#line 244
  c += __cil_tmp48;
#line 245
  bio_destroy(bio);
  }
#line 248
  if (tcp->csty & 4) {
#line 249
    *(c + 0) = (unsigned char )255;
#line 250
    *(c + 1) = (unsigned char )146;
#line 251
    c += 2;
  }
#line 258
  if (cstr_info) {
#line 258
    if (cstr_info->index_write) {
#line 259
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 260
      info_PK->end_ph_pos = (int )(c - dest);
    }
  }
#line 266
  bandno = 0;
  {
#line 266
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 266
    if (! (bandno < res->numbands)) {
#line 266
      goto while_break___6;
    }
#line 267
    band___1 = & res->bands[bandno];
#line 268
    prc___1 = band___1->precincts + precno;
#line 269
    cblkno = 0;
    {
#line 269
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 269
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 269
        goto while_break___7;
      }
#line 270
      cblk___2 = prc___1->cblks.enc + cblkno;
#line 271
      layer___1 = cblk___2->layers + layno;
#line 272
      if (! layer___1->numpasses) {
#line 273
        goto while_continue___7;
      }
#line 275
      if (c + layer___1->len > dest + length) {
#line 276
        return (- 999);
      }
      {
#line 279
      memcpy(c, layer___1->data, (unsigned long )layer___1->len);
#line 280
      cblk___2->numpasses += layer___1->numpasses;
#line 281
      c += layer___1->len;
      }
#line 283
      if (cstr_info) {
#line 283
        if (cstr_info->index_write) {
#line 284
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 285
          info_PK___0->disto += layer___1->disto;
#line 286
          if (cstr_info->D_max < info_PK___0->disto) {
#line 287
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 269
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 266
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 294
  return ((int )(c - dest));
}
}
#line 297 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static void t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty , int first ) 
{ 
  opj_tcd_seg_t *seg ;
  void *__cil_tmp6 ;
  int tmp ;

  {
  {
#line 299
  __cil_tmp6 = realloc(cblk->segs, (unsigned long )(index___0 + 1) * sizeof(opj_tcd_seg_t ));
#line 299
  cblk->segs = (opj_tcd_seg_t *)__cil_tmp6;
#line 300
  seg = cblk->segs + index___0;
#line 301
  seg->data = (unsigned char **)((void *)0);
#line 302
  seg->dataindex = 0;
#line 303
  seg->numpasses = 0;
#line 304
  seg->len = 0;
  }
#line 305
  if (cblksty & 4) {
#line 306
    seg->maxpasses = 1;
  } else
#line 308
  if (cblksty & 1) {
#line 309
    if (first) {
#line 310
      seg->maxpasses = 10;
    } else {
#line 312
      if ((seg - 1)->maxpasses == 1 || (seg - 1)->maxpasses == 10) {
#line 312
        tmp = 2;
      } else {
#line 312
        tmp = 1;
      }
#line 312
      seg->maxpasses = tmp;
    }
  } else {
#line 315
    seg->maxpasses = 109;
  }
  return;
}
}
#line 319 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  opj_cp_t *cp ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_resolution_t *res ;
  unsigned char *hd ;
  int present ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  opj_bio_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  int included ;
  int increment ;
  int n ;
  int segno ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int i ;
  int numimsbs ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_dec_t *cblk___1 ;
  opj_tcd_seg_t *seg ;
  int __cil_tmp54 ;
  opj_tcd_seg_t *__cil_tmp55 ;
  int __cil_tmp56 ;
  void *__cil_tmp57 ;
  opj_tcd_seg_t *__cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;

  {
#line 322
  c = src;
#line 324
  cp = t2->cp;
#line 326
  compno = pi->compno;
#line 327
  resno = pi->resno;
#line 328
  precno = pi->precno;
#line 329
  layno = pi->layno;
#line 331
  res = (tile->comps + compno)->resolutions + resno;
#line 333
  hd = (unsigned char *)((void *)0);
#line 336
  bio = (opj_bio_t *)((void *)0);
#line 338
  if (layno == 0) {
#line 339
    bandno = 0;
    {
#line 339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 339
      if (! (bandno < res->numbands)) {
#line 339
        goto while_break;
      }
#line 340
      band = & res->bands[bandno];
#line 341
      prc = band->precincts + precno;
#line 343
      if (band->x1 - band->x0 == 0) {
#line 343
        goto while_continue;
      } else
#line 343
      if (band->y1 - band->y0 == 0) {
#line 343
        goto while_continue;
      }
      {
#line 345
      tgt_reset(prc->incltree);
#line 346
      tgt_reset(prc->imsbtree);
#line 347
      cblkno = 0;
      }
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! (cblkno < prc->cw * prc->ch)) {
#line 347
          goto while_break___0;
        }
#line 348
        cblk = prc->cblks.dec + cblkno;
#line 349
        cblk->numsegs = 0;
#line 347
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 339
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 356
  if (tcp->csty & 2) {
#line 357
    if ((int )*c != 255) {
      {
      {
#line 358
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n");
      }
      }
    } else
#line 357
    if ((int )*(c + 1) != 145) {
      {
      {
#line 358
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n");
      }
      }
    } else {
#line 360
      c += 6;
    }
  }
  {
#line 373
  bio = bio_create();
  }
#line 375
  if (cp->ppm == 1) {
    {
#line 376
    hd = cp->ppm_data;
#line 377
    bio_init_dec(bio, hd, cp->ppm_len);
    }
  } else
#line 378
  if (tcp->ppt == 1) {
    {
#line 379
    hd = tcp->ppt_data;
#line 380
    bio_init_dec(bio, hd, tcp->ppt_len);
    }
  } else {
    {
#line 382
    hd = c;
#line 383
    bio_init_dec(bio, hd, (int )((src + len) - hd));
    }
  }
  {
#line 386
  present = bio_read(bio, 1);
  }
#line 388
  if (! present) {
    {
#line 389
    bio_inalign(bio);
#line 390
    __cil_tmp27 = bio_numbytes(bio);
    }
    {
#line 390
    hd += __cil_tmp27;
#line 391
    bio_destroy(bio);
    }
#line 395
    if (tcp->csty & 4) {
#line 396
      if ((int )*hd != 255) {
        {
        {
#line 397
        printf("Error : expected EPH marker\n");
        }
        }
      } else
#line 396
      if ((int )*(hd + 1) != 146) {
        {
        {
#line 397
        printf("Error : expected EPH marker\n");
        }
        }
      } else {
#line 399
        hd += 2;
      }
    }
#line 406
    if (pack_info) {
#line 407
      pack_info->end_ph_pos = (int )(c - src);
    }
#line 411
    if (cp->ppm == 1) {
#line 412
      cp->ppm_len += cp->ppm_data - hd;
#line 413
      cp->ppm_data = hd;
#line 414
      return ((int )(c - src));
    }
#line 416
    if (tcp->ppt == 1) {
#line 417
      tcp->ppt_len += tcp->ppt_data - hd;
#line 418
      tcp->ppt_data = hd;
#line 419
      return ((int )(c - src));
    }
#line 422
    return ((int )(hd - src));
  }
#line 425
  bandno = 0;
  {
#line 425
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 425
    if (! (bandno < res->numbands)) {
#line 425
      goto while_break___1;
    }
#line 426
    band___0 = & res->bands[bandno];
#line 427
    prc___0 = band___0->precincts + precno;
#line 429
    if (band___0->x1 - band___0->x0 == 0) {
#line 429
      goto while_continue___1;
    } else
#line 429
    if (band___0->y1 - band___0->y0 == 0) {
#line 429
      goto while_continue___1;
    }
#line 431
    cblkno = 0;
    {
#line 431
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 431
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 431
        goto while_break___2;
      }
#line 433
      cblk___0 = prc___0->cblks.dec + cblkno;
#line 435
      if (! cblk___0->numsegs) {
        {
#line 436
        included = tgt_decode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 439
        included = bio_read(bio, 1);
        }
      }
#line 442
      if (! included) {
#line 443
        cblk___0->numnewpasses = 0;
#line 444
        goto while_continue___2;
      }
#line 447
      if (! cblk___0->numsegs) {
#line 449
        i = 0;
        {
#line 449
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 449
          if (! (! __cil_tmp39)) {
#line 449
            goto while_break___3;
          }

#line 449
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 452
        numimsbs = i - 1;
#line 453
        cblk___0->numbps = band___0->numbps - numimsbs;
#line 454
        cblk___0->numlenbits = 3;
      }
      {
#line 457
      cblk___0->numnewpasses = t2_getnumpasses(bio);
#line 458
      increment = t2_getcommacode(bio);
#line 460
      cblk___0->numlenbits += increment;
#line 461
      segno = 0;
      }
#line 462
      if (! cblk___0->numsegs) {
        {
#line 463
        t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty, 1);
        }
      } else {
#line 465
        segno = cblk___0->numsegs - 1;
#line 466
        if ((cblk___0->segs + segno)->numpasses == (cblk___0->segs + segno)->maxpasses) {
          {
#line 467
          segno ++;
#line 468
          t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty, 0);
          }
        }
      }
#line 471
      n = cblk___0->numnewpasses;
      {
#line 473
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 474
        (cblk___0->segs + segno)->numnewpasses = int_min((cblk___0->segs + segno)->maxpasses - (cblk___0->segs + segno)->numpasses,
                                                         n);
#line 475
        __cil_tmp44 = int_floorlog2((cblk___0->segs + segno)->numnewpasses);
#line 475
        __cil_tmp45 = bio_read(bio, cblk___0->numlenbits + __cil_tmp44);
#line 475
        (cblk___0->segs + segno)->newlen = __cil_tmp45;
#line 476
        n -= (cblk___0->segs + segno)->numnewpasses;
        }
#line 477
        if (n > 0) {
          {
#line 478
          segno ++;
#line 479
          t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty, 0);
          }
        }
#line 473
        if (! (n > 0)) {
#line 473
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 431
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 425
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 485
  __cil_tmp48 = bio_inalign(bio);
  }
#line 485
  if (__cil_tmp48) {
    {
#line 486
    bio_destroy(bio);
    }
#line 487
    return (- 999);
  }
  {
#line 490
  __cil_tmp49 = bio_numbytes(bio);
  }
  {
#line 490
  hd += __cil_tmp49;
#line 491
  bio_destroy(bio);
  }
#line 494
  if (tcp->csty & 4) {
#line 495
    if ((int )*hd != 255) {
      {
      {
#line 496
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
    } else
#line 495
    if ((int )*(hd + 1) != 146) {
      {
      {
#line 496
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
    } else {
#line 498
      hd += 2;
    }
  }
#line 505
  if (pack_info) {
#line 506
    pack_info->end_ph_pos = (int )(hd - src);
  }
#line 510
  if (cp->ppm == 1) {
#line 511
    cp->ppm_len += cp->ppm_data - hd;
#line 512
    cp->ppm_data = hd;
  } else
#line 513
  if (tcp->ppt == 1) {
#line 514
    tcp->ppt_len += tcp->ppt_data - hd;
#line 515
    tcp->ppt_data = hd;
  } else {
#line 517
    c = hd;
  }
#line 520
  bandno = 0;
  {
#line 520
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 520
    if (! (bandno < res->numbands)) {
#line 520
      goto while_break___5;
    }
#line 521
    band___1 = & res->bands[bandno];
#line 522
    prc___1 = band___1->precincts + precno;
#line 524
    if (band___1->x1 - band___1->x0 == 0) {
#line 524
      goto while_continue___5;
    } else
#line 524
    if (band___1->y1 - band___1->y0 == 0) {
#line 524
      goto while_continue___5;
    }
#line 526
    cblkno = 0;
    {
#line 526
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 526
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 526
        goto while_break___6;
      }
#line 527
      cblk___1 = prc___1->cblks.dec + cblkno;
#line 528
      seg = (opj_tcd_seg_t *)((void *)0);
#line 529
      if (! cblk___1->numnewpasses) {
#line 530
        goto while_continue___6;
      }
#line 531
      if (! cblk___1->numsegs) {
#line 532
        seg = cblk___1->segs + 0;
#line 533
        (cblk___1->numsegs) ++;
#line 534
        cblk___1->len = 0;
      } else {
#line 536
        seg = cblk___1->segs + (cblk___1->numsegs - 1);
#line 537
        if (seg->numpasses == seg->maxpasses) {
#line 538
          seg ++;
#line 539
          (cblk___1->numsegs) ++;
        }
      }
      {
#line 543
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 544
        if (c + seg->newlen > src + len) {
#line 545
          return (- 999);
        }
        {
#line 568
        __cil_tmp57 = realloc(cblk___1->data, (unsigned long )(cblk___1->len + seg->newlen) * sizeof(unsigned char *));
#line 568
        cblk___1->data = (unsigned char *)__cil_tmp57;
#line 569
        memcpy(cblk___1->data + cblk___1->len, c, (unsigned long )seg->newlen);
        }
#line 570
        if (seg->numpasses == 0) {
#line 571
          seg->data = & cblk___1->data;
#line 572
          seg->dataindex = cblk___1->len;
        }
#line 574
        c += seg->newlen;
#line 575
        cblk___1->len += seg->newlen;
#line 576
        seg->len += seg->newlen;
#line 577
        seg->numpasses += seg->numnewpasses;
#line 578
        cblk___1->numnewpasses -= seg->numnewpasses;
#line 579
        if (cblk___1->numnewpasses > 0) {
#line 580
          seg ++;
#line 581
          (cblk___1->numsegs) ++;
        }
#line 543
        if (! (cblk___1->numnewpasses > 0)) {
#line 543
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 526
      cblkno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 520
    bandno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 587
  return ((int )(c - src));
}
}
#line 592 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  unsigned char *c ;
  int e ;
  int compno ;
  opj_pi_iterator_t *pi ;
  int poc ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int pocno ;
  int tmp ;
  int maxcomp ;
  int tmp___0 ;
  opj_pi_iterator_t *__cil_tmp25 ;
  int comp_len ;
  int tpnum___2 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___1 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 593
  c = dest;
#line 594
  e = 0;
#line 596
  pi = (opj_pi_iterator_t *)((void *)0);
#line 598
  image = t2->image;
#line 599
  cp = t2->cp;
#line 600
  tcp = cp->tcps + tileno;
#line 601
  if ((unsigned int )cp->cinema == 3U) {
#line 601
    tmp = 2;
  } else {
#line 601
    tmp = 1;
  }
#line 601
  pocno = tmp;
#line 602
  if (cp->max_comp_size > 0) {
#line 602
    tmp___0 = image->numcomps;
  } else {
#line 602
    tmp___0 = 1;
  }
  {
#line 602
  maxcomp = tmp___0;
#line 604
  pi = pi_initialise_encode(image, cp, tileno, t2_mode);
  }
#line 605
  if (! pi) {
#line 607
    return (- 999);
  }
#line 610
  if ((unsigned int )t2_mode == 0U) {
#line 611
    compno = 0;
    {
#line 611
    while (1) {
      while_continue: /* CIL Label */ ;
#line 611
      if (! (compno < maxcomp)) {
#line 611
        goto while_break;
      }
#line 612
      poc = 0;
      {
#line 612
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 612
        if (! (poc < pocno)) {
#line 612
          goto while_break___0;
        }
        {
#line 613
        comp_len = 0;
#line 614
        tpnum___2 = compno;
#line 615
        __cil_tmp28 = pi_create_encode(pi, cp, tileno, poc, tpnum___2, tppos, t2_mode,
                                       cur_totnum_tp);
        }
#line 615
        if (__cil_tmp28) {
          {
#line 616
          opj_event_msg(t2->cinfo, 1, "Error initializing Packet Iterator\n\237\032V");
          }
#line 617
          return (- 999);
        }
        {
#line 619
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 619
          __cil_tmp29 = pi_next(pi + poc);
          }
#line 619
          if (! __cil_tmp29) {
#line 619
            goto while_break___1;
          }
#line 620
          if ((pi + poc)->layno < maxlayers) {
            {
#line 621
            e = t2_encode_packet(tile, cp->tcps + tileno, pi + poc, c, (int )((dest + len) - c),
                                 cstr_info, tileno);
#line 622
            comp_len += e;
            }
#line 623
            if (e == -999) {
#line 624
              goto while_break___1;
            } else {
#line 626
              c += e;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 630
        if (e == -999) {
#line 630
          goto while_break___0;
        }
#line 631
        if (cp->max_comp_size) {
#line 632
          if (comp_len > cp->max_comp_size) {
#line 633
            e = - 999;
#line 634
            goto while_break___0;
          }
        }
#line 612
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 638
      if (e == -999) {
#line 638
        goto while_break;
      }
#line 611
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 641
    pi_create_encode(pi, cp, tileno, pino, tpnum, tppos, t2_mode, cur_totnum_tp);
    }
    {
#line 642
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 642
      __cil_tmp33 = pi_next(pi + pino);
      }
#line 642
      if (! __cil_tmp33) {
#line 642
        goto while_break___2;
      }
#line 643
      if ((pi + pino)->layno < maxlayers) {
        {
#line 644
        e = t2_encode_packet(tile, cp->tcps + tileno, pi + pino, c, (int )((dest + len) - c),
                             cstr_info, tileno);
        }
#line 645
        if (e == -999) {
#line 646
          goto while_break___2;
        } else {
#line 648
          c += e;
        }
#line 651
        if (cstr_info) {
#line 652
          if (cstr_info->index_write) {
#line 653
            info_TL = cstr_info->tile + tileno;
#line 654
            info_PK = info_TL->packet + cstr_info->packno;
#line 655
            if (! cstr_info->packno) {
#line 656
              info_PK->start_pos = info_TL->end_header + 1;
            } else {
#line 658
              if ((int )cp->tp_on | tcp->POC && info_PK->start_pos) {
#line 658
                tmp___1 = info_PK->start_pos;
              } else {
#line 658
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
              }
#line 658
              info_PK->start_pos = tmp___1;
            }
#line 660
            info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 661
            info_PK->end_ph_pos += info_PK->start_pos - 1;
          }
#line 665
          (cstr_info->packno) ++;
        }
#line 668
        (tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 673
  pi_destroy(pi, cp, tileno);
  }
#line 675
  if (e == -999) {
#line 676
    return (e);
  }
#line 679
  return ((int )(c - dest));
}
}
#line 682 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) 
{ 
  unsigned char *c ;
  opj_pi_iterator_t *pi ;
  int pino ;
  int e ;
  int n ;
  int curtp ;
  int tp_start_packno ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_pi_iterator_t *__cil_tmp16 ;
  int __cil_tmp17 ;
  opj_packet_info_t *pack_info ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int __cil_tmp22 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 683
  c = src;
#line 685
  e = 0;
#line 686
  n = 0;
  {
#line 686
  curtp = 0;
#line 689
  image = t2->image;
#line 690
  cp = t2->cp;
#line 693
  pi = pi_create_decode(image, cp, tileno);
  }
#line 694
  if (! pi) {
#line 696
    return (- 999);
  }
#line 699
  tp_start_packno = 0;
#line 701
  pino = 0;
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! (pino <= (cp->tcps + tileno)->numpocs)) {
#line 701
      goto while_break;
    }
    {
#line 702
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 702
      __cil_tmp17 = pi_next(pi + pino);
      }
#line 702
      if (! __cil_tmp17) {
#line 702
        goto while_break___0;
      }
#line 703
      if (cp->layer == 0) {
        _L: /* CIL Label */ 
#line 705
        if (cstr_info) {
#line 706
          pack_info = (cstr_info->tile + tileno)->packet + cstr_info->packno;
        } else {
#line 708
          pack_info = (opj_packet_info_t *)((void *)0);
        }
        {
#line 709
        e = t2_decode_packet(t2, c, (int )((src + len) - c), tile, cp->tcps + tileno,
                             pi + pino, pack_info);
        }
      } else
#line 703
      if (cp->layer >= (pi + pino)->layno + 1) {
#line 703
        goto _L;
      } else {
#line 711
        e = 0;
      }
#line 715
      if (e > 0) {
        {
#line 715
        __cil_tmp20 = int_max((pi + pino)->resno, (image->comps + (pi + pino)->compno)->resno_decoded);
#line 715
        tmp = __cil_tmp20;
        }
      } else {
#line 715
        tmp = (image->comps + (pi + pino)->compno)->resno_decoded;
      }
#line 715
      (image->comps + (pi + pino)->compno)->resno_decoded = tmp;
#line 719
      n ++;
#line 722
      if (cstr_info) {
#line 723
        info_TL = cstr_info->tile + tileno;
#line 724
        info_PK = info_TL->packet + cstr_info->packno;
#line 725
        if (! cstr_info->packno) {
#line 726
          info_PK->start_pos = info_TL->end_header + 1;
        } else
#line 727
        if ((info_TL->packet + (cstr_info->packno - 1))->end_pos >= (int )((cstr_info->tile + tileno)->tp + curtp)->tp_end_pos) {
#line 728
          (info_TL->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 729
          tp_start_packno = cstr_info->packno;
#line 730
          curtp ++;
#line 731
          info_PK->start_pos = ((cstr_info->tile + tileno)->tp + curtp)->tp_end_header + 1;
        } else {
#line 733
          if ((int )cp->tp_on && info_PK->start_pos) {
#line 733
            tmp___0 = info_PK->start_pos;
          } else {
#line 733
            tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
          }
#line 733
          info_PK->start_pos = tmp___0;
        }
#line 735
        info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 736
        info_PK->end_ph_pos += info_PK->start_pos - 1;
#line 738
        (cstr_info->packno) ++;
      }
#line 742
      if (e == -999) {
#line 743
        goto while_break___0;
      } else {
#line 745
        c += e;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 701
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  if (cstr_info) {
#line 751
    ((cstr_info->tile + tileno)->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
  }
  {
#line 756
  pi_destroy(pi, cp, tileno);
  }
#line 758
  if (e == -999) {
#line 759
    return (e);
  }
#line 762
  return ((int )(c - src));
}
}
#line 767 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) 
{ 
  opj_t2_t *t2 ;
  void *__cil_tmp5 ;

  {
  {
#line 769
  __cil_tmp5 = malloc(sizeof(opj_t2_t ));
#line 769
  t2 = (opj_t2_t *)__cil_tmp5;
  }
#line 770
  if (! t2) {
#line 770
    return ((opj_t2_t *)((void *)0));
  }
#line 771
  t2->cinfo = cinfo;
#line 772
  t2->image = image;
#line 773
  t2->cp = cp;
#line 775
  return (t2);
}
}
#line 778 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t2.c"
void t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 779
  if (t2) {
    {
#line 780
    free(t2);
    }
  }
  return;
}
}
#line 3 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static char lut_ctxno_zc[1024]  = 
#line 3 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
  {      (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )3,      (char )3,      (char )6, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )6,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8};
#line 38 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static char lut_ctxno_sc[256]  = 
#line 38
  {      (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13};
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static char lut_spb[256]  = 
#line 57
  {      (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1};
#line 68 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig[128]  = 
#line 68
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )384,      (short )768,      (short )1152, 
        (short )1536,      (short )1920,      (short )2304,      (short )2688, 
        (short )3072,      (short )3456,      (short )3840,      (short )4224, 
        (short )4608,      (short )4992,      (short )5376,      (short )5760, 
        (short )6144,      (short )6528,      (short )6912,      (short )7296, 
        (short )7680,      (short )8064,      (short )8448,      (short )8832, 
        (short )9216,      (short )9600,      (short )9984,      (short )10368, 
        (short )10752,      (short )11136,      (short )11520,      (short )11904, 
        (short )12288,      (short )12672,      (short )13056,      (short )13440, 
        (short )13824,      (short )14208,      (short )14592,      (short )14976, 
        (short )15360,      (short )15744,      (short )16128,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20736,      (short )21120, 
        (short )21504,      (short )21888,      (short )22272,      (short )22656, 
        (short )23040,      (short )23424,      (short )23808,      (short )24192, 
        (short )24576,      (short )24960,      (short )25344,      (short )25728, 
        (short )26112,      (short )26496,      (short )26880,      (short )27264, 
        (short )27648,      (short )28032,      (short )28416,      (short )28800, 
        (short )29184,      (short )29568,      (short )29952,      (short )30336};
#line 87 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig0[128]  = 
#line 87
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936, 
        (short )8192,      (short )8448,      (short )8704,      (short )8960, 
        (short )9216,      (short )9472,      (short )9856,      (short )10112, 
        (short )10368,      (short )10624,      (short )11008,      (short )11264, 
        (short )11520,      (short )11904,      (short )12160,      (short )12544, 
        (short )12800,      (short )13184,      (short )13440,      (short )13824, 
        (short )14080,      (short )14464,      (short )14848,      (short )15104, 
        (short )15488,      (short )15872,      (short )16256,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20864,      (short )21248, 
        (short )21632,      (short )22016,      (short )22528,      (short )22912, 
        (short )23296,      (short )23808,      (short )24192,      (short )24704, 
        (short )25088,      (short )25600,      (short )25984,      (short )26496, 
        (short )26880,      (short )27392,      (short )27904,      (short )28288, 
        (short )28800,      (short )29312,      (short )29824,      (short )30208, 
        (short )30720,      (short )31232,      (short )31744,      (short )32256};
#line 106 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref[128]  = 
#line 106
  {      (short )6144,      (short )6016,      (short )5888,      (short )5760, 
        (short )5632,      (short )5504,      (short )5376,      (short )5248, 
        (short )5120,      (short )4992,      (short )4864,      (short )4736, 
        (short )4608,      (short )4480,      (short )4352,      (short )4224, 
        (short )4096,      (short )3968,      (short )3840,      (short )3712, 
        (short )3584,      (short )3456,      (short )3328,      (short )3200, 
        (short )3072,      (short )2944,      (short )2816,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1280,      (short )1152, 
        (short )1024,      (short )896,      (short )768,      (short )640, 
        (short )512,      (short )384,      (short )256,      (short )128, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )128,      (short )256,      (short )384, 
        (short )512,      (short )640,      (short )768,      (short )896, 
        (short )1024,      (short )1152,      (short )1280,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2816,      (short )2944, 
        (short )3072,      (short )3200,      (short )3328,      (short )3456, 
        (short )3584,      (short )3712,      (short )3840,      (short )3968, 
        (short )4096,      (short )4224,      (short )4352,      (short )4480, 
        (short )4608,      (short )4736,      (short )4864,      (short )4992, 
        (short )5120,      (short )5248,      (short )5376,      (short )5504, 
        (short )5632,      (short )5760,      (short )5888,      (short )6016};
#line 125 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref0[128]  = 
#line 125
  {      (short )8192,      (short )7936,      (short )7680,      (short )7424, 
        (short )7168,      (short )6912,      (short )6784,      (short )6528, 
        (short )6272,      (short )6016,      (short )5888,      (short )5632, 
        (short )5376,      (short )5248,      (short )4992,      (short )4864, 
        (short )4608,      (short )4480,      (short )4224,      (short )4096, 
        (short )3840,      (short )3712,      (short )3584,      (short )3328, 
        (short )3200,      (short )3072,      (short )2944,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1408,      (short )1280, 
        (short )1152,      (short )1024,      (short )1024,      (short )896, 
        (short )768,      (short )768,      (short )640,      (short )640, 
        (short )512,      (short )512,      (short )384,      (short )384, 
        (short )256,      (short )256,      (short )256,      (short )128, 
        (short )128,      (short )128,      (short )128,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936};
#line 42 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) ;
#line 43
static char t1_getctxno_sc(int f ) ;
#line 44
static int t1_getctxno_mag(int f ) ;
#line 45
static char t1_getspb(int f ) ;
#line 46
static short t1_getnmsedec_sig(int x , int bitpos ) ;
#line 47
static short t1_getnmsedec_ref(int x , int bitpos ) ;
#line 48
static void t1_updateflags(flag_t *flagsp , int s , int stride ) ;
#line 52
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) ;
#line 65
static void t1_dec_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf , char type , int vsc ) ;
#line 76
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) ;
#line 86
static void t1_dec_sigpass(opj_t1_t *t1 , int bpno , int orient , char type , int cblksty ) ;
#line 95
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) ;
#line 107
static void t1_dec_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int poshalf ,
                                int neghalf , char type , int vsc ) ;
#line 118
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) ;
#line 127
static void t1_dec_refpass(opj_t1_t *t1 , int bpno , char type , int cblksty ) ;
#line 135
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) ;
#line 148
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf , int partial , int vsc ) ;
#line 159
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) ;
#line 168
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 173
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps ) ;
#line 195
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , opj_tcd_tile_t *tile ) ;
#line 214
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) ;
#line 227 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) 
{ 


  {
#line 228
  return (lut_ctxno_zc[(orient << 8) | (f & 255)]);
}
}
#line 231 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static char t1_getctxno_sc(int f ) 
{ 


  {
#line 232
  return (lut_ctxno_sc[(f & 4080) >> 4]);
}
}
#line 235 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static int t1_getctxno_mag(int f ) 
{ 
  int tmp1 ;
  int tmp ;
  int tmp2 ;
  int tmp___0 ;

  {
#line 236
  if (f & 255) {
#line 236
    tmp = 15;
  } else {
#line 236
    tmp = 14;
  }
#line 236
  tmp1 = tmp;
#line 237
  if (f & 8192) {
#line 237
    tmp___0 = 16;
  } else {
#line 237
    tmp___0 = tmp1;
  }
#line 237
  tmp2 = tmp___0;
#line 238
  return (tmp2);
}
}
#line 241 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static char t1_getspb(int f ) 
{ 


  {
#line 242
  return (lut_spb[(f & 4080) >> 4]);
}
}
#line 245 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static short t1_getnmsedec_sig(int x , int bitpos ) 
{ 


  {
#line 246
  if (bitpos > 6) {
#line 247
    return (lut_nmsedec_sig[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 250
  return (lut_nmsedec_sig0[x & ((1 << 7) - 1)]);
}
}
#line 253 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static short t1_getnmsedec_ref(int x , int bitpos ) 
{ 


  {
#line 254
  if (bitpos > 6) {
#line 255
    return (lut_nmsedec_ref[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 258
  return (lut_nmsedec_ref0[x & ((1 << 7) - 1)]);
}
}
#line 261 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_updateflags(flag_t *flagsp , int s , int stride ) 
{ 
  flag_t *np ;
  flag_t *sp ;
  static flag_t mod[8] ;

  {
#line 262
  np = flagsp - stride;
#line 263
  sp = flagsp + stride;
#line 265
  mod[0] = (flag_t )64;
#line 265
  mod[1] = (flag_t )1088;
#line 265
  mod[2] = (flag_t )32;
#line 265
  mod[3] = (flag_t )544;
#line 265
  mod[4] = (flag_t )128;
#line 265
  mod[5] = (flag_t )2176;
#line 265
  mod[6] = (flag_t )16;
#line 265
  mod[7] = (flag_t )272;
#line 272
  *(np + - 1) |= 2;
#line 273
  *(np + 0) |= (int )mod[s];
#line 274
  *(np + 1) |= 4;
#line 276
  *(flagsp + - 1) |= (int )mod[s + 2];
#line 277
  *(flagsp + 0) |= 4096;
#line 278
  *(flagsp + 1) |= (int )mod[s + 4];
#line 280
  *(sp + - 1) |= 1;
#line 281
  *(sp + 0) |= (int )mod[s + 6];
#line 282
  *(sp + 1) |= 8;
  return;
}
}
#line 285 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int tmp___1 ;
  int __cil_tmp18 ;
  short __cil_tmp19 ;
  char __cil_tmp20 ;
  char __cil_tmp21 ;

  {
#line 298
  mqc = t1->mqc;
#line 300
  if (vsc) {
#line 300
    tmp = (int )*flagsp & -1095;
  } else {
#line 300
    tmp = (int )*flagsp;
  }
#line 300
  flag = tmp;
#line 301
  if (flag & 255) {
#line 301
    if (! (flag & 20480)) {
      {
#line 302
      __cil_tmp14 = int_abs(*datap);
      }
#line 302
      if (__cil_tmp14 & one) {
#line 302
        tmp___0 = 1;
      } else {
#line 302
        tmp___0 = 0;
      }
      {
#line 302
      v = tmp___0;
#line 303
      __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 303
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
      }
#line 304
      if ((int )type == 1) {
        {
#line 305
        mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 307
        mqc_encode(mqc, v);
        }
      }
#line 309
      if (v) {
#line 310
        if (*datap < 0) {
#line 310
          tmp___1 = 1;
        } else {
#line 310
          tmp___1 = 0;
        }
        {
#line 310
        v = tmp___1;
#line 311
        __cil_tmp18 = int_abs(*datap);
#line 311
        __cil_tmp19 = t1_getnmsedec_sig(__cil_tmp18, bpno + 6);
        }
        {
#line 311
        *nmsedec += (int )__cil_tmp19;
#line 312
        __cil_tmp20 = t1_getctxno_sc(flag);
#line 312
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp20];
        }
#line 313
        if ((int )type == 1) {
          {
#line 314
          mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 316
          __cil_tmp21 = t1_getspb(flag);
#line 316
          mqc_encode(mqc, v ^ (int )__cil_tmp21);
          }
        }
        {
#line 318
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 320
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 324 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int __cil_tmp17 ;
  char __cil_tmp18 ;
  int __cil_tmp19 ;
  char __cil_tmp20 ;
  int tmp___1 ;

  {
#line 335
  raw = t1->raw;
#line 336
  mqc = t1->mqc;
#line 338
  if (vsc) {
#line 338
    tmp = (int )*flagsp & -1095;
  } else {
#line 338
    tmp = (int )*flagsp;
  }
#line 338
  flag = tmp;
#line 339
  if (flag & 255) {
#line 339
    if (! (flag & 20480)) {
#line 340
      if ((int )type == 1) {
        {
#line 341
        __cil_tmp13 = raw_decode(raw);
        }
#line 341
        if (__cil_tmp13) {
          {
#line 342
          v = raw_decode(raw);
          }
#line 343
          if (v) {
#line 343
            tmp___0 = - oneplushalf;
          } else {
#line 343
            tmp___0 = oneplushalf;
          }
          {
#line 343
          *datap = tmp___0;
#line 344
          t1_updateflags(flagsp, v, t1->flags_stride);
          }
        }
      } else {
        {
#line 347
        __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 347
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
#line 348
        __cil_tmp17 = mqc_decode(mqc);
        }
#line 348
        if (__cil_tmp17) {
          {
#line 349
          __cil_tmp18 = t1_getctxno_sc(flag);
#line 349
          mqc->curctx = & mqc->ctxs[(int )__cil_tmp18];
#line 350
          __cil_tmp20 = t1_getspb(flag);
          }
          {
#line 350
          __cil_tmp19 = mqc_decode(mqc);
#line 350
          v = __cil_tmp19 ^ (int )__cil_tmp20;
          }
#line 351
          if (v) {
#line 351
            tmp___1 = - oneplushalf;
          } else {
#line 351
            tmp___1 = oneplushalf;
          }
          {
#line 351
          *datap = tmp___1;
#line 352
          t1_updateflags(flagsp, v, t1->flags_stride);
          }
        }
      }
#line 355
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 359 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 368
  *nmsedec = 0;
#line 369
  one = 1 << (bpno + 6);
#line 370
  k = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (k < t1->h)) {
#line 370
      goto while_break;
    }
#line 371
    i = 0;
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (i < t1->w)) {
#line 371
        goto while_break___0;
      }
#line 372
      j = k;
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        if (! (j < k + 4 && j < t1->h)) {
#line 372
          goto while_break___1;
        }
#line 373
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 373
          tmp = 1;
        } else {
#line 373
          tmp = 0;
        }
        {
#line 373
        vsc = tmp;
#line 374
        t1_enc_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            type, vsc);
        }
#line 372
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 371
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 389 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_sigpass(opj_t1_t *t1 , int bpno , int orient , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 397
  one = 1 << bpno;
#line 398
  half = one >> 1;
#line 399
  oneplushalf = one | half;
#line 400
  k = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (k < t1->h)) {
#line 400
      goto while_break;
    }
#line 401
    i = 0;
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i < t1->w)) {
#line 401
        goto while_break___0;
      }
#line 402
      j = k;
      {
#line 402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 402
        if (! (j < k + 4 && j < t1->h)) {
#line 402
          goto while_break___1;
        }
#line 403
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 403
          tmp = 1;
        } else {
#line 403
          tmp = 0;
        }
        {
#line 403
        vsc = tmp;
#line 404
        t1_dec_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, oneplushalf, type,
                            vsc);
        }
#line 402
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 401
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 400
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 417 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  short __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;

  {
#line 429
  mqc = t1->mqc;
#line 431
  if (vsc) {
#line 431
    tmp = (int )*flagsp & -1095;
  } else {
#line 431
    tmp = (int )*flagsp;
  }
#line 431
  flag = tmp;
#line 432
  if ((flag & 20480) == 4096) {
    {
#line 433
    __cil_tmp13 = int_abs(*datap);
#line 433
    __cil_tmp14 = t1_getnmsedec_ref(__cil_tmp13, bpno + 6);
    }
    {
#line 433
    *nmsedec += (int )__cil_tmp14;
#line 434
    __cil_tmp15 = int_abs(*datap);
    }
#line 434
    if (__cil_tmp15 & one) {
#line 434
      tmp___0 = 1;
    } else {
#line 434
      tmp___0 = 0;
    }
    {
#line 434
    v = tmp___0;
#line 435
    __cil_tmp17 = t1_getctxno_mag(flag);
#line 435
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp17];
    }
#line 436
    if ((int )type == 1) {
      {
#line 437
      mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 439
      mqc_encode(mqc, v);
      }
    }
#line 441
    *flagsp |= 8192;
  }
  return;
}
}
#line 445 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int poshalf ,
                                int neghalf , char type , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 456
  mqc = t1->mqc;
#line 457
  raw = t1->raw;
#line 459
  if (vsc) {
#line 459
    tmp = (int )*flagsp & -1095;
  } else {
#line 459
    tmp = (int )*flagsp;
  }
#line 459
  flag = tmp;
#line 460
  if ((flag & 20480) == 4096) {
    {
#line 461
    __cil_tmp14 = t1_getctxno_mag(flag);
#line 461
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
    }
#line 462
    if ((int )type == 1) {
      {
#line 463
      v = raw_decode(raw);
      }
    } else {
      {
#line 465
      v = mqc_decode(mqc);
      }
    }
#line 467
    if (v) {
#line 467
      tmp___0 = poshalf;
    } else {
#line 467
      tmp___0 = neghalf;
    }
#line 467
    t = tmp___0;
#line 468
    if (*datap < 0) {
#line 468
      tmp___1 = - t;
    } else {
#line 468
      tmp___1 = t;
    }
#line 468
    *datap += tmp___1;
#line 469
    *flagsp |= 8192;
  }
  return;
}
}
#line 473 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 481
  *nmsedec = 0;
#line 482
  one = 1 << (bpno + 6);
#line 483
  k = 0;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! (k < t1->h)) {
#line 483
      goto while_break;
    }
#line 484
    i = 0;
    {
#line 484
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 484
      if (! (i < t1->w)) {
#line 484
        goto while_break___0;
      }
#line 485
      j = k;
      {
#line 485
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 485
        if (! (j < k + 4 && j < t1->h)) {
#line 485
          goto while_break___1;
        }
#line 486
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 486
          tmp = 1;
        } else {
#line 486
          tmp = 0;
        }
        {
#line 486
        vsc = tmp;
#line 487
        t1_enc_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                            vsc);
        }
#line 485
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 484
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 483
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 501 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_refpass(opj_t1_t *t1 , int bpno , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 509
  one = 1 << bpno;
#line 510
  poshalf = one >> 1;
#line 511
  if (bpno > 0) {
#line 511
    tmp = - poshalf;
  } else {
#line 511
    tmp = - 1;
  }
#line 511
  neghalf = tmp;
#line 512
  k = 0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! (k < t1->h)) {
#line 512
      goto while_break;
    }
#line 513
    i = 0;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      if (! (i < t1->w)) {
#line 513
        goto while_break___0;
      }
#line 514
      j = k;
      {
#line 514
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 514
        if (! (j < k + 4 && j < t1->h)) {
#line 514
          goto while_break___1;
        }
#line 515
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 515
          tmp___0 = 1;
        } else {
#line 515
          tmp___0 = 0;
        }
        {
#line 515
        vsc = tmp___0;
#line 516
        t1_dec_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), poshalf, neghalf, type, vsc);
        }
#line 514
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 513
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 512
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 529 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  short __cil_tmp18 ;
  char __cil_tmp19 ;
  int tmp___1 ;
  char __cil_tmp21 ;

  {
#line 542
  mqc = t1->mqc;
#line 544
  if (vsc) {
#line 544
    tmp = (int )*flagsp & -1095;
  } else {
#line 544
    tmp = (int )*flagsp;
  }
#line 544
  flag = tmp;
#line 545
  if (partial) {
#line 546
    goto LABEL_PARTIAL;
  }
#line 548
  if (! ((int )*flagsp & 20480)) {
    {
#line 549
    __cil_tmp14 = t1_getctxno_zc(flag, orient);
#line 549
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 550
    __cil_tmp15 = int_abs(*datap);
    }
#line 550
    if (__cil_tmp15 & one) {
#line 550
      tmp___0 = 1;
    } else {
#line 550
      tmp___0 = 0;
    }
    {
#line 550
    v = tmp___0;
#line 551
    mqc_encode(mqc, v);
    }
#line 552
    if (v) {
      LABEL_PARTIAL: 
      {
#line 554
      __cil_tmp17 = int_abs(*datap);
#line 554
      __cil_tmp18 = t1_getnmsedec_sig(__cil_tmp17, bpno + 6);
      }
      {
#line 554
      *nmsedec += (int )__cil_tmp18;
#line 555
      __cil_tmp19 = t1_getctxno_sc(flag);
#line 555
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp19];
      }
#line 556
      if (*datap < 0) {
#line 556
        tmp___1 = 1;
      } else {
#line 556
        tmp___1 = 0;
      }
      {
#line 556
      v = tmp___1;
#line 557
      __cil_tmp21 = t1_getspb(flag);
#line 557
      mqc_encode(mqc, v ^ (int )__cil_tmp21);
#line 558
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 561
  *flagsp &= ~ 16384;
  return;
}
}
#line 564 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf , int partial , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char __cil_tmp16 ;
  int tmp___0 ;

  {
#line 575
  mqc = t1->mqc;
#line 577
  if (vsc) {
#line 577
    tmp = (int )*flagsp & -1095;
  } else {
#line 577
    tmp = (int )*flagsp;
  }
#line 577
  flag = tmp;
#line 578
  if (partial) {
#line 579
    goto LABEL_PARTIAL;
  }
#line 581
  if (! (flag & 20480)) {
    {
#line 582
    __cil_tmp12 = t1_getctxno_zc(flag, orient);
#line 582
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 583
    __cil_tmp13 = mqc_decode(mqc);
    }
#line 583
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 585
      __cil_tmp14 = t1_getctxno_sc(flag);
#line 585
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
      }
      {
#line 586
      __cil_tmp16 = t1_getspb(flag);
      }
      {
#line 586
      __cil_tmp15 = mqc_decode(mqc);
#line 586
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 587
      if (v) {
#line 587
        tmp___0 = - oneplushalf;
      } else {
#line 587
        tmp___0 = oneplushalf;
      }
      {
#line 587
      *datap = tmp___0;
#line 588
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 591
  *flagsp &= ~ 16384;
  return;
}
}
#line 594 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int agg ;
  int runlen ;
  int vsc ;
  opj_mqc_t *mqc ;
  int __cil_tmp14 ;
  int tmp ;

  {
#line 603
  mqc = t1->mqc;
#line 605
  *nmsedec = 0;
#line 606
  one = 1 << (bpno + 6);
#line 607
  k = 0;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! (k < t1->h)) {
#line 607
      goto while_break;
    }
#line 608
    i = 0;
    {
#line 608
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 608
      if (! (i < t1->w)) {
#line 608
        goto while_break___0;
      }
#line 609
      if (k + 3 < t1->h) {
#line 610
        if (cblksty & 8) {
#line 611
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 617
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
        }
      } else {
#line 623
        agg = 0;
      }
#line 625
      if (agg) {
#line 626
        runlen = 0;
        {
#line 626
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 626
          if (! (runlen < 4)) {
#line 626
            goto while_break___1;
          }
          {
#line 627
          __cil_tmp14 = int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 627
          if (__cil_tmp14 & one) {
#line 628
            goto while_break___1;
          }
#line 626
          runlen ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 630
        mqc->curctx = & mqc->ctxs[(int )17];
#line 631
        mqc_encode(mqc, runlen != 4);
        }
#line 632
        if (runlen == 4) {
#line 633
          goto while_continue___0;
        }
        {
#line 635
        mqc->curctx = & mqc->ctxs[(int )18];
#line 636
        mqc_encode(mqc, runlen >> 1);
#line 637
        mqc_encode(mqc, runlen & 1);
        }
      } else {
#line 639
        runlen = 0;
      }
#line 641
      j = k + runlen;
      {
#line 641
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 641
        if (! (j < k + 4 && j < t1->h)) {
#line 641
          goto while_break___2;
        }
#line 642
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 642
          tmp = 1;
        } else {
#line 642
          tmp = 0;
        }
        {
#line 642
        vsc = tmp;
#line 643
        t1_enc_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            agg && j == k + runlen, vsc);
        }
#line 641
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 608
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 607
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 658 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int agg ;
  int runlen ;
  int vsc ;
  int segsym ;
  opj_mqc_t *mqc ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int v ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 665
  segsym = cblksty & 32;
#line 667
  mqc = t1->mqc;
#line 669
  one = 1 << bpno;
#line 670
  half = one >> 1;
#line 671
  oneplushalf = one | half;
#line 672
  k = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (k < t1->h)) {
#line 672
      goto while_break;
    }
#line 673
    i = 0;
    {
#line 673
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 673
      if (! (i < t1->w)) {
#line 673
        goto while_break___0;
      }
#line 674
      if (k + 3 < t1->h) {
#line 675
        if (cblksty & 8) {
#line 676
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 682
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
        }
      } else {
#line 688
        agg = 0;
      }
#line 690
      if (agg) {
        {
#line 691
        mqc->curctx = & mqc->ctxs[(int )17];
#line 692
        __cil_tmp16 = mqc_decode(mqc);
        }
#line 692
        if (! __cil_tmp16) {
#line 693
          goto while_continue___0;
        }
        {
#line 695
        mqc->curctx = & mqc->ctxs[(int )18];
#line 696
        runlen = mqc_decode(mqc);
#line 697
        __cil_tmp18 = mqc_decode(mqc);
#line 697
        runlen = (runlen << 1) | __cil_tmp18;
        }
      } else {
#line 699
        runlen = 0;
      }
#line 701
      j = k + runlen;
      {
#line 701
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 701
        if (! (j < k + 4 && j < t1->h)) {
#line 701
          goto while_break___1;
        }
#line 702
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 702
          tmp = 1;
        } else {
#line 702
          tmp = 0;
        }
        {
#line 702
        vsc = tmp;
#line 703
        t1_dec_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, oneplushalf, agg && j == k + runlen,
                            vsc);
        }
#line 701
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 673
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 672
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  if (segsym) {
    {
#line 715
    v = 0;
#line 716
    mqc->curctx = & mqc->ctxs[(int )18];
#line 717
    v = mqc_decode(mqc);
#line 718
    __cil_tmp22 = mqc_decode(mqc);
#line 718
    v = (v << 1) | __cil_tmp22;
#line 719
    __cil_tmp23 = mqc_decode(mqc);
#line 719
    v = (v << 1) | __cil_tmp23;
#line 720
    __cil_tmp24 = mqc_decode(mqc);
#line 720
    v = (v << 1) | __cil_tmp24;
    }
  }
  return;
}
}
#line 731 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps ) 
{ 
  double w1 ;
  double w2 ;
  double wmsedec ;
  double __cil_tmp12 ;
  double tmp ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double tmp___0 ;
  double __cil_tmp17 ;

  {
#line 742
  if (qmfbid == 1) {
#line 743
    if (numcomps > 1) {
      {
#line 743
      __cil_tmp12 = mct_getnorm(compno);
#line 743
      tmp = __cil_tmp12;
      }
    } else {
#line 743
      tmp = 1.;
    }
    {
#line 743
    w1 = tmp;
#line 744
    w2 = dwt_getnorm(level, orient);
    }
  } else {
#line 746
    if (numcomps > 1) {
      {
#line 746
      __cil_tmp15 = mct_getnorm_real(compno);
#line 746
      tmp___0 = __cil_tmp15;
      }
    } else {
#line 746
      tmp___0 = 1.;
    }
    {
#line 746
    w1 = tmp___0;
#line 747
    w2 = dwt_getnorm_real(level, orient);
    }
  }
#line 749
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 750
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 752
  return (wmsedec);
}
}
#line 755 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static int allocate_buffers(opj_t1_t *t1 , int w , int h ) 
{ 
  int datasize ;
  int flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 760
  datasize = w * h;
#line 763
  if (datasize > t1->datasize) {
    {
#line 764
    free(t1->data);
#line 765
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(int ));
#line 765
    t1->data = (int *)__cil_tmp6;
    }
#line 766
    if (! t1->data) {
#line 767
      return (0);
    }
#line 769
    t1->datasize = datasize;
  }
  {
#line 771
  memset(t1->data, 0, (unsigned long )datasize * sizeof(int ));
#line 773
  t1->flags_stride = w + 2;
#line 774
  flagssize = t1->flags_stride * (h + 2);
  }
#line 776
  if (flagssize > t1->flagssize) {
    {
#line 777
    free(t1->flags);
#line 778
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(flag_t ));
#line 778
    t1->flags = (flag_t *)__cil_tmp7;
    }
#line 779
    if (! t1->flags) {
#line 780
      return (0);
    }
#line 782
    t1->flagssize = flagssize;
  }
  {
#line 784
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(flag_t ));
#line 786
  t1->w = w;
#line 787
  t1->h = h;
  }
#line 789
  return (1);
}
}
#line 793 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , opj_tcd_tile_t *tile ) 
{ 
  double cumwmsedec ;
  opj_mqc_t *mqc ;
  int passno ;
  int bpno ;
  int passtype ;
  int nmsedec ;
  int i ;
  int max ;
  char type ;
  double tempwmsedec ;
  int tmp ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp___0 ;
  opj_tcd_pass_t *pass ;
  int correction ;
  int tmp___1 ;
  double __cil_tmp29 ;
  int __cil_tmp30 ;
  int tmp___2 ;
  int __cil_tmp32 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int tmp___3 ;
  int __cil_tmp38 ;

  {
#line 805
  cumwmsedec = 0.;
#line 807
  mqc = t1->mqc;
#line 810
  nmsedec = 0;
#line 812
  type = (char )0;
#line 815
  max = 0;
#line 816
  i = 0;
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (i < t1->w * t1->h)) {
#line 816
      goto while_break;
    }
    {
#line 817
    __cil_tmp22 = abs(*(t1->data + i));
#line 817
    tmp = __cil_tmp22;
#line 818
    max = int_max(max, tmp);
    }
#line 816
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (max) {
    {
#line 821
    __cil_tmp24 = int_floorlog2(max);
#line 821
    tmp___0 = (__cil_tmp24 + 1) - 6;
    }
  } else {
#line 821
    tmp___0 = 0;
  }
  {
#line 821
  cblk->numbps = tmp___0;
#line 823
  bpno = cblk->numbps - 1;
#line 824
  passtype = 2;
#line 826
  mqc_resetstates(mqc);
#line 827
  mqc_setstate(mqc, 18, 0, 46);
#line 828
  mqc_setstate(mqc, 17, 0, 3);
#line 829
  mqc_setstate(mqc, 0, 0, 4);
#line 830
  mqc_init_enc(mqc, cblk->data);
#line 832
  passno = 0;
  }
  {
#line 832
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 832
    if (! (bpno >= 0)) {
#line 832
      goto while_break___0;
    }
#line 833
    pass = cblk->passes + passno;
#line 834
    correction = 3;
#line 835
    if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 835
      tmp___1 = 1;
    } else {
#line 835
      tmp___1 = 0;
    }
#line 835
    type = (char )tmp___1;
    {
#line 838
    if (passtype == 0) {
#line 838
      goto case_0;
    }
#line 841
    if (passtype == 1) {
#line 841
      goto case_1;
    }
#line 844
    if (passtype == 2) {
#line 844
      goto case_2;
    }
#line 837
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 839
    t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 840
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 842
    t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 843
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 845
    t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 847
    if (cblksty & 32) {
      {
#line 848
      mqc_segmark_enc(mqc);
      }
    }
#line 849
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 853
    tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize,
                                numcomps);
#line 854
    cumwmsedec += tempwmsedec;
#line 855
    tile->distotile += tempwmsedec;
    }
#line 858
    if (cblksty & 4) {
#line 858
      if (! (passtype == 2 && bpno - 1 < 0)) {
#line 859
        if ((int )type == 1) {
          {
#line 860
          mqc_flush(mqc);
#line 861
          correction = 1;
          }
        } else {
          {
#line 864
          mqc_flush(mqc);
#line 865
          correction = 1;
          }
        }
#line 867
        pass->term = 1;
      } else {
#line 858
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 869
    if (bpno < cblk->numbps - 4) {
#line 869
      if (passtype > 0) {
        _L: /* CIL Label */ 
#line 869
        if (cblksty & 1) {
#line 871
          if ((int )type == 1) {
            {
#line 872
            mqc_flush(mqc);
#line 873
            correction = 1;
            }
          } else {
            {
#line 876
            mqc_flush(mqc);
#line 877
            correction = 1;
            }
          }
#line 879
          pass->term = 1;
        } else {
#line 881
          pass->term = 0;
        }
      } else {
#line 869
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 869
    if (bpno == cblk->numbps - 4) {
#line 869
      if (passtype == 2) {
#line 869
        goto _L;
      } else {
#line 881
        pass->term = 0;
      }
    } else {
#line 881
      pass->term = 0;
    }
#line 885
    passtype ++;
#line 885
    if (passtype == 3) {
#line 886
      passtype = 0;
#line 887
      __cil_tmp30 = bpno;
#line 887
      bpno --;
    }
#line 890
    if (pass->term) {
#line 890
      if (bpno > 0) {
#line 891
        if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 891
          tmp___2 = 1;
        } else {
#line 891
          tmp___2 = 0;
        }
#line 891
        type = (char )tmp___2;
#line 892
        if ((int )type == 1) {
          {
#line 893
          mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 895
          mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 898
    pass->distortiondec = cumwmsedec;
#line 899
    __cil_tmp32 = mqc_numbytes(mqc);
#line 899
    pass->rate = __cil_tmp32 + correction;
    }
#line 902
    if (cblksty & 2) {
      {
#line 903
      mqc_reset_enc(mqc);
      }
    }
#line 832
    passno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 907
  if (cblksty & 16) {
    {
#line 908
    mqc_erterm_enc(mqc);
    }
  } else
#line 909
  if (! (cblksty & 1)) {
    {
#line 910
    mqc_flush(mqc);
    }
  }
#line 912
  cblk->totalpasses = passno;
#line 914
  passno = 0;
  {
#line 914
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 914
    if (! (passno < cblk->totalpasses)) {
#line 914
      goto while_break___1;
    }
    {
#line 915
    pass___0 = cblk->passes + passno;
#line 916
    __cil_tmp34 = mqc_numbytes(mqc);
    }
#line 916
    if (pass___0->rate > __cil_tmp34) {
      {
#line 917
      pass___0->rate = mqc_numbytes(mqc);
      }
    }
#line 919
    if (pass___0->rate > 1) {
#line 919
      if ((int )*(cblk->data + (pass___0->rate - 1)) == 255) {
#line 920
        __cil_tmp36 = pass___0->rate;
#line 920
        (pass___0->rate) --;
      }
    }
#line 922
    if (passno == 0) {
#line 922
      tmp___3 = 0;
    } else {
#line 922
      tmp___3 = (cblk->passes + (passno - 1))->rate;
    }
#line 922
    pass___0->len = pass___0->rate - tmp___3;
#line 914
    passno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 926 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int bpno ;
  int passtype ;
  int segno ;
  int passno ;
  char type ;
  int __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 933
  raw = t1->raw;
#line 934
  mqc = t1->mqc;
#line 938
  type = (char )0;
#line 940
  __cil_tmp13 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
  }
#line 940
  if (! __cil_tmp13) {
#line 945
    return;
  }
  {
#line 948
  bpno = (roishift + cblk->numbps) - 1;
#line 949
  passtype = 2;
#line 951
  mqc_resetstates(mqc);
#line 952
  mqc_setstate(mqc, 18, 0, 46);
#line 953
  mqc_setstate(mqc, 17, 0, 3);
#line 954
  mqc_setstate(mqc, 0, 0, 4);
#line 956
  segno = 0;
  }
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (! (segno < cblk->numsegs)) {
#line 956
      goto while_break;
    }
#line 957
    seg = cblk->segs + segno;
#line 960
    if ((bpno <= (cblk->numbps - 1) - 4 && passtype < 2) && cblksty & 1) {
#line 960
      tmp = 1;
    } else {
#line 960
      tmp = 0;
    }
#line 960
    type = (char )tmp;
#line 962
    if (seg->data == (void *)0) {
#line 963
      goto while_continue;
    }
#line 965
    if ((int )type == 1) {
      {
#line 966
      raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 968
      mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
    }
#line 971
    passno = 0;
    {
#line 971
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 971
      if (! (passno < seg->numpasses)) {
#line 971
        goto while_break___0;
      }
      {
#line 973
      if (passtype == 0) {
#line 973
        goto case_0;
      }
#line 976
      if (passtype == 1) {
#line 976
        goto case_1;
      }
#line 979
      if (passtype == 2) {
#line 979
        goto case_2;
      }
#line 972
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 974
      t1_dec_sigpass(t1, bpno + 1, orient, type, cblksty);
      }
#line 975
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 977
      t1_dec_refpass(t1, bpno + 1, type, cblksty);
      }
#line 978
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 980
      t1_dec_clnpass(t1, bpno + 1, orient, cblksty);
      }
#line 981
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 984
      if (cblksty & 2) {
#line 984
        if ((int )type == 0) {
          {
#line 985
          mqc_resetstates(mqc);
#line 986
          mqc_setstate(mqc, 18, 0, 46);
#line 987
          mqc_setstate(mqc, 17, 0, 3);
#line 988
          mqc_setstate(mqc, 0, 0, 4);
          }
        }
      }
#line 990
      passtype ++;
#line 990
      if (passtype == 3) {
#line 991
        passtype = 0;
#line 992
        __cil_tmp16 = bpno;
#line 992
        bpno --;
      }
#line 971
      passno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 956
    segno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1000 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
opj_t1_t *t1_create(opj_common_ptr cinfo ) 
{ 
  opj_t1_t *t1 ;
  void *__cil_tmp3 ;
  opj_mqc_t *__cil_tmp4 ;
  opj_raw_t *__cil_tmp5 ;

  {
  {
#line 1001
  __cil_tmp3 = malloc(sizeof(opj_t1_t ));
#line 1001
  t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1002
  if (! t1) {
#line 1003
    return ((opj_t1_t *)((void *)0));
  }
  {
#line 1005
  t1->cinfo = cinfo;
#line 1007
  t1->mqc = mqc_create();
#line 1008
  t1->raw = raw_create();
#line 1010
  t1->data = (int *)((void *)0);
#line 1011
  t1->flags = (flag_t *)((void *)0);
#line 1012
  t1->datasize = 0;
#line 1013
  t1->flagssize = 0;
  }
#line 1015
  return (t1);
}
}
#line 1018 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
void t1_destroy(opj_t1_t *t1 ) 
{ 


  {
#line 1019
  if (t1) {
    {
#line 1021
    mqc_destroy(t1->mqc);
#line 1022
    raw_destroy(t1->raw);
#line 1023
    free(t1->data);
#line 1024
    free(t1->flags);
#line 1025
    free(t1);
    }
  }
  return;
}
}
#line 1029 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int *datap ;
  int *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int i ;
  int j ;
  int x ;
  int y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  double __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 1036
  tile->distotile = (double )0;
#line 1038
  compno = 0;
  {
#line 1038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1038
    if (! (compno < tile->numcomps)) {
#line 1038
      goto while_break;
    }
#line 1039
    tilec = tile->comps + compno;
#line 1040
    tccp = tcp->tccps + compno;
#line 1041
    tile_w = tilec->x1 - tilec->x0;
#line 1043
    resno = 0;
    {
#line 1043
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1043
      if (! (resno < tilec->numresolutions)) {
#line 1043
        goto while_break___0;
      }
#line 1044
      res = tilec->resolutions + resno;
#line 1046
      bandno = 0;
      {
#line 1046
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1046
        if (! (bandno < res->numbands)) {
#line 1046
          goto while_break___1;
        }
#line 1047
        band = & res->bands[bandno];
#line 1049
        precno = 0;
        {
#line 1049
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1049
          if (! (precno < res->pw * res->ph)) {
#line 1049
            goto while_break___2;
          }
#line 1050
          prc = band->precincts + precno;
#line 1052
          cblkno = 0;
          {
#line 1052
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1052
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1052
              goto while_break___3;
            }
#line 1053
            cblk = prc->cblks.enc + cblkno;
#line 1060
            x = cblk->x0 - band->x0;
#line 1061
            y = cblk->y0 - band->y0;
#line 1062
            if (band->bandno & 1) {
#line 1063
              pres = tilec->resolutions + (resno - 1);
#line 1064
              x += pres->x1 - pres->x0;
            }
#line 1066
            if (band->bandno & 2) {
#line 1067
              pres___0 = tilec->resolutions + (resno - 1);
#line 1068
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1071
            __cil_tmp26 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
            }
#line 1071
            if (! __cil_tmp26) {
#line 1076
              return;
            }
#line 1079
            datap = t1->data;
#line 1080
            cblk_w = t1->w;
#line 1081
            cblk_h = t1->h;
#line 1083
            tiledp = tilec->data + (y * tile_w + x);
#line 1084
            if (tccp->qmfbid == 1) {
#line 1085
              j = 0;
              {
#line 1085
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1085
                if (! (j < cblk_h)) {
#line 1085
                  goto while_break___4;
                }
#line 1086
                i = 0;
                {
#line 1086
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1086
                  if (! (i < cblk_w)) {
#line 1086
                    goto while_break___5;
                  }
#line 1087
                  tmp = *(tiledp + (j * tile_w + i));
#line 1088
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1086
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1085
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1092
              j = 0;
              {
#line 1092
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1092
                if (! (j < cblk_h)) {
#line 1092
                  goto while_break___6;
                }
#line 1093
                i = 0;
                {
#line 1093
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1093
                  if (! (i < cblk_w)) {
#line 1093
                    goto while_break___7;
                  }
                  {
#line 1094
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1095
                  __cil_tmp29 = floor((double )(band->stepsize * (float )8192));
#line 1095
                  __cil_tmp30 = fix_mul(tmp___0, 67108864 / (int )__cil_tmp29);
#line 1095
                  *(datap + (j * cblk_w + i)) = __cil_tmp30 >> 5;
                  }
#line 1093
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1092
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
            {
#line 1103
            t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1) - resno,
                           tccp->qmfbid, (double )band->stepsize, tccp->cblksty, tile->numcomps,
                           tile);
            }
#line 1052
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1049
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1046
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1043
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1038
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/t1.c"
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  int *datap ;
  void *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int x ;
  int y ;
  int i ;
  int j ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int thresh ;
  int val ;
  int mag ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  float tmp___1 ;

  {
#line 1129
  tile_w = tilec->x1 - tilec->x0;
#line 1131
  resno = 0;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! (resno < tilec->numresolutions)) {
#line 1131
      goto while_break;
    }
#line 1132
    res = tilec->resolutions + resno;
#line 1134
    bandno = 0;
    {
#line 1134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1134
      if (! (bandno < res->numbands)) {
#line 1134
        goto while_break___0;
      }
#line 1135
      band = & res->bands[bandno];
#line 1137
      precno = 0;
      {
#line 1137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1137
        if (! (precno < res->pw * res->ph)) {
#line 1137
          goto while_break___1;
        }
#line 1138
        precinct = band->precincts + precno;
#line 1140
        cblkno = 0;
        {
#line 1140
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1140
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1140
            goto while_break___2;
          }
          {
#line 1141
          cblk = precinct->cblks.dec + cblkno;
#line 1148
          t1_decode_cblk(t1, cblk, band->bandno, tccp->roishift, tccp->cblksty);
#line 1155
          x = cblk->x0 - band->x0;
#line 1156
          y = cblk->y0 - band->y0;
          }
#line 1157
          if (band->bandno & 1) {
#line 1158
            pres = tilec->resolutions + (resno - 1);
#line 1159
            x += pres->x1 - pres->x0;
          }
#line 1161
          if (band->bandno & 2) {
#line 1162
            pres___0 = tilec->resolutions + (resno - 1);
#line 1163
            y += pres___0->y1 - pres___0->y0;
          }
#line 1166
          datap = t1->data;
#line 1167
          cblk_w = t1->w;
#line 1168
          cblk_h = t1->h;
#line 1170
          if (tccp->roishift) {
#line 1171
            thresh = 1 << tccp->roishift;
#line 1172
            j = 0;
            {
#line 1172
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1172
              if (! (j < cblk_h)) {
#line 1172
                goto while_break___3;
              }
#line 1173
              i = 0;
              {
#line 1173
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1173
                if (! (i < cblk_w)) {
#line 1173
                  goto while_break___4;
                }
                {
#line 1174
                val = *(datap + (j * cblk_w + i));
#line 1175
                __cil_tmp26 = abs(val);
#line 1175
                mag = __cil_tmp26;
                }
#line 1176
                if (mag >= thresh) {
#line 1177
                  mag >>= tccp->roishift;
#line 1178
                  if (val < 0) {
#line 1178
                    tmp = - mag;
                  } else {
#line 1178
                    tmp = mag;
                  }
#line 1178
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1173
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1172
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1184
          tiledp = (void *)(tilec->data + (y * tile_w + x));
#line 1185
          if (tccp->qmfbid == 1) {
#line 1186
            j = 0;
            {
#line 1186
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1186
              if (! (j < cblk_h)) {
#line 1186
                goto while_break___5;
              }
#line 1187
              i = 0;
              {
#line 1187
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1187
                if (! (i < cblk_w)) {
#line 1187
                  goto while_break___6;
                }
#line 1188
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1189
                *((int *)tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1187
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1186
              j ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 1193
            j = 0;
            {
#line 1193
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1193
              if (! (j < cblk_h)) {
#line 1193
                goto while_break___7;
              }
#line 1194
              i = 0;
              {
#line 1194
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1194
                if (! (i < cblk_w)) {
#line 1194
                  goto while_break___8;
                }
#line 1195
                tmp___1 = (float )*(datap + (j * cblk_w + i)) * band->stepsize;
#line 1196
                *((float *)tiledp + (j * tile_w + i)) = tmp___1;
#line 1194
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1193
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 1200
          free(cblk->data);
#line 1201
          free(cblk->segs);
          }
#line 1140
          cblkno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1203
        free(precinct->cblks.dec);
        }
#line 1137
        precno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1134
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1131
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.c"
opj_raw_t *raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.c"
void raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free(raw);
    }
  }
  return;
}
}
#line 56 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.c"
int raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((int )(raw->bp - raw->start));
}
}
#line 60 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.c"
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = (unsigned int )len;
#line 63
  raw->len = (unsigned int )0;
#line 64
  raw->c = (unsigned char )0;
#line 65
  raw->ct = (unsigned int )0;
  return;
}
}
#line 68 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/raw.c"
int raw_decode(opj_raw_t *raw ) 
{ 
  int d ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = (unsigned int )8;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (unsigned char )255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = (unsigned int )7;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = ((int )raw->c >> raw->ct) & 1;
#line 85
  return (d);
}
}
#line 46 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
static int pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
static int pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
static int pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
static int pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 82 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___0 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 83
  comp = (opj_pi_comp_t *)((void *)0);
#line 84
  res = (opj_pi_resolution_t *)((void *)0);
#line 85
  index___0 = (long )0;
#line 87
  if (! pi->first) {
#line 88
    comp = pi->comps + pi->compno;
#line 89
    res = comp->resolutions + pi->resno;
#line 90
    goto LABEL_SKIP;
  } else {
#line 92
    pi->first = 0;
  }
#line 95
  pi->layno = pi->poc.layno0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (pi->layno < pi->poc.layno1)) {
#line 95
      goto while_break;
    }
#line 96
    pi->resno = pi->poc.resno0;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (pi->resno < pi->poc.resno1)) {
#line 96
        goto while_break___0;
      }
#line 98
      pi->compno = pi->poc.compno0;
      {
#line 98
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 98
        if (! (pi->compno < pi->poc.compno1)) {
#line 98
          goto while_break___1;
        }
#line 99
        comp = pi->comps + pi->compno;
#line 100
        if (pi->resno >= comp->numresolutions) {
#line 101
          goto while_continue___1;
        }
#line 103
        res = comp->resolutions + pi->resno;
#line 104
        if (! pi->tp_on) {
#line 105
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 107
        pi->precno = pi->poc.precno0;
        {
#line 107
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if (! (pi->precno < pi->poc.precno1)) {
#line 107
            goto while_break___2;
          }
#line 108
          index___0 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 109
          if (! *(pi->include + index___0)) {
#line 110
            *(pi->include + index___0) = (short )1;
#line 111
            return (1);
          }
          LABEL_SKIP: ;
#line 107
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 98
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 97
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___0 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 123
  comp = (opj_pi_comp_t *)((void *)0);
#line 124
  res = (opj_pi_resolution_t *)((void *)0);
#line 125
  index___0 = (long )0;
#line 127
  if (! pi->first) {
#line 128
    comp = pi->comps + pi->compno;
#line 129
    res = comp->resolutions + pi->resno;
#line 130
    goto LABEL_SKIP;
  } else {
#line 132
    pi->first = 0;
  }
#line 135
  pi->resno = pi->poc.resno0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (pi->resno < pi->poc.resno1)) {
#line 135
      goto while_break;
    }
#line 136
    pi->layno = pi->poc.layno0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (pi->layno < pi->poc.layno1)) {
#line 136
        goto while_break___0;
      }
#line 137
      pi->compno = pi->poc.compno0;
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (! (pi->compno < pi->poc.compno1)) {
#line 137
          goto while_break___1;
        }
#line 138
        comp = pi->comps + pi->compno;
#line 139
        if (pi->resno >= comp->numresolutions) {
#line 140
          goto while_continue___1;
        }
#line 142
        res = comp->resolutions + pi->resno;
#line 143
        if (! pi->tp_on) {
#line 144
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 146
        pi->precno = pi->poc.precno0;
        {
#line 146
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 146
          if (! (pi->precno < pi->poc.precno1)) {
#line 146
            goto while_break___2;
          }
#line 147
          index___0 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 148
          if (! *(pi->include + index___0)) {
#line 149
            *(pi->include + index___0) = (short )1;
#line 150
            return (1);
          }
          LABEL_SKIP: ;
#line 146
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 137
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 136
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___0 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 162
  comp = (opj_pi_comp_t *)((void *)0);
#line 163
  res = (opj_pi_resolution_t *)((void *)0);
#line 164
  index___0 = (long )0;
#line 166
  if (! pi->first) {
#line 167
    goto LABEL_SKIP;
  } else {
#line 170
    pi->first = 0;
#line 171
    pi->dx = 0;
#line 172
    pi->dy = 0;
#line 173
    compno = 0;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (compno < pi->numcomps)) {
#line 173
        goto while_break;
      }
#line 174
      comp = pi->comps + compno;
#line 175
      resno = 0;
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (resno < comp->numresolutions)) {
#line 175
          goto while_break___0;
        }
#line 177
        res = comp->resolutions + resno;
#line 178
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 179
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 180
        if (! pi->dx) {
#line 180
          tmp = dx;
        } else {
          {
#line 180
          __cil_tmp9 = int_min(pi->dx, dx);
#line 180
          tmp = __cil_tmp9;
          }
        }
#line 180
        pi->dx = tmp;
#line 181
        if (! pi->dy) {
#line 181
          tmp___0 = dy;
        } else {
          {
#line 181
          __cil_tmp11 = int_min(pi->dy, dy);
#line 181
          tmp___0 = __cil_tmp11;
          }
        }
#line 181
        pi->dy = tmp___0;
#line 175
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 173
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 185
  if (! pi->tp_on) {
#line 186
    pi->poc.ty0 = pi->ty0;
#line 187
    pi->poc.tx0 = pi->tx0;
#line 188
    pi->poc.ty1 = pi->ty1;
#line 189
    pi->poc.tx1 = pi->tx1;
  }
#line 191
  pi->resno = pi->poc.resno0;
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 191
    if (! (pi->resno < pi->poc.resno1)) {
#line 191
      goto while_break___1;
    }
#line 192
    pi->y = pi->poc.ty0;
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      if (! (pi->y < pi->poc.ty1)) {
#line 192
        goto while_break___2;
      }
#line 193
      pi->x = pi->poc.tx0;
      {
#line 193
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 193
        if (! (pi->x < pi->poc.tx1)) {
#line 193
          goto while_break___3;
        }
#line 194
        pi->compno = pi->poc.compno0;
        {
#line 194
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 194
          if (! (pi->compno < pi->poc.compno1)) {
#line 194
            goto while_break___4;
          }
#line 200
          comp = pi->comps + pi->compno;
#line 201
          if (pi->resno >= comp->numresolutions) {
#line 202
            goto while_continue___4;
          }
          {
#line 204
          res = comp->resolutions + pi->resno;
#line 205
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 206
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 207
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 208
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 209
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 210
          rpx = res->pdx + levelno;
#line 211
          rpy = res->pdy + levelno;
          }
#line 212
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
#line 213
            goto while_continue___4;
          }
#line 215
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 216
            goto while_continue___4;
          }
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          } else
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          }
#line 221
          if (trx0 == trx1) {
#line 221
            goto while_continue___4;
          } else
#line 221
          if (try0 == try1) {
#line 221
            goto while_continue___4;
          }
          {
#line 223
          __cil_tmp30 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 223
          __cil_tmp28 = int_ceildiv(pi->x, comp->dx << levelno);
#line 223
          __cil_tmp29 = int_floordivpow2(__cil_tmp28, res->pdx);
#line 223
          prci = __cil_tmp29 - __cil_tmp30;
#line 225
          __cil_tmp33 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 225
          __cil_tmp31 = int_ceildiv(pi->y, comp->dy << levelno);
#line 225
          __cil_tmp32 = int_floordivpow2(__cil_tmp31, res->pdy);
#line 225
          prcj = __cil_tmp32 - __cil_tmp33;
#line 227
          pi->precno = prci + prcj * res->pw;
#line 228
          pi->layno = pi->poc.layno0;
          }
          {
#line 228
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 228
            if (! (pi->layno < pi->poc.layno1)) {
#line 228
              goto while_break___5;
            }
#line 229
            index___0 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 230
            if (! *(pi->include + index___0)) {
#line 231
              *(pi->include + index___0) = (short )1;
#line 232
              return (1);
            }
            LABEL_SKIP: ;
#line 228
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 194
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 193
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 192
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 191
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  return (0);
}
}
#line 244 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___0 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 245
  comp = (opj_pi_comp_t *)((void *)0);
#line 246
  res = (opj_pi_resolution_t *)((void *)0);
#line 247
  index___0 = (long )0;
#line 249
  if (! pi->first) {
#line 250
    comp = pi->comps + pi->compno;
#line 251
    goto LABEL_SKIP;
  } else {
#line 254
    pi->first = 0;
#line 255
    pi->dx = 0;
#line 256
    pi->dy = 0;
#line 257
    compno = 0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! (compno < pi->numcomps)) {
#line 257
        goto while_break;
      }
#line 258
      comp = pi->comps + compno;
#line 259
      resno = 0;
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (! (resno < comp->numresolutions)) {
#line 259
          goto while_break___0;
        }
#line 261
        res = comp->resolutions + resno;
#line 262
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 263
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 264
        if (! pi->dx) {
#line 264
          tmp = dx;
        } else {
          {
#line 264
          __cil_tmp9 = int_min(pi->dx, dx);
#line 264
          tmp = __cil_tmp9;
          }
        }
#line 264
        pi->dx = tmp;
#line 265
        if (! pi->dy) {
#line 265
          tmp___0 = dy;
        } else {
          {
#line 265
          __cil_tmp11 = int_min(pi->dy, dy);
#line 265
          tmp___0 = __cil_tmp11;
          }
        }
#line 265
        pi->dy = tmp___0;
#line 259
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 257
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 269
  if (! pi->tp_on) {
#line 270
    pi->poc.ty0 = pi->ty0;
#line 271
    pi->poc.tx0 = pi->tx0;
#line 272
    pi->poc.ty1 = pi->ty1;
#line 273
    pi->poc.tx1 = pi->tx1;
  }
#line 275
  pi->y = pi->poc.ty0;
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 275
    if (! (pi->y < pi->poc.ty1)) {
#line 275
      goto while_break___1;
    }
#line 276
    pi->x = pi->poc.tx0;
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (pi->x < pi->poc.tx1)) {
#line 276
        goto while_break___2;
      }
#line 277
      pi->compno = pi->poc.compno0;
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (pi->compno < pi->poc.compno1)) {
#line 277
          goto while_break___3;
        }
#line 278
        comp = pi->comps + pi->compno;
#line 279
        pi->resno = pi->poc.resno0;
        {
#line 279
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 279
          if (! (pi->resno < __cil_tmp15)) {
#line 279
            goto while_break___4;
          }
          {
#line 285
          res = comp->resolutions + pi->resno;
#line 286
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 287
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 288
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 289
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 290
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 291
          rpx = res->pdx + levelno;
#line 292
          rpy = res->pdy + levelno;
          }
#line 293
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
#line 294
            goto while_continue___4;
          }
#line 296
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 297
            goto while_continue___4;
          }
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          } else
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          }
#line 302
          if (trx0 == trx1) {
#line 302
            goto while_continue___4;
          } else
#line 302
          if (try0 == try1) {
#line 302
            goto while_continue___4;
          }
          {
#line 304
          __cil_tmp31 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 304
          __cil_tmp29 = int_ceildiv(pi->x, comp->dx << levelno);
#line 304
          __cil_tmp30 = int_floordivpow2(__cil_tmp29, res->pdx);
#line 304
          prci = __cil_tmp30 - __cil_tmp31;
#line 306
          __cil_tmp34 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 306
          __cil_tmp32 = int_ceildiv(pi->y, comp->dy << levelno);
#line 306
          __cil_tmp33 = int_floordivpow2(__cil_tmp32, res->pdy);
#line 306
          prcj = __cil_tmp33 - __cil_tmp34;
#line 308
          pi->precno = prci + prcj * res->pw;
#line 309
          pi->layno = pi->poc.layno0;
          }
          {
#line 309
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 309
            if (! (pi->layno < pi->poc.layno1)) {
#line 309
              goto while_break___5;
            }
#line 310
            index___0 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 311
            if (! *(pi->include + index___0)) {
#line 312
              *(pi->include + index___0) = (short )1;
#line 313
              return (1);
            }
            LABEL_SKIP: ;
#line 309
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 279
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 277
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 276
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (0);
}
}
#line 325 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
static int pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___0 ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 326
  comp = (opj_pi_comp_t *)((void *)0);
#line 327
  res = (opj_pi_resolution_t *)((void *)0);
#line 328
  index___0 = (long )0;
#line 330
  if (! pi->first) {
#line 331
    comp = pi->comps + pi->compno;
#line 332
    goto LABEL_SKIP;
  } else {
#line 334
    pi->first = 0;
  }
#line 337
  pi->compno = pi->poc.compno0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (pi->compno < pi->poc.compno1)) {
#line 337
      goto while_break;
    }
#line 339
    comp = pi->comps + pi->compno;
#line 340
    pi->dx = 0;
#line 341
    pi->dy = 0;
#line 342
    resno = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (resno < comp->numresolutions)) {
#line 342
        goto while_break___0;
      }
#line 344
      res = comp->resolutions + resno;
#line 345
      dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 346
      dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 347
      if (! pi->dx) {
#line 347
        tmp = dx;
      } else {
        {
#line 347
        __cil_tmp8 = int_min(pi->dx, dx);
#line 347
        tmp = __cil_tmp8;
        }
      }
#line 347
      pi->dx = tmp;
#line 348
      if (! pi->dy) {
#line 348
        tmp___0 = dy;
      } else {
        {
#line 348
        __cil_tmp10 = int_min(pi->dy, dy);
#line 348
        tmp___0 = __cil_tmp10;
        }
      }
#line 348
      pi->dy = tmp___0;
#line 342
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    if (! pi->tp_on) {
#line 351
      pi->poc.ty0 = pi->ty0;
#line 352
      pi->poc.tx0 = pi->tx0;
#line 353
      pi->poc.ty1 = pi->ty1;
#line 354
      pi->poc.tx1 = pi->tx1;
    }
#line 356
    pi->y = pi->poc.ty0;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! (pi->y < pi->poc.ty1)) {
#line 356
        goto while_break___1;
      }
#line 357
      pi->x = pi->poc.tx0;
      {
#line 357
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 357
        if (! (pi->x < pi->poc.tx1)) {
#line 357
          goto while_break___2;
        }
#line 358
        pi->resno = pi->poc.resno0;
        {
#line 358
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 358
          if (! (pi->resno < __cil_tmp13)) {
#line 358
            goto while_break___3;
          }
          {
#line 364
          res = comp->resolutions + pi->resno;
#line 365
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 366
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 367
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 368
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 369
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 370
          rpx = res->pdx + levelno;
#line 371
          rpy = res->pdy + levelno;
          }
#line 372
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
#line 373
            goto while_continue___3;
          }
#line 375
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 376
            goto while_continue___3;
          }
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          } else
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          }
#line 381
          if (trx0 == trx1) {
#line 381
            goto while_continue___3;
          } else
#line 381
          if (try0 == try1) {
#line 381
            goto while_continue___3;
          }
          {
#line 383
          __cil_tmp29 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 383
          __cil_tmp27 = int_ceildiv(pi->x, comp->dx << levelno);
#line 383
          __cil_tmp28 = int_floordivpow2(__cil_tmp27, res->pdx);
#line 383
          prci = __cil_tmp28 - __cil_tmp29;
#line 385
          __cil_tmp32 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 385
          __cil_tmp30 = int_ceildiv(pi->y, comp->dy << levelno);
#line 385
          __cil_tmp31 = int_floordivpow2(__cil_tmp30, res->pdy);
#line 385
          prcj = __cil_tmp31 - __cil_tmp32;
#line 387
          pi->precno = prci + prcj * res->pw;
#line 388
          pi->layno = pi->poc.layno0;
          }
          {
#line 388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 388
            if (! (pi->layno < pi->poc.layno1)) {
#line 388
              goto while_break___4;
            }
#line 389
            index___0 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 390
            if (! *(pi->include + index___0)) {
#line 391
              *(pi->include + index___0) = (short )1;
#line 392
              return (1);
            }
            LABEL_SKIP: ;
#line 388
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 358
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 357
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 356
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 410 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) 
{ 
  int p ;
  int q ;
  int compno ;
  int resno ;
  int pino ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp12 ;
  int maxres ;
  int maxprec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void *__cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 413
  pi = (opj_pi_iterator_t *)((void *)0);
#line 414
  tcp = (opj_tcp_t *)((void *)0);
#line 415
  tccp = (opj_tccp_t *)((void *)0);
#line 417
  tcp = cp->tcps + tileno;
#line 419
  __cil_tmp12 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 419
  pi = (opj_pi_iterator_t *)__cil_tmp12;
  }
#line 420
  if (! pi) {
#line 422
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 425
  pino = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (pino < tcp->numpocs + 1)) {
#line 425
      goto while_break;
    }
    {
#line 426
    maxres = 0;
#line 427
    maxprec = 0;
#line 428
    p = tileno % cp->tw;
#line 429
    q = tileno / cp->tw;
#line 431
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 432
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 433
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 434
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 435
    (pi + pino)->numcomps = image->numcomps;
#line 437
    __cil_tmp19 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 437
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp19;
    }
#line 438
    if (! (pi + pino)->comps) {
      {
#line 440
      pi_destroy(pi, cp, tileno);
      }
#line 441
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 444
    compno = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (compno < pi->numcomps)) {
#line 444
        goto while_break___0;
      }
      {
#line 446
      comp = (pi + pino)->comps + compno;
#line 447
      tccp = tcp->tccps + compno;
#line 448
      comp->dx = (image->comps + compno)->dx;
#line 449
      comp->dy = (image->comps + compno)->dy;
#line 450
      comp->numresolutions = tccp->numresolutions;
#line 452
      __cil_tmp25 = calloc((unsigned long )comp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 452
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp25;
      }
#line 453
      if (! comp->resolutions) {
        {
#line 455
        pi_destroy(pi, cp, tileno);
        }
#line 456
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 459
      tcx0 = int_ceildiv(pi->tx0, comp->dx);
#line 460
      tcy0 = int_ceildiv(pi->ty0, comp->dy);
#line 461
      tcx1 = int_ceildiv(pi->tx1, comp->dx);
#line 462
      tcy1 = int_ceildiv(pi->ty1, comp->dy);
      }
#line 463
      if (comp->numresolutions > maxres) {
#line 464
        maxres = comp->numresolutions;
      }
#line 467
      resno = 0;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (! (resno < comp->numresolutions)) {
#line 467
          goto while_break___1;
        }
#line 471
        res = comp->resolutions + resno;
#line 472
        if (tccp->csty & 1) {
#line 473
          res->pdx = tccp->prcw[resno];
#line 474
          res->pdy = tccp->prch[resno];
        } else {
#line 476
          res->pdx = 15;
#line 477
          res->pdy = 15;
        }
        {
#line 479
        levelno = (comp->numresolutions - 1) - resno;
#line 480
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 481
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 482
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 483
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 484
        __cil_tmp44 = int_floordivpow2(rx0, res->pdx);
#line 484
        px0 = __cil_tmp44 << res->pdx;
#line 485
        __cil_tmp45 = int_floordivpow2(ry0, res->pdy);
#line 485
        py0 = __cil_tmp45 << res->pdy;
#line 486
        __cil_tmp46 = int_ceildivpow2(rx1, res->pdx);
#line 486
        px1 = __cil_tmp46 << res->pdx;
#line 487
        __cil_tmp47 = int_ceildivpow2(ry1, res->pdy);
#line 487
        py1 = __cil_tmp47 << res->pdy;
        }
#line 488
        if (rx0 == rx1) {
#line 488
          tmp = 0;
        } else {
#line 488
          tmp = (px1 - px0) >> res->pdx;
        }
#line 488
        res->pw = tmp;
#line 489
        if (ry0 == ry1) {
#line 489
          tmp___0 = 0;
        } else {
#line 489
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 489
        res->ph = tmp___0;
#line 491
        if (res->pw * res->ph > maxprec) {
#line 492
          maxprec = res->pw * res->ph;
        }
#line 467
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 444
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    tccp = tcp->tccps + 0;
#line 499
    (pi + pino)->step_p = 1;
#line 500
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 501
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 502
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 504
    if (pino == 0) {
      {
#line 505
      __cil_tmp52 = calloc((unsigned long )(((image->numcomps * maxres) * tcp->numlayers) * maxprec),
                           sizeof(short ));
#line 505
      (pi + pino)->include = (short *)__cil_tmp52;
      }
#line 506
      if (! (pi + pino)->include) {
        {
#line 508
        pi_destroy(pi, cp, tileno);
        }
#line 509
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 513
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 516
    if (tcp->POC == 0) {
#line 517
      (pi + pino)->first = 1;
#line 518
      (pi + pino)->poc.resno0 = 0;
#line 519
      (pi + pino)->poc.compno0 = 0;
#line 520
      (pi + pino)->poc.layno1 = tcp->numlayers;
#line 521
      (pi + pino)->poc.resno1 = maxres;
#line 522
      (pi + pino)->poc.compno1 = image->numcomps;
#line 523
      (pi + pino)->poc.prg = tcp->prg;
    } else {
#line 525
      (pi + pino)->first = 1;
#line 526
      (pi + pino)->poc.resno0 = tcp->pocs[pino].resno0;
#line 527
      (pi + pino)->poc.compno0 = tcp->pocs[pino].compno0;
#line 528
      (pi + pino)->poc.layno1 = tcp->pocs[pino].layno1;
#line 529
      (pi + pino)->poc.resno1 = tcp->pocs[pino].resno1;
#line 530
      (pi + pino)->poc.compno1 = tcp->pocs[pino].compno1;
#line 531
      (pi + pino)->poc.prg = tcp->pocs[pino].prg;
    }
#line 533
    (pi + pino)->poc.layno0 = 0;
#line 534
    (pi + pino)->poc.precno0 = 0;
#line 535
    (pi + pino)->poc.precno1 = maxprec;
#line 425
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (pi);
}
}
#line 543 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) 
{ 
  int p ;
  int q ;
  int pino ;
  int compno ;
  int resno ;
  int maxres ;
  int maxprec ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_pi_comp_t *comp___0 ;
  int dx ;
  int dy ;
  opj_pi_resolution_t *res___0 ;
  int __cil_tmp57 ;
  int tmp___1 ;
  int __cil_tmp59 ;
  int tmp___2 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  void *__cil_tmp63 ;
  int tmp___3 ;
  int __cil_tmp65 ;

  {
  {
#line 546
  maxres = 0;
#line 547
  maxprec = 0;
#line 548
  pi = (opj_pi_iterator_t *)((void *)0);
#line 549
  tcp = (opj_tcp_t *)((void *)0);
#line 550
  tccp = (opj_tccp_t *)((void *)0);
#line 552
  tcp = cp->tcps + tileno;
#line 554
  __cil_tmp15 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 554
  pi = (opj_pi_iterator_t *)__cil_tmp15;
  }
#line 555
  if (! pi) {
#line 555
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 556
  pi->tp_on = cp->tp_on;
#line 558
  pino = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (pino < tcp->numpocs + 1)) {
#line 558
      goto while_break;
    }
    {
#line 559
    p = tileno % cp->tw;
#line 560
    q = tileno / cp->tw;
#line 562
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 563
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 564
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 565
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 566
    (pi + pino)->numcomps = image->numcomps;
#line 568
    __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 568
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp20;
    }
#line 569
    if (! (pi + pino)->comps) {
      {
#line 570
      pi_destroy(pi, cp, tileno);
      }
#line 571
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 574
    compno = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (compno < (pi + pino)->numcomps)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      comp = (pi + pino)->comps + compno;
#line 577
      tccp = tcp->tccps + compno;
#line 578
      comp->dx = (image->comps + compno)->dx;
#line 579
      comp->dy = (image->comps + compno)->dy;
#line 580
      comp->numresolutions = tccp->numresolutions;
#line 582
      __cil_tmp26 = malloc((unsigned long )comp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 582
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp26;
      }
#line 583
      if (! comp->resolutions) {
        {
#line 584
        pi_destroy(pi, cp, tileno);
        }
#line 585
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 588
      tcx0 = int_ceildiv((pi + pino)->tx0, comp->dx);
#line 589
      tcy0 = int_ceildiv((pi + pino)->ty0, comp->dy);
#line 590
      tcx1 = int_ceildiv((pi + pino)->tx1, comp->dx);
#line 591
      tcy1 = int_ceildiv((pi + pino)->ty1, comp->dy);
      }
#line 592
      if (comp->numresolutions > maxres) {
#line 593
        maxres = comp->numresolutions;
      }
#line 596
      resno = 0;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 596
        if (! (resno < comp->numresolutions)) {
#line 596
          goto while_break___1;
        }
#line 600
        res = comp->resolutions + resno;
#line 601
        if (tccp->csty & 1) {
#line 602
          res->pdx = tccp->prcw[resno];
#line 603
          res->pdy = tccp->prch[resno];
        } else {
#line 605
          res->pdx = 15;
#line 606
          res->pdy = 15;
        }
        {
#line 608
        levelno = (comp->numresolutions - 1) - resno;
#line 609
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 610
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 611
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 612
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 613
        __cil_tmp45 = int_floordivpow2(rx0, res->pdx);
#line 613
        px0 = __cil_tmp45 << res->pdx;
#line 614
        __cil_tmp46 = int_floordivpow2(ry0, res->pdy);
#line 614
        py0 = __cil_tmp46 << res->pdy;
#line 615
        __cil_tmp47 = int_ceildivpow2(rx1, res->pdx);
#line 615
        px1 = __cil_tmp47 << res->pdx;
#line 616
        __cil_tmp48 = int_ceildivpow2(ry1, res->pdy);
#line 616
        py1 = __cil_tmp48 << res->pdy;
        }
#line 617
        if (rx0 == rx1) {
#line 617
          tmp = 0;
        } else {
#line 617
          tmp = (px1 - px0) >> res->pdx;
        }
#line 617
        res->pw = tmp;
#line 618
        if (ry0 == ry1) {
#line 618
          tmp___0 = 0;
        } else {
#line 618
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 618
        res->ph = tmp___0;
#line 620
        if (res->pw * res->ph > maxprec) {
#line 621
          maxprec = res->pw * res->ph;
        }
#line 596
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 574
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    tccp = tcp->tccps + 0;
#line 627
    (pi + pino)->step_p = 1;
#line 628
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 629
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 630
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 632
    compno = 0;
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (compno < pi->numcomps)) {
#line 632
        goto while_break___2;
      }
#line 633
      comp___0 = pi->comps + compno;
#line 634
      resno = 0;
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 634
        if (! (resno < comp___0->numresolutions)) {
#line 634
          goto while_break___3;
        }
#line 636
        res___0 = comp___0->resolutions + resno;
#line 637
        dx = comp___0->dx * (1 << (((res___0->pdx + comp___0->numresolutions) - 1) - resno));
#line 638
        dy = comp___0->dy * (1 << (((res___0->pdy + comp___0->numresolutions) - 1) - resno));
#line 639
        if (! pi->dx) {
#line 639
          tmp___1 = dx;
        } else {
          {
#line 639
          __cil_tmp57 = int_min(pi->dx, dx);
#line 639
          tmp___1 = __cil_tmp57;
          }
        }
#line 639
        (pi + pino)->dx = tmp___1;
#line 640
        if (! pi->dy) {
#line 640
          tmp___2 = dy;
        } else {
          {
#line 640
          __cil_tmp59 = int_min(pi->dy, dy);
#line 640
          tmp___2 = __cil_tmp59;
          }
        }
#line 640
        (pi + pino)->dy = tmp___2;
#line 634
        resno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 632
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    if (pino == 0) {
      {
#line 645
      __cil_tmp63 = calloc((unsigned long )(tcp->numlayers * (pi + pino)->step_l),
                           sizeof(short ));
#line 645
      (pi + pino)->include = (short *)__cil_tmp63;
      }
#line 646
      if (! (pi + pino)->include) {
        {
#line 647
        pi_destroy(pi, cp, tileno);
        }
#line 648
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 652
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 656
    if (tcp->POC) {
#line 656
      if ((unsigned int )cp->cinema) {
        _L___5: /* CIL Label */ 
#line 657
        tcp->pocs[pino].compS = tcp->pocs[pino].compno0;
#line 658
        tcp->pocs[pino].compE = tcp->pocs[pino].compno1;
#line 659
        tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
#line 660
        tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
#line 661
        tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
#line 662
        tcp->pocs[pino].prg = tcp->pocs[pino].prg1;
#line 663
        if (pino > 0) {
#line 664
          if (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) {
#line 664
            tmp___3 = tcp->pocs[pino - 1].layE;
          } else {
#line 664
            tmp___3 = 0;
          }
#line 664
          tcp->pocs[pino].layS = tmp___3;
        }
      } else
#line 656
      if (! cp->cinema) {
#line 656
        if ((unsigned int )t2_mode == 1U) {
#line 656
          goto _L___5;
        } else {
#line 656
          goto _L;
        }
      } else {
#line 656
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 666
      tcp->pocs[pino].compS = 0;
#line 667
      tcp->pocs[pino].compE = image->numcomps;
#line 668
      tcp->pocs[pino].resS = 0;
#line 669
      tcp->pocs[pino].resE = maxres;
#line 670
      tcp->pocs[pino].layS = 0;
#line 671
      tcp->pocs[pino].layE = tcp->numlayers;
#line 672
      tcp->pocs[pino].prg = tcp->prg;
    }
#line 674
    tcp->pocs[pino].prcS = 0;
#line 675
    tcp->pocs[pino].prcE = maxprec;
#line 676
    tcp->pocs[pino].txS = (pi + pino)->tx0;
#line 677
    tcp->pocs[pino].txE = (pi + pino)->tx1;
#line 678
    tcp->pocs[pino].tyS = (pi + pino)->ty0;
#line 679
    tcp->pocs[pino].tyE = (pi + pino)->ty1;
#line 680
    tcp->pocs[pino].dx = (pi + pino)->dx;
#line 681
    tcp->pocs[pino].dy = (pi + pino)->dy;
#line 558
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (pi);
}
}
#line 688 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) 
{ 
  int compno ;
  int pino ;
  opj_tcp_t *tcp ;
  opj_pi_comp_t *comp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 690
  tcp = cp->tcps + tileno;
#line 691
  if (pi) {
#line 692
    pino = 0;
    {
#line 692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 692
      if (! (pino < tcp->numpocs + 1)) {
#line 692
        goto while_break;
      }
#line 693
      if ((pi + pino)->comps) {
#line 694
        compno = 0;
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 694
          if (! (compno < pi->numcomps)) {
#line 694
            goto while_break___0;
          }
#line 695
          comp = (pi + pino)->comps + compno;
#line 696
          if (comp->resolutions) {
            {
#line 697
            free(comp->resolutions);
            }
          }
#line 694
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 700
        free((pi + pino)->comps);
        }
      }
#line 692
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    if (pi->include) {
      {
#line 704
      free(pi->include);
      }
    }
    {
#line 706
    free(pi);
    }
  }
  return;
}
}
#line 710 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
int pi_next(opj_pi_iterator_t *pi ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 712
  if ((int )pi->poc.prg == 0) {
#line 712
    goto case_0;
  }
#line 714
  if ((int )pi->poc.prg == 1) {
#line 714
    goto case_1;
  }
#line 716
  if ((int )pi->poc.prg == 2) {
#line 716
    goto case_2;
  }
#line 718
  if ((int )pi->poc.prg == 3) {
#line 718
    goto case_3;
  }
#line 720
  if ((int )pi->poc.prg == 4) {
#line 720
    goto case_4;
  }
#line 722
  if ((int )pi->poc.prg == -1) {
#line 722
    goto case_neg_1;
  }
#line 711
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 713
  __cil_tmp2 = pi_next_lrcp(pi);
  }
#line 713
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 715
  __cil_tmp3 = pi_next_rlcp(pi);
  }
#line 715
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 717
  __cil_tmp4 = pi_next_rpcl(pi);
  }
#line 717
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 719
  __cil_tmp5 = pi_next_pcrl(pi);
  }
#line 719
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 721
  __cil_tmp6 = pi_next_cprl(pi);
  }
#line 721
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 723
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 726
  return (0);
}
}
#line 729 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/pi.c"
int pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                     int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  char prog[4] ;
  int i ;
  int incr_top ;
  int resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  int __cil_tmp15 ;

  {
#line 732
  incr_top = 1;
#line 732
  resetX = 0;
#line 733
  tcps = cp->tcps + tileno;
#line 734
  tcp = & tcps->pocs[pino];
#line 736
  (pi + pino)->first = 1;
#line 737
  (pi + pino)->poc.prg = tcp->prg;
  {
#line 740
  if ((int )tcp->prg == 4) {
#line 740
    goto case_4;
  }
#line 742
  if ((int )tcp->prg == 0) {
#line 742
    goto case_0;
  }
#line 744
  if ((int )tcp->prg == 3) {
#line 744
    goto case_3;
  }
#line 746
  if ((int )tcp->prg == 1) {
#line 746
    goto case_1;
  }
#line 748
  if ((int )tcp->prg == 2) {
#line 748
    goto case_2;
  }
#line 750
  if ((int )tcp->prg == -1) {
#line 750
    goto case_neg_1;
  }
#line 739
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 740
  strncpy((char *)prog, "CPRL", (unsigned long )4);
  }
#line 741
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 742
  strncpy((char *)prog, "LRCP", (unsigned long )4);
  }
#line 743
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 744
  strncpy((char *)prog, "PCRL", (unsigned long )4);
  }
#line 745
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 746
  strncpy((char *)prog, "RLCP\032V", (unsigned long )4);
  }
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 748
  strncpy((char *)prog, "RPCL", (unsigned long )4);
  }
#line 749
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 751
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (! ((int )cp->tp_on && ((! cp->cinema && (unsigned int )t2_mode == 1U) || (unsigned int )cp->cinema))) {
#line 755
    (pi + pino)->poc.resno0 = tcp->resS;
#line 756
    (pi + pino)->poc.resno1 = tcp->resE;
#line 757
    (pi + pino)->poc.compno0 = tcp->compS;
#line 758
    (pi + pino)->poc.compno1 = tcp->compE;
#line 759
    (pi + pino)->poc.layno0 = tcp->layS;
#line 760
    (pi + pino)->poc.layno1 = tcp->layE;
#line 761
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 762
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 763
    (pi + pino)->poc.tx0 = tcp->txS;
#line 764
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 765
    (pi + pino)->poc.tx1 = tcp->txE;
#line 766
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else
#line 768
  if (tpnum < cur_totnum_tp) {
#line 769
    i = 3;
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (i >= 0)) {
#line 769
        goto while_break;
      }
      {
#line 771
      if ((int )prog[i] == 'C') {
#line 771
        goto case_67;
      }
#line 803
      if ((int )prog[i] == 'R') {
#line 803
        goto case_82;
      }
#line 835
      if ((int )prog[i] == 'L') {
#line 835
        goto case_76;
      }
#line 867
      if ((int )prog[i] == 'P') {
#line 867
        goto case_80;
      }
#line 870
      if ((int )prog[i] == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )prog[i] == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_67: /* CIL Label */ 
#line 772
      if (i > tppos) {
#line 773
        (pi + pino)->poc.compno0 = tcp->compS;
#line 774
        (pi + pino)->poc.compno1 = tcp->compE;
      } else
#line 776
      if (tpnum == 0) {
#line 777
        tcp->comp_t = tcp->compS;
#line 778
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 779
        (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 780
        (tcp->comp_t) ++;
      } else
#line 782
      if (incr_top == 1) {
#line 783
        if (tcp->comp_t == tcp->compE) {
#line 784
          tcp->comp_t = tcp->compS;
#line 785
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 786
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 787
          (tcp->comp_t) ++;
#line 788
          incr_top = 1;
        } else {
#line 790
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 791
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 792
          (tcp->comp_t) ++;
#line 793
          incr_top = 0;
        }
      } else {
#line 796
        (pi + pino)->poc.compno0 = tcp->comp_t - 1;
#line 797
        (pi + pino)->poc.compno1 = tcp->comp_t;
      }
#line 801
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 804
      if (i > tppos) {
#line 805
        (pi + pino)->poc.resno0 = tcp->resS;
#line 806
        (pi + pino)->poc.resno1 = tcp->resE;
      } else
#line 808
      if (tpnum == 0) {
#line 809
        tcp->res_t = tcp->resS;
#line 810
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 811
        (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 812
        (tcp->res_t) ++;
      } else
#line 814
      if (incr_top == 1) {
#line 815
        if (tcp->res_t == tcp->resE) {
#line 816
          tcp->res_t = tcp->resS;
#line 817
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 818
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 819
          (tcp->res_t) ++;
#line 820
          incr_top = 1;
        } else {
#line 822
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 823
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 824
          (tcp->res_t) ++;
#line 825
          incr_top = 0;
        }
      } else {
#line 828
        (pi + pino)->poc.resno0 = tcp->res_t - 1;
#line 829
        (pi + pino)->poc.resno1 = tcp->res_t;
      }
#line 833
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 836
      if (i > tppos) {
#line 837
        (pi + pino)->poc.layno0 = tcp->layS;
#line 838
        (pi + pino)->poc.layno1 = tcp->layE;
      } else
#line 840
      if (tpnum == 0) {
#line 841
        tcp->lay_t = tcp->layS;
#line 842
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 843
        (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 844
        (tcp->lay_t) ++;
      } else
#line 846
      if (incr_top == 1) {
#line 847
        if (tcp->lay_t == tcp->layE) {
#line 848
          tcp->lay_t = tcp->layS;
#line 849
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 850
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 851
          (tcp->lay_t) ++;
#line 852
          incr_top = 1;
        } else {
#line 854
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 855
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 856
          (tcp->lay_t) ++;
#line 857
          incr_top = 0;
        }
      } else {
#line 860
        (pi + pino)->poc.layno0 = tcp->lay_t - 1;
#line 861
        (pi + pino)->poc.layno1 = tcp->lay_t;
      }
#line 865
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 870
      if ((int )tcp->prg == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )tcp->prg == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 871
      if (i > tppos) {
#line 872
        (pi + pino)->poc.precno0 = tcp->prcS;
#line 873
        (pi + pino)->poc.precno1 = tcp->prcE;
      } else
#line 875
      if (tpnum == 0) {
#line 876
        tcp->prc_t = tcp->prcS;
#line 877
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 878
        (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 879
        (tcp->prc_t) ++;
      } else
#line 881
      if (incr_top == 1) {
#line 882
        if (tcp->prc_t == tcp->prcE) {
#line 883
          tcp->prc_t = tcp->prcS;
#line 884
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 885
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 886
          (tcp->prc_t) ++;
#line 887
          incr_top = 1;
        } else {
#line 889
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 890
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 891
          (tcp->prc_t) ++;
#line 892
          incr_top = 0;
        }
      } else {
#line 895
        (pi + pino)->poc.precno0 = tcp->prc_t - 1;
#line 896
        (pi + pino)->poc.precno1 = tcp->prc_t;
      }
#line 900
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 902
      if (i > tppos) {
#line 903
        (pi + pino)->poc.tx0 = tcp->txS;
#line 904
        (pi + pino)->poc.ty0 = tcp->tyS;
#line 905
        (pi + pino)->poc.tx1 = tcp->txE;
#line 906
        (pi + pino)->poc.ty1 = tcp->tyE;
      } else
#line 908
      if (tpnum == 0) {
#line 909
        tcp->tx0_t = tcp->txS;
#line 910
        tcp->ty0_t = tcp->tyS;
#line 911
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 912
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 913
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 914
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 915
        tcp->tx0_t = (pi + pino)->poc.tx1;
#line 916
        tcp->ty0_t = (pi + pino)->poc.ty1;
      } else
#line 918
      if (incr_top == 1) {
#line 919
        if (tcp->tx0_t >= tcp->txE) {
#line 920
          if (tcp->ty0_t >= tcp->tyE) {
#line 921
            tcp->ty0_t = tcp->tyS;
#line 922
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 923
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 924
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 925
            incr_top = 1;
#line 925
            resetX = 1;
          } else {
#line 927
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 928
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 929
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 930
            incr_top = 0;
#line 930
            resetX = 1;
          }
#line 932
          if (resetX == 1) {
#line 933
            tcp->tx0_t = tcp->txS;
#line 934
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 935
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 936
            tcp->tx0_t = (pi + pino)->poc.tx1;
          }
        } else {
#line 939
          (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 940
          (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 941
          tcp->tx0_t = (pi + pino)->poc.tx1;
#line 942
          (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 943
          (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 944
          incr_top = 0;
        }
      } else {
#line 947
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 948
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 949
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 950
        (pi + pino)->poc.ty1 = tcp->ty0_t;
      }
#line 954
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 956
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 769
      __cil_tmp15 = i;
#line 769
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 961
  return (0);
}
}
#line 56 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 57
  return ("1.3.0");
}
}
#line 60 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_dinfo_t *dinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 61
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_dinfo_t ));
#line 61
  dinfo = (opj_dinfo_t *)__cil_tmp3;
  }
#line 62
  if (! dinfo) {
#line 62
    return ((opj_dinfo_t *)((void *)0));
  }
#line 63
  dinfo->is_decompressor = 1;
  {
#line 66
  if ((int )format == 1) {
#line 66
    goto case_1;
  }
#line 66
  if ((int )format == 0) {
#line 66
    goto case_1;
  }
#line 74
  if ((int )format == 2) {
#line 74
    goto case_2;
  }
#line 83
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 68
  __cil_tmp4 = j2k_create_decompress((opj_common_ptr )dinfo);
#line 68
  dinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 69
  if (! dinfo->j2k_handle) {
    {
#line 70
    free(dinfo);
    }
#line 71
    return ((opj_dinfo_t *)((void *)0));
  }
#line 73
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 76
  __cil_tmp5 = jp2_create_decompress((opj_common_ptr )dinfo);
#line 76
  dinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 77
  if (! dinfo->jp2_handle) {
    {
#line 78
    free(dinfo);
    }
#line 79
    return ((opj_dinfo_t *)((void *)0));
  }
#line 81
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 84
  free(dinfo);
  }
#line 85
  return ((opj_dinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 88
  dinfo->codec_format = format;
#line 90
  return (dinfo);
}
}
#line 93 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_destroy_decompress(opj_dinfo_t *dinfo ) 
{ 


  {
#line 94
  if (dinfo) {
    {
#line 98
    if ((int )dinfo->codec_format == 1) {
#line 98
      goto case_1;
    }
#line 98
    if ((int )dinfo->codec_format == 0) {
#line 98
      goto case_1;
    }
#line 101
    if ((int )dinfo->codec_format == 2) {
#line 101
      goto case_2;
    }
#line 105
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 99
    j2k_destroy_decompress((opj_j2k_t *)dinfo->j2k_handle);
    }
#line 100
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 102
    jp2_destroy_decompress((opj_jp2_t *)dinfo->jp2_handle);
    }
#line 103
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 106
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 109
    free(dinfo);
    }
  }
  return;
}
}
#line 113 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 114
  if (parameters) {
    {
#line 115
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 117
    parameters->cp_layer = 0;
#line 118
    parameters->cp_reduce = 0;
#line 119
    parameters->cp_limit_decoding = (OPJ_LIMIT_DECODING )0;
#line 121
    parameters->decod_format = - 1;
#line 122
    parameters->cod_format = - 1;
    }
  }
  return;
}
}
#line 133 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) 
{ 


  {
#line 134
  if (dinfo) {
#line 134
    if (parameters) {
      {
#line 137
      if ((int )dinfo->codec_format == 1) {
#line 137
        goto case_1;
      }
#line 137
      if ((int )dinfo->codec_format == 0) {
#line 137
        goto case_1;
      }
#line 140
      if ((int )dinfo->codec_format == 2) {
#line 140
        goto case_2;
      }
#line 144
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 138
      j2k_setup_decoder((opj_j2k_t *)dinfo->j2k_handle, parameters);
      }
#line 139
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 141
      jp2_setup_decoder((opj_jp2_t *)dinfo->jp2_handle, parameters);
      }
#line 142
      goto switch_break;
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 145
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 150 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) 
{ 
  opj_image_t *__cil_tmp3 ;

  {
  {
#line 151
  __cil_tmp3 = opj_decode_with_info(dinfo, cio, (opj_codestream_info_t *)((void *)0));
  }
#line 151
  return (__cil_tmp3);
}
}
#line 154 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *__cil_tmp4 ;
  opj_image_t *__cil_tmp5 ;
  opj_image_t *__cil_tmp6 ;

  {
#line 155
  if (dinfo) {
#line 155
    if (cio) {
      {
#line 157
      if ((int )dinfo->codec_format == 0) {
#line 157
        goto case_0;
      }
#line 159
      if ((int )dinfo->codec_format == 1) {
#line 159
        goto case_1;
      }
#line 161
      if ((int )dinfo->codec_format == 2) {
#line 161
        goto case_2;
      }
#line 164
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 158
      __cil_tmp4 = j2k_decode((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 158
      return (__cil_tmp4);
      case_1: /* CIL Label */ 
      {
#line 160
      __cil_tmp5 = j2k_decode_jpt_stream((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 160
      return (__cil_tmp5);
      case_2: /* CIL Label */ 
      {
#line 162
      __cil_tmp6 = jp2_decode((opj_jp2_t *)dinfo->jp2_handle, cio, cstr_info);
      }
#line 162
      return (__cil_tmp6);
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 165
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 168
  return ((opj_image_t *)((void *)0));
}
}
#line 171 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_cinfo_t *cinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 172
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_cinfo_t ));
#line 172
  cinfo = (opj_cinfo_t *)__cil_tmp3;
  }
#line 173
  if (! cinfo) {
#line 173
    return ((opj_cinfo_t *)((void *)0));
  }
#line 174
  cinfo->is_decompressor = 0;
  {
#line 176
  if ((int )format == 0) {
#line 176
    goto case_0;
  }
#line 184
  if ((int )format == 2) {
#line 184
    goto case_2;
  }
#line 194
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 178
  __cil_tmp4 = j2k_create_compress((opj_common_ptr )cinfo);
#line 178
  cinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 179
  if (! cinfo->j2k_handle) {
    {
#line 180
    free(cinfo);
    }
#line 181
    return ((opj_cinfo_t *)((void *)0));
  }
#line 183
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 186
  __cil_tmp5 = jp2_create_compress((opj_common_ptr )cinfo);
#line 186
  cinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 187
  if (! cinfo->jp2_handle) {
    {
#line 188
    free(cinfo);
    }
#line 189
    return ((opj_cinfo_t *)((void *)0));
  }
#line 191
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 195
  free(cinfo);
  }
#line 196
  return ((opj_cinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 199
  cinfo->codec_format = format;
#line 201
  return (cinfo);
}
}
#line 204 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_destroy_compress(opj_cinfo_t *cinfo ) 
{ 


  {
#line 205
  if (cinfo) {
    {
#line 208
    if ((int )cinfo->codec_format == 0) {
#line 208
      goto case_0;
    }
#line 211
    if ((int )cinfo->codec_format == 2) {
#line 211
      goto case_2;
    }
#line 216
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 209
    j2k_destroy_compress((opj_j2k_t *)cinfo->j2k_handle);
    }
#line 210
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 212
    jp2_destroy_compress((opj_jp2_t *)cinfo->jp2_handle);
    }
#line 213
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 217
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 220
    free(cinfo);
    }
  }
  return;
}
}
#line 224 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 225
  if (parameters) {
    {
#line 226
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 228
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 229
    parameters->max_comp_size = 0;
#line 230
    parameters->numresolution = 6;
#line 231
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 232
    parameters->cblockw_init = 64;
#line 233
    parameters->cblockh_init = 64;
#line 234
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 235
    parameters->roi_compno = - 1;
#line 236
    parameters->subsampling_dx = 1;
#line 237
    parameters->subsampling_dy = 1;
#line 238
    parameters->tp_on = (char )0;
#line 239
    parameters->decod_format = - 1;
#line 240
    parameters->cod_format = - 1;
    }
  }
  return;
}
}
#line 276 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 


  {
#line 277
  if (cinfo) {
#line 277
    if (parameters) {
#line 277
      if (image) {
        {
#line 279
        if ((int )cinfo->codec_format == 0) {
#line 279
          goto case_0;
        }
#line 282
        if ((int )cinfo->codec_format == 2) {
#line 282
          goto case_2;
        }
#line 287
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 280
        j2k_setup_encoder((opj_j2k_t *)cinfo->j2k_handle, parameters, image);
        }
#line 281
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 283
        jp2_setup_encoder((opj_jp2_t *)cinfo->jp2_handle, parameters, image);
        }
#line 284
        goto switch_break;
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 288
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  return;
}
}
#line 293 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
int opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) 
{ 
  int __cil_tmp5 ;

  {
#line 294
  if (index___0 != (void *)0) {
    {
#line 295
    opj_event_msg((opj_common_ptr )cinfo, 2, "Set index to NULL when calling the opj_encode function.\nTo extract the index, use the opj_encode_with_info() function.\nNo index will be generated during this encoding\n");
    }
  }
  {
#line 298
  __cil_tmp5 = opj_encode_with_info(cinfo, cio, image, (opj_codestream_info_t *)((void *)0));
  }
#line 298
  return (__cil_tmp5);
}
}
#line 301 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
int opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 302
  if (cinfo) {
#line 302
    if (cio) {
#line 302
      if (image) {
        {
#line 304
        if ((int )cinfo->codec_format == 0) {
#line 304
          goto case_0;
        }
#line 306
        if ((int )cinfo->codec_format == 2) {
#line 306
          goto case_2;
        }
#line 310
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 305
        __cil_tmp5 = j2k_encode((opj_j2k_t *)cinfo->j2k_handle, cio, image, cstr_info);
        }
#line 305
        return (__cil_tmp5);
        case_2: /* CIL Label */ 
        {
#line 307
        __cil_tmp6 = jp2_encode((opj_jp2_t *)cinfo->jp2_handle, cio, image, cstr_info);
        }
#line 307
        return (__cil_tmp6);
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 311
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 314
  return (0);
}
}
#line 317 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  opj_tile_info_t *tile_info ;
  int __cil_tmp4 ;

  {
#line 318
  if (cstr_info) {
#line 320
    tileno = 0;
    {
#line 320
    while (1) {
      while_continue: /* CIL Label */ ;
#line 320
      if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 320
        goto while_break;
      }
      {
#line 321
      tile_info = cstr_info->tile + tileno;
#line 322
      free(tile_info->thresh);
#line 323
      free(tile_info->packet);
#line 324
      free(tile_info->tp);
      }
#line 320
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 326
    free(cstr_info->tile);
#line 327
    free(cstr_info->marker);
#line 328
    free(cstr_info->numdecompos);
    }
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) ;
#line 50
static void mqc_renorme(opj_mqc_t *mqc ) ;
#line 55
static void mqc_codemps(opj_mqc_t *mqc ) ;
#line 60
static void mqc_codelps(opj_mqc_t *mqc ) ;
#line 65
static void mqc_setbits(opj_mqc_t *mqc ) ;
#line 71
static int mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 77
static int mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 82
static void mqc_bytein(opj_mqc_t *mqc ) ;
#line 87
static void mqc_renormd(opj_mqc_t *mqc ) ;
#line 96 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 96
  {      {(unsigned int )22017, 0, & mqc_states[2], & mqc_states[3]}, 
        {(unsigned int )22017, 1, & mqc_states[3], & mqc_states[2]}, 
        {(unsigned int )13313, 0, & mqc_states[4], & mqc_states[12]}, 
        {(unsigned int )13313, 1, & mqc_states[5], & mqc_states[13]}, 
        {(unsigned int )6145, 0, & mqc_states[6], & mqc_states[18]}, 
        {(unsigned int )6145, 1, & mqc_states[7], & mqc_states[19]}, 
        {(unsigned int )2753, 0, & mqc_states[8], & mqc_states[24]}, 
        {(unsigned int )2753, 1, & mqc_states[9], & mqc_states[25]}, 
        {(unsigned int )1313, 0, & mqc_states[10], & mqc_states[58]}, 
        {(unsigned int )1313, 1, & mqc_states[11], & mqc_states[59]}, 
        {(unsigned int )545, 0, & mqc_states[76], & mqc_states[66]}, 
        {(unsigned int )545, 1, & mqc_states[77], & mqc_states[67]}, 
        {(unsigned int )22017, 0, & mqc_states[14], & mqc_states[13]}, 
        {(unsigned int )22017, 1, & mqc_states[15], & mqc_states[12]}, 
        {(unsigned int )21505, 0, & mqc_states[16], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[17], & mqc_states[29]}, 
        {(unsigned int )18433, 0, & mqc_states[18], & mqc_states[28]}, 
        {(unsigned int )18433, 1, & mqc_states[19], & mqc_states[29]}, 
        {(unsigned int )14337, 0, & mqc_states[20], & mqc_states[28]}, 
        {(unsigned int )14337, 1, & mqc_states[21], & mqc_states[29]}, 
        {(unsigned int )12289, 0, & mqc_states[22], & mqc_states[34]}, 
        {(unsigned int )12289, 1, & mqc_states[23], & mqc_states[35]}, 
        {(unsigned int )9217, 0, & mqc_states[24], & mqc_states[36]}, 
        {(unsigned int )9217, 1, & mqc_states[25], & mqc_states[37]}, 
        {(unsigned int )7169, 0, & mqc_states[26], & mqc_states[40]}, 
        {(unsigned int )7169, 1, & mqc_states[27], & mqc_states[41]}, 
        {(unsigned int )5633, 0, & mqc_states[58], & mqc_states[42]}, 
        {(unsigned int )5633, 1, & mqc_states[59], & mqc_states[43]}, 
        {(unsigned int )22017, 0, & mqc_states[30], & mqc_states[29]}, 
        {(unsigned int )22017, 1, & mqc_states[31], & mqc_states[28]}, 
        {(unsigned int )21505, 0, & mqc_states[32], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[33], & mqc_states[29]}, 
        {(unsigned int )20737, 0, & mqc_states[34], & mqc_states[30]}, 
        {(unsigned int )20737, 1, & mqc_states[35], & mqc_states[31]}, 
        {(unsigned int )18433, 0, & mqc_states[36], & mqc_states[32]}, 
        {(unsigned int )18433, 1, & mqc_states[37], & mqc_states[33]}, 
        {(unsigned int )14337, 0, & mqc_states[38], & mqc_states[34]}, 
        {(unsigned int )14337, 1, & mqc_states[39], & mqc_states[35]}, 
        {(unsigned int )13313, 0, & mqc_states[40], & mqc_states[36]}, 
        {(unsigned int )13313, 1, & mqc_states[41], & mqc_states[37]}, 
        {(unsigned int )12289, 0, & mqc_states[42], & mqc_states[38]}, 
        {(unsigned int )12289, 1, & mqc_states[43], & mqc_states[39]}, 
        {(unsigned int )10241, 0, & mqc_states[44], & mqc_states[38]}, 
        {(unsigned int )10241, 1, & mqc_states[45], & mqc_states[39]}, 
        {(unsigned int )9217, 0, & mqc_states[46], & mqc_states[40]}, 
        {(unsigned int )9217, 1, & mqc_states[47], & mqc_states[41]}, 
        {(unsigned int )8705, 0, & mqc_states[48], & mqc_states[42]}, 
        {(unsigned int )8705, 1, & mqc_states[49], & mqc_states[43]}, 
        {(unsigned int )7169, 0, & mqc_states[50], & mqc_states[44]}, 
        {(unsigned int )7169, 1, & mqc_states[51], & mqc_states[45]}, 
        {(unsigned int )6145, 0, & mqc_states[52], & mqc_states[46]}, 
        {(unsigned int )6145, 1, & mqc_states[53], & mqc_states[47]}, 
        {(unsigned int )5633, 0, & mqc_states[54], & mqc_states[48]}, 
        {(unsigned int )5633, 1, & mqc_states[55], & mqc_states[49]}, 
        {(unsigned int )5121, 0, & mqc_states[56], & mqc_states[50]}, 
        {(unsigned int )5121, 1, & mqc_states[57], & mqc_states[51]}, 
        {(unsigned int )4609, 0, & mqc_states[58], & mqc_states[52]}, 
        {(unsigned int )4609, 1, & mqc_states[59], & mqc_states[53]}, 
        {(unsigned int )4353, 0, & mqc_states[60], & mqc_states[54]}, 
        {(unsigned int )4353, 1, & mqc_states[61], & mqc_states[55]}, 
        {(unsigned int )2753, 0, & mqc_states[62], & mqc_states[56]}, 
        {(unsigned int )2753, 1, & mqc_states[63], & mqc_states[57]}, 
        {(unsigned int )2497, 0, & mqc_states[64], & mqc_states[58]}, 
        {(unsigned int )2497, 1, & mqc_states[65], & mqc_states[59]}, 
        {(unsigned int )2209, 0, & mqc_states[66], & mqc_states[60]}, 
        {(unsigned int )2209, 1, & mqc_states[67], & mqc_states[61]}, 
        {(unsigned int )1313, 0, & mqc_states[68], & mqc_states[62]}, 
        {(unsigned int )1313, 1, & mqc_states[69], & mqc_states[63]}, 
        {(unsigned int )1089, 0, & mqc_states[70], & mqc_states[64]}, 
        {(unsigned int )1089, 1, & mqc_states[71], & mqc_states[65]}, 
        {(unsigned int )673, 0, & mqc_states[72], & mqc_states[66]}, 
        {(unsigned int )673, 1, & mqc_states[73], & mqc_states[67]}, 
        {(unsigned int )545, 0, & mqc_states[74], & mqc_states[68]}, 
        {(unsigned int )545, 1, & mqc_states[75], & mqc_states[69]}, 
        {(unsigned int )321, 0, & mqc_states[76], & mqc_states[70]}, 
        {(unsigned int )321, 1, & mqc_states[77], & mqc_states[71]}, 
        {(unsigned int )273, 0, & mqc_states[78], & mqc_states[72]}, 
        {(unsigned int )273, 1, & mqc_states[79], & mqc_states[73]}, 
        {(unsigned int )133, 0, & mqc_states[80], & mqc_states[74]}, 
        {(unsigned int )133, 1, & mqc_states[81], & mqc_states[75]}, 
        {(unsigned int )73, 0, & mqc_states[82], & mqc_states[76]}, 
        {(unsigned int )73, 1, & mqc_states[83], & mqc_states[77]}, 
        {(unsigned int )37, 0, & mqc_states[84], & mqc_states[78]}, 
        {(unsigned int )37, 1, & mqc_states[85], & mqc_states[79]}, 
        {(unsigned int )21, 0, & mqc_states[86], & mqc_states[80]}, 
        {(unsigned int )21, 1, & mqc_states[87], & mqc_states[81]}, 
        {(unsigned int )9, 0, & mqc_states[88], & mqc_states[82]}, 
        {(unsigned int )9, 1, & mqc_states[89], & mqc_states[83]}, 
        {(unsigned int )5, 0, & mqc_states[90], & mqc_states[84]}, 
        {(unsigned int )5, 1, & mqc_states[91], & mqc_states[85]}, 
        {(unsigned int )1, 0, & mqc_states[90], & mqc_states[86]}, 
        {(unsigned int )1, 1, & mqc_states[91], & mqc_states[87]}, 
        {(unsigned int )22017, 0, & mqc_states[92], & mqc_states[92]}, 
        {(unsigned int )22017, 1, & mqc_states[93], & mqc_states[93]}};
#line 199 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;
  unsigned char *__cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;

  {
#line 200
  if ((int )*(mqc->bp) == 255) {
#line 201
    (mqc->bp) ++;
#line 202
    *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 203
    mqc->c &= (unsigned int )1048575;
#line 204
    mqc->ct = (unsigned int )7;
  } else
#line 206
  if ((mqc->c & 134217728U) == 0U) {
#line 207
    (mqc->bp) ++;
#line 208
    *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 209
    mqc->c &= (unsigned int )524287;
#line 210
    mqc->ct = (unsigned int )8;
  } else {
#line 212
    (*(mqc->bp)) ++;
#line 213
    if ((int )*(mqc->bp) == 255) {
#line 214
      mqc->c &= (unsigned int )134217727;
#line 215
      (mqc->bp) ++;
#line 216
      *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 217
      mqc->c &= (unsigned int )1048575;
#line 218
      mqc->ct = (unsigned int )7;
    } else {
#line 220
      (mqc->bp) ++;
#line 221
      *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 222
      mqc->c &= (unsigned int )524287;
#line 223
      mqc->ct = (unsigned int )8;
    }
  }
  return;
}
}
#line 229 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_renorme(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    mqc->a <<= 1;
#line 232
    mqc->c <<= 1;
#line 233
    __cil_tmp2 = mqc->ct;
#line 233
    (mqc->ct) --;
#line 234
    if (mqc->ct == 0U) {
      {
#line 235
      mqc_byteout(mqc);
      }
    }
#line 230
    if (! ((mqc->a & 32768U) == 0U)) {
#line 230
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 240 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 241
  mqc->a -= (*(mqc->curctx))->qeval;
#line 242
  if ((mqc->a & 32768U) == 0U) {
#line 243
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 244
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 246
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 248
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 249
    mqc_renorme(mqc);
    }
  } else {
#line 251
    mqc->c += (*(mqc->curctx))->qeval;
  }
  return;
}
}
#line 255 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 256
  mqc->a -= (*(mqc->curctx))->qeval;
#line 257
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 258
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 260
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 262
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 263
  mqc_renorme(mqc);
  }
  return;
}
}
#line 266 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_setbits(opj_mqc_t *mqc ) 
{ 
  unsigned int tempc ;

  {
#line 267
  tempc = mqc->c + mqc->a;
#line 268
  mqc->c |= (unsigned int )65535;
#line 269
  if (mqc->c >= tempc) {
#line 270
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 274 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static int mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 276
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 277
    d = 1 - (*(mqc->curctx))->mps;
#line 278
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 280
    d = (*(mqc->curctx))->mps;
#line 281
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 284
  return (d);
}
}
#line 287 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static int mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 289
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 290
    mqc->a = (*(mqc->curctx))->qeval;
#line 291
    d = (*(mqc->curctx))->mps;
#line 292
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 294
    mqc->a = (*(mqc->curctx))->qeval;
#line 295
    d = 1 - (*(mqc->curctx))->mps;
#line 296
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 299
  return (d);
}
}
#line 302 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_bytein(opj_mqc_t *mqc ) 
{ 
  unsigned int c ;
  unsigned char *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 303
  if (mqc->bp != mqc->end) {
#line 305
    if (mqc->bp + 1 != mqc->end) {
#line 306
      c = (unsigned int )*(mqc->bp + 1);
    } else {
#line 308
      c = (unsigned int )255;
    }
#line 310
    if ((int )*(mqc->bp) == 255) {
#line 311
      if (c > 143U) {
#line 312
        mqc->c += (unsigned int )65280;
#line 313
        mqc->ct = (unsigned int )8;
      } else {
#line 315
        (mqc->bp) ++;
#line 316
        mqc->c += c << 9;
#line 317
        mqc->ct = (unsigned int )7;
      }
    } else {
#line 320
      (mqc->bp) ++;
#line 321
      mqc->c += c << 8;
#line 322
      mqc->ct = (unsigned int )8;
    }
  } else {
#line 325
    mqc->c += (unsigned int )65280;
#line 326
    mqc->ct = (unsigned int )8;
  }
  return;
}
}
#line 330 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
static void mqc_renormd(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (mqc->ct == 0U) {
      {
#line 333
      mqc_bytein(mqc);
      }
    }
#line 335
    mqc->a <<= 1;
#line 336
    mqc->c <<= 1;
#line 337
    __cil_tmp2 = mqc->ct;
#line 337
    (mqc->ct) --;
#line 331
    if (! (mqc->a < 32768U)) {
#line 331
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 347 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
opj_mqc_t *mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 348
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 348
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 349
  return (mqc);
}
}
#line 352 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 353
  if (mqc) {
    {
#line 354
    free(mqc);
    }
  }
  return;
}
}
#line 358 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
int mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 359
  return ((int )(mqc->bp - mqc->start));
}
}
#line 362 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) 
{ 


  {
#line 363
  mqc->curctx = & mqc->ctxs[(int )0];
#line 364
  mqc->a = (unsigned int )32768;
#line 365
  mqc->c = (unsigned int )0;
#line 366
  mqc->bp = bp - 1;
#line 367
  mqc->ct = (unsigned int )12;
#line 368
  if ((int )*(mqc->bp) == 255) {
#line 369
    mqc->ct = (unsigned int )13;
  }
#line 371
  mqc->start = bp;
  return;
}
}
#line 374 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_encode(opj_mqc_t *mqc , int d ) 
{ 


  {
#line 375
  if ((*(mqc->curctx))->mps == d) {
    {
#line 376
    mqc_codemps(mqc);
    }
  } else {
    {
#line 378
    mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 382 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_flush(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
  {
#line 383
  mqc_setbits(mqc);
#line 384
  mqc->c <<= mqc->ct;
#line 385
  mqc_byteout(mqc);
#line 386
  mqc->c <<= mqc->ct;
#line 387
  mqc_byteout(mqc);
  }
#line 389
  if ((int )*(mqc->bp) != 255) {
#line 390
    (mqc->bp) ++;
  }
  return;
}
}
#line 394 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 395
  mqc->c = (unsigned int )0;
#line 396
  mqc->ct = (unsigned int )8;
  return;
}
}
#line 402 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) 
{ 
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 403
  __cil_tmp3 = mqc->ct;
#line 403
  (mqc->ct) --;
#line 404
  mqc->c += (unsigned int )(d << mqc->ct);
#line 405
  if (mqc->ct == 0U) {
#line 406
    (mqc->bp) ++;
#line 407
    *(mqc->bp) = (unsigned char )mqc->c;
#line 408
    mqc->ct = (unsigned int )8;
#line 409
    if ((int )*(mqc->bp) == 255) {
#line 410
      mqc->ct = (unsigned int )7;
    }
#line 412
    mqc->c = (unsigned int )0;
  }
  return;
}
}
#line 416 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char bit_padding ;
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 419
  bit_padding = (unsigned char )0;
#line 421
  if (mqc->ct != 0U) {
    {
#line 422
    while (1) {
      while_continue: /* CIL Label */ ;
#line 422
      if (! (mqc->ct > 0U)) {
#line 422
        goto while_break;
      }
#line 423
      __cil_tmp3 = mqc->ct;
#line 423
      (mqc->ct) --;
#line 424
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 425
      bit_padding = (unsigned char )(((int )bit_padding + 1) & 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 427
    (mqc->bp) ++;
#line 428
    *(mqc->bp) = (unsigned char )mqc->c;
#line 429
    mqc->ct = (unsigned int )8;
#line 430
    mqc->c = (unsigned int )0;
  }
#line 433
  return (1);
}
}
#line 436 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 437
  mqc_resetstates(mqc);
#line 438
  mqc_setstate(mqc, 18, 0, 46);
#line 439
  mqc_setstate(mqc, 17, 0, 3);
#line 440
  mqc_setstate(mqc, 0, 0, 4);
  }
  return;
}
}
#line 443 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
int mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  int correction ;
  int n ;

  {
#line 444
  correction = 1;
#line 447
  n = (int )(12U - mqc->ct);
#line 448
  mqc->c <<= mqc->ct;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (n > 0)) {
#line 449
      goto while_break;
    }
    {
#line 450
    mqc_byteout(mqc);
#line 451
    n -= mqc->ct;
#line 452
    mqc->c <<= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 454
  mqc_byteout(mqc);
  }
#line 456
  return (correction);
}
}
#line 459 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 461
  mqc->curctx = & mqc->ctxs[(int )0];
#line 462
  mqc->a = (unsigned int )32768;
#line 463
  mqc->c = (unsigned int )0;
#line 464
  mqc->ct = (unsigned int )12;
#line 465
  __cil_tmp2 = mqc->bp;
#line 465
  (mqc->bp) --;
#line 466
  if ((int )*(mqc->bp) == 255) {
#line 467
    mqc->ct = (unsigned int )13;
  }
  return;
}
}
#line 471 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  int k ;

  {
#line 472
  k = (int )((11U - mqc->ct) + 1U);
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (k > 0)) {
#line 474
      goto while_break;
    }
    {
#line 475
    mqc->c <<= mqc->ct;
#line 476
    mqc->ct = (unsigned int )0;
#line 477
    mqc_byteout(mqc);
#line 478
    k -= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  if ((int )*(mqc->bp) != 255) {
    {
#line 482
    mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 486 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 488
  mqc->curctx = & mqc->ctxs[(int )18];
#line 490
  i = 1;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 5)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc_encode(mqc, i % 2);
    }
#line 490
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 495 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) 
{ 


  {
#line 496
  mqc->curctx = & mqc->ctxs[(int )0];
#line 497
  mqc->start = bp;
#line 498
  mqc->end = bp + len;
#line 499
  mqc->bp = bp;
#line 500
  if (len == 0) {
#line 500
    mqc->c = (unsigned int )(255 << 16);
  } else {
#line 501
    mqc->c = (unsigned int )((int )*(mqc->bp) << 16);
  }
  {
#line 502
  mqc_bytein(mqc);
#line 503
  mqc->c <<= 7;
#line 504
  mqc->ct -= (unsigned int )7;
#line 505
  mqc->a = (unsigned int )32768;
  }
  return;
}
}
#line 508 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
int mqc_decode(opj_mqc_t *mqc ) 
{ 
  int d ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 510
  mqc->a -= (*(mqc->curctx))->qeval;
#line 511
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 512
    d = mqc_lpsexchange(mqc);
#line 513
    mqc_renormd(mqc);
    }
  } else {
#line 515
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 516
    if ((mqc->a & 32768U) == 0U) {
      {
#line 517
      d = mqc_mpsexchange(mqc);
#line 518
      mqc_renormd(mqc);
      }
    } else {
#line 520
      d = (*(mqc->curctx))->mps;
    }
  }
#line 524
  return (d);
}
}
#line 527 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 529
  i = 0;
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (i < 19)) {
#line 529
      goto while_break;
    }
#line 530
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 529
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 534 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/mqc.c"
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) 
{ 


  {
#line 535
  mqc->ctxs[ctxno] = & mqc_states[msb + (prob << 1)];
  return;
}
}
#line 37 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.c"
unsigned int jpt_read_VBAS_info(opj_cio_t *cio , unsigned int value ) 
{ 
  unsigned char elmt ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = cio_read(cio, 1);
#line 40
  elmt = (unsigned char )__cil_tmp4;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int )elmt >> 7 == 1)) {
#line 41
      goto while_break;
    }
    {
#line 42
    value <<= 7;
#line 43
    value |= (unsigned int )((int )elmt & 127);
#line 44
    __cil_tmp5 = cio_read(cio, 1);
#line 44
    elmt = (unsigned char )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  value <<= 7;
#line 47
  value |= (unsigned int )((int )elmt & 127);
#line 49
  return (value);
}
}
#line 56 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.c"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 57
  header->Id = (unsigned int )0;
#line 58
  header->last_byte = (unsigned int )0;
#line 59
  header->Class_Id = (unsigned int )0;
#line 60
  header->CSn_Id = (unsigned int )0;
#line 61
  header->Msg_offset = (unsigned int )0;
#line 62
  header->Msg_length = (unsigned int )0;
#line 63
  header->Layer_nb = (unsigned int )0;
  return;
}
}
#line 72 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.c"
void jpt_reinit_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 73
  header->Id = (unsigned int )0;
#line 74
  header->last_byte = (unsigned int )0;
#line 75
  header->Msg_offset = (unsigned int )0;
#line 76
  header->Msg_length = (unsigned int )0;
  return;
}
}
#line 83 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jpt.c"
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) 
{ 
  unsigned char elmt ;
  unsigned char Class ;
  unsigned char CSn ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 84
  Class = (unsigned char )0;
  {
#line 84
  CSn = (unsigned char )0;
#line 85
  jpt_reinit_msg_header(header);
#line 90
  __cil_tmp7 = cio_read(cio, 1);
#line 90
  elmt = (unsigned char )__cil_tmp7;
  }
  {
#line 94
  if ((((int )elmt >> 5) & 3) == 0) {
#line 94
    goto case_0;
  }
#line 97
  if ((((int )elmt >> 5) & 3) == 1) {
#line 97
    goto case_1;
  }
#line 101
  if ((((int )elmt >> 5) & 3) == 2) {
#line 101
    goto case_2;
  }
#line 105
  if ((((int )elmt >> 5) & 3) == 3) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 95
  opj_event_msg(cinfo, 1, "Forbidden value encounter in message header !!\n");
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
#line 98
  Class = (unsigned char )0;
#line 99
  CSn = (unsigned char )0;
#line 100
  goto switch_break;
  case_2: /* CIL Label */ 
#line 102
  Class = (unsigned char )1;
#line 103
  CSn = (unsigned char )0;
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
#line 106
  Class = (unsigned char )1;
#line 107
  CSn = (unsigned char )1;
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  if ((((int )elmt >> 4) & 1) == 1) {
#line 115
    header->last_byte = (unsigned int )1;
  }
#line 118
  header->Id |= (unsigned int )((int )elmt & 15);
#line 119
  if ((int )elmt >> 7 == 1) {
    {
#line 120
    header->Id = jpt_read_VBAS_info(cio, header->Id);
    }
  }
#line 125
  if ((int )Class == 1) {
    {
#line 126
    header->Class_Id = (unsigned int )0;
#line 127
    header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
    }
  }
#line 133
  if ((int )CSn == 1) {
    {
#line 134
    header->CSn_Id = (unsigned int )0;
#line 135
    header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
    }
  }
  {
#line 141
  header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
#line 146
  header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
  }
#line 151
  if ((header->Class_Id & 1U) == 1U) {
    {
#line 152
    header->Layer_nb = (unsigned int )0;
#line 153
    header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
    }
  }
  return;
}
}
#line 47 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 55
static int jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 56
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static int jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 60
static int jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 66
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static int jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 74
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 75
static int jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                         unsigned int *j2k_codestream_offset ) ;
#line 76
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 83
static int jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 90
static int jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 98 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 99
  box->init_pos = cio_tell(cio);
#line 100
  __cil_tmp5 = cio_read(cio, 4);
#line 100
  box->length = (int )__cil_tmp5;
#line 101
  __cil_tmp6 = cio_read(cio, 4);
#line 101
  box->type = (int )__cil_tmp6;
  }
#line 102
  if (box->length == 1) {
    {
#line 103
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 103
    if (__cil_tmp7 != 0U) {
      {
#line 104
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 105
      return (0);
    }
    {
#line 107
    __cil_tmp8 = cio_read(cio, 4);
#line 107
    box->length = (int )__cil_tmp8;
    }
#line 108
    if (box->length == 0) {
      {
#line 109
      __cil_tmp9 = cio_numbytesleft(cio);
#line 109
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 111
  if (box->length == 0) {
    {
#line 112
    __cil_tmp10 = cio_numbytesleft(cio);
#line 112
    box->length = __cil_tmp10 + 8;
    }
  }
#line 115
  return (1);
}
}
#line 142 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 145
  cinfo = jp2->cinfo;
#line 147
  jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 148
  if (1768449138 != box.type) {
    {
#line 149
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 150
    return (0);
  }
  {
#line 153
  jp2->h = cio_read(cio, 4);
#line 154
  jp2->w = cio_read(cio, 4);
#line 155
  jp2->numcomps = cio_read(cio, 2);
#line 156
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 156
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 158
  jp2->bpc = cio_read(cio, 1);
#line 160
  jp2->C = cio_read(cio, 1);
#line 161
  jp2->UnkC = cio_read(cio, 1);
#line 162
  jp2->IPR = cio_read(cio, 1);
#line 164
  __cil_tmp13 = cio_tell(cio);
  }
#line 164
  if (__cil_tmp13 - box.init_pos != box.length) {
    {
#line 165
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n");
    }
#line 166
    return (0);
  }
#line 169
  return (1);
}
}
#line 172 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 175
  box.init_pos = cio_tell(cio);
#line 176
  cio_skip(cio, 4);
#line 177
  cio_write(cio, (unsigned int )1768449138, 4);
#line 179
  cio_write(cio, jp2->h, 4);
#line 180
  cio_write(cio, jp2->w, 4);
#line 181
  cio_write(cio, jp2->numcomps, 2);
#line 183
  cio_write(cio, jp2->bpc, 1);
#line 185
  cio_write(cio, jp2->C, 1);
#line 186
  cio_write(cio, jp2->UnkC, 1);
#line 187
  cio_write(cio, jp2->IPR, 1);
#line 189
  __cil_tmp5 = cio_tell(cio);
#line 189
  box.length = __cil_tmp5 - box.init_pos;
#line 190
  cio_seek(cio, box.init_pos);
#line 191
  cio_write(cio, (unsigned int )box.length, 4);
#line 192
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 195 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 199
  box.init_pos = cio_tell(cio);
#line 200
  cio_skip(cio, 4);
#line 201
  cio_write(cio, (unsigned int )1651532643, 4);
#line 203
  i = (unsigned int )0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < jp2->numcomps)) {
#line 203
      goto while_break;
    }
    {
#line 204
    cio_write(cio, (unsigned int )(jp2->comps + i)->bpcc, 1);
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  __cil_tmp7 = cio_tell(cio);
#line 207
  box.length = __cil_tmp7 - box.init_pos;
#line 208
  cio_seek(cio, box.init_pos);
#line 209
  cio_write(cio, (unsigned int )box.length, 4);
#line 210
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 214 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 218
  cinfo = jp2->cinfo;
#line 220
  jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 221
  if (1651532643 != box.type) {
    {
#line 222
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\n");
    }
#line 223
    return (0);
  }
#line 226
  i = (unsigned int )0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < jp2->numcomps)) {
#line 226
      goto while_break;
    }
    {
#line 227
    __cil_tmp6 = cio_read(cio, 1);
#line 227
    (jp2->comps + i)->bpcc = (int )__cil_tmp6;
    }
#line 226
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  __cil_tmp8 = cio_tell(cio);
  }
#line 230
  if (__cil_tmp8 - box.init_pos != box.length) {
    {
#line 231
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 232
    return (0);
  }
#line 235
  return (1);
}
}
#line 238 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 241
  box.init_pos = cio_tell(cio);
#line 242
  cio_skip(cio, 4);
#line 243
  cio_write(cio, (unsigned int )1668246642, 4);
#line 245
  cio_write(cio, jp2->meth, 1);
#line 246
  cio_write(cio, jp2->precedence, 1);
#line 247
  cio_write(cio, jp2->approx, 1);
  }
#line 249
  if (jp2->meth == 1U) {
    {
#line 250
    cio_write(cio, jp2->enumcs, 4);
    }
  } else {
    {
#line 252
    cio_write(cio, (unsigned int )0, 1);
    }
  }
  {
#line 255
  __cil_tmp5 = cio_tell(cio);
#line 255
  box.length = __cil_tmp5 - box.init_pos;
#line 256
  cio_seek(cio, box.init_pos);
#line 257
  cio_write(cio, (unsigned int )box.length, 4);
#line 258
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 261 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int skip_len ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 265
  cinfo = jp2->cinfo;
#line 267
  jp2_read_boxhdr(cinfo, cio, & box);
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (1668246642 != box.type) {
      {
#line 270
      cio_skip(cio, box.length - 8);
#line 271
      jp2_read_boxhdr(cinfo, cio, & box);
      }
    }
#line 268
    if (! (1668246642 != box.type)) {
#line 268
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  jp2->meth = cio_read(cio, 1);
#line 276
  jp2->precedence = cio_read(cio, 1);
#line 277
  jp2->approx = cio_read(cio, 1);
  }
#line 279
  if (jp2->meth == 1U) {
    {
#line 280
    jp2->enumcs = cio_read(cio, 4);
    }
  } else {
    {
#line 283
    __cil_tmp10 = cio_tell(cio);
#line 283
    skip_len = (box.init_pos + box.length) - __cil_tmp10;
    }
#line 284
    if (skip_len < 0) {
      {
#line 285
      opj_event_msg(cinfo, 1, "Error with JP2H box size\n");
      }
#line 286
      return (0);
    }
    {
#line 288
    __cil_tmp11 = cio_tell(cio);
#line 288
    cio_skip(cio, (box.init_pos + box.length) - __cil_tmp11);
    }
  }
  {
#line 291
  __cil_tmp12 = cio_tell(cio);
  }
#line 291
  if (__cil_tmp12 - box.init_pos != box.length) {
    {
#line 292
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 293
    return (0);
  }
#line 295
  return (1);
}
}
#line 298 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 301
  box.init_pos = cio_tell(cio);
#line 302
  cio_skip(cio, 4);
#line 303
  cio_write(cio, (unsigned int )1785737832, 4);
#line 305
  jp2_write_ihdr(jp2, cio);
  }
#line 307
  if (jp2->bpc == 255U) {
    {
#line 308
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 310
  jp2_write_colr(jp2, cio);
#line 312
  __cil_tmp5 = cio_tell(cio);
#line 312
  box.length = __cil_tmp5 - box.init_pos;
#line 313
  cio_seek(cio, box.init_pos);
#line 314
  cio_write(cio, (unsigned int )box.length, 4);
#line 315
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 318 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
int jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int skip_len ;
  opj_common_ptr cinfo ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 322
  cinfo = jp2->cinfo;
#line 324
  jp2_read_boxhdr(cinfo, cio, & box);
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (1785737832 != box.type) {
#line 327
      if (box.type == 1785737827) {
        {
#line 328
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\n");
        }
#line 329
        return (0);
      }
      {
#line 331
      cio_skip(cio, box.length - 8);
#line 332
      jp2_read_boxhdr(cinfo, cio, & box);
      }
    }
#line 325
    if (! (1785737832 != box.type)) {
#line 325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  __cil_tmp6 = jp2_read_ihdr(jp2, cio);
  }
#line 336
  if (! __cil_tmp6) {
#line 337
    return (0);
  }
#line 339
  if (jp2->bpc == 255U) {
    {
#line 340
    __cil_tmp7 = jp2_read_bpcc(jp2, cio);
    }
#line 340
    if (! __cil_tmp7) {
#line 341
      return (0);
    }
  }
  {
#line 343
  __cil_tmp8 = jp2_read_colr(jp2, cio);
  }
#line 343
  if (! __cil_tmp8) {
#line 344
    return (0);
  }
  {
#line 346
  __cil_tmp9 = cio_tell(cio);
#line 346
  skip_len = (box.init_pos + box.length) - __cil_tmp9;
  }
#line 347
  if (skip_len < 0) {
    {
#line 348
    opj_event_msg(cinfo, 1, "Error with JP2H Box\n\032V");
    }
#line 349
    return (0);
  }
  {
#line 351
  __cil_tmp10 = cio_tell(cio);
#line 351
  cio_skip(cio, (box.init_pos + box.length) - __cil_tmp10);
  }
#line 353
  return (1);
}
}
#line 356 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 360
  box.init_pos = cio_tell(cio);
#line 361
  cio_skip(cio, 4);
#line 362
  cio_write(cio, (unsigned int )1718909296, 4);
#line 364
  cio_write(cio, jp2->brand, 4);
#line 365
  cio_write(cio, jp2->minversion, 4);
#line 367
  i = (unsigned int )0;
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (i < jp2->numcl)) {
#line 367
      goto while_break;
    }
    {
#line 368
    cio_write(cio, *(jp2->cl + i), 4);
    }
#line 367
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  __cil_tmp7 = cio_tell(cio);
#line 371
  box.length = __cil_tmp7 - box.init_pos;
#line 372
  cio_seek(cio, box.init_pos);
#line 373
  cio_write(cio, (unsigned int )box.length, 4);
#line 374
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 377 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 381
  cinfo = jp2->cinfo;
#line 383
  jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 385
  if (1718909296 != box.type) {
    {
#line 386
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\nV");
    }
#line 387
    return (0);
  }
  {
#line 390
  jp2->brand = cio_read(cio, 4);
#line 391
  jp2->minversion = cio_read(cio, 4);
#line 392
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 393
  __cil_tmp8 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 393
  jp2->cl = (unsigned int *)__cil_tmp8;
#line 395
  i = 0;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (i < (int )jp2->numcl)) {
#line 395
      goto while_break;
    }
    {
#line 396
    *(jp2->cl + i) = cio_read(cio, 4);
    }
#line 395
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  __cil_tmp11 = cio_tell(cio);
  }
#line 399
  if (__cil_tmp11 - box.init_pos != box.length) {
    {
#line 400
    opj_event_msg(cinfo, 1, "Error with FTYP Box\n");
    }
#line 401
    return (0);
  }
#line 404
  return (1);
}
}
#line 407 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 411
  j2k = jp2->j2k;
#line 413
  box.init_pos = cio_tell(cio);
#line 414
  cio_skip(cio, 4);
#line 415
  cio_write(cio, (unsigned int )1785737827, 4);
#line 418
  __cil_tmp10 = cio_tell(cio);
#line 418
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 419
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 419
  if (! __cil_tmp11) {
    {
#line 420
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 421
    return (0);
  }
  {
#line 423
  __cil_tmp12 = cio_tell(cio);
#line 423
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 425
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 426
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 428
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 429
  cio_seek(cio, box.init_pos);
#line 430
  cio_write(cio, (unsigned int )box.length, 4);
#line 431
  cio_seek(cio, box.init_pos + box.length);
  }
#line 433
  return (box.length);
}
}
#line 436 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                         unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  int __cil_tmp7 ;

  {
  {
#line 439
  cinfo = jp2->cinfo;
#line 441
  jp2_read_boxhdr(cinfo, cio, & box);
  }
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (1785737827 != box.type) {
      {
#line 444
      cio_skip(cio, box.length - 8);
#line 445
      jp2_read_boxhdr(cinfo, cio, & box);
      }
    }
#line 442
    if (! (1785737827 != box.type)) {
#line 442
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  __cil_tmp7 = cio_tell(cio);
#line 449
  *j2k_codestream_offset = (unsigned int )__cil_tmp7;
#line 450
  *j2k_codestream_length = (unsigned int )(box.length - 8);
  }
#line 452
  return (1);
}
}
#line 455 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 458
  box.init_pos = cio_tell(cio);
#line 459
  cio_skip(cio, 4);
#line 460
  cio_write(cio, (unsigned int )1783636000, 4);
#line 461
  cio_write(cio, (unsigned int )218793738, 4);
#line 463
  __cil_tmp4 = cio_tell(cio);
#line 463
  box.length = __cil_tmp4 - box.init_pos;
#line 464
  cio_seek(cio, box.init_pos);
#line 465
  cio_write(cio, (unsigned int )box.length, 4);
#line 466
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 469 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 472
  cinfo = jp2->cinfo;
#line 474
  jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 475
  if (1783636000 != box.type) {
    {
#line 476
    opj_event_msg(cinfo, 1, "Expected JP Marker\n\240\032V");
    }
#line 477
    return (0);
  }
  {
#line 479
  __cil_tmp5 = cio_read(cio, 4);
  }
#line 479
  if (218793738U != __cil_tmp5) {
    {
#line 480
    opj_event_msg(cinfo, 1, "Error with JP Marker\n");
    }
#line 481
    return (0);
  }
  {
#line 483
  __cil_tmp6 = cio_tell(cio);
  }
#line 483
  if (__cil_tmp6 - box.init_pos != box.length) {
    {
#line 484
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 485
    return (0);
  }
#line 488
  return (1);
}
}
#line 492 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
static int jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 493
  __cil_tmp3 = jp2_read_jp(jp2, cio);
  }
#line 493
  if (! __cil_tmp3) {
#line 494
    return (0);
  }
  {
#line 495
  __cil_tmp4 = jp2_read_ftyp(jp2, cio);
  }
#line 495
  if (! __cil_tmp4) {
#line 496
    return (0);
  }
  {
#line 497
  __cil_tmp5 = jp2_read_jp2h(jp2, cio);
  }
#line 497
  if (! __cil_tmp5) {
#line 498
    return (0);
  }
  {
#line 499
  __cil_tmp6 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 499
  if (! __cil_tmp6) {
#line 500
    return (0);
  }
#line 502
  return (1);
}
}
#line 509 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 510
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 510
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 511
  if (jp2) {
    {
#line 512
    jp2->cinfo = cinfo;
#line 514
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 515
    if (jp2->j2k == (void *)0) {
      {
#line 516
      jp2_destroy_decompress(jp2);
      }
#line 517
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 520
  return (jp2);
}
}
#line 523 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 524
  if (jp2) {
    {
#line 526
    j2k_destroy_decompress(jp2->j2k);
    }
#line 528
    if (jp2->comps) {
      {
#line 529
      free(jp2->comps);
      }
    }
#line 531
    if (jp2->cl) {
      {
#line 532
      free(jp2->cl);
      }
    }
    {
#line 534
    free(jp2);
    }
  }
  return;
}
}
#line 538 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 540
  j2k_setup_decoder(jp2->j2k, parameters);
  }
  return;
}
}
#line 544 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
opj_image_t *jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  int __cil_tmp6 ;
  opj_image_t *__cil_tmp7 ;

  {
#line 546
  image = (opj_image_t *)((void *)0);
#line 548
  if (! jp2) {
#line 549
    return ((opj_image_t *)((void *)0));
  } else
#line 548
  if (! cio) {
#line 549
    return ((opj_image_t *)((void *)0));
  }
  {
#line 552
  cinfo = jp2->cinfo;
#line 555
  __cil_tmp6 = jp2_read_struct(jp2, cio);
  }
#line 555
  if (! __cil_tmp6) {
    {
#line 556
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 557
    return ((opj_image_t *)((void *)0));
  }
  {
#line 561
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 562
  if (! image) {
    {
#line 563
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 564
    return ((opj_image_t *)((void *)0));
  }
#line 568
  if (jp2->enumcs == 16U) {
#line 569
    image->color_space = (OPJ_COLOR_SPACE )1;
  } else
#line 570
  if (jp2->enumcs == 17U) {
#line 571
    image->color_space = (OPJ_COLOR_SPACE )2;
  } else
#line 572
  if (jp2->enumcs == 18U) {
#line 573
    image->color_space = (OPJ_COLOR_SPACE )3;
  } else {
#line 575
    image->color_space = (OPJ_COLOR_SPACE )-1;
  }
#line 577
  return (image);
}
}
#line 584 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 585
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 585
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 586
  if (jp2) {
    {
#line 587
    jp2->cinfo = cinfo;
#line 589
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 590
    if (jp2->j2k == (void *)0) {
      {
#line 591
      jp2_destroy_compress(jp2);
      }
#line 592
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 595
  return (jp2);
}
}
#line 598 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 599
  if (jp2) {
    {
#line 601
    j2k_destroy_compress(jp2->j2k);
    }
#line 603
    if (jp2->comps) {
      {
#line 604
      free(jp2->comps);
      }
    }
#line 606
    if (jp2->cl) {
      {
#line 607
      free(jp2->cl);
      }
    }
    {
#line 609
    free(jp2);
    }
  }
  return;
}
}
#line 613 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 617
  if (! jp2) {
#line 618
    return;
  } else
#line 617
  if (! parameters) {
#line 618
    return;
  } else
#line 617
  if (! image) {
#line 618
    return;
  }
#line 624
  if (image->numcomps < 1) {
    {
    {
#line 625
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 626
    return;
  } else
#line 624
  if (image->numcomps > 16384) {
    {
    {
#line 625
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 626
    return;
  }
  {
#line 629
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 636
  jp2->brand = (unsigned int )1785737760;
#line 637
  jp2->minversion = (unsigned int )0;
#line 638
  jp2->numcl = (unsigned int )1;
#line 639
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 639
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 640
  *(jp2->cl + 0) = (unsigned int )1785737760;
#line 644
  jp2->numcomps = (unsigned int )image->numcomps;
#line 645
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 645
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 646
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 647
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 649
  depth_0 = (image->comps + 0)->prec - 1;
#line 650
  sign = (image->comps + 0)->sgnd;
#line 651
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 652
  i = 1;
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (i < image->numcomps)) {
#line 652
      goto while_break;
    }
#line 653
    depth = (image->comps + i)->prec - 1;
#line 654
    sign = (image->comps + i)->sgnd;
#line 655
    if (depth_0 != depth) {
#line 656
      jp2->bpc = (unsigned int )255;
    }
#line 652
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 658
  jp2->C = (unsigned int )7;
#line 659
  jp2->UnkC = (unsigned int )0;
#line 660
  jp2->IPR = (unsigned int )0;
#line 664
  i = 0;
  {
#line 664
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 664
    if (! (i < image->numcomps)) {
#line 664
      goto while_break___0;
    }
#line 665
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 664
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 670
  if (image->numcomps == 1) {
    _L: /* CIL Label */ 
#line 670
    if (jp2->bpc != 255U) {
#line 671
      jp2->meth = (unsigned int )1;
    } else {
#line 673
      jp2->meth = (unsigned int )2;
    }
  } else
#line 670
  if (image->numcomps == 3) {
#line 670
    goto _L;
  } else {
#line 673
    jp2->meth = (unsigned int )2;
  }
#line 675
  if (jp2->meth == 1U) {
#line 676
    if ((int )image->color_space == 1) {
#line 677
      jp2->enumcs = (unsigned int )16;
    } else
#line 678
    if ((int )image->color_space == 2) {
#line 679
      jp2->enumcs = (unsigned int )17;
    } else
#line 680
    if ((int )image->color_space == 3) {
#line 681
      jp2->enumcs = (unsigned int )18;
    }
  } else {
#line 683
    jp2->enumcs = (unsigned int )0;
  }
#line 685
  jp2->precedence = (unsigned int )0;
#line 686
  jp2->approx = (unsigned int )0;
  return;
}
}
#line 690 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/jp2.c"
int jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 695
  jp2_write_jp(cio);
#line 697
  jp2_write_ftyp(jp2, cio);
#line 699
  jp2_write_jp2h(jp2, cio);
#line 703
  __cil_tmp5 = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 703
  if (! __cil_tmp5) {
    {
#line 704
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 705
    return (0);
  }
#line 708
  return (1);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 36 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 50
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 55
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 60
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 65
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 70
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 76
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 82
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 87
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 92
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 98
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 103
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 109
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 116
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 121
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 126
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 132
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 137
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 142
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 147
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 152
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 157
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 162
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 167
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 172
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 177
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 182
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 187
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 192
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 198
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 203
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 210
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 215
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 220
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 225
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 230
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 242 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0}}};
#line 251 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 253
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! ((int )po->enum_prog != -1)) {
#line 253
      goto while_break;
    }
#line 254
    if ((int )po->enum_prog == (int )prg_order) {
#line 255
      goto while_break;
    }
#line 253
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return ((char *)po->str_prog);
}
}
#line 261 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_dump_image(FILE *fd , opj_image_t *img ) 
{ 
  int compno ;
  opj_image_comp_t *comp ;
  int __cil_tmp5 ;

  {
  {
#line 263
  fprintf(fd, "image {\n\220");
#line 264
  fprintf(fd, "  x0=%d, y0=%d, x1=%d, y1=%d\n", img->x0, img->y0, img->x1, img->y1);
#line 265
  fprintf(fd, "  numcomps=%d\n", img->numcomps);
#line 266
  compno = 0;
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (compno < img->numcomps)) {
#line 266
      goto while_break;
    }
    {
#line 267
    comp = img->comps + compno;
#line 268
    fprintf(fd, "  comp %d {\n", compno);
#line 269
    fprintf(fd, "    dx=%d, dy=%d\n", comp->dx, comp->dy);
#line 270
    fprintf(fd, "    prec=%d\n", comp->prec);
#line 271
    fprintf(fd, "    sgnd=%d\n", comp->sgnd);
#line 272
    fprintf(fd, "  }\n");
    }
#line 266
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 277 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_dump_cp(FILE *fd , opj_image_t *img , opj_cp_t *cp ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int bandno ;
  int resno ;
  int numbands ;
  opj_tcp_t *tcp ;
  int __cil_tmp11 ;
  opj_tccp_t *tccp ;
  int tmp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 279
  fprintf(fd, "coding parameters {\n");
#line 280
  fprintf(fd, "  tx0=%d, ty0=%d\n", cp->tx0, cp->ty0);
#line 281
  fprintf(fd, "  tdx=%d, tdy=%d\n", cp->tdx, cp->tdy);
#line 282
  fprintf(fd, "  tw=%d, th=%d\n", cp->tw, cp->th);
#line 283
  tileno = 0;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (tileno < cp->tw * cp->th)) {
#line 283
      goto while_break;
    }
    {
#line 284
    tcp = cp->tcps + tileno;
#line 285
    fprintf(fd, "  tile %d {\n", tileno);
#line 286
    fprintf(fd, "    csty=%x\n", tcp->csty);
#line 287
    fprintf(fd, "    prg=%d\n", (int )tcp->prg);
#line 288
    fprintf(fd, "    numlayers=%d\n", tcp->numlayers);
#line 289
    fprintf(fd, "    mct=%d\n", tcp->mct);
#line 290
    fprintf(fd, "    rates=");
#line 291
    layno = 0;
    }
    {
#line 291
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 291
      if (! (layno < tcp->numlayers)) {
#line 291
        goto while_break___0;
      }
      {
#line 292
      fprintf(fd, "%.1f ", (double )tcp->rates[layno]);
      }
#line 291
      layno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 294
    fprintf(fd, "\n");
#line 295
    compno = 0;
    }
    {
#line 295
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 295
      if (! (compno < img->numcomps)) {
#line 295
        goto while_break___1;
      }
      {
#line 296
      tccp = tcp->tccps + compno;
#line 297
      fprintf(fd, "    comp %d {\n", compno);
#line 298
      fprintf(fd, "      csty=%x\n", tccp->csty);
#line 299
      fprintf(fd, "      numresolutions=%d\n\230\001", tccp->numresolutions);
#line 300
      fprintf(fd, "      cblkw=%d\n", tccp->cblkw);
#line 301
      fprintf(fd, "      cblkh=%d\n", tccp->cblkh);
#line 302
      fprintf(fd, "      cblksty=%x\n", tccp->cblksty);
#line 303
      fprintf(fd, "      qmfbid=%d\n\230\001", tccp->qmfbid);
#line 304
      fprintf(fd, "      qntsty=%d\n\230\001", tccp->qntsty);
#line 305
      fprintf(fd, "      numgbits=%d\n", tccp->numgbits);
#line 306
      fprintf(fd, "      roishift=%d\n", tccp->roishift);
#line 307
      fprintf(fd, "      stepsizes=\220");
      }
#line 308
      if (tccp->qntsty == 1) {
#line 308
        tmp = 1;
      } else {
#line 308
        tmp = tccp->numresolutions * 3 - 2;
      }
#line 308
      numbands = tmp;
#line 309
      bandno = 0;
      {
#line 309
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 309
        if (! (bandno < numbands)) {
#line 309
          goto while_break___2;
        }
        {
#line 310
        fprintf(fd, "(%d,%d) \230\001", tccp->stepsizes[bandno].mant, tccp->stepsizes[bandno].expn);
        }
#line 309
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 313
      fprintf(fd, "\n");
      }
#line 315
      if (tccp->csty & 1) {
        {
#line 316
        fprintf(fd, "      prcw=");
#line 317
        resno = 0;
        }
        {
#line 317
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 317
          if (! (resno < tccp->numresolutions)) {
#line 317
            goto while_break___3;
          }
          {
#line 318
          fprintf(fd, "%d ", tccp->prcw[resno]);
          }
#line 317
          resno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 320
        fprintf(fd, "\n");
#line 321
        fprintf(fd, "      prch=");
#line 322
        resno = 0;
        }
        {
#line 322
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 322
          if (! (resno < tccp->numresolutions)) {
#line 322
            goto while_break___4;
          }
          {
#line 323
          fprintf(fd, "%d ", tccp->prch[resno]);
          }
#line 322
          resno ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 325
        fprintf(fd, "\n");
        }
      }
      {
#line 327
      fprintf(fd, "    }\n");
      }
#line 295
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 329
    fprintf(fd, "  }\n");
    }
#line 283
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 335 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 338
  tpnum = 1;
  {
#line 338
  tpend = 0;
#line 339
  tcp = cp->tcps + tileno;
#line 340
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 342
  if ((int )cp->tp_on == 1) {
#line 343
    i = 0;
    {
#line 343
    while (1) {
      while_continue: /* CIL Label */ ;
#line 343
      if (! (i < 4)) {
#line 343
        goto while_break;
      }
#line 344
      if (tpend != 1) {
#line 345
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 346
          tpend = 1;
#line 346
          cp->tp_pos = i;
        }
        {
#line 349
        if ((int )*(prog + i) == 'C') {
#line 349
          goto case_67;
        }
#line 352
        if ((int )*(prog + i) == 'R') {
#line 352
          goto case_82;
        }
#line 355
        if ((int )*(prog + i) == 'P') {
#line 355
          goto case_80;
        }
#line 358
        if ((int )*(prog + i) == 'L') {
#line 358
          goto case_76;
        }
#line 348
        goto switch_break;
        case_67: /* CIL Label */ 
#line 350
        tpnum *= tcp->pocs[pino].compE;
#line 351
        goto switch_break;
        case_82: /* CIL Label */ 
#line 353
        tpnum *= tcp->pocs[pino].resE;
#line 354
        goto switch_break;
        case_80: /* CIL Label */ 
#line 356
        tpnum *= tcp->pocs[pino].prcE;
#line 357
        goto switch_break;
        case_76: /* CIL Label */ 
#line 359
        tpnum *= tcp->pocs[pino].layE;
#line 360
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 343
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 365
    tpnum = 1;
  }
#line 367
  return (tpnum);
}
}
#line 371 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 372
  totnum_tp = 0;
#line 373
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 373
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 374
  tileno = 0;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (tileno < cp->tw * cp->th)) {
#line 374
      goto while_break;
    }
#line 375
    cur_totnum_tp = 0;
#line 376
    tcp = cp->tcps + tileno;
#line 377
    pino = 0;
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      if (! (pino <= tcp->numpocs)) {
#line 377
        goto while_break___0;
      }
      {
#line 378
      tp_num = 0;
#line 379
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 379
      pi = __cil_tmp13;
      }
#line 380
      if (! pi) {
#line 380
        return (- 1);
      }
      {
#line 381
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 382
      totnum_tp += tp_num;
#line 383
      cur_totnum_tp += tp_num;
#line 384
      pi_destroy(pi, cp, tileno);
      }
#line 377
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 386
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 388
    if (j2k->cstr_info) {
      {
#line 389
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 390
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 390
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 374
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return (totnum_tp);
}
}
#line 397 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 398
  cio = j2k->cio;
#line 399
  cio_write(cio, (unsigned int )65359, 2);
  }
  return;
}
}
#line 411 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 412
  j2k->state = 2;
#line 414
  if (j2k->cstr_info) {
    {
#line 415
    __cil_tmp2 = cio_tell(j2k->cio);
#line 415
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 416
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 416
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
  return;
}
}
#line 420 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 424
  cio = j2k->cio;
#line 425
  image = j2k->image;
#line 426
  cp = j2k->cp;
#line 428
  cio_write(cio, (unsigned int )65361, 2);
#line 429
  lenp = cio_tell(cio);
#line 430
  cio_skip(cio, 2);
#line 431
  cio_write(cio, (unsigned int )cp->rsiz, 2);
#line 432
  cio_write(cio, (unsigned int )image->x1, 4);
#line 433
  cio_write(cio, (unsigned int )image->y1, 4);
#line 434
  cio_write(cio, (unsigned int )image->x0, 4);
#line 435
  cio_write(cio, (unsigned int )image->y0, 4);
#line 436
  cio_write(cio, (unsigned int )cp->tdx, 4);
#line 437
  cio_write(cio, (unsigned int )cp->tdy, 4);
#line 438
  cio_write(cio, (unsigned int )cp->tx0, 4);
#line 439
  cio_write(cio, (unsigned int )cp->ty0, 4);
#line 440
  cio_write(cio, (unsigned int )image->numcomps, 2);
#line 441
  i = 0;
  }
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (i < image->numcomps)) {
#line 441
      goto while_break;
    }
    {
#line 442
    cio_write(cio, (unsigned int )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 443
    cio_write(cio, (unsigned int )(image->comps + i)->dx, 1);
#line 444
    cio_write(cio, (unsigned int )(image->comps + i)->dy, 1);
    }
#line 441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 446
  __cil_tmp10 = cio_tell(cio);
#line 446
  len = __cil_tmp10 - lenp;
#line 447
  cio_seek(cio, lenp);
#line 448
  cio_write(cio, (unsigned int )len, 2);
#line 449
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 452 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  int tmp ;
  int w ;
  int h ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp38 ;

  {
  {
#line 455
  cio = j2k->cio;
#line 456
  image = j2k->image;
#line 457
  cp = j2k->cp;
#line 459
  __cil_tmp7 = cio_read(cio, 2);
#line 459
  len = (int )__cil_tmp7;
#line 460
  cio_read(cio, 2);
#line 461
  __cil_tmp8 = cio_read(cio, 4);
#line 461
  image->x1 = (int )__cil_tmp8;
#line 462
  __cil_tmp9 = cio_read(cio, 4);
#line 462
  image->y1 = (int )__cil_tmp9;
#line 463
  __cil_tmp10 = cio_read(cio, 4);
#line 463
  image->x0 = (int )__cil_tmp10;
#line 464
  __cil_tmp11 = cio_read(cio, 4);
#line 464
  image->y0 = (int )__cil_tmp11;
#line 465
  __cil_tmp12 = cio_read(cio, 4);
#line 465
  cp->tdx = (int )__cil_tmp12;
#line 466
  __cil_tmp13 = cio_read(cio, 4);
#line 466
  cp->tdy = (int )__cil_tmp13;
#line 467
  __cil_tmp14 = cio_read(cio, 4);
#line 467
  cp->tx0 = (int )__cil_tmp14;
#line 468
  __cil_tmp15 = cio_read(cio, 4);
#line 468
  cp->ty0 = (int )__cil_tmp15;
#line 470
  __cil_tmp16 = cio_read(cio, 2);
#line 470
  image->numcomps = (int )__cil_tmp16;
#line 511
  __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 511
  image->comps = (opj_image_comp_t *)__cil_tmp17;
#line 512
  i = 0;
  }
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! (i < image->numcomps)) {
#line 512
      goto while_break;
    }
    {
#line 514
    __cil_tmp21 = cio_read(cio, 1);
#line 514
    tmp = (int )__cil_tmp21;
#line 515
    (image->comps + i)->prec = (tmp & 127) + 1;
#line 516
    (image->comps + i)->sgnd = tmp >> 7;
#line 517
    __cil_tmp22 = cio_read(cio, 1);
#line 517
    (image->comps + i)->dx = (int )__cil_tmp22;
#line 518
    __cil_tmp23 = cio_read(cio, 1);
#line 518
    (image->comps + i)->dy = (int )__cil_tmp23;
#line 550
    w = int_ceildiv(image->x1 - image->x0, (image->comps + i)->dx);
#line 551
    h = int_ceildiv(image->y1 - image->y0, (image->comps + i)->dy);
#line 553
    (image->comps + i)->resno_decoded = 0;
#line 554
    (image->comps + i)->factor = cp->reduce;
    }
#line 512
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 558
  cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
#line 600
  __cil_tmp29 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 600
  cp->tcps = (opj_tcp_t *)__cil_tmp29;
#line 601
  __cil_tmp30 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 601
  cp->tileno = (int *)__cil_tmp30;
#line 602
  cp->tileno_size = 0;
#line 617
  i = 0;
  }
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 617
    if (! (i < cp->tw * cp->th)) {
#line 617
      goto while_break___0;
    }
#line 618
    (cp->tcps + i)->POC = 0;
#line 619
    (cp->tcps + i)->numpocs = 0;
#line 620
    (cp->tcps + i)->first = 1;
#line 617
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 624
  cp->ppm = 0;
#line 625
  cp->ppm_data = (unsigned char *)((void *)0);
#line 626
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 627
  cp->ppm_previous = 0;
#line 628
  cp->ppm_store = 0;
#line 630
  __cil_tmp32 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 630
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp32;
#line 631
  i = 0;
  }
  {
#line 631
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 631
    if (! (i < cp->tw * cp->th)) {
#line 631
      goto while_break___1;
    }
    {
#line 632
    __cil_tmp33 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 632
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp33;
    }
#line 631
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 634
  __cil_tmp35 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 634
  j2k->tile_data = (unsigned char **)__cil_tmp35;
#line 635
  __cil_tmp36 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 635
  j2k->tile_len = (int *)__cil_tmp36;
#line 636
  j2k->state = 4;
  }
#line 639
  if (j2k->cstr_info) {
    {
#line 640
    cstr_info = j2k->cstr_info;
#line 641
    cstr_info->image_w = image->x1 - image->x0;
#line 642
    cstr_info->image_h = image->y1 - image->y0;
#line 643
    cstr_info->numcomps = image->numcomps;
#line 644
    cstr_info->tw = cp->tw;
#line 645
    cstr_info->th = cp->th;
#line 646
    cstr_info->tile_x = cp->tdx;
#line 647
    cstr_info->tile_y = cp->tdy;
#line 648
    cstr_info->tile_Ox = cp->tx0;
#line 649
    cstr_info->tile_Oy = cp->ty0;
#line 650
    __cil_tmp38 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 650
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp38;
    }
  }
  return;
}
}
#line 654 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 658
  if ((j2k->cp)->comment) {
    {
#line 659
    cio = j2k->cio;
#line 660
    comment = (j2k->cp)->comment;
#line 662
    cio_write(cio, (unsigned int )65380, 2);
#line 663
    lenp = cio_tell(cio);
#line 664
    cio_skip(cio, 2);
#line 665
    cio_write(cio, (unsigned int )1, 2);
#line 666
    i = (unsigned int )0;
    }
    {
#line 666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 666
        goto while_break;
      }
      {
#line 667
      cio_write(cio, (unsigned int )*(comment + i), 1);
      }
#line 666
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 669
    __cil_tmp10 = cio_tell(cio);
#line 669
    len = __cil_tmp10 - lenp;
#line 670
    cio_seek(cio, lenp);
#line 671
    cio_write(cio, (unsigned int )len, 2);
#line 672
    cio_seek(cio, lenp + len);
    }
  }
  return;
}
}
#line 676 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 679
  cio = j2k->cio;
#line 681
  __cil_tmp4 = cio_read(cio, 2);
#line 681
  len = (int )__cil_tmp4;
#line 682
  cio_skip(cio, len - 2);
  }
  return;
}
}
#line 685 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 688
  cp = j2k->cp;
#line 689
  tcp = cp->tcps + j2k->curtileno;
#line 690
  tccp = tcp->tccps + compno;
#line 691
  cio = j2k->cio;
#line 693
  cio_write(cio, (unsigned int )(tccp->numresolutions - 1), 1);
#line 694
  cio_write(cio, (unsigned int )(tccp->cblkw - 2), 1);
#line 695
  cio_write(cio, (unsigned int )(tccp->cblkh - 2), 1);
#line 696
  cio_write(cio, (unsigned int )tccp->cblksty, 1);
#line 697
  cio_write(cio, (unsigned int )tccp->qmfbid, 1);
  }
#line 699
  if (tccp->csty & 1) {
#line 700
    i = 0;
    {
#line 700
    while (1) {
      while_continue: /* CIL Label */ ;
#line 700
      if (! (i < tccp->numresolutions)) {
#line 700
        goto while_break;
      }
      {
#line 701
      cio_write(cio, (unsigned int )(tccp->prcw[i] + (tccp->prch[i] << 4)), 1);
      }
#line 700
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 706 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 709
  cp = j2k->cp;
#line 710
  if (j2k->state == 16) {
#line 710
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 710
    tmp = j2k->default_tcp;
  }
  {
#line 710
  tcp = tmp;
#line 711
  tccp = tcp->tccps + compno;
#line 712
  cio = j2k->cio;
#line 714
  __cil_tmp9 = cio_read(cio, 1);
#line 714
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 717
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 718
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 720
    j2k->state |= 128;
    }
  }
  {
#line 723
  __cil_tmp10 = cio_read(cio, 1);
#line 723
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 724
  __cil_tmp11 = cio_read(cio, 1);
#line 724
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 725
  __cil_tmp12 = cio_read(cio, 1);
#line 725
  tccp->cblksty = (int )__cil_tmp12;
#line 726
  __cil_tmp13 = cio_read(cio, 1);
#line 726
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 727
  if (tccp->csty & 1) {
#line 728
    i = 0;
    {
#line 728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 728
      if (! (i < tccp->numresolutions)) {
#line 728
        goto while_break;
      }
      {
#line 729
      __cil_tmp15 = cio_read(cio, 1);
#line 729
      tmp___0 = (int )__cil_tmp15;
#line 730
      tccp->prcw[i] = tmp___0 & 15;
#line 731
      tccp->prch[i] = tmp___0 >> 4;
      }
#line 728
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 736
  if (j2k->cstr_info) {
#line 736
    if (compno == 0) {
#line 737
      i = 0;
      {
#line 737
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 737
        if (! (i < tccp->numresolutions)) {
#line 737
          goto while_break___0;
        }
#line 738
        if (tccp->csty & 1) {
#line 739
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 740
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 743
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 744
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 737
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 751 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 752
  cp = (opj_cp_t *)((void *)0);
#line 753
  tcp = (opj_tcp_t *)((void *)0);
#line 756
  cio = j2k->cio;
#line 758
  cio_write(cio, (unsigned int )65362, 2);
#line 760
  lenp = cio_tell(cio);
#line 761
  cio_skip(cio, 2);
#line 763
  cp = j2k->cp;
#line 764
  tcp = cp->tcps + j2k->curtileno;
#line 766
  cio_write(cio, (unsigned int )tcp->csty, 1);
#line 767
  cio_write(cio, (unsigned int )tcp->prg, 1);
#line 768
  cio_write(cio, (unsigned int )tcp->numlayers, 2);
#line 769
  cio_write(cio, (unsigned int )tcp->mct, 1);
#line 771
  j2k_write_cox(j2k, 0);
#line 772
  __cil_tmp8 = cio_tell(cio);
#line 772
  len = __cil_tmp8 - lenp;
#line 773
  cio_seek(cio, lenp);
#line 774
  cio_write(cio, (unsigned int )len, 2);
#line 775
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 778 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 781
  cio = j2k->cio;
#line 782
  cp = j2k->cp;
#line 783
  if (j2k->state == 16) {
#line 783
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 783
    tmp = j2k->default_tcp;
  }
  {
#line 783
  tcp = tmp;
#line 784
  image = j2k->image;
#line 786
  __cil_tmp10 = cio_read(cio, 2);
#line 786
  len = (int )__cil_tmp10;
#line 787
  __cil_tmp11 = cio_read(cio, 1);
#line 787
  tcp->csty = (int )__cil_tmp11;
#line 788
  __cil_tmp12 = cio_read(cio, 1);
#line 788
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 789
  __cil_tmp13 = cio_read(cio, 2);
#line 789
  tcp->numlayers = (int )__cil_tmp13;
#line 790
  __cil_tmp14 = cio_read(cio, 1);
#line 790
  tcp->mct = (int )__cil_tmp14;
#line 792
  pos = cio_tell(cio);
#line 793
  i = 0;
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (i < image->numcomps)) {
#line 793
      goto while_break;
    }
    {
#line 794
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 795
    cio_seek(cio, pos);
#line 796
    j2k_read_cox(j2k, i);
    }
#line 793
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if (j2k->cstr_info) {
    {
#line 801
    cstr_info = j2k->cstr_info;
#line 802
    cstr_info->prog = tcp->prg;
#line 803
    cstr_info->numlayers = tcp->numlayers;
#line 804
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 804
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 805
    i = 0;
    }
    {
#line 805
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 805
      if (! (i < image->numcomps)) {
#line 805
        goto while_break___0;
      }
#line 806
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 805
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 811 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 814
  cp = j2k->cp;
#line 815
  tcp = cp->tcps + j2k->curtileno;
#line 816
  image = j2k->image;
#line 817
  cio = j2k->cio;
#line 819
  cio_write(cio, (unsigned int )65363, 2);
#line 820
  lenp = cio_tell(cio);
#line 821
  cio_skip(cio, 2);
  }
#line 822
  if (image->numcomps <= 256) {
#line 822
    tmp = 1;
  } else {
#line 822
    tmp = 2;
  }
  {
#line 822
  cio_write(cio, (unsigned int )compno, tmp);
#line 823
  cio_write(cio, (unsigned int )(tcp->tccps + compno)->csty, 1);
#line 824
  j2k_write_cox(j2k, compno);
#line 825
  __cil_tmp11 = cio_tell(cio);
#line 825
  len = __cil_tmp11 - lenp;
#line 826
  cio_seek(cio, lenp);
#line 827
  cio_write(cio, (unsigned int )len, 2);
#line 828
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 831 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 834
  cp = j2k->cp;
#line 835
  if (j2k->state == 16) {
#line 835
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 835
    tmp = j2k->default_tcp;
  }
  {
#line 835
  tcp = tmp;
#line 836
  image = j2k->image;
#line 837
  cio = j2k->cio;
#line 839
  __cil_tmp9 = cio_read(cio, 2);
#line 839
  len = (int )__cil_tmp9;
  }
#line 840
  if (image->numcomps <= 256) {
#line 840
    tmp___0 = 1;
  } else {
#line 840
    tmp___0 = 2;
  }
  {
#line 840
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 840
  compno = (int )__cil_tmp11;
#line 841
  __cil_tmp12 = cio_read(cio, 1);
#line 841
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 842
  j2k_read_cox(j2k, compno);
  }
  return;
}
}
#line 845 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 849
  cp = j2k->cp;
#line 850
  tcp = cp->tcps + j2k->curtileno;
#line 851
  tccp = tcp->tccps + compno;
#line 852
  cio = j2k->cio;
#line 854
  cio_write(cio, (unsigned int )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 855
  if (tccp->qntsty == 1) {
#line 855
    tmp = 1;
  } else {
#line 855
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 855
  numbands = tmp;
#line 857
  bandno = 0;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! (bandno < numbands)) {
#line 857
      goto while_break;
    }
#line 858
    expn = tccp->stepsizes[bandno].expn;
#line 859
    mant = tccp->stepsizes[bandno].mant;
#line 861
    if (tccp->qntsty == 0) {
      {
#line 862
      cio_write(cio, (unsigned int )(expn << 3), 1);
      }
    } else {
      {
#line 864
      cio_write(cio, (unsigned int )((expn << 11) + mant), 2);
      }
    }
#line 857
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 869 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___6 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___7 ;
  int tmp___8 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___9 ;
  int __cil_tmp21 ;

  {
#line 873
  cp = j2k->cp;
#line 874
  if (j2k->state == 16) {
#line 874
    tmp___6 = cp->tcps + j2k->curtileno;
  } else {
#line 874
    tmp___6 = j2k->default_tcp;
  }
  {
#line 874
  tcp = tmp___6;
#line 875
  tccp = tcp->tccps + compno;
#line 876
  cio = j2k->cio;
#line 878
  __cil_tmp12 = cio_read(cio, 1);
#line 878
  tmp = (int )__cil_tmp12;
#line 879
  tccp->qntsty = tmp & 31;
#line 880
  tccp->numgbits = tmp >> 5;
  }
#line 881
  if (tccp->qntsty == 1) {
#line 881
    tmp___8 = 1;
  } else {
#line 881
    if (tccp->qntsty == 0) {
#line 881
      tmp___7 = len - 1;
    } else {
#line 881
      tmp___7 = (len - 1) / 2;
    }
#line 881
    tmp___8 = tmp___7;
  }
#line 881
  numbands = tmp___8;
#line 906
  bandno = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (bandno < numbands)) {
#line 906
      goto while_break;
    }
#line 908
    if (tccp->qntsty == 0) {
      {
#line 909
      __cil_tmp17 = cio_read(cio, 1);
#line 909
      expn = (int )(__cil_tmp17 >> 3);
#line 910
      mant = 0;
      }
    } else {
      {
#line 912
      __cil_tmp18 = cio_read(cio, 2);
#line 912
      tmp = (int )__cil_tmp18;
#line 913
      expn = tmp >> 11;
#line 914
      mant = tmp & 2047;
      }
    }
#line 916
    tccp->stepsizes[bandno].expn = expn;
#line 917
    tccp->stepsizes[bandno].mant = mant;
#line 906
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 921
  if (tccp->qntsty == 1) {
#line 922
    bandno = 1;
    {
#line 922
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 922
      if (! (bandno < 97)) {
#line 922
        goto while_break___0;
      }
#line 923
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 923
        tmp___9 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 923
        tmp___9 = 0;
      }
#line 923
      tccp->stepsizes[bandno].expn = tmp___9;
#line 926
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 922
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 932 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 935
  cio = j2k->cio;
#line 937
  cio_write(cio, (unsigned int )65372, 2);
#line 938
  lenp = cio_tell(cio);
#line 939
  cio_skip(cio, 2);
#line 940
  j2k_write_qcx(j2k, 0);
#line 941
  __cil_tmp6 = cio_tell(cio);
#line 941
  len = __cil_tmp6 - lenp;
#line 942
  cio_seek(cio, lenp);
#line 943
  cio_write(cio, (unsigned int )len, 2);
#line 944
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 947 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 950
  cio = j2k->cio;
#line 951
  image = j2k->image;
#line 953
  __cil_tmp7 = cio_read(cio, 2);
#line 953
  len = (int )__cil_tmp7;
#line 954
  pos = cio_tell(cio);
#line 955
  i = 0;
  }
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
#line 955
    if (! (i < image->numcomps)) {
#line 955
      goto while_break;
    }
    {
#line 956
    cio_seek(cio, pos);
#line 957
    j2k_read_qcx(j2k, i, len - 2);
    }
#line 955
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 961 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 964
  cio = j2k->cio;
#line 966
  cio_write(cio, (unsigned int )65373, 2);
#line 967
  lenp = cio_tell(cio);
#line 968
  cio_skip(cio, 2);
  }
#line 969
  if ((j2k->image)->numcomps <= 256) {
#line 969
    tmp = 1;
  } else {
#line 969
    tmp = 2;
  }
  {
#line 969
  cio_write(cio, (unsigned int )compno, tmp);
#line 970
  j2k_write_qcx(j2k, compno);
#line 971
  __cil_tmp8 = cio_tell(cio);
#line 971
  len = __cil_tmp8 - lenp;
#line 972
  cio_seek(cio, lenp);
#line 973
  cio_write(cio, (unsigned int )len, 2);
#line 974
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 977 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 979
  numcomp = (j2k->image)->numcomps;
#line 980
  cio = j2k->cio;
#line 982
  __cil_tmp6 = cio_read(cio, 2);
#line 982
  len = (int )__cil_tmp6;
  }
#line 983
  if (numcomp <= 256) {
#line 983
    tmp = 1;
  } else {
#line 983
    tmp = 2;
  }
  {
#line 983
  __cil_tmp8 = cio_read(cio, tmp);
#line 983
  compno = (int )__cil_tmp8;
  }
#line 1011
  if (numcomp <= 256) {
#line 1011
    tmp___0 = 1;
  } else {
#line 1011
    tmp___0 = 2;
  }
  {
#line 1011
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
  return;
}
}
#line 1014 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1017
  numcomps = (j2k->image)->numcomps;
#line 1019
  cp = j2k->cp;
#line 1020
  tcp = cp->tcps + j2k->curtileno;
#line 1021
  tccp = tcp->tccps + 0;
#line 1022
  cio = j2k->cio;
#line 1024
  numpchgs = 1 + tcp->numpocs;
#line 1025
  cio_write(cio, (unsigned int )65375, 2);
  }
#line 1026
  if (numcomps <= 256) {
#line 1026
    tmp = 1;
  } else {
#line 1026
    tmp = 2;
  }
  {
#line 1026
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1027
  cio_write(cio, (unsigned int )len, 2);
#line 1028
  i = 0;
  }
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (i < numpchgs)) {
#line 1028
      goto while_break;
    }
    {
#line 1029
    poc = & tcp->pocs[i];
#line 1030
    cio_write(cio, (unsigned int )poc->resno0, 1);
    }
#line 1031
    if (numcomps <= 256) {
#line 1031
      tmp___0 = 1;
    } else {
#line 1031
      tmp___0 = 2;
    }
    {
#line 1031
    cio_write(cio, (unsigned int )poc->compno0, tmp___0);
#line 1032
    cio_write(cio, (unsigned int )poc->layno1, 2);
#line 1033
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1034
    cio_write(cio, (unsigned int )poc->resno1, 1);
#line 1035
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1036
    if (numcomps <= 256) {
#line 1036
      tmp___1 = 1;
    } else {
#line 1036
      tmp___1 = 2;
    }
    {
#line 1036
    cio_write(cio, (unsigned int )poc->compno1, tmp___1);
#line 1037
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1038
    cio_write(cio, (unsigned int )poc->prg, 1);
    }
#line 1028
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1042 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1045
  numcomps = (j2k->image)->numcomps;
#line 1047
  cp = j2k->cp;
#line 1048
  if (j2k->state == 16) {
#line 1048
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1048
    tmp = j2k->default_tcp;
  }
#line 1048
  tcp = tmp;
#line 1049
  cio = j2k->cio;
#line 1051
  if (tcp->POC) {
#line 1051
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1051
    tmp___0 = 0;
  }
  {
#line 1051
  old_poc = tmp___0;
#line 1052
  tcp->POC = 1;
#line 1053
  __cil_tmp12 = cio_read(cio, 2);
#line 1053
  len = (int )__cil_tmp12;
  }
#line 1054
  if (numcomps <= 256) {
#line 1054
    tmp___1 = 1;
  } else {
#line 1054
    tmp___1 = 2;
  }
#line 1054
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1056
  i = old_poc;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! (i < numpchgs + old_poc)) {
#line 1056
      goto while_break;
    }
    {
#line 1058
    poc = & tcp->pocs[i];
#line 1059
    __cil_tmp15 = cio_read(cio, 1);
#line 1059
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1060
    if (numcomps <= 256) {
#line 1060
      tmp___2 = 1;
    } else {
#line 1060
      tmp___2 = 2;
    }
    {
#line 1060
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1060
    poc->compno0 = (int )__cil_tmp17;
#line 1061
    __cil_tmp18 = cio_read(cio, 2);
#line 1061
    poc->layno1 = (int )__cil_tmp18;
#line 1062
    __cil_tmp19 = cio_read(cio, 1);
#line 1062
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1063
    if (numcomps <= 256) {
#line 1063
      tmp___3 = 1;
    } else {
#line 1063
      tmp___3 = 2;
    }
    {
#line 1063
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1063
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1063
    poc->compno1 = __cil_tmp22;
#line 1065
    __cil_tmp23 = cio_read(cio, 1);
#line 1065
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
    }
#line 1056
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1068
  tcp->numpocs = (numpchgs + old_poc) - 1;
  return;
}
}
#line 1071 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1074
  cio = j2k->cio;
#line 1075
  numcomps = (j2k->image)->numcomps;
#line 1077
  __cil_tmp8 = cio_read(cio, 2);
#line 1077
  len = (int )__cil_tmp8;
#line 1078
  i = 0;
  }
  {
#line 1078
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (! (i < numcomps)) {
#line 1078
      goto while_break;
    }
    {
#line 1079
    __cil_tmp9 = cio_read(cio, 2);
#line 1079
    Xcrg_i = (int )__cil_tmp9;
#line 1080
    __cil_tmp10 = cio_read(cio, 2);
#line 1080
    Ycrg_i = (int )__cil_tmp10;
    }
#line 1078
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1084 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1088
  cio = j2k->cio;
#line 1090
  __cil_tmp12 = cio_read(cio, 2);
#line 1090
  len = (int )__cil_tmp12;
#line 1091
  __cil_tmp13 = cio_read(cio, 1);
#line 1091
  Ztlm = (int )__cil_tmp13;
#line 1092
  __cil_tmp14 = cio_read(cio, 1);
#line 1092
  Stlm = (int )__cil_tmp14;
#line 1093
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1094
  SP = (Stlm >> 6) & 1;
#line 1095
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1096
  i = 0;
  }
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    if (! (i < tile_tlm)) {
#line 1096
      goto while_break;
    }
    {
#line 1097
    __cil_tmp15 = cio_read(cio, ST);
#line 1097
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1098
    if (SP) {
#line 1098
      tmp = 4;
    } else {
#line 1098
      tmp = 2;
    }
    {
#line 1098
    __cil_tmp17 = cio_read(cio, tmp);
#line 1098
    Ptlm_i = (long )__cil_tmp17;
    }
#line 1096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1102 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1103
  packet_len = 0;
#line 1105
  cio = j2k->cio;
#line 1107
  __cil_tmp9 = cio_read(cio, 2);
#line 1107
  len = (int )__cil_tmp9;
#line 1108
  __cil_tmp10 = cio_read(cio, 1);
#line 1108
  Zplm = (int )__cil_tmp10;
#line 1109
  len -= 3;
  }
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! (len > 0)) {
#line 1110
      goto while_break;
    }
    {
#line 1111
    __cil_tmp11 = cio_read(cio, 4);
#line 1111
    Nplm = (int )__cil_tmp11;
#line 1112
    len -= 4;
#line 1113
    i = Nplm;
    }
    {
#line 1113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1113
      if (! (i > 0)) {
#line 1113
        goto while_break___0;
      }
      {
#line 1114
      __cil_tmp12 = cio_read(cio, 1);
#line 1114
      add = (int )__cil_tmp12;
#line 1115
      __cil_tmp13 = len;
#line 1115
      len --;
#line 1116
      packet_len = (packet_len << 7) + add;
      }
#line 1117
      if ((add & 128) == 0) {
#line 1119
        packet_len = 0;
      }
#line 1121
      if (len <= 0) {
#line 1122
        goto while_break___0;
      }
#line 1113
      __cil_tmp14 = i;
#line 1113
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1127 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1128
  packet_len = 0;
#line 1130
  cio = j2k->cio;
#line 1132
  __cil_tmp8 = cio_read(cio, 2);
#line 1132
  len = (int )__cil_tmp8;
#line 1133
  __cil_tmp9 = cio_read(cio, 1);
#line 1133
  Zplt = (int )__cil_tmp9;
#line 1134
  i = len - 3;
  }
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (i > 0)) {
#line 1134
      goto while_break;
    }
    {
#line 1135
    __cil_tmp10 = cio_read(cio, 1);
#line 1135
    add = (int )__cil_tmp10;
#line 1136
    packet_len = (packet_len << 7) + add;
    }
#line 1137
    if ((add & 128) == 0) {
#line 1139
      packet_len = 0;
    }
#line 1134
    __cil_tmp11 = i;
#line 1134
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1144 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1148
  cp = j2k->cp;
#line 1149
  cio = j2k->cio;
#line 1151
  __cil_tmp9 = cio_read(cio, 2);
#line 1151
  len = (int )__cil_tmp9;
#line 1152
  cp->ppm = 1;
#line 1154
  __cil_tmp10 = cio_read(cio, 1);
#line 1154
  Z_ppm = (int )__cil_tmp10;
#line 1155
  len -= 3;
  }
  {
#line 1156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1156
    if (! (len > 0)) {
#line 1156
      goto while_break;
    }
#line 1157
    if (cp->ppm_previous == 0) {
      {
#line 1158
      __cil_tmp11 = cio_read(cio, 4);
#line 1158
      N_ppm = (int )__cil_tmp11;
#line 1159
      len -= 4;
      }
    } else {
#line 1161
      N_ppm = cp->ppm_previous;
    }
#line 1163
    j = cp->ppm_store;
#line 1164
    if (Z_ppm == 0) {
      {
#line 1165
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1165
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1166
      cp->ppm_data_first = cp->ppm_data;
#line 1167
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1169
      __cil_tmp13 = realloc(cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1169
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1187
      cp->ppm_data_first = cp->ppm_data;
#line 1188
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1190
    i = N_ppm;
    {
#line 1190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1190
      if (! (i > 0)) {
#line 1190
        goto while_break___0;
      }
      {
#line 1191
      __cil_tmp14 = cio_read(cio, 1);
#line 1191
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1192
      j ++;
#line 1193
      __cil_tmp16 = len;
#line 1193
      len --;
      }
#line 1194
      if (len == 0) {
#line 1195
        goto while_break___0;
      }
#line 1190
      __cil_tmp17 = i;
#line 1190
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1197
    cp->ppm_previous = i - 1;
#line 1198
    cp->ppm_store = j;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1202 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 1203
  j = 0;
#line 1205
  cp = j2k->cp;
#line 1206
  tcp = cp->tcps + j2k->curtileno;
#line 1207
  cio = j2k->cio;
#line 1209
  __cil_tmp9 = cio_read(cio, 2);
#line 1209
  len = (int )__cil_tmp9;
#line 1210
  __cil_tmp10 = cio_read(cio, 1);
#line 1210
  Z_ppt = (int )__cil_tmp10;
#line 1211
  tcp->ppt = 1;
  }
#line 1212
  if (Z_ppt == 0) {
    {
#line 1213
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1213
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1214
    tcp->ppt_data_first = tcp->ppt_data;
#line 1215
    tcp->ppt_store = 0;
#line 1216
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1218
    __cil_tmp12 = realloc(tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1218
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1219
    tcp->ppt_data_first = tcp->ppt_data;
#line 1220
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1222
  j = tcp->ppt_store;
#line 1223
  i = len - 3;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i > 0)) {
#line 1223
      goto while_break;
    }
    {
#line 1224
    __cil_tmp13 = cio_read(cio, 1);
#line 1224
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1225
    j ++;
    }
#line 1223
    __cil_tmp15 = i;
#line 1223
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  tcp->ppt_store = j;
  return;
}
}
#line 1230 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;
  int __cil_tmp4 ;

  {
  {
#line 1232
  cio = j2k->cio;
#line 1233
  j2k->tlm_start = cio_tell(cio);
#line 1234
  cio_write(cio, (unsigned int )65365, 2);
#line 1235
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1236
  cio_write(cio, (unsigned int )lenp, 2);
#line 1237
  cio_write(cio, (unsigned int )0, 1);
#line 1238
  cio_write(cio, (unsigned int )80, 1);
#line 1239
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
  return;
}
}
#line 1242 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1245
  cio = j2k->cio;
#line 1247
  j2k->sot_start = cio_tell(cio);
#line 1248
  cio_write(cio, (unsigned int )65424, 2);
#line 1249
  lenp = cio_tell(cio);
#line 1250
  cio_skip(cio, 2);
#line 1251
  cio_write(cio, (unsigned int )j2k->curtileno, 2);
#line 1252
  cio_skip(cio, 4);
#line 1253
  cio_write(cio, (unsigned int )j2k->cur_tp_num, 1);
#line 1254
  cio_write(cio, (unsigned int )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1255
  __cil_tmp7 = cio_tell(cio);
#line 1255
  len = __cil_tmp7 - lenp;
#line 1256
  cio_seek(cio, lenp);
#line 1257
  cio_write(cio, (unsigned int )len, 2);
#line 1258
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1268 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  opj_tccp_t *tmp___0 ;
  int __cil_tmp29 ;

  {
  {
#line 1270
  tcp = (opj_tcp_t *)((void *)0);
#line 1271
  status = (char )0;
#line 1273
  cp = j2k->cp;
#line 1274
  cio = j2k->cio;
#line 1276
  __cil_tmp12 = cio_read(cio, 2);
#line 1276
  len = (int )__cil_tmp12;
#line 1277
  __cil_tmp13 = cio_read(cio, 2);
#line 1277
  tileno = (int )__cil_tmp13;
  }
#line 1305
  if (cp->tileno_size == 0) {
#line 1306
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1307
    (cp->tileno_size) ++;
  } else {
#line 1309
    i = 0;
    {
#line 1310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1310
      if (! (i < cp->tileno_size && (int )status == 0)) {
#line 1310
        goto while_break;
      }
#line 1311
      if (*(cp->tileno + i) == tileno) {
#line 1311
        tmp = 1;
      } else {
#line 1311
        tmp = 0;
      }
#line 1311
      status = (char )tmp;
#line 1312
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1314
    if ((int )status == 0) {
#line 1315
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1316
      (cp->tileno_size) ++;
    }
  }
  {
#line 1320
  __cil_tmp18 = cio_read(cio, 4);
#line 1320
  totlen = (int )__cil_tmp18;
  }
#line 1344
  if (! totlen) {
    {
#line 1345
    __cil_tmp19 = cio_numbytesleft(cio);
#line 1345
    totlen = __cil_tmp19 + 8;
    }
  }
  {
#line 1347
  __cil_tmp20 = cio_read(cio, 1);
#line 1347
  partno = (int )__cil_tmp20;
#line 1348
  __cil_tmp21 = cio_read(cio, 1);
#line 1348
  numparts = (int )__cil_tmp21;
#line 1350
  j2k->curtileno = tileno;
#line 1351
  j2k->cur_tp_num = partno;
#line 1352
  __cil_tmp22 = cio_getbp(cio);
#line 1352
  j2k->eot = (__cil_tmp22 - 12) + totlen;
#line 1353
  j2k->state = 16;
#line 1354
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1357
  if (j2k->cstr_info) {
#line 1358
    if (tcp->first) {
#line 1359
      if (tileno == 0) {
        {
#line 1360
        __cil_tmp23 = cio_tell(cio);
#line 1360
        (j2k->cstr_info)->main_head_end = __cil_tmp23 - 13;
        }
      }
      {
#line 1361
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1362
      __cil_tmp24 = cio_tell(cio);
#line 1362
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp24 - 12;
#line 1363
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
#line 1364
      ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
      }
#line 1365
      if (numparts) {
        {
#line 1366
        __cil_tmp25 = malloc((unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1366
        ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp25;
        }
      } else {
        {
#line 1368
        __cil_tmp26 = malloc(10UL * sizeof(opj_tp_info_t ));
#line 1368
        ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp26;
        }
      }
    } else {
#line 1371
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
    {
#line 1373
    __cil_tmp27 = cio_tell(cio);
#line 1373
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp27 - 12;
#line 1374
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1378
  if (tcp->first == 1) {
    {
#line 1380
    tmp___0 = tcp->tccps;
#line 1381
    memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1382
    tcp->ppt = 0;
#line 1383
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1384
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1385
    tcp->tccps = tmp___0;
#line 1387
    i = 0;
    }
    {
#line 1387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1387
      if (! (i < (j2k->image)->numcomps)) {
#line 1387
        goto while_break___0;
      }
#line 1388
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1387
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1390
    (cp->tcps + j2k->curtileno)->first = 0;
  }
  return;
}
}
#line 1394 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1397
  tcp = (opj_tcp_t *)((void *)0);
#line 1398
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1400
  tcd = (opj_tcd_t *)tile_coder;
#line 1401
  cp = j2k->cp;
#line 1402
  cio = j2k->cio;
#line 1404
  tcd->tp_num = j2k->tp_num;
#line 1405
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1407
  cio_write(cio, (unsigned int )65427, 2);
  }
#line 1408
  if (j2k->curtileno == 0) {
    {
#line 1409
    __cil_tmp11 = cio_tell(cio);
#line 1409
    j2k->sod_start = __cil_tmp11 + j2k->pos_correction;
    }
  }
#line 1413
  cstr_info = j2k->cstr_info;
#line 1414
  if (cstr_info) {
#line 1415
    if (! j2k->cur_tp_num) {
      {
#line 1416
      __cil_tmp12 = cio_tell(cio);
#line 1416
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp12 + j2k->pos_correction) - 1;
#line 1417
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1420
      __cil_tmp13 = cio_tell(cio);
      }
#line 1420
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp13) {
        {
#line 1421
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1432
  tcp = cp->tcps + j2k->curtileno;
#line 1433
  layno = 0;
  {
#line 1433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1433
    if (! (layno < tcp->numlayers)) {
#line 1433
      goto while_break;
    }
#line 1434
    if (tcp->rates[layno]) {
#line 1434
      tmp = j2k->sod_start / (cp->th * cp->tw);
    } else {
#line 1434
      tmp = 0;
    }
#line 1434
    tcp->rates[layno] -= (float )tmp;
#line 1433
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  if (j2k->cur_tp_num == 0) {
#line 1437
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1438
    if (cstr_info) {
#line 1439
      cstr_info->packno = 0;
    }
  }
  {
#line 1442
  __cil_tmp17 = cio_getbp(cio);
  }
  {
#line 1442
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1442
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1442
  l = __cil_tmp19;
#line 1445
  __cil_tmp20 = cio_tell(cio);
#line 1445
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1446
  cio_seek(cio, j2k->sot_start + 6);
#line 1447
  cio_write(cio, (unsigned int )totlen, 4);
#line 1448
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1450
  if (cp->cinema) {
    {
#line 1451
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1452
    cio_write(cio, (unsigned int )j2k->curtileno, 1);
#line 1453
    cio_write(cio, (unsigned int )totlen, 4);
    }
  }
  {
#line 1455
  cio_seek(cio, j2k->sot_start + totlen);
  }
  return;
}
}
#line 1458 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1459
  truncate = 0;
#line 1460
  data = (unsigned char *)((void *)0);
#line 1460
  data_ptr = (unsigned char *)((void *)0);
#line 1462
  cio = j2k->cio;
#line 1463
  curtileno = j2k->curtileno;
#line 1466
  if (j2k->cstr_info) {
    {
#line 1467
    __cil_tmp9 = cio_tell(cio);
#line 1467
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1469
    if (j2k->cur_tp_num == 0) {
      {
#line 1470
      __cil_tmp10 = cio_tell(cio);
#line 1470
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1471
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1474
  __cil_tmp11 = cio_getbp(cio);
  }
  {
#line 1474
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1474
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1474
  len = __cil_tmp13;
#line 1476
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1476
  if (len == __cil_tmp14 + 1) {
#line 1477
    truncate = 1;
  }
  {
#line 1480
  data = *(j2k->tile_data + curtileno);
#line 1481
  __cil_tmp15 = realloc(data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1481
  data = (unsigned char *)__cil_tmp15;
#line 1483
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1484
  i = 0;
  }
  {
#line 1484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1484
    if (! (i < len)) {
#line 1484
      goto while_break;
    }
    {
#line 1485
    __cil_tmp16 = cio_read(cio, 1);
#line 1485
    *(data_ptr + i) = (unsigned char )__cil_tmp16;
    }
#line 1484
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1488
  *(j2k->tile_len + curtileno) += len;
#line 1489
  *(j2k->tile_data + curtileno) = data;
#line 1491
  if (! truncate) {
#line 1492
    j2k->state = 8;
  } else {
#line 1494
    j2k->state = 64;
  }
#line 1496
  (j2k->cur_tp_num) ++;
  return;
}
}
#line 1499 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1500
  cp = j2k->cp;
#line 1501
  tcp = cp->tcps + tileno;
#line 1502
  cio = j2k->cio;
#line 1503
  numcomps = (j2k->image)->numcomps;
#line 1505
  cio_write(cio, (unsigned int )65374, 2);
  }
#line 1506
  if (numcomps <= 256) {
#line 1506
    tmp = 5;
  } else {
#line 1506
    tmp = 6;
  }
  {
#line 1506
  cio_write(cio, (unsigned int )tmp, 2);
  }
#line 1507
  if (numcomps <= 256) {
#line 1507
    tmp___0 = 1;
  } else {
#line 1507
    tmp___0 = 2;
  }
  {
#line 1507
  cio_write(cio, (unsigned int )compno, tmp___0);
#line 1508
  cio_write(cio, (unsigned int )0, 1);
#line 1509
  cio_write(cio, (unsigned int )(tcp->tccps + compno)->roishift, 1);
  }
  return;
}
}
#line 1512 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1515
  cp = j2k->cp;
#line 1516
  if (j2k->state == 16) {
#line 1516
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1516
    tmp = j2k->default_tcp;
  }
  {
#line 1516
  tcp = tmp;
#line 1517
  cio = j2k->cio;
#line 1518
  numcomps = (j2k->image)->numcomps;
#line 1520
  __cil_tmp10 = cio_read(cio, 2);
#line 1520
  len = (int )__cil_tmp10;
  }
#line 1521
  if (numcomps <= 256) {
#line 1521
    tmp___0 = 1;
  } else {
#line 1521
    tmp___0 = 2;
  }
  {
#line 1521
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1521
  compno = (int )__cil_tmp12;
#line 1522
  __cil_tmp13 = cio_read(cio, 1);
#line 1522
  roisty = (int )__cil_tmp13;
#line 1539
  __cil_tmp14 = cio_read(cio, 1);
#line 1539
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
  return;
}
}
#line 1542 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1543
  cio = j2k->cio;
#line 1545
  cio_write(cio, (unsigned int )65497, 2);
  }
  return;
}
}
#line 1555 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  int success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1560
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1561
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1561
    tcd = __cil_tmp6;
#line 1562
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1563
    i = 0;
    }
    {
#line 1563
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1563
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1563
        goto while_break;
      }
      {
#line 1564
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
#line 1565
      tileno = *((j2k->cp)->tileno + i);
#line 1566
      success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                tileno, j2k->cstr_info);
#line 1567
      free(*(j2k->tile_data + tileno));
#line 1568
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1569
      tcd_free_decode_tile(tcd, i);
      }
#line 1570
      if (success == 0) {
#line 1571
        j2k->state |= 128;
#line 1572
        goto while_break;
      }
#line 1563
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1575
    tcd_free_decode(tcd);
#line 1576
    tcd_destroy(tcd);
    }
  } else {
#line 1580
    i = 0;
    {
#line 1580
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1580
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1580
        goto while_break___0;
      }
      {
#line 1581
      tileno = *((j2k->cp)->tileno + i);
#line 1582
      free(*(j2k->tile_data + tileno));
#line 1583
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
      }
#line 1580
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1586
  if (j2k->state & 128) {
#line 1587
    j2k->state = 160;
  } else {
#line 1589
    j2k->state = 32;
  }
  return;
}
}
#line 1601 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1601
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1636 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1637
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
  return;
}
}
#line 1702 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;
  opj_dec_mstabent_t *__cil_tmp3 ;

  {
#line 1704
  e = (opj_dec_mstabent_t *)j2k_dec_mstab;
  {
#line 1704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1704
    if (! (e->id != 0)) {
#line 1704
      goto while_break;
    }
#line 1705
    if (e->id == id) {
#line 1706
      goto while_break;
    }
#line 1704
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1709
  return (e);
}
}
#line 1716 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1717
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1717
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1718
  if (! j2k) {
#line 1719
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1721
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 1721
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1722
  if (! j2k->default_tcp) {
    {
#line 1723
    free(j2k);
    }
#line 1724
    return ((opj_j2k_t *)((void *)0));
  }
#line 1727
  j2k->cinfo = cinfo;
#line 1728
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1730
  return (j2k);
}
}
#line 1733 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;
  int __cil_tmp5 ;

  {
#line 1734
  i = 0;
#line 1736
  if (j2k->tile_len != (void *)0) {
    {
#line 1737
    free(j2k->tile_len);
    }
  }
#line 1739
  if (j2k->tile_data != (void *)0) {
    {
#line 1740
    free(j2k->tile_data);
    }
  }
#line 1742
  if (j2k->default_tcp != (void *)0) {
#line 1743
    default_tcp = j2k->default_tcp;
#line 1744
    if (default_tcp->ppt_data_first != (void *)0) {
      {
#line 1745
      free(default_tcp->ppt_data_first);
      }
    }
#line 1747
    if ((j2k->default_tcp)->tccps != (void *)0) {
      {
#line 1748
      free((j2k->default_tcp)->tccps);
      }
    }
    {
#line 1750
    free(j2k->default_tcp);
    }
  }
#line 1752
  if (j2k->cp != (void *)0) {
#line 1753
    cp = j2k->cp;
#line 1754
    if (cp->tcps != (void *)0) {
#line 1755
      i = 0;
      {
#line 1755
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1755
        if (! (i < cp->tw * cp->th)) {
#line 1755
          goto while_break;
        }
#line 1756
        if ((cp->tcps + i)->ppt_data_first != (void *)0) {
          {
#line 1757
          free((cp->tcps + i)->ppt_data_first);
          }
        }
#line 1759
        if ((cp->tcps + i)->tccps != (void *)0) {
          {
#line 1760
          free((cp->tcps + i)->tccps);
          }
        }
#line 1755
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1763
      free(cp->tcps);
      }
    }
#line 1765
    if (cp->ppm_data_first != (void *)0) {
      {
#line 1766
      free(cp->ppm_data_first);
      }
    }
#line 1768
    if (cp->tileno != (void *)0) {
      {
#line 1769
      free(cp->tileno);
      }
    }
#line 1771
    if (cp->comment != (void *)0) {
      {
#line 1772
      free(cp->comment);
      }
    }
    {
#line 1775
    free(cp);
    }
  }
  {
#line 1777
  free(j2k);
  }
  return;
}
}
#line 1780 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1781
  if (j2k) {
#line 1781
    if (parameters) {
      {
#line 1783
      __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 1783
      cp = (opj_cp_t *)__cil_tmp4;
#line 1784
      cp->reduce = parameters->cp_reduce;
#line 1785
      cp->layer = parameters->cp_layer;
#line 1786
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1796
      j2k->cp = cp;
      }
    }
  }
  return;
}
}
#line 1800 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp6 ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  opj_dec_mstabent_t *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 1801
  image = (opj_image_t *)((void *)0);
#line 1803
  cinfo = j2k->cinfo;
#line 1805
  j2k->cio = cio;
#line 1806
  j2k->cstr_info = cstr_info;
#line 1807
  if (cstr_info) {
    {
#line 1808
    memset(cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1811
  image = opj_image_create0();
#line 1812
  j2k->image = image;
#line 1814
  j2k->state = 1;
  }
  {
#line 1816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1816
    if (! 1) {
#line 1816
      goto while_break;
    }
    {
#line 1818
    __cil_tmp9 = cio_read(cio, 2);
#line 1818
    id = (int )__cil_tmp9;
    }
#line 1858
    if (id >> 8 != 255) {
      {
#line 1859
      opj_image_destroy(image);
#line 1860
      __cil_tmp10 = cio_tell(cio);
#line 1860
      opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp10 - 2,
                    id);
      }
#line 1861
      return ((opj_image_t *)0);
    }
    {
#line 1863
    e = j2k_dec_mstab_lookup(id);
    }
#line 1865
    if (! (j2k->state & e->states)) {
      {
#line 1866
      opj_image_destroy(image);
#line 1867
      __cil_tmp12 = cio_tell(cio);
#line 1867
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp12 - 2, id);
      }
#line 1868
      return ((opj_image_t *)0);
    }
#line 1871
    if (e->id == 65424) {
#line 1871
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 1872
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 1873
        return (image);
      }
    }
#line 1876
    if (e->handler) {
      {
#line 1877
      (*(e->handler))(j2k);
      }
    }
#line 1879
    if (j2k->state & 128) {
#line 1880
      return ((opj_image_t *)((void *)0));
    }
#line 1882
    if (j2k->state == 32) {
#line 1883
      goto while_break;
    }
#line 1885
    if (j2k->state == 64) {
#line 1886
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1889
  if (j2k->state == 64) {
    {
#line 1890
    j2k_read_eoc(j2k);
    }
  }
#line 1893
  if (j2k->state != 32) {
    {
#line 1894
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 1897
  return (image);
}
}
#line 1904 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_dec_mstabent_t *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1905
  image = (opj_image_t *)((void *)0);
#line 1909
  cinfo = j2k->cinfo;
#line 1911
  j2k->cio = cio;
#line 1914
  image = opj_image_create0();
#line 1915
  j2k->image = image;
#line 1917
  j2k->state = 1;
#line 1920
  jpt_init_msg_header(& header);
#line 1922
  jpt_read_msg_header(cinfo, cio, & header);
#line 1924
  position = cio_tell(cio);
  }
#line 1925
  if (header.Class_Id != 6U) {
    {
#line 1926
    opj_image_destroy(image);
#line 1927
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 1928
    return ((opj_image_t *)0);
  }
  {
#line 1931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1931
    if (! 1) {
#line 1931
      goto while_break;
    }
    {
#line 1932
    e = (opj_dec_mstabent_t *)((void *)0);
#line 1935
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 1935
    if (! __cil_tmp12) {
      {
#line 1936
      j2k_read_eoc(j2k);
      }
#line 1937
      return (image);
    }
    {
#line 1940
    __cil_tmp13 = cio_tell(cio);
    }
#line 1940
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 1941
      jpt_read_msg_header(cinfo, cio, & header);
#line 1942
      position = cio_tell(cio);
      }
#line 1943
      if (header.Class_Id != 4U) {
        {
#line 1944
        opj_image_destroy(image);
#line 1945
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\nV");
        }
#line 1946
        return ((opj_image_t *)0);
      }
    }
    {
#line 1950
    __cil_tmp15 = cio_read(cio, 2);
#line 1950
    id = (int )__cil_tmp15;
    }
#line 1951
    if (id >> 8 != 255) {
      {
#line 1952
      opj_image_destroy(image);
#line 1953
      __cil_tmp16 = cio_tell(cio);
#line 1953
      opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp16 - 2,
                    id);
      }
#line 1954
      return ((opj_image_t *)0);
    }
    {
#line 1956
    e = j2k_dec_mstab_lookup(id);
    }
#line 1957
    if (! (j2k->state & e->states)) {
      {
#line 1958
      opj_image_destroy(image);
#line 1959
      __cil_tmp18 = cio_tell(cio);
#line 1959
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n\240\032V", __cil_tmp18 - 2,
                    id);
      }
#line 1960
      return ((opj_image_t *)0);
    }
#line 1962
    if (e->handler) {
      {
#line 1963
      (*(e->handler))(j2k);
      }
    }
#line 1965
    if (j2k->state == 32) {
#line 1966
      goto while_break;
    }
#line 1968
    if (j2k->state == 64) {
#line 1969
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1972
  if (j2k->state == 64) {
    {
#line 1973
    j2k_read_eoc(j2k);
    }
  }
#line 1976
  if (j2k->state != 32) {
    {
#line 1977
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 1980
  return (image);
}
}
#line 1987 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 1988
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1988
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1989
  if (j2k) {
#line 1990
    j2k->cinfo = cinfo;
  }
#line 1992
  return (j2k);
}
}
#line 1995 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;
  int __cil_tmp4 ;

  {
#line 1998
  if (! j2k) {
#line 1998
    return;
  }
#line 1999
  if (j2k->cp != (void *)0) {
#line 2000
    cp = j2k->cp;
#line 2002
    if (cp->comment) {
      {
#line 2003
      free(cp->comment);
      }
    }
#line 2005
    if (cp->matrice) {
      {
#line 2006
      free(cp->matrice);
      }
    }
#line 2008
    tileno = 0;
    {
#line 2008
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2008
      if (! (tileno < cp->tw * cp->th)) {
#line 2008
        goto while_break;
      }
      {
#line 2009
      free((cp->tcps + tileno)->tccps);
      }
#line 2008
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2011
    free(cp->tcps);
#line 2012
    free(cp);
    }
  }
  {
#line 2015
  free(j2k);
  }
  return;
}
}
#line 2018 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  opj_poc_t *tcp_poc ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int p ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 2020
  cp = (opj_cp_t *)((void *)0);
#line 2022
  if (! j2k) {
#line 2023
    return;
  } else
#line 2022
  if (! parameters) {
#line 2023
    return;
  } else
#line 2022
  if (! image) {
#line 2023
    return;
  }
  {
#line 2027
  __cil_tmp9 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 2027
  cp = (opj_cp_t *)__cil_tmp9;
#line 2030
  j2k->cp = cp;
#line 2033
  cp->tw = 1;
#line 2034
  cp->th = 1;
#line 2039
  cp->cinema = parameters->cp_cinema;
#line 2040
  cp->max_comp_size = parameters->max_comp_size;
#line 2041
  cp->rsiz = parameters->cp_rsiz;
#line 2042
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2043
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2044
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2047
  if (parameters->cp_matrice) {
    {
#line 2048
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2049
    __cil_tmp11 = malloc(array_size);
#line 2049
    cp->matrice = (int *)__cil_tmp11;
#line 2050
    memcpy(cp->matrice, parameters->cp_matrice, array_size);
    }
  }
#line 2054
  cp->tdx = parameters->cp_tdx;
#line 2055
  cp->tdy = parameters->cp_tdy;
#line 2058
  cp->tx0 = parameters->cp_tx0;
#line 2059
  cp->ty0 = parameters->cp_ty0;
#line 2062
  if (parameters->cp_comment) {
    {
#line 2063
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2063
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2063
    cp->comment = (char *)__cil_tmp13;
    }
#line 2064
    if (cp->comment) {
      {
#line 2065
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2073
  if (parameters->tile_size_on) {
    {
#line 2074
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2075
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2077
    cp->tdx = image->x1 - cp->tx0;
#line 2078
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2081
  if (parameters->tp_on) {
#line 2082
    cp->tp_flag = parameters->tp_flag;
#line 2083
    cp->tp_on = (char )1;
  }
#line 2086
  cp->img_size = 0;
#line 2087
  i = 0;
  {
#line 2087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2087
    if (! (i < image->numcomps)) {
#line 2087
      goto while_break;
    }
#line 2088
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2087
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2151
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2151
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2153
  tileno = 0;
  }
  {
#line 2153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2153
    if (! (tileno < cp->tw * cp->th)) {
#line 2153
      goto while_break___0;
    }
#line 2154
    tcp = cp->tcps + tileno;
#line 2155
    tcp->numlayers = parameters->tcp_numlayers;
#line 2156
    j = 0;
    {
#line 2156
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2156
      if (! (j < tcp->numlayers)) {
#line 2156
        goto while_break___1;
      }
#line 2157
      if (cp->cinema) {
#line 2158
        if (cp->fixed_quality) {
#line 2159
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2161
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2163
      if (cp->fixed_quality) {
#line 2164
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2166
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2156
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2170
    tcp->csty = parameters->csty;
#line 2171
    tcp->prg = parameters->prog_order;
#line 2172
    tcp->mct = (int )parameters->tcp_mct;
#line 2174
    numpocs_tile = 0;
#line 2175
    tcp->POC = 0;
#line 2176
    if (parameters->numpocs) {
#line 2178
      tcp->POC = 1;
#line 2179
      i = 0;
      {
#line 2179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2179
        if (! (i < parameters->numpocs)) {
#line 2179
          goto while_break___2;
        }
#line 2180
        if (tileno == parameters->POC[i].tile - 1) {
          _L: /* CIL Label */ 
#line 2181
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2182
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2183
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2184
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2185
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2186
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2187
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2188
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2189
          numpocs_tile ++;
        } else
#line 2180
        if (parameters->POC[i].tile == -1) {
#line 2180
          goto _L;
        }
#line 2179
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2192
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2194
      tcp->numpocs = 0;
    }
    {
#line 2197
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2197
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2199
    i = 0;
    }
    {
#line 2199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2199
      if (! (i < image->numcomps)) {
#line 2199
        goto while_break___3;
      }
      {
#line 2200
      tccp = tcp->tccps + i;
#line 2201
      tccp->csty = parameters->csty & 1;
#line 2202
      tccp->numresolutions = parameters->numresolution;
#line 2203
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2204
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2205
      tccp->cblksty = parameters->mode;
      }
#line 2206
      if (parameters->irreversible) {
#line 2206
        tmp = 0;
      } else {
#line 2206
        tmp = 1;
      }
#line 2206
      tccp->qmfbid = tmp;
#line 2207
      if (parameters->irreversible) {
#line 2207
        tmp___0 = 2;
      } else {
#line 2207
        tmp___0 = 0;
      }
#line 2207
      tccp->qntsty = tmp___0;
#line 2208
      tccp->numgbits = 2;
#line 2209
      if (i == parameters->roi_compno) {
#line 2210
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2212
        tccp->roishift = 0;
      }
#line 2215
      if (parameters->cp_cinema) {
#line 2218
        tccp->prcw[0] = 7;
#line 2219
        tccp->prch[0] = 7;
#line 2221
        j = 1;
        {
#line 2221
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2221
          if (! (j < tccp->numresolutions)) {
#line 2221
            goto while_break___4;
          }
#line 2222
          tccp->prcw[j] = 8;
#line 2223
          tccp->prch[j] = 8;
#line 2221
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2226
      if (parameters->csty & 1) {
#line 2227
        p = 0;
#line 2228
        j = tccp->numresolutions - 1;
        {
#line 2228
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2228
          if (! (j >= 0)) {
#line 2228
            goto while_break___5;
          }
#line 2229
          if (p < parameters->res_spec) {
#line 2231
            if (parameters->prcw_init[p] < 1) {
#line 2232
              tccp->prcw[j] = 1;
            } else {
              {
#line 2234
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2237
            if (parameters->prch_init[p] < 1) {
#line 2238
              tccp->prch[j] = 1;
            } else {
              {
#line 2240
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2244
            res_spec = parameters->res_spec;
#line 2245
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2246
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2248
            if (size_prcw < 1) {
#line 2249
              tccp->prcw[j] = 1;
            } else {
              {
#line 2251
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2254
            if (size_prch < 1) {
#line 2255
              tccp->prch[j] = 1;
            } else {
              {
#line 2257
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2260
          p ++;
#line 2228
          __cil_tmp39 = j;
#line 2228
          j --;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2264
        j = 0;
        {
#line 2264
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2264
          if (! (j < tccp->numresolutions)) {
#line 2264
            goto while_break___6;
          }
#line 2265
          tccp->prcw[j] = 15;
#line 2266
          tccp->prch[j] = 15;
#line 2264
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2271
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
      }
#line 2199
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2153
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 2276 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/j2k.c"
int j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___10 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  opj_tcp_t *tcp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_tcd_t *__cil_tmp20 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  int tot_num_tp ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 2278
  cp = (opj_cp_t *)((void *)0);
#line 2280
  tcd = (opj_tcd_t *)((void *)0);
#line 2282
  j2k->cio = cio;
#line 2283
  j2k->image = image;
#line 2285
  cp = j2k->cp;
#line 2290
  j2k->cstr_info = cstr_info;
#line 2291
  if (cstr_info) {
    {
#line 2293
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2293
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2294
    cstr_info->image_w = image->x1 - image->x0;
#line 2295
    cstr_info->image_h = image->y1 - image->y0;
#line 2296
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2297
    cstr_info->tw = cp->tw;
#line 2298
    cstr_info->th = cp->th;
#line 2299
    cstr_info->tile_x = cp->tdx;
#line 2300
    cstr_info->tile_y = cp->tdy;
#line 2301
    cstr_info->tile_Ox = cp->tx0;
#line 2302
    cstr_info->tile_Oy = cp->ty0;
#line 2303
    cstr_info->numcomps = image->numcomps;
#line 2304
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2305
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2305
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2306
    compno___10 = 0;
    }
    {
#line 2306
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2306
      if (! (compno___10 < image->numcomps)) {
#line 2306
        goto while_break;
      }
#line 2307
      *(cstr_info->numdecompos + compno___10) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2306
      compno___10 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2309
    cstr_info->D_max = 0.;
#line 2310
    cstr_info->main_head_start = cio_tell(cio);
#line 2311
    cstr_info->maxmarknum = 100;
#line 2312
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2312
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2313
    cstr_info->marknum = 0;
    }
  }
  {
#line 2317
  j2k_write_soc(j2k);
#line 2318
  j2k_write_siz(j2k);
#line 2319
  j2k_write_cod(j2k);
#line 2320
  j2k_write_qcd(j2k);
  }
#line 2322
  if (cp->cinema) {
#line 2323
    compno = 1;
    {
#line 2323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2323
      if (! (compno < image->numcomps)) {
#line 2323
        goto while_break___0;
      }
      {
#line 2324
      j2k_write_coc(j2k, compno);
#line 2325
      j2k_write_qcc(j2k, compno);
      }
#line 2323
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2329
  compno = 0;
  {
#line 2329
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2329
    if (! (compno < image->numcomps)) {
#line 2329
      goto while_break___1;
    }
#line 2330
    tcp = cp->tcps + 0;
#line 2331
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2332
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2329
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2334
  if (cp->comment != (void *)0) {
    {
#line 2335
    j2k_write_com(j2k);
    }
  }
  {
#line 2338
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2340
  if (cp->cinema) {
    {
#line 2341
    j2k_write_tlm(j2k);
    }
#line 2342
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2343
      j2k_write_poc(j2k);
      }
    }
  }
#line 2351
  if (cstr_info) {
    {
#line 2352
    __cil_tmp19 = cio_tell(cio);
#line 2352
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2358
  tcd = tcd_create(j2k->cinfo);
#line 2361
  tileno = 0;
  }
  {
#line 2361
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2361
    if (! (tileno < cp->tw * cp->th)) {
#line 2361
      goto while_break___2;
    }
    {
#line 2363
    tilepartno = 0;
#line 2365
    acc_pack_num = 0;
#line 2369
    tcp___0 = cp->tcps + tileno;
#line 2370
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2372
    j2k->curtileno = tileno;
#line 2373
    j2k->cur_tp_num = 0;
#line 2374
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2376
    if (tileno == 0) {
      {
#line 2377
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2379
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2383
    if (cstr_info) {
      {
#line 2384
      __cil_tmp25 = cio_tell(cio);
#line 2384
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
      }
    }
#line 2388
    pino = 0;
    {
#line 2388
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2388
      if (! (pino <= tcp___0->numpocs)) {
#line 2388
        goto while_break___3;
      }
      {
#line 2390
      tcd->cur_pino = pino;
#line 2393
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2394
      tcd->tp_pos = cp->tp_pos;
#line 2396
      tilepartno = 0;
      }
      {
#line 2396
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2396
        if (! (tilepartno < tot_num_tp)) {
#line 2396
          goto while_break___4;
        }
#line 2397
        j2k->tp_num = tilepartno;
#line 2399
        if (cstr_info) {
          {
#line 2400
          __cil_tmp28 = cio_tell(cio);
#line 2400
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp28 + j2k->pos_correction;
          }
        }
        {
#line 2403
        j2k_write_sot(j2k);
        }
#line 2405
        if (j2k->cur_tp_num == 0) {
#line 2405
          if ((unsigned int )cp->cinema == 0U) {
#line 2406
            compno = 1;
            {
#line 2406
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2406
              if (! (compno < image->numcomps)) {
#line 2406
                goto while_break___5;
              }
              {
#line 2407
              j2k_write_coc(j2k, compno);
#line 2408
              j2k_write_qcc(j2k, compno);
              }
#line 2406
              compno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2410
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2411
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2416
        if (cstr_info) {
          {
#line 2417
          __cil_tmp30 = cio_tell(cio);
#line 2417
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp30 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2421
        j2k_write_sod(j2k, tcd);
        }
#line 2424
        if (cstr_info) {
          {
#line 2425
          __cil_tmp31 = cio_tell(cio);
#line 2425
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp31 + j2k->pos_correction) - 1;
#line 2427
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2429
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2431
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2435
        (j2k->cur_tp_num) ++;
#line 2396
        tilepartno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2388
      pino ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2438
    if (cstr_info) {
      {
#line 2439
      __cil_tmp35 = cio_tell(cio);
#line 2439
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp35 + j2k->pos_correction) - 1;
      }
    }
#line 2361
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2462
  tcd_free_encode(tcd);
#line 2463
  tcd_destroy(tcd);
#line 2465
  free(j2k->cur_totnum_tp);
#line 2467
  j2k_write_eoc(j2k);
  }
#line 2469
  if (cstr_info) {
    {
#line 2470
    __cil_tmp37 = cio_tell(cio);
#line 2470
    cstr_info->codestream_size = __cil_tmp37 + j2k->pos_correction;
#line 2475
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2491
  return (1);
}
}
#line 29 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/image.c"
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) 
{ 
  int compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = malloc((unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(int ));
#line 61
      comp->data = (int *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 70
  return (image);
}
}
#line 73 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  int i ;
  opj_image_comp_t *image_comp ;
  int __cil_tmp4 ;

  {
#line 75
  if (image) {
#line 76
    if (image->comps) {
#line 78
      i = 0;
      {
#line 78
      while (1) {
        while_continue: /* CIL Label */ ;
#line 78
        if (! (i < image->numcomps)) {
#line 78
          goto while_break;
        }
#line 79
        image_comp = image->comps + i;
#line 80
        if (image_comp->data) {
          {
#line 81
          free(image_comp->data);
          }
        }
#line 78
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 84
      free(image->comps);
      }
    }
    {
#line 86
    free(image);
    }
  }
  return;
}
}
#line 35 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/event.c"
static char *i2a(unsigned int i , char *a , unsigned int r ) 
{ 
  char *__cil_tmp4 ;

  {
#line 36
  if (i / r > 0U) {
    {
#line 36
    a = i2a(i / r, a, r);
    }
  }
#line 37
  *a = *("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" + i % r);
#line 38
  return (a + 1);
}
}
#line 50 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/event.c"
static char *_itoa(int i , char *a , int r ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 51
  if (r < 2 || r > 36) {
#line 51
    tmp = 10;
  } else {
#line 51
    tmp = r;
  }
#line 51
  r = tmp;
#line 52
  if (i < 0) {
    {
#line 53
    *a = (char )'-';
#line 54
    __cil_tmp5 = i2a((unsigned int )(- i), a + 1, (unsigned int )r);
#line 54
    *__cil_tmp5 = (char )0;
    }
  } else {
    {
#line 56
    __cil_tmp6 = i2a((unsigned int )i, a, (unsigned int )r);
#line 56
    *__cil_tmp6 = (char )0;
    }
  }
#line 57
  return (a);
}
}
#line 64 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/event.c"
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) 
{ 
  opj_event_mgr_t *previous ;

  {
#line 65
  if (cinfo) {
#line 66
    previous = cinfo->event_mgr;
#line 67
    cinfo->event_mgr = event_mgr;
#line 68
    cinfo->client_data = context;
#line 69
    return (previous);
  }
#line 72
  return ((opj_event_mgr_t *)((void *)0));
}
}
#line 75 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/event.c"
int opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt  , ...) 
{ 
  opj_msg_callback msg_handler ;
  opj_event_mgr_t *event_mgr ;
  va_list arg ;
  int str_length ;
  char message[512] ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long tmp ;

  {
#line 77
  msg_handler = (opj_msg_callback )((void *)0);
#line 79
  event_mgr = cinfo->event_mgr;
#line 80
  if (event_mgr != (void *)0) {
    {
#line 82
    if (event_type == 1) {
#line 82
      goto case_1;
    }
#line 85
    if (event_type == 2) {
#line 85
      goto case_2;
    }
#line 88
    if (event_type == 4) {
#line 88
      goto case_4;
    }
#line 91
    goto switch_default;
    case_1: /* CIL Label */ 
#line 83
    msg_handler = event_mgr->error_handler;
#line 84
    goto switch_break;
    case_2: /* CIL Label */ 
#line 86
    msg_handler = event_mgr->warning_handler;
#line 87
    goto switch_break;
    case_4: /* CIL Label */ 
#line 89
    msg_handler = event_mgr->info_handler;
#line 90
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 92
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 94
    if (msg_handler == (void *)0) {
#line 95
      return (0);
    }
  } else {
#line 98
    return (0);
  }
#line 101
  if (fmt != (void *)0) {
#line 101
    if (event_mgr != (void *)0) {
      {
#line 105
      memset((char *)message, 0, (unsigned long )512);
#line 107
      __builtin_va_start((void *)arg, fmt);
#line 109
      __cil_tmp9 = strlen(fmt);
      }
#line 109
      if (__cil_tmp9 > 512UL) {
#line 109
        tmp = (unsigned long )512;
      } else {
        {
#line 109
        __cil_tmp10 = strlen(fmt);
#line 109
        tmp = __cil_tmp10;
        }
      }
      {
#line 109
      str_length = (int )tmp;
#line 111
      vsprintf((char *)message, fmt, (void *)arg);
#line 113
      __builtin_va_end((void *)arg);
#line 116
      (*msg_handler)((char const   *)((char *)message), cinfo->client_data);
      }
    }
  }
#line 119
  return (1);
}
}
#line 36 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 37
  cp = (opj_cp_t *)((void *)0);
#line 38
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 38
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 39
  if (! cio) {
#line 39
    return ((opj_cio_t *)((void *)0));
  }
#line 40
  cio->cinfo = cinfo;
#line 41
  if (buffer) {
#line 41
    if (length) {
#line 43
      cio->openmode = 1;
#line 44
      cio->buffer = buffer;
#line 45
      cio->length = length;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 47
  if (! buffer) {
#line 47
    if (! length) {
#line 47
      if (cinfo) {
#line 49
        cio->openmode = 2;
        {
#line 51
        if ((int )cinfo->codec_format == 0) {
#line 51
          goto case_0;
        }
#line 54
        if ((int )cinfo->codec_format == 2) {
#line 54
          goto case_2;
        }
#line 57
        goto switch_default;
        case_0: /* CIL Label */ 
#line 52
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 53
        goto switch_break;
        case_2: /* CIL Label */ 
#line 55
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 56
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 58
        free(cio);
        }
#line 59
        return ((opj_cio_t *)((void *)0));
        switch_break: /* CIL Label */ ;
        }
        {
#line 61
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 62
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 62
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 63
        if (! cio->buffer) {
          {
#line 64
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n");
#line 65
          free(cio);
          }
#line 66
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
        {
        {
#line 70
        free(cio);
        }
        }
        }
#line 71
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
      {
      {
#line 70
      free(cio);
      }
      }
      }
#line 71
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
    {
    {
#line 70
    free(cio);
    }
    }
    }
#line 71
    return ((opj_cio_t *)((void *)0));
  }
#line 75
  cio->start = cio->buffer;
#line 76
  cio->end = cio->buffer + cio->length;
#line 77
  cio->bp = cio->buffer;
#line 79
  return (cio);
}
}
#line 82 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 83
  if (cio) {
#line 84
    if (cio->openmode == 2) {
      {
#line 86
      free(cio->buffer);
      }
    }
    {
#line 89
    free(cio);
    }
  }
  return;
}
}
#line 99 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 100
  return ((int )(cio->bp - cio->start));
}
}
#line 108 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 


  {
#line 109
  cio->bp = cio->start + pos;
  return;
}
}
#line 115 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 


  {
#line 116
  return ((int )(cio->end - cio->bp));
}
}
#line 122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 123
  return (cio->bp);
}
}
#line 129 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
int cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 130
  if (cio->bp >= cio->end) {
    {
#line 131
    opj_event_msg(cio->cinfo, 1, "write error\n\032V");
    }
#line 132
    return (0);
  }
#line 134
  __cil_tmp3 = cio->bp;
#line 134
  (cio->bp) ++;
#line 134
  *__cil_tmp3 = v;
#line 135
  return (1);
}
}
#line 141 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 142
  if (cio->bp >= cio->end) {
    {
#line 143
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 144
    return ((unsigned char )0);
  }
#line 146
  __cil_tmp2 = cio->bp;
#line 146
  (cio->bp) ++;
#line 146
  return (*__cil_tmp2);
}
}
#line 155 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  i = n - 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i >= 0)) {
#line 157
      goto while_break;
    }
    {
#line 158
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255U));
    }
#line 158
    if (! __cil_tmp5) {
#line 159
      return ((unsigned int )0);
    }
#line 157
    __cil_tmp6 = i;
#line 157
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return ((unsigned int )n);
}
}
#line 171 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 174
  v = (unsigned int )0;
#line 175
  i = n - 1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i >= 0)) {
#line 175
      goto while_break;
    }
    {
#line 176
    __cil_tmp5 = cio_bytein(cio);
    }
#line 176
    v += (unsigned int )((int )__cil_tmp5 << (i << 3));
#line 175
    __cil_tmp6 = i;
#line 175
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (v);
}
}
#line 186 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 


  {
#line 187
  cio->bp += n;
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) ;
#line 51
static int bio_getbit(opj_bio_t *bio ) ;
#line 57
static int bio_byteout(opj_bio_t *bio ) ;
#line 63
static int bio_bytein(opj_bio_t *bio ) ;
#line 75 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
static int bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = tmp;
#line 78
  if (bio->bp >= bio->end) {
#line 79
    return (1);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (unsigned char )(bio->buf >> 8);
#line 82
  return (0);
}
}
#line 85 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
static int bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = tmp;
#line 88
  if (bio->bp >= bio->end) {
#line 89
    return (1);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (0);
}
}
#line 95 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) 
{ 
  int __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0) {
    {
#line 97
    bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= (unsigned int )(b << bio->ct);
  return;
}
}
#line 103 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
static int bio_getbit(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0) {
    {
#line 105
    bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((int )((bio->buf >> bio->ct) & 1U));
}
}
#line 117 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
opj_bio_t *bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
void bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free(bio);
    }
  }
  return;
}
}
#line 128 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
int bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return ((int )(bio->bp - bio->start));
}
}
#line 132 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (unsigned int )0;
#line 137
  bio->ct = 8;
  return;
}
}
#line 140 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = (unsigned int )0;
#line 145
  bio->ct = 0;
  return;
}
}
#line 148 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
void bio_write(opj_bio_t *bio , int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 150
  i = n - 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i >= 0)) {
#line 150
      goto while_break;
    }
    {
#line 151
    bio_putbit(bio, (v >> i) & 1);
    }
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 155 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
int bio_read(opj_bio_t *bio , int n ) 
{ 
  int i ;
  int v ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  v = 0;
#line 158
  i = n - 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    __cil_tmp5 = bio_getbit(bio);
    }
#line 159
    v += __cil_tmp5 << i;
#line 158
    __cil_tmp6 = i;
#line 158
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (v);
}
}
#line 164 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
int bio_flush(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 165
  bio->ct = 0;
#line 166
  __cil_tmp2 = bio_byteout(bio);
  }
#line 166
  if (__cil_tmp2) {
#line 167
    return (1);
  }
#line 169
  if (bio->ct == 7) {
    {
#line 170
    bio->ct = 0;
#line 171
    __cil_tmp3 = bio_byteout(bio);
    }
#line 171
    if (__cil_tmp3) {
#line 172
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/doner/openjpeg/openjpeg-65e5ff0/libopenjpeg/bio.c"
int bio_inalign(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 179
  bio->ct = 0;
#line 180
  if ((bio->buf & 255U) == 255U) {
    {
#line 181
    __cil_tmp2 = bio_bytein(bio);
    }
#line 181
    if (__cil_tmp2) {
#line 182
      return (1);
    }
#line 184
    bio->ct = 0;
  }
#line 186
  return (0);
}
}
#line 152 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 134 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 54 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 18 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.h"
int opterr ;
#line 19
int optind ;
#line 20
int optopt ;
#line 21
int optreset ;
#line 22
char const   *optarg ;
#line 24
int getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int getopt_long(int argc , char * const  argv[] , char const   *optstring , struct option *longopts ,
                int totlen ) ;
#line 51 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 42 "/doner/openjpeg/openjpeg-65e5ff0/codec/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 84 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
void decode_help_display(void) 
{ 


  {
  {
#line 85
  fprintf(stdout, "HELP\n----\n\n");
#line 86
  fprintf(stdout, "- the -h option displays this help information on screen\n\n");
#line 89
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n");
#line 95
  fprintf(stdout, "\n");
#line 96
  fprintf(stdout, "\n");
#line 97
  fprintf(stdout, "  -ImgDir \n");
#line 98
  fprintf(stdout, "\tImage file Directory path \n");
#line 99
  fprintf(stdout, "  -OutFor \n");
#line 100
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 101
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 102
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n\220");
#line 103
  fprintf(stdout, "  -i <compressed file>\n");
#line 104
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n");
#line 105
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 106
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 107
  fprintf(stdout, "  -o <decompressed file>\n");
#line 108
  fprintf(stdout, "    REQUIRED\n");
#line 109
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA files\n");
#line 110
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 111
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 112
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 113
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n");
#line 114
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 115
  fprintf(stdout, "    will be written to the file.\n");
#line 116
  fprintf(stdout, "  -r <reduce factor>\n");
#line 117
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 118
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 119
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 120
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 121
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 122
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 123
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 124
  fprintf(stdout, "    are decoded.\n");
#line 125
  fprintf(stdout, "  -x  \n");
#line 126
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 127
  fprintf(stdout, "\n");
#line 138
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 143 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 146
  num_images = 0;
#line 150
  dir = opendir((char const   *)imgdirpath);
  }
#line 151
  if (! dir) {
    {
#line 152
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 153
    return (0);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    content = readdir(dir);
    }
#line 156
    if (! (content != (void *)0)) {
#line 156
      goto while_break;
    }
    {
#line 157
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 157
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 157
    if (__cil_tmp7 == 0) {
#line 158
      goto while_continue;
    } else
#line 157
    if (__cil_tmp8 == 0) {
#line 158
      goto while_continue;
    }
#line 159
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (num_images);
}
}
#line 164 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 167
  i = 0;
#line 171
  dir = opendir((char const   *)imgdirpath);
  }
#line 172
  if (! dir) {
    {
#line 173
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 174
    return (1);
  } else {
    {
#line 176
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    content = readdir(dir);
    }
#line 179
    if (! (content != (void *)0)) {
#line 179
      goto while_break;
    }
    {
#line 180
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 180
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 180
    if (__cil_tmp8 == 0) {
#line 181
      goto while_continue;
    } else
#line 180
    if (__cil_tmp9 == 0) {
#line 181
      goto while_continue;
    }
    {
#line 183
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 184
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (0);
}
}
#line 189 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[12] ;
  static int const   format[12] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 191
  extension[0] = "pgx";
#line 191
  extension[1] = "pnm";
#line 191
  extension[2] = "pgm";
#line 191
  extension[3] = "ppm";
#line 191
  extension[4] = "bmp";
#line 191
  extension[5] = "tif";
#line 191
  extension[6] = "raw";
#line 191
  extension[7] = "tga";
#line 191
  extension[8] = "j2k";
#line 191
  extension[9] = "jp2";
#line 191
  extension[10] = "jpt";
#line 191
  extension[11] = "j2c";
#line 192
  format[0] = 11;
#line 192
  format[1] = 10;
#line 192
  format[2] = 10;
#line 192
  format[3] = 10;
#line 192
  format[4] = 12;
#line 192
  format[5] = 14;
#line 192
  format[6] = 15;
#line 192
  format[7] = 16;
#line 192
  format[8] = 0;
#line 192
  format[9] = 1;
#line 192
  format[10] = 2;
#line 192
  format[11] = 0;
#line 193
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 193
  ext = __cil_tmp6;
  }
#line 194
  if (ext == (void *)0) {
#line 195
    return (- 1);
  }
#line 196
  ext ++;
#line 197
  if (ext) {
#line 198
    i = (unsigned int )0;
    {
#line 198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 198
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 198
        goto while_break;
      }
      {
#line 199
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
      }
#line 199
      if (__cil_tmp8 == 0) {
#line 200
        return (format[i]);
      }
#line 198
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 205
  return (- 1);
}
}
#line 208 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 210
  temp1 = "\002";
#line 212
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 213
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 214
  parameters->decod_format = get_file_format((char *)image_filename);
  }
#line 215
  if (parameters->decod_format == -1) {
#line 216
    return ((char )1);
  }
  {
#line 217
  sprintf((char *)infilename, "%s/%s", img_fol->imgdirpath, (char *)image_filename);
#line 218
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 221
  __cil_tmp12 = strtok((char *)image_filename, ".");
#line 221
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 222
    if (! (temp_p != (void *)0)) {
#line 222
      goto while_break;
    }
    {
#line 223
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 224
    sprintf((char *)temp1, ".%s\240\032V", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if ((int )img_fol->set_out_format == 1) {
    {
#line 227
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 228
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 230
  return ((char )0);
}
}
#line 234 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  option_t long_option[2] ;
  char const   optlist[12] ;
  int c ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp14 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *index___11 ;

  {
#line 237
  long_option[0].name = "ImgDir";
#line 237
  long_option[0].has_arg = 1;
#line 237
  long_option[0].flag = (int *)((void *)0);
#line 237
  long_option[0].val = 'y';
#line 237
  long_option[1].name = "OutFor";
#line 237
  long_option[1].has_arg = 1;
#line 237
  long_option[1].flag = (int *)((void *)0);
#line 237
  long_option[1].val = 'O';
#line 242
  optlist = "i:o:r:l:hx:";
#line 250
  totlen = (int )sizeof(long_option);
#line 251
  img_fol->set_out_format = (char )0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 253
    __cil_tmp10 = getopt_long(argc, (char * const  [])argv, (char const   *)optlist,
                              (option_t *)long_option, totlen);
#line 253
    c = __cil_tmp10;
    }
#line 254
    if (c == -1) {
#line 255
      goto while_break;
    }
    {
#line 257
    if (c == 'i') {
#line 257
      goto case_105;
    }
#line 264
    if (c == 2) {
#line 264
      goto case_2;
    }
#line 264
    if (c == 1) {
#line 264
      goto case_2;
    }
#line 264
    if (c == 0) {
#line 264
      goto case_2;
    }
#line 278
    if (c == 'o') {
#line 278
      goto case_111;
    }
#line 288
    if (c == 16) {
#line 288
      goto case_16;
    }
#line 288
    if (c == 15) {
#line 288
      goto case_16;
    }
#line 288
    if (c == 14) {
#line 288
      goto case_16;
    }
#line 288
    if (c == 12) {
#line 288
      goto case_16;
    }
#line 288
    if (c == 10) {
#line 288
      goto case_16;
    }
#line 288
    if (c == 11) {
#line 288
      goto case_16;
    }
#line 300
    if (c == 'O') {
#line 300
      goto case_79;
    }
#line 308
    if (c == 11) {
#line 308
      goto case_11___0;
    }
#line 311
    if (c == 10) {
#line 311
      goto case_10___0;
    }
#line 314
    if (c == 12) {
#line 314
      goto case_12___0;
    }
#line 317
    if (c == 14) {
#line 317
      goto case_14___0;
    }
#line 320
    if (c == 15) {
#line 320
      goto case_15___0;
    }
#line 323
    if (c == 16) {
#line 323
      goto case_16___0;
    }
#line 337
    if (c == 'r') {
#line 337
      goto case_114;
    }
#line 346
    if (c == 'l') {
#line 346
      goto case_108;
    }
#line 354
    if (c == 'h') {
#line 354
      goto case_104;
    }
#line 360
    if (c == 'y') {
#line 360
      goto case_121;
    }
#line 368
    if (c == 'x') {
#line 368
      goto case_120;
    }
#line 448
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 259
    infile = optarg;
#line 260
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 264
    if (parameters->decod_format == 2) {
#line 264
      goto case_2;
    }
#line 264
    if (parameters->decod_format == 1) {
#line 264
      goto case_2;
    }
#line 264
    if (parameters->decod_format == 0) {
#line 264
      goto case_2;
    }
#line 266
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 265
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 267
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 270
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 272
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 274
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 280
    outfile = optarg;
#line 281
    parameters->cod_format = get_file_format(outfile);
    }
    {
#line 288
    if (parameters->cod_format == 16) {
#line 288
      goto case_16;
    }
#line 288
    if (parameters->cod_format == 15) {
#line 288
      goto case_16;
    }
#line 288
    if (parameters->cod_format == 14) {
#line 288
      goto case_16;
    }
#line 288
    if (parameters->cod_format == 12) {
#line 288
      goto case_16;
    }
#line 288
    if (parameters->cod_format == 10) {
#line 288
      goto case_16;
    }
#line 288
    if (parameters->cod_format == 11) {
#line 288
      goto case_16;
    }
#line 290
    goto switch_default___0;
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 289
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 291
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outfile);
    }
#line 292
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 294
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 296
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 303
    of = optarg;
#line 304
    sprintf((char *)outformat, ".%s", of);
#line 305
    img_fol->set_out_format = (char )1;
#line 306
    parameters->cod_format = get_file_format((char *)outformat);
    }
    {
#line 308
    if (parameters->cod_format == 11) {
#line 308
      goto case_11___0;
    }
#line 311
    if (parameters->cod_format == 10) {
#line 311
      goto case_10___0;
    }
#line 314
    if (parameters->cod_format == 12) {
#line 314
      goto case_12___0;
    }
#line 317
    if (parameters->cod_format == 14) {
#line 317
      goto case_14___0;
    }
#line 320
    if (parameters->cod_format == 15) {
#line 320
      goto case_15___0;
    }
#line 323
    if (parameters->cod_format == 16) {
#line 323
      goto case_16___0;
    }
#line 326
    goto switch_default___1;
    case_11___0: /* CIL Label */ 
#line 309
    img_fol->out_format = "pgx";
#line 310
    goto switch_break___2;
    case_10___0: /* CIL Label */ 
#line 312
    img_fol->out_format = "ppm";
#line 313
    goto switch_break___2;
    case_12___0: /* CIL Label */ 
#line 315
    img_fol->out_format = "bmp";
#line 316
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 318
    img_fol->out_format = "tif";
#line 319
    goto switch_break___2;
    case_15___0: /* CIL Label */ 
#line 321
    img_fol->out_format = "raw";
#line 322
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
#line 324
    img_fol->out_format = "raw";
#line 325
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 327
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            (char *)outformat);
    }
#line 328
    return (1);
#line 329
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 332
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 339
    sscanf((char const   *)optarg, "%d", & parameters->cp_reduce);
    }
#line 341
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 348
    sscanf((char const   *)optarg, "%d", & parameters->cp_layer);
    }
#line 350
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 355
    decode_help_display();
    }
#line 356
    return (1);
    case_121: /* CIL Label */ 
    {
#line 362
    __cil_tmp18 = strlen((char const   *)optarg);
#line 362
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 362
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 363
    strcpy(img_fol->imgdirpath, (char const   *)optarg);
#line 364
    img_fol->set_imgdir = (char )1;
    }
#line 366
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 370
    index___11 = optarg;
#line 371
    strncpy(indexfilename, (char const   *)index___11, (unsigned long )4096);
    }
#line 373
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 449
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, optarg);
    }
#line 450
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  if ((int )img_fol->set_imgdir == 1) {
#line 456
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 457
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 458
      return (1);
    }
#line 460
    if ((int )img_fol->set_out_format == 0) {
      {
#line 461
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 462
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 463
      return (1);
    }
#line 465
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 466
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 467
      return (1);
    }
  } else
#line 470
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 471
    fprintf(stderr, "Error: One of the options -i or -ImgDir must be specified\n");
    }
    {
#line 472
    fprintf(stderr, "Error: When using -i, -o must be used\n");
    }
    {
#line 473
    fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2/j2c -o *.pgm/ppm/pnm/pgx/bmp/tif/raw/tga(+ options)\n");
    }
    }
#line 474
    return (1);
  } else
#line 470
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 471
    fprintf(stderr, "Error: One of the options -i or -ImgDir must be specified\n");
    }
    {
#line 472
    fprintf(stderr, "Error: When using -i, -o must be used\n");
    }
    {
#line 473
    fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2/j2c -o *.pgm/ppm/pnm/pgx/bmp/tif/raw/tga(+ options)\n");
    }
    }
#line 474
    return (1);
  }
#line 478
  return (0);
}
}
#line 486 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 487
  stream = (FILE *)client_data;
#line 488
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 493 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 494
  stream = (FILE *)client_data;
#line 495
  fprintf(stream, "[WARNING] %s", msg);
  }
  return;
}
}
#line 500 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 502
  fprintf(stdout, "[INFO] %s", msg);
  }
  return;
}
}
#line 507 "/doner/openjpeg/openjpeg-65e5ff0/codec/j2k_to_image.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char __cil_tmp25 ;
  FILE *__cil_tmp26 ;
  long __cil_tmp27 ;
  void *__cil_tmp28 ;
  opj_dinfo_t *__cil_tmp29 ;
  opj_cio_t *__cil_tmp30 ;
  opj_image_t *__cil_tmp31 ;
  opj_image_t *__cil_tmp32 ;
  char bSuccess ;
  int __cil_tmp34 ;
  opj_dinfo_t *__cil_tmp35 ;
  opj_cio_t *__cil_tmp36 ;
  opj_image_t *__cil_tmp37 ;
  opj_image_t *__cil_tmp38 ;
  char bSuccess___0 ;
  int __cil_tmp40 ;
  opj_dinfo_t *__cil_tmp41 ;
  opj_cio_t *__cil_tmp42 ;
  opj_image_t *__cil_tmp43 ;
  opj_image_t *__cil_tmp44 ;
  char bSuccess___1 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 511
  image = (opj_image_t *)((void *)0);
#line 512
  fsrc = (FILE *)((void *)0);
#line 513
  src = (unsigned char *)((void *)0);
#line 518
  dinfo = (opj_dinfo_t *)((void *)0);
#line 519
  cio = (opj_cio_t *)((void *)0);
#line 524
  memset(& event_mgr, 0, sizeof(opj_event_mgr_t ));
#line 525
  event_mgr.error_handler = & error_callback;
#line 526
  event_mgr.warning_handler = & warning_callback;
#line 527
  event_mgr.info_handler = & info_callback;
#line 530
  opj_set_default_decoder_parameters(& parameters);
#line 533
  *((char *)indexfilename) = (char )0;
#line 534
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 537
  __cil_tmp18 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 537
  if (__cil_tmp18 == 1) {
#line 538
    return (1);
  }
#line 542
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 543
    num_images = get_num_images(img_fol.imgdirpath);
#line 545
    __cil_tmp20 = malloc(sizeof(dircnt_t ));
#line 545
    dirptr = (dircnt_t *)__cil_tmp20;
    }
#line 546
    if (dirptr) {
      {
#line 547
      __cil_tmp21 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 547
      dirptr->filename_buf = (char *)__cil_tmp21;
#line 548
      __cil_tmp22 = malloc((unsigned long )num_images * sizeof(char *));
#line 548
      dirptr->filename = (char **)__cil_tmp22;
      }
#line 550
      if (! dirptr->filename_buf) {
#line 551
        return (0);
      }
#line 553
      i = 0;
      {
#line 553
      while (1) {
        while_continue: /* CIL Label */ ;
#line 553
        if (! (i < num_images)) {
#line 553
          goto while_break;
        }
#line 554
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 553
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 557
    __cil_tmp24 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 557
    if (__cil_tmp24 == 1) {
#line 558
      return (0);
    }
#line 560
    if (num_images == 0) {
      {
#line 561
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 562
      return (0);
    }
  } else {
#line 565
    num_images = 1;
  }
#line 569
  imageno = 0;
  {
#line 569
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 569
    if (! (imageno < num_images)) {
#line 569
      goto while_break___0;
    }
    {
#line 570
    image = (opj_image_t *)((void *)0);
#line 571
    fprintf(stderr, "\n\003\364\240\032V");
    }
#line 573
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 574
      __cil_tmp25 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 574
      if (__cil_tmp25) {
        {
#line 575
        fprintf(stderr, "skipping file...\n");
        }
#line 576
        goto while_continue___0;
      }
    }
    {
#line 582
    fsrc = fopen((char const   *)((char *)parameters.infile), "rb");
    }
#line 583
    if (! fsrc) {
      {
#line 584
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.infile);
      }
#line 585
      return (1);
    }
    {
#line 587
    fseek(fsrc, (long )0, 2);
#line 588
    __cil_tmp27 = ftell(fsrc);
#line 588
    file_length = (int )__cil_tmp27;
#line 589
    fseek(fsrc, (long )0, 0);
#line 590
    __cil_tmp28 = malloc((unsigned long )file_length);
#line 590
    src = (unsigned char *)__cil_tmp28;
#line 591
    fread(src, (unsigned long )1, (unsigned long )file_length, fsrc);
#line 592
    fclose(fsrc);
    }
    {
#line 598
    if (parameters.decod_format == 0) {
#line 598
      goto case_0;
    }
#line 640
    if (parameters.decod_format == 1) {
#line 640
      goto case_1;
    }
#line 682
    if (parameters.decod_format == 2) {
#line 682
      goto case_2;
    }
#line 724
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 603
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 606
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 609
    opj_setup_decoder(dinfo, & parameters);
#line 612
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 615
    if (*((char *)indexfilename)) {
      {
#line 616
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 618
      image = opj_decode(dinfo, cio);
      }
    }
#line 619
    if (! image) {
      {
#line 620
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 621
      opj_destroy_decompress(dinfo);
#line 622
      opj_cio_close(cio);
      }
#line 623
      return (1);
    }
    {
#line 627
    opj_cio_close(cio);
    }
#line 630
    if (*((char *)indexfilename)) {
      {
#line 632
      __cil_tmp34 = write_index_file(& cstr_info, (char *)indexfilename);
#line 632
      bSuccess = (char )__cil_tmp34;
      }
#line 633
      if (bSuccess) {
        {
#line 634
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 638
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 645
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 648
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 651
    opj_setup_decoder(dinfo, & parameters);
#line 654
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 657
    if (*((char *)indexfilename)) {
      {
#line 658
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 660
      image = opj_decode(dinfo, cio);
      }
    }
#line 661
    if (! image) {
      {
#line 662
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 663
      opj_destroy_decompress(dinfo);
#line 664
      opj_cio_close(cio);
      }
#line 665
      return (1);
    }
    {
#line 669
    opj_cio_close(cio);
    }
#line 672
    if (*((char *)indexfilename)) {
      {
#line 674
      __cil_tmp40 = write_index_file(& cstr_info, (char *)indexfilename);
#line 674
      bSuccess___0 = (char )__cil_tmp40;
      }
#line 675
      if (bSuccess___0) {
        {
#line 676
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 680
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 687
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 690
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 693
    opj_setup_decoder(dinfo, & parameters);
#line 696
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 699
    if (*((char *)indexfilename)) {
      {
#line 700
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 702
      image = opj_decode(dinfo, cio);
      }
    }
#line 703
    if (! image) {
      {
#line 704
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 705
      opj_destroy_decompress(dinfo);
#line 706
      opj_cio_close(cio);
      }
#line 707
      return (1);
    }
    {
#line 711
    opj_cio_close(cio);
    }
#line 714
    if (*((char *)indexfilename)) {
      {
#line 716
      __cil_tmp46 = write_index_file(& cstr_info, (char *)indexfilename);
#line 716
      bSuccess___1 = (char )__cil_tmp46;
      }
#line 717
      if (bSuccess___1) {
        {
#line 718
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 722
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 725
    fprintf(stderr, "skipping file..\n\220");
    }
#line 726
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 730
    free(src);
#line 731
    src = (unsigned char *)((void *)0);
    }
    {
#line 736
    if (parameters.cod_format == 10) {
#line 736
      goto case_10;
    }
#line 745
    if (parameters.cod_format == 11) {
#line 745
      goto case_11;
    }
#line 754
    if (parameters.cod_format == 12) {
#line 754
      goto case_12;
    }
#line 763
    if (parameters.cod_format == 14) {
#line 763
      goto case_14;
    }
#line 772
    if (parameters.cod_format == 15) {
#line 772
      goto case_15;
    }
#line 781
    if (parameters.cod_format == 16) {
#line 781
      goto case_16;
    }
#line 735
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 737
    __cil_tmp47 = imagetopnm(image, (char const   *)((char *)parameters.outfile));
    }
#line 737
    if (__cil_tmp47) {
      {
#line 738
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 741
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 743
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 746
    __cil_tmp48 = imagetopgx(image, (char const   *)((char *)parameters.outfile));
    }
#line 746
    if (__cil_tmp48) {
      {
#line 747
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 750
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 752
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 755
    __cil_tmp49 = imagetobmp(image, (char const   *)((char *)parameters.outfile));
    }
#line 755
    if (__cil_tmp49) {
      {
#line 756
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 759
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 761
    goto switch_break___0;
    case_14: /* CIL Label */ 
    {
#line 764
    __cil_tmp50 = imagetotif(image, (char const   *)((char *)parameters.outfile));
    }
#line 764
    if (__cil_tmp50) {
      {
#line 765
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 768
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 770
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 773
    __cil_tmp51 = imagetoraw(image, (char const   *)((char *)parameters.outfile));
    }
#line 773
    if (__cil_tmp51) {
      {
#line 774
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 777
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 779
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 782
    __cil_tmp52 = imagetotga(image, (char const   *)((char *)parameters.outfile));
    }
#line 782
    if (__cil_tmp52) {
      {
#line 783
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 786
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 788
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 792
    if (dinfo) {
      {
#line 793
      opj_destroy_decompress(dinfo);
      }
    }
#line 796
    if (*((char *)indexfilename)) {
      {
#line 797
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 799
    opj_image_destroy(image);
    }
#line 569
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 802
  return (0);
}
}
#line 269 "/doner/openjpeg/openjpeg-65e5ff0/codec/../libs/libtiff/tiffio.h"
extern char const   *TIFFGetVersion(void) ;
#line 271
extern TIFFCodec *TIFFFindCODEC(uint16  ) ;
#line 272
extern TIFFCodec *TIFFRegisterCODEC(uint16  , char const   * , TIFFInitMethod  ) ;
#line 273
extern void TIFFUnRegisterCODEC(TIFFCodec * ) ;
#line 274
extern int TIFFIsCODECConfigured(uint16  ) ;
#line 275
extern TIFFCodec *TIFFGetConfiguredCODECs(void) ;
#line 281
extern tdata_t _TIFFmalloc(tsize_t  ) ;
#line 282
extern tdata_t _TIFFrealloc(tdata_t  , tsize_t  ) ;
#line 283
extern void _TIFFmemset(tdata_t  , int  , tsize_t  ) ;
#line 284
extern void _TIFFmemcpy(tdata_t  , tdata_t  , tsize_t  ) ;
#line 285
extern int _TIFFmemcmp(tdata_t  , tdata_t  , tsize_t  ) ;
#line 286
extern void _TIFFfree(tdata_t  ) ;
#line 291
extern int TIFFGetTagListCount(TIFF * ) ;
#line 292
extern ttag_t TIFFGetTagListEntry(TIFF * , int tag_index ) ;
#line 318
extern void TIFFMergeFieldInfo(TIFF * , TIFFFieldInfo [] , int  ) ;
#line 319
extern TIFFFieldInfo *TIFFFindFieldInfo(TIFF * , ttag_t  , TIFFDataType  ) ;
#line 320
extern TIFFFieldInfo *TIFFFindFieldInfoByName(TIFF * , char const   * , TIFFDataType  ) ;
#line 322
extern TIFFFieldInfo *TIFFFieldWithTag(TIFF * , ttag_t  ) ;
#line 323
extern TIFFFieldInfo *TIFFFieldWithName(TIFF * , char const   * ) ;
#line 335
extern TIFFTagMethods *TIFFAccessTagMethods(TIFF * ) ;
#line 336
extern void *TIFFGetClientInfo(TIFF * , char const   * ) ;
#line 337
extern void TIFFSetClientInfo(TIFF * , void * , char const   * ) ;
#line 339
extern void TIFFCleanup(TIFF * ) ;
#line 340
extern void TIFFClose(TIFF * ) ;
#line 341
extern int TIFFFlush(TIFF * ) ;
#line 342
extern int TIFFFlushData(TIFF * ) ;
#line 343
extern int TIFFGetField(TIFF * , ttag_t   , ...) ;
#line 344
extern int TIFFVGetField(TIFF * , ttag_t  , va_list  ) ;
#line 345
extern int TIFFGetFieldDefaulted(TIFF * , ttag_t   , ...) ;
#line 346
extern int TIFFVGetFieldDefaulted(TIFF * , ttag_t  , va_list  ) ;
#line 347
extern int TIFFReadDirectory(TIFF * ) ;
#line 348
extern int TIFFReadCustomDirectory(TIFF * , toff_t  , TIFFFieldInfo [] , size_t  ) ;
#line 350
extern int TIFFReadEXIFDirectory(TIFF * , toff_t  ) ;
#line 351
extern tsize_t TIFFScanlineSize(TIFF * ) ;
#line 352
extern tsize_t TIFFRasterScanlineSize(TIFF * ) ;
#line 353
extern tsize_t TIFFStripSize(TIFF * ) ;
#line 354
extern tsize_t TIFFRawStripSize(TIFF * , tstrip_t  ) ;
#line 355
extern tsize_t TIFFVStripSize(TIFF * , uint32  ) ;
#line 356
extern tsize_t TIFFTileRowSize(TIFF * ) ;
#line 357
extern tsize_t TIFFTileSize(TIFF * ) ;
#line 358
extern tsize_t TIFFVTileSize(TIFF * , uint32  ) ;
#line 359
extern uint32 TIFFDefaultStripSize(TIFF * , uint32  ) ;
#line 360
extern void TIFFDefaultTileSize(TIFF * , uint32 * , uint32 * ) ;
#line 361
extern int TIFFFileno(TIFF * ) ;
#line 362
extern int TIFFSetFileno(TIFF * , int  ) ;
#line 363
extern thandle_t TIFFClientdata(TIFF * ) ;
#line 364
extern thandle_t TIFFSetClientdata(TIFF * , thandle_t  ) ;
#line 365
extern int TIFFGetMode(TIFF * ) ;
#line 366
extern int TIFFSetMode(TIFF * , int  ) ;
#line 367
extern int TIFFIsTiled(TIFF * ) ;
#line 368
extern int TIFFIsByteSwapped(TIFF * ) ;
#line 369
extern int TIFFIsUpSampled(TIFF * ) ;
#line 370
extern int TIFFIsMSB2LSB(TIFF * ) ;
#line 371
extern int TIFFIsBigEndian(TIFF * ) ;
#line 372
extern TIFFReadWriteProc TIFFGetReadProc(TIFF * ) ;
#line 373
extern TIFFReadWriteProc TIFFGetWriteProc(TIFF * ) ;
#line 374
extern TIFFSeekProc TIFFGetSeekProc(TIFF * ) ;
#line 375
extern TIFFCloseProc TIFFGetCloseProc(TIFF * ) ;
#line 376
extern TIFFSizeProc TIFFGetSizeProc(TIFF * ) ;
#line 377
extern TIFFMapFileProc TIFFGetMapFileProc(TIFF * ) ;
#line 378
extern TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF * ) ;
#line 379
extern uint32 TIFFCurrentRow(TIFF * ) ;
#line 380
extern tdir_t TIFFCurrentDirectory(TIFF * ) ;
#line 381
extern tdir_t TIFFNumberOfDirectories(TIFF * ) ;
#line 382
extern uint32 TIFFCurrentDirOffset(TIFF * ) ;
#line 383
extern tstrip_t TIFFCurrentStrip(TIFF * ) ;
#line 384
extern ttile_t TIFFCurrentTile(TIFF * ) ;
#line 385
extern int TIFFReadBufferSetup(TIFF * , tdata_t  , tsize_t  ) ;
#line 386
extern int TIFFWriteBufferSetup(TIFF * , tdata_t  , tsize_t  ) ;
#line 387
extern int TIFFSetupStrips(TIFF * ) ;
#line 388
extern int TIFFWriteCheck(TIFF * , int  , char const   * ) ;
#line 389
extern void TIFFFreeDirectory(TIFF * ) ;
#line 390
extern int TIFFCreateDirectory(TIFF * ) ;
#line 391
extern int TIFFLastDirectory(TIFF * ) ;
#line 392
extern int TIFFSetDirectory(TIFF * , tdir_t  ) ;
#line 393
extern int TIFFSetSubDirectory(TIFF * , uint32  ) ;
#line 394
extern int TIFFUnlinkDirectory(TIFF * , tdir_t  ) ;
#line 395
extern int TIFFSetField(TIFF * , ttag_t   , ...) ;
#line 396
extern int TIFFVSetField(TIFF * , ttag_t  , va_list  ) ;
#line 397
extern int TIFFWriteDirectory(TIFF * ) ;
#line 398
extern int TIFFCheckpointDirectory(TIFF * ) ;
#line 399
extern int TIFFRewriteDirectory(TIFF * ) ;
#line 400
extern int TIFFReassignTagToIgnore(enum TIFFIgnoreSense  , int  ) ;
#line 410
extern void TIFFPrintDirectory(TIFF * , FILE * , long  ) ;
#line 411
extern int TIFFReadScanline(TIFF * , tdata_t  , uint32  , tsample_t  ) ;
#line 412
extern int TIFFWriteScanline(TIFF * , tdata_t  , uint32  , tsample_t  ) ;
#line 413
extern int TIFFReadRGBAImage(TIFF * , uint32  , uint32  , uint32 * , int  ) ;
#line 414
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 417
extern int TIFFReadRGBAStrip(TIFF * , tstrip_t  , uint32 * ) ;
#line 418
extern int TIFFReadRGBATile(TIFF * , uint32  , uint32  , uint32 * ) ;
#line 419
extern int TIFFRGBAImageOK(TIFF * , char [1024] ) ;
#line 420
extern int TIFFRGBAImageBegin(TIFFRGBAImage * , TIFF * , int  , char [1024] ) ;
#line 421
extern int TIFFRGBAImageGet(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
#line 422
extern void TIFFRGBAImageEnd(TIFFRGBAImage * ) ;
#line 423
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 427
extern TIFF *TIFFFdOpen(int  , char const   * , char const   * ) ;
#line 428
extern TIFF *TIFFClientOpen(char const   * , char const   * , thandle_t  , TIFFReadWriteProc  ,
                            TIFFReadWriteProc  , TIFFSeekProc  , TIFFCloseProc  ,
                            TIFFSizeProc  , TIFFMapFileProc  , TIFFUnmapFileProc  ) ;
#line 434
extern char const   *TIFFFileName(TIFF * ) ;
#line 435
extern char const   *TIFFSetFileName(TIFF * , char const   * ) ;
#line 436
extern void TIFFError(char const   * , char const   *  , ...) ;
#line 437
extern void TIFFErrorExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 438
extern void TIFFWarning(char const   * , char const   *  , ...) ;
#line 439
extern void TIFFWarningExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 440
extern TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler  ) ;
#line 441
extern TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt  ) ;
#line 442
extern TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler  ) ;
#line 443
extern TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt  ) ;
#line 444
extern TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc  ) ;
#line 445
extern ttile_t TIFFComputeTile(TIFF * , uint32  , uint32  , uint32  , tsample_t  ) ;
#line 446
extern int TIFFCheckTile(TIFF * , uint32  , uint32  , uint32  , tsample_t  ) ;
#line 447
extern ttile_t TIFFNumberOfTiles(TIFF * ) ;
#line 448
extern tsize_t TIFFReadTile(TIFF * , tdata_t  , uint32  , uint32  , uint32  , tsample_t  ) ;
#line 450
extern tsize_t TIFFWriteTile(TIFF * , tdata_t  , uint32  , uint32  , uint32  , tsample_t  ) ;
#line 452
extern tstrip_t TIFFComputeStrip(TIFF * , uint32  , tsample_t  ) ;
#line 453
extern tstrip_t TIFFNumberOfStrips(TIFF * ) ;
#line 454
extern tsize_t TIFFReadEncodedStrip(TIFF * , tstrip_t  , tdata_t  , tsize_t  ) ;
#line 455
extern tsize_t TIFFReadRawStrip(TIFF * , tstrip_t  , tdata_t  , tsize_t  ) ;
#line 456
extern tsize_t TIFFReadEncodedTile(TIFF * , ttile_t  , tdata_t  , tsize_t  ) ;
#line 457
extern tsize_t TIFFReadRawTile(TIFF * , ttile_t  , tdata_t  , tsize_t  ) ;
#line 458
extern tsize_t TIFFWriteEncodedStrip(TIFF * , tstrip_t  , tdata_t  , tsize_t  ) ;
#line 459
extern tsize_t TIFFWriteRawStrip(TIFF * , tstrip_t  , tdata_t  , tsize_t  ) ;
#line 460
extern tsize_t TIFFWriteEncodedTile(TIFF * , ttile_t  , tdata_t  , tsize_t  ) ;
#line 461
extern tsize_t TIFFWriteRawTile(TIFF * , ttile_t  , tdata_t  , tsize_t  ) ;
#line 462
extern int TIFFDataWidth(TIFFDataType  ) ;
#line 463
extern void TIFFSetWriteOffset(TIFF * , toff_t  ) ;
#line 464
extern void TIFFSwabShort(uint16 * ) ;
#line 465
extern void TIFFSwabLong(uint32 * ) ;
#line 466
extern void TIFFSwabDouble(double * ) ;
#line 467
extern void TIFFSwabArrayOfShort(uint16 * , unsigned long  ) ;
#line 468
extern void TIFFSwabArrayOfTriples(uint8 * , unsigned long  ) ;
#line 469
extern void TIFFSwabArrayOfLong(uint32 * , unsigned long  ) ;
#line 470
extern void TIFFSwabArrayOfDouble(double * , unsigned long  ) ;
#line 471
extern void TIFFReverseBits(unsigned char * , unsigned long  ) ;
#line 472
extern unsigned char const   *TIFFGetBitRevTable(int  ) ;
#line 478
extern double LogL16toY(int  ) ;
#line 479
extern double LogL10toY(int  ) ;
#line 480
extern void XYZtoRGB24(float * , uint8 * ) ;
#line 481
extern int uv_decode(double * , double * , int  ) ;
#line 482
extern void LogLuv24toXYZ(uint32  , float * ) ;
#line 483
extern void LogLuv32toXYZ(uint32  , float * ) ;
#line 491
extern int LogL16fromY(double  , int  ) ;
#line 492
extern int LogL10fromY(double  , int  ) ;
#line 493
extern int uv_encode(double  , double  , int  ) ;
#line 494
extern uint32 LogLuv24fromXYZ(float * , int  ) ;
#line 495
extern uint32 LogLuv32fromXYZ(float * , int  ) ;
#line 499
extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB * , TIFFDisplay * , float * ) ;
#line 500
extern void TIFFCIELabToXYZ(TIFFCIELabToRGB * , uint32  , int32  , int32  , float * ,
                            float * , float * ) ;
#line 502
extern void TIFFXYZToRGB(TIFFCIELabToRGB * , float  , float  , float  , uint32 * ,
                         uint32 * , uint32 * ) ;
#line 505
extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB * , float * , float * ) ;
#line 506
extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB * , uint32  , int32  , int32  , uint32 * ,
                           uint32 * , uint32 * ) ;
#line 44 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
static int int_floorlog2___15(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 46
  l = 0;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (a > 1)) {
#line 46
      goto while_break;
    }
#line 47
    a >>= 1;
#line 46
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (l);
}
}
#line 57 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
static int int_ceildivpow2___15(int a , int b ) 
{ 


  {
#line 58
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 66 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
static int int_ceildiv___15(int a , int b ) 
{ 


  {
#line 67
  return (((a + b) - 1) / b);
}
}
#line 102 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int tga_readheader(FILE *fp , int *bits_per_pixel , int *width , int *height , int *flip_image ) 
{ 
  int palette_size ;
  tga_header tga ;
  uint8 *id ;
  void *__cil_tmp9 ;

  {
#line 107
  if (! bits_per_pixel) {
#line 108
    return (0);
  } else
#line 107
  if (! width) {
#line 108
    return (0);
  } else
#line 107
  if (! height) {
#line 108
    return (0);
  } else
#line 107
  if (! flip_image) {
#line 108
    return (0);
  }
  {
#line 111
  fread((uint8 *)(& tga), sizeof(tga_header ), (unsigned long )1, fp);
#line 113
  *bits_per_pixel = (int )tga.pixel_depth;
#line 115
  *width = (int )tga.image_width;
#line 116
  *height = (int )tga.image_height;
  }
#line 119
  if (tga.id_length) {
    {
#line 121
    __cil_tmp9 = malloc((unsigned long )tga.id_length);
#line 121
    id = (uint8 *)__cil_tmp9;
#line 122
    fread(id, (unsigned long )tga.id_length, (unsigned long )1, fp);
#line 123
    free(id);
    }
  }
#line 129
  if ((int )tga.image_type > 8) {
    {
#line 131
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 132
    return (0);
  }
#line 135
  *flip_image = ! ((int )tga.image_desc & 32);
#line 138
  palette_size = (int )tga.colour_map_length * ((int )tga.colour_map_entry_size / 8);
#line 140
  if (palette_size > 0) {
    {
#line 142
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 143
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 145
  return (1);
}
}
#line 148 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height , int flip_image ) 
{ 
  tga_header tga ;

  {
#line 152
  if (! bits_per_pixel) {
#line 153
    return (0);
  } else
#line 152
  if (! width) {
#line 153
    return (0);
  } else
#line 152
  if (! height) {
#line 153
    return (0);
  }
  {
#line 155
  memset(& tga, 0, sizeof(tga_header ));
#line 157
  tga.pixel_depth = (uint8 )bits_per_pixel;
#line 158
  tga.image_width = (uint16 )width;
#line 159
  tga.image_height = (uint16 )height;
#line 160
  tga.image_type = (uint8 )2;
#line 161
  tga.image_desc = (uint8 )8;
  }
#line 163
  if (flip_image) {
#line 164
    tga.image_desc |= 32;
  }
  {
#line 167
  fwrite((uint8 *)(& tga), sizeof(tga_header ), (unsigned long )1, fp);
  }
#line 169
  return (1);
}
}
#line 172 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  uint32 image_width ;
  uint32 image_height ;
  uint32 pixel_bit_depth ;
  uint32 x ;
  uint32 y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  int mono ;
  int save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;
  opj_image_t *__cil_tmp24 ;
  uint32 tmp___1 ;
  uint32 tmp___2 ;
  int index___12 ;
  uint8 r ;
  uint8 g ;
  uint8 b ;
  int __cil_tmp31 ;
  uint32 __cil_tmp32 ;
  uint8 r___0 ;
  uint8 g___0 ;
  uint8 b___0 ;
  uint8 a ;
  int __cil_tmp37 ;
  uint32 __cil_tmp38 ;
  uint32 __cil_tmp39 ;

  {
  {
#line 177
  flip_image = 0;
#line 186
  f = fopen(filename, "rb");
  }
#line 187
  if (! f) {
    {
#line 188
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 189
    return ((opj_image_t *)0);
  }
  {
#line 192
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 192
  if (! __cil_tmp20) {
#line 193
    return ((opj_image_t *)((void *)0));
  }
#line 196
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
#line 197
    return ((opj_image_t *)((void *)0));
  }
  {
#line 200
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 202
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 203
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 205
  if (mono) {
#line 206
    color_space = (OPJ_COLOR_SPACE )2;
#line 207
    if (save_alpha) {
#line 207
      tmp = 2;
    } else {
#line 207
      tmp = 1;
    }
#line 207
    numcomps = tmp;
  } else {
#line 210
    if (save_alpha) {
#line 210
      tmp___0 = 4;
    } else {
#line 210
      tmp___0 = 3;
    }
#line 210
    numcomps = tmp___0;
#line 211
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 214
  subsampling_dx = parameters->subsampling_dx;
#line 215
  subsampling_dy = parameters->subsampling_dy;
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < numcomps)) {
#line 217
      goto while_break;
    }
#line 218
    cmptparm[i].prec = 8;
#line 219
    cmptparm[i].bpp = 8;
#line 220
    cmptparm[i].sgnd = 0;
#line 221
    cmptparm[i].dx = subsampling_dx;
#line 222
    cmptparm[i].dy = subsampling_dy;
#line 223
    cmptparm[i].w = (int )image_width;
#line 224
    cmptparm[i].h = (int )image_height;
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 230
  if (! image) {
#line 231
    return ((opj_image_t *)((void *)0));
  }
#line 234
  image->x0 = parameters->image_offset_x0;
#line 235
  image->y0 = parameters->image_offset_y0;
#line 236
  if (! image->x0) {
#line 236
    tmp___1 = (image_width - 1U) * (unsigned int )subsampling_dx + 1U;
  } else {
#line 236
    tmp___1 = ((unsigned int )image->x0 + (image_width - 1U) * (unsigned int )subsampling_dx) + 1U;
  }
#line 236
  image->x1 = (int )tmp___1;
#line 237
  if (! image->y0) {
#line 237
    tmp___2 = (image_height - 1U) * (unsigned int )subsampling_dy + 1U;
  } else {
#line 237
    tmp___2 = ((unsigned int )image->y0 + (image_height - 1U) * (unsigned int )subsampling_dy) + 1U;
  }
#line 237
  image->y1 = (int )tmp___2;
#line 240
  y = (uint32 )0;
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (y < image_height)) {
#line 240
      goto while_break___0;
    }
#line 244
    if (flip_image) {
#line 245
      index___12 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 247
      index___12 = (int )(y * image_width);
    }
#line 249
    if (numcomps == 3) {
#line 251
      x = (uint32 )0;
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (! (x < image_width)) {
#line 251
          goto while_break___1;
        }
        {
#line 254
        fread(& b, (unsigned long )1, (unsigned long )1, f);
#line 255
        fread(& g, (unsigned long )1, (unsigned long )1, f);
#line 256
        fread(& r, (unsigned long )1, (unsigned long )1, f);
#line 258
        *((image->comps + 0)->data + index___12) = (int )r;
#line 259
        *((image->comps + 1)->data + index___12) = (int )g;
#line 260
        *((image->comps + 2)->data + index___12) = (int )b;
#line 261
        index___12 ++;
        }
#line 251
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 264
    if (numcomps == 4) {
#line 266
      x = (uint32 )0;
      {
#line 266
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 266
        if (! (x < image_width)) {
#line 266
          goto while_break___2;
        }
        {
#line 269
        fread(& b___0, (unsigned long )1, (unsigned long )1, f);
#line 270
        fread(& g___0, (unsigned long )1, (unsigned long )1, f);
#line 271
        fread(& r___0, (unsigned long )1, (unsigned long )1, f);
#line 272
        fread(& a, (unsigned long )1, (unsigned long )1, f);
#line 274
        *((image->comps + 0)->data + index___12) = (int )r___0;
#line 275
        *((image->comps + 1)->data + index___12) = (int )g___0;
#line 276
        *((image->comps + 2)->data + index___12) = (int )b___0;
#line 277
        *((image->comps + 3)->data + index___12) = (int )a;
#line 278
        index___12 ++;
        }
#line 266
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 282
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 240
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 285
  return (image);
}
}
#line 288 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  int write_alpha ;
  int i ;
  uint32 alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  uint8 value ;
  float scale ;
  FILE *fdest ;
  FILE *__cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int __cil_tmp21 ;
  uint32 index___13 ;
  int __cil_tmp23 ;
  uint32 __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  {
#line 298
  fdest = fopen(outfile, "wb");
  }
#line 299
  if (! fdest) {
    {
#line 300
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 301
    return (1);
  }
#line 304
  i = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (i < image->numcomps - 1)) {
#line 304
      goto while_break;
    }
#line 305
    if ((image->comps + 0)->dx != (image->comps + (i + 1))->dx) {
      {
      {
      {
#line 308
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 309
      return (1);
    } else
#line 305
    if ((image->comps + 0)->dy != (image->comps + (i + 1))->dy) {
      {
      {
      {
#line 308
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 309
      return (1);
    } else
#line 305
    if ((image->comps + 0)->prec != (image->comps + (i + 1))->prec) {
      {
      {
      {
#line 308
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 309
      return (1);
    }
#line 304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  width = (image->comps + 0)->w;
#line 314
  height = (image->comps + 0)->h;
#line 317
  write_alpha = image->numcomps == 2 || image->numcomps == 4;
#line 320
  if (write_alpha) {
#line 320
    tmp = 32;
  } else {
#line 320
    tmp = 24;
  }
  {
#line 320
  bpp = tmp;
#line 321
  __cil_tmp21 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 321
  if (! __cil_tmp21) {
#line 322
    return (1);
  }
#line 324
  alpha_channel = (uint32 )(image->numcomps - 1);
#line 326
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 328
  y = 0;
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 328
    if (! (y < height)) {
#line 328
      goto while_break___0;
    }
#line 329
    index___13 = (uint32 )(y * width);
#line 331
    x = 0;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      if (! (x < width)) {
#line 331
        goto while_break___1;
      }
#line 332
      r = (float )*((image->comps + 0)->data + index___13);
#line 334
      if (image->numcomps > 2) {
#line 335
        g = (float )*((image->comps + 1)->data + index___13);
#line 336
        b = (float )*((image->comps + 2)->data + index___13);
      } else {
#line 339
        g = r;
#line 340
        b = r;
      }
      {
#line 344
      value = (uint8 )(b * scale);
#line 345
      fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
#line 347
      value = (uint8 )(g * scale);
#line 348
      fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
#line 350
      value = (uint8 )(r * scale);
#line 351
      fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 353
      if (write_alpha) {
        {
#line 354
        a = (float )*((image->comps + alpha_channel)->data + index___13);
#line 355
        value = (uint8 )(a * scale);
#line 356
        fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
      }
#line 331
      __cil_tmp24 = index___13;
#line 331
      index___13 ++;
#line 331
      __cil_tmp23 = x;
#line 331
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 328
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 398 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  int x ;
  int y ;
  int index___14 ;
  int gray_scale ;
  int not_end_file ;
  unsigned int line ;
  unsigned int col ;
  unsigned char v ;
  unsigned char v2 ;
  DWORD W ;
  DWORD H ;
  FILE *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  opj_image_t *__cil_tmp88 ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  void *__cil_tmp92 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  void *__cil_tmp98 ;
  void *__cil_tmp99 ;
  void *__cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  unsigned int __cil_tmp104 ;
  DWORD __cil_tmp105 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp108 ;
  opj_image_t *__cil_tmp109 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp112 ;
  int __cil_tmp113 ;
  unsigned int __cil_tmp114 ;
  unsigned char pixel_index ;
  int __cil_tmp116 ;
  unsigned int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  unsigned int __cil_tmp124 ;
  int tmp___6 ;
  int tmp___7 ;
  int __cil_tmp127 ;
  opj_image_t *__cil_tmp128 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  unsigned int __cil_tmp134 ;
  int __cil_tmp135 ;
  int __cil_tmp136 ;
  unsigned int __cil_tmp137 ;
  unsigned int __cil_tmp138 ;
  int __cil_tmp139 ;
  unsigned int __cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  unsigned int __cil_tmp144 ;
  unsigned int __cil_tmp145 ;
  unsigned char pixel_index___0 ;
  int __cil_tmp147 ;
  unsigned int __cil_tmp148 ;
  unsigned int __cil_tmp149 ;

  {
#line 399
  subsampling_dx = parameters->subsampling_dx;
#line 400
  subsampling_dy = parameters->subsampling_dy;
#line 405
  image = (opj_image_t *)((void *)0);
#line 412
  PAD = (unsigned int )0;
#line 415
  gray_scale = 1;
#line 415
  not_end_file = 1;
#line 417
  line = (unsigned int )0;
  {
#line 417
  col = (unsigned int )0;
#line 421
  IN = fopen(filename, "rb");
  }
#line 422
  if (! IN) {
    {
#line 423
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 424
    return ((opj_image_t *)0);
  }
  {
#line 427
  __cil_tmp33 = getc(IN);
#line 427
  File_h.bfType = (WORD )__cil_tmp33;
#line 428
  __cil_tmp34 = getc(IN);
#line 428
  File_h.bfType = (WORD )((__cil_tmp34 << 8) + (int )File_h.bfType);
  }
#line 430
  if ((int )File_h.bfType != 19778) {
    {
#line 431
    fprintf(stderr, "Error, not a BMP file!\n");
    }
#line 432
    return ((opj_image_t *)0);
  } else {
    {
#line 436
    __cil_tmp35 = getc(IN);
#line 436
    File_h.bfSize = (DWORD )__cil_tmp35;
#line 437
    __cil_tmp36 = getc(IN);
#line 437
    File_h.bfSize = (unsigned long )(__cil_tmp36 << 8) + File_h.bfSize;
#line 438
    __cil_tmp37 = getc(IN);
#line 438
    File_h.bfSize = (unsigned long )(__cil_tmp37 << 16) + File_h.bfSize;
#line 439
    __cil_tmp38 = getc(IN);
#line 439
    File_h.bfSize = (unsigned long )(__cil_tmp38 << 24) + File_h.bfSize;
#line 441
    __cil_tmp39 = getc(IN);
#line 441
    File_h.bfReserved1 = (WORD )__cil_tmp39;
#line 442
    __cil_tmp40 = getc(IN);
#line 442
    File_h.bfReserved1 = (WORD )((__cil_tmp40 << 8) + (int )File_h.bfReserved1);
#line 444
    __cil_tmp41 = getc(IN);
#line 444
    File_h.bfReserved2 = (WORD )__cil_tmp41;
#line 445
    __cil_tmp42 = getc(IN);
#line 445
    File_h.bfReserved2 = (WORD )((__cil_tmp42 << 8) + (int )File_h.bfReserved2);
#line 447
    __cil_tmp43 = getc(IN);
#line 447
    File_h.bfOffBits = (DWORD )__cil_tmp43;
#line 448
    __cil_tmp44 = getc(IN);
#line 448
    File_h.bfOffBits = (unsigned long )(__cil_tmp44 << 8) + File_h.bfOffBits;
#line 449
    __cil_tmp45 = getc(IN);
#line 449
    File_h.bfOffBits = (unsigned long )(__cil_tmp45 << 16) + File_h.bfOffBits;
#line 450
    __cil_tmp46 = getc(IN);
#line 450
    File_h.bfOffBits = (unsigned long )(__cil_tmp46 << 24) + File_h.bfOffBits;
#line 455
    __cil_tmp47 = getc(IN);
#line 455
    Info_h.biSize = (DWORD )__cil_tmp47;
#line 456
    __cil_tmp48 = getc(IN);
#line 456
    Info_h.biSize = (unsigned long )(__cil_tmp48 << 8) + Info_h.biSize;
#line 457
    __cil_tmp49 = getc(IN);
#line 457
    Info_h.biSize = (unsigned long )(__cil_tmp49 << 16) + Info_h.biSize;
#line 458
    __cil_tmp50 = getc(IN);
#line 458
    Info_h.biSize = (unsigned long )(__cil_tmp50 << 24) + Info_h.biSize;
#line 460
    __cil_tmp51 = getc(IN);
#line 460
    Info_h.biWidth = (DWORD )__cil_tmp51;
#line 461
    __cil_tmp52 = getc(IN);
#line 461
    Info_h.biWidth = (unsigned long )(__cil_tmp52 << 8) + Info_h.biWidth;
#line 462
    __cil_tmp53 = getc(IN);
#line 462
    Info_h.biWidth = (unsigned long )(__cil_tmp53 << 16) + Info_h.biWidth;
#line 463
    __cil_tmp54 = getc(IN);
#line 463
    Info_h.biWidth = (unsigned long )(__cil_tmp54 << 24) + Info_h.biWidth;
#line 464
    w = (int )Info_h.biWidth;
#line 466
    __cil_tmp55 = getc(IN);
#line 466
    Info_h.biHeight = (DWORD )__cil_tmp55;
#line 467
    __cil_tmp56 = getc(IN);
#line 467
    Info_h.biHeight = (unsigned long )(__cil_tmp56 << 8) + Info_h.biHeight;
#line 468
    __cil_tmp57 = getc(IN);
#line 468
    Info_h.biHeight = (unsigned long )(__cil_tmp57 << 16) + Info_h.biHeight;
#line 469
    __cil_tmp58 = getc(IN);
#line 469
    Info_h.biHeight = (unsigned long )(__cil_tmp58 << 24) + Info_h.biHeight;
#line 470
    h = (int )Info_h.biHeight;
#line 472
    __cil_tmp59 = getc(IN);
#line 472
    Info_h.biPlanes = (WORD )__cil_tmp59;
#line 473
    __cil_tmp60 = getc(IN);
#line 473
    Info_h.biPlanes = (WORD )((__cil_tmp60 << 8) + (int )Info_h.biPlanes);
#line 475
    __cil_tmp61 = getc(IN);
#line 475
    Info_h.biBitCount = (WORD )__cil_tmp61;
#line 476
    __cil_tmp62 = getc(IN);
#line 476
    Info_h.biBitCount = (WORD )((__cil_tmp62 << 8) + (int )Info_h.biBitCount);
#line 478
    __cil_tmp63 = getc(IN);
#line 478
    Info_h.biCompression = (DWORD )__cil_tmp63;
#line 479
    __cil_tmp64 = getc(IN);
#line 479
    Info_h.biCompression = (unsigned long )(__cil_tmp64 << 8) + Info_h.biCompression;
#line 480
    __cil_tmp65 = getc(IN);
#line 480
    Info_h.biCompression = (unsigned long )(__cil_tmp65 << 16) + Info_h.biCompression;
#line 481
    __cil_tmp66 = getc(IN);
#line 481
    Info_h.biCompression = (unsigned long )(__cil_tmp66 << 24) + Info_h.biCompression;
#line 483
    __cil_tmp67 = getc(IN);
#line 483
    Info_h.biSizeImage = (DWORD )__cil_tmp67;
#line 484
    __cil_tmp68 = getc(IN);
#line 484
    Info_h.biSizeImage = (unsigned long )(__cil_tmp68 << 8) + Info_h.biSizeImage;
#line 485
    __cil_tmp69 = getc(IN);
#line 485
    Info_h.biSizeImage = (unsigned long )(__cil_tmp69 << 16) + Info_h.biSizeImage;
#line 486
    __cil_tmp70 = getc(IN);
#line 486
    Info_h.biSizeImage = (unsigned long )(__cil_tmp70 << 24) + Info_h.biSizeImage;
#line 488
    __cil_tmp71 = getc(IN);
#line 488
    Info_h.biXpelsPerMeter = (DWORD )__cil_tmp71;
#line 489
    __cil_tmp72 = getc(IN);
#line 489
    Info_h.biXpelsPerMeter = (unsigned long )(__cil_tmp72 << 8) + Info_h.biXpelsPerMeter;
#line 490
    __cil_tmp73 = getc(IN);
#line 490
    Info_h.biXpelsPerMeter = (unsigned long )(__cil_tmp73 << 16) + Info_h.biXpelsPerMeter;
#line 491
    __cil_tmp74 = getc(IN);
#line 491
    Info_h.biXpelsPerMeter = (unsigned long )(__cil_tmp74 << 24) + Info_h.biXpelsPerMeter;
#line 493
    __cil_tmp75 = getc(IN);
#line 493
    Info_h.biYpelsPerMeter = (DWORD )__cil_tmp75;
#line 494
    __cil_tmp76 = getc(IN);
#line 494
    Info_h.biYpelsPerMeter = (unsigned long )(__cil_tmp76 << 8) + Info_h.biYpelsPerMeter;
#line 495
    __cil_tmp77 = getc(IN);
#line 495
    Info_h.biYpelsPerMeter = (unsigned long )(__cil_tmp77 << 16) + Info_h.biYpelsPerMeter;
#line 496
    __cil_tmp78 = getc(IN);
#line 496
    Info_h.biYpelsPerMeter = (unsigned long )(__cil_tmp78 << 24) + Info_h.biYpelsPerMeter;
#line 498
    __cil_tmp79 = getc(IN);
#line 498
    Info_h.biClrUsed = (DWORD )__cil_tmp79;
#line 499
    __cil_tmp80 = getc(IN);
#line 499
    Info_h.biClrUsed = (unsigned long )(__cil_tmp80 << 8) + Info_h.biClrUsed;
#line 500
    __cil_tmp81 = getc(IN);
#line 500
    Info_h.biClrUsed = (unsigned long )(__cil_tmp81 << 16) + Info_h.biClrUsed;
#line 501
    __cil_tmp82 = getc(IN);
#line 501
    Info_h.biClrUsed = (unsigned long )(__cil_tmp82 << 24) + Info_h.biClrUsed;
#line 503
    __cil_tmp83 = getc(IN);
#line 503
    Info_h.biClrImportant = (DWORD )__cil_tmp83;
#line 504
    __cil_tmp84 = getc(IN);
#line 504
    Info_h.biClrImportant = (unsigned long )(__cil_tmp84 << 8) + Info_h.biClrImportant;
#line 505
    __cil_tmp85 = getc(IN);
#line 505
    Info_h.biClrImportant = (unsigned long )(__cil_tmp85 << 16) + Info_h.biClrImportant;
#line 506
    __cil_tmp86 = getc(IN);
#line 506
    Info_h.biClrImportant = (unsigned long )(__cil_tmp86 << 24) + Info_h.biClrImportant;
    }
#line 510
    if ((int )Info_h.biBitCount == 24) {
      {
#line 511
      numcomps = 3;
#line 512
      color_space = (OPJ_COLOR_SPACE )1;
#line 514
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 515
      i = 0;
      }
      {
#line 515
      while (1) {
        while_continue: /* CIL Label */ ;
#line 515
        if (! (i < numcomps)) {
#line 515
          goto while_break;
        }
#line 516
        cmptparm[i].prec = 8;
#line 517
        cmptparm[i].bpp = 8;
#line 518
        cmptparm[i].sgnd = 0;
#line 519
        cmptparm[i].dx = subsampling_dx;
#line 520
        cmptparm[i].dy = subsampling_dy;
#line 521
        cmptparm[i].w = w;
#line 522
        cmptparm[i].h = h;
#line 515
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 525
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 526
      if (! image) {
        {
#line 527
        fclose(IN);
        }
#line 528
        return ((opj_image_t *)((void *)0));
      }
#line 532
      image->x0 = parameters->image_offset_x0;
#line 533
      image->y0 = parameters->image_offset_y0;
#line 534
      if (! image->x0) {
#line 534
        tmp = (w - 1) * subsampling_dx + 1;
      } else {
#line 534
        tmp = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 534
      image->x1 = tmp;
#line 535
      if (! image->y0) {
#line 535
        tmp___0 = (h - 1) * subsampling_dy + 1;
      } else {
#line 535
        tmp___0 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 535
      image->y1 = tmp___0;
#line 540
      fseek(IN, (long )0, 0);
#line 541
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 543
      W = Info_h.biWidth;
#line 544
      H = Info_h.biHeight;
      }
#line 548
      if ((3UL * W) % 4UL) {
#line 548
        tmp___1 = 4UL - (3UL * W) % 4UL;
      } else {
#line 548
        tmp___1 = (unsigned long )0;
      }
      {
#line 548
      PAD = (unsigned int )tmp___1;
#line 550
      __cil_tmp92 = malloc(((3UL * W + (unsigned long )PAD) * H) * sizeof(unsigned char ));
#line 550
      RGB = (unsigned char *)__cil_tmp92;
#line 552
      fread(RGB, sizeof(unsigned char ), (3UL * W + (unsigned long )PAD) * H, IN);
#line 554
      index___14 = 0;
#line 556
      y = 0;
      }
      {
#line 556
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 556
        if (! (y < (int )H)) {
#line 556
          goto while_break___0;
        }
#line 557
        scanline = RGB + (3UL * W + (unsigned long )PAD) * ((H - 1UL) - (unsigned long )y);
#line 558
        x = 0;
        {
#line 558
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 558
          if (! (x < (int )W)) {
#line 558
            goto while_break___1;
          }
#line 559
          pixel = scanline + 3 * x;
#line 560
          *((image->comps + 0)->data + index___14) = (int )*(pixel + 2);
#line 561
          *((image->comps + 1)->data + index___14) = (int )*(pixel + 1);
#line 562
          *((image->comps + 2)->data + index___14) = (int )*(pixel + 0);
#line 563
          index___14 ++;
#line 558
          x ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 556
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 567
      free(RGB);
      }
    } else
#line 569
    if ((int )Info_h.biBitCount == 8) {
#line 569
      if (Info_h.biCompression == 0UL) {
        {
#line 570
        __cil_tmp98 = malloc(256UL * sizeof(unsigned char ));
#line 570
        table_R = (unsigned char *)__cil_tmp98;
#line 571
        __cil_tmp99 = malloc(256UL * sizeof(unsigned char ));
#line 571
        table_G = (unsigned char *)__cil_tmp99;
#line 572
        __cil_tmp100 = malloc(256UL * sizeof(unsigned char ));
#line 572
        table_B = (unsigned char *)__cil_tmp100;
#line 574
        j = (unsigned int )0;
        }
        {
#line 574
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 574
          if (! ((unsigned long )j < Info_h.biClrUsed)) {
#line 574
            goto while_break___2;
          }
          {
#line 575
          __cil_tmp101 = getc(IN);
#line 575
          *(table_B + j) = (unsigned char )__cil_tmp101;
#line 576
          __cil_tmp102 = getc(IN);
#line 576
          *(table_G + j) = (unsigned char )__cil_tmp102;
#line 577
          __cil_tmp103 = getc(IN);
#line 577
          *(table_R + j) = (unsigned char )__cil_tmp103;
#line 578
          getc(IN);
          }
#line 579
          if ((int )*(table_R + j) != (int )*(table_G + j)) {
#line 579
            if ((int )*(table_R + j) != (int )*(table_B + j)) {
#line 579
              if ((int )*(table_G + j) != (int )*(table_B + j)) {
#line 580
                gray_scale = 0;
              }
            }
          }
#line 574
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 584
        fseek(IN, (long )0, 0);
#line 585
        fseek(IN, (long )File_h.bfOffBits, 0);
#line 587
        W = Info_h.biWidth;
#line 588
        H = Info_h.biHeight;
        }
#line 589
        if (Info_h.biWidth % 2UL) {
#line 590
          W ++;
        }
#line 592
        if (gray_scale) {
#line 592
          tmp___2 = 1;
        } else {
#line 592
          tmp___2 = 3;
        }
#line 592
        numcomps = tmp___2;
#line 593
        if (gray_scale) {
#line 593
          tmp___3 = 2;
        } else {
#line 593
          tmp___3 = 1;
        }
        {
#line 593
        color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 595
        memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 596
        i = 0;
        }
        {
#line 596
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 596
          if (! (i < numcomps)) {
#line 596
            goto while_break___3;
          }
#line 597
          cmptparm[i].prec = 8;
#line 598
          cmptparm[i].bpp = 8;
#line 599
          cmptparm[i].sgnd = 0;
#line 600
          cmptparm[i].dx = subsampling_dx;
#line 601
          cmptparm[i].dy = subsampling_dy;
#line 602
          cmptparm[i].w = w;
#line 603
          cmptparm[i].h = h;
#line 596
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 606
        image = opj_image_create(numcomps, & cmptparm[0], color_space);
        }
#line 607
        if (! image) {
          {
#line 608
          fclose(IN);
          }
#line 609
          return ((opj_image_t *)((void *)0));
        }
#line 613
        image->x0 = parameters->image_offset_x0;
#line 614
        image->y0 = parameters->image_offset_y0;
#line 615
        if (! image->x0) {
#line 615
          tmp___4 = (w - 1) * subsampling_dx + 1;
        } else {
#line 615
          tmp___4 = (image->x0 + (w - 1) * subsampling_dx) + 1;
        }
#line 615
        image->x1 = tmp___4;
#line 616
        if (! image->y0) {
#line 616
          tmp___5 = (h - 1) * subsampling_dy + 1;
        } else {
#line 616
          tmp___5 = (image->y0 + (h - 1) * subsampling_dy) + 1;
        }
        {
#line 616
        image->y1 = tmp___5;
#line 620
        __cil_tmp112 = malloc((W * H) * sizeof(unsigned char ));
#line 620
        RGB = (unsigned char *)__cil_tmp112;
#line 622
        fread(RGB, sizeof(unsigned char ), W * H, IN);
        }
#line 623
        if (gray_scale) {
#line 624
          index___14 = 0;
#line 625
          j = (unsigned int )0;
          {
#line 625
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 625
            if (! ((unsigned long )j < W * H)) {
#line 625
              goto while_break___4;
            }
#line 626
            if ((unsigned long )j % W < W - 1UL) {
#line 626
              if (Info_h.biWidth % 2UL) {
#line 627
                *((image->comps + 0)->data + index___14) = (int )*(table_R + *(RGB + ((W * H - ((unsigned long )j / W + 1UL) * W) + (unsigned long )j % W)));
#line 628
                index___14 ++;
              } else {
#line 626
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 626
            if (! (Info_h.biWidth % 2UL)) {
#line 627
              *((image->comps + 0)->data + index___14) = (int )*(table_R + *(RGB + ((W * H - ((unsigned long )j / W + 1UL) * W) + (unsigned long )j % W)));
#line 628
              index___14 ++;
            }
#line 625
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
#line 633
          index___14 = 0;
#line 634
          j = (unsigned int )0;
          {
#line 634
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 634
            if (! ((unsigned long )j < W * H)) {
#line 634
              goto while_break___5;
            }
#line 635
            if ((unsigned long )j % W < W - 1UL) {
#line 635
              if (Info_h.biWidth % 2UL) {
#line 636
                pixel_index = *(RGB + ((W * H - ((unsigned long )j / W + 1UL) * W) + (unsigned long )j % W));
#line 637
                *((image->comps + 0)->data + index___14) = (int )*(table_R + pixel_index);
#line 638
                *((image->comps + 1)->data + index___14) = (int )*(table_G + pixel_index);
#line 639
                *((image->comps + 2)->data + index___14) = (int )*(table_B + pixel_index);
#line 640
                index___14 ++;
              } else {
#line 635
                goto _L___15;
              }
            } else
            _L___15: /* CIL Label */ 
#line 635
            if (! (Info_h.biWidth % 2UL)) {
#line 636
              pixel_index = *(RGB + ((W * H - ((unsigned long )j / W + 1UL) * W) + (unsigned long )j % W));
#line 637
              *((image->comps + 0)->data + index___14) = (int )*(table_R + pixel_index);
#line 638
              *((image->comps + 1)->data + index___14) = (int )*(table_G + pixel_index);
#line 639
              *((image->comps + 2)->data + index___14) = (int )*(table_B + pixel_index);
#line 640
              index___14 ++;
            }
#line 634
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
#line 644
        free(RGB);
#line 645
        free(table_R);
#line 646
        free(table_G);
#line 647
        free(table_B);
        }
      } else {
#line 569
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 648
    if ((int )Info_h.biBitCount == 8) {
#line 648
      if (Info_h.biCompression == 1UL) {
        {
#line 649
        __cil_tmp118 = malloc(256UL * sizeof(unsigned char ));
#line 649
        table_R = (unsigned char *)__cil_tmp118;
#line 650
        __cil_tmp119 = malloc(256UL * sizeof(unsigned char ));
#line 650
        table_G = (unsigned char *)__cil_tmp119;
#line 651
        __cil_tmp120 = malloc(256UL * sizeof(unsigned char ));
#line 651
        table_B = (unsigned char *)__cil_tmp120;
#line 653
        j = (unsigned int )0;
        }
        {
#line 653
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 653
          if (! ((unsigned long )j < Info_h.biClrUsed)) {
#line 653
            goto while_break___6;
          }
          {
#line 654
          __cil_tmp121 = getc(IN);
#line 654
          *(table_B + j) = (unsigned char )__cil_tmp121;
#line 655
          __cil_tmp122 = getc(IN);
#line 655
          *(table_G + j) = (unsigned char )__cil_tmp122;
#line 656
          __cil_tmp123 = getc(IN);
#line 656
          *(table_R + j) = (unsigned char )__cil_tmp123;
#line 657
          getc(IN);
          }
#line 658
          if ((int )*(table_R + j) != (int )*(table_G + j)) {
#line 658
            if ((int )*(table_R + j) != (int )*(table_B + j)) {
#line 658
              if ((int )*(table_G + j) != (int )*(table_B + j)) {
#line 659
                gray_scale = 0;
              }
            }
          }
#line 653
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 662
        if (gray_scale) {
#line 662
          tmp___6 = 1;
        } else {
#line 662
          tmp___6 = 3;
        }
#line 662
        numcomps = tmp___6;
#line 663
        if (gray_scale) {
#line 663
          tmp___7 = 2;
        } else {
#line 663
          tmp___7 = 1;
        }
        {
#line 663
        color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 665
        memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 666
        i = 0;
        }
        {
#line 666
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 666
          if (! (i < numcomps)) {
#line 666
            goto while_break___7;
          }
#line 667
          cmptparm[i].prec = 8;
#line 668
          cmptparm[i].bpp = 8;
#line 669
          cmptparm[i].sgnd = 0;
#line 670
          cmptparm[i].dx = subsampling_dx;
#line 671
          cmptparm[i].dy = subsampling_dy;
#line 672
          cmptparm[i].w = w;
#line 673
          cmptparm[i].h = h;
#line 666
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 676
        image = opj_image_create(numcomps, & cmptparm[0], color_space);
        }
#line 677
        if (! image) {
          {
#line 678
          fclose(IN);
          }
#line 679
          return ((opj_image_t *)((void *)0));
        }
#line 683
        image->x0 = parameters->image_offset_x0;
#line 684
        image->y0 = parameters->image_offset_y0;
#line 685
        if (! image->x0) {
#line 685
          tmp___8 = (w - 1) * subsampling_dx + 1;
        } else {
#line 685
          tmp___8 = (image->x0 + (w - 1) * subsampling_dx) + 1;
        }
#line 685
        image->x1 = tmp___8;
#line 686
        if (! image->y0) {
#line 686
          tmp___9 = (h - 1) * subsampling_dy + 1;
        } else {
#line 686
          tmp___9 = (image->y0 + (h - 1) * subsampling_dy) + 1;
        }
        {
#line 686
        image->y1 = tmp___9;
#line 691
        fseek(IN, (long )0, 0);
#line 692
        fseek(IN, (long )File_h.bfOffBits, 0);
#line 694
        __cil_tmp131 = malloc((Info_h.biWidth * Info_h.biHeight) * sizeof(unsigned char ));
#line 694
        RGB = (unsigned char *)__cil_tmp131;
        }
        {
#line 696
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 696
          if (! not_end_file) {
#line 696
            goto while_break___8;
          }
          {
#line 697
          __cil_tmp132 = getc(IN);
#line 697
          v = (unsigned char )__cil_tmp132;
          }
#line 698
          if (v) {
            {
#line 699
            __cil_tmp133 = getc(IN);
#line 699
            v2 = (unsigned char )__cil_tmp133;
#line 700
            i = 0;
            }
            {
#line 700
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 700
              if (! (i < (int )v)) {
#line 700
                goto while_break___9;
              }
#line 701
              *(RGB + ((unsigned long )line * Info_h.biWidth + (unsigned long )col)) = v2;
#line 702
              col ++;
#line 700
              i ++;
            }
            while_break___9: /* CIL Label */ ;
            }
          } else {
            {
#line 705
            __cil_tmp136 = getc(IN);
#line 705
            v = (unsigned char )__cil_tmp136;
            }
            {
#line 707
            if ((int )v == 0) {
#line 707
              goto case_0;
            }
#line 711
            if ((int )v == 1) {
#line 711
              goto case_1;
            }
#line 715
            if ((int )v == 2) {
#line 715
              goto case_2;
            }
#line 720
            goto switch_default;
            case_0: /* CIL Label */ 
#line 708
            col = (unsigned int )0;
#line 709
            line ++;
#line 710
            goto switch_break;
            case_1: /* CIL Label */ 
#line 712
            line ++;
#line 713
            not_end_file = 0;
#line 714
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 716
            fprintf(stderr, "No Delta supported\n");
            }
            {
#line 717
            opj_image_destroy(image);
#line 718
            fclose(IN);
            }
#line 719
            return ((opj_image_t *)((void *)0));
            switch_default: /* CIL Label */ 
#line 721
            i = 0;
            {
#line 721
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 721
              if (! (i < (int )v)) {
#line 721
                goto while_break___10;
              }
              {
#line 722
              __cil_tmp139 = getc(IN);
#line 722
              v2 = (unsigned char )__cil_tmp139;
#line 723
              *(RGB + ((unsigned long )line * Info_h.biWidth + (unsigned long )col)) = v2;
#line 724
              col ++;
              }
#line 721
              i ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 726
            if ((int )v % 2) {
              {
#line 727
              __cil_tmp142 = getc(IN);
#line 727
              v2 = (unsigned char )__cil_tmp142;
              }
            }
#line 728
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 732
        if (gray_scale) {
#line 733
          index___14 = 0;
#line 734
          line = (unsigned int )0;
          {
#line 734
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 734
            if (! ((unsigned long )line < Info_h.biHeight)) {
#line 734
              goto while_break___11;
            }
#line 735
            col = (unsigned int )0;
            {
#line 735
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 735
              if (! ((unsigned long )col < Info_h.biWidth)) {
#line 735
                goto while_break___12;
              }
#line 736
              *((image->comps + 0)->data + index___14) = (int )*(table_R + (int )*(RGB + (((Info_h.biHeight - (unsigned long )line) - 1UL) * Info_h.biWidth + (unsigned long )col)));
#line 737
              index___14 ++;
#line 735
              col ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 734
            line ++;
          }
          while_break___11: /* CIL Label */ ;
          }
        } else {
#line 741
          index___14 = 0;
#line 742
          line = (unsigned int )0;
          {
#line 742
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 742
            if (! ((unsigned long )line < Info_h.biHeight)) {
#line 742
              goto while_break___13;
            }
#line 743
            col = (unsigned int )0;
            {
#line 743
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 743
              if (! ((unsigned long )col < Info_h.biWidth)) {
#line 743
                goto while_break___14;
              }
#line 744
              pixel_index___0 = (unsigned char )((int )*(RGB + (((Info_h.biHeight - (unsigned long )line) - 1UL) * Info_h.biWidth + (unsigned long )col)));
#line 745
              *((image->comps + 0)->data + index___14) = (int )*(table_R + pixel_index___0);
#line 746
              *((image->comps + 1)->data + index___14) = (int )*(table_G + pixel_index___0);
#line 747
              *((image->comps + 2)->data + index___14) = (int )*(table_B + pixel_index___0);
#line 748
              index___14 ++;
#line 743
              col ++;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 742
            line ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
        {
#line 752
        free(RGB);
#line 753
        free(table_R);
#line 754
        free(table_G);
#line 755
        free(table_B);
        }
      } else {
        {
        {
#line 757
        fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
                (int )Info_h.biBitCount);
        }
        }
      }
    } else {
      {
      {
#line 757
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
    {
#line 760
    fclose(IN);
    }
  }
#line 763
  return (image);
}
}
#line 766 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned char rc___0 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;

  {
#line 769
  fdest = (FILE *)((void *)0);
#line 772
  if (image->numcomps == 3) {
#line 772
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 772
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 772
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 772
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 772
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 772
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 783
                fdest = fopen(outfile, "wb\t\241\032V");
                }
#line 784
                if (! fdest) {
                  {
#line 785
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 786
                  return (1);
                }
                {
#line 789
                w = (image->comps + 0)->w;
#line 790
                h = (image->comps + 0)->h;
#line 792
                fprintf(fdest, "BM");
#line 796
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 801
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 802
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 806
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 807
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 811
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 815
                fprintf(fdest, "%c%c\032V", 1, (1 >> 8) & 255);
#line 816
                fprintf(fdest, "%c%c", 24, (24 >> 8) & 255);
#line 817
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 818
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 822
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 823
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 824
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 825
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 827
                if ((image->comps + 0)->prec > 8) {
                  {
#line 828
                  adjustR = (image->comps + 0)->prec - 8;
#line 829
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 832
                  adjustR = 0;
                }
#line 833
                if ((image->comps + 1)->prec > 8) {
                  {
#line 834
                  adjustG = (image->comps + 1)->prec - 8;
#line 835
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 838
                  adjustG = 0;
                }
#line 839
                if ((image->comps + 2)->prec > 8) {
                  {
#line 840
                  adjustB = (image->comps + 2)->prec - 8;
#line 841
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 844
                  adjustB = 0;
                }
#line 846
                i = 0;
                {
#line 846
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 846
                  if (! (i < w * h)) {
#line 846
                    goto while_break;
                  }
#line 850
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 851
                  if ((image->comps + 0)->sgnd) {
#line 851
                    tmp = 1 << ((image->comps + 0)->prec - 1);
                  } else {
#line 851
                    tmp = 0;
                  }
#line 851
                  r += tmp;
#line 852
                  rc = (unsigned char )((r >> adjustR) + (r >> (adjustR - 1)) % 2);
#line 853
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 854
                  if ((image->comps + 1)->sgnd) {
#line 854
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1);
                  } else {
#line 854
                    tmp___0 = 0;
                  }
#line 854
                  g += tmp___0;
#line 855
                  gc = (unsigned char )((g >> adjustG) + (g >> (adjustG - 1)) % 2);
#line 856
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 857
                  if ((image->comps + 2)->sgnd) {
#line 857
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1);
                  } else {
#line 857
                    tmp___1 = 0;
                  }
                  {
#line 857
                  b += tmp___1;
#line 858
                  bc = (unsigned char )((b >> adjustB) + (b >> (adjustB - 1)) % 2);
#line 860
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 862
                  if ((i + 1) % w == 0) {
#line 863
                    if ((3 * w) % 4) {
#line 863
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 863
                      tmp___2 = 0;
                    }
#line 863
                    pad = tmp___2;
                    {
#line 863
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 863
                      if (! (pad > 0)) {
#line 863
                        goto while_break___0;
                      }
                      {
#line 864
                      fprintf(fdest, "%c", 0);
                      }
#line 863
                      __cil_tmp22 = pad;
#line 863
                      pad --;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
#line 846
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 867
                fclose(fdest);
                }
              } else {
#line 772
                goto _L;
              }
            } else {
#line 772
              goto _L;
            }
          } else {
#line 772
            goto _L;
          }
        } else {
#line 772
          goto _L;
        }
      } else {
#line 772
        goto _L;
      }
    } else {
#line 772
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___17: /* CIL Label */ 
    _L___18: /* CIL Label */ 
    _L___19: /* CIL Label */ 
    _L___20: /* CIL Label */ 
    _L___21: /* CIL Label */ 
    {
#line 874
    fdest = fopen(outfile, "wb\b\241\032V");
#line 875
    w = (image->comps + 0)->w;
#line 876
    h = (image->comps + 0)->h;
#line 878
    fprintf(fdest, "BM\b\241\032V");
#line 882
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 886
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 887
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 893
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 894
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 898
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 902
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 903
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 904
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 905
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 909
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 910
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 911
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 912
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 914
    if ((image->comps + 0)->prec > 8) {
      {
#line 915
      adjustR = (image->comps + 0)->prec - 8;
#line 916
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 918
      adjustR = 0;
    }
#line 920
    i = 0;
    {
#line 920
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 920
      if (! (i < 256)) {
#line 920
        goto while_break___1;
      }
      {
#line 921
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 920
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 924
    i = 0;
    {
#line 924
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 924
      if (! (i < w * h)) {
#line 924
        goto while_break___2;
      }
#line 928
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 929
      if ((image->comps + 0)->sgnd) {
#line 929
        tmp___3 = 1 << ((image->comps + 0)->prec - 1);
      } else {
#line 929
        tmp___3 = 0;
      }
      {
#line 929
      r___0 += tmp___3;
#line 930
      rc___0 = (unsigned char )((r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2);
#line 932
      fprintf(fdest, "%c\b\241\032V", (int )rc___0);
      }
#line 934
      if ((i + 1) % w == 0) {
#line 935
        if (w % 4) {
#line 935
          tmp___4 = 4 - w % 4;
        } else {
#line 935
          tmp___4 = 0;
        }
#line 935
        pad = tmp___4;
        {
#line 935
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 935
          if (! (pad > 0)) {
#line 935
            goto while_break___3;
          }
          {
#line 936
          fprintf(fdest, "%c", 0);
          }
#line 935
          __cil_tmp30 = pad;
#line 935
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 924
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 939
    fclose(fdest);
    }
  }
#line 942
  return (0);
}
}
#line 952 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;

  {
  {
#line 955
  fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 956
  return (c1);
}
}
#line 959 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;

  {
  {
#line 962
  fread(& c1, (unsigned long )1, (unsigned long )1, f);
#line 963
  fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 964
  if (bigendian) {
#line 965
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 967
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 970 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;

  {
  {
#line 973
  fread(& c1, (unsigned long )1, (unsigned long )1, f);
#line 974
  fread(& c2, (unsigned long )1, (unsigned long )1, f);
#line 975
  fread(& c3, (unsigned long )1, (unsigned long )1, f);
#line 976
  fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 977
  if (bigendian) {
#line 978
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 980
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 983 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp ;
  int tmp___0 ;
  opj_image_t *__cil_tmp24 ;
  int v ;
  unsigned char __cil_tmp26 ;
  unsigned char __cil_tmp27 ;
  unsigned short __cil_tmp28 ;
  unsigned short __cil_tmp29 ;
  unsigned int __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
  {
#line 984
  f = (FILE *)((void *)0);
#line 989
  image = (opj_image_t *)((void *)0);
#line 996
  comp = (opj_image_comp_t *)((void *)0);
#line 998
  numcomps = 1;
#line 999
  color_space = (OPJ_COLOR_SPACE )2;
#line 1001
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1003
  max = 0;
#line 1005
  f = fopen(filename, "rb");
  }
#line 1006
  if (! f) {
    {
#line 1007
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1008
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1011
  fseek(f, (long )0, 0);
#line 1012
  fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d", (char *)temp, & endian1, & endian2,
         (char *)signtmp, & prec, (char *)temp, & w, (char *)temp, & h);
#line 1014
  i = 0;
#line 1015
  sign = (char )'+';
  }
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! ((int )signtmp[i] != 0)) {
#line 1016
      goto while_break;
    }
#line 1017
    if ((int )signtmp[i] == 45) {
#line 1017
      sign = (char )'-';
    }
#line 1018
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  fgetc(f);
  }
#line 1022
  if ((int )endian1 == 77) {
#line 1022
    if ((int )endian2 == 76) {
#line 1023
      bigendian = 1;
    } else {
#line 1022
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1024
  if ((int )endian2 == 77) {
#line 1024
    if ((int )endian1 == 76) {
#line 1025
      bigendian = 0;
    } else {
      {
      {
#line 1027
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      }
#line 1028
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1027
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
#line 1028
    return ((opj_image_t *)((void *)0));
  }
#line 1033
  cmptparm.x0 = parameters->image_offset_x0;
#line 1034
  cmptparm.y0 = parameters->image_offset_y0;
#line 1035
  if (! cmptparm.x0) {
#line 1035
    tmp = (w - 1) * parameters->subsampling_dx + 1;
  } else {
#line 1035
    tmp = (cmptparm.x0 + (w - 1) * parameters->subsampling_dx) + 1;
  }
#line 1035
  cmptparm.w = tmp;
#line 1036
  if (! cmptparm.y0) {
#line 1036
    tmp___0 = (h - 1) * parameters->subsampling_dy + 1;
  } else {
#line 1036
    tmp___0 = (cmptparm.y0 + (h - 1) * parameters->subsampling_dy) + 1;
  }
#line 1036
  cmptparm.h = tmp___0;
#line 1038
  if ((int )sign == 45) {
#line 1039
    cmptparm.sgnd = 1;
  } else {
#line 1041
    cmptparm.sgnd = 0;
  }
  {
#line 1043
  cmptparm.prec = prec;
#line 1044
  cmptparm.bpp = prec;
#line 1045
  cmptparm.dx = parameters->subsampling_dx;
#line 1046
  cmptparm.dy = parameters->subsampling_dy;
#line 1049
  image = opj_image_create(numcomps, & cmptparm, color_space);
  }
#line 1050
  if (! image) {
    {
#line 1051
    fclose(f);
    }
#line 1052
    return ((opj_image_t *)((void *)0));
  }
#line 1055
  image->x0 = cmptparm.x0;
#line 1056
  image->y0 = cmptparm.x0;
#line 1057
  image->x1 = cmptparm.w;
#line 1058
  image->y1 = cmptparm.h;
#line 1062
  comp = image->comps + 0;
#line 1064
  i = 0;
  {
#line 1064
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1064
    if (! (i < w * h)) {
#line 1064
      goto while_break___0;
    }
#line 1066
    if (comp->prec <= 8) {
#line 1067
      if (! comp->sgnd) {
        {
#line 1068
        __cil_tmp26 = readuchar(f);
#line 1068
        v = (int )__cil_tmp26;
        }
      } else {
        {
#line 1070
        __cil_tmp27 = readuchar(f);
#line 1070
        v = (int )((char )__cil_tmp27);
        }
      }
    } else
#line 1072
    if (comp->prec <= 16) {
#line 1073
      if (! comp->sgnd) {
        {
#line 1074
        __cil_tmp28 = readushort(f, bigendian);
#line 1074
        v = (int )__cil_tmp28;
        }
      } else {
        {
#line 1076
        __cil_tmp29 = readushort(f, bigendian);
#line 1076
        v = (int )((short )__cil_tmp29);
        }
      }
    } else
#line 1079
    if (! comp->sgnd) {
      {
#line 1080
      __cil_tmp30 = readuint(f, bigendian);
#line 1080
      v = (int )__cil_tmp30;
      }
    } else {
      {
#line 1082
      __cil_tmp31 = readuint(f, bigendian);
#line 1082
      v = (int )__cil_tmp31;
      }
    }
#line 1085
    if (v > max) {
#line 1086
      max = v;
    }
#line 1087
    *(comp->data + i) = v;
#line 1064
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1089
  fclose(f);
#line 1090
  __cil_tmp33 = int_floorlog2___15(max);
#line 1090
  comp->bpp = __cil_tmp33 + 1;
  }
#line 1092
  return (image);
}
}
#line 1095 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t olen ;
  unsigned long __cil_tmp14 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp17 ;
  FILE *__cil_tmp18 ;
  int tmp ;
  int v ;
  char byte ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1098
  fdest = (FILE *)((void *)0);
#line 1100
  compno = 0;
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! (compno < image->numcomps)) {
#line 1100
      goto while_break;
    }
    {
#line 1101
    comp = image->comps + compno;
#line 1103
    name = (char *)bname;
#line 1104
    nbytes = 0;
#line 1105
    __cil_tmp14 = strlen(outfile);
#line 1105
    olen = __cil_tmp14;
#line 1106
    dotpos = olen - 4UL;
#line 1107
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1108
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1110
      fprintf(stderr, "ERROR -> Impossible happen.\241\032V");
      }
#line 1111
      return (1);
    }
#line 1113
    if (total > 256UL) {
      {
#line 1114
      __cil_tmp17 = malloc(total + 1UL);
#line 1114
      name = (char *)__cil_tmp17;
      }
    }
    {
#line 1116
    strncpy(name, outfile, dotpos);
    }
#line 1117
    if (image->numcomps > 1) {
      {
#line 1118
      sprintf(name + dotpos, "-%d.pgx", compno);
      }
    } else {
      {
#line 1120
      strcpy(name + dotpos, ".pgx\032V");
      }
    }
    {
#line 1122
    fdest = fopen((char const   *)name, "wb\n\241\032V");
    }
#line 1123
    if (! fdest) {
      {
#line 1124
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1125
      return (1);
    }
#line 1128
    if (total > 256UL) {
      {
#line 1129
      free(name);
      }
    }
#line 1132
    w = (image->comps + compno)->w;
#line 1133
    h = (image->comps + compno)->h;
#line 1135
    if (comp->sgnd) {
#line 1135
      tmp = '-';
    } else {
#line 1135
      tmp = '+';
    }
    {
#line 1135
    fprintf(fdest, "PG ML %c %d %d %d\n\v\241\032V", tmp, comp->prec, w, h);
    }
#line 1136
    if (comp->prec <= 8) {
#line 1137
      nbytes = 1;
    } else
#line 1138
    if (comp->prec <= 16) {
#line 1139
      nbytes = 2;
    } else {
#line 1141
      nbytes = 4;
    }
#line 1143
    i = 0;
    {
#line 1143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1143
      if (! (i < w * h)) {
#line 1143
        goto while_break___0;
      }
#line 1144
      v = *((image->comps + compno)->data + i);
#line 1145
      j = nbytes - 1;
      {
#line 1145
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1145
        if (! (j >= 0)) {
#line 1145
          goto while_break___1;
        }
        {
#line 1146
        byte = (char )(v >> j * 8);
#line 1147
        fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1145
        __cil_tmp22 = j;
#line 1145
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1143
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1150
    fclose(fdest);
    }
#line 1100
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  return (0);
}
}
#line 1162 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  char value ;
  FILE *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_image_t *__cil_tmp21 ;
  unsigned int index___22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char index___23 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
  {
#line 1163
  subsampling_dx = parameters->subsampling_dx;
#line 1164
  subsampling_dy = parameters->subsampling_dy;
#line 1166
  f = (FILE *)((void *)0);
#line 1170
  image = (opj_image_t *)((void *)0);
#line 1173
  f = fopen(filename, "rb");
  }
#line 1174
  if (! f) {
    {
#line 1175
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 1176
    return ((opj_image_t *)0);
  }
  {
#line 1179
  __cil_tmp16 = fgetc(f);
  }
#line 1179
  if (__cil_tmp16 != 80) {
#line 1180
    return ((opj_image_t *)0);
  }
  {
#line 1181
  __cil_tmp17 = fgetc(f);
#line 1181
  value = (char )__cil_tmp17;
  }
  {
#line 1185
  if ((int )value == '5') {
#line 1185
    goto case_53;
  }
#line 1185
  if ((int )value == '2') {
#line 1185
    goto case_53;
  }
#line 1191
  if ((int )value == '6') {
#line 1191
    goto case_54;
  }
#line 1191
  if ((int )value == '3') {
#line 1191
    goto case_54;
  }
#line 1196
  goto switch_default;
  case_53: /* CIL Label */ 
  case_50: /* CIL Label */ 
#line 1186
  numcomps = 1;
#line 1187
  color_space = (OPJ_COLOR_SPACE )2;
#line 1188
  goto switch_break;
  case_54: /* CIL Label */ 
  case_51: /* CIL Label */ 
#line 1192
  numcomps = 3;
#line 1193
  color_space = (OPJ_COLOR_SPACE )1;
#line 1194
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1197
  fclose(f);
  }
#line 1198
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 1201
  fgetc(f);
  }
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1204
    __cil_tmp18 = fgetc(f);
    }
#line 1204
    if (! (__cil_tmp18 == 35)) {
#line 1204
      goto while_break;
    }
    {
#line 1204
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1204
      __cil_tmp19 = fgetc(f);
      }
#line 1204
      if (! (__cil_tmp19 != 10)) {
#line 1204
        goto while_break___0;
      }

    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1206
  fseek(f, (long )(- 1), 1);
#line 1207
  fscanf(f, "%d %d\n255y\v\241\032V", & w, & h);
#line 1208
  fgetc(f);
#line 1211
  memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 1212
  i = 0;
  }
  {
#line 1212
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1212
    if (! (i < numcomps)) {
#line 1212
      goto while_break___1;
    }
#line 1213
    cmptparm[i].prec = 8;
#line 1214
    cmptparm[i].bpp = 8;
#line 1215
    cmptparm[i].sgnd = 0;
#line 1216
    cmptparm[i].dx = subsampling_dx;
#line 1217
    cmptparm[i].dy = subsampling_dy;
#line 1218
    cmptparm[i].w = w;
#line 1219
    cmptparm[i].h = h;
#line 1212
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1222
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 1223
  if (! image) {
    {
#line 1224
    fclose(f);
    }
#line 1225
    return ((opj_image_t *)((void *)0));
  }
#line 1229
  image->x0 = parameters->image_offset_x0;
#line 1230
  image->y0 = parameters->image_offset_y0;
#line 1231
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 1232
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 1236
  if ((int )value == 50) {
    _L___24: /* CIL Label */ 
#line 1237
    i = 0;
    {
#line 1237
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1237
      if (! (i < w * h)) {
#line 1237
        goto while_break___2;
      }
#line 1238
      compno = 0;
      {
#line 1238
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1238
        if (! (compno < numcomps)) {
#line 1238
          goto while_break___3;
        }
        {
#line 1239
        index___22 = (unsigned int )0;
#line 1240
        fscanf(f, "%u\n\241\032V", & index___22);
#line 1242
        *((image->comps + compno)->data + i) = (int )index___22;
        }
#line 1238
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1237
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1236
  if ((int )value == 51) {
#line 1236
    goto _L___24;
  } else
#line 1245
  if ((int )value == 53) {
    _L: /* CIL Label */ 
#line 1246
    i = 0;
    {
#line 1246
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1246
      if (! (i < w * h)) {
#line 1246
        goto while_break___4;
      }
#line 1247
      compno = 0;
      {
#line 1247
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1247
        if (! (compno < numcomps)) {
#line 1247
          goto while_break___5;
        }
        {
#line 1248
        index___23 = (unsigned char )0;
#line 1249
        fread(& index___23, (unsigned long )1, (unsigned long )1, f);
#line 1251
        *((image->comps + compno)->data + i) = (int )index___23;
        }
#line 1247
        compno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1246
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1245
  if ((int )value == 54) {
#line 1245
    goto _L;
  }
  {
#line 1256
  fclose(f);
  }
#line 1258
  return (image);
}
}
#line 1261 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int wr ;
  int h ;
  int hr ;
  int max ;
  int i ;
  int compno ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustX ;
  FILE *fdest ;
  char S2 ;
  char const   *tmp ;
  char const   *__cil_tmp17 ;
  char const   *__cil_tmp18 ;
  char const   *__cil_tmp19 ;
  FILE *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp___25 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int r ;
  int g ;
  int b ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int __cil_tmp37 ;
  int ncomp ;
  int tmp___29 ;
  char name[256] ;
  FILE *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp___30 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int l ;
  unsigned char lc ;
  int tmp___31 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
#line 1265
  fdest = (FILE *)((void *)0);
#line 1267
  tmp = outfile;
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1269
    if (! *tmp) {
#line 1269
      goto while_break;
    }
#line 1270
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1272
  __cil_tmp18 = tmp;
#line 1272
  tmp --;
#line 1273
  __cil_tmp19 = tmp;
#line 1273
  tmp --;
#line 1274
  S2 = *tmp;
#line 1276
  if (image->numcomps == 3) {
#line 1276
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1276
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1276
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1276
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1276
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1276
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1276
                if ((int )S2 != 103) {
#line 1276
                  if ((int )S2 != 71) {
                    {
#line 1284
                    fdest = fopen(outfile, "wb");
                    }
#line 1285
                    if (! fdest) {
                      {
#line 1286
                      fprintf(stderr, "ERROR -> failed to open %s for writing\n",
                              outfile);
                      }
#line 1287
                      return (1);
                    }
                    {
#line 1290
                    w = int_ceildiv___15(image->x1 - image->x0, (image->comps + 0)->dx);
#line 1291
                    wr = (image->comps + 0)->w;
#line 1293
                    h = int_ceildiv___15(image->y1 - image->y0, (image->comps + 0)->dy);
#line 1294
                    hr = (image->comps + 0)->h;
                    }
#line 1296
                    if ((image->comps + 0)->prec > 8) {
#line 1296
                      tmp___25 = 255;
                    } else {
#line 1296
                      tmp___25 = (1 << (image->comps + 0)->prec) - 1;
                    }
                    {
#line 1296
                    max = tmp___25;
#line 1298
                    __cil_tmp24 = int_ceildiv___15(image->x0, (image->comps + 0)->dx);
#line 1298
                    __cil_tmp25 = int_ceildivpow2___15((image->comps + 0)->x0 - __cil_tmp24,
                                                       (image->comps + 0)->factor);
#line 1298
                    (image->comps + 0)->x0 = __cil_tmp25;
#line 1299
                    __cil_tmp26 = int_ceildiv___15(image->y0, (image->comps + 0)->dy);
#line 1299
                    __cil_tmp27 = int_ceildivpow2___15((image->comps + 0)->y0 - __cil_tmp26,
                                                       (image->comps + 0)->factor);
#line 1299
                    (image->comps + 0)->y0 = __cil_tmp27;
#line 1301
                    fprintf(fdest, "P6\n%d %d\n%d\n\032V", wr, hr, max);
                    }
#line 1303
                    if ((image->comps + 0)->prec > 8) {
                      {
#line 1304
                      adjustR = (image->comps + 0)->prec - 8;
#line 1305
                      printf("PNM CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                             (image->comps + 0)->prec);
                      }
                    } else {
#line 1308
                      adjustR = 0;
                    }
#line 1309
                    if ((image->comps + 1)->prec > 8) {
                      {
#line 1310
                      adjustG = (image->comps + 1)->prec - 8;
#line 1311
                      printf("PNM CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                             (image->comps + 1)->prec);
                      }
                    } else {
#line 1314
                      adjustG = 0;
                    }
#line 1315
                    if ((image->comps + 2)->prec > 8) {
                      {
#line 1316
                      adjustB = (image->comps + 2)->prec - 8;
#line 1317
                      printf("PNM CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                             (image->comps + 2)->prec);
                      }
                    } else {
#line 1320
                      adjustB = 0;
                    }
#line 1323
                    i = 0;
                    {
#line 1323
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1323
                      if (! (i < wr * hr)) {
#line 1323
                        goto while_break___0;
                      }
#line 1326
                      r = *((image->comps + 0)->data + i);
#line 1327
                      if ((image->comps + 0)->sgnd) {
#line 1327
                        tmp___26 = 1 << ((image->comps + 0)->prec - 1);
                      } else {
#line 1327
                        tmp___26 = 0;
                      }
#line 1327
                      r += tmp___26;
#line 1328
                      rc = (unsigned char )((r >> adjustR) + (r >> (adjustR - 1)) % 2);
#line 1330
                      g = *((image->comps + 1)->data + i);
#line 1331
                      if ((image->comps + 1)->sgnd) {
#line 1331
                        tmp___27 = 1 << ((image->comps + 1)->prec - 1);
                      } else {
#line 1331
                        tmp___27 = 0;
                      }
#line 1331
                      g += tmp___27;
#line 1332
                      gc = (unsigned char )((g >> adjustG) + (g >> (adjustG - 1)) % 2);
#line 1334
                      b = *((image->comps + 2)->data + i);
#line 1335
                      if ((image->comps + 2)->sgnd) {
#line 1335
                        tmp___28 = 1 << ((image->comps + 2)->prec - 1);
                      } else {
#line 1335
                        tmp___28 = 0;
                      }
                      {
#line 1335
                      b += tmp___28;
#line 1336
                      bc = (unsigned char )((b >> adjustB) + (b >> (adjustB - 1)) % 2);
#line 1338
                      fprintf(fdest, "%c%c%c", (int )rc, (int )gc, (int )bc);
                      }
#line 1323
                      i ++;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                    {
#line 1340
                    fclose(fdest);
                    }
                  } else {
#line 1276
                    goto _L;
                  }
                } else {
#line 1276
                  goto _L;
                }
              } else {
#line 1276
                goto _L;
              }
            } else {
#line 1276
              goto _L;
            }
          } else {
#line 1276
            goto _L;
          }
        } else {
#line 1276
          goto _L;
        }
      } else {
#line 1276
        goto _L;
      }
    } else {
#line 1276
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___32: /* CIL Label */ 
    _L___33: /* CIL Label */ 
    _L___34: /* CIL Label */ 
    _L___35: /* CIL Label */ 
    _L___36: /* CIL Label */ 
    _L___37: /* CIL Label */ 
    _L___38: /* CIL Label */ 
#line 1343
    if ((int )S2 == 103 || (int )S2 == 71) {
#line 1343
      tmp___29 = 1;
    } else {
#line 1343
      tmp___29 = image->numcomps;
    }
#line 1343
    ncomp = tmp___29;
#line 1344
    if (image->numcomps > ncomp) {
      {
#line 1345
      fprintf(stderr, "WARNING -> [PGM files] Only the first component\n\220");
#line 1346
      fprintf(stderr, "           is written to the file\n");
      }
    }
#line 1348
    compno = 0;
    {
#line 1348
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1348
      if (! (compno < ncomp)) {
#line 1348
        goto while_break___1;
      }
#line 1350
      if (ncomp > 1) {
        {
#line 1351
        sprintf((char *)name, "%d.%s", compno, outfile);
        }
      } else {
        {
#line 1353
        sprintf((char *)name, "%s", outfile);
        }
      }
      {
#line 1356
      fdest = fopen((char const   *)((char *)name), "wb");
      }
#line 1357
      if (! fdest) {
        {
#line 1358
        fprintf(stderr, "ERROR -> failed to open %s for writing\n", (char *)name);
        }
#line 1359
        return (1);
      }
      {
#line 1362
      w = int_ceildiv___15(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1363
      wr = (image->comps + compno)->w;
#line 1365
      h = int_ceildiv___15(image->y1 - image->y0, (image->comps + compno)->dy);
#line 1366
      hr = (image->comps + compno)->h;
      }
#line 1368
      if ((image->comps + compno)->prec > 8) {
#line 1368
        tmp___30 = 255;
      } else {
#line 1368
        tmp___30 = (1 << (image->comps + compno)->prec) - 1;
      }
      {
#line 1368
      max = tmp___30;
#line 1370
      __cil_tmp45 = int_ceildiv___15(image->x0, (image->comps + compno)->dx);
#line 1370
      __cil_tmp46 = int_ceildivpow2___15((image->comps + compno)->x0 - __cil_tmp45,
                                         (image->comps + compno)->factor);
#line 1370
      (image->comps + compno)->x0 = __cil_tmp46;
#line 1371
      __cil_tmp47 = int_ceildiv___15(image->y0, (image->comps + compno)->dy);
#line 1371
      __cil_tmp48 = int_ceildivpow2___15((image->comps + compno)->y0 - __cil_tmp47,
                                         (image->comps + compno)->factor);
#line 1371
      (image->comps + compno)->y0 = __cil_tmp48;
#line 1373
      fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
      }
#line 1375
      if ((image->comps + compno)->prec > 8) {
        {
#line 1376
        adjustX = (image->comps + 0)->prec - 8;
#line 1377
        printf("PNM CONVERSION: Truncating component %d from %d bits to 8 bits\n",
               compno, (image->comps + compno)->prec);
        }
      } else {
#line 1380
        adjustX = 0;
      }
#line 1382
      i = 0;
      {
#line 1382
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1382
        if (! (i < wr * hr)) {
#line 1382
          goto while_break___2;
        }
#line 1385
        l = *((image->comps + compno)->data + i);
#line 1386
        if ((image->comps + compno)->sgnd) {
#line 1386
          tmp___31 = 1 << ((image->comps + compno)->prec - 1);
        } else {
#line 1386
          tmp___31 = 0;
        }
        {
#line 1386
        l += tmp___31;
#line 1387
        lc = (unsigned char )((l >> adjustX) + (l >> (adjustX - 1)) % 2);
#line 1388
        fprintf(fdest, "%c", (int )lc);
        }
#line 1382
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1390
      fclose(fdest);
      }
#line 1348
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1394
  return (0);
}
}
#line 1413 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetotif(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int imgsize ;
  int bps ;
  int index___39 ;
  int adjust ;
  int last_i ;
  TIFF *tif ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  TIFF *__cil_tmp14 ;
  tsize_t __cil_tmp15 ;
  tdata_t __cil_tmp16 ;
  int tmp ;
  tstrip_t __cil_tmp18 ;
  unsigned char *dat8 ;
  int i ;
  int ssize ;
  tsize_t __cil_tmp22 ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp26 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int __cil_tmp30 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int r1 ;
  int g1 ;
  int b1 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int r1___0 ;
  int g1___0 ;
  int b1___0 ;
  int r___3 ;
  int g___3 ;
  int b___3 ;
  int __cil_tmp46 ;
  int r___4 ;
  int g___4 ;
  int b___4 ;
  int __cil_tmp50 ;
  tstrip_t __cil_tmp51 ;
  TIFF *__cil_tmp52 ;
  tsize_t __cil_tmp53 ;
  tdata_t __cil_tmp54 ;
  tstrip_t __cil_tmp55 ;
  unsigned char *dat8___0 ;
  int i___0 ;
  tsize_t __cil_tmp58 ;
  int r___5 ;
  int __cil_tmp60 ;
  tsize_t __cil_tmp61 ;
  int r___6 ;
  int r1___1 ;
  tsize_t __cil_tmp64 ;
  int r___7 ;
  int __cil_tmp66 ;
  tstrip_t __cil_tmp67 ;

  {
#line 1415
  adjust = 0;
#line 1416
  last_i = 0;
#line 1422
  if (image->numcomps == 3) {
#line 1422
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1422
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1422
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1422
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1422
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1422
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1433
                tif = TIFFOpen(outfile, "wb\f\241\032V");
                }
#line 1434
                if (! tif) {
                  {
#line 1435
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1436
                  return (1);
                }
                {
#line 1439
                width = (image->comps + 0)->w;
#line 1440
                height = (image->comps + 0)->h;
#line 1441
                imgsize = width * height;
#line 1442
                bps = (image->comps + 0)->prec;
#line 1444
                TIFFSetField(tif, (ttag_t )256, width);
#line 1445
                TIFFSetField(tif, (ttag_t )257, height);
#line 1446
                TIFFSetField(tif, (ttag_t )277, 3);
#line 1447
                TIFFSetField(tif, (ttag_t )258, bps);
#line 1448
                TIFFSetField(tif, (ttag_t )274, 1);
#line 1449
                TIFFSetField(tif, (ttag_t )284, 1);
#line 1450
                TIFFSetField(tif, (ttag_t )262, 2);
#line 1451
                TIFFSetField(tif, (ttag_t )278, 1);
#line 1454
                strip_size = TIFFStripSize(tif);
#line 1455
                buf = _TIFFmalloc(strip_size);
#line 1456
                index___39 = 0;
                }
#line 1457
                if ((image->comps + 0)->sgnd) {
#line 1457
                  tmp = 1 << ((image->comps + 0)->prec - 1);
                } else {
#line 1457
                  tmp = 0;
                }
#line 1457
                adjust = tmp;
#line 1458
                strip = (tstrip_t )0;
                {
#line 1458
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1458
                  if (! (strip < __cil_tmp18)) {
#line 1458
                    goto while_break;
                  }
                  {
#line 1461
                  ssize = TIFFStripSize(tif);
#line 1462
                  dat8 = buf;
                  }
#line 1463
                  if ((image->comps + 0)->prec == 8) {
#line 1464
                    i = 0;
                    {
#line 1464
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1464
                      if (! (i < ssize - 2)) {
#line 1464
                        goto while_break___0;
                      }
#line 1465
                      r = 0;
#line 1465
                      g = 0;
#line 1465
                      b = 0;
#line 1466
                      if (index___39 < imgsize) {
#line 1467
                        r = *((image->comps + 0)->data + index___39);
#line 1468
                        g = *((image->comps + 1)->data + index___39);
#line 1469
                        b = *((image->comps + 2)->data + index___39);
#line 1470
                        if ((image->comps + 0)->sgnd) {
#line 1471
                          r += adjust;
#line 1472
                          g += adjust;
#line 1473
                          b += adjust;
                        }
#line 1475
                        *(dat8 + i) = (unsigned char )r;
#line 1476
                        *(dat8 + (i + 1)) = (unsigned char )g;
#line 1477
                        *(dat8 + (i + 2)) = (unsigned char )b;
#line 1478
                        index___39 ++;
#line 1479
                        last_i = i + 3;
                      } else {
#line 1481
                        goto while_break___0;
                      }
#line 1464
                      i += 3;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 1483
                    if (last_i < ssize) {
#line 1484
                      i = last_i;
                      {
#line 1484
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 1484
                        if (! (i < ssize)) {
#line 1484
                          goto while_break___1;
                        }
#line 1485
                        r___0 = 0;
#line 1485
                        g___0 = 0;
#line 1485
                        b___0 = 0;
#line 1486
                        if (index___39 < imgsize) {
#line 1487
                          r___0 = *((image->comps + 0)->data + index___39);
#line 1488
                          g___0 = *((image->comps + 1)->data + index___39);
#line 1489
                          b___0 = *((image->comps + 2)->data + index___39);
#line 1490
                          if ((image->comps + 0)->sgnd) {
#line 1491
                            r___0 += adjust;
#line 1492
                            g___0 += adjust;
#line 1493
                            b___0 += adjust;
                          }
#line 1495
                          *(dat8 + i) = (unsigned char )r___0;
#line 1496
                          if (i + 1 < ssize) {
#line 1496
                            *(dat8 + (i + 1)) = (unsigned char )g___0;
                          } else {
#line 1496
                            goto while_break___1;
                          }
#line 1497
                          if (i + 2 < ssize) {
#line 1497
                            *(dat8 + (i + 2)) = (unsigned char )b___0;
                          } else {
#line 1497
                            goto while_break___1;
                          }
#line 1498
                          index___39 ++;
                        } else {
#line 1500
                          goto while_break___1;
                        }
#line 1484
                        i += 3;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
                    }
                  } else
#line 1503
                  if ((image->comps + 0)->prec == 12) {
#line 1504
                    i = 0;
                    {
#line 1504
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 1504
                      if (! (i < ssize - 8)) {
#line 1504
                        goto while_break___2;
                      }
#line 1505
                      r___1 = 0;
#line 1505
                      g___1 = 0;
#line 1505
                      b___1 = 0;
#line 1506
                      r1 = 0;
#line 1506
                      g1 = 0;
#line 1506
                      b1 = 0;
#line 1507
                      if ((index___39 < imgsize) & (index___39 + 1 < imgsize)) {
#line 1508
                        r___1 = *((image->comps + 0)->data + index___39);
#line 1509
                        g___1 = *((image->comps + 1)->data + index___39);
#line 1510
                        b___1 = *((image->comps + 2)->data + index___39);
#line 1511
                        r1 = *((image->comps + 0)->data + (index___39 + 1));
#line 1512
                        g1 = *((image->comps + 1)->data + (index___39 + 1));
#line 1513
                        b1 = *((image->comps + 2)->data + (index___39 + 1));
#line 1514
                        if ((image->comps + 0)->sgnd) {
#line 1515
                          r___1 += adjust;
#line 1516
                          g___1 += adjust;
#line 1517
                          b___1 += adjust;
#line 1518
                          r1 += adjust;
#line 1519
                          g1 += adjust;
#line 1520
                          b1 += adjust;
                        }
#line 1522
                        *(dat8 + i) = (unsigned char )(r___1 >> 4);
#line 1523
                        *(dat8 + (i + 1)) = (unsigned char )(((r___1 & 15) << 4) | ((g___1 >> 8) & 15));
#line 1524
                        *(dat8 + (i + 2)) = (unsigned char )g___1;
#line 1525
                        *(dat8 + (i + 3)) = (unsigned char )(b___1 >> 4);
#line 1526
                        *(dat8 + (i + 4)) = (unsigned char )(((b___1 & 15) << 4) | ((r1 >> 8) & 15));
#line 1527
                        *(dat8 + (i + 5)) = (unsigned char )r1;
#line 1528
                        *(dat8 + (i + 6)) = (unsigned char )(g1 >> 4);
#line 1529
                        *(dat8 + (i + 7)) = (unsigned char )(((g1 & 15) << 4) | ((b1 >> 8) & 15));
#line 1530
                        *(dat8 + (i + 8)) = (unsigned char )b1;
#line 1531
                        index___39 += 2;
#line 1532
                        last_i = i + 9;
                      } else {
#line 1534
                        goto while_break___2;
                      }
#line 1504
                      i += 9;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 1536
                    if (last_i < ssize) {
#line 1537
                      i = last_i;
                      {
#line 1537
                      while (1) {
                        while_continue___3: /* CIL Label */ ;
#line 1537
                        if (! (i < ssize)) {
#line 1537
                          goto while_break___3;
                        }
#line 1538
                        r___2 = 0;
#line 1538
                        g___2 = 0;
#line 1538
                        b___2 = 0;
#line 1539
                        r1___0 = 0;
#line 1539
                        g1___0 = 0;
#line 1539
                        b1___0 = 0;
#line 1540
                        if ((index___39 < imgsize) & (index___39 + 1 < imgsize)) {
#line 1541
                          r___2 = *((image->comps + 0)->data + index___39);
#line 1542
                          g___2 = *((image->comps + 1)->data + index___39);
#line 1543
                          b___2 = *((image->comps + 2)->data + index___39);
#line 1544
                          r1___0 = *((image->comps + 0)->data + (index___39 + 1));
#line 1545
                          g1___0 = *((image->comps + 1)->data + (index___39 + 1));
#line 1546
                          b1___0 = *((image->comps + 2)->data + (index___39 + 1));
#line 1547
                          if ((image->comps + 0)->sgnd) {
#line 1548
                            r___2 += adjust;
#line 1549
                            g___2 += adjust;
#line 1550
                            b___2 += adjust;
#line 1551
                            r1___0 += adjust;
#line 1552
                            g1___0 += adjust;
#line 1553
                            b1___0 += adjust;
                          }
#line 1555
                          *(dat8 + i) = (unsigned char )(r___2 >> 4);
#line 1556
                          if (i + 1 < ssize) {
#line 1556
                            *(dat8 + (i + 1)) = (unsigned char )(((r___2 & 15) << 4) | ((g___2 >> 8) & 15));
                          } else {
#line 1556
                            goto while_break___3;
                          }
#line 1557
                          if (i + 2 < ssize) {
#line 1557
                            *(dat8 + (i + 2)) = (unsigned char )g___2;
                          } else {
#line 1557
                            goto while_break___3;
                          }
#line 1558
                          if (i + 3 < ssize) {
#line 1558
                            *(dat8 + (i + 3)) = (unsigned char )(b___2 >> 4);
                          } else {
#line 1558
                            goto while_break___3;
                          }
#line 1559
                          if (i + 4 < ssize) {
#line 1559
                            *(dat8 + (i + 4)) = (unsigned char )(((b___2 & 15) << 4) | ((r1___0 >> 8) & 15));
                          } else {
#line 1559
                            goto while_break___3;
                          }
#line 1560
                          if (i + 5 < ssize) {
#line 1560
                            *(dat8 + (i + 5)) = (unsigned char )r1___0;
                          } else {
#line 1560
                            goto while_break___3;
                          }
#line 1561
                          if (i + 6 < ssize) {
#line 1561
                            *(dat8 + (i + 6)) = (unsigned char )(g1___0 >> 4);
                          } else {
#line 1561
                            goto while_break___3;
                          }
#line 1562
                          if (i + 7 < ssize) {
#line 1562
                            *(dat8 + (i + 7)) = (unsigned char )(((g1___0 & 15) << 4) | ((b1___0 >> 8) & 15));
                          } else {
#line 1562
                            goto while_break___3;
                          }
#line 1563
                          if (i + 8 < ssize) {
#line 1563
                            *(dat8 + (i + 8)) = (unsigned char )b1___0;
                          } else {
#line 1563
                            goto while_break___3;
                          }
#line 1564
                          index___39 += 2;
                        } else {
#line 1566
                          goto while_break___3;
                        }
#line 1537
                        i += 9;
                      }
                      while_break___3: /* CIL Label */ ;
                      }
                    }
                  } else
#line 1569
                  if ((image->comps + 0)->prec == 16) {
#line 1570
                    i = 0;
                    {
#line 1570
                    while (1) {
                      while_continue___4: /* CIL Label */ ;
#line 1570
                      if (! (i < ssize - 5)) {
#line 1570
                        goto while_break___4;
                      }
#line 1571
                      r___3 = 0;
#line 1571
                      g___3 = 0;
#line 1571
                      b___3 = 0;
#line 1572
                      if (index___39 < imgsize) {
#line 1573
                        r___3 = *((image->comps + 0)->data + index___39);
#line 1574
                        g___3 = *((image->comps + 1)->data + index___39);
#line 1575
                        b___3 = *((image->comps + 2)->data + index___39);
#line 1576
                        if ((image->comps + 0)->sgnd) {
#line 1577
                          r___3 += adjust;
#line 1578
                          g___3 += adjust;
#line 1579
                          b___3 += adjust;
                        }
#line 1581
                        *(dat8 + i) = (unsigned char )r___3;
#line 1582
                        *(dat8 + (i + 1)) = (unsigned char )(r___3 >> 8);
#line 1583
                        *(dat8 + (i + 2)) = (unsigned char )g___3;
#line 1584
                        *(dat8 + (i + 3)) = (unsigned char )(g___3 >> 8);
#line 1585
                        *(dat8 + (i + 4)) = (unsigned char )b___3;
#line 1586
                        *(dat8 + (i + 5)) = (unsigned char )(b___3 >> 8);
#line 1587
                        index___39 ++;
#line 1588
                        last_i = i + 6;
                      } else {
#line 1590
                        goto while_break___4;
                      }
#line 1570
                      i += 6;
                    }
                    while_break___4: /* CIL Label */ ;
                    }
#line 1592
                    if (last_i < ssize) {
#line 1593
                      i = 0;
                      {
#line 1593
                      while (1) {
                        while_continue___5: /* CIL Label */ ;
#line 1593
                        if (! (i < ssize)) {
#line 1593
                          goto while_break___5;
                        }
#line 1594
                        r___4 = 0;
#line 1594
                        g___4 = 0;
#line 1594
                        b___4 = 0;
#line 1595
                        if (index___39 < imgsize) {
#line 1596
                          r___4 = *((image->comps + 0)->data + index___39);
#line 1597
                          g___4 = *((image->comps + 1)->data + index___39);
#line 1598
                          b___4 = *((image->comps + 2)->data + index___39);
#line 1599
                          if ((image->comps + 0)->sgnd) {
#line 1600
                            r___4 += adjust;
#line 1601
                            g___4 += adjust;
#line 1602
                            b___4 += adjust;
                          }
#line 1604
                          *(dat8 + i) = (unsigned char )r___4;
#line 1605
                          if (i + 1 < ssize) {
#line 1605
                            *(dat8 + (i + 1)) = (unsigned char )(r___4 >> 8);
                          } else {
#line 1605
                            goto while_break___5;
                          }
#line 1606
                          if (i + 2 < ssize) {
#line 1606
                            *(dat8 + (i + 2)) = (unsigned char )g___4;
                          } else {
#line 1606
                            goto while_break___5;
                          }
#line 1607
                          if (i + 3 < ssize) {
#line 1607
                            *(dat8 + (i + 3)) = (unsigned char )(g___4 >> 8);
                          } else {
#line 1607
                            goto while_break___5;
                          }
#line 1608
                          if (i + 4 < ssize) {
#line 1608
                            *(dat8 + (i + 4)) = (unsigned char )b___4;
                          } else {
#line 1608
                            goto while_break___5;
                          }
#line 1609
                          if (i + 5 < ssize) {
#line 1609
                            *(dat8 + (i + 5)) = (unsigned char )(b___4 >> 8);
                          } else {
#line 1609
                            goto while_break___5;
                          }
#line 1610
                          index___39 ++;
                        } else {
#line 1612
                          goto while_break___5;
                        }
#line 1593
                        i += 6;
                      }
                      while_break___5: /* CIL Label */ ;
                      }
                    }
                  } else {
                    {
#line 1616
                    fprintf(stderr, "Bits=%d, Only 8,12,16 bits implemented\n", (image->comps + 0)->prec);
#line 1617
                    fprintf(stderr, "Aborting\n");
                    }
#line 1618
                    return (1);
                  }
                  {
#line 1620
                  TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
                  }
#line 1458
                  strip ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 1622
                _TIFFfree(buf);
#line 1623
                TIFFClose(tif);
                }
              } else {
#line 1422
                goto _L;
              }
            } else {
#line 1422
              goto _L;
            }
          } else {
#line 1422
            goto _L;
          }
        } else {
#line 1422
          goto _L;
        }
      } else {
#line 1422
        goto _L;
      }
    } else {
#line 1422
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___40: /* CIL Label */ 
  _L___41: /* CIL Label */ 
  _L___42: /* CIL Label */ 
  _L___43: /* CIL Label */ 
  _L___44: /* CIL Label */ 
#line 1624
  if (image->numcomps == 1) {
    {
#line 1629
    tif = TIFFOpen(outfile, "wb");
    }
#line 1630
    if (! tif) {
      {
#line 1631
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1632
      return (1);
    }
    {
#line 1635
    width = (image->comps + 0)->w;
#line 1636
    height = (image->comps + 0)->h;
#line 1637
    imgsize = width * height;
#line 1638
    bps = (image->comps + 0)->prec;
#line 1641
    TIFFSetField(tif, (ttag_t )256, width);
#line 1642
    TIFFSetField(tif, (ttag_t )257, height);
#line 1643
    TIFFSetField(tif, (ttag_t )277, 1);
#line 1644
    TIFFSetField(tif, (ttag_t )258, bps);
#line 1645
    TIFFSetField(tif, (ttag_t )274, 1);
#line 1646
    TIFFSetField(tif, (ttag_t )284, 1);
#line 1647
    TIFFSetField(tif, (ttag_t )262, 1);
#line 1648
    TIFFSetField(tif, (ttag_t )278, 1);
#line 1651
    strip_size = TIFFStripSize(tif);
#line 1652
    buf = _TIFFmalloc(strip_size);
#line 1653
    index___39 = 0;
#line 1654
    strip = (tstrip_t )0;
    }
    {
#line 1654
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1654
      if (! (strip < __cil_tmp55)) {
#line 1654
        goto while_break___6;
      }
#line 1657
      dat8___0 = buf;
#line 1658
      if ((image->comps + 0)->prec == 8) {
#line 1659
        i___0 = 0;
        {
#line 1659
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1659
          if (! (i___0 < __cil_tmp58)) {
#line 1659
            goto while_break___7;
          }
#line 1660
          if (index___39 < imgsize) {
#line 1661
            r___5 = 0;
#line 1662
            r___5 = *((image->comps + 0)->data + index___39);
#line 1663
            if ((image->comps + 0)->sgnd) {
#line 1664
              r___5 += adjust;
            }
#line 1666
            *(dat8___0 + i___0) = (unsigned char )r___5;
#line 1667
            index___39 ++;
          } else {
#line 1669
            goto while_break___7;
          }
#line 1659
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else
#line 1671
      if ((image->comps + 0)->prec == 12) {
#line 1672
        i___0 = 0;
        {
#line 1672
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1672
          if (! (i___0 < __cil_tmp61)) {
#line 1672
            goto while_break___8;
          }
#line 1673
          if (index___39 < imgsize) {
#line 1674
            r___6 = 0;
#line 1674
            r1___1 = 0;
#line 1675
            r___6 = *((image->comps + 0)->data + index___39);
#line 1676
            r1___1 = *((image->comps + 0)->data + (index___39 + 1));
#line 1677
            if ((image->comps + 0)->sgnd) {
#line 1678
              r___6 += adjust;
#line 1679
              r1___1 += adjust;
            }
#line 1681
            *(dat8___0 + i___0) = (unsigned char )(r___6 >> 4);
#line 1682
            *(dat8___0 + (i___0 + 1)) = (unsigned char )(((r___6 & 15) << 4) | ((r1___1 >> 8) & 15));
#line 1683
            *(dat8___0 + (i___0 + 2)) = (unsigned char )r1___1;
#line 1684
            index___39 += 2;
          } else {
#line 1686
            goto while_break___8;
          }
#line 1672
          i___0 += 3;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else
#line 1688
      if ((image->comps + 0)->prec == 16) {
#line 1689
        i___0 = 0;
        {
#line 1689
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1689
          if (! (i___0 < __cil_tmp64)) {
#line 1689
            goto while_break___9;
          }
#line 1690
          if (index___39 < imgsize) {
#line 1691
            r___7 = 0;
#line 1692
            r___7 = *((image->comps + 0)->data + index___39);
#line 1693
            if ((image->comps + 0)->sgnd) {
#line 1694
              r___7 += adjust;
            }
#line 1696
            *(dat8___0 + i___0) = (unsigned char )r___7;
#line 1697
            *(dat8___0 + (i___0 + 1)) = (unsigned char )(r___7 >> 8);
#line 1698
            index___39 ++;
          } else {
#line 1700
            goto while_break___9;
          }
#line 1689
          i___0 += 2;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
        {
#line 1703
        fprintf(stderr, "TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",
                (image->comps + 0)->prec);
#line 1704
        fprintf(stderr, "Aborting\n");
        }
#line 1705
        return (1);
      }
      {
#line 1707
      TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
      }
#line 1654
      strip ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1709
    _TIFFfree(buf);
#line 1710
    TIFFClose(tif);
    }
  } else {
    {
#line 1712
    fprintf(stderr, "TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n\220");
#line 1713
    fprintf(stderr, "Aborting\n");
    }
#line 1714
    return (1);
  }
#line 1716
  return (0);
}
}
#line 1719 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  TIFF *tif ;
  tiff_infoheader_t Info ;
  tdata_t buf ;
  tstrip_t strip ;
  tsize_t strip_size ;
  int j ;
  int numcomps ;
  int w ;
  int h ;
  int index___45 ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  int imgsize ;
  TIFF *__cil_tmp19 ;
  int __cil_tmp20 ;
  opj_image_t *__cil_tmp21 ;
  int tmp ;
  int tmp___0 ;
  tsize_t __cil_tmp24 ;
  tdata_t __cil_tmp25 ;
  tsize_t __cil_tmp26 ;
  tstrip_t __cil_tmp27 ;
  unsigned char *dat8 ;
  int i ;
  int ssize ;
  tsize_t __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  tstrip_t __cil_tmp34 ;
  opj_image_t *__cil_tmp35 ;
  int tmp___1 ;
  int tmp___2 ;
  tsize_t __cil_tmp38 ;
  tdata_t __cil_tmp39 ;
  tsize_t __cil_tmp40 ;
  tstrip_t __cil_tmp41 ;
  unsigned char *dat8___0 ;
  int i___0 ;
  int ssize___0 ;
  tsize_t __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  tstrip_t __cil_tmp48 ;

  {
  {
#line 1721
  subsampling_dx = parameters->subsampling_dx;
#line 1722
  subsampling_dy = parameters->subsampling_dy;
#line 1731
  image = (opj_image_t *)((void *)0);
#line 1732
  imgsize = 0;
#line 1734
  tif = TIFFOpen(filename, "r");
  }
#line 1736
  if (! tif) {
    {
#line 1737
    fprintf(stderr, "Failed to open %s for reading\n", filename);
    }
#line 1738
    return ((opj_image_t *)0);
  }
  {
#line 1741
  TIFFGetField(tif, (ttag_t )256, & Info.tiWidth);
#line 1742
  TIFFGetField(tif, (ttag_t )257, & Info.tiHeight);
#line 1743
  TIFFGetField(tif, (ttag_t )258, & Info.tiBps);
#line 1744
  TIFFGetField(tif, (ttag_t )339, & Info.tiSf);
#line 1745
  TIFFGetField(tif, (ttag_t )277, & Info.tiSpp);
#line 1746
  Info.tiPhoto = (DWORD )0;
#line 1747
  TIFFGetField(tif, (ttag_t )262, & Info.tiPhoto);
#line 1748
  TIFFGetField(tif, (ttag_t )284, & Info.tiPC);
#line 1749
  w = (int )Info.tiWidth;
#line 1750
  h = (int )Info.tiHeight;
  }
#line 1752
  if (Info.tiPhoto == 2UL) {
    {
#line 1757
    numcomps = 3;
#line 1758
    color_space = (OPJ_COLOR_SPACE )1;
#line 1760
    memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 1761
    j = 0;
    }
    {
#line 1761
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1761
      if (! (j < numcomps)) {
#line 1761
        goto while_break;
      }
#line 1762
      if (parameters->cp_cinema) {
#line 1763
        cmptparm[j].prec = 12;
#line 1764
        cmptparm[j].bpp = 12;
      } else {
#line 1766
        cmptparm[j].prec = (int )Info.tiBps;
#line 1767
        cmptparm[j].bpp = (int )Info.tiBps;
      }
#line 1769
      cmptparm[j].sgnd = 0;
#line 1770
      cmptparm[j].dx = subsampling_dx;
#line 1771
      cmptparm[j].dy = subsampling_dy;
#line 1772
      cmptparm[j].w = w;
#line 1773
      cmptparm[j].h = h;
#line 1761
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1776
    image = opj_image_create(numcomps, & cmptparm[0], color_space);
    }
#line 1777
    if (! image) {
      {
#line 1778
      TIFFClose(tif);
      }
#line 1779
      return ((opj_image_t *)((void *)0));
    }
#line 1783
    image->x0 = parameters->image_offset_x0;
#line 1784
    image->y0 = parameters->image_offset_y0;
#line 1785
    if (! image->x0) {
#line 1785
      tmp = (w - 1) * subsampling_dx + 1;
    } else {
#line 1785
      tmp = (image->x0 + (w - 1) * subsampling_dx) + 1;
    }
#line 1785
    image->x1 = tmp;
#line 1786
    if (! image->y0) {
#line 1786
      tmp___0 = (h - 1) * subsampling_dy + 1;
    } else {
#line 1786
      tmp___0 = (image->y0 + (h - 1) * subsampling_dy) + 1;
    }
    {
#line 1786
    image->y1 = tmp___0;
#line 1788
    __cil_tmp24 = TIFFStripSize(tif);
#line 1788
    __cil_tmp25 = _TIFFmalloc(__cil_tmp24);
#line 1788
    buf = __cil_tmp25;
#line 1789
    strip_size = 0;
#line 1790
    strip_size = TIFFStripSize(tif);
#line 1791
    index___45 = 0;
#line 1792
    imgsize = (image->comps + 0)->w * (image->comps + 0)->h;
#line 1794
    strip = (tstrip_t )0;
    }
    {
#line 1794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1794
      if (! (strip < __cil_tmp27)) {
#line 1794
        goto while_break___0;
      }
      {
#line 1797
      ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 1798
      dat8 = buf;
      }
#line 1800
      if ((int )Info.tiBps == 12) {
#line 1801
        i = 0;
        {
#line 1801
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1801
          if (! (i < ssize)) {
#line 1801
            goto while_break___1;
          }
#line 1802
          if ((index___45 < imgsize) & (index___45 + 1 < imgsize)) {
#line 1803
            *((image->comps + 0)->data + index___45) = ((int )*(dat8 + i) << 4) | ((int )*(dat8 + (i + 1)) >> 4);
#line 1804
            *((image->comps + 1)->data + index___45) = (((int )*(dat8 + (i + 1)) & 15) << 8) | (int )*(dat8 + (i + 2));
#line 1805
            *((image->comps + 2)->data + index___45) = ((int )*(dat8 + (i + 3)) << 4) | ((int )*(dat8 + (i + 4)) >> 4);
#line 1806
            *((image->comps + 0)->data + (index___45 + 1)) = (((int )*(dat8 + (i + 4)) & 15) << 8) | (int )*(dat8 + (i + 5));
#line 1807
            *((image->comps + 1)->data + (index___45 + 1)) = ((int )*(dat8 + (i + 6)) << 4) | ((int )*(dat8 + (i + 7)) >> 4);
#line 1808
            *((image->comps + 2)->data + (index___45 + 1)) = (((int )*(dat8 + (i + 7)) & 15) << 8) | (int )*(dat8 + (i + 8));
#line 1809
            index___45 += 2;
          } else {
#line 1811
            goto while_break___1;
          }
#line 1801
          i += 9;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1814
      if ((int )Info.tiBps == 16) {
#line 1815
        i = 0;
        {
#line 1815
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1815
          if (! (i < ssize)) {
#line 1815
            goto while_break___2;
          }
#line 1816
          if (index___45 < imgsize) {
#line 1817
            *((image->comps + 0)->data + index___45) = ((int )*(dat8 + (i + 1)) << 8) | (int )*(dat8 + i);
#line 1818
            *((image->comps + 1)->data + index___45) = ((int )*(dat8 + (i + 3)) << 8) | (int )*(dat8 + (i + 2));
#line 1819
            *((image->comps + 2)->data + index___45) = ((int )*(dat8 + (i + 5)) << 8) | (int )*(dat8 + (i + 4));
#line 1820
            if (parameters->cp_cinema) {
#line 1821
              *((image->comps + 0)->data + index___45) = (*((image->comps + 0)->data + index___45) + 8) >> 4;
#line 1822
              *((image->comps + 1)->data + index___45) = (*((image->comps + 1)->data + index___45) + 8) >> 4;
#line 1823
              *((image->comps + 2)->data + index___45) = (*((image->comps + 2)->data + index___45) + 8) >> 4;
            }
#line 1825
            index___45 ++;
          } else {
#line 1827
            goto while_break___2;
          }
#line 1815
          i += 6;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 1830
      if ((int )Info.tiBps == 8) {
#line 1831
        i = 0;
        {
#line 1831
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1831
          if (! (i < ssize)) {
#line 1831
            goto while_break___3;
          }
#line 1832
          if (index___45 < imgsize) {
#line 1833
            *((image->comps + 0)->data + index___45) = (int )*(dat8 + i);
#line 1834
            *((image->comps + 1)->data + index___45) = (int )*(dat8 + (i + 1));
#line 1835
            *((image->comps + 2)->data + index___45) = (int )*(dat8 + (i + 2));
#line 1836
            if (parameters->cp_cinema) {
#line 1837
              *((image->comps + 0)->data + index___45) <<= 4;
#line 1838
              *((image->comps + 1)->data + index___45) <<= 4;
#line 1839
              *((image->comps + 2)->data + index___45) <<= 4;
            }
#line 1841
            index___45 ++;
          } else {
#line 1843
            goto while_break___3;
          }
#line 1831
          i += 3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 1847
        fprintf(stderr, "TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",
                (int )Info.tiBps);
#line 1848
        fprintf(stderr, "Aborting\n");
        }
#line 1849
        return ((opj_image_t *)((void *)0));
      }
#line 1794
      strip ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1853
    _TIFFfree(buf);
#line 1854
    TIFFClose(tif);
    }
  } else
#line 1855
  if (Info.tiPhoto == 1UL) {
    {
#line 1860
    numcomps = 1;
#line 1861
    color_space = (OPJ_COLOR_SPACE )2;
#line 1863
    memset(& cmptparm[0], 0, sizeof(opj_image_cmptparm_t ));
#line 1864
    cmptparm[0].prec = (int )Info.tiBps;
#line 1865
    cmptparm[0].bpp = (int )Info.tiBps;
#line 1866
    cmptparm[0].sgnd = 0;
#line 1867
    cmptparm[0].dx = subsampling_dx;
#line 1868
    cmptparm[0].dy = subsampling_dy;
#line 1869
    cmptparm[0].w = w;
#line 1870
    cmptparm[0].h = h;
#line 1873
    image = opj_image_create(numcomps, & cmptparm[0], color_space);
    }
#line 1874
    if (! image) {
      {
#line 1875
      TIFFClose(tif);
      }
#line 1876
      return ((opj_image_t *)((void *)0));
    }
#line 1879
    image->x0 = parameters->image_offset_x0;
#line 1880
    image->y0 = parameters->image_offset_y0;
#line 1881
    if (! image->x0) {
#line 1881
      tmp___1 = (w - 1) * subsampling_dx + 1;
    } else {
#line 1881
      tmp___1 = (image->x0 + (w - 1) * subsampling_dx) + 1;
    }
#line 1881
    image->x1 = tmp___1;
#line 1882
    if (! image->y0) {
#line 1882
      tmp___2 = (h - 1) * subsampling_dy + 1;
    } else {
#line 1882
      tmp___2 = (image->y0 + (h - 1) * subsampling_dy) + 1;
    }
    {
#line 1882
    image->y1 = tmp___2;
#line 1884
    __cil_tmp38 = TIFFStripSize(tif);
#line 1884
    __cil_tmp39 = _TIFFmalloc(__cil_tmp38);
#line 1884
    buf = __cil_tmp39;
#line 1885
    strip_size = 0;
#line 1886
    strip_size = TIFFStripSize(tif);
#line 1887
    index___45 = 0;
#line 1888
    imgsize = (image->comps + 0)->w * (image->comps + 0)->h;
#line 1890
    strip = (tstrip_t )0;
    }
    {
#line 1890
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1890
      if (! (strip < __cil_tmp41)) {
#line 1890
        goto while_break___4;
      }
      {
#line 1893
      ssize___0 = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
#line 1894
      dat8___0 = buf;
      }
#line 1896
      if ((int )Info.tiBps == 12) {
#line 1897
        i___0 = 0;
        {
#line 1897
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1897
          if (! (i___0 < ssize___0)) {
#line 1897
            goto while_break___5;
          }
#line 1898
          if (index___45 < imgsize) {
#line 1899
            *((image->comps + 0)->data + index___45) = ((int )*(dat8___0 + i___0) << 4) | ((int )*(dat8___0 + (i___0 + 1)) >> 4);
#line 1900
            *((image->comps + 0)->data + (index___45 + 1)) = (((int )*(dat8___0 + (i___0 + 1)) & 15) << 8) | (int )*(dat8___0 + (i___0 + 2));
#line 1901
            index___45 += 2;
          } else {
#line 1903
            goto while_break___5;
          }
#line 1897
          i___0 += 3;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else
#line 1906
      if ((int )Info.tiBps == 16) {
#line 1907
        i___0 = 0;
        {
#line 1907
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1907
          if (! (i___0 < ssize___0)) {
#line 1907
            goto while_break___6;
          }
#line 1908
          if (index___45 < imgsize) {
#line 1909
            *((image->comps + 0)->data + index___45) = ((int )*(dat8___0 + (i___0 + 1)) << 8) | (int )*(dat8___0 + i___0);
#line 1910
            index___45 ++;
          } else {
#line 1912
            goto while_break___6;
          }
#line 1907
          i___0 += 2;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 1915
      if ((int )Info.tiBps == 8) {
#line 1916
        i___0 = 0;
        {
#line 1916
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1916
          if (! (i___0 < ssize___0)) {
#line 1916
            goto while_break___7;
          }
#line 1917
          if (index___45 < imgsize) {
#line 1918
            *((image->comps + 0)->data + index___45) = (int )*(dat8___0 + i___0);
#line 1919
            index___45 ++;
          } else {
#line 1921
            goto while_break___7;
          }
#line 1916
          i___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 1925
        fprintf(stderr, "TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",
                (int )Info.tiBps);
#line 1926
        fprintf(stderr, "Aborting\n");
        }
#line 1927
        return ((opj_image_t *)((void *)0));
      }
#line 1890
      strip ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1931
    _TIFFfree(buf);
#line 1932
    TIFFClose(tif);
    }
  } else {
    {
#line 1934
    fprintf(stderr, "TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n\220");
#line 1935
    fprintf(stderr, "Aborting\n\233\016\241\032V");
    }
#line 1936
    return ((opj_image_t *)((void *)0));
  }
#line 1938
  return (image);
}
}
#line 1947 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_image_t *__cil_tmp19 ;
  unsigned char value ;
  unsigned long __cil_tmp21 ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned short value___0 ;
  unsigned long __cil_tmp26 ;
  int tmp___0 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 1948
  subsampling_dx = parameters->subsampling_dx;
#line 1949
  subsampling_dy = parameters->subsampling_dy;
#line 1951
  f = (FILE *)((void *)0);
#line 1955
  image = (opj_image_t *)((void *)0);
#line 1958
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 1960
    fprintf(stderr, "\nError: invalid raw image parameters\nV");
#line 1961
    fprintf(stderr, "Please use the Format option -F:\n\341\307\240\032V");
#line 1962
    fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 1963
    fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 1964
    fprintf(stderr, "Aborting\n\233\016\241\032V");
    }
#line 1965
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1968
  f = fopen(filename, "rb\016\241\032V");
  }
#line 1969
  if (! f) {
    {
#line 1970
    fprintf(stderr, "Failed to open %s for reading !!\n\270\016\241\032V", filename);
#line 1971
    fprintf(stderr, "Aborting\n");
    }
#line 1972
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1974
  numcomps = raw_cp->rawComp;
#line 1975
  color_space = (OPJ_COLOR_SPACE )1;
#line 1976
  w = raw_cp->rawWidth;
#line 1977
  h = raw_cp->rawHeight;
#line 1978
  __cil_tmp17 = malloc((unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1978
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp17;
#line 1981
  memset(cmptparm + 0, 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1982
  i = 0;
  }
  {
#line 1982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1982
    if (! (i < numcomps)) {
#line 1982
      goto while_break;
    }
#line 1983
    (cmptparm + i)->prec = raw_cp->rawBitDepth;
#line 1984
    (cmptparm + i)->bpp = raw_cp->rawBitDepth;
#line 1985
    (cmptparm + i)->sgnd = raw_cp->rawSigned;
#line 1986
    (cmptparm + i)->dx = subsampling_dx;
#line 1987
    (cmptparm + i)->dy = subsampling_dy;
#line 1988
    (cmptparm + i)->w = w;
#line 1989
    (cmptparm + i)->h = h;
#line 1982
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1992
  image = opj_image_create(numcomps, cmptparm + 0, color_space);
  }
#line 1993
  if (! image) {
    {
#line 1994
    fclose(f);
    }
#line 1995
    return ((opj_image_t *)((void *)0));
  }
#line 1998
  image->x0 = parameters->image_offset_x0;
#line 1999
  image->y0 = parameters->image_offset_y0;
#line 2000
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 2001
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 2003
  if (raw_cp->rawBitDepth <= 8) {
#line 2005
    value = (unsigned char )0;
#line 2006
    compno = 0;
    {
#line 2006
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2006
      if (! (compno < numcomps)) {
#line 2006
        goto while_break___0;
      }
#line 2007
      i = 0;
      {
#line 2007
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2007
        if (! (i < w * h)) {
#line 2007
          goto while_break___1;
        }
        {
#line 2008
        __cil_tmp21 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 2008
        if (! __cil_tmp21) {
          {
#line 2009
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2010
          return ((opj_image_t *)((void *)0));
        }
#line 2012
        if (raw_cp->rawSigned) {
#line 2012
          tmp = (int )((char )value);
        } else {
#line 2012
          tmp = (int )value;
        }
#line 2012
        *((image->comps + compno)->data + i) = tmp;
#line 2007
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2006
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 2018
    value___0 = (unsigned short )0;
#line 2019
    compno = 0;
    {
#line 2019
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2019
      if (! (compno < numcomps)) {
#line 2019
        goto while_break___2;
      }
#line 2020
      i = 0;
      {
#line 2020
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2020
        if (! (i < w * h)) {
#line 2020
          goto while_break___3;
        }
        {
#line 2021
        __cil_tmp26 = fread(& value___0, (unsigned long )2, (unsigned long )1, f);
        }
#line 2021
        if (! __cil_tmp26) {
          {
#line 2022
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2023
          return ((opj_image_t *)((void *)0));
        }
#line 2025
        if (raw_cp->rawSigned) {
#line 2025
          tmp___0 = (int )((short )value___0);
        } else {
#line 2025
          tmp___0 = (int )value___0;
        }
#line 2025
        *((image->comps + compno)->data + i) = tmp___0;
#line 2020
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2019
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2030
  __cil_tmp30 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 2030
  if (__cil_tmp30) {
    {
#line 2031
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
  }
  {
#line 2033
  fclose(f);
  }
#line 2035
  return (image);
}
}
#line 2038 "/doner/openjpeg/openjpeg-65e5ff0/codec/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  FILE *rawFile ;
  int compno ;
  int w ;
  int h ;
  int line ;
  int row ;
  int *ptr ;
  FILE *__cil_tmp10 ;
  char const   *tmp ;
  signed char curr ;
  int mask ;
  int *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char curr___0 ;
  int mask___0 ;
  int *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  short curr___1 ;
  int mask___1 ;
  int *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned short curr___2 ;
  int mask___2 ;
  int *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 2040
  rawFile = (FILE *)((void *)0);
#line 2046
  if ((image->numcomps * image->x1) * image->y1 == 0) {
    {
#line 2048
    fprintf(stderr, "\nError: invalid raw image parameters\n");
    }
#line 2049
    return (1);
  }
  {
#line 2052
  rawFile = fopen(outfile, "wb\016\241\032V");
  }
#line 2053
  if (! rawFile) {
    {
#line 2054
    fprintf(stderr, "Failed to open %s for writing !!\n\377\016\241\032V", outfile);
    }
#line 2055
    return (1);
  }
  {
#line 2058
  fprintf(stdout, "Raw image characteristics: %d components\n`\016\241\032V", image->numcomps);
#line 2060
  compno = 0;
  }
  {
#line 2060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2060
    if (! (compno < image->numcomps)) {
#line 2060
      goto while_break;
    }
#line 2062
    if ((image->comps + compno)->sgnd == 1) {
#line 2062
      tmp = "signed";
    } else {
#line 2062
      tmp = "unsigned\220";
    }
    {
#line 2062
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n\016\241\032V", compno,
            (image->comps + compno)->w, (image->comps + compno)->h, (image->comps + compno)->prec,
            tmp);
#line 2065
    w = (image->comps + compno)->w;
#line 2066
    h = (image->comps + compno)->h;
    }
#line 2068
    if ((image->comps + compno)->prec <= 8) {
#line 2070
      if ((image->comps + compno)->sgnd == 1) {
#line 2073
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2074
        ptr = (image->comps + compno)->data;
#line 2075
        line = 0;
        {
#line 2075
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2075
          if (! (line < h)) {
#line 2075
            goto while_break___0;
          }
#line 2076
          row = 0;
          {
#line 2076
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2076
            if (! (row < w)) {
#line 2076
              goto while_break___1;
            }
            {
#line 2077
            curr = (signed char )(*ptr & mask);
#line 2078
            fwrite(& curr, sizeof(signed char ), (unsigned long )1, rawFile);
#line 2079
            ptr ++;
            }
#line 2076
            row ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2075
          line ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 2083
      if ((image->comps + compno)->sgnd == 0) {
#line 2086
        mask___0 = (1 << (image->comps + compno)->prec) - 1;
#line 2087
        ptr = (image->comps + compno)->data;
#line 2088
        line = 0;
        {
#line 2088
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2088
          if (! (line < h)) {
#line 2088
            goto while_break___2;
          }
#line 2089
          row = 0;
          {
#line 2089
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2089
            if (! (row < w)) {
#line 2089
              goto while_break___3;
            }
            {
#line 2090
            curr___0 = (unsigned char )(*ptr & mask___0);
#line 2091
            fwrite(& curr___0, sizeof(unsigned char ), (unsigned long )1, rawFile);
#line 2092
            ptr ++;
            }
#line 2089
            row ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2088
          line ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 2097
    if ((image->comps + compno)->prec <= 16) {
#line 2099
      if ((image->comps + compno)->sgnd == 1) {
#line 2102
        mask___1 = (1 << (image->comps + compno)->prec) - 1;
#line 2103
        ptr = (image->comps + compno)->data;
#line 2104
        line = 0;
        {
#line 2104
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2104
          if (! (line < h)) {
#line 2104
            goto while_break___4;
          }
#line 2105
          row = 0;
          {
#line 2105
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2105
            if (! (row < w)) {
#line 2105
              goto while_break___5;
            }
            {
#line 2106
            curr___1 = (short )(*ptr & mask___1);
#line 2107
            fwrite(& curr___1, sizeof(short ), (unsigned long )1, rawFile);
#line 2108
            ptr ++;
            }
#line 2105
            row ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2104
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2112
      if ((image->comps + compno)->sgnd == 0) {
#line 2115
        mask___2 = (1 << (image->comps + compno)->prec) - 1;
#line 2116
        ptr = (image->comps + compno)->data;
#line 2117
        line = 0;
        {
#line 2117
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2117
          if (! (line < h)) {
#line 2117
            goto while_break___6;
          }
#line 2118
          row = 0;
          {
#line 2118
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2118
            if (! (row < w)) {
#line 2118
              goto while_break___7;
            }
            {
#line 2119
            curr___2 = (unsigned short )(*ptr & mask___2);
#line 2120
            fwrite(& curr___2, sizeof(unsigned short ), (unsigned long )1, rawFile);
#line 2121
            ptr ++;
            }
#line 2118
            row ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2117
          line ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    } else
#line 2126
    if ((image->comps + compno)->prec <= 32) {
      {
#line 2128
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
      }
#line 2129
      return (1);
    } else {
      {
#line 2133
      fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
      }
#line 2134
      return (1);
    }
#line 2060
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2137
  fclose(rawFile);
  }
#line 2138
  return (0);
}
}
#line 43 "/doner/openjpeg/openjpeg-65e5ff0/codec/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int start_pos ;
  int end_ph_pos ;
  int end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___46 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___47 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___48 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___49 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___50 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___51 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 45
  stream = (FILE *)((void *)0);
#line 46
  total_disto = (double )0;
#line 57
  if (! cstr_info) {
#line 58
    return (1);
  }
  {
#line 60
  stream = fopen((char const   *)index___0, "w");
  }
#line 61
  if (! stream) {
    {
#line 62
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 63
    return (1);
  }
#line 66
  if ((cstr_info->tile + 0)->distotile) {
#line 67
    disto_on = (char )1;
  } else {
#line 69
    disto_on = (char )0;
  }
#line 71
  if ((cstr_info->tile + 0)->numpix) {
#line 72
    numpix_on = (char )1;
  } else {
#line 74
    numpix_on = (char )0;
  }
  {
#line 76
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 77
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 78
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 80
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 81
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 82
  fprintf(stream, "%d\n", cstr_info->numdecompos);
#line 84
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (resno >= 0)) {
#line 84
      goto while_break;
    }
    {
#line 85
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 84
    __cil_tmp17 = resno;
#line 84
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  fprintf(stream, "\n");
#line 91
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 93
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 94
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 96
  fprintf(stream, "\nINFO ON TILES\n");
#line 97
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 98
  if (disto_on) {
    {
#line 99
    fprintf(stream, "         disto");
    }
  }
#line 100
  if (numpix_on) {
    {
#line 101
    fprintf(stream, "     nbpix");
    }
  }
#line 102
  if ((int )disto_on) {
#line 102
    if ((int )numpix_on) {
      {
#line 103
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 104
  fprintf(stream, "\n");
#line 106
  tileno = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 113
    if (disto_on) {
      {
#line 114
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 115
    if (numpix_on) {
      {
#line 116
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 117
    if ((int )disto_on) {
#line 117
      if ((int )numpix_on) {
        {
#line 118
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 119
    fprintf(stream, "\n");
    }
#line 106
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  tileno = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 122
      goto while_break___1;
    }
#line 124
    disto = (double )0;
#line 125
    max_numdecompos = 0;
#line 126
    pack_nb = 0;
#line 128
    compno = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (compno < cstr_info->numcomps)) {
#line 128
        goto while_break___2;
      }
#line 129
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 130
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 128
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 134
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 135
    tilepartno = 0;
    }
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 135
        goto while_break___3;
      }
      {
#line 136
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 135
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 145
    if ((int )cstr_info->prog == 0) {
      {
#line 146
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 147
      if (disto_on) {
        {
#line 148
        fprintf(stream, " disto");
        }
      }
      {
#line 149
      fprintf(stream, "\n");
#line 151
      layno = 0;
      }
      {
#line 151
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 151
        if (! (layno < cstr_info->numlayers)) {
#line 151
          goto while_break___4;
        }
#line 152
        resno = 0;
        {
#line 152
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 152
          if (! (resno < max_numdecompos + 1)) {
#line 152
            goto while_break___5;
          }
#line 153
          compno = 0;
          {
#line 153
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 153
            if (! (compno < cstr_info->numcomps)) {
#line 153
              goto while_break___6;
            }
#line 155
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 156
              goto while_break___6;
            }
#line 157
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 158
            precno = 0;
            {
#line 158
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 158
              if (! (precno < prec_max)) {
#line 158
                goto while_break___7;
              }
              {
#line 159
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 160
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 161
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 162
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 163
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 165
              if (disto_on) {
                {
#line 166
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 167
              fprintf(stream, "\n");
#line 168
              total_disto += disto;
#line 169
              pack_nb ++;
              }
#line 158
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 153
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 152
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 151
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 176
    if ((int )cstr_info->prog == 1) {
      {
#line 177
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 178
      if (disto_on) {
        {
#line 179
        fprintf(stream, " disto");
        }
      }
      {
#line 180
      fprintf(stream, "\n");
#line 182
      resno = 0;
      }
      {
#line 182
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 182
        if (! (resno < max_numdecompos + 1)) {
#line 182
          goto while_break___8;
        }
#line 183
        layno = 0;
        {
#line 183
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 183
          if (! (layno < cstr_info->numlayers)) {
#line 183
            goto while_break___9;
          }
#line 184
          compno = 0;
          {
#line 184
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 184
            if (! (compno < cstr_info->numcomps)) {
#line 184
              goto while_break___10;
            }
#line 186
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 187
              goto while_break___10;
            }
#line 188
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 189
            precno = 0;
            {
#line 189
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 189
              if (! (precno < prec_max___0)) {
#line 189
                goto while_break___11;
              }
              {
#line 190
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 191
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 192
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 193
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 194
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d", pack_nb, tileno,
                      resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
              }
#line 196
              if (disto_on) {
                {
#line 197
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 198
              fprintf(stream, "\n");
#line 199
              total_disto += disto;
#line 200
              pack_nb ++;
              }
#line 189
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 184
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 183
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 182
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 207
    if ((int )cstr_info->prog == 2) {
      {
#line 209
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 210
      if (disto_on) {
        {
#line 211
        fprintf(stream, " disto");
        }
      }
      {
#line 212
      fprintf(stream, "\n");
#line 214
      resno = 0;
      }
      {
#line 214
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 214
        if (! (resno < max_numdecompos + 1)) {
#line 214
          goto while_break___12;
        }
#line 215
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 216
        precno = 0;
        {
#line 216
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 216
          if (! (precno < numprec)) {
#line 216
            goto while_break___13;
          }
          {
#line 218
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 218
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 219
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          y0___46 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 220
          x1 = x0 + cstr_info->tile_x;
#line 221
          y1___47 = y0___46 + cstr_info->tile_y;
#line 222
          compno = 0;
          }
          {
#line 222
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 222
            if (! (compno < cstr_info->numcomps)) {
#line 222
              goto while_break___14;
            }
            {
#line 223
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 224
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 224
            pcx = (int )__cil_tmp47;
#line 225
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcy = (int )__cil_tmp49;
#line 226
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 226
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 227
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_y = (int )__cil_tmp53;
            }
#line 228
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 229
              goto while_break___14;
            }
#line 230
            y = y0___46;
            {
#line 230
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 230
              if (! (y < y1___47)) {
#line 230
                goto while_break___15;
              }
#line 231
              if (precno_y * pcy == y) {
#line 232
                x = x0;
                {
#line 232
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 232
                  if (! (x < x1)) {
#line 232
                    goto while_break___16;
                  }
#line 233
                  if (precno_x * pcx == x) {
#line 234
                    layno = 0;
                    {
#line 234
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 234
                      if (! (layno < cstr_info->numlayers)) {
#line 234
                        goto while_break___17;
                      }
                      {
#line 235
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 236
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 237
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 238
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 239
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d", pack_nb,
                              tileno, resno, precno, compno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 241
                      if (disto_on) {
                        {
#line 242
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 243
                      fprintf(stream, "\n");
#line 244
                      total_disto += disto;
#line 245
                      pack_nb ++;
                      }
#line 234
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 232
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 230
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 222
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 216
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 214
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 256
    if ((int )cstr_info->prog == 3) {
      {
#line 258
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 258
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 259
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      y0___48 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 260
      x1___0 = x0___0 + cstr_info->tile_x;
#line 261
      y1___49 = y0___48 + cstr_info->tile_y;
#line 264
      max_numprec = 0;
#line 265
      resno = 0;
      }
      {
#line 265
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 265
        if (! (resno < max_numdecompos + 1)) {
#line 265
          goto while_break___18;
        }
#line 266
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 267
        if (numprec___0 > max_numprec) {
#line 268
          max_numprec = numprec___0;
        }
#line 265
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 271
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 272
      if (disto_on) {
        {
#line 273
        fprintf(stream, " disto");
        }
      }
      {
#line 274
      fprintf(stream, "\n");
#line 276
      precno = 0;
      }
      {
#line 276
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 276
        if (! (precno < max_numprec)) {
#line 276
          goto while_break___19;
        }
#line 277
        compno = 0;
        {
#line 277
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 277
          if (! (compno < cstr_info->numcomps)) {
#line 277
            goto while_break___20;
          }
#line 278
          resno = 0;
          {
#line 278
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 278
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 278
              goto while_break___21;
            }
            {
#line 279
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 280
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 281
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 281
            pcx___0 = (int )__cil_tmp73;
#line 282
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcy___0 = (int )__cil_tmp75;
#line 283
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 283
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 284
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_y___0 = (int )__cil_tmp79;
            }
#line 285
            if (precno >= numprec___1) {
#line 286
              goto while_continue___21;
            }
#line 287
            y = y0___48;
            {
#line 287
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 287
              if (! (y < y1___49)) {
#line 287
                goto while_break___22;
              }
#line 288
              if (precno_y___0 * pcy___0 == y) {
#line 289
                x = x0___0;
                {
#line 289
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 289
                  if (! (x < x1___0)) {
#line 289
                    goto while_break___23;
                  }
#line 290
                  if (precno_x___0 * pcx___0 == x) {
#line 291
                    layno = 0;
                    {
#line 291
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 291
                      if (! (layno < cstr_info->numlayers)) {
#line 291
                        goto while_break___24;
                      }
                      {
#line 292
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 293
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 294
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 295
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 296
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, precno, compno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 298
                      if (disto_on) {
                        {
#line 299
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 300
                      fprintf(stream, "\n");
#line 301
                      total_disto += disto;
#line 302
                      pack_nb ++;
                      }
#line 291
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 289
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 287
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 278
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 277
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 276
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 315
      max_numprec___0 = 0;
#line 316
      resno = 0;
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! (resno < max_numdecompos + 1)) {
#line 316
          goto while_break___25;
        }
#line 317
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 318
        if (numprec___2 > max_numprec___0) {
#line 319
          max_numprec___0 = numprec___2;
        }
#line 316
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 322
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 323
      if (disto_on) {
        {
#line 324
        fprintf(stream, " disto");
        }
      }
      {
#line 325
      fprintf(stream, "\n");
#line 327
      compno = 0;
      }
      {
#line 327
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 327
        if (! (compno < cstr_info->numcomps)) {
#line 327
          goto while_break___26;
        }
        {
#line 329
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 329
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 330
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        y0___50 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 331
        x1___1 = x0___1 + cstr_info->tile_x;
#line 332
        y1___51 = y0___50 + cstr_info->tile_y;
#line 334
        precno = 0;
        }
        {
#line 334
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 334
          if (! (precno < max_numprec___0)) {
#line 334
            goto while_break___27;
          }
#line 335
          resno = 0;
          {
#line 335
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 335
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 335
              goto while_break___28;
            }
            {
#line 336
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 337
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 338
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 338
            pcx___1 = (int )__cil_tmp99;
#line 339
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcy___1 = (int )__cil_tmp101;
#line 340
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 340
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 341
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_y___1 = (int )__cil_tmp105;
            }
#line 342
            if (precno >= numprec___3) {
#line 343
              goto while_continue___28;
            }
#line 345
            y = y0___50;
            {
#line 345
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 345
              if (! (y < y1___51)) {
#line 345
                goto while_break___29;
              }
#line 346
              if (precno_y___1 * pcy___1 == y) {
#line 347
                x = x0___1;
                {
#line 347
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 347
                  if (! (x < x1___1)) {
#line 347
                    goto while_break___30;
                  }
#line 348
                  if (precno_x___1 * pcx___1 == x) {
#line 349
                    layno = 0;
                    {
#line 349
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 349
                      if (! (layno < cstr_info->numlayers)) {
#line 349
                        goto while_break___31;
                      }
                      {
#line 350
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 351
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 352
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 353
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 354
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, compno, precno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 356
                      if (disto_on) {
                        {
#line 357
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 358
                      fprintf(stream, "\n");
#line 359
                      total_disto += disto;
#line 360
                      pack_nb ++;
                      }
#line 349
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 347
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 345
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 335
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 334
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 327
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 122
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  if (disto_on) {
    {
#line 373
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 374
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 378
  if (cstr_info->marknum) {
    {
#line 379
    fprintf(stream, "\nMARKER LIST\n");
#line 380
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 381
    fprintf(stream, "type\tstart_pos    length\n");
#line 382
    x = 0;
    }
    {
#line 382
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 382
      if (! (x < cstr_info->marknum)) {
#line 382
        goto while_break___32;
      }
      {
#line 383
      fprintf(stream, "%X\t%9d %9d\n", (int )(cstr_info->marker + x)->type, (cstr_info->marker + x)->pos,
              (cstr_info->marker + x)->len);
      }
#line 382
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 386
  fclose(stream);
#line 388
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 390
  return (0);
}
}
#line 44 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.c"
int opterr  =    1;
#line 45 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.c"
int optind  =    1;
#line 63 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 64
  opterr = 1;
#line 65
  optind = 1;
  return;
}
}
#line 72 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.c"
int getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char const   *place ;
  char *oli ;
  char const   *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 74
  place = "\220";
#line 77
  if (optreset) {
    _L: /* CIL Label */ 
#line 78
    optreset = 0;
#line 79
    place = (char const   *)*(nargv + optind);
#line 79
    if (optind >= nargc) {
#line 80
      place = "\220";
#line 81
      return (- 1);
    } else
#line 79
    if ((int )*place != 45) {
#line 80
      place = "\220";
#line 81
      return (- 1);
    }
#line 83
    place ++;
#line 83
    if ((int )*(place + 1)) {
#line 83
      if ((int )*place == 45) {
#line 84
        optind ++;
#line 85
        place = "\220";
#line 86
        return (- 1);
      }
    }
  } else
#line 77
  if (! *place) {
#line 77
    goto _L;
  }
  {
#line 89
  oli = strchr(ostr, optopt);
  }
#line 89
  __cil_tmp6 = place;
#line 89
  place ++;
#line 89
  optopt = (int )*__cil_tmp6;
#line 89
  if (! oli) {
    _L___52: /* CIL Label */ 
#line 95
    if (optopt == 45) {
#line 96
      return (- 1);
    }
#line 97
    if (! *place) {
#line 98
      optind ++;
    }
#line 99
    if (opterr) {
#line 99
      if ((int )*ostr != 58) {
        {
#line 100
        fprintf(stderr, "%s: illegal option -- %c\n\315-\241\032V", *(nargv + 0),
                optopt);
        }
#line 102
        return ((int )'?');
      }
    }
  } else
#line 89
  if (optopt == 58) {
#line 89
    goto _L___52;
  }
#line 105
  oli ++;
#line 105
  if ((int )*oli != 58) {
#line 106
    optarg = (char const   *)((void *)0);
#line 107
    if (! *place) {
#line 108
      optind ++;
    }
  } else {
#line 110
    if (*place) {
#line 111
      optarg = place;
    } else {
#line 112
      optind ++;
#line 112
      if (nargc <= optind) {
#line 113
        place = "\220";
#line 114
        if ((int )*ostr == 58) {
#line 115
          return ((int )':');
        }
#line 116
        if (opterr) {
          {
#line 117
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  optopt);
          }
#line 120
          return ((int )'?');
        }
      } else {
#line 123
        optarg = (char const   *)*(nargv + optind);
      }
    }
#line 124
    place = "\220";
#line 125
    optind ++;
  }
#line 127
  return (optopt);
}
}
#line 131 "/doner/openjpeg/openjpeg-65e5ff0/codec/compat/getopt.c"
int getopt_long(int argc , char * const  argv[] , char const   *optstring , struct option *longopts ,
                int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  struct option *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  struct option *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 136
  param = (char )1;
  again: 
#line 139
  if (! argv[optind]) {
#line 140
    return (- 1);
  } else
#line 139
  if (optind >= argc) {
#line 140
    return (- 1);
  } else
#line 139
  if ((int )*(argv[optind]) != 45) {
#line 140
    return (- 1);
  }
#line 142
  if ((int )*(argv[optind] + 0) == 45) {
#line 142
    if ((int )*(argv[optind] + 1) == 0) {
#line 143
      if (optind >= argc - 1) {
#line 144
        param = (char )0;
      } else
#line 147
      if ((int )*(argv[optind + 1] + 0) == 45) {
#line 148
        param = (char )0;
      } else {
#line 151
        param = (char )2;
      }
    }
  }
#line 156
  if ((int )param == 0) {
#line 157
    optind ++;
#line 158
    return ((int )'?');
  }
#line 161
  if ((int )*(argv[optind] + 0) == 45) {
#line 162
    arg = argv[optind] + 1;
#line 164
    o = longopts;
#line 165
    len = (int )sizeof(*(longopts + 0));
#line 167
    if ((int )param > 1) {
#line 168
      arg = argv[optind + 1];
#line 169
      optind ++;
    } else {
#line 172
      arg = argv[optind] + 1;
    }
    {
#line 174
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 174
    if (__cil_tmp15 > 1UL) {
#line 175
      i = 0;
      {
#line 175
      while (1) {
        while_continue: /* CIL Label */ ;
#line 175
        if (! (i < totlen)) {
#line 175
          goto while_break;
        }
        {
#line 176
        __cil_tmp16 = strcmp((char const   *)o->name, (char const   *)arg);
        }
#line 176
        if (! __cil_tmp16) {
#line 177
          if (o->has_arg == 0) {
#line 178
            if (argv[optind + 1]) {
#line 178
              if (! ((int )*(argv[optind + 1] + 0) == 45)) {
                {
#line 179
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[optind + 1]);
#line 180
                optind ++;
                }
              }
            }
          } else {
#line 183
            optarg = (char const   *)argv[optind + 1];
#line 184
            if (optarg) {
#line 185
              if ((int )*(optarg + 0) == 45) {
#line 186
                if (opterr) {
                  {
#line 187
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 188
                  return ((int )'?');
                }
              }
            }
#line 192
            if (! optarg) {
#line 192
              if (o->has_arg == 1) {
#line 193
                if (opterr) {
                  {
#line 194
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 195
                  return ((int )'?');
                }
              }
            }
#line 198
            optind ++;
          }
#line 200
          optind ++;
#line 201
          if (o->flag) {
#line 202
            *(o->flag) = o->val;
          } else {
#line 204
            return (o->val);
          }
#line 205
          return (0);
        }
#line 175
        __cil_tmp17 = o;
#line 175
        o ++;
#line 175
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 208
      fprintf(stderr, "Invalid option %s\n1\241\032V", arg);
#line 209
      optind ++;
      }
#line 210
      return ((int )'?');
    } else {
#line 212
      if ((int )*optstring == 58) {
#line 212
        return (':');
      }
#line 213
      if (lastidx != optind) {
#line 214
        lastidx = optind;
#line 214
        lastofs = 0;
      }
      {
#line 216
      optopt = (int )*(argv[optind] + (lastofs + 1));
#line 217
      tmp = strchr(optstring, optopt);
      }
#line 217
      if (tmp) {
#line 218
        if ((int )*tmp == 0) {
#line 219
          optind ++;
#line 220
          goto again;
        }
#line 222
        if ((int )*(tmp + 1) == 58) {
#line 223
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 224
            optarg = (char const   *)((argv[optind] + lastofs) + 2);
#line 224
            if (! *optarg) {
#line 224
              optarg = (char const   *)0;
            }
#line 225
            goto found;
          } else
#line 223
          if ((int )*(argv[optind] + (lastofs + 2))) {
#line 223
            goto _L;
          }
#line 227
          optarg = (char const   *)argv[optind + 1];
#line 228
          if (optarg) {
#line 229
            if ((int )*(optarg + 0) == 45) {
#line 230
              if (opterr) {
                {
#line 231
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 232
                return ((int )'?');
              }
            }
          }
#line 236
          if (! optarg) {
#line 237
            if (opterr) {
              {
#line 238
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 239
              return ((int )'?');
            }
          }
#line 242
          optind ++;
        } else {
#line 244
          lastofs ++;
#line 245
          return (optopt);
        }
        found: 
#line 248
        optind ++;
#line 249
        return (optopt);
      } else {
        {
#line 251
        fprintf(stderr, "Invalid option %s\n", arg);
#line 252
        optind ++;
        }
#line 253
        return ((int )'?');
      }
    }
  }
  {
#line 258
  fprintf(stderr, "Invalid option\n");
#line 259
  optind ++;
  }
#line 260
  return ((int )'?');

}
}
