# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
# 32 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 329 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = getc_unlocked (__stream);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 33 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





# 1 "/usr/include/x86_64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 124 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 647 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);
# 820 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 840 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));
# 1003 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1014 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1018 "/usr/include/stdlib.h" 2 3 4






# 34 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));
# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 237 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 238 "/usr/include/ctype.h" 2 3 4
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 35 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "./jinclude.h" 1
# 23 "./jinclude.h"
# 1 "./jconfig.h" 1
# 24 "./jinclude.h" 2
# 38 "./jinclude.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 39 "./jinclude.h" 2
# 69 "./jinclude.h"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 385 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 410 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 428 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 495 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
# 71 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}
# 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 496 "/usr/include/string.h" 2 3 4




# 70 "./jinclude.h" 2
# 36 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2

# 1 "./jpeglib.h" 1
# 31 "./jpeglib.h"
# 1 "./jmorecfg.h" 1
# 51 "./jmorecfg.h"

# 51 "./jmorecfg.h"
typedef unsigned char JSAMPLE;
# 91 "./jmorecfg.h"
typedef short JCOEF;
# 102 "./jmorecfg.h"
typedef unsigned char JOCTET;
# 127 "./jmorecfg.h"
typedef unsigned char UINT8;
# 139 "./jmorecfg.h"
typedef unsigned short UINT16;







typedef short INT16;
# 179 "./jmorecfg.h"
typedef long INT32;
# 194 "./jmorecfg.h"
typedef unsigned int JDIMENSION;
# 242 "./jmorecfg.h"
typedef int boolean;
# 368 "./jmorecfg.h"
static const int rgb_red[17] = {
  -1, -1, 0, -1, -1, -1, 0, 0,
  2, 2, 3, 1,
  0, 2, 3, 1,
  -1
};

static const int rgb_green[17] = {
  -1, -1, 1, -1, -1, -1, 1, 1,
  1, 1, 2, 2,
  1, 1, 2, 2,
  -1
};

static const int rgb_blue[17] = {
  -1, -1, 2, -1, -1, -1, 2, 2,
  0, 0, 1, 3,
  2, 0, 1, 3,
  -1
};

static const int rgb_pixelsize[17] = {
  -1, -1, 3, -1, -1, -1, 3, 4,
  3, 4, 4, 4,
  4, 4, 4, 4,
  -1
};
# 32 "./jpeglib.h" 2
# 69 "./jpeglib.h"
typedef JSAMPLE *JSAMPROW;
typedef JSAMPROW *JSAMPARRAY;
typedef JSAMPARRAY *JSAMPIMAGE;

typedef JCOEF JBLOCK[64];
typedef JBLOCK *JBLOCKROW;
typedef JBLOCKROW *JBLOCKARRAY;
typedef JBLOCKARRAY *JBLOCKIMAGE;

typedef JCOEF *JCOEFPTR;







typedef struct {




  UINT16 quantval[64];





  boolean sent_table;
} JQUANT_TBL;




typedef struct {

  UINT8 bits[17];

  UINT8 huffval[256];





  boolean sent_table;
} JHUFF_TBL;




typedef struct {



  int component_id;
  int component_index;
  int h_samp_factor;
  int v_samp_factor;
  int quant_tbl_no;




  int dc_tbl_no;
  int ac_tbl_no;
# 142 "./jpeglib.h"
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
# 154 "./jpeglib.h"
  int DCT_scaled_size;







  JDIMENSION downsampled_width;
  JDIMENSION downsampled_height;




  boolean component_needed;



  int MCU_width;
  int MCU_height;
  int MCU_blocks;
  int MCU_sample_width;
  int last_col_width;
  int last_row_height;





  JQUANT_TBL *quant_table;


  void *dct_table;
} jpeg_component_info;




typedef struct {
  int comps_in_scan;
  int component_index[4];
  int Ss, Se;
  int Ah, Al;
} jpeg_scan_info;



typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;

struct jpeg_marker_struct {
  jpeg_saved_marker_ptr next;
  UINT8 marker;
  unsigned int original_length;
  unsigned int data_length;
  JOCTET *data;

};






typedef enum {
  JCS_UNKNOWN,
  JCS_GRAYSCALE,
  JCS_RGB,

  JCS_YCbCr,
  JCS_CMYK,
  JCS_YCCK,
  JCS_EXT_RGB,
  JCS_EXT_RGBX,
  JCS_EXT_BGR,
  JCS_EXT_BGRX,
  JCS_EXT_XBGR,
  JCS_EXT_XRGB,






  JCS_EXT_RGBA,
  JCS_EXT_BGRA,
  JCS_EXT_ABGR,
  JCS_EXT_ARGB,
  JCS_RGB565
} J_COLOR_SPACE;



typedef enum {
  JDCT_ISLOW,
  JDCT_IFAST,
  JDCT_FLOAT
} J_DCT_METHOD;
# 261 "./jpeglib.h"
typedef enum {
  JDITHER_NONE,
  JDITHER_ORDERED,
  JDITHER_FS
} J_DITHER_MODE;
# 282 "./jpeglib.h"
struct jpeg_common_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;




};

typedef struct jpeg_common_struct *j_common_ptr;
typedef struct jpeg_compress_struct *j_compress_ptr;
typedef struct jpeg_decompress_struct *j_decompress_ptr;




struct jpeg_compress_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;


  struct jpeg_destination_mgr *dest;






  JDIMENSION image_width;
  JDIMENSION image_height;
  int input_components;
  J_COLOR_SPACE in_color_space;

  double input_gamma;
# 336 "./jpeglib.h"
  int data_precision;

  int num_components;
  J_COLOR_SPACE jpeg_color_space;

  jpeg_component_info *comp_info;


  JQUANT_TBL *quant_tbl_ptrs[4];







  JHUFF_TBL *dc_huff_tbl_ptrs[4];
  JHUFF_TBL *ac_huff_tbl_ptrs[4];


  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  int num_scans;
  const jpeg_scan_info *scan_info;





  boolean raw_data_in;
  boolean arith_code;
  boolean optimize_coding;
  boolean CCIR601_sampling;



  int smoothing_factor;
  J_DCT_METHOD dct_method;






  unsigned int restart_interval;
  int restart_in_rows;



  boolean write_JFIF_header;
  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;




  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean write_Adobe_marker;






  JDIMENSION next_scanline;
# 413 "./jpeglib.h"
  boolean progressive_mode;
  int max_h_samp_factor;
  int max_v_samp_factor;






  JDIMENSION total_iMCU_rows;
# 433 "./jpeglib.h"
  int comps_in_scan;
  jpeg_component_info *cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;
# 456 "./jpeglib.h"
  struct jpeg_comp_master *master;
  struct jpeg_c_main_controller *main;
  struct jpeg_c_prep_controller *prep;
  struct jpeg_c_coef_controller *coef;
  struct jpeg_marker_writer *marker;
  struct jpeg_color_converter *cconvert;
  struct jpeg_downsampler *downsample;
  struct jpeg_forward_dct *fdct;
  struct jpeg_entropy_encoder *entropy;
  jpeg_scan_info *script_space;
  int script_space_size;
};




struct jpeg_decompress_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;


  struct jpeg_source_mgr *src;




  JDIMENSION image_width;
  JDIMENSION image_height;
  int num_components;
  J_COLOR_SPACE jpeg_color_space;






  J_COLOR_SPACE out_color_space;

  unsigned int scale_num, scale_denom;

  double output_gamma;

  boolean buffered_image;
  boolean raw_data_out;

  J_DCT_METHOD dct_method;
  boolean do_fancy_upsampling;
  boolean do_block_smoothing;

  boolean quantize_colors;

  J_DITHER_MODE dither_mode;
  boolean two_pass_quantize;
  int desired_number_of_colors;

  boolean enable_1pass_quant;
  boolean enable_external_quant;
  boolean enable_2pass_quant;







  JDIMENSION output_width;
  JDIMENSION output_height;
  int out_color_components;
  int output_components;



  int rec_outbuf_height;
# 539 "./jpeglib.h"
  int actual_number_of_colors;
  JSAMPARRAY colormap;
# 550 "./jpeglib.h"
  JDIMENSION output_scanline;




  int input_scan_number;
  JDIMENSION input_iMCU_row;





  int output_scan_number;
  JDIMENSION output_iMCU_row;
# 572 "./jpeglib.h"
  int (*coef_bits)[64];
# 583 "./jpeglib.h"
  JQUANT_TBL *quant_tbl_ptrs[4];


  JHUFF_TBL *dc_huff_tbl_ptrs[4];
  JHUFF_TBL *ac_huff_tbl_ptrs[4];






  int data_precision;

  jpeg_component_info *comp_info;





  boolean progressive_mode;
  boolean arith_code;

  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  unsigned int restart_interval;




  boolean saw_JFIF_marker;

  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;
  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean saw_Adobe_marker;
  UINT8 Adobe_transform;

  boolean CCIR601_sampling;





  jpeg_saved_marker_ptr marker_list;
# 639 "./jpeglib.h"
  int max_h_samp_factor;
  int max_v_samp_factor;





  int min_DCT_scaled_size;


  JDIMENSION total_iMCU_rows;
# 658 "./jpeglib.h"
  JSAMPLE *sample_range_limit;






  int comps_in_scan;
  jpeg_component_info *cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;
# 691 "./jpeglib.h"
  int unread_marker;




  struct jpeg_decomp_master *master;
  struct jpeg_d_main_controller *main;
  struct jpeg_d_coef_controller *coef;
  struct jpeg_d_post_controller *post;
  struct jpeg_input_controller *inputctl;
  struct jpeg_marker_reader *marker;
  struct jpeg_entropy_decoder *entropy;
  struct jpeg_inverse_dct *idct;
  struct jpeg_upsampler *upsample;
  struct jpeg_color_deconverter *cconvert;
  struct jpeg_color_quantizer *cquantize;
};
# 720 "./jpeglib.h"
struct jpeg_error_mgr {

  void (*error_exit) (j_common_ptr cinfo);

  void (*emit_message) (j_common_ptr cinfo, int msg_level);

  void (*output_message) (j_common_ptr cinfo);

  void (*format_message) (j_common_ptr cinfo, char *buffer);


  void (*reset_error_mgr) (j_common_ptr cinfo);




  int msg_code;

  union {
    int i[8];
    char s[80];
  } msg_parm;



  int trace_level;







  long num_warnings;
# 765 "./jpeglib.h"
  const char * const *jpeg_message_table;
  int last_jpeg_message;



  const char * const *addon_message_table;
  int first_addon_message;
  int last_addon_message;
};




struct jpeg_progress_mgr {
  void (*progress_monitor) (j_common_ptr cinfo);

  long pass_counter;
  long pass_limit;
  int completed_passes;
  int total_passes;
};




struct jpeg_destination_mgr {
  JOCTET *next_output_byte;
  size_t free_in_buffer;

  void (*init_destination) (j_compress_ptr cinfo);
  boolean (*empty_output_buffer) (j_compress_ptr cinfo);
  void (*term_destination) (j_compress_ptr cinfo);
};




struct jpeg_source_mgr {
  const JOCTET *next_input_byte;
  size_t bytes_in_buffer;

  void (*init_source) (j_decompress_ptr cinfo);
  boolean (*fill_input_buffer) (j_decompress_ptr cinfo);
  void (*skip_input_data) (j_decompress_ptr cinfo, long num_bytes);
  boolean (*resync_to_restart) (j_decompress_ptr cinfo, int desired);
  void (*term_source) (j_decompress_ptr cinfo);
};
# 829 "./jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
typedef struct jvirt_barray_control *jvirt_barray_ptr;


struct jpeg_memory_mgr {

  void *(*alloc_small) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);
  void *(*alloc_large) (j_common_ptr cinfo, int pool_id,
                        size_t sizeofobject);
  JSAMPARRAY (*alloc_sarray) (j_common_ptr cinfo, int pool_id,
                              JDIMENSION samplesperrow, JDIMENSION numrows);
  JBLOCKARRAY (*alloc_barray) (j_common_ptr cinfo, int pool_id,
                               JDIMENSION blocksperrow, JDIMENSION numrows);
  jvirt_sarray_ptr (*request_virt_sarray) (j_common_ptr cinfo, int pool_id,
                                           boolean pre_zero,
                                           JDIMENSION samplesperrow,
                                           JDIMENSION numrows,
                                           JDIMENSION maxaccess);
  jvirt_barray_ptr (*request_virt_barray) (j_common_ptr cinfo, int pool_id,
                                           boolean pre_zero,
                                           JDIMENSION blocksperrow,
                                           JDIMENSION numrows,
                                           JDIMENSION maxaccess);
  void (*realize_virt_arrays) (j_common_ptr cinfo);
  JSAMPARRAY (*access_virt_sarray) (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
                                    JDIMENSION start_row, JDIMENSION num_rows,
                                    boolean writable);
  JBLOCKARRAY (*access_virt_barray) (j_common_ptr cinfo, jvirt_barray_ptr ptr,
                                     JDIMENSION start_row, JDIMENSION num_rows,
                                     boolean writable);
  void (*free_pool) (j_common_ptr cinfo, int pool_id);
  void (*self_destruct) (j_common_ptr cinfo);






  long max_memory_to_use;


  long max_alloc_chunk;
};





typedef boolean (*jpeg_marker_parser_method) (j_decompress_ptr cinfo);
# 891 "./jpeglib.h"
extern struct jpeg_error_mgr * jpeg_std_error (struct jpeg_error_mgr *err);
# 906 "./jpeglib.h"
extern void jpeg_CreateCompress (j_compress_ptr cinfo, int version,
                                  size_t structsize);
extern void jpeg_CreateDecompress (j_decompress_ptr cinfo, int version,
                                    size_t structsize);

extern void jpeg_destroy_compress (j_compress_ptr cinfo);
extern void jpeg_destroy_decompress (j_decompress_ptr cinfo);



extern void jpeg_stdio_dest (j_compress_ptr cinfo, FILE *outfile);
extern void jpeg_stdio_src (j_decompress_ptr cinfo, FILE *infile);



extern void jpeg_mem_dest (j_compress_ptr cinfo, unsigned char **outbuffer,
                            unsigned long *outsize);
extern void jpeg_mem_src (j_decompress_ptr cinfo,
                           const unsigned char *inbuffer,
                           unsigned long insize);



extern void jpeg_set_defaults (j_compress_ptr cinfo);

extern void jpeg_set_colorspace (j_compress_ptr cinfo,
                                  J_COLOR_SPACE colorspace);
extern void jpeg_default_colorspace (j_compress_ptr cinfo);
extern void jpeg_set_quality (j_compress_ptr cinfo, int quality,
                               boolean force_baseline);
extern void jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
                                      boolean force_baseline);




extern void jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
                                   const unsigned int *basic_table,
                                   int scale_factor, boolean force_baseline);
extern int jpeg_quality_scaling (int quality);
extern void jpeg_simple_progression (j_compress_ptr cinfo);
extern void jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress);
extern JQUANT_TBL * jpeg_alloc_quant_table (j_common_ptr cinfo);
extern JHUFF_TBL * jpeg_alloc_huff_table (j_common_ptr cinfo);


extern void jpeg_start_compress (j_compress_ptr cinfo,
                                  boolean write_all_tables);
extern JDIMENSION jpeg_write_scanlines (j_compress_ptr cinfo,
                                         JSAMPARRAY scanlines,
                                         JDIMENSION num_lines);
extern void jpeg_finish_compress (j_compress_ptr cinfo);







extern JDIMENSION jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
                                        JDIMENSION num_lines);


extern void jpeg_write_marker (j_compress_ptr cinfo, int marker,
                                const JOCTET *dataptr, unsigned int datalen);

extern void jpeg_write_m_header (j_compress_ptr cinfo, int marker,
                                  unsigned int datalen);
extern void jpeg_write_m_byte (j_compress_ptr cinfo, int val);


extern void jpeg_write_tables (j_compress_ptr cinfo);


extern int jpeg_read_header (j_decompress_ptr cinfo, boolean require_image);
# 992 "./jpeglib.h"
extern boolean jpeg_start_decompress (j_decompress_ptr cinfo);
extern JDIMENSION jpeg_read_scanlines (j_decompress_ptr cinfo,
                                        JSAMPARRAY scanlines,
                                        JDIMENSION max_lines);
extern JDIMENSION jpeg_skip_scanlines (j_decompress_ptr cinfo,
                                        JDIMENSION num_lines);
extern void jpeg_crop_scanline (j_decompress_ptr cinfo, JDIMENSION *xoffset,
                                 JDIMENSION *width);
extern boolean jpeg_finish_decompress (j_decompress_ptr cinfo);


extern JDIMENSION jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
                                       JDIMENSION max_lines);


extern boolean jpeg_has_multiple_scans (j_decompress_ptr cinfo);
extern boolean jpeg_start_output (j_decompress_ptr cinfo, int scan_number);
extern boolean jpeg_finish_output (j_decompress_ptr cinfo);
extern boolean jpeg_input_complete (j_decompress_ptr cinfo);
extern void jpeg_new_colormap (j_decompress_ptr cinfo);
extern int jpeg_consume_input (j_decompress_ptr cinfo);
# 1024 "./jpeglib.h"
extern void jpeg_calc_output_dimensions (j_decompress_ptr cinfo);


extern void jpeg_save_markers (j_decompress_ptr cinfo, int marker_code,
                                unsigned int length_limit);


extern void jpeg_set_marker_processor (j_decompress_ptr cinfo,
                                        int marker_code,
                                        jpeg_marker_parser_method routine);


extern jvirt_barray_ptr * jpeg_read_coefficients (j_decompress_ptr cinfo);
extern void jpeg_write_coefficients (j_compress_ptr cinfo,
                                      jvirt_barray_ptr *coef_arrays);
extern void jpeg_copy_critical_parameters (j_decompress_ptr srcinfo,
                                            j_compress_ptr dstinfo);







extern void jpeg_abort_compress (j_compress_ptr cinfo);
extern void jpeg_abort_decompress (j_decompress_ptr cinfo);




extern void jpeg_abort (j_common_ptr cinfo);
extern void jpeg_destroy (j_common_ptr cinfo);


extern boolean jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired);
# 1112 "./jpeglib.h"
# 1 "./jpegint.h" 1
# 21 "./jpegint.h"
typedef enum {
  JBUF_PASS_THRU,

  JBUF_SAVE_SOURCE,
  JBUF_CRANK_DEST,
  JBUF_SAVE_AND_PASS
} J_BUF_MODE;
# 48 "./jpegint.h"
typedef long JLONG;
# 62 "./jpegint.h"
struct jpeg_comp_master {
  void (*prepare_for_pass) (j_compress_ptr cinfo);
  void (*pass_startup) (j_compress_ptr cinfo);
  void (*finish_pass) (j_compress_ptr cinfo);


  boolean call_pass_startup;
  boolean is_last_pass;
};


struct jpeg_c_main_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                        JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail);
};


struct jpeg_c_prep_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*pre_process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                            JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail,
                            JSAMPIMAGE output_buf,
                            JDIMENSION *out_row_group_ctr,
                            JDIMENSION out_row_groups_avail);
};


struct jpeg_c_coef_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  boolean (*compress_data) (j_compress_ptr cinfo, JSAMPIMAGE input_buf);
};


struct jpeg_color_converter {
  void (*start_pass) (j_compress_ptr cinfo);
  void (*color_convert) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                         JSAMPIMAGE output_buf, JDIMENSION output_row,
                         int num_rows);
};


struct jpeg_downsampler {
  void (*start_pass) (j_compress_ptr cinfo);
  void (*downsample) (j_compress_ptr cinfo, JSAMPIMAGE input_buf,
                      JDIMENSION in_row_index, JSAMPIMAGE output_buf,
                      JDIMENSION out_row_group_index);

  boolean need_context_rows;
};


struct jpeg_forward_dct {
  void (*start_pass) (j_compress_ptr cinfo);

  void (*forward_DCT) (j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
                       JDIMENSION start_row, JDIMENSION start_col,
                       JDIMENSION num_blocks);
};


struct jpeg_entropy_encoder {
  void (*start_pass) (j_compress_ptr cinfo, boolean gather_statistics);
  boolean (*encode_mcu) (j_compress_ptr cinfo, JBLOCKROW *MCU_data);
  void (*finish_pass) (j_compress_ptr cinfo);
};


struct jpeg_marker_writer {
  void (*write_file_header) (j_compress_ptr cinfo);
  void (*write_frame_header) (j_compress_ptr cinfo);
  void (*write_scan_header) (j_compress_ptr cinfo);
  void (*write_file_trailer) (j_compress_ptr cinfo);
  void (*write_tables_only) (j_compress_ptr cinfo);


  void (*write_marker_header) (j_compress_ptr cinfo, int marker,
                               unsigned int datalen);
  void (*write_marker_byte) (j_compress_ptr cinfo, int val);
};





struct jpeg_decomp_master {
  void (*prepare_for_output_pass) (j_decompress_ptr cinfo);
  void (*finish_output_pass) (j_decompress_ptr cinfo);


  boolean is_dummy_pass;


  JDIMENSION first_iMCU_col;
  JDIMENSION last_iMCU_col;
  JDIMENSION first_MCU_col[10];
  JDIMENSION last_MCU_col[10];
  boolean jinit_upsampler_no_alloc;
};


struct jpeg_input_controller {
  int (*consume_input) (j_decompress_ptr cinfo);
  void (*reset_input_controller) (j_decompress_ptr cinfo);
  void (*start_input_pass) (j_decompress_ptr cinfo);
  void (*finish_input_pass) (j_decompress_ptr cinfo);


  boolean has_multiple_scans;
  boolean eoi_reached;
};


struct jpeg_d_main_controller {
  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*process_data) (j_decompress_ptr cinfo, JSAMPARRAY output_buf,
                        JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);
};


struct jpeg_d_coef_controller {
  void (*start_input_pass) (j_decompress_ptr cinfo);
  int (*consume_data) (j_decompress_ptr cinfo);
  void (*start_output_pass) (j_decompress_ptr cinfo);
  int (*decompress_data) (j_decompress_ptr cinfo, JSAMPIMAGE output_buf);

  jvirt_barray_ptr *coef_arrays;
};


struct jpeg_d_post_controller {
  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                             JDIMENSION *in_row_group_ctr,
                             JDIMENSION in_row_groups_avail,
                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                             JDIMENSION out_rows_avail);
};


struct jpeg_marker_reader {
  void (*reset_marker_reader) (j_decompress_ptr cinfo);




  int (*read_markers) (j_decompress_ptr cinfo);

  jpeg_marker_parser_method read_restart_marker;




  boolean saw_SOI;
  boolean saw_SOF;
  int next_restart_num;
  unsigned int discarded_bytes;
};


struct jpeg_entropy_decoder {
  void (*start_pass) (j_decompress_ptr cinfo);
  boolean (*decode_mcu) (j_decompress_ptr cinfo, JBLOCKROW *MCU_data);



  boolean insufficient_data;
};


typedef void (*inverse_DCT_method_ptr) (j_decompress_ptr cinfo,
                                        jpeg_component_info *compptr,
                                        JCOEFPTR coef_block,
                                        JSAMPARRAY output_buf,
                                        JDIMENSION output_col);

struct jpeg_inverse_dct {
  void (*start_pass) (j_decompress_ptr cinfo);

  inverse_DCT_method_ptr inverse_DCT[10];
};


struct jpeg_upsampler {
  void (*start_pass) (j_decompress_ptr cinfo);
  void (*upsample) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                    JDIMENSION *in_row_group_ctr,
                    JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);

  boolean need_context_rows;
};


struct jpeg_color_deconverter {
  void (*start_pass) (j_decompress_ptr cinfo);
  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                         JDIMENSION input_row, JSAMPARRAY output_buf,
                         int num_rows);
};


struct jpeg_color_quantizer {
  void (*start_pass) (j_decompress_ptr cinfo, boolean is_pre_scan);
  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                          JSAMPARRAY output_buf, int num_rows);
  void (*finish_pass) (j_decompress_ptr cinfo);
  void (*new_color_map) (j_decompress_ptr cinfo);
};
# 305 "./jpegint.h"
extern void jinit_compress_master (j_compress_ptr cinfo);
extern void jinit_c_master_control (j_compress_ptr cinfo,
                                     boolean transcode_only);
extern void jinit_c_main_controller (j_compress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_c_prep_controller (j_compress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_c_coef_controller (j_compress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_color_converter (j_compress_ptr cinfo);
extern void jinit_downsampler (j_compress_ptr cinfo);
extern void jinit_forward_dct (j_compress_ptr cinfo);
extern void jinit_huff_encoder (j_compress_ptr cinfo);
extern void jinit_phuff_encoder (j_compress_ptr cinfo);
extern void jinit_arith_encoder (j_compress_ptr cinfo);
extern void jinit_marker_writer (j_compress_ptr cinfo);

extern void jinit_master_decompress (j_decompress_ptr cinfo);
extern void jinit_d_main_controller (j_decompress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_d_coef_controller (j_decompress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_d_post_controller (j_decompress_ptr cinfo,
                                      boolean need_full_buffer);
extern void jinit_input_controller (j_decompress_ptr cinfo);
extern void jinit_marker_reader (j_decompress_ptr cinfo);
extern void jinit_huff_decoder (j_decompress_ptr cinfo);
extern void jinit_phuff_decoder (j_decompress_ptr cinfo);
extern void jinit_arith_decoder (j_decompress_ptr cinfo);
extern void jinit_inverse_dct (j_decompress_ptr cinfo);
extern void jinit_upsampler (j_decompress_ptr cinfo);
extern void jinit_color_deconverter (j_decompress_ptr cinfo);
extern void jinit_1pass_quantizer (j_decompress_ptr cinfo);
extern void jinit_2pass_quantizer (j_decompress_ptr cinfo);
extern void jinit_merged_upsampler (j_decompress_ptr cinfo);

extern void jinit_memory_mgr (j_common_ptr cinfo);


extern long jdiv_round_up (long a, long b);
extern long jround_up (long a, long b);
extern void jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
                                JSAMPARRAY output_array, int dest_row,
                                int num_rows, JDIMENSION num_cols);
extern void jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
                              JDIMENSION num_blocks);
extern void jzero_far (void *target, size_t bytestozero);




extern const int jpeg_natural_order[];


extern const JLONG jpeg_aritab[];
# 1113 "./jpeglib.h" 2
# 1 "./jerror.h" 1
# 37 "./jerror.h"
typedef enum {





JMSG_NOMESSAGE ,



JERR_ARITH_NOTIMPL ,


JERR_BAD_ALIGN_TYPE ,
JERR_BAD_ALLOC_CHUNK ,
JERR_BAD_BUFFER_MODE ,
JERR_BAD_COMPONENT_ID ,



JERR_BAD_DCT_COEF ,
JERR_BAD_DCTSIZE ,




JERR_BAD_HUFF_TABLE ,
JERR_BAD_IN_COLORSPACE ,
JERR_BAD_J_COLORSPACE ,
JERR_BAD_LENGTH ,
JERR_BAD_LIB_VERSION ,

JERR_BAD_MCU_SIZE ,
JERR_BAD_POOL_ID ,
JERR_BAD_PRECISION ,
JERR_BAD_PROGRESSION ,

JERR_BAD_PROG_SCRIPT ,

JERR_BAD_SAMPLING ,
JERR_BAD_SCAN_SCRIPT ,
JERR_BAD_STATE ,
JERR_BAD_STRUCT_SIZE ,

JERR_BAD_VIRTUAL_ACCESS ,
JERR_BUFFER_SIZE ,
JERR_CANT_SUSPEND ,
JERR_CCIR601_NOTIMPL ,
JERR_COMPONENT_COUNT ,
JERR_CONVERSION_NOTIMPL ,
JERR_DAC_INDEX ,
JERR_DAC_VALUE ,
JERR_DHT_INDEX ,
JERR_DQT_INDEX ,
JERR_EMPTY_IMAGE ,
JERR_EMS_READ ,
JERR_EMS_WRITE ,
JERR_EOI_EXPECTED ,
JERR_FILE_READ ,
JERR_FILE_WRITE ,
JERR_FRACT_SAMPLE_NOTIMPL ,
JERR_HUFF_CLEN_OVERFLOW ,
JERR_HUFF_MISSING_CODE ,
JERR_IMAGE_TOO_BIG ,
JERR_INPUT_EMPTY ,
JERR_INPUT_EOF ,
JERR_MISMATCHED_QUANT_TABLE ,

JERR_MISSING_DATA ,
JERR_MODE_CHANGE ,
JERR_NOTIMPL ,
JERR_NOT_COMPILED ,



JERR_NO_BACKING_STORE ,
JERR_NO_HUFF_TABLE ,
JERR_NO_IMAGE ,
JERR_NO_QUANT_TABLE ,
JERR_NO_SOI ,
JERR_OUT_OF_MEMORY ,
JERR_QUANT_COMPONENTS ,

JERR_QUANT_FEW_COLORS ,
JERR_QUANT_MANY_COLORS ,
JERR_SOF_DUPLICATE ,
JERR_SOF_NO_SOS ,
JERR_SOF_UNSUPPORTED ,
JERR_SOI_DUPLICATE ,
JERR_SOS_NO_SOF ,
JERR_TFILE_CREATE ,
JERR_TFILE_READ ,
JERR_TFILE_SEEK ,
JERR_TFILE_WRITE ,

JERR_TOO_LITTLE_DATA ,
JERR_UNKNOWN_MARKER ,
JERR_VIRTUAL_BUG ,
JERR_WIDTH_OVERFLOW ,
JERR_XMS_READ ,
JERR_XMS_WRITE ,
JMSG_COPYRIGHT ,
JMSG_VERSION ,
JTRC_16BIT_TABLES ,

JTRC_ADOBE ,

JTRC_APP0 ,
JTRC_APP14 ,
JTRC_DAC ,
JTRC_DHT ,
JTRC_DQT ,
JTRC_DRI ,
JTRC_EMS_CLOSE ,
JTRC_EMS_OPEN ,
JTRC_EOI ,
JTRC_HUFFBITS ,
JTRC_JFIF ,
JTRC_JFIF_BADTHUMBNAILSIZE ,

JTRC_JFIF_EXTENSION ,

JTRC_JFIF_THUMBNAIL ,
JTRC_MISC_MARKER ,
JTRC_PARMLESS_MARKER ,
JTRC_QUANTVALS ,
JTRC_QUANT_3_NCOLORS ,
JTRC_QUANT_NCOLORS ,
JTRC_QUANT_SELECTED ,
JTRC_RECOVERY_ACTION ,
JTRC_RST ,
JTRC_SMOOTH_NOTIMPL ,

JTRC_SOF ,
JTRC_SOF_COMPONENT ,
JTRC_SOI ,
JTRC_SOS ,
JTRC_SOS_COMPONENT ,
JTRC_SOS_PARAMS ,
JTRC_TFILE_CLOSE ,
JTRC_TFILE_OPEN ,
JTRC_THUMB_JPEG ,

JTRC_THUMB_PALETTE ,

JTRC_THUMB_RGB ,

JTRC_UNKNOWN_IDS ,

JTRC_XMS_CLOSE ,
JTRC_XMS_OPEN ,
JWRN_ADOBE_XFORM ,



JWRN_BOGUS_PROGRESSION ,

JWRN_EXTRANEOUS_DATA ,

JWRN_HIT_MARKER ,
JWRN_HUFF_BAD_CODE ,
JWRN_JFIF_MAJOR ,
JWRN_JPEG_EOF ,
JWRN_MUST_RESYNC ,

JWRN_NOT_SEQUENTIAL ,
JWRN_TOO_MUCH_DATA ,

JERR_BAD_CROP_SPEC ,

JERR_NO_ARITH_TABLE ,
JWRN_ARITH_BAD_CODE ,





  JMSG_LASTMSGCODE
} J_MESSAGE_CODE;
# 1114 "./jpeglib.h" 2
# 38 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "./jerror.h" 1
# 43 "./jerror.h"






































































































































































# 39 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/setjmp.h" 1 3 4
# 27 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4





# 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };


typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));




extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 67 "/usr/include/setjmp.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));





extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 93 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp2.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/setjmp2.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__))

                        __attribute__ ((__noreturn__));
extern void _longjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__))

                        __attribute__ ((__noreturn__));
extern void siglongjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__))

                        __attribute__ ((__noreturn__));
# 101 "/usr/include/setjmp.h" 2 3 4



# 40 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h" 1
# 92 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"

# 92 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
enum TJSAMP
{





  TJSAMP_444=0,




  TJSAMP_422,




  TJSAMP_420,



  TJSAMP_GRAY,






  TJSAMP_440,
# 132 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
  TJSAMP_411
};
# 144 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
static const int tjMCUWidth[6] = {8, 16, 16, 8, 8, 32};
# 155 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
static const int tjMCUHeight[6] = {8, 8, 16, 8, 16, 8};
# 166 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
enum TJPF
{





  TJPF_RGB=0,





  TJPF_BGR,






  TJPF_RGBX,






  TJPF_BGRX,






  TJPF_XBGR,






  TJPF_XRGB,




  TJPF_GRAY,





  TJPF_RGBA,





  TJPF_BGRA,





  TJPF_ABGR,





  TJPF_ARGB,
# 252 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
  TJPF_CMYK
};
# 262 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
static const int tjRedOffset[12] = {0, 2, 0, 2, 3, 1, 0, 0, 2, 3, 1, -1};







static const int tjGreenOffset[12] = {1, 1, 1, 1, 2, 2, 0, 1, 1, 2, 2, -1};






static const int tjBlueOffset[12] = {2, 0, 2, 0, 1, 3, 0, 2, 0, 1, 3, -1};




static const int tjPixelSize[12] = {3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4};
# 293 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
enum TJCS
{







  TJCS_RGB=0,
# 318 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
  TJCS_YCbCr,







  TJCS_GRAY,






  TJCS_CMYK,
# 343 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
  TJCS_YCCK
};
# 396 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
enum TJXOP
{



  TJXOP_NONE=0,




  TJXOP_HFLIP,




  TJXOP_VFLIP,




  TJXOP_TRANSPOSE,





  TJXOP_TRANSVERSE,





  TJXOP_ROT90,




  TJXOP_ROT180,





  TJXOP_ROT270
};
# 483 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
typedef struct
{



  int num;



  int denom;
} tjscalingfactor;




typedef struct
{




  int x;




  int y;




  int w;




  int h;
} tjregion;




typedef struct tjtransform
{



  tjregion r;



  int op;



  int options;




  void *data;
# 577 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
  int (*customFilter)(short *coeffs, tjregion arrayRegion,
    tjregion planeRegion, int componentIndex, int transformIndex,
    struct tjtransform *transform);
} tjtransform;




typedef void* tjhandle;
# 613 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 tjhandle tjInitCompress(void);
# 675 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
  int width, int pitch, int height, int pixelFormat, unsigned char **jpegBuf,
  unsigned long *jpegSize, int jpegSubsamp, int jpegQual, int flags);
# 739 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjCompressFromYUV(tjhandle handle,
  const unsigned char *srcBuf, int width, int pad, int height, int subsamp,
  unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual, int flags);
# 809 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjCompressFromYUVPlanes(tjhandle handle,
  const unsigned char **srcPlanes, int width, const int *strides, int height,
  int subsamp, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual,
  int flags);
# 837 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 unsigned long tjBufSize(int width, int height,
  int jpegSubsamp);
# 858 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 unsigned long tjBufSizeYUV2(int width, int pad, int height,
  int subsamp);
# 883 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 unsigned long tjPlaneSizeYUV(int componentID, int width,
  int stride, int height, int subsamp);
# 901 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjPlaneWidth(int componentID, int width, int subsamp);
# 918 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjPlaneHeight(int componentID, int height, int subsamp);
# 969 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjEncodeYUV3(tjhandle handle,
  const unsigned char *srcBuf, int width, int pitch, int height,
  int pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags);
# 1027 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjEncodeYUVPlanes(tjhandle handle,
  const unsigned char *srcBuf, int width, int pitch, int height,
  int pixelFormat, unsigned char **dstPlanes, int *strides, int subsamp,
  int flags);
# 1039 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 tjhandle tjInitDecompress(void);
# 1067 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecompressHeader3(tjhandle handle,
  const unsigned char *jpegBuf, unsigned long jpegSize, int *width,
  int *height, int *jpegSubsamp, int *jpegColorspace);
# 1082 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 tjscalingfactor* tjGetScalingFactors(int *numscalingfactors);
# 1134 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecompress2(tjhandle handle,
  const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
  int width, int pitch, int height, int pixelFormat, int flags);
# 1184 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecompressToYUV2(tjhandle handle,
  const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
  int width, int pad, int height, int flags);
# 1240 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecompressToYUVPlanes(tjhandle handle,
  const unsigned char *jpegBuf, unsigned long jpegSize,
  unsigned char **dstPlanes, int width, int *strides, int height, int flags);
# 1292 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
  int pad, int subsamp, unsigned char *dstBuf, int width, int pitch,
  int height, int pixelFormat, int flags);
# 1349 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDecodeYUVPlanes(tjhandle handle,
  const unsigned char **srcPlanes, const int *strides, int subsamp,
  unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat,
  int flags);
# 1361 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 tjhandle tjInitTransform(void);
# 1423 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjTransform(tjhandle handle,
  const unsigned char *jpegBuf, unsigned long jpegSize, int n,
  unsigned char **dstBufs, unsigned long *dstSizes, tjtransform *transforms,
  int flags);
# 1437 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 int tjDestroy(tjhandle handle);
# 1453 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 unsigned char* tjAlloc(int bytes);
# 1466 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 void tjFree(unsigned char *buffer);







 char* tjGetErrorStr(void);
# 1502 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./turbojpeg.h"
 unsigned long TJBUFSIZE(int width, int height);

 unsigned long TJBUFSIZEYUV(int width, int height,
  int jpegSubsamp);

 unsigned long tjBufSizeYUV(int width, int height,
  int subsamp);

 int tjCompress(tjhandle handle, unsigned char *srcBuf,
  int width, int pitch, int height, int pixelSize, unsigned char *dstBuf,
  unsigned long *compressedSize, int jpegSubsamp, int jpegQual, int flags);

 int tjEncodeYUV(tjhandle handle,
  unsigned char *srcBuf, int width, int pitch, int height, int pixelSize,
  unsigned char *dstBuf, int subsamp, int flags);

 int tjEncodeYUV2(tjhandle handle,
  unsigned char *srcBuf, int width, int pitch, int height, int pixelFormat,
  unsigned char *dstBuf, int subsamp, int flags);

 int tjDecompressHeader(tjhandle handle,
  unsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height);

 int tjDecompressHeader2(tjhandle handle,
  unsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height,
  int *jpegSubsamp);

 int tjDecompress(tjhandle handle,
  unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
  int width, int pitch, int height, int pixelSize, int flags);

 int tjDecompressToYUV(tjhandle handle,
  unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
  int flags);
# 41 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./tjutil.h" 1
# 47 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./tjutil.h"
extern double gettime(void);
# 42 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/transupp.h" 1
# 87 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/transupp.h"
typedef enum {
  JXFORM_NONE,
  JXFORM_FLIP_H,
  JXFORM_FLIP_V,
  JXFORM_TRANSPOSE,
  JXFORM_TRANSVERSE,
  JXFORM_ROT_90,
  JXFORM_ROT_180,
  JXFORM_ROT_270
} JXFORM_CODE;







typedef enum {
  JCROP_UNSET,
  JCROP_POS,
  JCROP_NEG,
  JCROP_FORCE
} JCROP_CODE;







typedef struct {

  JXFORM_CODE transform;
  boolean perfect;
  boolean trim;
  boolean force_grayscale;
  boolean crop;
  boolean slow_hflip;
# 135 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/transupp.h"
  JDIMENSION crop_width;
  JCROP_CODE crop_width_set;
  JDIMENSION crop_height;
  JCROP_CODE crop_height_set;
  JDIMENSION crop_xoffset;
  JCROP_CODE crop_xoffset_set;
  JDIMENSION crop_yoffset;
  JCROP_CODE crop_yoffset_set;


  int num_components;
  jvirt_barray_ptr *workspace_coef_arrays;
  JDIMENSION output_width;
  JDIMENSION output_height;
  JDIMENSION x_crop_offset;
  JDIMENSION y_crop_offset;
  int iMCU_sample_width;
  int iMCU_sample_height;
} jpeg_transform_info;





extern boolean jtransform_parse_crop_spec
        (jpeg_transform_info *info, const char *spec);

extern boolean jtransform_request_workspace
        (j_decompress_ptr srcinfo, jpeg_transform_info *info);

extern jvirt_barray_ptr * jtransform_adjust_parameters
        (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
         jvirt_barray_ptr *src_coef_arrays, jpeg_transform_info *info);

extern void jtransform_execute_transform
        (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
         jvirt_barray_ptr *src_coef_arrays, jpeg_transform_info *info);



extern boolean jtransform_perfect_transform
        (JDIMENSION image_width, JDIMENSION image_height, int MCU_width,
         int MCU_height, JXFORM_CODE transform);
# 193 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/transupp.h"
typedef enum {
  JCOPYOPT_NONE,
  JCOPYOPT_COMMENTS,
  JCOPYOPT_ALL
} JCOPY_OPTION;




extern void jcopy_markers_setup
        (j_decompress_ptr srcinfo, JCOPY_OPTION option);

extern void jcopy_markers_execute
        (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
         JCOPY_OPTION option);
# 43 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/./jpegcomp.h" 1
# 44 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 2

extern void jpeg_mem_dest_tj(j_compress_ptr, unsigned char **,
 unsigned long *, boolean);
extern void jpeg_mem_src_tj(j_decompress_ptr, const unsigned char *,
 unsigned long);







static char errStr[200]="No error";

struct my_error_mgr
{
 struct jpeg_error_mgr pub;
 jmp_buf setjmp_buffer;
 void (*emit_message)(j_common_ptr, int);
 boolean warning;
};
typedef struct my_error_mgr *my_error_ptr;

static void my_error_exit(j_common_ptr cinfo)
{
 my_error_ptr myerr=(my_error_ptr)cinfo->err;
 (*cinfo->err->output_message)(cinfo);
 longjmp(myerr->setjmp_buffer, 1);
}



static void my_output_message(j_common_ptr cinfo)
{
 (*cinfo->err->format_message)(cinfo, errStr);
}

static void my_emit_message(j_common_ptr cinfo, int msg_level)
{
 my_error_ptr myerr=(my_error_ptr)cinfo->err;
 myerr->emit_message(cinfo, msg_level);
 if(msg_level<0) myerr->warning=1;
}




enum {COMPRESS=1, DECOMPRESS=2};

typedef struct _tjinstance
{
 struct jpeg_compress_struct cinfo;
 struct jpeg_decompress_struct dinfo;
 struct my_error_mgr jerr;
 int init, headerRead;
} tjinstance;

static const int pixelsize[6]={3, 3, 3, 1, 3, 3};

static const JXFORM_CODE xformtypes[8]=
{
 JXFORM_NONE, JXFORM_FLIP_H, JXFORM_FLIP_V, JXFORM_TRANSPOSE,
 JXFORM_TRANSVERSE, JXFORM_ROT_90, JXFORM_ROT_180, JXFORM_ROT_270
};


static const tjscalingfactor sf[16]={
 {2, 1},
 {15, 8},
 {7, 4},
 {13, 8},
 {3, 2},
 {11, 8},
 {5, 4},
 {9, 8},
 {1, 1},
 {7, 8},
 {3, 4},
 {5, 8},
 {1, 2},
 {3, 8},
 {1, 4},
 {1, 8}
};
# 150 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
static int getPixelFormat(int pixelSize, int flags)
{
 if(pixelSize==1) return TJPF_GRAY;
 if(pixelSize==3)
 {
  if(flags&1) return TJPF_BGR;
  else return TJPF_RGB;
 }
 if(pixelSize==4)
 {
  if(flags&64)
  {
   if(flags&1) return TJPF_XBGR;
   else return TJPF_XRGB;
  }
  else
  {
   if(flags&1) return TJPF_BGRX;
   else return TJPF_RGBX;
  }
 }
 return -1;
}

static int setCompDefaults(struct jpeg_compress_struct *cinfo,
 int pixelFormat, int subsamp, int jpegQual, int flags)
{
 int retval=0;
 char *env=
# 178 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
          ((void *)0)
# 178 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
              ;

 switch(pixelFormat)
 {
  case TJPF_GRAY:
   cinfo->in_color_space=JCS_GRAYSCALE; break;

  case TJPF_RGB:
   cinfo->in_color_space=JCS_EXT_RGB; break;
  case TJPF_BGR:
   cinfo->in_color_space=JCS_EXT_BGR; break;
  case TJPF_RGBX:
  case TJPF_RGBA:
   cinfo->in_color_space=JCS_EXT_RGBX; break;
  case TJPF_BGRX:
  case TJPF_BGRA:
   cinfo->in_color_space=JCS_EXT_BGRX; break;
  case TJPF_XRGB:
  case TJPF_ARGB:
   cinfo->in_color_space=JCS_EXT_XRGB; break;
  case TJPF_XBGR:
  case TJPF_ABGR:
   cinfo->in_color_space=JCS_EXT_XBGR; break;
# 215 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
  case TJPF_CMYK:
   cinfo->in_color_space=JCS_CMYK; break;
 }

 cinfo->input_components=tjPixelSize[pixelFormat];
 jpeg_set_defaults(cinfo);


 if((env=getenv("TJ_OPTIMIZE"))!=
# 223 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                ((void *)0) 
# 223 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                     && strlen(env)>0 && !strcmp(env, "1"))
  cinfo->optimize_coding=1;
 if((env=getenv("TJ_ARITHMETIC"))!=
# 225 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                  ((void *)0) 
# 225 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                       && strlen(env)>0 && !strcmp(env, "1"))
  cinfo->arith_code=1;
 if((env=getenv("TJ_RESTART"))!=
# 227 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                               ((void *)0) 
# 227 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                    && strlen(env)>0)
 {
  int temp=-1; char tempc=0;
  if(sscanf(env, "%d%c", &temp, &tempc)>=1 && temp>=0 && temp<=65535)
  {
   if(
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     (__extension__ ({ int __res; if (sizeof (
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
     tempc
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     ) > 1) { if (__builtin_constant_p (
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
     tempc
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     )) { int __c = (
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
     tempc
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     ); __res = __c < -128 || __c > 255 ? __c : (*__ctype_toupper_loc ())[__c]; } else __res = toupper (
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
     tempc
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     ); } else __res = (*__ctype_toupper_loc ())[(int) (
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
     tempc
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
     )]; __res; }))
# 232 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                   =='B')
   {
    cinfo->restart_interval=temp;
    cinfo->restart_in_rows=0;
   }
   else
    cinfo->restart_in_rows=temp;
  }
 }


 if(jpegQual>=0)
 {
  jpeg_set_quality(cinfo, jpegQual, 1);
  if(jpegQual>=96 || flags&4096) cinfo->dct_method=JDCT_ISLOW;
  else cinfo->dct_method=JDCT_IFAST;
 }
 if(subsamp==TJSAMP_GRAY)
  jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
 else if(pixelFormat==TJPF_CMYK)
  jpeg_set_colorspace(cinfo, JCS_YCCK);
 else jpeg_set_colorspace(cinfo, JCS_YCbCr);


 if((env=getenv("TJ_PROGRESSIVE"))!=
# 256 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                   ((void *)0) 
# 256 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                        && strlen(env)>0
  && !strcmp(env, "1"))
  jpeg_simple_progression(cinfo);


 cinfo->comp_info[0].h_samp_factor=tjMCUWidth[subsamp]/8;
 cinfo->comp_info[1].h_samp_factor=1;
 cinfo->comp_info[2].h_samp_factor=1;
 if(cinfo->num_components>3)
  cinfo->comp_info[3].h_samp_factor=tjMCUWidth[subsamp]/8;
 cinfo->comp_info[0].v_samp_factor=tjMCUHeight[subsamp]/8;
 cinfo->comp_info[1].v_samp_factor=1;
 cinfo->comp_info[2].v_samp_factor=1;
 if(cinfo->num_components>3)
  cinfo->comp_info[3].v_samp_factor=tjMCUHeight[subsamp]/8;

 return retval;
}

static int setDecompDefaults(struct jpeg_decompress_struct *dinfo,
 int pixelFormat, int flags)
{
 int retval=0;

 switch(pixelFormat)
 {
  case TJPF_GRAY:
   dinfo->out_color_space=JCS_GRAYSCALE; break;

  case TJPF_RGB:
   dinfo->out_color_space=JCS_EXT_RGB; break;
  case TJPF_BGR:
   dinfo->out_color_space=JCS_EXT_BGR; break;
  case TJPF_RGBX:
   dinfo->out_color_space=JCS_EXT_RGBX; break;
  case TJPF_BGRX:
   dinfo->out_color_space=JCS_EXT_BGRX; break;
  case TJPF_XRGB:
   dinfo->out_color_space=JCS_EXT_XRGB; break;
  case TJPF_XBGR:
   dinfo->out_color_space=JCS_EXT_XBGR; break;

  case TJPF_RGBA:
   dinfo->out_color_space=JCS_EXT_RGBA; break;
  case TJPF_BGRA:
   dinfo->out_color_space=JCS_EXT_BGRA; break;
  case TJPF_ARGB:
   dinfo->out_color_space=JCS_EXT_ARGB; break;
  case TJPF_ABGR:
   dinfo->out_color_space=JCS_EXT_ABGR; break;
# 320 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
  case TJPF_CMYK:
   dinfo->out_color_space=JCS_CMYK; break;
  default:
   {snprintf(errStr, 200, "%s", "Unsupported pixel format"); retval=-1; goto bailout;};
 }

 if(flags&2048) dinfo->dct_method=JDCT_IFAST;

 bailout:
 return retval;
}


static int getSubsamp(j_decompress_ptr dinfo)
{
 int retval=-1, i, k;





 if(dinfo->num_components==1 && dinfo->jpeg_color_space==JCS_GRAYSCALE)
  return TJSAMP_GRAY;

 for(i=0; i<6; i++)
 {
  if(dinfo->num_components==pixelsize[i]
   || ((dinfo->jpeg_color_space==JCS_YCCK
    || dinfo->jpeg_color_space==JCS_CMYK)
     && pixelsize[i]==3 && dinfo->num_components==4))
  {
   if(dinfo->comp_info[0].h_samp_factor==tjMCUWidth[i]/8
    && dinfo->comp_info[0].v_samp_factor==tjMCUHeight[i]/8)
   {
    int match=0;
    for(k=1; k<dinfo->num_components; k++)
    {
     int href=1, vref=1;
     if(dinfo->jpeg_color_space==JCS_YCCK && k==3)
     {
      href=tjMCUWidth[i]/8; vref=tjMCUHeight[i]/8;
     }
     if(dinfo->comp_info[k].h_samp_factor==href
      && dinfo->comp_info[k].v_samp_factor==vref)
      match++;
    }
    if(match==dinfo->num_components-1)
    {
     retval=i; break;
    }
   }


   if(dinfo->comp_info[0].h_samp_factor==2 &&
    dinfo->comp_info[0].v_samp_factor==2 &&
    (i==TJSAMP_422 || i==TJSAMP_440))
   {
    int match=0;
    for(k=1; k<dinfo->num_components; k++)
    {
     int href=tjMCUHeight[i]/8, vref=tjMCUWidth[i]/8;
     if(dinfo->jpeg_color_space==JCS_YCCK && k==3)
     {
      href=vref=2;
     }
     if(dinfo->comp_info[k].h_samp_factor==href
      && dinfo->comp_info[k].v_samp_factor==vref)
      match++;
    }
    if(match==dinfo->num_components-1)
    {
     retval=i; break;
    }
   }
  }
 }
 return retval;
}
# 545 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 char* tjGetErrorStr(void)
{
 return errStr;
}


 int tjDestroy(tjhandle handle)
{
 tjinstance *this=(tjinstance *)handle; j_compress_ptr cinfo=
# 553 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 553 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; j_decompress_ptr dinfo=
# 553 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 553 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} cinfo=&this->cinfo; dinfo=&this->dinfo; this->jerr.warning=0;;
 if(
# 554 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 554 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 554 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 554 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   ) return -1;
 if(this->init&COMPRESS) jpeg_destroy_compress(cinfo);
 if(this->init&DECOMPRESS) jpeg_destroy_decompress(dinfo);
 free(this);
 return 0;
}







 void tjFree(unsigned char *buf)
{
 if(buf) free(buf);
}


 unsigned char * tjAlloc(int bytes)
{
 return (unsigned char *)malloc(bytes);
}




static tjhandle _tjInitCompress(tjinstance *this)
{
 static unsigned char buffer[1];
 unsigned char *buf=buffer; unsigned long size=1;


 this->cinfo.err=jpeg_std_error(&this->jerr.pub);
 this->jerr.pub.error_exit=my_error_exit;
 this->jerr.pub.output_message=my_output_message;
 this->jerr.emit_message=this->jerr.pub.emit_message;
 this->jerr.pub.emit_message=my_emit_message;

 if(
# 593 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 593 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 593 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 593 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  if(this) free(this);
  return 
# 597 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 597 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }

 jpeg_CreateCompress((&this->cinfo), 62, (size_t) sizeof(struct jpeg_compress_struct));

 jpeg_mem_dest_tj(&this->cinfo, &buf, &size, 0);

 this->init|=COMPRESS;
 return (tjhandle)this;
}

 tjhandle tjInitCompress(void)
{
 tjinstance *this=
# 610 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0)
# 610 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                     ;
 if((this=(tjinstance *)malloc(sizeof(tjinstance)))==
# 611 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                    ((void *)0)
# 611 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                        )
 {
  snprintf(errStr, 200,
   "tjInitCompress(): Memory allocation failure");
  return 
# 615 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 615 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }
 memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
 return _tjInitCompress(this);
}


 unsigned long tjBufSize(int width, int height,
 int jpegSubsamp)
{
 unsigned long retval=0; int mcuw, mcuh, chromasf;
 if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=6)
  {snprintf(errStr, 200, "%s", "tjBufSize(): Invalid argument"); retval=-1; goto bailout;};




 mcuw=tjMCUWidth[jpegSubsamp];
 mcuh=tjMCUHeight[jpegSubsamp];
 chromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);
 retval=((width+(mcuw)-1)&(~((mcuw)-1))) * ((height+(mcuh)-1)&(~((mcuh)-1))) * (2 + chromasf) + 2048;

 bailout:
 return retval;
}

 unsigned long TJBUFSIZE(int width, int height)
{
 unsigned long retval=0;
 if(width<1 || height<1)
  {snprintf(errStr, 200, "%s", "TJBUFSIZE(): Invalid argument"); retval=-1; goto bailout;};




 retval=((width+(16)-1)&(~((16)-1))) * ((height+(16)-1)&(~((16)-1))) * 6 + 2048;

 bailout:
 return retval;
}


 unsigned long tjBufSizeYUV2(int width, int pad, int height,
 int subsamp)
{
 int retval=0, nc, i;

 if(subsamp<0 || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjBufSizeYUV2(): Invalid argument"); retval=-1; goto bailout;};

 nc=(subsamp==TJSAMP_GRAY? 1:3);
 for(i=0; i<nc; i++)
 {
  int pw=tjPlaneWidth(i, width, subsamp);
  int stride=((pw+(pad)-1)&(~((pad)-1)));
  int ph=tjPlaneHeight(i, height, subsamp);
  if(pw<0 || ph<0) return -1;
  else retval+=stride*ph;
 }

 bailout:
 return retval;
}

 unsigned long tjBufSizeYUV(int width, int height,
 int subsamp)
{
 return tjBufSizeYUV2(width, 4, height, subsamp);
}

 unsigned long TJBUFSIZEYUV(int width, int height,
 int subsamp)
{
 return tjBufSizeYUV(width, height, subsamp);
}


 int tjPlaneWidth(int componentID, int width, int subsamp)
{
 int pw, nc, retval=0;

 if(width<1 || subsamp<0 || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjPlaneWidth(): Invalid argument"); retval=-1; goto bailout;};
 nc=(subsamp==TJSAMP_GRAY? 1:3);
 if(componentID<0 || componentID>=nc)
  {snprintf(errStr, 200, "%s", "tjPlaneWidth(): Invalid argument"); retval=-1; goto bailout;};

 pw=((width+(tjMCUWidth[subsamp]/8)-1)&(~((tjMCUWidth[subsamp]/8)-1)));
 if(componentID==0)
  retval=pw;
 else
  retval=pw*8/tjMCUWidth[subsamp];

 bailout:
 return retval;
}


 int tjPlaneHeight(int componentID, int height, int subsamp)
{
 int ph, nc, retval=0;

 if(height<1 || subsamp<0 || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjPlaneHeight(): Invalid argument"); retval=-1; goto bailout;};
 nc=(subsamp==TJSAMP_GRAY? 1:3);
 if(componentID<0 || componentID>=nc)
  {snprintf(errStr, 200, "%s", "tjPlaneHeight(): Invalid argument"); retval=-1; goto bailout;};

 ph=((height+(tjMCUHeight[subsamp]/8)-1)&(~((tjMCUHeight[subsamp]/8)-1)));
 if(componentID==0)
  retval=ph;
 else
  retval=ph*8/tjMCUHeight[subsamp];

 bailout:
 return retval;
}


 unsigned long tjPlaneSizeYUV(int componentID, int width,
 int stride, int height, int subsamp)
{
 unsigned long retval=0;
 int pw, ph;

 if(width<1 || height<1 || subsamp<0 || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjPlaneSizeYUV(): Invalid argument"); retval=-1; goto bailout;};

 pw=tjPlaneWidth(componentID, width, subsamp);
 ph=tjPlaneHeight(componentID, height, subsamp);
 if(pw<0 || ph<0) return -1;

 if(stride==0) stride=pw;
 else stride=abs(stride);

 retval=stride*(ph-1)+pw;

 bailout:
 return retval;
}


 int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
 int width, int pitch, int height, int pixelFormat, unsigned char **jpegBuf,
 unsigned long *jpegSize, int jpegSubsamp, int jpegQual, int flags)
{
 int i, retval=0, alloc=1; JSAMPROW *row_pointer=
# 761 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                 ((void *)0)
# 761 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                     ;




 tjinstance *this=(tjinstance *)handle; j_compress_ptr cinfo=
# 766 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 766 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} cinfo=&this->cinfo; this->jerr.warning=0;
 if((this->init&COMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjCompress2(): Instance has not been initialized for compression"); retval=-1; goto bailout;};

 if(srcBuf==
# 770 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0) 
# 770 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                || width<=0 || pitch<0 || height<=0 || pixelFormat<0
  || pixelFormat>=12 || jpegBuf==
# 771 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                      ((void *)0) 
# 771 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                           || jpegSize==
# 771 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                        ((void *)0)
  
# 772 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 || jpegSubsamp<0 || jpegSubsamp>=6 || jpegQual<0 || jpegQual>100)
  {snprintf(errStr, 200, "%s", "tjCompress2(): Invalid argument"); retval=-1; goto bailout;};

 if(pitch==0) pitch=width*tjPixelSize[pixelFormat];
# 787 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 if((row_pointer=(JSAMPROW *)malloc(sizeof(JSAMPROW)*height))==
# 787 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                              ((void *)0)
# 787 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                  )
  {snprintf(errStr, 200, "%s", "tjCompress2(): Memory allocation failure"); retval=-1; goto bailout;};

 if(
# 790 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 790 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 790 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 790 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 cinfo->image_width=width;
 cinfo->image_height=height;

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(flags&1024)
 {
  alloc=0; *jpegSize=tjBufSize(width, height, jpegSubsamp);
 }
 jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);
 if(setCompDefaults(cinfo, pixelFormat, jpegSubsamp, jpegQual, flags)==-1)
  return -1;

 jpeg_start_compress(cinfo, 1);
 for(i=0; i<height; i++)
 {
  if(flags&2)
   row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*pitch];
  else row_pointer[i]=(JSAMPROW)&srcBuf[i*pitch];
 }
 while(cinfo->next_scanline<cinfo->image_height)
 {
  jpeg_write_scanlines(cinfo, &row_pointer[cinfo->next_scanline],
   cinfo->image_height-cinfo->next_scanline);
 }
 jpeg_finish_compress(cinfo);

 bailout:
 if(cinfo->global_state>100) jpeg_abort_compress(cinfo);



 if(row_pointer) free(row_pointer);
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjCompress(tjhandle handle, unsigned char *srcBuf,
 int width, int pitch, int height, int pixelSize, unsigned char *jpegBuf,
 unsigned long *jpegSize, int jpegSubsamp, int jpegQual, int flags)
{
 int retval=0; unsigned long size;
 if(flags&512)
 {
  size=tjBufSizeYUV(width, height, jpegSubsamp);
  retval=tjEncodeYUV2(handle, srcBuf, width, pitch, height,
   getPixelFormat(pixelSize, flags), jpegBuf, jpegSubsamp, flags);
 }
 else
 {
  retval=tjCompress2(handle, srcBuf, width, pitch, height,
   getPixelFormat(pixelSize, flags), &jpegBuf, &size, jpegSubsamp, jpegQual,
   flags|1024);
 }
 *jpegSize=size;
 return retval;
}


 int tjEncodeYUVPlanes(tjhandle handle,
 const unsigned char *srcBuf, int width, int pitch, int height,
 int pixelFormat, unsigned char **dstPlanes, int *strides, int subsamp,
 int flags)
{
 int i, retval=0; JSAMPROW *row_pointer=
# 863 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                        ((void *)0)
# 863 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                            ;
 JSAMPLE *_tmpbuf[10], *_tmpbuf2[10];
 JSAMPROW *tmpbuf[10], *tmpbuf2[10];
 JSAMPROW *outbuf[10];
 int row, pw0, ph0, pw[10], ph[10];
 JSAMPLE *ptr;
 jpeg_component_info *compptr;




 tjinstance *this=(tjinstance *)handle; j_compress_ptr cinfo=
# 874 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 874 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} cinfo=&this->cinfo; this->jerr.warning=0;;

 for(i=0; i<10; i++)
 {
  tmpbuf[i]=
# 878 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0)
# 878 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
               ; _tmpbuf[i]=
# 878 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                             ((void *)0)
# 878 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                 ;
  tmpbuf2[i]=
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0)
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                ; _tmpbuf2[i]=
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                               ((void *)0)
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   ; outbuf[i]=
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                ((void *)0)
# 879 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                    ;
 }

 if((this->init&COMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Instance has not been initialized for compression"); retval=-1; goto bailout;};

 if(srcBuf==
# 885 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0) 
# 885 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                || width<=0 || pitch<0 || height<=0 || pixelFormat<0
  || pixelFormat>=12 || !dstPlanes || !dstPlanes[0] || subsamp<0
  || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};
 if(subsamp!=TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};

 if(pixelFormat==TJPF_CMYK)
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Cannot generate YUV images from CMYK pixels"); retval=-1; goto bailout;};

 if(pitch==0) pitch=width*tjPixelSize[pixelFormat];
# 907 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 if(
# 907 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 907 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 907 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 907 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 cinfo->image_width=width;
 cinfo->image_height=height;

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(setCompDefaults(cinfo, pixelFormat, subsamp, -1, flags)==-1) return -1;





 if(cinfo->global_state!=100)
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): libjpeg API is in the wrong state"); retval=-1; goto bailout;};
 (*cinfo->err->reset_error_mgr)((j_common_ptr)cinfo);
 jinit_c_master_control(cinfo, 0);
 jinit_color_converter(cinfo);
 jinit_downsampler(cinfo);
 (*cinfo->cconvert->start_pass)(cinfo);

 pw0=((width+(cinfo->max_h_samp_factor)-1)&(~((cinfo->max_h_samp_factor)-1)));
 ph0=((height+(cinfo->max_v_samp_factor)-1)&(~((cinfo->max_v_samp_factor)-1)));

 if((row_pointer=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph0))==
# 938 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                           ((void *)0)
# 938 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                               )
  {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
 for(i=0; i<height; i++)
 {
  if(flags&2)
   row_pointer[i]=(JSAMPROW)&srcBuf[(height-i-1)*pitch];
  else row_pointer[i]=(JSAMPROW)&srcBuf[i*pitch];
 }
 if(height<ph0)
  for(i=height; i<ph0; i++) row_pointer[i]=row_pointer[height-1];

 for(i=0; i<cinfo->num_components; i++)
 {
  compptr=&cinfo->comp_info[i];
  _tmpbuf[i]=(JSAMPLE *)malloc(
   (((compptr->width_in_blocks*cinfo->max_h_samp_factor*8) /compptr->h_samp_factor+(16)-1)&(~((16)-1)))
                                 * cinfo->max_v_samp_factor + 16);
  if(!_tmpbuf[i]) {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*cinfo->max_v_samp_factor);
  if(!tmpbuf[i]) {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  for(row=0; row<cinfo->max_v_samp_factor; row++)
  {
   unsigned char *_tmpbuf_aligned=
    (unsigned char *)(((size_t)_tmpbuf[i]+(16)-1)&(~((16)-1)));
   tmpbuf[i][row]=&_tmpbuf_aligned[
    (((compptr->width_in_blocks*cinfo->max_h_samp_factor*8) /compptr->h_samp_factor+(16)-1)&(~((16)-1)))
                                  * row];
  }
  _tmpbuf2[i]=(JSAMPLE *)malloc(((compptr->width_in_blocks*8 +(16)-1)&(~((16)-1)))
   * compptr->v_samp_factor + 16);
  if(!_tmpbuf2[i]) {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  tmpbuf2[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*compptr->v_samp_factor);
  if(!tmpbuf2[i]) {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  for(row=0; row<compptr->v_samp_factor; row++)
  {
   unsigned char *_tmpbuf2_aligned=
    (unsigned char *)(((size_t)_tmpbuf2[i]+(16)-1)&(~((16)-1)));
   tmpbuf2[i][row]=&_tmpbuf2_aligned[
    ((compptr->width_in_blocks*8 +(16)-1)&(~((16)-1))) * row];
  }
  pw[i]=pw0*compptr->h_samp_factor/cinfo->max_h_samp_factor;
  ph[i]=ph0*compptr->v_samp_factor/cinfo->max_v_samp_factor;
  outbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph[i]);
  if(!outbuf[i]) {snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=dstPlanes[i];
  for(row=0; row<ph[i]; row++)
  {
   outbuf[i][row]=ptr;
   ptr+=(strides && strides[i]!=0)? strides[i]:pw[i];
  }
 }

 if(
# 990 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 990 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 990 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 990 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 for(row=0; row<ph0; row+=cinfo->max_v_samp_factor)
 {
  (*cinfo->cconvert->color_convert)(cinfo, &row_pointer[row], tmpbuf, 0,
   cinfo->max_v_samp_factor);
  (cinfo->downsample->downsample)(cinfo, tmpbuf, 0, tmpbuf2, 0);
  for(i=0, compptr=cinfo->comp_info; i<cinfo->num_components; i++, compptr++)
   jcopy_sample_rows(tmpbuf2[i], 0, outbuf[i],
    row*compptr->v_samp_factor/cinfo->max_v_samp_factor,
    compptr->v_samp_factor, pw[i]);
 }
 cinfo->next_scanline+=height;
 jpeg_abort_compress(cinfo);

 bailout:
 if(cinfo->global_state>100) jpeg_abort_compress(cinfo);



 if(row_pointer) free(row_pointer);
 for(i=0; i<10; i++)
 {
  if(tmpbuf[i]!=
# 1018 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
               ((void *)0)
# 1018 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                   ) free(tmpbuf[i]);
  if(_tmpbuf[i]!=
# 1019 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                ((void *)0)
# 1019 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                    ) free(_tmpbuf[i]);
  if(tmpbuf2[i]!=
# 1020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                ((void *)0)
# 1020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                    ) free(tmpbuf2[i]);
  if(_tmpbuf2[i]!=
# 1021 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0)
# 1021 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                     ) free(_tmpbuf2[i]);
  if(outbuf[i]!=
# 1022 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
               ((void *)0)
# 1022 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                   ) free(outbuf[i]);
 }
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjEncodeYUV3(tjhandle handle,
 const unsigned char *srcBuf, int width, int pitch, int height,
 int pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)
{
 unsigned char *dstPlanes[3];
 int pw0, ph0, strides[3], retval=-1;

 if(width<=0 || height<=0 || dstBuf==
# 1035 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                    ((void *)0) 
# 1035 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                         || pad<0 || !(((pad)&(pad-1))==0)
  || subsamp<0 || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjEncodeYUV3(): Invalid argument"); retval=-1; goto bailout;};

 pw0=tjPlaneWidth(0, width, subsamp);
 ph0=tjPlaneHeight(0, height, subsamp);
 dstPlanes[0]=dstBuf;
 strides[0]=((pw0+(pad)-1)&(~((pad)-1)));
 if(subsamp==TJSAMP_GRAY)
 {
  strides[1]=strides[2]=0;
  dstPlanes[1]=dstPlanes[2]=
# 1046 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 1046 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 }
 else
 {
  int pw1=tjPlaneWidth(1, width, subsamp);
  int ph1=tjPlaneHeight(1, height, subsamp);
  strides[1]=strides[2]=((pw1+(pad)-1)&(~((pad)-1)));
  dstPlanes[1]=dstPlanes[0]+strides[0]*ph0;
  dstPlanes[2]=dstPlanes[1]+strides[1]*ph1;
 }

 return tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,
  dstPlanes, strides, subsamp, flags);

 bailout:
 return retval;
}

 int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf,
 int width, int pitch, int height, int pixelFormat, unsigned char *dstBuf,
 int subsamp, int flags)
{
 return tjEncodeYUV3(handle, srcBuf, width, pitch, height, pixelFormat,
  dstBuf, 4, subsamp, flags);
}

 int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf,
 int width, int pitch, int height, int pixelSize, unsigned char *dstBuf,
 int subsamp, int flags)
{
 return tjEncodeYUV2(handle, srcBuf, width, pitch, height,
  getPixelFormat(pixelSize, flags), dstBuf, subsamp, flags);
}


 int tjCompressFromYUVPlanes(tjhandle handle,
 const unsigned char **srcPlanes, int width, const int *strides, int height,
 int subsamp, unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual,
 int flags)
{
 int i, row, retval=0, alloc=1; JSAMPROW *inbuf[10];
 int pw[10], ph[10], iw[10],
  tmpbufsize=0, usetmpbuf=0, th[10];
 JSAMPLE *_tmpbuf=
# 1089 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0)
# 1089 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                     , *ptr; JSAMPROW *tmpbuf[10];

 tjinstance *this=(tjinstance *)handle; j_compress_ptr cinfo=
# 1091 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1091 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} cinfo=&this->cinfo; this->jerr.warning=0;

 for(i=0; i<10; i++)
 {
  tmpbuf[i]=
# 1095 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0)
# 1095 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
               ; inbuf[i]=
# 1095 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 1095 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 }

 if((this->init&COMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Instance has not been initialized for compression"); retval=-1; goto bailout;};

 if(!srcPlanes || !srcPlanes[0] || width<=0 || height<=0 || subsamp<0
  || subsamp>=6 || jpegBuf==
# 1102 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                   ((void *)0) 
# 1102 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                        || jpegSize==
# 1102 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                     ((void *)0) 
# 1102 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                          || jpegQual<0
  || jpegQual>100)
  {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};
 if(subsamp!=TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))
  {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};

 if(
# 1108 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1108 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1108 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1108 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 cinfo->image_width=width;
 cinfo->image_height=height;

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(flags&1024)
 {
  alloc=0; *jpegSize=tjBufSize(width, height, subsamp);
 }
 jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);
 if(setCompDefaults(cinfo, TJPF_RGB, subsamp, jpegQual, flags)==-1)
  return -1;
 cinfo->raw_data_in=1;

 jpeg_start_compress(cinfo, 1);
 for(i=0; i<cinfo->num_components; i++)
 {
  jpeg_component_info *compptr=&cinfo->comp_info[i];
  int ih;
  iw[i]=compptr->width_in_blocks*8;
  ih=compptr->height_in_blocks*8;
  pw[i]=((cinfo->image_width+(cinfo->max_h_samp_factor)-1)&(~((cinfo->max_h_samp_factor)-1)))
   *compptr->h_samp_factor/cinfo->max_h_samp_factor;
  ph[i]=((cinfo->image_height+(cinfo->max_v_samp_factor)-1)&(~((cinfo->max_v_samp_factor)-1)))
   *compptr->v_samp_factor/cinfo->max_v_samp_factor;
  if(iw[i]!=pw[i] || ih!=ph[i]) usetmpbuf=1;
  th[i]=compptr->v_samp_factor*8;
  tmpbufsize+=iw[i]*th[i];
  if((inbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph[i]))==
# 1145 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                           ((void *)0)
# 1145 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                               )
   {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=(JSAMPLE *)srcPlanes[i];
  for(row=0; row<ph[i]; row++)
  {
   inbuf[i][row]=ptr;
   ptr+=(strides && strides[i]!=0)? strides[i]:pw[i];
  }
 }
 if(usetmpbuf)
 {
  if((_tmpbuf=(JSAMPLE *)malloc(sizeof(JSAMPLE)*tmpbufsize))==
# 1156 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                             ((void *)0)
# 1156 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                 )
   {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=_tmpbuf;
  for(i=0; i<cinfo->num_components; i++)
  {
   if((tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*th[i]))==
# 1161 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                             ((void *)0)
# 1161 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                 )
    {snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
   for(row=0; row<th[i]; row++)
   {
    tmpbuf[i][row]=ptr;
    ptr+=iw[i];
   }
  }
 }

 if(
# 1171 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1171 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1171 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1171 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 for(row=0; row<(int)cinfo->image_height;
  row+=cinfo->max_v_samp_factor*8)
 {
  JSAMPARRAY yuvptr[10];
  int crow[10];
  for(i=0; i<cinfo->num_components; i++)
  {
   jpeg_component_info *compptr=&cinfo->comp_info[i];
   crow[i]=row*compptr->v_samp_factor/cinfo->max_v_samp_factor;
   if(usetmpbuf)
   {
    int j, k;
    for(j=0; j<((th[i])<(ph[i]-crow[i])?(th[i]):(ph[i]-crow[i])); j++)
    {
     memcpy(tmpbuf[i][j], inbuf[i][crow[i]+j], pw[i]);

     for(k=pw[i]; k<iw[i]; k++) tmpbuf[i][j][k]=tmpbuf[i][j][pw[i]-1];
    }

    for(j=ph[i]-crow[i]; j<th[i]; j++)
     memcpy(tmpbuf[i][j], tmpbuf[i][ph[i]-crow[i]-1], iw[i]);
    yuvptr[i]=tmpbuf[i];
   }
   else
    yuvptr[i]=&inbuf[i][crow[i]];
  }
  jpeg_write_raw_data(cinfo, yuvptr, cinfo->max_v_samp_factor*8);
 }
 jpeg_finish_compress(cinfo);

 bailout:
 if(cinfo->global_state>100) jpeg_abort_compress(cinfo);
 for(i=0; i<10; i++)
 {
  if(tmpbuf[i]) free(tmpbuf[i]);
  if(inbuf[i]) free(inbuf[i]);
 }
 if(_tmpbuf) free(_tmpbuf);
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjCompressFromYUV(tjhandle handle,
 const unsigned char *srcBuf, int width, int pad, int height, int subsamp,
 unsigned char **jpegBuf, unsigned long *jpegSize, int jpegQual, int flags)
{
 const unsigned char *srcPlanes[3];
 int pw0, ph0, strides[3], retval=-1;

 if(srcBuf==
# 1227 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0) 
# 1227 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                || width<=0 || pad<1 || height<=0 || subsamp<0
  || subsamp>=6)
  {snprintf(errStr, 200, "%s", "tjCompressFromYUV(): Invalid argument"); retval=-1; goto bailout;};

 pw0=tjPlaneWidth(0, width, subsamp);
 ph0=tjPlaneHeight(0, height, subsamp);
 srcPlanes[0]=srcBuf;
 strides[0]=((pw0+(pad)-1)&(~((pad)-1)));
 if(subsamp==TJSAMP_GRAY)
 {
  strides[1]=strides[2]=0;
  srcPlanes[1]=srcPlanes[2]=
# 1238 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 1238 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 }
 else
 {
  int pw1=tjPlaneWidth(1, width, subsamp);
  int ph1=tjPlaneHeight(1, height, subsamp);
  strides[1]=strides[2]=((pw1+(pad)-1)&(~((pad)-1)));
  srcPlanes[1]=srcPlanes[0]+strides[0]*ph0;
  srcPlanes[2]=srcPlanes[1]+strides[1]*ph1;
 }

 return tjCompressFromYUVPlanes(handle, srcPlanes, width, strides, height,
  subsamp, jpegBuf, jpegSize, jpegQual, flags);

 bailout:
 return retval;
}




static tjhandle _tjInitDecompress(tjinstance *this)
{
 static unsigned char buffer[1];


 this->dinfo.err=jpeg_std_error(&this->jerr.pub);
 this->jerr.pub.error_exit=my_error_exit;
 this->jerr.pub.output_message=my_output_message;
 this->jerr.emit_message=this->jerr.pub.emit_message;
 this->jerr.pub.emit_message=my_emit_message;

 if(
# 1270 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1270 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1270 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1270 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  if(this) free(this);
  return 
# 1274 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 1274 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }

 jpeg_CreateDecompress((&this->dinfo), 62, (size_t) sizeof(struct jpeg_decompress_struct));

 jpeg_mem_src_tj(&this->dinfo, buffer, 1);

 this->init|=DECOMPRESS;
 return (tjhandle)this;
}

 tjhandle tjInitDecompress(void)
{
 tjinstance *this;
 if((this=(tjinstance *)malloc(sizeof(tjinstance)))==
# 1288 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                    ((void *)0)
# 1288 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                        )
 {
  snprintf(errStr, 200,
   "tjInitDecompress(): Memory allocation failure");
  return 
# 1292 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 1292 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }
 memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
 return _tjInitDecompress(this);
}


 int tjDecompressHeader3(tjhandle handle,
 const unsigned char *jpegBuf, unsigned long jpegSize, int *width,
 int *height, int *jpegSubsamp, int *jpegColorspace)
{
 int retval=0;

 tjinstance *this=(tjinstance *)handle; j_decompress_ptr dinfo=
# 1305 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1305 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} dinfo=&this->dinfo; this->jerr.warning=0;;
 if((this->init&DECOMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Instance has not been initialized for decompression"); retval=-1; goto bailout;};

 if(jpegBuf==
# 1309 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 1309 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || jpegSize<=0 || width==
# 1309 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                          ((void *)0) 
# 1309 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                               || height==
# 1309 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                          ((void *)0)
  
# 1310 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 || jpegSubsamp==
# 1310 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0) 
# 1310 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                      || jpegColorspace==
# 1310 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                         ((void *)0)
# 1310 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                             )
  {snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Invalid argument"); retval=-1; goto bailout;};

 if(
# 1313 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1313 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1313 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1313 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  return -1;
 }

 jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
 jpeg_read_header(dinfo, 1);

 *width=dinfo->image_width;
 *height=dinfo->image_height;
 *jpegSubsamp=getSubsamp(dinfo);
 switch(dinfo->jpeg_color_space)
 {
  case JCS_GRAYSCALE: *jpegColorspace=TJCS_GRAY; break;
  case JCS_RGB: *jpegColorspace=TJCS_RGB; break;
  case JCS_YCbCr: *jpegColorspace=TJCS_YCbCr; break;
  case JCS_CMYK: *jpegColorspace=TJCS_CMYK; break;
  case JCS_YCCK: *jpegColorspace=TJCS_YCCK; break;
  default: *jpegColorspace=-1; break;
 }

 jpeg_abort_decompress(dinfo);

 if(*jpegSubsamp<0)
  {snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Could not determine subsampling type for JPEG image"); retval=-1; goto bailout;};
 if(*jpegColorspace<0)
  {snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Could not determine colorspace of JPEG image"); retval=-1; goto bailout;};
 if(*width<1 || *height<1)
  {snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Invalid data returned in header"); retval=-1; goto bailout;};

 bailout:
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjDecompressHeader2(tjhandle handle,
 unsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height,
 int *jpegSubsamp)
{
 int jpegColorspace;
 return tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,
  jpegSubsamp, &jpegColorspace);
}

 int tjDecompressHeader(tjhandle handle,
 unsigned char *jpegBuf, unsigned long jpegSize, int *width, int *height)
{
 int jpegSubsamp;
 return tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height,
  &jpegSubsamp);
}


 tjscalingfactor* tjGetScalingFactors(int *numscalingfactors)
{
 if(numscalingfactors==
# 1369 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                      ((void *)0)
# 1369 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                          )
 {
  snprintf(errStr, 200,
   "tjGetScalingFactors(): Invalid argument");
  return 
# 1373 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 1373 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }

 *numscalingfactors=16;
 return (tjscalingfactor *)sf;
}


 int tjDecompress2(tjhandle handle,
 const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
 int width, int pitch, int height, int pixelFormat, int flags)
{
 int i, retval=0; JSAMPROW *row_pointer=
# 1385 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                        ((void *)0)
# 1385 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                            ;
 int jpegwidth, jpegheight, scaledw, scaledh;





 tjinstance *this=(tjinstance *)handle; j_decompress_ptr dinfo=
# 1392 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1392 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} dinfo=&this->dinfo; this->jerr.warning=0;;
 if((this->init&DECOMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjDecompress2(): Instance has not been initialized for decompression"); retval=-1; goto bailout;};

 if(jpegBuf==
# 1396 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 1396 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || jpegSize<=0 || dstBuf==
# 1396 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                           ((void *)0) 
# 1396 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                || width<0 || pitch<0
  || height<0 || pixelFormat<0 || pixelFormat>=12)
  {snprintf(errStr, 200, "%s", "tjDecompress2(): Invalid argument"); retval=-1; goto bailout;};

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(
# 1404 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1404 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1404 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1404 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
 jpeg_read_header(dinfo, 1);
 if(setDecompDefaults(dinfo, pixelFormat, flags)==-1)
 {
  retval=-1; goto bailout;
 }

 if(flags&256) dinfo->do_fancy_upsampling=0;

 jpegwidth=dinfo->image_width; jpegheight=dinfo->image_height;
 if(width==0) width=jpegwidth;
 if(height==0) height=jpegheight;
 for(i=0; i<16; i++)
 {
  scaledw=((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  scaledh=((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  if(scaledw<=width && scaledh<=height)
   break;
 }
 if(i>=16)
  {snprintf(errStr, 200, "%s", "tjDecompress2(): Could not scale down to desired image dimensions"); retval=-1; goto bailout;};
 width=scaledw; height=scaledh;
 dinfo->scale_num=sf[i].num;
 dinfo->scale_denom=sf[i].denom;

 jpeg_start_decompress(dinfo);
 if(pitch==0) pitch=dinfo->output_width*tjPixelSize[pixelFormat];
# 1453 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 if((row_pointer=(JSAMPROW *)malloc(sizeof(JSAMPROW)
  *dinfo->output_height))==
# 1454 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                          ((void *)0)
# 1454 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                              )
  {snprintf(errStr, 200, "%s", "tjDecompress2(): Memory allocation failure"); retval=-1; goto bailout;};
 if(
# 1456 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1456 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1456 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1456 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }
 for(i=0; i<(int)dinfo->output_height; i++)
 {
  if(flags&2)
   row_pointer[i]=&dstBuf[(dinfo->output_height-i-1)*pitch];
  else row_pointer[i]=&dstBuf[i*pitch];
 }
 while(dinfo->output_scanline<dinfo->output_height)
 {
  jpeg_read_scanlines(dinfo, &row_pointer[dinfo->output_scanline],
   dinfo->output_height-dinfo->output_scanline);
 }
 jpeg_finish_decompress(dinfo);





 bailout:
 if(dinfo->global_state>200) jpeg_abort_decompress(dinfo);



 if(row_pointer) free(row_pointer);
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
 unsigned long jpegSize, unsigned char *dstBuf, int width, int pitch,
 int height, int pixelSize, int flags)
{
 if(flags&512)
  return tjDecompressToYUV(handle, jpegBuf, jpegSize, dstBuf, flags);
 else
  return tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, width, pitch,
   height, getPixelFormat(pixelSize, flags), flags);
}


static int setDecodeDefaults(struct jpeg_decompress_struct *dinfo,
 int pixelFormat, int subsamp, int flags)
{
 int i;

 dinfo->scale_num=dinfo->scale_denom=1;

 if(subsamp==TJSAMP_GRAY)
 {
  dinfo->num_components=dinfo->comps_in_scan=1;
  dinfo->jpeg_color_space=JCS_GRAYSCALE;
 }
 else
 {
  dinfo->num_components=dinfo->comps_in_scan=3;
  dinfo->jpeg_color_space=JCS_YCbCr;
 }

 dinfo->comp_info=(jpeg_component_info *)
  (*dinfo->mem->alloc_small)((j_common_ptr)dinfo, 1,
   dinfo->num_components*sizeof(jpeg_component_info));

 for(i=0; i<dinfo->num_components; i++)
 {
  jpeg_component_info *compptr=&dinfo->comp_info[i];
  compptr->h_samp_factor=(i==0)? tjMCUWidth[subsamp]/8:1;
  compptr->v_samp_factor=(i==0)? tjMCUHeight[subsamp]/8:1;
  compptr->component_index=i;
  compptr->component_id=i+1;
  compptr->quant_tbl_no=compptr->dc_tbl_no=compptr->ac_tbl_no=
   (i==0)? 0:1;
  dinfo->cur_comp_info[i]=compptr;
 }
 dinfo->data_precision=8;
 for(i=0; i<2; i++)
 {
  if(dinfo->quant_tbl_ptrs[i]==
# 1537 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                              ((void *)0)
# 1537 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                  )
   dinfo->quant_tbl_ptrs[i]=jpeg_alloc_quant_table((j_common_ptr)dinfo);
 }

 return 0;
}


int my_read_markers(j_decompress_ptr dinfo)
{
 return 1;
}

void my_reset_marker_reader(j_decompress_ptr dinfo)
{
}

 int tjDecodeYUVPlanes(tjhandle handle,
 const unsigned char **srcPlanes, const int *strides, int subsamp,
 unsigned char *dstBuf, int width, int pitch, int height, int pixelFormat,
 int flags)
{
 int i, retval=0; JSAMPROW *row_pointer=
# 1559 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                        ((void *)0)
# 1559 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                            ;
 JSAMPLE *_tmpbuf[10];
 JSAMPROW *tmpbuf[10], *inbuf[10];
 int row, pw0, ph0, pw[10], ph[10];
 JSAMPLE *ptr;
 jpeg_component_info *compptr;




 int (*old_read_markers)(j_decompress_ptr);
 void (*old_reset_marker_reader)(j_decompress_ptr);

 tjinstance *this=(tjinstance *)handle; j_decompress_ptr dinfo=
# 1572 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1572 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} dinfo=&this->dinfo; this->jerr.warning=0;;

 for(i=0; i<10; i++)
 {
  tmpbuf[i]=
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0)
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
               ; _tmpbuf[i]=
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                             ((void *)0)
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                 ; inbuf[i]=
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                             ((void *)0)
# 1576 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                 ;
 }

 if((this->init&DECOMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Instance has not been initialized for decompression"); retval=-1; goto bailout;};

 if(!srcPlanes || !srcPlanes[0] || subsamp<0 || subsamp>=6
  || dstBuf==
# 1583 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 1583 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || width<=0 || pitch<0 || height<=0 || pixelFormat<0
  || pixelFormat>=12)
  {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};
 if(subsamp!=TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))
  {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};

 if(
# 1589 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1589 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1589 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1589 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 if(pixelFormat==TJPF_CMYK)
  {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Cannot decode YUV images into CMYK pixels."); retval=-1; goto bailout;};

 if(pitch==0) pitch=width*tjPixelSize[pixelFormat];
 dinfo->image_width=width;
 dinfo->image_height=height;

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(setDecodeDefaults(dinfo, pixelFormat, subsamp, flags)==-1)
 {
  retval=-1; goto bailout;
 }
 old_read_markers=dinfo->marker->read_markers;
 dinfo->marker->read_markers=my_read_markers;
 old_reset_marker_reader=dinfo->marker->reset_marker_reader;
 dinfo->marker->reset_marker_reader=my_reset_marker_reader;
 jpeg_read_header(dinfo, 1);
 dinfo->marker->read_markers=old_read_markers;
 dinfo->marker->reset_marker_reader=old_reset_marker_reader;

 if(setDecompDefaults(dinfo, pixelFormat, flags)==-1)
 {
  retval=-1; goto bailout;
 }
 dinfo->do_fancy_upsampling=0;
 dinfo->Se=64 -1;
 jinit_master_decompress(dinfo);
 (*dinfo->upsample->start_pass)(dinfo);

 pw0=((width+(dinfo->max_h_samp_factor)-1)&(~((dinfo->max_h_samp_factor)-1)));
 ph0=((height+(dinfo->max_v_samp_factor)-1)&(~((dinfo->max_v_samp_factor)-1)));

 if(pitch==0) pitch=dinfo->output_width*tjPixelSize[pixelFormat];
# 1647 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 if((row_pointer=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph0))==
# 1647 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                           ((void *)0)
# 1647 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                               )
  {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
 for(i=0; i<height; i++)
 {
  if(flags&2) row_pointer[i]=&dstBuf[(height-i-1)*pitch];
  else row_pointer[i]=&dstBuf[i*pitch];
 }
 if(height<ph0)
  for(i=height; i<ph0; i++) row_pointer[i]=row_pointer[height-1];

 for(i=0; i<dinfo->num_components; i++)
 {
  compptr=&dinfo->comp_info[i];
  _tmpbuf[i]=(JSAMPLE *)malloc(((compptr->width_in_blocks*8 +(16)-1)&(~((16)-1)))
   * compptr->v_samp_factor + 16);
  if(!_tmpbuf[i]) {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*compptr->v_samp_factor);
  if(!tmpbuf[i]) {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  for(row=0; row<compptr->v_samp_factor; row++)
  {
   unsigned char *_tmpbuf_aligned=
    (unsigned char *)(((size_t)_tmpbuf[i]+(16)-1)&(~((16)-1)));
   tmpbuf[i][row]=&_tmpbuf_aligned[
    ((compptr->width_in_blocks*8 +(16)-1)&(~((16)-1))) * row];
  }
  pw[i]=pw0*compptr->h_samp_factor/dinfo->max_h_samp_factor;
  ph[i]=ph0*compptr->v_samp_factor/dinfo->max_v_samp_factor;
  inbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph[i]);
  if(!inbuf[i]) {snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=(JSAMPLE *)srcPlanes[i];
  for(row=0; row<ph[i]; row++)
  {
   inbuf[i][row]=ptr;
   ptr+=(strides && strides[i]!=0)? strides[i]:pw[i];
  }
 }

 if(
# 1684 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1684 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1684 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1684 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 for(row=0; row<ph0; row+=dinfo->max_v_samp_factor)
 {
  JDIMENSION inrow=0, outrow=0;
  for(i=0, compptr=dinfo->comp_info; i<dinfo->num_components; i++, compptr++)
   jcopy_sample_rows(inbuf[i],
    row*compptr->v_samp_factor/dinfo->max_v_samp_factor, tmpbuf[i], 0,
    compptr->v_samp_factor, pw[i]);
  (dinfo->upsample->upsample)(dinfo, tmpbuf, &inrow,
   dinfo->max_v_samp_factor, &row_pointer[row], &outrow,
   dinfo->max_v_samp_factor);
 }
 jpeg_abort_decompress(dinfo);





 bailout:
 if(dinfo->global_state>200) jpeg_abort_decompress(dinfo);



 if(row_pointer) free(row_pointer);
 for(i=0; i<10; i++)
 {
  if(tmpbuf[i]!=
# 1716 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
               ((void *)0)
# 1716 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                   ) free(tmpbuf[i]);
  if(_tmpbuf[i]!=
# 1717 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                ((void *)0)
# 1717 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                    ) free(_tmpbuf[i]);
  if(inbuf[i]!=
# 1718 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
              ((void *)0)
# 1718 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                  ) free(inbuf[i]);
 }
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
 int pad, int subsamp, unsigned char *dstBuf, int width, int pitch,
 int height, int pixelFormat, int flags)
{
 const unsigned char *srcPlanes[3];
 int pw0, ph0, strides[3], retval=-1;

 if(srcBuf==
# 1731 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0) 
# 1731 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                || pad<0 || !(((pad)&(pad-1))==0) || subsamp<0 || subsamp>=6
  || width<=0 || height<=0)
  {snprintf(errStr, 200, "%s", "tjDecodeYUV(): Invalid argument"); retval=-1; goto bailout;};

 pw0=tjPlaneWidth(0, width, subsamp);
 ph0=tjPlaneHeight(0, height, subsamp);
 srcPlanes[0]=srcBuf;
 strides[0]=((pw0+(pad)-1)&(~((pad)-1)));
 if(subsamp==TJSAMP_GRAY)
 {
  strides[1]=strides[2]=0;
  srcPlanes[1]=srcPlanes[2]=
# 1742 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 1742 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 }
 else
 {
  int pw1=tjPlaneWidth(1, width, subsamp);
  int ph1=tjPlaneHeight(1, height, subsamp);
  strides[1]=strides[2]=((pw1+(pad)-1)&(~((pad)-1)));
  srcPlanes[1]=srcPlanes[0]+strides[0]*ph0;
  srcPlanes[2]=srcPlanes[1]+strides[1]*ph1;
 }

 return tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,
  pitch, height, pixelFormat, flags);

 bailout:
 return retval;
}

 int tjDecompressToYUVPlanes(tjhandle handle,
 const unsigned char *jpegBuf, unsigned long jpegSize,
 unsigned char **dstPlanes, int width, int *strides, int height, int flags)
{
 int i, sfi, row, retval=0; JSAMPROW *outbuf[10];
 int jpegwidth, jpegheight, jpegSubsamp, scaledw, scaledh;
 int pw[10], ph[10], iw[10],
  tmpbufsize=0, usetmpbuf=0, th[10];
 JSAMPLE *_tmpbuf=
# 1768 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0)
# 1768 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                     , *ptr; JSAMPROW *tmpbuf[10];
 int dctsize;

 tjinstance *this=(tjinstance *)handle; j_decompress_ptr dinfo=
# 1771 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1771 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} dinfo=&this->dinfo; this->jerr.warning=0;;

 for(i=0; i<10; i++)
 {
  tmpbuf[i]=
# 1775 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
           ((void *)0)
# 1775 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
               ; outbuf[i]=
# 1775 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                            ((void *)0)
# 1775 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                ;
 }

 if((this->init&DECOMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Instance has not been initialized for decompression"); retval=-1; goto bailout;};

 if(jpegBuf==
# 1781 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 1781 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || jpegSize<=0 || !dstPlanes || !dstPlanes[0] || width<0
  || height<0)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if(
# 1789 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1789 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1789 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1789 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 if(!this->headerRead)
 {
  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
  jpeg_read_header(dinfo, 1);
 }
 this->headerRead=0;
 jpegSubsamp=getSubsamp(dinfo);
 if(jpegSubsamp<0)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not determine subsampling type for JPEG image"); retval=-1; goto bailout;};

 if(jpegSubsamp!=TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); retval=-1; goto bailout;};

 jpegwidth=dinfo->image_width; jpegheight=dinfo->image_height;
 if(width==0) width=jpegwidth;
 if(height==0) height=jpegheight;
 for(i=0; i<16; i++)
 {
  scaledw=((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  scaledh=((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  if(scaledw<=width && scaledh<=height)
   break;
 }
 if(i>=16)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not scale down to desired image dimensions"); retval=-1; goto bailout;};
 if(dinfo->num_components>3)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): JPEG image must have 3 or fewer components"); retval=-1; goto bailout;};

 width=scaledw; height=scaledh;
 dinfo->scale_num=sf[i].num;
 dinfo->scale_denom=sf[i].denom;
 sfi=i;
 jpeg_calc_output_dimensions(dinfo);

 dctsize=8*sf[sfi].num/sf[sfi].denom;

 for(i=0; i<dinfo->num_components; i++)
 {
  jpeg_component_info *compptr=&dinfo->comp_info[i];
  int ih;
  iw[i]=compptr->width_in_blocks*dctsize;
  ih=compptr->height_in_blocks*dctsize;
  pw[i]=((dinfo->output_width+(dinfo->max_h_samp_factor)-1)&(~((dinfo->max_h_samp_factor)-1)))
   *compptr->h_samp_factor/dinfo->max_h_samp_factor;
  ph[i]=((dinfo->output_height+(dinfo->max_v_samp_factor)-1)&(~((dinfo->max_v_samp_factor)-1)))
   *compptr->v_samp_factor/dinfo->max_v_samp_factor;
  if(iw[i]!=pw[i] || ih!=ph[i]) usetmpbuf=1;
  th[i]=compptr->v_samp_factor*dctsize;
  tmpbufsize+=iw[i]*th[i];
  if((outbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*ph[i]))==
# 1845 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                            ((void *)0)
# 1845 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                )
   {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=dstPlanes[i];
  for(row=0; row<ph[i]; row++)
  {
   outbuf[i][row]=ptr;
   ptr+=(strides && strides[i]!=0)? strides[i]:pw[i];
  }
 }
 if(usetmpbuf)
 {
  if((_tmpbuf=(JSAMPLE *)malloc(sizeof(JSAMPLE)*tmpbufsize))==
# 1856 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                             ((void *)0)
# 1856 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                 )
   {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
  ptr=_tmpbuf;
  for(i=0; i<dinfo->num_components; i++)
  {
   if((tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*th[i]))==
# 1861 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                             ((void *)0)
# 1861 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                                 )
    {snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval=-1; goto bailout;};
   for(row=0; row<th[i]; row++)
   {
    tmpbuf[i][row]=ptr;
    ptr+=iw[i];
   }
  }
 }

 if(
# 1871 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1871 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1871 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1871 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 if(flags&256) dinfo->do_fancy_upsampling=0;
 if(flags&2048) dinfo->dct_method=JDCT_IFAST;
 dinfo->raw_data_out=1;

 jpeg_start_decompress(dinfo);
 for(row=0; row<(int)dinfo->output_height;
  row+=dinfo->max_v_samp_factor*dinfo->min_DCT_scaled_size)
 {
  JSAMPARRAY yuvptr[10];
  int crow[10];
  for(i=0; i<dinfo->num_components; i++)
  {
   jpeg_component_info *compptr=&dinfo->comp_info[i];
   if(jpegSubsamp==TJSAMP_420)
   {
# 1903 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
    compptr->DCT_scaled_size=dctsize;
    compptr->MCU_sample_width=tjMCUWidth[jpegSubsamp]*
     sf[sfi].num/sf[sfi].denom*
     compptr->v_samp_factor/dinfo->max_v_samp_factor;
    dinfo->idct->inverse_DCT[i] = dinfo->idct->inverse_DCT[0];
   }
   crow[i]=row*compptr->v_samp_factor/dinfo->max_v_samp_factor;
   if(usetmpbuf) yuvptr[i]=tmpbuf[i];
   else yuvptr[i]=&outbuf[i][crow[i]];
  }
  jpeg_read_raw_data(dinfo, yuvptr,
   dinfo->max_v_samp_factor*dinfo->min_DCT_scaled_size);
  if(usetmpbuf)
  {
   int j;
   for(i=0; i<dinfo->num_components; i++)
   {
    for(j=0; j<((th[i])<(ph[i]-crow[i])?(th[i]):(ph[i]-crow[i])); j++)
    {
     memcpy(outbuf[i][crow[i]+j], tmpbuf[i][j], pw[i]);
    }
   }
  }
 }
 jpeg_finish_decompress(dinfo);

 bailout:
 if(dinfo->global_state>200) jpeg_abort_decompress(dinfo);
 for(i=0; i<10; i++)
 {
  if(tmpbuf[i]) free(tmpbuf[i]);
  if(outbuf[i]) free(outbuf[i]);
 }
 if(_tmpbuf) free(_tmpbuf);
 if(this->jerr.warning) retval=-1;
 return retval;
}

 int tjDecompressToYUV2(tjhandle handle,
 const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
 int width, int pad, int height, int flags)
{
 unsigned char *dstPlanes[3];
 int pw0, ph0, strides[3], retval=-1, jpegSubsamp=-1;
 int i, jpegwidth, jpegheight, scaledw, scaledh;

 tjinstance *this=(tjinstance *)handle; j_decompress_ptr dinfo=
# 1949 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 1949 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} dinfo=&this->dinfo; this->jerr.warning=0;;

 if(jpegBuf==
# 1951 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 1951 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || jpegSize<=0 || dstBuf==
# 1951 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                           ((void *)0) 
# 1951 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                || width<0 || pad<1
  || !(((pad)&(pad-1))==0) || height<0)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Invalid argument"); retval=-1; goto bailout;};

 if(
# 1955 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 1955 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 1955 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 1955 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  return -1;
 }

 jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
 jpeg_read_header(dinfo, 1);
 jpegSubsamp=getSubsamp(dinfo);
 if(jpegSubsamp<0)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Could not determine subsampling type for JPEG image"); retval=-1; goto bailout;};

 jpegwidth=dinfo->image_width; jpegheight=dinfo->image_height;
 if(width==0) width=jpegwidth;
 if(height==0) height=jpegheight;

 for(i=0; i<16; i++)
 {
  scaledw=((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  scaledh=((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
  if(scaledw<=width && scaledh<=height)
   break;
 }
 if(i>=16)
  {snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Could not scale down to desired image dimensions"); retval=-1; goto bailout;};

 pw0=tjPlaneWidth(0, width, jpegSubsamp);
 ph0=tjPlaneHeight(0, height, jpegSubsamp);
 dstPlanes[0]=dstBuf;
 strides[0]=((pw0+(pad)-1)&(~((pad)-1)));
 if(jpegSubsamp==TJSAMP_GRAY)
 {
  strides[1]=strides[2]=0;
  dstPlanes[1]=dstPlanes[2]=
# 1988 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 1988 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 }
 else
 {
  int pw1=tjPlaneWidth(1, width, jpegSubsamp);
  int ph1=tjPlaneHeight(1, height, jpegSubsamp);
  strides[1]=strides[2]=((pw1+(pad)-1)&(~((pad)-1)));
  dstPlanes[1]=dstPlanes[0]+strides[0]*ph0;
  dstPlanes[2]=dstPlanes[1]+strides[1]*ph1;
 }

 this->headerRead=1;
 return tjDecompressToYUVPlanes(handle, jpegBuf, jpegSize, dstPlanes, width,
  strides, height, flags);

 bailout:
 return retval;

}

 int tjDecompressToYUV(tjhandle handle,
 unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
 int flags)
{
 return tjDecompressToYUV2(handle, jpegBuf, jpegSize, dstBuf, 0, 4, 0, flags);
}




 tjhandle tjInitTransform(void)
{
 tjinstance *this=
# 2020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                 ((void *)0)
# 2020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                     ; tjhandle handle=
# 2020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                        ((void *)0)
# 2020 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                            ;
 if((this=(tjinstance *)malloc(sizeof(tjinstance)))==
# 2021 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                    ((void *)0)
# 2021 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                        )
 {
  snprintf(errStr, 200,
   "tjInitTransform(): Memory allocation failure");
  return 
# 2025 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
        ((void *)0)
# 2025 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            ;
 }
 memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
 handle=_tjInitCompress(this);
 if(!handle) return 
# 2029 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                   ((void *)0)
# 2029 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                       ;
 handle=_tjInitDecompress(this);
 return handle;
}


 int tjTransform(tjhandle handle,
 const unsigned char *jpegBuf, unsigned long jpegSize, int n,
 unsigned char **dstBufs, unsigned long *dstSizes, tjtransform *t, int flags)
{
 jpeg_transform_info *xinfo=
# 2039 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                           ((void *)0)
# 2039 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                               ;
 jvirt_barray_ptr *srccoefs, *dstcoefs;
 int retval=0, i, jpegSubsamp;

 tjinstance *this=(tjinstance *)handle; j_compress_ptr cinfo=
# 2043 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 2043 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; j_decompress_ptr dinfo=
# 2043 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
((void *)0)
# 2043 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
; if(!this) {snprintf(errStr, 200, "Invalid handle"); return -1;} cinfo=&this->cinfo; dinfo=&this->dinfo; this->jerr.warning=0;;
 if((this->init&COMPRESS)==0 || (this->init&DECOMPRESS)==0)
  {snprintf(errStr, 200, "%s", "tjTransform(): Instance has not been initialized for transformation"); retval=-1; goto bailout;};

 if(jpegBuf==
# 2047 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
            ((void *)0) 
# 2047 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                 || jpegSize<=0 || n<1 || dstBufs==
# 2047 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                   ((void *)0) 
# 2047 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                                        || dstSizes==
# 2047 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
                                                                     ((void *)0)
  
# 2048 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
 || t==
# 2048 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
       ((void *)0) 
# 2048 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
            || flags<0)
  {snprintf(errStr, 200, "%s", "tjTransform(): Invalid argument"); retval=-1; goto bailout;};

 if(flags&8) putenv("JSIMD_FORCEMMX=1");
 else if(flags&16) putenv("JSIMD_FORCESSE=1");
 else if(flags&32) putenv("JSIMD_FORCESSE2=1");

 if((xinfo=(jpeg_transform_info *)malloc(sizeof(jpeg_transform_info)*n))
  ==
# 2056 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   ((void *)0)
# 2056 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
       )
  {snprintf(errStr, 200, "%s", "tjTransform(): Memory allocation failure"); retval=-1; goto bailout;};
 memset((void *)(xinfo), 0, (size_t)(sizeof(jpeg_transform_info)*n));

 if(
# 2060 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   _setjmp (
# 2060 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
   this->jerr.setjmp_buffer
# 2060 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c" 3 4
   )
# 2060 "/doner/libjpeg/libjpeg-3212005/libjpeg-turbo/turbojpeg.c"
                                   )
 {

  retval=-1;
  goto bailout;
 }

 jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);

 for(i=0; i<n; i++)
 {
  xinfo[i].transform=xformtypes[t[i].op];
  xinfo[i].perfect=(t[i].options&1)? 1:0;
  xinfo[i].trim=(t[i].options&2)? 1:0;
  xinfo[i].force_grayscale=(t[i].options&8)? 1:0;
  xinfo[i].crop=(t[i].options&4)? 1:0;
  if(n!=1 && t[i].op==TJXOP_HFLIP) xinfo[i].slow_hflip=1;
  else xinfo[i].slow_hflip=0;

  if(xinfo[i].crop)
  {
   xinfo[i].crop_xoffset=t[i].r.x; xinfo[i].crop_xoffset_set=JCROP_POS;
   xinfo[i].crop_yoffset=t[i].r.y; xinfo[i].crop_yoffset_set=JCROP_POS;
   if(t[i].r.w!=0)
   {
    xinfo[i].crop_width=t[i].r.w; xinfo[i].crop_width_set=JCROP_POS;
   }
   else xinfo[i].crop_width=JCROP_UNSET;
   if(t[i].r.h!=0)
   {
    xinfo[i].crop_height=t[i].r.h; xinfo[i].crop_height_set=JCROP_POS;
   }
   else xinfo[i].crop_height=JCROP_UNSET;
  }
 }

 jcopy_markers_setup(dinfo, JCOPYOPT_ALL);
 jpeg_read_header(dinfo, 1);
 jpegSubsamp=getSubsamp(dinfo);
 if(jpegSubsamp<0)
  {snprintf(errStr, 200, "%s", "tjTransform(): Could not determine subsampling type for JPEG image"); retval=-1; goto bailout;};

 for(i=0; i<n; i++)
 {
  if(!jtransform_request_workspace(dinfo, &xinfo[i]))
   {snprintf(errStr, 200, "%s", "tjTransform(): Transform is not perfect"); retval=-1; goto bailout;};

  if(xinfo[i].crop)
  {
   if((t[i].r.x%xinfo[i].iMCU_sample_width)!=0
    || (t[i].r.y%xinfo[i].iMCU_sample_height)!=0)
   {
    snprintf(errStr, 200,
     "To crop this JPEG image, x must be a multiple of %d\n"
     "and y must be a multiple of %d.\n",
     xinfo[i].iMCU_sample_width, xinfo[i].iMCU_sample_height);
    retval=-1; goto bailout;
   }
  }
 }

 srccoefs=jpeg_read_coefficients(dinfo);

 for(i=0; i<n; i++)
 {
  int w, h, alloc=1;
  if(!xinfo[i].crop)
  {
   w=dinfo->image_width; h=dinfo->image_height;
  }
  else
  {
   w=xinfo[i].crop_width; h=xinfo[i].crop_height;
  }
  if(flags&1024)
  {
   alloc=0; dstSizes[i]=tjBufSize(w, h, jpegSubsamp);
  }
  if(!(t[i].options&16))
   jpeg_mem_dest_tj(cinfo, &dstBufs[i], &dstSizes[i], alloc);
  jpeg_copy_critical_parameters(dinfo, cinfo);
  dstcoefs=jtransform_adjust_parameters(dinfo, cinfo, srccoefs,
   &xinfo[i]);
  if(!(t[i].options&16))
  {
   jpeg_write_coefficients(cinfo, dstcoefs);
   jcopy_markers_execute(dinfo, cinfo, JCOPYOPT_ALL);
  }
  else jinit_c_master_control(cinfo, 1);
  jtransform_execute_transform(dinfo, cinfo, srccoefs,
   &xinfo[i]);
  if(t[i].customFilter)
  {
   int ci, y; JDIMENSION by;
   for(ci=0; ci<cinfo->num_components; ci++)
   {
    jpeg_component_info *compptr=&cinfo->comp_info[ci];
    tjregion arrayRegion={0, 0, compptr->width_in_blocks*8,
     8};
    tjregion planeRegion={0, 0, compptr->width_in_blocks*8,
     compptr->height_in_blocks*8};
    for(by=0; by<compptr->height_in_blocks; by+=compptr->v_samp_factor)
    {
     JBLOCKARRAY barray=(dinfo->mem->access_virt_barray)
      ((j_common_ptr)dinfo, dstcoefs[ci], by, compptr->v_samp_factor,
      1);
     for(y=0; y<compptr->v_samp_factor; y++)
     {
      if(t[i].customFilter(barray[y][0], arrayRegion, planeRegion,
       ci, i, &t[i])==-1)
       {snprintf(errStr, 200, "%s", "tjTransform(): Error in custom filter"); retval=-1; goto bailout;};
      arrayRegion.y+=8;
     }
    }
   }
  }
  if(!(t[i].options&16)) jpeg_finish_compress(cinfo);
 }

 jpeg_finish_decompress(dinfo);

 bailout:
 if(cinfo->global_state>100) jpeg_abort_compress(cinfo);
 if(dinfo->global_state>200) jpeg_abort_decompress(dinfo);
 if(xinfo) free(xinfo);
 if(this->jerr.warning) retval=-1;
 return retval;
}
