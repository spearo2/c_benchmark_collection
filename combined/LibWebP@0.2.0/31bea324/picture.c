/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 18 "../../src/dec/common_dec.h"
enum __anonenum__0 {
    B_DC_PRED = 0,
    B_TM_PRED = 1,
    B_VE_PRED = 2,
    B_HE_PRED = 3,
    B_RD_PRED = 4,
    B_VR_PRED = 5,
    B_LD_PRED = 6,
    B_VL_PRED = 7,
    B_HD_PRED = 8,
    B_HU_PRED = 9,
    NUM_BMODES = 10,
    DC_PRED = 0,
    V_PRED = 2,
    H_PRED = 3,
    TM_PRED = 1,
    B_PRED = 10,
    NUM_PRED_MODES = 4,
    B_DC_PRED_NOTOP = 4,
    B_DC_PRED_NOLEFT = 5,
    B_DC_PRED_NOTOPLEFT = 6,
    NUM_B_DC_MODES = 7
} ;
#line 42
enum __anonenum__1 {
    MB_FEATURE_TREE_PROBS = 3,
    NUM_MB_SEGMENTS = 4,
    NUM_REF_LF_DELTAS = 4,
    NUM_MODE_LF_DELTAS = 4,
    MAX_NUM_PARTITIONS = 8,
    NUM_TYPES = 4,
    NUM_BANDS = 8,
    NUM_CTX = 3,
    NUM_PROBAS = 11
} ;
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef long ptrdiff_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
struct __anonstruct_2 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef struct __anonstruct_2 max_align_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_3 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_3 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_4 imaxdiv_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 38 "/usr/include/sched.h"
typedef __pid_t pid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_5 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_5 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_7 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_6 {
   unsigned long long __wseq ;
   struct __anonstruct_7 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_8 {
   unsigned long long __g1_start ;
   struct __anonstruct_9 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_6  ;
   unsigned long long __wseq ;
   struct __anonstruct_7 __wseq32 ;
   union __anonunion_8  ;
   unsigned long long __g1_start ;
   struct __anonstruct_9 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_10 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_10 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_barrierattr_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/pthread.h"
enum __anonenum__18 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 43
enum __anonenum__19 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 65
enum __anonenum__20 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 77
enum __anonenum__21 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 100
enum __anonenum__22 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 120
enum __anonenum__23 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 130
enum __anonenum__24 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 140
enum __anonenum__25 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 155 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 164
enum __anonenum__26 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 171
enum __anonenum__27 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 501 "/usr/include/pthread.h"
struct __anonstruct_29 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 499 "/usr/include/pthread.h"
struct __anonstruct_28 {
   struct __anonstruct_29 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 507 "/usr/include/pthread.h"
typedef struct __anonstruct_28 __pthread_unwind_buf_t;
#line 516 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 718
struct __jmp_buf_tag ;
#line 250 "../../src/dsp/cpu.h"
enum __anonenum__30 {
    kSSE2 = 0,
    kSSE3 = 1,
    kSlowSSSE3 = 2,
    kSSE4_1 = 3,
    kAVX = 4,
    kAVX2 = 5,
    kNEON = 6,
    kMIPS32 = 7,
    kMIPSdspR2 = 8,
    kMSA = 9
} ;
#line 261 "../../src/dsp/cpu.h"
typedef enum __anonenum__30 CPUFeature;
#line 264 "../../src/dsp/cpu.h"
typedef int (*VP8CPUInfo)(CPUFeature  );
#line 63 "../../src/dsp/dsp.h"
typedef void (*VP8Idct)(uint8_t * , int16_t * , uint8_t * , int  );
#line 65 "../../src/dsp/dsp.h"
typedef void (*VP8Fdct)(uint8_t * , uint8_t * , int16_t * );
#line 66 "../../src/dsp/dsp.h"
typedef void (*VP8WHT)(int16_t * , int16_t * );
#line 73 "../../src/dsp/dsp.h"
typedef void (*VP8IntraPreds)(uint8_t * , uint8_t * , uint8_t * );
#line 75 "../../src/dsp/dsp.h"
typedef void (*VP8Intra4Preds)(uint8_t * , uint8_t * );
#line 80 "../../src/dsp/dsp.h"
typedef int (*VP8Metric)(uint8_t * , uint8_t * );
#line 82 "../../src/dsp/dsp.h"
typedef int (*VP8WMetric)(uint8_t * , uint8_t * , uint16_t * const   );
#line 90 "../../src/dsp/dsp.h"
typedef void (*VP8MeanMetric)(uint8_t * , uint32_t [4] );
#line 93 "../../src/dsp/dsp.h"
typedef void (*VP8BlockCopy)(uint8_t * , uint8_t * );
#line 97
struct VP8Matrix ;
#line 98 "../../src/dsp/dsp.h"
typedef int (*VP8QuantizeBlock)(int16_t [16] , int16_t [16] , struct VP8Matrix * const   );
#line 101 "../../src/dsp/dsp.h"
typedef int (*VP8Quantize2Blocks)(int16_t [32] , int16_t [32] , struct VP8Matrix * const   );
#line 108 "../../src/dsp/dsp.h"
typedef int (*VP8QuantizeBlockWHT)(int16_t [16] , int16_t [16] , struct VP8Matrix * const   );
#line 116 "../../src/dsp/dsp.h"
struct __anonstruct_31 {
   int max_value ;
   int last_non_zero ;
};
#line 120 "../../src/dsp/dsp.h"
typedef struct __anonstruct_31 VP8Histogram;
#line 121 "../../src/dsp/dsp.h"
typedef void (*VP8CHisto)(uint8_t * , uint8_t * , int  , int  , VP8Histogram * const   );
#line 140
struct VP8Residual ;
#line 141 "../../src/dsp/dsp.h"
typedef void (*VP8SetResidualCoeffsFunc)(int16_t * const   , struct VP8Residual * const   );
#line 146 "../../src/dsp/dsp.h"
typedef int (*VP8GetResidualCostFunc)(int  , struct VP8Residual * const   );
#line 157 "../../src/dsp/dsp.h"
struct __anonstruct_32 {
   uint32_t w ;
   uint32_t xm ;
   uint32_t ym ;
   uint32_t xxm ;
   uint32_t xym ;
   uint32_t yym ;
};
#line 161 "../../src/dsp/dsp.h"
typedef struct __anonstruct_32 VP8DistoStats;
#line 169 "../../src/dsp/dsp.h"
typedef double (*VP8SSIMGetClippedFunc)(uint8_t * , int  , uint8_t * , int  , int  ,
                                        int  , int  , int  );
#line 177 "../../src/dsp/dsp.h"
typedef double (*VP8SSIMGetFunc)(uint8_t * , int  , uint8_t * , int  );
#line 185 "../../src/dsp/dsp.h"
typedef uint32_t (*VP8AccumulateSSEFunc)(uint8_t * , uint8_t * , int  );
#line 196 "../../src/dsp/dsp.h"
typedef void (*VP8DecIdct)(int16_t * , uint8_t * );
#line 198 "../../src/dsp/dsp.h"
typedef void (*VP8DecIdct2)(int16_t * , uint8_t * , int  );
#line 208 "../../src/dsp/dsp.h"
typedef void (*VP8PredFunc)(uint8_t * );
#line 222 "../../src/dsp/dsp.h"
typedef void (*VP8SimpleFilterFunc)(uint8_t * , int  , int  );
#line 229 "../../src/dsp/dsp.h"
typedef void (*VP8LumaFilterFunc)(uint8_t * , int  , int  , int  , int  );
#line 231 "../../src/dsp/dsp.h"
typedef void (*VP8ChromaFilterFunc)(uint8_t * , uint8_t * , int  , int  , int  , int  );
#line 264 "../../src/dsp/dsp.h"
typedef void (*WebPUpsampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         int  );
#line 278 "../../src/dsp/dsp.h"
typedef void (*WebPSamplerRowFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                   int  );
#line 296 "../../src/dsp/dsp.h"
typedef void (*WebPYUV444Converter)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                    int  );
#line 341
struct WebPRescaler ;
#line 346 "../../src/dsp/dsp.h"
typedef void (*WebPRescalerImportRowFunc)(struct WebPRescaler * const   , uint8_t * );
#line 355 "../../src/dsp/dsp.h"
typedef void (*WebPRescalerExportRowFunc)(struct WebPRescaler * const   );
#line 468
enum __anonenum__33 {
    WEBP_FILTER_NONE = 0,
    WEBP_FILTER_HORIZONTAL = 1,
    WEBP_FILTER_VERTICAL = 2,
    WEBP_FILTER_GRADIENT = 3,
    WEBP_FILTER_LAST = 4,
    WEBP_FILTER_BEST = 5,
    WEBP_FILTER_FAST = 6
} ;
#line 476 "../../src/dsp/dsp.h"
typedef enum __anonenum__33 WEBP_FILTER_TYPE;
#line 478 "../../src/dsp/dsp.h"
typedef void (*WebPFilterFunc)(uint8_t * , int  , int  , int  , uint8_t * );
#line 482 "../../src/dsp/dsp.h"
typedef void (*WebPUnfilterFunc)(uint8_t * , uint8_t * , uint8_t * , int  );
#line 26 "../../src/utils/bit_writer_utils.h"
struct VP8BitWriter ;
#line 26 "../../src/utils/bit_writer_utils.h"
typedef struct VP8BitWriter VP8BitWriter;
#line 27 "../../src/utils/bit_writer_utils.h"
struct VP8BitWriter {
   int32_t range_ ;
   int32_t value_ ;
   int run_ ;
   int nb_bits_ ;
   uint8_t *buf_ ;
   size_t pos_ ;
   size_t max_pos_ ;
   int error_ ;
};
#line 74 "../../src/utils/bit_writer_utils.h"
typedef uint64_t vp8l_atype_t;
#line 75 "../../src/utils/bit_writer_utils.h"
typedef uint32_t vp8l_wtype_t;
#line 89 "../../src/utils/bit_writer_utils.h"
struct __anonstruct_34 {
   vp8l_atype_t bits_ ;
   int used_ ;
   uint8_t *buf_ ;
   uint8_t *cur_ ;
   uint8_t *end_ ;
   int error_ ;
};
#line 101 "../../src/utils/bit_writer_utils.h"
typedef struct __anonstruct_34 VP8LBitWriter;
#line 28 "../../src/utils/thread_utils.h"
enum __anonenum__35 {
    NOT_OK = 0,
    OK = 1,
    WORK = 2
} ;
#line 32 "../../src/utils/thread_utils.h"
typedef enum __anonenum__35 WebPWorkerStatus;
#line 36 "../../src/utils/thread_utils.h"
typedef int (*WebPWorkerHook)(void * , void * );
#line 39 "../../src/utils/thread_utils.h"
struct __anonstruct_36 {
   void *impl_ ;
   WebPWorkerStatus status_ ;
   WebPWorkerHook hook ;
   void *data1 ;
   void *data2 ;
   int had_error ;
};
#line 46 "../../src/utils/thread_utils.h"
typedef struct __anonstruct_36 WebPWorker;
#line 50 "../../src/utils/thread_utils.h"
struct __anonstruct_37 {
   void (*Init)(WebPWorker * const   ) ;
   int (*Reset)(WebPWorker * const   ) ;
   int (*Sync)(WebPWorker * const   ) ;
   void (*Launch)(WebPWorker * const   ) ;
   void (*Execute)(WebPWorker * const   ) ;
   void (*End)(WebPWorker * const   ) ;
};
#line 71 "../../src/utils/thread_utils.h"
typedef struct __anonstruct_37 WebPWorkerInterface;
#line 177 "../../src/utils/utils.h"
struct WebPPicture ;
#line 31 "../../src/webp/encode.h"
struct WebPConfig ;
#line 31 "../../src/webp/encode.h"
typedef struct WebPConfig WebPConfig;
#line 32 "../../src/webp/encode.h"
typedef struct WebPPicture WebPPicture;
#line 33
struct WebPAuxStats ;
#line 33 "../../src/webp/encode.h"
typedef struct WebPAuxStats WebPAuxStats;
#line 34
struct WebPMemoryWriter ;
#line 34 "../../src/webp/encode.h"
typedef struct WebPMemoryWriter WebPMemoryWriter;
#line 86
enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4
} ;
#line 92 "../../src/webp/encode.h"
typedef enum WebPImageHint WebPImageHint;
#line 95 "../../src/webp/encode.h"
struct WebPConfig {
   int lossless ;
   float quality ;
   int method ;
   WebPImageHint image_hint ;
   int target_size ;
   float target_PSNR ;
   int segments ;
   int sns_strength ;
   int filter_strength ;
   int filter_sharpness ;
   int filter_type ;
   int autofilter ;
   int alpha_compression ;
   int alpha_filtering ;
   int alpha_quality ;
   int pass ;
   int show_compressed ;
   int preprocessing ;
   int partitions ;
   int partition_limit ;
   int emulate_jpeg_size ;
   int thread_level ;
   int low_memory ;
   int near_lossless ;
   int exact ;
   int use_delta_palette ;
   int use_sharp_yuv ;
   int qmin ;
   int qmax ;
};
#line 157
enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5
} ;
#line 164 "../../src/webp/encode.h"
typedef enum WebPPreset WebPPreset;
#line 204 "../../src/webp/encode.h"
struct WebPAuxStats {
   int coded_size ;
   float PSNR[5] ;
   int block_count[3] ;
   int header_bytes[2] ;
   int residual_bytes[3][4] ;
   int segment_size[4] ;
   int segment_quant[4] ;
   int segment_level[4] ;
   int alpha_data_size ;
   int layer_data_size ;
   uint32_t lossless_features ;
   int histogram_bits ;
   int transform_bits ;
   int cache_bits ;
   int palette_size ;
   int lossless_size ;
   int lossless_hdr_size ;
   int lossless_data_size ;
   uint32_t pad[2] ;
};
#line 237 "../../src/webp/encode.h"
typedef int (*WebPWriterFunction)(uint8_t * , size_t  , WebPPicture * );
#line 242 "../../src/webp/encode.h"
struct WebPMemoryWriter {
   uint8_t *mem ;
   size_t size ;
   size_t max_size ;
   uint32_t pad[1] ;
};
#line 264 "../../src/webp/encode.h"
typedef int (*WebPProgressHook)(int  , WebPPicture * );
#line 267
enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV420A = 4,
    WEBP_CSP_UV_MASK = 3,
    WEBP_CSP_ALPHA_BIT = 4
} ;
#line 273 "../../src/webp/encode.h"
typedef enum WebPEncCSP WebPEncCSP;
#line 276
enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11
} ;
#line 289 "../../src/webp/encode.h"
typedef enum WebPEncodingError WebPEncodingError;
#line 300 "../../src/webp/encode.h"
struct WebPPicture {
   int use_argb ;
   WebPEncCSP colorspace ;
   int width ;
   int height ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   uint8_t *a ;
   int a_stride ;
   uint32_t pad1[2] ;
   uint32_t *argb ;
   int argb_stride ;
   uint32_t pad2[3] ;
   WebPWriterFunction writer ;
   void *custom_ptr ;
   int extra_info_type ;
   uint8_t *extra_info ;
   WebPAuxStats *stats ;
   WebPEncodingError error_code ;
   WebPProgressHook progress_hook ;
   void *user_data ;
   uint32_t pad3[3] ;
   uint8_t *pad4 ;
   uint8_t *pad5 ;
   uint32_t pad6[8] ;
   void *memory_ ;
   void *memory_argb_ ;
   void *pad7[2] ;
};
#line 37 "../../src/enc/vp8i_enc.h"
enum __anonenum__38 {
    MAX_LF_LEVELS = 64,
    MAX_VARIABLE_LEVEL = 67,
    MAX_LEVEL = 2047
} ;
#line 42
enum __anonenum__39 {
    RD_OPT_NONE = 0,
    RD_OPT_BASIC = 1,
    RD_OPT_TRELLIS = 2,
    RD_OPT_TRELLIS_ALL = 3
} ;
#line 47 "../../src/enc/vp8i_enc.h"
typedef enum __anonenum__39 VP8RDLevel;
#line 107 "../../src/enc/vp8i_enc.h"
typedef int64_t score_t;
#line 129 "../../src/enc/vp8i_enc.h"
typedef uint32_t proba_t;
#line 130 "../../src/enc/vp8i_enc.h"
typedef uint8_t ProbaArray[3][11];
#line 131 "../../src/enc/vp8i_enc.h"
typedef proba_t StatsArray[3][11];
#line 132 "../../src/enc/vp8i_enc.h"
typedef uint16_t CostArray[3][68];
#line 133 "../../src/enc/vp8i_enc.h"
typedef uint16_t *(*CostArrayPtr)[3];
#line 134 "../../src/enc/vp8i_enc.h"
typedef uint16_t *CostArrayMap[16][3];
#line 135 "../../src/enc/vp8i_enc.h"
typedef double LFStats[4][64];
#line 137
struct VP8Encoder ;
#line 137 "../../src/enc/vp8i_enc.h"
typedef struct VP8Encoder VP8Encoder;
#line 140 "../../src/enc/vp8i_enc.h"
struct __anonstruct_40 {
   int num_segments_ ;
   int update_map_ ;
   int size_ ;
};
#line 145 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_40 VP8EncSegmentHeader;
#line 148 "../../src/enc/vp8i_enc.h"
struct __anonstruct_41 {
   uint8_t segments_[3] ;
   uint8_t skip_proba_ ;
   ProbaArray coeffs_[4][8] ;
   StatsArray stats_[4][8] ;
   CostArray level_cost_[4][8] ;
   CostArrayMap remapped_costs_[4] ;
   int dirty_ ;
   int use_skip_proba_ ;
   int nb_skip_ ;
};
#line 158 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_41 VP8EncProba;
#line 162 "../../src/enc/vp8i_enc.h"
struct __anonstruct_42 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int i4x4_lf_delta_ ;
};
#line 167 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_42 VP8EncFilterHeader;
#line 172 "../../src/enc/vp8i_enc.h"
struct __anonstruct_43 {
   unsigned int type_ ;
   unsigned int uv_mode_ ;
   unsigned int skip_ ;
   unsigned int segment_ ;
   uint8_t alpha_ ;
};
#line 179 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_43 VP8MBInfo;
#line 181 "../../src/enc/vp8i_enc.h"
struct VP8Matrix {
   uint16_t q_[16] ;
   uint16_t iq_[16] ;
   uint32_t bias_[16] ;
   uint32_t zthresh_[16] ;
   uint16_t sharpen_[16] ;
};
#line 187 "../../src/enc/vp8i_enc.h"
typedef struct VP8Matrix VP8Matrix;
#line 189 "../../src/enc/vp8i_enc.h"
struct __anonstruct_44 {
   VP8Matrix y1_ ;
   VP8Matrix y2_ ;
   VP8Matrix uv_ ;
   int alpha_ ;
   int beta_ ;
   int quant_ ;
   int fstrength_ ;
   int max_edge_ ;
   int min_disto_ ;
   int lambda_i16_ ;
   int lambda_i4_ ;
   int lambda_uv_ ;
   int lambda_mode_ ;
   int lambda_trellis_ ;
   int tlambda_ ;
   int lambda_trellis_i16_ ;
   int lambda_trellis_i4_ ;
   int lambda_trellis_uv_ ;
   score_t i4_penalty_ ;
};
#line 205 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_44 VP8SegmentInfo;
#line 207 "../../src/enc/vp8i_enc.h"
typedef int8_t DError[2][2];
#line 211 "../../src/enc/vp8i_enc.h"
struct __anonstruct_45 {
   score_t D ;
   score_t SD ;
   score_t H ;
   score_t R ;
   score_t score ;
   int16_t y_dc_levels[16] ;
   int16_t y_ac_levels[16][16] ;
   int16_t uv_levels[8][16] ;
   int mode_i16 ;
   uint8_t modes_i4[16] ;
   int mode_uv ;
   uint32_t nz ;
   int8_t derr[2][3] ;
};
#line 222 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_45 VP8ModeScore;
#line 226 "../../src/enc/vp8i_enc.h"
struct __anonstruct_46 {
   int x_ ;
   int y_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   VP8Encoder *enc_ ;
   VP8MBInfo *mb_ ;
   VP8BitWriter *bw_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t i4_boundary_[37] ;
   uint8_t *i4_top_ ;
   int i4_ ;
   int top_nz_[9] ;
   int left_nz_[9] ;
   uint64_t bit_count_[4][3] ;
   uint64_t luma_bits_ ;
   uint64_t uv_bits_ ;
   LFStats *lf_stats_ ;
   int do_trellis_ ;
   int count_down_ ;
   int count_down0_ ;
   int percent0_ ;
   DError left_derr_ ;
   DError *top_derr_ ;
   uint8_t *y_left_ ;
   uint8_t *u_left_ ;
   uint8_t *v_left_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   uint8_t yuv_left_mem_[88] ;
   uint8_t yuv_mem_[3359] ;
};
#line 265 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_46 VP8EncIterator;
#line 310
struct VP8Tokens ;
#line 310 "../../src/enc/vp8i_enc.h"
typedef struct VP8Tokens VP8Tokens;
#line 312 "../../src/enc/vp8i_enc.h"
struct __anonstruct_47 {
   VP8Tokens *pages_ ;
   VP8Tokens **last_page_ ;
   uint16_t *tokens_ ;
   int left_ ;
   int page_size_ ;
   int error_ ;
};
#line 321 "../../src/enc/vp8i_enc.h"
typedef struct __anonstruct_47 VP8TBuffer;
#line 346 "../../src/enc/vp8i_enc.h"
struct VP8Encoder {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   VP8EncFilterHeader filter_hdr_ ;
   VP8EncSegmentHeader segment_hdr_ ;
   int profile_ ;
   int mb_w_ ;
   int mb_h_ ;
   int preds_w_ ;
   int num_parts_ ;
   VP8BitWriter bw_ ;
   VP8BitWriter parts_[8] ;
   VP8TBuffer tokens_ ;
   int percent_ ;
   int has_alpha_ ;
   uint8_t *alpha_data_ ;
   uint32_t alpha_data_size_ ;
   WebPWorker alpha_worker_ ;
   VP8SegmentInfo dqm_[4] ;
   int base_quant_ ;
   int alpha_ ;
   int uv_alpha_ ;
   int dq_y1_dc_ ;
   int dq_y2_dc_ ;
   int dq_y2_ac_ ;
   int dq_uv_dc_ ;
   int dq_uv_ac_ ;
   VP8EncProba proba_ ;
   uint64_t sse_[4] ;
   uint64_t sse_count_ ;
   int coded_size_ ;
   int residual_bytes_[3][4] ;
   int block_count_[3] ;
   int method_ ;
   VP8RDLevel rd_opt_level_ ;
   int max_i4_header_bits_ ;
   int mb_header_limit_ ;
   int thread_level_ ;
   int do_search_ ;
   int use_tokens_ ;
   VP8MBInfo *mb_info_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   LFStats *lf_stats_ ;
   DError *top_derr_ ;
};
#line 29 "../../src/webp/decode.h"
struct WebPRGBABuffer ;
#line 29 "../../src/webp/decode.h"
typedef struct WebPRGBABuffer WebPRGBABuffer;
#line 30
struct WebPYUVABuffer ;
#line 30 "../../src/webp/decode.h"
typedef struct WebPYUVABuffer WebPYUVABuffer;
#line 31
struct WebPDecBuffer ;
#line 31 "../../src/webp/decode.h"
typedef struct WebPDecBuffer WebPDecBuffer;
#line 32
struct WebPIDecoder ;
#line 32 "../../src/webp/decode.h"
typedef struct WebPIDecoder WebPIDecoder;
#line 33
struct WebPBitstreamFeatures ;
#line 33 "../../src/webp/decode.h"
typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
#line 34
struct WebPDecoderOptions ;
#line 34 "../../src/webp/decode.h"
typedef struct WebPDecoderOptions WebPDecoderOptions;
#line 35
struct WebPDecoderConfig ;
#line 35 "../../src/webp/decode.h"
typedef struct WebPDecoderConfig WebPDecoderConfig;
#line 150
enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13
} ;
#line 163 "../../src/webp/decode.h"
typedef enum WEBP_CSP_MODE WEBP_CSP_MODE;
#line 184 "../../src/webp/decode.h"
struct WebPRGBABuffer {
   uint8_t *rgba ;
   int stride ;
   size_t size ;
};
#line 190 "../../src/webp/decode.h"
struct WebPYUVABuffer {
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   uint8_t *a ;
   int y_stride ;
   int u_stride ;
   int v_stride ;
   int a_stride ;
   size_t y_size ;
   size_t u_size ;
   size_t v_size ;
   size_t a_size ;
};
#line 208 "../../src/webp/decode.h"
union __anonunion_48 {
   WebPRGBABuffer RGBA ;
   WebPYUVABuffer YUVA ;
};
#line 201 "../../src/webp/decode.h"
struct WebPDecBuffer {
   WEBP_CSP_MODE colorspace ;
   int width ;
   int height ;
   int is_external_memory ;
   union __anonunion_48 u ;
   uint32_t pad[4] ;
   uint8_t *private_memory ;
};
#line 235
enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7
} ;
#line 244 "../../src/webp/decode.h"
typedef enum VP8StatusCode VP8StatusCode;
#line 413 "../../src/webp/decode.h"
struct WebPBitstreamFeatures {
   int width ;
   int height ;
   int has_alpha ;
   int has_animation ;
   int format ;
   uint32_t pad[5] ;
};
#line 446 "../../src/webp/decode.h"
struct WebPDecoderOptions {
   int bypass_filtering ;
   int no_fancy_upsampling ;
   int use_cropping ;
   int crop_left ;
   int crop_top ;
   int crop_width ;
   int crop_height ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   int use_threads ;
   int dithering_strength ;
   int flip ;
   int alpha_dithering_strength ;
   uint32_t pad[5] ;
};
#line 464 "../../src/webp/decode.h"
struct WebPDecoderConfig {
   WebPBitstreamFeatures input ;
   WebPDecBuffer output ;
   WebPDecoderOptions options ;
};
#line 42 "../../src/dec/vp8_dec.h"
struct VP8Io ;
#line 42 "../../src/dec/vp8_dec.h"
typedef struct VP8Io VP8Io;
#line 43 "../../src/dec/vp8_dec.h"
typedef int (*VP8IoPutHook)(VP8Io * );
#line 44 "../../src/dec/vp8_dec.h"
typedef int (*VP8IoSetupHook)(VP8Io * );
#line 45 "../../src/dec/vp8_dec.h"
typedef void (*VP8IoTeardownHook)(VP8Io * );
#line 47 "../../src/dec/vp8_dec.h"
struct VP8Io {
   int width ;
   int height ;
   int mb_y ;
   int mb_w ;
   int mb_h ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   void *opaque ;
   VP8IoPutHook put ;
   VP8IoSetupHook setup ;
   VP8IoTeardownHook teardown ;
   int fancy_upsampling ;
   size_t data_size ;
   uint8_t *data ;
   int bypass_filtering ;
   int use_cropping ;
   int crop_left ;
   int crop_right ;
   int crop_top ;
   int crop_bottom ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   uint8_t *a ;
};
#line 123
struct VP8Decoder ;
#line 123 "../../src/dec/vp8_dec.h"
typedef struct VP8Decoder VP8Decoder;
#line 48 "../../src/dsp/yuv.h"
enum __anonenum__49 {
    YUV_FIX = 16,
    YUV_HALF = 32768,
    YUV_FIX2 = 6,
    YUV_MASK2 = 16383
} ;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__53 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__53 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_54 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_54 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_55 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_55 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_56 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_56 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_57 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_57 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_58 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_58 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 18 "../../src/dec/common_dec.h"
enum __anonenum__71 {
    B_DC_PRED___0 = 0,
    B_TM_PRED___0 = 1,
    B_VE_PRED___0 = 2,
    B_HE_PRED___0 = 3,
    B_RD_PRED___0 = 4,
    B_VR_PRED___0 = 5,
    B_LD_PRED___0 = 6,
    B_VL_PRED___0 = 7,
    B_HD_PRED___0 = 8,
    B_HU_PRED___0 = 9,
    NUM_BMODES___0 = 10,
    DC_PRED___0 = 0,
    V_PRED___0 = 2,
    H_PRED___0 = 3,
    TM_PRED___0 = 1,
    B_PRED___0 = 10,
    NUM_PRED_MODES___0 = 4,
    B_DC_PRED_NOTOP___0 = 4,
    B_DC_PRED_NOLEFT___0 = 5,
    B_DC_PRED_NOTOPLEFT___0 = 6,
    NUM_B_DC_MODES___0 = 7
} ;
#line 42
enum __anonenum__72 {
    MB_FEATURE_TREE_PROBS___0 = 3,
    NUM_MB_SEGMENTS___0 = 4,
    NUM_REF_LF_DELTAS___0 = 4,
    NUM_MODE_LF_DELTAS___0 = 4,
    MAX_NUM_PARTITIONS___0 = 8,
    NUM_TYPES___0 = 4,
    NUM_BANDS___0 = 8,
    NUM_CTX___0 = 3,
    NUM_PROBAS___0 = 11
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__74 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 43
enum __anonenum__75 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 65
enum __anonenum__76 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 77
enum __anonenum__77 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 100
enum __anonenum__78 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 120
enum __anonenum__79 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 130
enum __anonenum__80 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 140
enum __anonenum__81 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 164
enum __anonenum__82 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 171
enum __anonenum__83 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 37 "../../src/enc/vp8i_enc.h"
enum __anonenum__94 {
    MAX_LF_LEVELS___0 = 64,
    MAX_VARIABLE_LEVEL___0 = 67,
    MAX_LEVEL___0 = 2047
} ;
#line 29 "../../src/utils/rescaler_utils.h"
typedef uint32_t rescaler_t;
#line 30 "../../src/utils/rescaler_utils.h"
typedef struct WebPRescaler WebPRescaler;
#line 31 "../../src/utils/rescaler_utils.h"
struct WebPRescaler {
   int x_expand ;
   int y_expand ;
   int num_channels ;
   uint32_t fx_scale ;
   uint32_t fy_scale ;
   uint32_t fxy_scale ;
   int y_accum ;
   int y_add ;
   int y_sub ;
   int x_add ;
   int x_sub ;
   int src_width ;
   int src_height ;
   int dst_width ;
   int dst_height ;
   int src_y ;
   int dst_y ;
   uint8_t *dst ;
   int dst_stride ;
   rescaler_t *irow ;
   rescaler_t *frow ;
};
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__104 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__124 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 43
enum __anonenum__125 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 65
enum __anonenum__126 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 77
enum __anonenum__127 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 100
enum __anonenum__128 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 120
enum __anonenum__129 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 130
enum __anonenum__130 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 140
enum __anonenum__131 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 164
enum __anonenum__132 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 171
enum __anonenum__133 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 18 "../../src/dec/common_dec.h"
enum __anonenum__140 {
    B_DC_PRED___1 = 0,
    B_TM_PRED___1 = 1,
    B_VE_PRED___1 = 2,
    B_HE_PRED___1 = 3,
    B_RD_PRED___1 = 4,
    B_VR_PRED___1 = 5,
    B_LD_PRED___1 = 6,
    B_VL_PRED___1 = 7,
    B_HD_PRED___1 = 8,
    B_HU_PRED___1 = 9,
    NUM_BMODES___1 = 10,
    DC_PRED___1 = 0,
    V_PRED___1 = 2,
    H_PRED___1 = 3,
    TM_PRED___1 = 1,
    B_PRED___1 = 10,
    NUM_PRED_MODES___1 = 4,
    B_DC_PRED_NOTOP___1 = 4,
    B_DC_PRED_NOLEFT___1 = 5,
    B_DC_PRED_NOTOPLEFT___1 = 6,
    NUM_B_DC_MODES___1 = 7
} ;
#line 42
enum __anonenum__141 {
    MB_FEATURE_TREE_PROBS___1 = 3,
    NUM_MB_SEGMENTS___1 = 4,
    NUM_REF_LF_DELTAS___1 = 4,
    NUM_MODE_LF_DELTAS___1 = 4,
    MAX_NUM_PARTITIONS___1 = 8,
    NUM_TYPES___1 = 4,
    NUM_BANDS___1 = 8,
    NUM_CTX___1 = 3,
    NUM_PROBAS___1 = 11
} ;
#line 37 "../../src/enc/vp8i_enc.h"
enum __anonenum__146 {
    MAX_LF_LEVELS___1 = 64,
    MAX_VARIABLE_LEVEL___1 = 67,
    MAX_LEVEL___1 = 2047
} ;
#line 25 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
typedef double (*AccumulateFunc)(uint8_t * , int  , uint8_t * , int  , int  , int  );
#line 18 "../../src/dec/common_dec.h"
enum __anonenum__175 {
    B_DC_PRED___2 = 0,
    B_TM_PRED___2 = 1,
    B_VE_PRED___2 = 2,
    B_HE_PRED___2 = 3,
    B_RD_PRED___2 = 4,
    B_VR_PRED___2 = 5,
    B_LD_PRED___2 = 6,
    B_VL_PRED___2 = 7,
    B_HD_PRED___2 = 8,
    B_HU_PRED___2 = 9,
    NUM_BMODES___2 = 10,
    DC_PRED___2 = 0,
    V_PRED___2 = 2,
    H_PRED___2 = 3,
    TM_PRED___2 = 1,
    B_PRED___2 = 10,
    NUM_PRED_MODES___2 = 4,
    B_DC_PRED_NOTOP___2 = 4,
    B_DC_PRED_NOLEFT___2 = 5,
    B_DC_PRED_NOTOPLEFT___2 = 6,
    NUM_B_DC_MODES___2 = 7
} ;
#line 42
enum __anonenum__176 {
    MB_FEATURE_TREE_PROBS___2 = 3,
    NUM_MB_SEGMENTS___2 = 4,
    NUM_REF_LF_DELTAS___2 = 4,
    NUM_MODE_LF_DELTAS___2 = 4,
    MAX_NUM_PARTITIONS___2 = 8,
    NUM_TYPES___2 = 4,
    NUM_BANDS___2 = 8,
    NUM_CTX___2 = 3,
    NUM_PROBAS___2 = 11
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__180 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 43
enum __anonenum__181 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 65
enum __anonenum__182 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 77
enum __anonenum__183 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 100
enum __anonenum__184 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 120
enum __anonenum__185 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 130
enum __anonenum__186 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 140
enum __anonenum__187 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 164
enum __anonenum__188 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 171
enum __anonenum__189 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 37 "../../src/enc/vp8i_enc.h"
enum __anonenum__200 {
    MAX_LF_LEVELS___2 = 64,
    MAX_VARIABLE_LEVEL___2 = 67,
    MAX_LEVEL___2 = 2047
} ;
#line 238 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
typedef int (*Importer)(WebPPicture * const   , uint8_t * const   , int  );
#line 853 "/usr/include/math.h"
enum __anonenum__210 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 75 "../../sharpyuv/sharpyuv.h"
struct __anonstruct_211 {
   int rgb_to_y[4] ;
   int rgb_to_u[4] ;
   int rgb_to_v[4] ;
};
#line 79 "../../sharpyuv/sharpyuv.h"
typedef struct __anonstruct_211 SharpYuvConversionMatrix;
#line 81
struct SharpYuvOptions ;
#line 81 "../../sharpyuv/sharpyuv.h"
typedef struct SharpYuvOptions SharpYuvOptions;
#line 85
enum SharpYuvTransferFunctionType {
    kSharpYuvTransferFunctionBt709 = 1,
    kSharpYuvTransferFunctionBt470M = 4,
    kSharpYuvTransferFunctionBt470Bg = 5,
    kSharpYuvTransferFunctionBt601 = 6,
    kSharpYuvTransferFunctionSmpte240 = 7,
    kSharpYuvTransferFunctionLinear = 8,
    kSharpYuvTransferFunctionLog100 = 9,
    kSharpYuvTransferFunctionLog100_Sqrt10 = 10,
    kSharpYuvTransferFunctionIec61966 = 11,
    kSharpYuvTransferFunctionBt1361 = 12,
    kSharpYuvTransferFunctionSrgb = 13,
    kSharpYuvTransferFunctionBt2020_10Bit = 14,
    kSharpYuvTransferFunctionBt2020_12Bit = 15,
    kSharpYuvTransferFunctionSmpte2084 = 16,
    kSharpYuvTransferFunctionSmpte428 = 17,
    kSharpYuvTransferFunctionHlg = 18,
    kSharpYuvTransferFunctionNum = 19
} ;
#line 106 "../../sharpyuv/sharpyuv.h"
typedef enum SharpYuvTransferFunctionType SharpYuvTransferFunctionType;
#line 142 "../../sharpyuv/sharpyuv.h"
struct SharpYuvOptions {
   SharpYuvConversionMatrix *yuv_matrix ;
   SharpYuvTransferFunctionType transfer_type ;
};
#line 22 "../../sharpyuv/sharpyuv_csp.h"
enum __anonenum__212 {
    kSharpYuvRangeFull = 0,
    kSharpYuvRangeLimited = 1
} ;
#line 25 "../../sharpyuv/sharpyuv_csp.h"
typedef enum __anonenum__212 SharpYuvRange;
#line 28 "../../sharpyuv/sharpyuv_csp.h"
struct __anonstruct_213 {
   float kr ;
   float kb ;
   int bit_depth ;
   SharpYuvRange range ;
};
#line 35 "../../sharpyuv/sharpyuv_csp.h"
typedef struct __anonstruct_213 SharpYuvColorSpace;
#line 43
enum __anonenum__214 {
    kSharpYuvMatrixWebp = 0,
    kSharpYuvMatrixRec601Limited = 1,
    kSharpYuvMatrixRec601Full = 2,
    kSharpYuvMatrixRec709Limited = 3,
    kSharpYuvMatrixRec709Full = 4,
    kSharpYuvMatrixNum = 5
} ;
#line 50 "../../sharpyuv/sharpyuv_csp.h"
typedef enum __anonenum__214 SharpYuvMatrixType;
#line 18 "../../src/dec/common_dec.h"
enum __anonenum__215 {
    B_DC_PRED___3 = 0,
    B_TM_PRED___3 = 1,
    B_VE_PRED___3 = 2,
    B_HE_PRED___3 = 3,
    B_RD_PRED___3 = 4,
    B_VR_PRED___3 = 5,
    B_LD_PRED___3 = 6,
    B_VL_PRED___3 = 7,
    B_HD_PRED___3 = 8,
    B_HU_PRED___3 = 9,
    NUM_BMODES___3 = 10,
    DC_PRED___3 = 0,
    V_PRED___3 = 2,
    H_PRED___3 = 3,
    TM_PRED___3 = 1,
    B_PRED___3 = 10,
    NUM_PRED_MODES___3 = 4,
    B_DC_PRED_NOTOP___3 = 4,
    B_DC_PRED_NOLEFT___3 = 5,
    B_DC_PRED_NOTOPLEFT___3 = 6,
    NUM_B_DC_MODES___3 = 7
} ;
#line 42
enum __anonenum__216 {
    MB_FEATURE_TREE_PROBS___3 = 3,
    NUM_MB_SEGMENTS___3 = 4,
    NUM_REF_LF_DELTAS___3 = 4,
    NUM_MODE_LF_DELTAS___3 = 4,
    MAX_NUM_PARTITIONS___3 = 8,
    NUM_TYPES___3 = 4,
    NUM_BANDS___3 = 8,
    NUM_CTX___3 = 3,
    NUM_PROBAS___3 = 11
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__220 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 43
enum __anonenum__221 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 65
enum __anonenum__222 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 77
enum __anonenum__223 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 100
enum __anonenum__224 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 120
enum __anonenum__225 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 130
enum __anonenum__226 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 140
enum __anonenum__227 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 164
enum __anonenum__228 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 171
enum __anonenum__229 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 37 "../../src/enc/vp8i_enc.h"
enum __anonenum__240 {
    MAX_LF_LEVELS___3 = 64,
    MAX_VARIABLE_LEVEL___3 = 67,
    MAX_LEVEL___3 = 2047
} ;
#line 27 "../../src/utils/random_utils.h"
struct __anonstruct_250 {
   int index1_ ;
   int index2_ ;
   uint32_t tab_[55] ;
   int amp_ ;
};
#line 31 "../../src/utils/random_utils.h"
typedef struct __anonstruct_250 VP8Random;
#line 55 "../../src/webp/format_constants.h"
enum __anonenum__252 {
    PREDICTOR_TRANSFORM = 0,
    CROSS_COLOR_TRANSFORM = 1,
    SUBTRACT_GREEN_TRANSFORM = 2,
    COLOR_INDEXING_TRANSFORM = 3
} ;
#line 60 "../../src/webp/format_constants.h"
typedef enum __anonenum__252 VP8LImageTransformType;
#line 32 "../../src/enc/backward_references_enc.h"
enum Mode {
    kLiteral = 0,
    kCacheIdx = 1,
    kCopy = 2,
    kNone = 3
} ;
#line 39 "../../src/enc/backward_references_enc.h"
struct __anonstruct_253 {
   uint8_t mode ;
   uint16_t len ;
   uint32_t argb_or_distance ;
};
#line 44 "../../src/enc/backward_references_enc.h"
typedef struct __anonstruct_253 PixOrCopy;
#line 122
struct VP8LHashChain ;
#line 122 "../../src/enc/backward_references_enc.h"
typedef struct VP8LHashChain VP8LHashChain;
#line 123 "../../src/enc/backward_references_enc.h"
struct VP8LHashChain {
   uint32_t *offset_length_ ;
   int size_ ;
};
#line 168
struct PixOrCopyBlock ;
#line 168 "../../src/enc/backward_references_enc.h"
typedef struct PixOrCopyBlock PixOrCopyBlock;
#line 169
struct VP8LBackwardRefs ;
#line 169 "../../src/enc/backward_references_enc.h"
typedef struct VP8LBackwardRefs VP8LBackwardRefs;
#line 172 "../../src/enc/backward_references_enc.h"
struct VP8LBackwardRefs {
   int block_size_ ;
   int error_ ;
   PixOrCopyBlock *refs_ ;
   PixOrCopyBlock **tail_ ;
   PixOrCopyBlock *free_blocks_ ;
   PixOrCopyBlock *last_block_ ;
};
#line 188 "../../src/enc/backward_references_enc.h"
struct __anonstruct_254 {
   PixOrCopy *cur_pos ;
   PixOrCopyBlock *cur_block_ ;
   PixOrCopy *last_pos_ ;
};
#line 194 "../../src/enc/backward_references_enc.h"
typedef struct __anonstruct_254 VP8LRefsCursor;
#line 214
enum VP8LLZ77Type {
    kLZ77Standard = 1,
    kLZ77RLE = 2,
    kLZ77Box = 4
} ;
#line 31 "../../src/enc/histogram_enc.h"
struct __anonstruct_255 {
   uint32_t *literal_ ;
   uint32_t red_[256] ;
   uint32_t blue_[256] ;
   uint32_t alpha_[256] ;
   uint32_t distance_[40] ;
   int palette_code_bits_ ;
   uint32_t trivial_symbol_ ;
   float bit_cost_ ;
   float literal_cost_ ;
   float red_cost_ ;
   float blue_cost_ ;
   uint8_t is_used_[5] ;
};
#line 48 "../../src/enc/histogram_enc.h"
typedef struct __anonstruct_255 VP8LHistogram;
#line 52 "../../src/enc/histogram_enc.h"
struct __anonstruct_256 {
   int size ;
   int max_size ;
   VP8LHistogram **histograms ;
};
#line 56 "../../src/enc/histogram_enc.h"
typedef struct __anonstruct_256 VP8LHistogramSet;
#line 31 "../../src/dsp/lossless.h"
typedef uint32_t (*VP8LPredictorFunc)(uint32_t * const   , uint32_t * const   );
#line 65 "../../src/dsp/lossless.h"
typedef void (*VP8LPredictorAddSubFunc)(uint32_t * , uint32_t * , int  , uint32_t * );
#line 71 "../../src/dsp/lossless.h"
typedef void (*VP8LProcessDecBlueAndRedFunc)(uint32_t * , int  , uint32_t * );
#line 75 "../../src/dsp/lossless.h"
struct __anonstruct_257 {
   uint8_t green_to_red_ ;
   uint8_t green_to_blue_ ;
   uint8_t red_to_blue_ ;
};
#line 81 "../../src/dsp/lossless.h"
typedef struct __anonstruct_257 VP8LMultipliers;
#line 82 "../../src/dsp/lossless.h"
typedef void (*VP8LTransformColorInverseFunc)(VP8LMultipliers * const   , uint32_t * ,
                                              int  , uint32_t * );
#line 87
struct VP8LTransform ;
#line 98 "../../src/dsp/lossless.h"
typedef void (*VP8LConvertFunc)(uint32_t * , int  , uint8_t * );
#line 110 "../../src/dsp/lossless.h"
typedef void (*VP8LMapARGBFunc)(uint32_t * , uint32_t * const   , uint32_t * , int  ,
                                int  , int  );
#line 114 "../../src/dsp/lossless.h"
typedef void (*VP8LMapAlphaFunc)(uint8_t * , uint32_t * const   , uint8_t * , int  ,
                                 int  , int  );
#line 150 "../../src/dsp/lossless.h"
typedef void (*VP8LProcessEncBlueAndRedFunc)(uint32_t * , int  );
#line 152 "../../src/dsp/lossless.h"
typedef void (*VP8LTransformColorFunc)(VP8LMultipliers * const   , uint32_t * , int  );
#line 155 "../../src/dsp/lossless.h"
typedef void (*VP8LCollectColorBlueTransformsFunc)(uint32_t * , int  , int  , int  ,
                                                   int  , int  , int [] );
#line 161 "../../src/dsp/lossless.h"
typedef void (*VP8LCollectColorRedTransformsFunc)(uint32_t * , int  , int  , int  ,
                                                  int  , int [] );
#line 185 "../../src/dsp/lossless.h"
typedef uint32_t (*VP8LCostFunc)(uint32_t * , int  );
#line 186 "../../src/dsp/lossless.h"
typedef uint32_t (*VP8LCostCombinedFunc)(uint32_t * , uint32_t * , int  );
#line 188 "../../src/dsp/lossless.h"
typedef float (*VP8LCombinedShannonEntropyFunc)(int const   [256] , int const   [256] );
#line 195 "../../src/dsp/lossless.h"
struct __anonstruct_258 {
   int counts[2] ;
   int streaks[2][2] ;
};
#line 198 "../../src/dsp/lossless.h"
typedef struct __anonstruct_258 VP8LStreaks;
#line 200 "../../src/dsp/lossless.h"
struct __anonstruct_259 {
   float entropy ;
   uint32_t sum ;
   int nonzeros ;
   uint32_t max_val ;
   uint32_t nonzero_code ;
};
#line 206 "../../src/dsp/lossless.h"
typedef struct __anonstruct_259 VP8LBitEntropy;
#line 213 "../../src/dsp/lossless.h"
typedef void (*VP8LGetCombinedEntropyUnrefinedFunc)(uint32_t [] , uint32_t [] , int  ,
                                                    VP8LBitEntropy * const   , VP8LStreaks * const   );
#line 219 "../../src/dsp/lossless.h"
typedef void (*VP8LGetEntropyUnrefinedFunc)(uint32_t [] , int  , VP8LBitEntropy * const   ,
                                            VP8LStreaks * const   );
#line 227 "../../src/dsp/lossless.h"
typedef void (*VP8LAddVectorFunc)(uint32_t * , uint32_t * , uint32_t * , int  );
#line 230 "../../src/dsp/lossless.h"
typedef void (*VP8LAddVectorEqFunc)(uint32_t * , uint32_t * , int  );
#line 239 "../../src/dsp/lossless.h"
typedef int (*VP8LVectorMismatchFunc)(uint32_t * const   , uint32_t * const   , int  );
#line 244 "../../src/dsp/lossless.h"
typedef void (*VP8LBundleColorMapFunc)(uint8_t * const   , int  , int  , uint32_t * );
#line 48 "../../src/dsp/yuv.h"
enum __anonenum__260 {
    YUV_FIX___0 = 16,
    YUV_HALF___0 = 32768,
    YUV_FIX2___0 = 6,
    YUV_MASK2___0 = 16383
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_263 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_262 {
   int __count ;
   union __anonunion_263 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_262 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 29 "../src/webp/mux_types.h"
struct WebPData ;
#line 29 "../src/webp/mux_types.h"
typedef struct WebPData WebPData;
#line 32
enum WebPFeatureFlags {
    ANIMATION_FLAG = 2,
    XMP_FLAG = 4,
    EXIF_FLAG = 8,
    ALPHA_FLAG = 16,
    ICCP_FLAG = 32,
    ALL_VALID_FLAGS = 62
} ;
#line 40 "../src/webp/mux_types.h"
typedef enum WebPFeatureFlags WebPFeatureFlags;
#line 44
enum WebPMuxAnimDispose {
    WEBP_MUX_DISPOSE_NONE = 0,
    WEBP_MUX_DISPOSE_BACKGROUND = 1
} ;
#line 47 "../src/webp/mux_types.h"
typedef enum WebPMuxAnimDispose WebPMuxAnimDispose;
#line 51
enum WebPMuxAnimBlend {
    WEBP_MUX_BLEND = 0,
    WEBP_MUX_NO_BLEND = 1
} ;
#line 54 "../src/webp/mux_types.h"
typedef enum WebPMuxAnimBlend WebPMuxAnimBlend;
#line 59 "../src/webp/mux_types.h"
struct WebPData {
   uint8_t *bytes ;
   size_t size ;
};
#line 47 "/doner/libwebp/libwebp-31bea324/examples/../examples/example_util.h"
struct __anonstruct_284 {
   int argc_ ;
   char const   **argv_ ;
   WebPData argv_data_ ;
   int own_argv_ ;
};
#line 52 "/doner/libwebp/libwebp-31bea324/examples/../examples/example_util.h"
typedef struct __anonstruct_284 CommandLineArguments;
#line 22 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./metadata.h"
struct MetadataPayload {
   uint8_t *bytes ;
   size_t size ;
};
#line 25 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./metadata.h"
typedef struct MetadataPayload MetadataPayload;
#line 27 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./metadata.h"
struct Metadata {
   MetadataPayload exif ;
   MetadataPayload iccp ;
   MetadataPayload xmp ;
};
#line 31 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./metadata.h"
typedef struct Metadata Metadata;
#line 35 "/doner/libwebp/libwebp-31bea324/examples/../imageio/image_dec.h"
enum __anonenum__286 {
    WEBP_PNG_FORMAT = 0,
    WEBP_JPEG_FORMAT = 1,
    WEBP_TIFF_FORMAT = 2,
    WEBP_WEBP_FORMAT = 3,
    WEBP_PNM_FORMAT = 4,
    WEBP_UNSUPPORTED_FORMAT = 5
} ;
#line 42 "/doner/libwebp/libwebp-31bea324/examples/../imageio/image_dec.h"
typedef enum __anonenum__286 WebPInputFileFormat;
#line 53 "/doner/libwebp/libwebp-31bea324/examples/../imageio/image_dec.h"
typedef int (*WebPImageReader)(uint8_t * const   , size_t  , struct WebPPicture * const   ,
                               int  , struct Metadata * const   );
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 45 "/doner/libwebp/libwebp-31bea324/examples/./stopwatch.h"
typedef struct timeval Stopwatch;
#line 345 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
enum __anonenum__288 {
    METADATA_EXIF = 1,
    METADATA_ICC = 2,
    METADATA_XMP = 4,
    METADATA_ALL = 7
} ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 63 "../../src/webp/types.h"
extern void *WebPMalloc(size_t size ) ;
#line 66
extern void WebPFree(void *ptr ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 77
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 207
extern void pthread_exit(void *__retval ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 247
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 251
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 254
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 263
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 266
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 270
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 281
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 286
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 302
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 307
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 311
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 316
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 322
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 327
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 331
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 339
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 351
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 357
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 365
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 405
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 410
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 416
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 470
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 482
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 486
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 489
extern int pthread_cancel(pthread_t __th ) ;
#line 494
extern void pthread_testcancel(void) ;
#line 656
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 668
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 719
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 734
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 743
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 761
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 768
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 776
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 789
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 793
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 797
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 803
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 809
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 816
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 821
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 828
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 833
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 839
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 845
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 871
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 876
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 880
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 884
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 889
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 902
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 911
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 931
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 945
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 950
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 956
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 978
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 997
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1020
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1024
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1028
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1034
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1039
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1045
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1056
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1060
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1064
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1068
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1072
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1080
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1090
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1095
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1099
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1109
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1123
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1128
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1131
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1134
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1140
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1157
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1165
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1165 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1167
  return (__thread1 == __thread2);
}
}
#line 67 "../../src/dsp/dsp.h"
extern VP8Idct VP8ITransform ;
#line 68
extern VP8Fdct VP8FTransform ;
#line 69
extern VP8Fdct VP8FTransform2 ;
#line 70
extern VP8WHT VP8FTransformWHT ;
#line 76
extern VP8Intra4Preds VP8EncPredLuma4 ;
#line 77
extern VP8IntraPreds VP8EncPredLuma16 ;
#line 78
extern VP8IntraPreds VP8EncPredChroma8 ;
#line 81
extern VP8Metric VP8SSE16x16 ;
#line 81
extern VP8Metric VP8SSE16x8 ;
#line 81
extern VP8Metric VP8SSE8x8 ;
#line 81
extern VP8Metric VP8SSE4x4 ;
#line 86
extern VP8WMetric VP8TDisto4x4 ;
#line 86
extern VP8WMetric VP8TDisto16x16 ;
#line 91
extern VP8MeanMetric VP8Mean16x4 ;
#line 94
extern VP8BlockCopy VP8Copy4x4 ;
#line 95
extern VP8BlockCopy VP8Copy16x8 ;
#line 104
extern VP8QuantizeBlock VP8EncQuantizeBlock ;
#line 105
extern VP8Quantize2Blocks VP8EncQuantize2Blocks ;
#line 110
extern VP8QuantizeBlockWHT VP8EncQuantizeBlockWHT ;
#line 112
extern int const   VP8DspScan[24] ;
#line 124
extern VP8CHisto VP8CollectHistogram ;
#line 126
void VP8SetHistogramData(int const   distribution[32] , VP8Histogram * const  histo ) ;
#line 130
void VP8EncDspInit(void) ;
#line 135
extern uint16_t VP8EntropyCost[256] ;
#line 137
extern uint16_t VP8LevelFixedCosts[2048] ;
#line 138
extern uint8_t VP8EncBands[17] ;
#line 143
extern VP8SetResidualCoeffsFunc VP8SetResidualCoeffs ;
#line 148
extern VP8GetResidualCostFunc VP8GetResidualCost ;
#line 151
void VP8EncDspCostInit(void) ;
#line 165
double VP8SSIMFromStats(VP8DistoStats * const  stats ) ;
#line 166
double VP8SSIMFromStatsClipped(VP8DistoStats * const  stats ) ;
#line 180
extern VP8SSIMGetFunc VP8SSIMGet ;
#line 181
extern VP8SSIMGetClippedFunc VP8SSIMGetClipped ;
#line 187
extern VP8AccumulateSSEFunc VP8AccumulateSSE ;
#line 191
void VP8SSIMDspInit(void) ;
#line 199
extern VP8DecIdct2 VP8Transform ;
#line 200
extern VP8DecIdct VP8TransformAC3 ;
#line 201
extern VP8DecIdct VP8TransformUV ;
#line 202
extern VP8DecIdct VP8TransformDC ;
#line 203
extern VP8DecIdct VP8TransformDCUV ;
#line 204
extern VP8WHT VP8TransformWHT ;
#line 209
extern VP8PredFunc VP8PredLuma16[] ;
#line 210
extern VP8PredFunc VP8PredChroma8[] ;
#line 211
extern VP8PredFunc VP8PredLuma4[] ;
#line 214
extern int8_t * const  VP8ksclip1 ;
#line 215
extern int8_t * const  VP8ksclip2 ;
#line 216
extern uint8_t * const  VP8kclip1 ;
#line 217
extern uint8_t * const  VP8kabs0 ;
#line 219
void VP8InitClipTables(void) ;
#line 223
extern VP8SimpleFilterFunc VP8SimpleVFilter16 ;
#line 224
extern VP8SimpleFilterFunc VP8SimpleHFilter16 ;
#line 225
extern VP8SimpleFilterFunc VP8SimpleVFilter16i ;
#line 226
extern VP8SimpleFilterFunc VP8SimpleHFilter16i ;
#line 234
extern VP8LumaFilterFunc VP8VFilter16 ;
#line 235
extern VP8LumaFilterFunc VP8HFilter16 ;
#line 236
extern VP8ChromaFilterFunc VP8VFilter8 ;
#line 237
extern VP8ChromaFilterFunc VP8HFilter8 ;
#line 240
extern VP8LumaFilterFunc VP8VFilter16i ;
#line 241
extern VP8LumaFilterFunc VP8HFilter16i ;
#line 242
extern VP8ChromaFilterFunc VP8VFilter8i ;
#line 243
extern VP8ChromaFilterFunc VP8HFilter8i ;
#line 251
extern void (*VP8DitherCombine8x8)(uint8_t * , uint8_t * , int  ) ;
#line 255
void VP8DspInit(void) ;
#line 273
extern WebPUpsampleLinePairFunc WebPUpsamplers[] ;
#line 282
void WebPSamplerProcessPlane(uint8_t *y , int y_stride , uint8_t *u , uint8_t *v ,
                             int uv_stride , uint8_t *dst , int dst_stride , int width ,
                             int height , WebPSamplerRowFunc func ) ;
#line 288
extern WebPSamplerRowFunc WebPSamplers[] ;
#line 293
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) ;
#line 300
extern WebPYUV444Converter WebPYUV444Converters[] ;
#line 304
void WebPInitUpsamplers(void) ;
#line 306
void WebPInitSamplers(void) ;
#line 308
void WebPInitYUV444Converters(void) ;
#line 314
extern void (*WebPConvertARGBToY)(uint32_t * , uint8_t * , int  ) ;
#line 318
extern void (*WebPConvertARGBToUV)(uint32_t * , uint8_t * , uint8_t * , int  , int  ) ;
#line 322
extern void (*WebPConvertRGBA32ToUV)(uint16_t * , uint8_t * , uint8_t * , int  ) ;
#line 326
extern void (*WebPConvertRGB24ToY)(uint8_t * , uint8_t * , int  ) ;
#line 327
extern void (*WebPConvertBGR24ToY)(uint8_t * , uint8_t * , int  ) ;
#line 330
extern void WebPConvertARGBToUV_C(uint32_t *argb , uint8_t *u , uint8_t *v , int src_width ,
                                  int do_store ) ;
#line 332
extern void WebPConvertRGBA32ToUV_C(uint16_t *rgb , uint8_t *u , uint8_t *v , int width ) ;
#line 336
void WebPInitConvertARGBToYUV(void) ;
#line 349
extern WebPRescalerImportRowFunc WebPRescalerImportRowExpand ;
#line 350
extern WebPRescalerImportRowFunc WebPRescalerImportRowShrink ;
#line 356
extern WebPRescalerExportRowFunc WebPRescalerExportRowExpand ;
#line 357
extern WebPRescalerExportRowFunc WebPRescalerExportRowShrink ;
#line 360
extern void WebPRescalerImportRowExpand_C(struct WebPRescaler * const  wrk , uint8_t *src ) ;
#line 362
extern void WebPRescalerImportRowShrink_C(struct WebPRescaler * const  wrk , uint8_t *src ) ;
#line 364
extern void WebPRescalerExportRowExpand_C(struct WebPRescaler * const  wrk ) ;
#line 365
extern void WebPRescalerExportRowShrink_C(struct WebPRescaler * const  wrk ) ;
#line 368
extern void WebPRescalerImportRow(struct WebPRescaler * const  wrk , uint8_t *src ) ;
#line 371
extern void WebPRescalerExportRow(struct WebPRescaler * const  wrk ) ;
#line 374
void WebPRescalerDspInit(void) ;
#line 381
extern void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  ) ;
#line 385
extern void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  ) ;
#line 390
extern int (*WebPDispatchAlpha)(uint8_t * , int  , int  , int  , uint8_t * , int  ) ;
#line 396
extern void (*WebPDispatchAlphaToGreen)(uint8_t * , int  , int  , int  , uint32_t * ,
                                        int  ) ;
#line 404
extern int (*WebPExtractAlpha)(uint8_t * , int  , int  , int  , uint8_t * , int  ) ;
#line 411
extern void (*WebPExtractGreen)(uint32_t * , uint8_t * , int  ) ;
#line 418
extern void (*WebPMultARGBRow)(uint32_t * const   , int  , int  ) ;
#line 421
void WebPMultARGBRows(uint8_t *ptr , int stride , int width , int num_rows , int inverse ) ;
#line 425
extern void (*WebPMultRow)(uint8_t * const   , uint8_t * const   , int  , int  ) ;
#line 430
void WebPMultRows(uint8_t *ptr , int stride , uint8_t *alpha , int alpha_stride ,
                  int width , int num_rows , int inverse ) ;
#line 435
void WebPMultRow_C(uint8_t * const  ptr , uint8_t * const  alpha , int width , int inverse ) ;
#line 438
void WebPMultARGBRow_C(uint32_t * const  ptr , int width , int inverse ) ;
#line 450
extern void (*WebPPackRGB)(uint8_t * , uint8_t * , uint8_t * , int  , int  , uint32_t * ) ;
#line 456
extern int (*WebPHasAlpha8b)(uint8_t * , int  ) ;
#line 458
extern int (*WebPHasAlpha32b)(uint8_t * , int  ) ;
#line 460
extern void (*WebPAlphaReplace)(uint32_t * , int  , uint32_t  ) ;
#line 463
void WebPInitAlphaProcessing(void) ;
#line 490
extern WebPFilterFunc WebPFilters[4] ;
#line 495
extern WebPUnfilterFunc WebPUnfilters[4] ;
#line 498
void VP8FiltersInit(void) ;
#line 39 "../../src/utils/bit_writer_utils.h"
int VP8BitWriterInit(VP8BitWriter * const  bw , size_t expected_size ) ;
#line 41
uint8_t *VP8BitWriterFinish(VP8BitWriter * const  bw ) ;
#line 44
void VP8BitWriterWipeOut(VP8BitWriter * const  bw ) ;
#line 46
int VP8PutBit(VP8BitWriter * const  bw , int bit , int prob ) ;
#line 47
int VP8PutBitUniform(VP8BitWriter * const  bw , int bit ) ;
#line 48
void VP8PutBits(VP8BitWriter * const  bw , uint32_t value , int nb_bits ) ;
#line 49
void VP8PutSignedBits(VP8BitWriter * const  bw , int value , int nb_bits ) ;
#line 52
int VP8BitWriterAppend(VP8BitWriter * const  bw , uint8_t *data , size_t size ) ;
#line 56 "../../src/utils/bit_writer_utils.h"
__inline static uint64_t VP8BitWriterPos(VP8BitWriter *bw ) 
{ 
  uint64_t nb_bits ;

  {
#line 57
  nb_bits = (uint64_t )(8 + bw->nb_bits_);
#line 58
  return ((bw->pos_ + (unsigned long )bw->run_) * 8UL + nb_bits);
}
}
#line 62 "../../src/utils/bit_writer_utils.h"
__inline static uint8_t *VP8BitWriterBuf(VP8BitWriter *bw ) 
{ 


  {
#line 63
  return (bw->buf_);
}
}
#line 66 "../../src/utils/bit_writer_utils.h"
__inline static size_t VP8BitWriterSize(VP8BitWriter *bw ) 
{ 


  {
#line 67
  return (bw->pos_);
}
}
#line 103 "../../src/utils/bit_writer_utils.h"
__inline static size_t VP8LBitWriterNumBytes(VP8LBitWriter *bw ) 
{ 


  {
#line 104
  return ((size_t )((bw->cur_ - bw->buf_) + (long )((bw->used_ + 7) >> 3)));
}
}
#line 108
int VP8LBitWriterInit(VP8LBitWriter * const  bw , size_t expected_size ) ;
#line 110
int VP8LBitWriterClone(VP8LBitWriter * const  src , VP8LBitWriter * const  dst ) ;
#line 113
uint8_t *VP8LBitWriterFinish(VP8LBitWriter * const  bw ) ;
#line 115
void VP8LBitWriterWipeOut(VP8LBitWriter * const  bw ) ;
#line 117
void VP8LBitWriterReset(VP8LBitWriter * const  bw_init , VP8LBitWriter * const  bw ) ;
#line 120
void VP8LBitWriterSwap(VP8LBitWriter * const  src , VP8LBitWriter * const  dst ) ;
#line 123
void VP8LPutBitsFlushBits(VP8LBitWriter * const  bw ) ;
#line 126
void VP8LPutBitsInternal(VP8LBitWriter * const  bw , uint32_t bits , int n_bits ) ;
#line 133 "../../src/utils/bit_writer_utils.h"
__inline static void VP8LPutBits(VP8LBitWriter *bw , uint32_t bits , int n_bits ) 
{ 


  {
#line 135
  if (sizeof(vp8l_wtype_t ) == 4UL) {
#line 136
    if (n_bits > 0) {
#line 137
      if (bw->used_ >= 32) {
        {
#line 138
        VP8LPutBitsFlushBits(bw);
        }
      }
#line 140
      bw->bits_ |= (vp8l_atype_t )bits << bw->used_;
#line 141
      bw->used_ += n_bits;
    }
  } else {
    {
#line 144
    VP8LPutBitsInternal(bw, bits, n_bits);
    }
  }
  return;
}
}
#line 78 "../../src/utils/thread_utils.h"
extern int WebPSetWorkerInterface(WebPWorkerInterface * const  winterface ) ;
#line 82
extern WebPWorkerInterface *WebPGetWorkerInterface(void) ;
#line 43 "../../src/utils/utils.h"
__inline static int CheckSizeOverflow(uint64_t size ) 
{ 


  {
#line 44
  return (size == (size_t )size);
}
}
#line 53
extern void *WebPSafeMalloc(uint64_t nmemb , size_t size ) ;
#line 56
extern void *WebPSafeCalloc(uint64_t nmemb , size_t size ) ;
#line 59
extern void WebPSafeFree(void * const  ptr ) ;
#line 70 "../../src/utils/utils.h"
__inline static uint32_t WebPMemToUint32(uint8_t *ptr ) 
{ 
  uint32_t A ;

  {
  {
#line 72
  memcpy(& A, ptr, sizeof(A));
  }
#line 73
  return (A);
}
}
#line 76 "../../src/utils/utils.h"
__inline static int32_t WebPMemToInt32(uint8_t *ptr ) 
{ 
  uint32_t __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = WebPMemToUint32(ptr);
  }
#line 77
  return ((int32_t )__cil_tmp2);
}
}
#line 80 "../../src/utils/utils.h"
__inline static void WebPUint32ToMem(uint8_t *ptr , uint32_t val ) 
{ 


  {
  {
#line 81
  memcpy(ptr, & val, sizeof(val));
  }
  return;
}
}
#line 84 "../../src/utils/utils.h"
__inline static void WebPInt32ToMem(uint8_t *ptr , int val ) 
{ 


  {
  {
#line 85
  WebPUint32ToMem(ptr, (uint32_t )val);
  }
  return;
}
}
#line 92 "../../src/utils/utils.h"
__inline static int GetLE16(uint8_t *data ) 
{ 


  {
#line 93
  return ((int )((int )*(data + 0)) | ((int )*(data + 1) << 8));
}
}
#line 96 "../../src/utils/utils.h"
__inline static int GetLE24(uint8_t *data ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 97
  __cil_tmp2 = GetLE16(data);
  }
#line 97
  return (__cil_tmp2 | ((int )*(data + 2) << 16));
}
}
#line 100 "../../src/utils/utils.h"
__inline static uint32_t GetLE32(uint8_t *data ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 101
  __cil_tmp3 = GetLE16(data + 2);
  }
  {
#line 101
  __cil_tmp2 = GetLE16(data);
  }
#line 101
  return ((unsigned int )__cil_tmp2 | ((uint32_t )__cil_tmp3 << 16));
}
}
#line 105 "../../src/utils/utils.h"
__inline static void PutLE16(uint8_t *data , int val ) 
{ 


  {
#line 107
  *(data + 0) = (uint8_t )(val & 255);
#line 108
  *(data + 1) = (uint8_t )((val >> 8) & 255);
  return;
}
}
#line 111 "../../src/utils/utils.h"
__inline static void PutLE24(uint8_t *data , int val ) 
{ 


  {
  {
#line 113
  PutLE16(data, val & 65535);
#line 114
  *(data + 2) = (uint8_t )((val >> 16) & 255);
  }
  return;
}
}
#line 117 "../../src/utils/utils.h"
__inline static void PutLE32(uint8_t *data , uint32_t val ) 
{ 


  {
  {
#line 118
  PutLE16(data, (int )(val & 65535U));
#line 119
  PutLE16(data + 2, (int )(val >> 16));
  }
  return;
}
}
#line 126 "../../src/utils/utils.h"
__inline static int BitsLog2Floor(uint32_t n ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 127
  __cil_tmp2 = __builtin_clz(n);
  }
#line 127
  return (31 ^ __cil_tmp2);
}
}
#line 130 "../../src/utils/utils.h"
__inline static int BitsCtz(uint32_t n ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 130
  __cil_tmp2 = __builtin_ctz(n);
  }
#line 130
  return (__cil_tmp2);
}
}
#line 180
extern void WebPCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                          int width , int height ) ;
#line 186
extern void WebPCopyPixels(struct WebPPicture * const  src , struct WebPPicture * const  dst ) ;
#line 200
extern int WebPGetColorPalette(struct WebPPicture * const  pic , uint32_t * const  palette ) ;
#line 38 "../../src/webp/encode.h"
extern int WebPGetEncoderVersion(void) ;
#line 49
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 52
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 55
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 58
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 69
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 72
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 75
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 78
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 167
extern int WebPConfigInitInternal(WebPConfig * , WebPPreset  , float  , int  ) ;
#line 173 "../../src/webp/encode.h"
__inline static int WebPConfigInit(WebPConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 174
  __cil_tmp2 = WebPConfigInitInternal(config, (WebPPreset )0, 75.f, 527);
  }
#line 174
  return (__cil_tmp2);
}
}
#line 182 "../../src/webp/encode.h"
__inline static int WebPConfigPreset(WebPConfig *config , WebPPreset preset , float quality ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 184
  __cil_tmp4 = WebPConfigInitInternal(config, preset, quality, 527);
  }
#line 184
  return (__cil_tmp4);
}
}
#line 194
extern int WebPConfigLosslessPreset(WebPConfig *config , int level ) ;
#line 198
extern int WebPValidateConfig(WebPConfig *config ) ;
#line 250
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) ;
#line 254
void WebPMemoryWriterClear(WebPMemoryWriter *writer ) ;
#line 258
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) ;
#line 367
int WebPPictureInitInternal(WebPPicture *picture , int version ) ;
#line 373 "../../src/webp/encode.h"
__inline static int WebPPictureInit(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 374
  __cil_tmp2 = WebPPictureInitInternal(picture, 527);
  }
#line 374
  return (__cil_tmp2);
}
}
#line 384
int WebPPictureAlloc(WebPPicture *picture ) ;
#line 391
void WebPPictureFree(WebPPicture *picture ) ;
#line 397
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) ;
#line 406
int WebPPlaneDistortion(uint8_t *src , size_t src_stride , uint8_t *ref , size_t ref_stride ,
                        int width , int height , size_t x_step , int type , float *distortion ,
                        float *result ) ;
#line 418
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float results[5] ) ;
#line 431
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) ;
#line 445
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) ;
#line 451
int WebPPictureIsView(WebPPicture *picture ) ;
#line 458
int WebPPictureRescale(WebPPicture *picture , int width , int height ) ;
#line 464
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 467
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 472
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgbx , int rgbx_stride ) ;
#line 476
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *bgr , int bgr_stride ) ;
#line 478
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *bgra , int bgra_stride ) ;
#line 480
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *bgrx , int bgrx_stride ) ;
#line 489
int WebPPictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace ) ;
#line 496
int WebPPictureARGBToYUVADithered(WebPPicture *picture , WebPEncCSP colorspace , float dithering ) ;
#line 504
int WebPPictureSharpARGBToYUVA(WebPPicture *picture ) ;
#line 506
int WebPPictureSmartARGBToYUVA(WebPPicture *picture ) ;
#line 514
int WebPPictureYUVAToARGB(WebPPicture *picture ) ;
#line 519
void WebPCleanupTransparentArea(WebPPicture *pic ) ;
#line 524
int WebPPictureHasTransparency(WebPPicture *picture ) ;
#line 529
void WebPBlendAlpha(WebPPicture *picture , uint32_t background_rgb ) ;
#line 544
extern int WebPEncode(WebPConfig *config , WebPPicture *picture ) ;
#line 78 "../../src/enc/vp8i_enc.h"
extern uint16_t VP8Scan[16] ;
#line 79
extern uint16_t VP8UVModeOffsets[4] ;
#line 80
extern uint16_t VP8I16ModeOffsets[4] ;
#line 81
extern uint16_t VP8I4ModeOffsets[10] ;
#line 116 "../../src/enc/vp8i_enc.h"
__inline static int QUANTDIV(uint32_t n , uint32_t iQ , uint32_t B ) 
{ 


  {
#line 117
  return ((int )((n * iQ + B) >> 17));
}
}
#line 269
void VP8IteratorInit(VP8Encoder * const  enc , VP8EncIterator * const  it ) ;
#line 271
void VP8IteratorReset(VP8EncIterator * const  it ) ;
#line 273
void VP8IteratorSetRow(VP8EncIterator * const  it , int y ) ;
#line 275
void VP8IteratorSetCountDown(VP8EncIterator * const  it , int count_down ) ;
#line 277
int VP8IteratorIsDone(VP8EncIterator * const  it ) ;
#line 281
void VP8IteratorImport(VP8EncIterator * const  it , uint8_t * const  tmp_32 ) ;
#line 283
void VP8IteratorExport(VP8EncIterator * const  it ) ;
#line 285
int VP8IteratorNext(VP8EncIterator * const  it ) ;
#line 287
void VP8IteratorSaveBoundary(VP8EncIterator * const  it ) ;
#line 289
int VP8IteratorProgress(VP8EncIterator * const  it , int delta ) ;
#line 291
void VP8IteratorStartI4(VP8EncIterator * const  it ) ;
#line 293
int VP8IteratorRotateI4(VP8EncIterator * const  it , uint8_t * const  yuv_out ) ;
#line 297
void VP8IteratorNzToBytes(VP8EncIterator * const  it ) ;
#line 298
void VP8IteratorBytesToNz(VP8EncIterator * const  it ) ;
#line 301
void VP8SetIntra16Mode(VP8EncIterator * const  it , int mode ) ;
#line 302
void VP8SetIntra4Mode(VP8EncIterator * const  it , uint8_t *modes ) ;
#line 303
void VP8SetIntraUVMode(VP8EncIterator * const  it , int mode ) ;
#line 304
void VP8SetSkip(VP8EncIterator * const  it , int skip ) ;
#line 305
void VP8SetSegment(VP8EncIterator * const  it , int segment ) ;
#line 324
void VP8TBufferInit(VP8TBuffer * const  b , int page_size ) ;
#line 325
void VP8TBufferClear(VP8TBuffer * const  b ) ;
#line 331
int VP8EmitTokens(VP8TBuffer * const  b , VP8BitWriter * const  bw , uint8_t * const  probas ,
                  int final_pass ) ;
#line 335
int VP8RecordCoeffTokens(int ctx , struct VP8Residual * const  res , VP8TBuffer * const  tokens ) ;
#line 339
size_t VP8EstimateTokenSize(VP8TBuffer * const  b , uint8_t * const  probas ) ;
#line 419
extern uint8_t VP8CoeffsProba0[4][8][3][11] ;
#line 421
extern uint8_t VP8CoeffsUpdateProba[4][8][3][11] ;
#line 423
void VP8DefaultProbas(VP8Encoder * const  enc ) ;
#line 425
void VP8WriteProbas(VP8BitWriter * const  bw , VP8EncProba * const  probas ) ;
#line 427
void VP8CodeIntraModes(VP8Encoder * const  enc ) ;
#line 433
int VP8EncWrite(VP8Encoder * const  enc ) ;
#line 435
void VP8EncFreeBitWriters(VP8Encoder * const  enc ) ;
#line 438
extern uint8_t VP8Cat3[] ;
#line 439
extern uint8_t VP8Cat4[] ;
#line 440
extern uint8_t VP8Cat5[] ;
#line 441
extern uint8_t VP8Cat6[] ;
#line 444
void VP8MakeLuma16Preds(VP8EncIterator * const  it ) ;
#line 446
void VP8MakeChroma8Preds(VP8EncIterator * const  it ) ;
#line 449
void VP8MakeIntra4Preds(VP8EncIterator * const  it ) ;
#line 451
int VP8GetCostLuma16(VP8EncIterator * const  it , VP8ModeScore * const  rd ) ;
#line 452
int VP8GetCostLuma4(VP8EncIterator * const  it , int16_t levels[16] ) ;
#line 453
int VP8GetCostUV(VP8EncIterator * const  it , VP8ModeScore * const  rd ) ;
#line 455
int VP8EncLoop(VP8Encoder * const  enc ) ;
#line 456
int VP8EncTokenLoop(VP8Encoder * const  enc ) ;
#line 460
int WebPEncodingSetError(WebPPicture * const  pic , WebPEncodingError error ) ;
#line 461
int WebPReportProgress(WebPPicture * const  pic , int percent , int * const  percent_store ) ;
#line 467
int VP8EncAnalyze(VP8Encoder * const  enc ) ;
#line 471
void VP8SetSegmentParams(VP8Encoder * const  enc , float quality ) ;
#line 473
int VP8Decimate(VP8EncIterator * const  it , VP8ModeScore * const  rd , VP8RDLevel rd_opt ) ;
#line 478
void VP8EncInitAlpha(VP8Encoder * const  enc ) ;
#line 479
int VP8EncStartAlpha(VP8Encoder * const  enc ) ;
#line 480
int VP8EncFinishAlpha(VP8Encoder * const  enc ) ;
#line 481
int VP8EncDeleteAlpha(VP8Encoder * const  enc ) ;
#line 484
void VP8InitFilter(VP8EncIterator * const  it ) ;
#line 485
void VP8StoreFilterStats(VP8EncIterator * const  it ) ;
#line 486
void VP8AdjustFilterStrength(VP8EncIterator * const  it ) ;
#line 490
int VP8FilterStrengthFromDelta(int sharpness , int delta ) ;
#line 497
int WebPValidatePicture(WebPPicture *picture ) ;
#line 500
void WebPPictureResetBuffers(WebPPicture *picture ) ;
#line 505
int WebPPictureAllocARGB(WebPPicture *picture ) ;
#line 511
int WebPPictureAllocYUVA(WebPPicture *picture ) ;
#line 515
void WebPReplaceTransparentPixels(WebPPicture *pic , uint32_t color ) ;
#line 39 "../../src/webp/decode.h"
extern int WebPGetDecoderVersion(void) ;
#line 51
extern int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 59
extern uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 63
extern uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 67
extern uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 72
extern uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 76
extern uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 90
extern uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                              uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) ;
#line 103
extern uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output_buffer ,
                                   size_t output_buffer_size , int output_stride ) ;
#line 106
extern uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output_buffer ,
                                   size_t output_buffer_size , int output_stride ) ;
#line 109
extern uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output_buffer ,
                                   size_t output_buffer_size , int output_stride ) ;
#line 115
extern uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output_buffer ,
                                  size_t output_buffer_size , int output_stride ) ;
#line 118
extern uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output_buffer ,
                                  size_t output_buffer_size , int output_stride ) ;
#line 129
extern uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma ,
                                  size_t luma_size , int luma_stride , uint8_t *u ,
                                  size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                                  int v_stride ) ;
#line 166 "../../src/webp/decode.h"
__inline static int WebPIsPremultipliedMode(WEBP_CSP_MODE mode ) 
{ 


  {
#line 167
  return ((((unsigned int )mode == 7U || (unsigned int )mode == 8U) || (unsigned int )mode == 9U) || (unsigned int )mode == 10U);
}
}
#line 171 "../../src/webp/decode.h"
__inline static int WebPIsAlphaMode(WEBP_CSP_MODE mode ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 172
  __cil_tmp2 = WebPIsPremultipliedMode(mode);
  }
#line 172
  return ((((((unsigned int )mode == 1U || (unsigned int )mode == 3U) || (unsigned int )mode == 4U) || (unsigned int )mode == 5U) || (unsigned int )mode == 12U) || __cil_tmp2);
}
}
#line 177 "../../src/webp/decode.h"
__inline static int WebPIsRGBMode(WEBP_CSP_MODE mode ) 
{ 


  {
#line 178
  return ((unsigned int )mode < 11U);
}
}
#line 220
extern int WebPInitDecBufferInternal(WebPDecBuffer * , int  ) ;
#line 224 "../../src/webp/decode.h"
__inline static int WebPInitDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 225
  __cil_tmp2 = WebPInitDecBufferInternal(buffer, 521);
  }
#line 225
  return (__cil_tmp2);
}
}
#line 230
extern void WebPFreeDecBuffer(WebPDecBuffer *buffer ) ;
#line 284
extern WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) ;
#line 296
extern WebPIDecoder *WebPINewRGB(WEBP_CSP_MODE csp , uint8_t *output_buffer , size_t output_buffer_size ,
                                 int output_stride ) ;
#line 311
extern WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride ,
                                  uint8_t *u , size_t u_size , int u_stride , uint8_t *v ,
                                  size_t v_size , int v_stride , uint8_t *a , size_t a_size ,
                                  int a_stride ) ;
#line 319
extern WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride ,
                                 uint8_t *u , size_t u_size , int u_stride , uint8_t *v ,
                                 size_t v_size , int v_stride ) ;
#line 326
extern void WebPIDelete(WebPIDecoder *idec ) ;
#line 331
extern VP8StatusCode WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 339
extern VP8StatusCode WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 349
extern uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                               int *stride ) ;
#line 356
extern uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                                uint8_t **a , int *width , int *height , int *stride ,
                                int *uv_stride , int *a_stride ) ;
#line 363 "../../src/webp/decode.h"
__inline static uint8_t *WebPIDecGetYUV(WebPIDecoder *idec , int *last_y , uint8_t **u ,
                                        uint8_t **v , int *width , int *height , int *stride ,
                                        int *uv_stride ) 
{ 
  uint8_t *__cil_tmp9 ;

  {
  {
#line 366
  __cil_tmp9 = WebPIDecGetYUVA(idec, last_y, u, v, (uint8_t **)((void *)0), width,
                               height, stride, uv_stride, (int *)((void *)0));
  }
#line 366
  return (__cil_tmp9);
}
}
#line 376
extern WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top ,
                                       int *width , int *height ) ;
#line 424
extern VP8StatusCode WebPGetFeaturesInternal(uint8_t * , size_t  , WebPBitstreamFeatures * ,
                                             int  ) ;
#line 438 "../../src/webp/decode.h"
__inline static VP8StatusCode WebPGetFeatures(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ) 
{ 
  VP8StatusCode __cil_tmp4 ;

  {
  {
#line 441
  __cil_tmp4 = WebPGetFeaturesInternal(data, data_size, features, 521);
  }
#line 441
  return (__cil_tmp4);
}
}
#line 471
extern int WebPInitDecoderConfigInternal(WebPDecoderConfig * , int  ) ;
#line 476 "../../src/webp/decode.h"
__inline static int WebPInitDecoderConfig(WebPDecoderConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 477
  __cil_tmp2 = WebPInitDecoderConfigInternal(config, 521);
  }
#line 477
  return (__cil_tmp2);
}
}
#line 491
extern WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 497
extern VP8StatusCode WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 111 "../../src/dec/vp8_dec.h"
int VP8InitIoInternal(VP8Io * const   , int  ) ;
#line 116
int WebPISetIOHooks(WebPIDecoder * const  idec , VP8IoPutHook put , VP8IoSetupHook setup ,
                    VP8IoTeardownHook teardown , void *user_data ) ;
#line 126
VP8Decoder *VP8New(void) ;
#line 131 "../../src/dec/vp8_dec.h"
__inline static int VP8InitIo(VP8Io *io ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 132
  __cil_tmp2 = VP8InitIoInternal(io, 521);
  }
#line 132
  return (__cil_tmp2);
}
}
#line 137
int VP8GetHeaders(VP8Decoder * const  dec , VP8Io * const  io ) ;
#line 141
int VP8Decode(VP8Decoder * const  dec , VP8Io * const  io ) ;
#line 144
VP8StatusCode VP8Status(VP8Decoder * const  dec ) ;
#line 147
char const   *VP8StatusMessage(VP8Decoder * const  dec ) ;
#line 151
void VP8Clear(VP8Decoder * const  dec ) ;
#line 154
void VP8Delete(VP8Decoder * const  dec ) ;
#line 160
extern int VP8CheckSignature(uint8_t * const  data , size_t data_size ) ;
#line 165
extern int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int * const  width ,
                      int * const  height ) ;
#line 172
extern int VP8LCheckSignature(uint8_t * const  data , size_t size ) ;
#line 177
extern int VP8LGetInfo(uint8_t *data , size_t data_size , int * const  width , int * const  height ,
                       int * const  has_alpha ) ;
#line 59 "../../src/dsp/yuv.h"
__inline static int MultHi(int v , int coeff ) 
{ 


  {
#line 60
  return (v * coeff >> 8);
}
}
#line 63 "../../src/dsp/yuv.h"
__inline static int VP8Clip8(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 64
  if ((v & -16384) == 0) {
#line 64
    tmp___0 = v >> 6;
  } else {
#line 64
    if (v < 0) {
#line 64
      tmp = 0;
    } else {
#line 64
      tmp = 255;
    }
#line 64
    tmp___0 = tmp;
  }
#line 64
  return (tmp___0);
}
}
#line 67 "../../src/dsp/yuv.h"
__inline static int VP8YUVToR(int y , int v ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 68
  __cil_tmp4 = MultHi(v, 26149);
  }
  {
#line 68
  __cil_tmp3 = MultHi(y, 19077);
#line 68
  __cil_tmp5 = VP8Clip8((__cil_tmp3 + __cil_tmp4) - 14234);
  }
#line 68
  return (__cil_tmp5);
}
}
#line 71 "../../src/dsp/yuv.h"
__inline static int VP8YUVToG(int y , int u , int v ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 72
  __cil_tmp6 = MultHi(v, 13320);
  }
  {
#line 72
  __cil_tmp5 = MultHi(u, 6419);
  }
  {
#line 72
  __cil_tmp4 = MultHi(y, 19077);
#line 72
  __cil_tmp7 = VP8Clip8(((__cil_tmp4 - __cil_tmp5) - __cil_tmp6) + 8708);
  }
#line 72
  return (__cil_tmp7);
}
}
#line 75 "../../src/dsp/yuv.h"
__inline static int VP8YUVToB(int y , int u ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 76
  __cil_tmp4 = MultHi(u, 33050);
  }
  {
#line 76
  __cil_tmp3 = MultHi(y, 19077);
#line 76
  __cil_tmp5 = VP8Clip8((__cil_tmp3 + __cil_tmp4) - 17685);
  }
#line 76
  return (__cil_tmp5);
}
}
#line 79 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgb(int y , int u , int v , uint8_t *rgb ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 81
  __cil_tmp5 = VP8YUVToR(y, v);
#line 81
  *(rgb + 0) = (uint8_t )__cil_tmp5;
#line 82
  __cil_tmp6 = VP8YUVToG(y, u, v);
#line 82
  *(rgb + 1) = (uint8_t )__cil_tmp6;
#line 83
  __cil_tmp7 = VP8YUVToB(y, u);
#line 83
  *(rgb + 2) = (uint8_t )__cil_tmp7;
  }
  return;
}
}
#line 86 "../../src/dsp/yuv.h"
__inline static void VP8YuvToBgr(int y , int u , int v , uint8_t *bgr ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp5 = VP8YUVToB(y, u);
#line 88
  *(bgr + 0) = (uint8_t )__cil_tmp5;
#line 89
  __cil_tmp6 = VP8YUVToG(y, u, v);
#line 89
  *(bgr + 1) = (uint8_t )__cil_tmp6;
#line 90
  __cil_tmp7 = VP8YUVToR(y, v);
#line 90
  *(bgr + 2) = (uint8_t )__cil_tmp7;
  }
  return;
}
}
#line 93 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgb565(int y , int u , int v , uint8_t *rgb ) 
{ 
  int r ;
  int __cil_tmp6 ;
  int g ;
  int __cil_tmp8 ;
  int b ;
  int __cil_tmp10 ;
  int rg ;
  int gb ;

  {
  {
#line 95
  __cil_tmp6 = VP8YUVToR(y, v);
#line 95
  r = __cil_tmp6;
#line 96
  __cil_tmp8 = VP8YUVToG(y, u, v);
#line 96
  g = __cil_tmp8;
#line 97
  __cil_tmp10 = VP8YUVToB(y, u);
#line 97
  b = __cil_tmp10;
#line 98
  rg = (r & 248) | (g >> 5);
#line 99
  gb = ((g << 3) & 224) | (b >> 3);
#line 104
  *(rgb + 0) = (uint8_t )rg;
#line 105
  *(rgb + 1) = (uint8_t )gb;
  }
  return;
}
}
#line 109 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgba4444(int y , int u , int v , uint8_t *argb ) 
{ 
  int r ;
  int __cil_tmp6 ;
  int g ;
  int __cil_tmp8 ;
  int b ;
  int __cil_tmp10 ;
  int rg ;
  int ba ;

  {
  {
#line 111
  __cil_tmp6 = VP8YUVToR(y, v);
#line 111
  r = __cil_tmp6;
#line 112
  __cil_tmp8 = VP8YUVToG(y, u, v);
#line 112
  g = __cil_tmp8;
#line 113
  __cil_tmp10 = VP8YUVToB(y, u);
#line 113
  b = __cil_tmp10;
#line 114
  rg = (r & 240) | (g >> 4);
#line 115
  ba = (b & 240) | 15;
#line 120
  *(argb + 0) = (uint8_t )rg;
#line 121
  *(argb + 1) = (uint8_t )ba;
  }
  return;
}
}
#line 128 "../../src/dsp/yuv.h"
__inline static void VP8YuvToArgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 


  {
  {
#line 130
  *(argb + 0) = (uint8_t )255;
#line 131
  VP8YuvToRgb((int )y, (int )u, (int )v, argb + 1);
  }
  return;
}
}
#line 134 "../../src/dsp/yuv.h"
__inline static void VP8YuvToBgra(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgra ) 
{ 


  {
  {
#line 136
  VP8YuvToBgr((int )y, (int )u, (int )v, bgra);
#line 137
  *(bgra + 3) = (uint8_t )255;
  }
  return;
}
}
#line 140 "../../src/dsp/yuv.h"
__inline static void VP8YuvToRgba(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgba ) 
{ 


  {
  {
#line 142
  VP8YuvToRgb((int )y, (int )u, (int )v, rgba);
#line 143
  *(rgba + 3) = (uint8_t )255;
  }
  return;
}
}
#line 152
void VP8YuvToRgba32_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 154
void VP8YuvToRgb32_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 156
void VP8YuvToBgra32_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 158
void VP8YuvToBgr32_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 160
void VP8YuvToArgb32_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 162
void VP8YuvToRgba444432_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 164
void VP8YuvToRgb56532_SSE2(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ) ;
#line 186 "../../src/dsp/yuv.h"
__inline static int VP8ClipUV(int uv , int rounding ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 187
  uv = ((uv + rounding) + (128 << 18)) >> 18;
#line 188
  if ((uv & -256) == 0) {
#line 188
    tmp___0 = uv;
  } else {
#line 188
    if (uv < 0) {
#line 188
      tmp = 0;
    } else {
#line 188
      tmp = 255;
    }
#line 188
    tmp___0 = tmp;
  }
#line 188
  return (tmp___0);
}
}
#line 191 "../../src/dsp/yuv.h"
__inline static int VP8RGBToY(int r , int g , int b , int rounding ) 
{ 
  int luma ;

  {
#line 192
  luma = (16839 * r + 33059 * g) + 6420 * b;
#line 193
  return (((luma + rounding) + (16 << 16)) >> 16);
}
}
#line 196 "../../src/dsp/yuv.h"
__inline static int VP8RGBToU(int r , int g , int b , int rounding ) 
{ 
  int u ;
  int __cil_tmp6 ;

  {
  {
#line 197
  u = (-9719 * r - 19081 * g) + 28800 * b;
#line 198
  __cil_tmp6 = VP8ClipUV(u, rounding);
  }
#line 198
  return (__cil_tmp6);
}
}
#line 201 "../../src/dsp/yuv.h"
__inline static int VP8RGBToV(int r , int g , int b , int rounding ) 
{ 
  int v ;
  int __cil_tmp6 ;

  {
  {
#line 202
  v = (28800 * r - 24116 * g) - 4684 * b;
#line 203
  __cil_tmp6 = VP8ClipUV(v, rounding);
  }
#line 203
  return (__cil_tmp6);
}
}
#line 24 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
static int IsTransparentARGBArea(uint32_t *ptr , int stride , int size ) 
{ 
  int y ;
  int x ;

  {
#line 26
  y = 0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! (y < size)) {
#line 26
      goto while_break;
    }
#line 27
    x = 0;
    {
#line 27
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 27
      if (! (x < size)) {
#line 27
        goto while_break___0;
      }
#line 28
      if (*(ptr + x) & 4278190080U) {
#line 29
        return (0);
      }
#line 27
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 32
    ptr += stride;
#line 26
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return (1);
}
}
#line 37 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
static void Flatten(uint8_t *ptr , int v , int stride , int size ) 
{ 
  int y ;

  {
#line 39
  y = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (y < size)) {
#line 39
      goto while_break;
    }
    {
#line 40
    memset(ptr, v, (unsigned long )size);
#line 41
    ptr += stride;
    }
#line 39
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 45 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
static void FlattenARGB(uint32_t *ptr , uint32_t v , int stride , int size ) 
{ 
  int x ;
  int y ;

  {
#line 47
  y = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (y < size)) {
#line 47
      goto while_break;
    }
#line 48
    x = 0;
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (! (x < size)) {
#line 48
        goto while_break___0;
      }
#line 48
      *(ptr + x) = v;
#line 48
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    ptr += stride;
#line 47
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 55 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
static int SmoothenBlock(uint8_t *a_ptr , int a_stride , uint8_t *y_ptr , int y_stride ,
                         int width , int height ) 
{ 
  int sum ;
  int count ;
  int x ;
  int y ;
  uint8_t *alpha_ptr ;
  uint8_t *luma_ptr ;
  uint8_t avg_u8 ;

  {
#line 57
  sum = 0;
#line 57
  count = 0;
#line 59
  alpha_ptr = a_ptr;
#line 60
  luma_ptr = y_ptr;
#line 61
  y = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (y < height)) {
#line 61
      goto while_break;
    }
#line 62
    x = 0;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (x < width)) {
#line 62
        goto while_break___0;
      }
#line 63
      if ((int )*(alpha_ptr + x) != 0) {
#line 64
        count ++;
#line 65
        sum += (int )*(luma_ptr + x);
      }
#line 62
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 68
    alpha_ptr += a_stride;
#line 69
    luma_ptr += y_stride;
#line 61
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if (count > 0) {
#line 71
    if (count < width * height) {
#line 72
      avg_u8 = (uint8_t )(sum / count);
#line 73
      alpha_ptr = a_ptr;
#line 74
      luma_ptr = y_ptr;
#line 75
      y = 0;
      {
#line 75
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 75
        if (! (y < height)) {
#line 75
          goto while_break___1;
        }
#line 76
        x = 0;
        {
#line 76
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 76
          if (! (x < width)) {
#line 76
            goto while_break___2;
          }
#line 77
          if ((int )*(alpha_ptr + x) == 0) {
#line 77
            *(luma_ptr + x) = avg_u8;
          }
#line 76
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 79
        alpha_ptr += a_stride;
#line 80
        luma_ptr += y_stride;
#line 75
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 83
  return (count == 0);
}
}
#line 86 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
void WebPReplaceTransparentPixels(WebPPicture *pic , uint32_t color ) 
{ 
  int y ;
  uint32_t *argb ;
  int __cil_tmp5 ;

  {
#line 87
  if (pic != (void *)0) {
#line 87
    if (pic->use_argb) {
      {
#line 88
      y = pic->height;
#line 89
      argb = pic->argb;
#line 90
      color &= 16777215U;
#line 91
      WebPInitAlphaProcessing();
      }
      {
#line 92
      while (1) {
        while_continue: /* CIL Label */ ;
#line 92
        __cil_tmp5 = y;
#line 92
        y --;
#line 92
        if (! (__cil_tmp5 > 0)) {
#line 92
          goto while_break;
        }
        {
#line 93
        (*WebPAlphaReplace)(argb, pic->width, color);
#line 94
        argb += pic->argb_stride;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 99 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
void WebPCleanupTransparentArea(WebPPicture *pic ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  uint32_t argb_value ;
  int need_reset ;
  int off ;
  int __cil_tmp9 ;
  int width ;
  int height ;
  int y_stride ;
  int uv_stride ;
  int a_stride ;
  uint8_t *y_ptr ;
  uint8_t *u_ptr ;
  uint8_t *v_ptr ;
  uint8_t *a_ptr ;
  int values[3] ;
  unsigned int tmp ;
  int need_reset___0 ;
  int __cil_tmp22 ;
  int sub_height ;

  {
#line 101
  if (pic == (void *)0) {
#line 101
    return;
  }
#line 102
  w = pic->width / 8;
#line 103
  h = pic->height / 8;
#line 106
  if (pic->use_argb) {
#line 107
    argb_value = (uint32_t )0;
#line 108
    y = 0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (! (y < h)) {
#line 108
        goto while_break;
      }
#line 109
      need_reset = 1;
#line 110
      x = 0;
      {
#line 110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 110
        if (! (x < w)) {
#line 110
          goto while_break___0;
        }
        {
#line 111
        off = (y * pic->argb_stride + x) * 8;
#line 112
        __cil_tmp9 = IsTransparentARGBArea(pic->argb + off, pic->argb_stride, 8);
        }
#line 112
        if (__cil_tmp9) {
#line 113
          if (need_reset) {
#line 114
            argb_value = *(pic->argb + off);
#line 115
            need_reset = 0;
          }
          {
#line 117
          FlattenARGB(pic->argb + off, argb_value, pic->argb_stride, 8);
          }
        } else {
#line 119
          need_reset = 1;
        }
#line 110
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 108
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 124
    width = pic->width;
#line 125
    height = pic->height;
#line 126
    y_stride = pic->y_stride;
#line 127
    uv_stride = pic->uv_stride;
#line 128
    a_stride = pic->a_stride;
#line 129
    y_ptr = pic->y;
#line 130
    u_ptr = pic->u;
#line 131
    v_ptr = pic->v;
#line 132
    a_ptr = pic->a;
#line 133
    values[0] = 0;
#line 133
    tmp = (unsigned int )1;
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 133
      if (tmp >= 3) {
#line 133
        goto while_break___1;
      }
#line 133
      values[tmp] = 0;
#line 133
      tmp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 134
    if (a_ptr == (void *)0) {
#line 135
      return;
    } else
#line 134
    if (y_ptr == (void *)0) {
#line 135
      return;
    } else
#line 134
    if (u_ptr == (void *)0) {
#line 135
      return;
    } else
#line 134
    if (v_ptr == (void *)0) {
#line 135
      return;
    }
#line 137
    y = 0;
    {
#line 137
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 137
      if (! (y + 8 <= height)) {
#line 137
        goto while_break___2;
      }
#line 138
      need_reset___0 = 1;
#line 139
      x = 0;
      {
#line 139
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 139
        if (! (x + 8 <= width)) {
#line 139
          goto while_break___3;
        }
        {
#line 140
        __cil_tmp22 = SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, 8, 8);
        }
#line 140
        if (__cil_tmp22) {
#line 142
          if (need_reset___0) {
#line 143
            values[0] = (int )*(y_ptr + x);
#line 144
            values[1] = (int )*(u_ptr + (x >> 1));
#line 145
            values[2] = (int )*(v_ptr + (x >> 1));
#line 146
            need_reset___0 = 0;
          }
          {
#line 148
          Flatten(y_ptr + x, values[0], y_stride, 8);
#line 149
          Flatten(u_ptr + (x >> 1), values[1], uv_stride, 4);
#line 150
          Flatten(v_ptr + (x >> 1), values[2], uv_stride, 4);
          }
        } else {
#line 152
          need_reset___0 = 1;
        }
#line 139
        x += 8;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 155
      if (x < width) {
        {
#line 156
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, width - x, 8);
        }
      }
#line 159
      a_ptr += 8 * a_stride;
#line 160
      y_ptr += 8 * y_stride;
#line 161
      u_ptr += 4 * uv_stride;
#line 162
      v_ptr += 4 * uv_stride;
#line 137
      y += 8;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 164
    if (y < height) {
#line 165
      sub_height = height - y;
#line 166
      x = 0;
      {
#line 166
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 166
        if (! (x + 8 <= width)) {
#line 166
          goto while_break___4;
        }
        {
#line 167
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, 8, sub_height);
        }
#line 166
        x += 8;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 170
      if (x < width) {
        {
#line 171
        SmoothenBlock(a_ptr + x, a_stride, y_ptr + x, y_stride, width - x, sub_height);
        }
      }
    }
  }
  return;
}
}
#line 189 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
__inline static uint32_t MakeARGB32(int r , int g , int b ) 
{ 


  {
#line 190
  return (((4278190080U | (unsigned int )(r << 16)) | (unsigned int )(g << 8)) | (unsigned int )b);
}
}
#line 193 "/doner/libwebp/libwebp-31bea324/src/enc/picture_tools_enc.c"
void WebPBlendAlpha(WebPPicture *picture , uint32_t background_rgb ) 
{ 
  int red ;
  int green ;
  int blue ;
  int x ;
  int y ;
  int uv_width ;
  int Y0 ;
  int __cil_tmp10 ;
  int U0 ;
  int __cil_tmp12 ;
  int V0 ;
  int __cil_tmp14 ;
  int has_alpha ;
  uint8_t *y_ptr ;
  uint8_t *u_ptr ;
  uint8_t *v_ptr ;
  uint8_t *a_ptr ;
  uint8_t alpha ;
  uint8_t *a_ptr2 ;
  uint8_t *tmp ;
  uint32_t alpha___0 ;
  uint32_t alpha___1 ;
  uint32_t *argb ;
  uint32_t background ;
  uint32_t __cil_tmp27 ;
  int alpha___2 ;
  int r ;
  int g ;
  int b ;
  uint32_t __cil_tmp32 ;

  {
#line 194
  red = (int )((background_rgb >> 16) & 255U);
#line 195
  green = (int )((background_rgb >> 8) & 255U);
#line 196
  blue = (int )(background_rgb & 255U);
#line 198
  if (picture == (void *)0) {
#line 198
    return;
  }
#line 199
  if (! picture->use_argb) {
    {
#line 201
    uv_width = picture->width >> 1;
#line 202
    __cil_tmp10 = VP8RGBToY(red, green, blue, 32768);
#line 202
    Y0 = __cil_tmp10;
#line 204
    __cil_tmp12 = VP8RGBToU(4 * red, 4 * green, 4 * blue, 131072);
#line 204
    U0 = __cil_tmp12;
#line 205
    __cil_tmp14 = VP8RGBToV(4 * red, 4 * green, 4 * blue, 131072);
#line 205
    V0 = __cil_tmp14;
#line 206
    has_alpha = (int )((unsigned int )picture->colorspace & 4U);
#line 207
    y_ptr = picture->y;
#line 208
    u_ptr = picture->u;
#line 209
    v_ptr = picture->v;
#line 210
    a_ptr = picture->a;
    }
#line 211
    if (a_ptr == (void *)0) {
#line 211
      return;
    } else
#line 211
    if (! has_alpha) {
#line 211
      return;
    }
#line 212
    y = 0;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! (y < picture->height)) {
#line 212
        goto while_break;
      }
#line 214
      x = 0;
      {
#line 214
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 214
        if (! (x < picture->width)) {
#line 214
          goto while_break___0;
        }
#line 215
        alpha = *(a_ptr + x);
#line 216
        if ((int )alpha < 255) {
#line 217
          *(y_ptr + x) = (uint8_t )(((Y0 * (255 - (int )alpha) + (int )*(y_ptr + x) * (int )alpha) * 257 + 256) >> 16);
        }
#line 214
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 221
      if ((y & 1) == 0) {
#line 222
        if (y + 1 == picture->height) {
#line 222
          tmp = a_ptr;
        } else {
#line 222
          tmp = a_ptr + picture->a_stride;
        }
#line 222
        a_ptr2 = tmp;
#line 224
        x = 0;
        {
#line 224
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 224
          if (! (x < uv_width)) {
#line 224
            goto while_break___1;
          }
#line 227
          alpha___0 = (uint32_t )((((int )*(a_ptr + 2 * x) + (int )*(a_ptr + (2 * x + 1))) + (int )*(a_ptr2 + 2 * x)) + (int )*(a_ptr2 + (2 * x + 1)));
#line 230
          *(u_ptr + x) = (uint8_t )((((unsigned int )U0 * (1020U - alpha___0) + (unsigned int )*(u_ptr + x) * alpha___0) * 257U + 1024U) >> 18);
#line 231
          *(v_ptr + x) = (uint8_t )((((unsigned int )V0 * (1020U - alpha___0) + (unsigned int )*(v_ptr + x) * alpha___0) * 257U + 1024U) >> 18);
#line 224
          x ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 233
        if (picture->width & 1) {
#line 234
          alpha___1 = (uint32_t )(2 * ((int )*(a_ptr + 2 * x) + (int )*(a_ptr2 + 2 * x)));
#line 235
          *(u_ptr + x) = (uint8_t )((((unsigned int )U0 * (1020U - alpha___1) + (unsigned int )*(u_ptr + x) * alpha___1) * 257U + 1024U) >> 18);
#line 236
          *(v_ptr + x) = (uint8_t )((((unsigned int )V0 * (1020U - alpha___1) + (unsigned int )*(v_ptr + x) * alpha___1) * 257U + 1024U) >> 18);
        }
      } else {
#line 239
        u_ptr += picture->uv_stride;
#line 240
        v_ptr += picture->uv_stride;
      }
      {
#line 242
      memset(a_ptr, 255, (unsigned long )picture->width);
#line 243
      a_ptr += picture->a_stride;
#line 244
      y_ptr += picture->y_stride;
      }
#line 212
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 247
    argb = picture->argb;
#line 248
    __cil_tmp27 = MakeARGB32(red, green, blue);
#line 248
    background = __cil_tmp27;
#line 249
    y = 0;
    }
    {
#line 249
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 249
      if (! (y < picture->height)) {
#line 249
        goto while_break___2;
      }
#line 250
      x = 0;
      {
#line 250
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 250
        if (! (x < picture->width)) {
#line 250
          goto while_break___3;
        }
#line 251
        alpha___2 = (int )((*(argb + x) >> 24) & 255U);
#line 252
        if (alpha___2 != 255) {
#line 253
          if (alpha___2 > 0) {
            {
#line 254
            r = (int )((*(argb + x) >> 16) & 255U);
#line 255
            g = (int )((*(argb + x) >> 8) & 255U);
#line 256
            b = (int )(*(argb + x) & 255U);
#line 257
            r = ((red * (255 - alpha___2) + r * alpha___2) * 257 + 256) >> 16;
#line 258
            g = ((green * (255 - alpha___2) + g * alpha___2) * 257 + 256) >> 16;
#line 259
            b = ((blue * (255 - alpha___2) + b * alpha___2) * 257 + 256) >> 16;
#line 260
            *(argb + x) = MakeARGB32(r, g, b);
            }
          } else {
#line 262
            *(argb + x) = background;
          }
        }
#line 250
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 266
      argb += picture->argb_stride;
#line 249
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 51 "../../src/utils/rescaler_utils.h"
int WebPRescalerInit(WebPRescaler * const  rescaler , int src_width , int src_height ,
                     uint8_t * const  dst , int dst_width , int dst_height , int dst_stride ,
                     int num_channels , rescaler_t * const  work ) ;
#line 62
int WebPRescalerGetScaledDimensions(int src_width , int src_height , int * const  scaled_width ,
                                    int * const  scaled_height ) ;
#line 68
int WebPRescaleNeededLines(WebPRescaler * const  rescaler , int max_num_lines ) ;
#line 73
int WebPRescalerImport(WebPRescaler * const  rescaler , int num_rows , uint8_t *src ,
                       int src_stride ) ;
#line 77
int WebPRescalerExport(WebPRescaler * const  rescaler ) ;
#line 81 "../../src/utils/rescaler_utils.h"
__inline static int WebPRescalerInputDone(WebPRescaler *rescaler ) 
{ 


  {
#line 82
  return (rescaler->src_y >= rescaler->src_height);
}
}
#line 86 "../../src/utils/rescaler_utils.h"
__inline static int WebPRescalerOutputDone(WebPRescaler *rescaler ) 
{ 


  {
#line 87
  return (rescaler->dst_y >= rescaler->dst_height);
}
}
#line 92 "../../src/utils/rescaler_utils.h"
__inline static int WebPRescalerHasPendingOutput(WebPRescaler *rescaler ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 93
  __cil_tmp2 = WebPRescalerOutputDone(rescaler);
  }
#line 93
  return (! __cil_tmp2 && rescaler->y_accum <= 0);
}
}
#line 30 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static void PictureGrabSpecs(WebPPicture *src , WebPPicture *dst ) 
{ 


  {
  {
#line 33
  *dst = *src;
#line 34
  WebPPictureResetBuffers(dst);
  }
  return;
}
}
#line 40 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static void SnapTopLeftPosition(WebPPicture *pic , int *left , int *top ) 
{ 


  {
#line 42
  if (! pic->use_argb) {
#line 43
    *left &= ~ 1;
#line 44
    *top &= ~ 1;
  }
  return;
}
}
#line 49 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static int AdjustAndCheckRectangle(WebPPicture *pic , int *left , int *top , int width ,
                                   int height ) 
{ 


  {
  {
#line 52
  SnapTopLeftPosition(pic, left, top);
  }
#line 53
  if (*left < 0) {
#line 53
    return (0);
  } else
#line 53
  if (*top < 0) {
#line 53
    return (0);
  }
#line 54
  if (width <= 0) {
#line 54
    return (0);
  } else
#line 54
  if (height <= 0) {
#line 54
    return (0);
  }
#line 55
  if (*left + width > pic->width) {
#line 55
    return (0);
  }
#line 56
  if (*top + height > pic->height) {
#line 56
    return (0);
  }
#line 57
  return (1);
}
}
#line 61 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) 
{ 
  int __cil_tmp3 ;

  {
#line 62
  if (src == (void *)0) {
#line 62
    return (0);
  } else
#line 62
  if (dst == (void *)0) {
#line 62
    return (0);
  }
#line 63
  if (src == dst) {
#line 63
    return (1);
  }
  {
#line 65
  PictureGrabSpecs(src, dst);
#line 66
  __cil_tmp3 = WebPPictureAlloc(dst);
  }
#line 66
  if (! __cil_tmp3) {
#line 66
    return (0);
  }
#line 68
  if (! src->use_argb) {
    {
#line 69
    WebPCopyPlane(src->y, src->y_stride, dst->y, dst->y_stride, dst->width, dst->height);
#line 71
    WebPCopyPlane(src->u, src->uv_stride, dst->u, dst->uv_stride, (dst->width + 1) >> 1,
                  (dst->height + 1) >> 1);
#line 73
    WebPCopyPlane(src->v, src->uv_stride, dst->v, dst->uv_stride, (dst->width + 1) >> 1,
                  (dst->height + 1) >> 1);
    }
#line 75
    if (dst->a != (void *)0) {
      {
#line 76
      WebPCopyPlane(src->a, src->a_stride, dst->a, dst->a_stride, dst->width, dst->height);
      }
    }
  } else {
    {
#line 80
    WebPCopyPlane((uint8_t *)src->argb, 4 * src->argb_stride, (uint8_t *)dst->argb,
                  4 * dst->argb_stride, 4 * dst->width, dst->height);
    }
  }
#line 84
  return (1);
}
}
#line 88 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
int WebPPictureIsView(WebPPicture *picture ) 
{ 


  {
#line 89
  if (picture == (void *)0) {
#line 89
    return (0);
  }
#line 90
  if (picture->use_argb) {
#line 91
    return (picture->memory_argb_ == (void *)0);
  }
#line 93
  return (picture->memory_ == (void *)0);
}
}
#line 96 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) 
{ 
  int __cil_tmp7 ;

  {
#line 99
  if (src == (void *)0) {
#line 99
    return (0);
  } else
#line 99
  if (dst == (void *)0) {
#line 99
    return (0);
  }
  {
#line 102
  __cil_tmp7 = AdjustAndCheckRectangle(src, & left, & top, width, height);
  }
#line 102
  if (! __cil_tmp7) {
#line 102
    return (0);
  }
#line 104
  if (src != dst) {
    {
#line 105
    PictureGrabSpecs(src, dst);
    }
  }
#line 107
  dst->width = width;
#line 108
  dst->height = height;
#line 109
  if (! src->use_argb) {
#line 110
    dst->y = (src->y + top * src->y_stride) + left;
#line 111
    dst->u = (src->u + (top >> 1) * src->uv_stride) + (left >> 1);
#line 112
    dst->v = (src->v + (top >> 1) * src->uv_stride) + (left >> 1);
#line 113
    dst->y_stride = src->y_stride;
#line 114
    dst->uv_stride = src->uv_stride;
#line 115
    if (src->a != (void *)0) {
#line 116
      dst->a = (src->a + top * src->a_stride) + left;
#line 117
      dst->a_stride = src->a_stride;
    }
  } else {
#line 120
    dst->argb = (src->argb + top * src->argb_stride) + left;
#line 121
    dst->argb_stride = src->argb_stride;
  }
#line 123
  return (1);
}
}
#line 130 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int y_offset ;
  int uv_offset ;
  int a_offset ;
  uint8_t *src ;

  {
#line 134
  if (pic == (void *)0) {
#line 134
    return (0);
  }
  {
#line 135
  __cil_tmp7 = AdjustAndCheckRectangle(pic, & left, & top, width, height);
  }
#line 135
  if (! __cil_tmp7) {
#line 135
    return (0);
  }
  {
#line 137
  PictureGrabSpecs(pic, & tmp);
#line 138
  tmp.width = width;
#line 139
  tmp.height = height;
#line 140
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 140
  if (! __cil_tmp8) {
    {
#line 141
    __cil_tmp9 = WebPEncodingSetError(pic, tmp.error_code);
    }
#line 141
    return (__cil_tmp9);
  }
#line 144
  if (! pic->use_argb) {
    {
#line 145
    y_offset = top * pic->y_stride + left;
#line 146
    uv_offset = (top / 2) * pic->uv_stride + left / 2;
#line 147
    WebPCopyPlane(pic->y + y_offset, pic->y_stride, tmp.y, tmp.y_stride, width, height);
#line 149
    WebPCopyPlane(pic->u + uv_offset, pic->uv_stride, tmp.u, tmp.uv_stride, (width + 1) >> 1,
                  (height + 1) >> 1);
#line 151
    WebPCopyPlane(pic->v + uv_offset, pic->uv_stride, tmp.v, tmp.uv_stride, (width + 1) >> 1,
                  (height + 1) >> 1);
    }
#line 154
    if (tmp.a != (void *)0) {
      {
#line 155
      a_offset = top * pic->a_stride + left;
#line 156
      WebPCopyPlane(pic->a + a_offset, pic->a_stride, tmp.a, tmp.a_stride, width,
                    height);
      }
    }
  } else {
    {
#line 160
    src = (uint8_t *)((pic->argb + top * pic->argb_stride) + left);
#line 162
    WebPCopyPlane(src, pic->argb_stride * 4, (uint8_t *)tmp.argb, tmp.argb_stride * 4,
                  width * 4, height);
    }
  }
  {
#line 165
  WebPPictureFree(pic);
#line 166
  *pic = tmp;
  }
#line 167
  return (1);
}
}
#line 173 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static int RescalePlane(uint8_t *src , int src_width , int src_height , int src_stride ,
                        uint8_t *dst , int dst_width , int dst_height , int dst_stride ,
                        rescaler_t *work , int num_channels ) 
{ 
  WebPRescaler rescaler ;
  int y ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 180
  y = 0;
#line 181
  __cil_tmp13 = WebPRescalerInit(& rescaler, src_width, src_height, dst, dst_width,
                                 dst_height, dst_stride, num_channels, work);
  }
#line 181
  if (! __cil_tmp13) {
#line 184
    return (0);
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (y < src_height)) {
#line 186
      goto while_break;
    }
    {
#line 187
    __cil_tmp14 = WebPRescalerImport(& rescaler, src_height - y, src + y * src_stride,
                                     src_stride);
    }
    {
#line 187
    y += __cil_tmp14;
#line 189
    WebPRescalerExport(& rescaler);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (1);
}
}
#line 194 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static void AlphaMultiplyARGB(WebPPicture *pic , int inverse ) 
{ 


  {
  {
#line 196
  WebPMultARGBRows((uint8_t *)pic->argb, (int )((unsigned long )pic->argb_stride * sizeof(*(pic->argb))),
                   pic->width, pic->height, inverse);
  }
  return;
}
}
#line 200 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
static void AlphaMultiplyY(WebPPicture *pic , int inverse ) 
{ 


  {
#line 201
  if (pic->a != (void *)0) {
    {
#line 202
    WebPMultRows(pic->y, pic->y_stride, pic->a, pic->a_stride, pic->width, pic->height,
                 inverse);
    }
  }
  return;
}
}
#line 207 "/doner/libwebp/libwebp-31bea324/src/enc/picture_rescale_enc.c"
int WebPPictureRescale(WebPPicture *picture , int width , int height ) 
{ 
  WebPPicture tmp ;
  int prev_width ;
  int prev_height ;
  rescaler_t *work ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
#line 212
  if (picture == (void *)0) {
#line 212
    return (0);
  }
  {
#line 213
  prev_width = picture->width;
#line 214
  prev_height = picture->height;
#line 215
  __cil_tmp8 = WebPRescalerGetScaledDimensions(prev_width, prev_height, & width, & height);
  }
#line 215
  if (! __cil_tmp8) {
    {
#line 217
    __cil_tmp9 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
#line 217
    return (__cil_tmp9);
  }
  {
#line 220
  PictureGrabSpecs(picture, & tmp);
#line 221
  tmp.width = width;
#line 222
  tmp.height = height;
#line 223
  __cil_tmp10 = WebPPictureAlloc(& tmp);
  }
#line 223
  if (! __cil_tmp10) {
    {
#line 224
    __cil_tmp11 = WebPEncodingSetError(picture, tmp.error_code);
    }
#line 224
    return (__cil_tmp11);
  }
#line 227
  if (! picture->use_argb) {
    {
#line 228
    __cil_tmp12 = WebPSafeMalloc((uint64_t )(2ULL * (unsigned long long )width), sizeof(*work));
#line 228
    work = (rescaler_t *)__cil_tmp12;
    }
#line 229
    if (work == (void *)0) {
      {
#line 230
      WebPPictureFree(& tmp);
#line 231
      __cil_tmp13 = WebPEncodingSetError(picture, (WebPEncodingError )1);
      }
#line 231
      return (__cil_tmp13);
    }
#line 234
    if (picture->a != (void *)0) {
      {
#line 235
      WebPInitAlphaProcessing();
#line 236
      __cil_tmp14 = RescalePlane(picture->a, prev_width, prev_height, picture->a_stride,
                                 tmp.a, width, height, tmp.a_stride, work, 1);
      }
#line 236
      if (! __cil_tmp14) {
        {
#line 238
        __cil_tmp15 = WebPEncodingSetError(picture, (WebPEncodingError )5);
        }
#line 238
        return (__cil_tmp15);
      }
    }
    {
#line 244
    AlphaMultiplyY(picture, 0);
#line 245
    __cil_tmp18 = RescalePlane(picture->v, (prev_width + 1) >> 1, (prev_height + 1) >> 1,
                               picture->uv_stride, tmp.v, (width + 1) >> 1, (height + 1) >> 1,
                               tmp.uv_stride, work, 1);
    }
    {
#line 245
    __cil_tmp17 = RescalePlane(picture->u, (prev_width + 1) >> 1, (prev_height + 1) >> 1,
                               picture->uv_stride, tmp.u, (width + 1) >> 1, (height + 1) >> 1,
                               tmp.uv_stride, work, 1);
    }
    {
#line 245
    __cil_tmp16 = RescalePlane(picture->y, prev_width, prev_height, picture->y_stride,
                               tmp.y, width, height, tmp.y_stride, work, 1);
    }
#line 245
    if (! __cil_tmp16) {
      {
      {
      {
#line 253
      __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
      }
      }
      }
#line 253
      return (__cil_tmp19);
    } else
#line 245
    if (! __cil_tmp17) {
      {
      {
      {
#line 253
      __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
      }
      }
      }
#line 253
      return (__cil_tmp19);
    } else
#line 245
    if (! __cil_tmp18) {
      {
      {
      {
#line 253
      __cil_tmp19 = WebPEncodingSetError(picture, (WebPEncodingError )5);
      }
      }
      }
#line 253
      return (__cil_tmp19);
    }
    {
#line 255
    AlphaMultiplyY(& tmp, 1);
    }
  } else {
    {
#line 257
    __cil_tmp20 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * 4ULL),
                                 sizeof(*work));
#line 257
    work = (rescaler_t *)__cil_tmp20;
    }
#line 258
    if (work == (void *)0) {
      {
#line 259
      WebPPictureFree(& tmp);
#line 260
      __cil_tmp21 = WebPEncodingSetError(picture, (WebPEncodingError )1);
      }
#line 260
      return (__cil_tmp21);
    }
    {
#line 265
    WebPInitAlphaProcessing();
#line 266
    AlphaMultiplyARGB(picture, 0);
#line 267
    __cil_tmp22 = RescalePlane((uint8_t *)picture->argb, prev_width, prev_height,
                               picture->argb_stride * 4, (uint8_t *)tmp.argb, width,
                               height, tmp.argb_stride * 4, work, 4);
    }
#line 267
    if (! __cil_tmp22) {
      {
#line 270
      __cil_tmp23 = WebPEncodingSetError(picture, (WebPEncodingError )5);
      }
#line 270
      return (__cil_tmp23);
    }
    {
#line 272
    AlphaMultiplyARGB(& tmp, 1);
    }
  }
  {
#line 274
  WebPPictureFree(picture);
#line 275
  WebPSafeFree(work);
#line 276
  *picture = tmp;
  }
#line 277
  return (1);
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 37 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double AccumulateLSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                             int w , int h ) 
{ 
  int x ;
  int y ;
  double total_sse ;
  int y_0 ;
  int tmp ;
  int y_1 ;
  int tmp___0 ;
  int x_0 ;
  int tmp___1 ;
  int x_1 ;
  int tmp___2 ;
  double best_sse ;
  double value ;
  int i ;
  int j ;
  uint8_t *s ;
  double diff ;
  double sse ;

  {
#line 41
  total_sse = 0.;
#line 42
  y = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (y < h)) {
#line 42
      goto while_break;
    }
#line 43
    if (y - 2 < 0) {
#line 43
      tmp = 0;
    } else {
#line 43
      tmp = y - 2;
    }
#line 43
    y_0 = tmp;
#line 44
    if ((y + 2) + 1 >= h) {
#line 44
      tmp___0 = h;
    } else {
#line 44
      tmp___0 = (y + 2) + 1;
    }
#line 44
    y_1 = tmp___0;
#line 45
    x = 0;
    {
#line 45
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 45
      if (! (x < w)) {
#line 45
        goto while_break___0;
      }
#line 46
      if (x - 2 < 0) {
#line 46
        tmp___1 = 0;
      } else {
#line 46
        tmp___1 = x - 2;
      }
#line 46
      x_0 = tmp___1;
#line 47
      if ((x + 2) + 1 >= w) {
#line 47
        tmp___2 = w;
      } else {
#line 47
        tmp___2 = (x + 2) + 1;
      }
#line 47
      x_1 = tmp___2;
#line 48
      best_sse = 255. * 255.;
#line 49
      value = (double )*(ref + (y * ref_stride + x));
#line 51
      j = y_0;
      {
#line 51
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 51
        if (! (j < y_1)) {
#line 51
          goto while_break___1;
        }
#line 52
        s = src + j * src_stride;
#line 53
        i = x_0;
        {
#line 53
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 53
          if (! (i < x_1)) {
#line 53
            goto while_break___2;
          }
#line 54
          diff = (double )((int )*(s + i)) - value;
#line 55
          sse = diff * diff;
#line 56
          if (sse < best_sse) {
#line 56
            best_sse = sse;
          }
#line 53
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 51
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 59
      total_sse += best_sse;
#line 45
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 42
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (total_sse);
}
}
#line 66 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double AccumulateSSE(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                            int w , int h ) 
{ 
  int y ;
  double total_sse ;
  uint32_t __cil_tmp9 ;

  {
#line 70
  total_sse = 0.;
#line 71
  y = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (y < h)) {
#line 71
      goto while_break;
    }
    {
#line 72
    __cil_tmp9 = (*VP8AccumulateSSE)(src, ref, w);
    }
#line 72
    total_sse += (double )__cil_tmp9;
#line 73
    src += src_stride;
#line 74
    ref += ref_stride;
#line 71
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (total_sse);
}
}
#line 81 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double AccumulateSSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                             int w , int h ) 
{ 
  int w0 ;
  int tmp ;
  int w1 ;
  int h0 ;
  int tmp___0 ;
  int h1 ;
  int x ;
  int y ;
  double sum ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;
  int off1 ;
  int off2 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;

  {
#line 84
  if (w < 3) {
#line 84
    tmp = w;
  } else {
#line 84
    tmp = 3;
  }
#line 84
  w0 = tmp;
#line 85
  w1 = (w - 3) - 1;
#line 86
  if (h < 3) {
#line 86
    tmp___0 = h;
  } else {
#line 86
    tmp___0 = 3;
  }
#line 86
  h0 = tmp___0;
#line 87
  h1 = (h - 3) - 1;
#line 89
  sum = 0.;
#line 90
  y = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (y < h0)) {
#line 90
      goto while_break;
    }
#line 91
    x = 0;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! (x < w)) {
#line 91
        goto while_break___0;
      }
      {
#line 92
      __cil_tmp16 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
      }
#line 92
      sum += __cil_tmp16;
#line 91
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 90
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 95
    if (! (y < h1)) {
#line 95
      goto while_break___1;
    }
#line 96
    x = 0;
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 96
      if (! (x < w0)) {
#line 96
        goto while_break___2;
      }
      {
#line 97
      __cil_tmp17 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
      }
#line 97
      sum += __cil_tmp17;
#line 96
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 99
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 99
      if (! (x < w1)) {
#line 99
        goto while_break___3;
      }
      {
#line 100
      off1 = (x - 3) + (y - 3) * src_stride;
#line 101
      off2 = (x - 3) + (y - 3) * ref_stride;
#line 102
      __cil_tmp20 = (*VP8SSIMGet)(src + off1, src_stride, ref + off2, ref_stride);
      }
#line 102
      sum += __cil_tmp20;
#line 99
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 104
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 104
      if (! (x < w)) {
#line 104
        goto while_break___4;
      }
      {
#line 105
      __cil_tmp21 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
      }
#line 105
      sum += __cil_tmp21;
#line 104
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 95
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 108
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 108
    if (! (y < h)) {
#line 108
      goto while_break___5;
    }
#line 109
    x = 0;
    {
#line 109
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 109
      if (! (x < w)) {
#line 109
        goto while_break___6;
      }
      {
#line 110
      __cil_tmp22 = (*VP8SSIMGetClipped)(src, src_stride, ref, ref_stride, x, y, w,
                                         h);
      }
#line 110
      sum += __cil_tmp22;
#line 109
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 108
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 113
  return (sum);
}
}
#line 120 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double const   kMinDistortion_dB  =    99.;
#line 122 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double GetPSNR(double v , double size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 123
  if (v > 0. && size > 0.) {
    {
#line 123
    __cil_tmp3 = log(v / ((size * (double )255) * 255.));
#line 123
    tmp = - 4.3429448 * __cil_tmp3;
    }
  } else {
#line 123
    tmp = (double )kMinDistortion_dB;
  }
#line 123
  return ((int )tmp);
}
}
#line 127 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
static double GetLogSSIM(double v , double size ) 
{ 
  double tmp ;
  double __cil_tmp4 ;
  double tmp___0 ;

  {
#line 128
  if (size > 0.) {
#line 128
    tmp = v / size;
  } else {
#line 128
    tmp = 1.;
  }
#line 128
  v = tmp;
#line 129
  if (v < 1.) {
    {
#line 129
    __cil_tmp4 = log10(1. - v);
#line 129
    tmp___0 = - 10. * __cil_tmp4;
    }
  } else {
#line 129
    tmp___0 = (double )kMinDistortion_dB;
  }
#line 129
  return ((int )tmp___0);
}
}
#line 132 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
int WebPPlaneDistortion(uint8_t *src , size_t src_stride , uint8_t *ref , size_t ref_stride ,
                        int width , int height , size_t x_step , int type , float *distortion ,
                        float *result ) 
{ 
  uint8_t *allocated ;
  AccumulateFunc metric ;
  double (*tmp)(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride , int w ,
                int h ) ;
  double (*tmp___0)(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                    int w , int h ) ;
  int x ;
  int y ;
  uint8_t *tmp1 ;
  uint8_t *tmp2 ;
  void *__cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  float tmp___1 ;

  {
#line 136
  allocated = (uint8_t *)((void *)0);
#line 137
  if (type == 0) {
#line 137
    tmp___0 = & AccumulateSSE;
  } else {
#line 137
    if (type == 1) {
#line 137
      tmp = & AccumulateSSIM;
    } else {
#line 137
      tmp = & AccumulateLSIM;
    }
#line 137
    tmp___0 = tmp;
  }
#line 137
  metric = tmp___0;
#line 140
  if (src == (void *)0) {
#line 143
    return (0);
  } else
#line 140
  if (ref == (void *)0) {
#line 143
    return (0);
  } else
#line 140
  if (src_stride < x_step * (unsigned long )width) {
#line 143
    return (0);
  } else
#line 140
  if (ref_stride < x_step * (unsigned long )width) {
#line 143
    return (0);
  } else
#line 140
  if (result == (void *)0) {
#line 143
    return (0);
  } else
#line 140
  if (distortion == (void *)0) {
#line 143
    return (0);
  }
  {
#line 146
  VP8SSIMDspInit();
  }
#line 147
  if (x_step != 1UL) {
    {
#line 151
    __cil_tmp19 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * (unsigned long long )height),
                                 sizeof(*allocated));
#line 151
    allocated = (uint8_t *)__cil_tmp19;
    }
#line 153
    if (allocated == (void *)0) {
#line 153
      return (0);
    }
#line 154
    tmp1 = allocated;
#line 155
    tmp2 = tmp1 + (size_t )width * (unsigned long )height;
#line 156
    y = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (y < height)) {
#line 156
        goto while_break;
      }
#line 157
      x = 0;
      {
#line 157
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 157
        if (! (x < width)) {
#line 157
          goto while_break___0;
        }
#line 158
        *(tmp1 + (x + y * width)) = *(src + ((unsigned long )x * x_step + (unsigned long )y * src_stride));
#line 159
        *(tmp2 + (x + y * width)) = *(ref + ((unsigned long )x * x_step + (unsigned long )y * ref_stride));
#line 157
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 156
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 162
    src = tmp1;
#line 163
    ref = tmp2;
  }
  {
#line 165
  __cil_tmp20 = (*metric)(src, width, ref, width, width, height);
#line 165
  *distortion = (float )__cil_tmp20;
#line 166
  WebPSafeFree(allocated);
  }
#line 168
  if (type == 1) {
    {
#line 168
    __cil_tmp21 = GetLogSSIM((double )*distortion, (double )width * (double )height);
#line 168
    tmp___1 = (float )__cil_tmp21;
    }
  } else {
    {
#line 168
    __cil_tmp22 = GetPSNR((double )*distortion, (double )width * (double )height);
#line 168
    tmp___1 = (float )__cil_tmp22;
    }
  }
#line 168
  *result = tmp___1;
#line 170
  return (1);
}
}
#line 179 "/doner/libwebp/libwebp-31bea324/src/enc/picture_psnr_enc.c"
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float results[5] ) 
{ 
  int w ;
  int h ;
  int c ;
  int ok ;
  WebPPicture p0 ;
  WebPPicture p1 ;
  double total_size ;
  double total_distortion ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  float distortion ;
  size_t stride0 ;
  size_t stride1 ;
  int offset ;
  int __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  float tmp ;

  {
#line 182
  ok = 0;
#line 184
  total_size = 0.;
#line 184
  total_distortion = 0.;
#line 185
  if (src == (void *)0) {
#line 188
    return (0);
  } else
#line 185
  if (ref == (void *)0) {
#line 188
    return (0);
  } else
#line 185
  if (src->width != ref->width) {
#line 188
    return (0);
  } else
#line 185
  if (src->height != ref->height) {
#line 188
    return (0);
  } else
#line 185
  if (results == (void *)0) {
#line 188
    return (0);
  }
  {
#line 191
  VP8SSIMDspInit();
#line 192
  __cil_tmp14 = WebPPictureInit(& p1);
  }
  {
#line 192
  __cil_tmp13 = WebPPictureInit(& p0);
  }
#line 192
  if (! __cil_tmp13) {
#line 192
    return (0);
  } else
#line 192
  if (! __cil_tmp14) {
#line 192
    return (0);
  }
  {
#line 193
  w = src->width;
#line 194
  h = src->height;
#line 195
  __cil_tmp15 = WebPPictureView(src, 0, 0, w, h, & p0);
  }
#line 195
  if (! __cil_tmp15) {
#line 195
    goto Error;
  }
  {
#line 196
  __cil_tmp16 = WebPPictureView(ref, 0, 0, w, h, & p1);
  }
#line 196
  if (! __cil_tmp16) {
#line 196
    goto Error;
  }
  {
#line 199
  __cil_tmp17 = WebPPictureYUVAToARGB(& p0);
  }
#line 199
  if (p0.use_argb == 0) {
#line 199
    if (! __cil_tmp17) {
#line 199
      goto Error;
    }
  }
  {
#line 200
  __cil_tmp18 = WebPPictureYUVAToARGB(& p1);
  }
#line 200
  if (p1.use_argb == 0) {
#line 200
    if (! __cil_tmp18) {
#line 200
      goto Error;
    }
  }
#line 201
  c = 0;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (c < 4)) {
#line 201
      goto while_break;
    }
    {
#line 203
    stride0 = 4UL * (size_t )p0.argb_stride;
#line 204
    stride1 = 4UL * (size_t )p1.argb_stride;
#line 206
    offset = c;
#line 207
    __cil_tmp23 = WebPPlaneDistortion((uint8_t *)p0.argb + offset, stride0, (uint8_t *)p1.argb + offset,
                                      stride1, w, h, (size_t )4, type, & distortion,
                                      results + c);
    }
#line 207
    if (! __cil_tmp23) {
#line 210
      goto Error;
    }
#line 212
    total_distortion += (double )distortion;
#line 213
    total_size += (double )(w * h);
#line 201
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if (type == 1) {
    {
#line 216
    __cil_tmp24 = GetLogSSIM(total_distortion, total_size);
#line 216
    tmp = (float )__cil_tmp24;
    }
  } else {
    {
#line 216
    __cil_tmp25 = GetPSNR(total_distortion, total_size);
#line 216
    tmp = (float )__cil_tmp25;
    }
  }
#line 216
  results[4] = tmp;
#line 218
  ok = 1;
  Error: 
  {
#line 221
  WebPPictureFree(& p0);
  }
  {
#line 222
  WebPPictureFree(& p1);
  }
#line 223
  return (ok);
}
}
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size(__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 25 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
static int DummyWriter(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 


  {
#line 31
  return (1);
}
}
#line 34 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPPictureInitInternal(WebPPicture *picture , int version ) 
{ 


  {
#line 35
  if (version >> 8 != 527 >> 8) {
#line 36
    return (0);
  }
#line 38
  if (picture != (void *)0) {
    {
#line 39
    memset(picture, 0, sizeof(*picture));
#line 40
    picture->writer = & DummyWriter;
#line 41
    WebPEncodingSetError(picture, (WebPEncodingError )0);
    }
  }
#line 43
  return (1);
}
}
#line 48 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPValidatePicture(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 49
  if (picture == (void *)0) {
#line 49
    return (0);
  }
#line 50
  if (picture->width <= 0) {
    {
    {
#line 51
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
#line 51
    return (__cil_tmp2);
  } else
#line 50
  if (picture->height <= 0) {
    {
    {
#line 51
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
#line 51
    return (__cil_tmp2);
  }
#line 53
  if (picture->width <= 0) {
    {
    {
    {
    {
#line 55
    __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 55
    return (__cil_tmp3);
  } else
#line 53
  if (picture->width / 4 > 536870911) {
    {
    {
    {
    {
#line 55
    __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 55
    return (__cil_tmp3);
  } else
#line 53
  if (picture->height <= 0) {
    {
    {
    {
    {
#line 55
    __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 55
    return (__cil_tmp3);
  } else
#line 53
  if (picture->height / 4 > 536870911) {
    {
    {
    {
    {
#line 55
    __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 55
    return (__cil_tmp3);
  }
#line 57
  if ((unsigned int )picture->colorspace != 0U) {
#line 57
    if ((unsigned int )picture->colorspace != 4U) {
      {
#line 59
      __cil_tmp4 = WebPEncodingSetError(picture, (WebPEncodingError )4);
      }
#line 59
      return (__cil_tmp4);
    }
  }
#line 61
  return (1);
}
}
#line 64 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
static void WebPPictureResetBufferARGB(WebPPicture *picture ) 
{ 


  {
#line 65
  picture->memory_argb_ = (void *)0;
#line 66
  picture->argb = (uint32_t *)((void *)0);
#line 67
  picture->argb_stride = 0;
  return;
}
}
#line 70 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
static void WebPPictureResetBufferYUVA(WebPPicture *picture ) 
{ 


  {
#line 71
  picture->memory_ = (void *)0;
#line 72
  picture->a = (uint8_t *)((void *)0);
#line 72
  picture->v = picture->a;
#line 72
  picture->u = picture->v;
#line 72
  picture->y = picture->u;
#line 73
  picture->uv_stride = 0;
#line 73
  picture->y_stride = picture->uv_stride;
#line 74
  picture->a_stride = 0;
  return;
}
}
#line 77 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
void WebPPictureResetBuffers(WebPPicture *picture ) 
{ 


  {
  {
#line 78
  WebPPictureResetBufferARGB(picture);
#line 79
  WebPPictureResetBufferYUVA(picture);
  }
  return;
}
}
#line 82 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPPictureAllocARGB(WebPPicture *picture ) 
{ 
  void *memory ;
  int width ;
  int height ;
  uint64_t argb_size ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 84
  width = picture->width;
#line 85
  height = picture->height;
#line 86
  argb_size = (uint64_t )width * (unsigned long )height;
#line 88
  __cil_tmp6 = WebPValidatePicture(picture);
  }
#line 88
  if (! __cil_tmp6) {
#line 88
    return (0);
  }
  {
#line 90
  WebPSafeFree(picture->memory_argb_);
#line 91
  WebPPictureResetBufferARGB(picture);
#line 94
  memory = WebPSafeMalloc(argb_size + 31UL, sizeof(*(picture->argb)));
  }
#line 95
  if (memory == (void *)0) {
    {
#line 96
    __cil_tmp8 = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 96
    return (__cil_tmp8);
  }
#line 98
  picture->memory_argb_ = memory;
#line 99
  picture->argb = (uint32_t *)(((uintptr_t )memory + 31UL) & 0xffffffffffffffe0UL);
#line 100
  picture->argb_stride = width;
#line 101
  return (1);
}
}
#line 104 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPPictureAllocYUVA(WebPPicture *picture ) 
{ 
  int has_alpha ;
  int width ;
  int height ;
  int y_stride ;
  int uv_width ;
  int uv_height ;
  int uv_stride ;
  int a_width ;
  int a_stride ;
  uint64_t y_size ;
  uint64_t uv_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  uint8_t *mem ;
  int __cil_tmp16 ;
  int tmp ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 105
  has_alpha = (int )picture->colorspace & 4;
#line 106
  width = picture->width;
#line 107
  height = picture->height;
#line 108
  y_stride = width;
#line 109
  uv_width = (int )(((int64_t )width + 1L) >> 1);
#line 110
  uv_height = (int )(((int64_t )height + 1L) >> 1);
#line 111
  uv_stride = uv_width;
#line 116
  __cil_tmp16 = WebPValidatePicture(picture);
  }
#line 116
  if (! __cil_tmp16) {
#line 116
    return (0);
  }
  {
#line 118
  WebPSafeFree(picture->memory_);
#line 119
  WebPPictureResetBufferYUVA(picture);
  }
#line 122
  if (has_alpha) {
#line 122
    tmp = width;
  } else {
#line 122
    tmp = 0;
  }
#line 122
  a_width = tmp;
#line 123
  a_stride = a_width;
#line 124
  y_size = (uint64_t )y_stride * (unsigned long )height;
#line 125
  uv_size = (uint64_t )uv_stride * (unsigned long )uv_height;
#line 126
  a_size = (uint64_t )a_stride * (unsigned long )height;
#line 128
  total_size = (y_size + a_size) + 2UL * uv_size;
#line 131
  if (width <= 0) {
    {
    {
    {
    {
#line 133
    __cil_tmp18 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 133
    return (__cil_tmp18);
  } else
#line 131
  if (height <= 0) {
    {
    {
    {
    {
#line 133
    __cil_tmp18 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 133
    return (__cil_tmp18);
  } else
#line 131
  if (uv_width <= 0) {
    {
    {
    {
    {
#line 133
    __cil_tmp18 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 133
    return (__cil_tmp18);
  } else
#line 131
  if (uv_height <= 0) {
    {
    {
    {
    {
#line 133
    __cil_tmp18 = WebPEncodingSetError(picture, (WebPEncodingError )5);
    }
    }
    }
    }
#line 133
    return (__cil_tmp18);
  }
  {
#line 136
  __cil_tmp19 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 136
  mem = (uint8_t *)__cil_tmp19;
  }
#line 137
  if (mem == (void *)0) {
    {
#line 138
    __cil_tmp20 = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 138
    return (__cil_tmp20);
  }
#line 142
  picture->memory_ = (void *)mem;
#line 143
  picture->y_stride = y_stride;
#line 144
  picture->uv_stride = uv_stride;
#line 145
  picture->a_stride = a_stride;
#line 148
  picture->y = mem;
#line 149
  mem += y_size;
#line 151
  picture->u = mem;
#line 152
  mem += uv_size;
#line 153
  picture->v = mem;
#line 154
  mem += uv_size;
#line 156
  if (a_size > 0UL) {
#line 157
    picture->a = mem;
#line 158
    mem += a_size;
  }
#line 161
  return (1);
}
}
#line 164 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPPictureAlloc(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 165
  if (picture != (void *)0) {
    {
#line 166
    WebPPictureFree(picture);
    }
#line 168
    if (! picture->use_argb) {
      {
#line 169
      __cil_tmp2 = WebPPictureAllocYUVA(picture);
      }
#line 169
      return (__cil_tmp2);
    } else {
      {
#line 171
      __cil_tmp3 = WebPPictureAllocARGB(picture);
      }
#line 171
      return (__cil_tmp3);
    }
  }
#line 174
  return (1);
}
}
#line 177 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
void WebPPictureFree(WebPPicture *picture ) 
{ 


  {
#line 178
  if (picture != (void *)0) {
    {
#line 179
    WebPSafeFree(picture->memory_);
#line 180
    WebPSafeFree(picture->memory_argb_);
#line 181
    WebPPictureResetBuffers(picture);
    }
  }
  return;
}
}
#line 188 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) 
{ 


  {
#line 189
  writer->mem = (uint8_t *)((void *)0);
#line 190
  writer->size = (size_t )0;
#line 191
  writer->max_size = (size_t )0;
  return;
}
}
#line 194 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 
  WebPMemoryWriter *w ;
  uint64_t next_size ;
  uint8_t *new_mem ;
  uint64_t next_max_size ;
  void *__cil_tmp8 ;

  {
#line 196
  w = (WebPMemoryWriter *)picture->custom_ptr;
#line 198
  if (w == (void *)0) {
#line 199
    return (1);
  }
#line 201
  next_size = (uint64_t )w->size + data_size;
#line 202
  if (next_size > w->max_size) {
#line 204
    next_max_size = (uint64_t )(2ULL * (unsigned long long )w->max_size);
#line 205
    if (next_max_size < next_size) {
#line 205
      next_max_size = next_size;
    }
#line 206
    if ((unsigned long long )next_max_size < 8192ULL) {
#line 206
      next_max_size = (uint64_t )8192ULL;
    }
    {
#line 207
    __cil_tmp8 = WebPSafeMalloc(next_max_size, (size_t )1);
#line 207
    new_mem = (uint8_t *)__cil_tmp8;
    }
#line 208
    if (new_mem == (void *)0) {
#line 209
      return (0);
    }
#line 211
    if (w->size > 0UL) {
      {
#line 212
      memcpy(new_mem, w->mem, w->size);
      }
    }
    {
#line 214
    WebPSafeFree(w->mem);
#line 215
    w->mem = new_mem;
#line 217
    w->max_size = (size_t )next_max_size;
    }
  }
#line 219
  if (data_size > 0UL) {
    {
#line 220
    memcpy(w->mem + w->size, data, data_size);
#line 221
    w->size += data_size;
    }
  }
#line 223
  return (1);
}
}
#line 226 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
void WebPMemoryWriterClear(WebPMemoryWriter *writer ) 
{ 


  {
#line 227
  if (writer != (void *)0) {
    {
#line 228
    WebPSafeFree(writer->mem);
#line 229
    writer->mem = (uint8_t *)((void *)0);
#line 230
    writer->size = (size_t )0;
#line 231
    writer->max_size = (size_t )0;
    }
  }
  return;
}
}
#line 240 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
static size_t Encode(uint8_t *rgba , int width , int height , int stride , Importer import ,
                     float quality_factor , int lossless , uint8_t **output ) 
{ 
  WebPPicture pic ;
  WebPConfig config ;
  WebPMemoryWriter wrt ;
  int ok ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 248
  if (output == (void *)0) {
#line 248
    return ((size_t )0);
  }
  {
#line 250
  __cil_tmp14 = WebPPictureInit(& pic);
  }
  {
#line 250
  __cil_tmp13 = WebPConfigPreset(& config, (WebPPreset )0, quality_factor);
  }
#line 250
  if (! __cil_tmp13) {
#line 252
    return ((size_t )0);
  } else
#line 250
  if (! __cil_tmp14) {
#line 252
    return ((size_t )0);
  }
  {
#line 255
  config.lossless = ! (! lossless);
#line 256
  pic.use_argb = ! (! lossless);
#line 257
  pic.width = width;
#line 258
  pic.height = height;
#line 259
  pic.writer = & WebPMemoryWrite;
#line 260
  pic.custom_ptr = & wrt;
#line 261
  WebPMemoryWriterInit(& wrt);
#line 263
  __cil_tmp16 = WebPEncode(& config, & pic);
  }
  {
#line 263
  __cil_tmp15 = (*import)(& pic, rgba, stride);
#line 263
  ok = __cil_tmp15 && __cil_tmp16;
#line 264
  WebPPictureFree(& pic);
  }
#line 265
  if (! ok) {
    {
#line 266
    WebPMemoryWriterClear(& wrt);
#line 267
    *output = (uint8_t *)((void *)0);
    }
#line 268
    return ((size_t )0);
  }
#line 270
  *output = wrt.mem;
#line 271
  return (wrt.size);
}
}
#line 280 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 280
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportRGB, q, 0, out);
  }
#line 280
  return (__cil_tmp7);
}
}
#line 281 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 281
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportRGBA, q, 0, out);
  }
#line 281
  return (__cil_tmp7);
}
}
#line 283 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 283
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportBGR, q, 0, out);
  }
#line 283
  return (__cil_tmp7);
}
}
#line 284 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 284
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportBGRA, q, 0, out);
  }
#line 284
  return (__cil_tmp7);
}
}
#line 295 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 295
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportRGB, (float )70., 1, out);
  }
#line 295
  return (__cil_tmp6);
}
}
#line 296 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 296
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportRGBA, (float )70., 1, out);
  }
#line 296
  return (__cil_tmp6);
}
}
#line 298 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 298
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportBGR, (float )70., 1, out);
  }
#line 298
  return (__cil_tmp6);
}
}
#line 299 "/doner/libwebp/libwebp-31bea324/src/enc/picture_enc.c"
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 299
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportBGRA, (float )70., 1, out);
  }
#line 299
  return (__cil_tmp6);
}
}
#line 68 "../../sharpyuv/sharpyuv.h"
extern int SharpYuvGetVersion(void) ;
#line 134
extern int SharpYuvConvert(void const   *r_ptr , void const   *g_ptr , void const   *b_ptr ,
                           int rgb_step , int rgb_stride , int rgb_bit_depth , void *y_ptr ,
                           int y_stride , void *u_ptr , int u_stride , void *v_ptr ,
                           int v_stride , int yuv_bit_depth , int width , int height ,
                           SharpYuvConversionMatrix *yuv_matrix ) ;
#line 150
extern int SharpYuvOptionsInitInternal(SharpYuvConversionMatrix * , SharpYuvOptions * ,
                                       int  ) ;
#line 156 "../../sharpyuv/sharpyuv.h"
__inline static int SharpYuvOptionsInit(SharpYuvConversionMatrix *yuv_matrix , SharpYuvOptions *options ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 158
  __cil_tmp3 = SharpYuvOptionsInitInternal(yuv_matrix, options, 4 << 16);
  }
#line 158
  return (__cil_tmp3);
}
}
#line 161
extern int SharpYuvConvertWithOptions(void const   *r_ptr , void const   *g_ptr ,
                                      void const   *b_ptr , int rgb_step , int rgb_stride ,
                                      int rgb_bit_depth , void *y_ptr , int y_stride ,
                                      void *u_ptr , int u_stride , void *v_ptr , int v_stride ,
                                      int yuv_bit_depth , int width , int height ,
                                      SharpYuvOptions *options ) ;
#line 38 "../../sharpyuv/sharpyuv_csp.h"
extern void SharpYuvComputeConversionMatrix(SharpYuvColorSpace *yuv_color_space ,
                                            SharpYuvConversionMatrix *matrix ) ;
#line 53
extern SharpYuvConversionMatrix *SharpYuvGetConversionMatrix(SharpYuvMatrixType matrix_type ) ;
#line 34 "../../src/utils/random_utils.h"
void VP8InitRandom(VP8Random * const  rg , float dithering ) ;
#line 39 "../../src/utils/random_utils.h"
__inline static int VP8RandomBits2(VP8Random *rg , int num_bits , int amp ) 
{ 
  int diff ;

  {
#line 43
  diff = (int )(rg->tab_[rg->index1_] - rg->tab_[rg->index2_]);
#line 44
  if (diff < 0) {
#line 44
    diff += 1U << 31;
  }
#line 45
  rg->tab_[rg->index1_] = (uint32_t )diff;
#line 46
  (rg->index1_) ++;
#line 46
  if (rg->index1_ == 55) {
#line 46
    rg->index1_ = 0;
  }
#line 47
  (rg->index2_) ++;
#line 47
  if (rg->index2_ == 55) {
#line 47
    rg->index2_ = 0;
  }
#line 49
  diff = (int )((uint32_t )diff << 1) >> (32 - num_bits);
#line 50
  diff = diff * amp >> 8;
#line 51
  diff += 1 << (num_bits - 1);
#line 52
  return (diff);
}
}
#line 55 "../../src/utils/random_utils.h"
__inline static int VP8RandomBits(VP8Random *rg , int num_bits ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 56
  __cil_tmp3 = VP8RandomBits2(rg, num_bits, rg->amp_);
  }
#line 56
  return (__cil_tmp3);
}
}
#line 46 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateCopy(uint32_t distance , uint16_t len ) 
{ 
  PixOrCopy retval ;

  {
#line 49
  retval.mode = (uint8_t )2;
#line 50
  retval.argb_or_distance = distance;
#line 51
  retval.len = len;
#line 52
  return (retval);
}
}
#line 55 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateCacheIdx(int idx ) 
{ 
  PixOrCopy retval ;

  {
#line 59
  retval.mode = (uint8_t )1;
#line 60
  retval.argb_or_distance = (uint32_t )idx;
#line 61
  retval.len = (uint16_t )1;
#line 62
  return (retval);
}
}
#line 65 "../../src/enc/backward_references_enc.h"
__inline static PixOrCopy PixOrCopyCreateLiteral(uint32_t argb ) 
{ 
  PixOrCopy retval ;

  {
#line 67
  retval.mode = (uint8_t )0;
#line 68
  retval.argb_or_distance = argb;
#line 69
  retval.len = (uint16_t )1;
#line 70
  return (retval);
}
}
#line 73 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsLiteral(PixOrCopy *p ) 
{ 


  {
#line 74
  return ((int )p->mode == 0);
}
}
#line 77 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 78
  return ((int )p->mode == 1);
}
}
#line 81 "../../src/enc/backward_references_enc.h"
__inline static int PixOrCopyIsCopy(PixOrCopy *p ) 
{ 


  {
#line 82
  return ((int )p->mode == 2);
}
}
#line 85 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyLiteral(PixOrCopy *p , int component ) 
{ 


  {
#line 88
  return ((p->argb_or_distance >> component * 8) & 255U);
}
}
#line 91 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyLength(PixOrCopy *p ) 
{ 


  {
#line 92
  return ((uint32_t )p->len);
}
}
#line 95 "../../src/enc/backward_references_enc.h"
__inline static uint32_t PixOrCopyCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 98
  return (p->argb_or_distance);
}
}
#line 136
int VP8LHashChainInit(VP8LHashChain * const  p , int size ) ;
#line 138
int VP8LHashChainFill(VP8LHashChain * const  p , int quality , uint32_t * const  argb ,
                      int xsize , int ysize , int low_effort , WebPPicture * const  pic ,
                      int percent_range , int * const  percent ) ;
#line 142
void VP8LHashChainClear(VP8LHashChain * const  p ) ;
#line 144 "../../src/enc/backward_references_enc.h"
__inline static int VP8LHashChainFindOffset(VP8LHashChain *p , int base_position ) 
{ 


  {
#line 146
  return ((int )(*(p->offset_length_ + base_position) >> 12));
}
}
#line 149 "../../src/enc/backward_references_enc.h"
__inline static int VP8LHashChainFindLength(VP8LHashChain *p , int base_position ) 
{ 


  {
#line 151
  return ((int )(*(p->offset_length_ + base_position) & ((1U << 12) - 1U)));
}
}
#line 154 "../../src/enc/backward_references_enc.h"
__inline static void VP8LHashChainFindCopy(VP8LHashChain *p , int base_position ,
                                           int *offset_ptr , int *length_ptr ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 158
  *offset_ptr = VP8LHashChainFindOffset(p, base_position);
#line 159
  *length_ptr = VP8LHashChainFindLength(p, base_position);
  }
  return;
}
}
#line 183
void VP8LBackwardRefsInit(VP8LBackwardRefs * const  refs , int block_size ) ;
#line 185
void VP8LBackwardRefsClear(VP8LBackwardRefs * const  refs ) ;
#line 197
VP8LRefsCursor VP8LRefsCursorInit(VP8LBackwardRefs * const  refs ) ;
#line 199 "../../src/enc/backward_references_enc.h"
__inline static int VP8LRefsCursorOk(VP8LRefsCursor *c ) 
{ 


  {
#line 200
  return (c->cur_pos != (void *)0);
}
}
#line 203
void VP8LRefsCursorNextBlock(VP8LRefsCursor * const  c ) ;
#line 205 "../../src/enc/backward_references_enc.h"
__inline static void VP8LRefsCursorNext(VP8LRefsCursor *c ) 
{ 


  {
#line 208
  (c->cur_pos) ++;
#line 208
  if (c->cur_pos == c->last_pos_) {
    {
#line 208
    VP8LRefsCursorNextBlock(c);
    }
  }
  return;
}
}
#line 233
int VP8LGetBackwardReferences(int width , int height , uint32_t * const  argb , int quality ,
                              int low_effort , int lz77_types_to_try , int cache_bits_max ,
                              int do_no_cache , VP8LHashChain * const  hash_chain ,
                              VP8LBackwardRefs * const  refs , int * const  cache_bits_best ,
                              WebPPicture * const  pic , int percent_range , int * const  percent ) ;
#line 63 "../../src/enc/histogram_enc.h"
void VP8LHistogramCreate(VP8LHistogram * const  p , VP8LBackwardRefs * const  refs ,
                         int palette_code_bits ) ;
#line 68
int VP8LGetHistogramSize(int cache_bits ) ;
#line 72
void VP8LHistogramInit(VP8LHistogram * const  p , int palette_code_bits , int init_arrays ) ;
#line 76
void VP8LHistogramStoreRefs(VP8LBackwardRefs * const  refs , VP8LHistogram * const  histo ) ;
#line 80
void VP8LFreeHistogram(VP8LHistogram * const  histo ) ;
#line 83
void VP8LFreeHistogramSet(VP8LHistogramSet * const  histo ) ;
#line 87
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) ;
#line 90
void VP8LHistogramSetClear(VP8LHistogramSet * const  set ) ;
#line 95
VP8LHistogram *VP8LAllocateHistogram(int cache_bits ) ;
#line 98
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram * const  histo , PixOrCopy * const  v ,
                                     int (* const  distance_modifier)(int  , int  ) ,
                                     int distance_modifier_arg0 ) ;
#line 103 "../../src/enc/histogram_enc.h"
__inline static int VP8LHistogramNumCodes(int palette_code_bits ) 
{ 
  int tmp ;

  {
#line 104
  if (palette_code_bits > 0) {
#line 104
    tmp = 1 << palette_code_bits;
  } else {
#line 104
    tmp = 0;
  }
#line 104
  return (280 + tmp);
}
}
#line 110
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs * const  refs ,
                             int quality , int low_effort , int histogram_bits , int cache_bits ,
                             VP8LHistogramSet * const  image_histo , VP8LHistogram * const  tmp_histo ,
                             uint16_t * const  histogram_symbols , WebPPicture * const  pic ,
                             int percent_range , int * const  percent ) ;
#line 120
float VP8LBitsEntropy(uint32_t * const  array , int n ) ;
#line 124
float VP8LHistogramEstimateBits(VP8LHistogram * const  p ) ;
#line 33 "../../src/dsp/lossless.h"
extern VP8LPredictorFunc VP8LPredictors[16] ;
#line 35
uint32_t VP8LPredictor0_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 37
uint32_t VP8LPredictor1_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 39
uint32_t VP8LPredictor2_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 41
uint32_t VP8LPredictor3_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 43
uint32_t VP8LPredictor4_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 45
uint32_t VP8LPredictor5_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 47
uint32_t VP8LPredictor6_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 49
uint32_t VP8LPredictor7_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 51
uint32_t VP8LPredictor8_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 53
uint32_t VP8LPredictor9_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 55
uint32_t VP8LPredictor10_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 57
uint32_t VP8LPredictor11_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 59
uint32_t VP8LPredictor12_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 61
uint32_t VP8LPredictor13_C(uint32_t * const  left , uint32_t * const  top ) ;
#line 68
extern VP8LPredictorAddSubFunc VP8LPredictorsAdd[16] ;
#line 69
extern VP8LPredictorAddSubFunc VP8LPredictorsAdd_C[16] ;
#line 73
extern VP8LProcessDecBlueAndRedFunc VP8LAddGreenToBlueAndRed ;
#line 85
extern VP8LTransformColorInverseFunc VP8LTransformColorInverse ;
#line 93
void VP8LInverseTransform(struct VP8LTransform * const  transform , int row_start ,
                          int row_end , uint32_t * const  in , uint32_t * const  out ) ;
#line 100
extern VP8LConvertFunc VP8LConvertBGRAToRGB ;
#line 101
extern VP8LConvertFunc VP8LConvertBGRAToRGBA ;
#line 102
extern VP8LConvertFunc VP8LConvertBGRAToRGBA4444 ;
#line 103
extern VP8LConvertFunc VP8LConvertBGRAToRGB565 ;
#line 104
extern VP8LConvertFunc VP8LConvertBGRAToBGR ;
#line 107
void VP8LConvertFromBGRA(uint32_t * const  in_data , int num_pixels , WEBP_CSP_MODE out_colorspace ,
                         uint8_t * const  rgba ) ;
#line 119
extern VP8LMapARGBFunc VP8LMapColor32b ;
#line 120
extern VP8LMapAlphaFunc VP8LMapColor8b ;
#line 125
void VP8LColorIndexInverseTransformAlpha(struct VP8LTransform * const  transform ,
                                         int y_start , int y_end , uint8_t *src ,
                                         uint8_t *dst ) ;
#line 130
void VP8LTransformColorInverse_C(VP8LMultipliers * const  m , uint32_t *src , int num_pixels ,
                                 uint32_t *dst ) ;
#line 134
void VP8LConvertBGRAToRGB_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 135
void VP8LConvertBGRAToRGBA_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 136
void VP8LConvertBGRAToRGBA4444_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 138
void VP8LConvertBGRAToRGB565_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 140
void VP8LConvertBGRAToBGR_C(uint32_t *src , int num_pixels , uint8_t *dst ) ;
#line 141
void VP8LAddGreenToBlueAndRed_C(uint32_t *src , int num_pixels , uint32_t *dst ) ;
#line 145
void VP8LDspInit(void) ;
#line 151
extern VP8LProcessEncBlueAndRedFunc VP8LSubtractGreenFromBlueAndRed ;
#line 154
extern VP8LTransformColorFunc VP8LTransformColor ;
#line 159
extern VP8LCollectColorBlueTransformsFunc VP8LCollectColorBlueTransforms ;
#line 165
extern VP8LCollectColorRedTransformsFunc VP8LCollectColorRedTransforms ;
#line 168
void VP8LTransformColor_C(VP8LMultipliers * const  m , uint32_t *data , int num_pixels ) ;
#line 170
void VP8LSubtractGreenFromBlueAndRed_C(uint32_t *argb_data , int num_pixels ) ;
#line 171
void VP8LCollectColorRedTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                     int tile_height , int green_to_red , int histo[] ) ;
#line 174
void VP8LCollectColorBlueTransforms_C(uint32_t *argb , int stride , int tile_width ,
                                      int tile_height , int green_to_blue , int red_to_blue ,
                                      int histo[] ) ;
#line 179
extern VP8LPredictorAddSubFunc VP8LPredictorsSub[16] ;
#line 180
extern VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16] ;
#line 191
extern VP8LCostFunc VP8LExtraCost ;
#line 192
extern VP8LCostCombinedFunc VP8LExtraCostCombined ;
#line 193
extern VP8LCombinedShannonEntropyFunc VP8LCombinedShannonEntropy ;
#line 208
void VP8LBitEntropyInit(VP8LBitEntropy * const  entropy ) ;
#line 216
extern VP8LGetCombinedEntropyUnrefinedFunc VP8LGetCombinedEntropyUnrefined ;
#line 222
extern VP8LGetEntropyUnrefinedFunc VP8LGetEntropyUnrefined ;
#line 224
void VP8LBitsEntropyUnrefined(uint32_t * const  array , int n , VP8LBitEntropy * const  entropy ) ;
#line 229
extern VP8LAddVectorFunc VP8LAddVector ;
#line 231
extern VP8LAddVectorEqFunc VP8LAddVectorEq ;
#line 232
void VP8LHistogramAdd(VP8LHistogram * const  a , VP8LHistogram * const  b , VP8LHistogram * const  out ) ;
#line 242
extern VP8LVectorMismatchFunc VP8LVectorMismatch ;
#line 246
extern VP8LBundleColorMapFunc VP8LBundleColorMap ;
#line 247
void VP8LBundleColorMap_C(uint8_t * const  row , int width , int xbits , uint32_t *dst ) ;
#line 251
void VP8LEncDspInit(void) ;
#line 52 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int CheckNonOpaque(uint8_t *alpha , int width , int height , int x_step , int y_step ) 
{ 
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 54
  if (alpha == (void *)0) {
#line 54
    return (0);
  }
  {
#line 55
  WebPInitAlphaProcessing();
  }
#line 56
  if (x_step == 1) {
    {
#line 57
    while (1) {
      while_continue: /* CIL Label */ ;
#line 57
      if (! (__cil_tmp6 > 0)) {
#line 57
        goto while_break;
      }
      {
#line 58
      __cil_tmp7 = (*WebPHasAlpha8b)(alpha, width);
      }
#line 58
      if (__cil_tmp7) {
#line 58
        return (1);
      }
#line 57
      alpha += y_step;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      if (! (__cil_tmp8 > 0)) {
#line 61
        goto while_break___0;
      }
      {
#line 62
      __cil_tmp9 = (*WebPHasAlpha32b)(alpha, width);
      }
#line 62
      if (__cil_tmp9) {
#line 62
        return (1);
      }
#line 61
      alpha += y_step;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 65
  return (0);
}
}
#line 69 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureHasTransparency(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 70
  if (picture == (void *)0) {
#line 70
    return (0);
  }
#line 71
  if (picture->use_argb) {
#line 72
    if (picture->argb != (void *)0) {
      {
#line 73
      __cil_tmp2 = CheckNonOpaque((uint8_t *)picture->argb + 3, picture->width, picture->height,
                                  4, (int )((unsigned long )picture->argb_stride * sizeof(*(picture->argb))));
      }
#line 73
      return (__cil_tmp2);
    }
#line 77
    return (0);
  }
  {
#line 79
  __cil_tmp3 = CheckNonOpaque(picture->a, picture->width, picture->height, 1, picture->a_stride);
  }
#line 79
  return (__cil_tmp3);
}
}
#line 92 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static double const   kGamma  =    0.800000000001;
#line 93 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int const   kGammaScale  =    (1 << 12) - 1;
#line 94 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int const   kGammaTabScale  =    1 << 7;
#line 95 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int const   kGammaTabRounder  =    (1 << 7) >> 1;
#line 97
static int kLinearToGammaTab[33] ;
#line 98
static uint16_t kGammaToLinearTab[256] ;
#line 99 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int kGammaTablesOk  =    0;
#line 100
void InitGammaTables(void) ;
#line 101
extern VP8CPUInfo VP8GetCPUInfo ;
#line 103
static void InitGammaTables_body(void) ;
#line 103 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
void InitGammaTables(void) 
{ 
  static VP8CPUInfo InitGammaTables_body_last_cpuinfo_used ;
  static pthread_mutex_t InitGammaTables_body_lock ;
  int __cil_tmp3 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    InitGammaTables_body_last_cpuinfo_used = (VP8CPUInfo )(& InitGammaTables_body_last_cpuinfo_used);
#line 103
    InitGammaTables_body_lock.__data.__lock = 0;
#line 103
    InitGammaTables_body_lock.__data.__count = (unsigned int )0;
#line 103
    InitGammaTables_body_lock.__data.__owner = 0;
#line 103
    InitGammaTables_body_lock.__data.__nusers = (unsigned int )0;
#line 103
    InitGammaTables_body_lock.__data.__kind = 0;
#line 103
    InitGammaTables_body_lock.__data.__spins = (short )0;
#line 103
    InitGammaTables_body_lock.__data.__elision = (short )0;
#line 103
    InitGammaTables_body_lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
    {
#line 103
    InitGammaTables_body_lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 103
    __cil_tmp3 = pthread_mutex_lock(& InitGammaTables_body_lock);
    }
#line 103
    if (__cil_tmp3) {
#line 103
      goto while_break;
    }
#line 103
    if (InitGammaTables_body_last_cpuinfo_used != VP8GetCPUInfo) {
      {
#line 103
      InitGammaTables_body();
      }
    }
    {
#line 103
    InitGammaTables_body_last_cpuinfo_used = VP8GetCPUInfo;
#line 103
    pthread_mutex_unlock(& InitGammaTables_body_lock);
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 103 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static void InitGammaTables_body(void) 
{ 
  int v ;
  double scale ;
  double norm ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;

  {
#line 104
  if (! kGammaTablesOk) {
#line 106
    scale = (double )(1 << 7) / (double )kGammaScale;
#line 107
    norm = 1. / 255.;
#line 108
    v = 0;
    {
#line 108
    while (1) {
      while_continue: /* CIL Label */ ;
#line 108
      if (! (v <= 255)) {
#line 108
        goto while_break;
      }
      {
#line 109
      __cil_tmp4 = pow(norm * (double )v, kGamma);
#line 109
      kGammaToLinearTab[v] = (uint16_t )(__cil_tmp4 * (double )kGammaScale + 0.5);
      }
#line 108
      v ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 112
    v = 0;
    {
#line 112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 112
      if (! (v <= 1 << 5)) {
#line 112
        goto while_break___0;
      }
      {
#line 113
      __cil_tmp5 = pow(scale * (double )v, 1. / kGamma);
#line 113
      kLinearToGammaTab[v] = (int )(255. * __cil_tmp5 + 0.5);
      }
#line 112
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    kGammaTablesOk = 1;
  }
  return;
}
}
#line 119 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static uint32_t GammaToLinear(uint8_t v ) 
{ 


  {
#line 120
  return ((uint32_t )kGammaToLinearTab[v]);
}
}
#line 123 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static int Interpolate(int v ) 
{ 
  int tab_pos ;
  int x ;
  int v0 ;
  int v1 ;
  int y ;

  {
#line 124
  tab_pos = v >> 9;
#line 125
  x = v & ((kGammaTabScale << 2) - 1);
#line 126
  v0 = kLinearToGammaTab[tab_pos];
#line 127
  v1 = kLinearToGammaTab[tab_pos + 1];
#line 128
  y = v1 * x + v0 * ((kGammaTabScale << 2) - x);
#line 130
  return (y);
}
}
#line 135 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static int LinearToGamma(uint32_t base_value , int shift ) 
{ 
  int y ;
  int __cil_tmp4 ;

  {
  {
#line 136
  __cil_tmp4 = Interpolate((int )(base_value << shift));
#line 136
  y = __cil_tmp4;
  }
#line 137
  return ((y + kGammaTabRounder) >> 7);
}
}
#line 153 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int RGBToY(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 154
  if (rg == (void *)0) {
    {
#line 154
    __cil_tmp5 = VP8RGBToY(r, g, b, 32768);
#line 154
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 154
    __cil_tmp6 = VP8RandomBits(rg, 16);
#line 154
    __cil_tmp7 = VP8RGBToY(r, g, b, __cil_tmp6);
#line 154
    tmp = __cil_tmp7;
    }
  }
#line 154
  return (tmp);
}
}
#line 158 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int RGBToU(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 159
  if (rg == (void *)0) {
    {
#line 159
    __cil_tmp5 = VP8RGBToU(r, g, b, 32768 << 2);
#line 159
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 159
    __cil_tmp6 = VP8RandomBits(rg, 18);
#line 159
    __cil_tmp7 = VP8RGBToU(r, g, b, __cil_tmp6);
#line 159
    tmp = __cil_tmp7;
    }
  }
#line 159
  return (tmp);
}
}
#line 163 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int RGBToV(int r , int g , int b , VP8Random *rg ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 164
  if (rg == (void *)0) {
    {
#line 164
    __cil_tmp5 = VP8RGBToV(r, g, b, 32768 << 2);
#line 164
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 164
    __cil_tmp6 = VP8RandomBits(rg, 18);
#line 164
    __cil_tmp7 = VP8RGBToV(r, g, b, __cil_tmp6);
#line 164
    tmp = __cil_tmp7;
    }
  }
#line 164
  return (tmp);
}
}
#line 171 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int const   kMinDimensionIterativeConversion  =    4;
#line 176 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int PreprocessARGB(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , int step ,
                          int rgb_stride , WebPPicture *picture ) 
{ 
  int ok ;
  SharpYuvConversionMatrix *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 181
  __cil_tmp8 = SharpYuvGetConversionMatrix((SharpYuvMatrixType )0);
#line 181
  __cil_tmp9 = SharpYuvConvert(r_ptr, g_ptr, b_ptr, step, rgb_stride, 8, picture->y,
                               picture->y_stride, picture->u, picture->uv_stride,
                               picture->v, picture->uv_stride, 8, picture->width,
                               picture->height, __cil_tmp8);
#line 181
  ok = __cil_tmp9;
  }
#line 186
  if (! ok) {
    {
#line 187
    __cil_tmp10 = WebPEncodingSetError(picture, (WebPEncodingError )1);
    }
#line 187
    return (__cil_tmp10);
  }
#line 189
  return (ok);
}
}
#line 209 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int const   kAlphaFix  =    19;
#line 217 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static uint32_t kInvAlpha[1021]  = 
#line 217
  {      (uint32_t )0,      (uint32_t )524288,      (uint32_t )262144,      (uint32_t )174762, 
        (uint32_t )131072,      (uint32_t )104857,      (uint32_t )87381,      (uint32_t )74898, 
        (uint32_t )65536,      (uint32_t )58254,      (uint32_t )52428,      (uint32_t )47662, 
        (uint32_t )43690,      (uint32_t )40329,      (uint32_t )37449,      (uint32_t )34952, 
        (uint32_t )32768,      (uint32_t )30840,      (uint32_t )29127,      (uint32_t )27594, 
        (uint32_t )26214,      (uint32_t )24966,      (uint32_t )23831,      (uint32_t )22795, 
        (uint32_t )21845,      (uint32_t )20971,      (uint32_t )20164,      (uint32_t )19418, 
        (uint32_t )18724,      (uint32_t )18078,      (uint32_t )17476,      (uint32_t )16912, 
        (uint32_t )16384,      (uint32_t )15887,      (uint32_t )15420,      (uint32_t )14979, 
        (uint32_t )14563,      (uint32_t )14169,      (uint32_t )13797,      (uint32_t )13443, 
        (uint32_t )13107,      (uint32_t )12787,      (uint32_t )12483,      (uint32_t )12192, 
        (uint32_t )11915,      (uint32_t )11650,      (uint32_t )11397,      (uint32_t )11155, 
        (uint32_t )10922,      (uint32_t )10699,      (uint32_t )10485,      (uint32_t )10280, 
        (uint32_t )10082,      (uint32_t )9892,      (uint32_t )9709,      (uint32_t )9532, 
        (uint32_t )9362,      (uint32_t )9198,      (uint32_t )9039,      (uint32_t )8886, 
        (uint32_t )8738,      (uint32_t )8594,      (uint32_t )8456,      (uint32_t )8322, 
        (uint32_t )8192,      (uint32_t )8065,      (uint32_t )7943,      (uint32_t )7825, 
        (uint32_t )7710,      (uint32_t )7598,      (uint32_t )7489,      (uint32_t )7384, 
        (uint32_t )7281,      (uint32_t )7182,      (uint32_t )7084,      (uint32_t )6990, 
        (uint32_t )6898,      (uint32_t )6808,      (uint32_t )6721,      (uint32_t )6636, 
        (uint32_t )6553,      (uint32_t )6472,      (uint32_t )6393,      (uint32_t )6316, 
        (uint32_t )6241,      (uint32_t )6168,      (uint32_t )6096,      (uint32_t )6026, 
        (uint32_t )5957,      (uint32_t )5890,      (uint32_t )5825,      (uint32_t )5761, 
        (uint32_t )5698,      (uint32_t )5637,      (uint32_t )5577,      (uint32_t )5518, 
        (uint32_t )5461,      (uint32_t )5405,      (uint32_t )5349,      (uint32_t )5295, 
        (uint32_t )5242,      (uint32_t )5190,      (uint32_t )5140,      (uint32_t )5090, 
        (uint32_t )5041,      (uint32_t )4993,      (uint32_t )4946,      (uint32_t )4899, 
        (uint32_t )4854,      (uint32_t )4809,      (uint32_t )4766,      (uint32_t )4723, 
        (uint32_t )4681,      (uint32_t )4639,      (uint32_t )4599,      (uint32_t )4559, 
        (uint32_t )4519,      (uint32_t )4481,      (uint32_t )4443,      (uint32_t )4405, 
        (uint32_t )4369,      (uint32_t )4332,      (uint32_t )4297,      (uint32_t )4262, 
        (uint32_t )4228,      (uint32_t )4194,      (uint32_t )4161,      (uint32_t )4128, 
        (uint32_t )4096,      (uint32_t )4064,      (uint32_t )4032,      (uint32_t )4002, 
        (uint32_t )3971,      (uint32_t )3942,      (uint32_t )3912,      (uint32_t )3883, 
        (uint32_t )3855,      (uint32_t )3826,      (uint32_t )3799,      (uint32_t )3771, 
        (uint32_t )3744,      (uint32_t )3718,      (uint32_t )3692,      (uint32_t )3666, 
        (uint32_t )3640,      (uint32_t )3615,      (uint32_t )3591,      (uint32_t )3566, 
        (uint32_t )3542,      (uint32_t )3518,      (uint32_t )3495,      (uint32_t )3472, 
        (uint32_t )3449,      (uint32_t )3426,      (uint32_t )3404,      (uint32_t )3382, 
        (uint32_t )3360,      (uint32_t )3339,      (uint32_t )3318,      (uint32_t )3297, 
        (uint32_t )3276,      (uint32_t )3256,      (uint32_t )3236,      (uint32_t )3216, 
        (uint32_t )3196,      (uint32_t )3177,      (uint32_t )3158,      (uint32_t )3139, 
        (uint32_t )3120,      (uint32_t )3102,      (uint32_t )3084,      (uint32_t )3066, 
        (uint32_t )3048,      (uint32_t )3030,      (uint32_t )3013,      (uint32_t )2995, 
        (uint32_t )2978,      (uint32_t )2962,      (uint32_t )2945,      (uint32_t )2928, 
        (uint32_t )2912,      (uint32_t )2896,      (uint32_t )2880,      (uint32_t )2864, 
        (uint32_t )2849,      (uint32_t )2833,      (uint32_t )2818,      (uint32_t )2803, 
        (uint32_t )2788,      (uint32_t )2774,      (uint32_t )2759,      (uint32_t )2744, 
        (uint32_t )2730,      (uint32_t )2716,      (uint32_t )2702,      (uint32_t )2688, 
        (uint32_t )2674,      (uint32_t )2661,      (uint32_t )2647,      (uint32_t )2634, 
        (uint32_t )2621,      (uint32_t )2608,      (uint32_t )2595,      (uint32_t )2582, 
        (uint32_t )2570,      (uint32_t )2557,      (uint32_t )2545,      (uint32_t )2532, 
        (uint32_t )2520,      (uint32_t )2508,      (uint32_t )2496,      (uint32_t )2484, 
        (uint32_t )2473,      (uint32_t )2461,      (uint32_t )2449,      (uint32_t )2438, 
        (uint32_t )2427,      (uint32_t )2416,      (uint32_t )2404,      (uint32_t )2394, 
        (uint32_t )2383,      (uint32_t )2372,      (uint32_t )2361,      (uint32_t )2351, 
        (uint32_t )2340,      (uint32_t )2330,      (uint32_t )2319,      (uint32_t )2309, 
        (uint32_t )2299,      (uint32_t )2289,      (uint32_t )2279,      (uint32_t )2269, 
        (uint32_t )2259,      (uint32_t )2250,      (uint32_t )2240,      (uint32_t )2231, 
        (uint32_t )2221,      (uint32_t )2212,      (uint32_t )2202,      (uint32_t )2193, 
        (uint32_t )2184,      (uint32_t )2175,      (uint32_t )2166,      (uint32_t )2157, 
        (uint32_t )2148,      (uint32_t )2139,      (uint32_t )2131,      (uint32_t )2122, 
        (uint32_t )2114,      (uint32_t )2105,      (uint32_t )2097,      (uint32_t )2088, 
        (uint32_t )2080,      (uint32_t )2072,      (uint32_t )2064,      (uint32_t )2056, 
        (uint32_t )2048,      (uint32_t )2040,      (uint32_t )2032,      (uint32_t )2024, 
        (uint32_t )2016,      (uint32_t )2008,      (uint32_t )2001,      (uint32_t )1993, 
        (uint32_t )1985,      (uint32_t )1978,      (uint32_t )1971,      (uint32_t )1963, 
        (uint32_t )1956,      (uint32_t )1949,      (uint32_t )1941,      (uint32_t )1934, 
        (uint32_t )1927,      (uint32_t )1920,      (uint32_t )1913,      (uint32_t )1906, 
        (uint32_t )1899,      (uint32_t )1892,      (uint32_t )1885,      (uint32_t )1879, 
        (uint32_t )1872,      (uint32_t )1865,      (uint32_t )1859,      (uint32_t )1852, 
        (uint32_t )1846,      (uint32_t )1839,      (uint32_t )1833,      (uint32_t )1826, 
        (uint32_t )1820,      (uint32_t )1814,      (uint32_t )1807,      (uint32_t )1801, 
        (uint32_t )1795,      (uint32_t )1789,      (uint32_t )1783,      (uint32_t )1777, 
        (uint32_t )1771,      (uint32_t )1765,      (uint32_t )1759,      (uint32_t )1753, 
        (uint32_t )1747,      (uint32_t )1741,      (uint32_t )1736,      (uint32_t )1730, 
        (uint32_t )1724,      (uint32_t )1718,      (uint32_t )1713,      (uint32_t )1707, 
        (uint32_t )1702,      (uint32_t )1696,      (uint32_t )1691,      (uint32_t )1685, 
        (uint32_t )1680,      (uint32_t )1675,      (uint32_t )1669,      (uint32_t )1664, 
        (uint32_t )1659,      (uint32_t )1653,      (uint32_t )1648,      (uint32_t )1643, 
        (uint32_t )1638,      (uint32_t )1633,      (uint32_t )1628,      (uint32_t )1623, 
        (uint32_t )1618,      (uint32_t )1613,      (uint32_t )1608,      (uint32_t )1603, 
        (uint32_t )1598,      (uint32_t )1593,      (uint32_t )1588,      (uint32_t )1583, 
        (uint32_t )1579,      (uint32_t )1574,      (uint32_t )1569,      (uint32_t )1565, 
        (uint32_t )1560,      (uint32_t )1555,      (uint32_t )1551,      (uint32_t )1546, 
        (uint32_t )1542,      (uint32_t )1537,      (uint32_t )1533,      (uint32_t )1528, 
        (uint32_t )1524,      (uint32_t )1519,      (uint32_t )1515,      (uint32_t )1510, 
        (uint32_t )1506,      (uint32_t )1502,      (uint32_t )1497,      (uint32_t )1493, 
        (uint32_t )1489,      (uint32_t )1485,      (uint32_t )1481,      (uint32_t )1476, 
        (uint32_t )1472,      (uint32_t )1468,      (uint32_t )1464,      (uint32_t )1460, 
        (uint32_t )1456,      (uint32_t )1452,      (uint32_t )1448,      (uint32_t )1444, 
        (uint32_t )1440,      (uint32_t )1436,      (uint32_t )1432,      (uint32_t )1428, 
        (uint32_t )1424,      (uint32_t )1420,      (uint32_t )1416,      (uint32_t )1413, 
        (uint32_t )1409,      (uint32_t )1405,      (uint32_t )1401,      (uint32_t )1398, 
        (uint32_t )1394,      (uint32_t )1390,      (uint32_t )1387,      (uint32_t )1383, 
        (uint32_t )1379,      (uint32_t )1376,      (uint32_t )1372,      (uint32_t )1368, 
        (uint32_t )1365,      (uint32_t )1361,      (uint32_t )1358,      (uint32_t )1354, 
        (uint32_t )1351,      (uint32_t )1347,      (uint32_t )1344,      (uint32_t )1340, 
        (uint32_t )1337,      (uint32_t )1334,      (uint32_t )1330,      (uint32_t )1327, 
        (uint32_t )1323,      (uint32_t )1320,      (uint32_t )1317,      (uint32_t )1314, 
        (uint32_t )1310,      (uint32_t )1307,      (uint32_t )1304,      (uint32_t )1300, 
        (uint32_t )1297,      (uint32_t )1294,      (uint32_t )1291,      (uint32_t )1288, 
        (uint32_t )1285,      (uint32_t )1281,      (uint32_t )1278,      (uint32_t )1275, 
        (uint32_t )1272,      (uint32_t )1269,      (uint32_t )1266,      (uint32_t )1263, 
        (uint32_t )1260,      (uint32_t )1257,      (uint32_t )1254,      (uint32_t )1251, 
        (uint32_t )1248,      (uint32_t )1245,      (uint32_t )1242,      (uint32_t )1239, 
        (uint32_t )1236,      (uint32_t )1233,      (uint32_t )1230,      (uint32_t )1227, 
        (uint32_t )1224,      (uint32_t )1222,      (uint32_t )1219,      (uint32_t )1216, 
        (uint32_t )1213,      (uint32_t )1210,      (uint32_t )1208,      (uint32_t )1205, 
        (uint32_t )1202,      (uint32_t )1199,      (uint32_t )1197,      (uint32_t )1194, 
        (uint32_t )1191,      (uint32_t )1188,      (uint32_t )1186,      (uint32_t )1183, 
        (uint32_t )1180,      (uint32_t )1178,      (uint32_t )1175,      (uint32_t )1172, 
        (uint32_t )1170,      (uint32_t )1167,      (uint32_t )1165,      (uint32_t )1162, 
        (uint32_t )1159,      (uint32_t )1157,      (uint32_t )1154,      (uint32_t )1152, 
        (uint32_t )1149,      (uint32_t )1147,      (uint32_t )1144,      (uint32_t )1142, 
        (uint32_t )1139,      (uint32_t )1137,      (uint32_t )1134,      (uint32_t )1132, 
        (uint32_t )1129,      (uint32_t )1127,      (uint32_t )1125,      (uint32_t )1122, 
        (uint32_t )1120,      (uint32_t )1117,      (uint32_t )1115,      (uint32_t )1113, 
        (uint32_t )1110,      (uint32_t )1108,      (uint32_t )1106,      (uint32_t )1103, 
        (uint32_t )1101,      (uint32_t )1099,      (uint32_t )1096,      (uint32_t )1094, 
        (uint32_t )1092,      (uint32_t )1089,      (uint32_t )1087,      (uint32_t )1085, 
        (uint32_t )1083,      (uint32_t )1081,      (uint32_t )1078,      (uint32_t )1076, 
        (uint32_t )1074,      (uint32_t )1072,      (uint32_t )1069,      (uint32_t )1067, 
        (uint32_t )1065,      (uint32_t )1063,      (uint32_t )1061,      (uint32_t )1059, 
        (uint32_t )1057,      (uint32_t )1054,      (uint32_t )1052,      (uint32_t )1050, 
        (uint32_t )1048,      (uint32_t )1046,      (uint32_t )1044,      (uint32_t )1042, 
        (uint32_t )1040,      (uint32_t )1038,      (uint32_t )1036,      (uint32_t )1034, 
        (uint32_t )1032,      (uint32_t )1030,      (uint32_t )1028,      (uint32_t )1026, 
        (uint32_t )1024,      (uint32_t )1022,      (uint32_t )1020,      (uint32_t )1018, 
        (uint32_t )1016,      (uint32_t )1014,      (uint32_t )1012,      (uint32_t )1010, 
        (uint32_t )1008,      (uint32_t )1006,      (uint32_t )1004,      (uint32_t )1002, 
        (uint32_t )1000,      (uint32_t )998,      (uint32_t )996,      (uint32_t )994, 
        (uint32_t )992,      (uint32_t )991,      (uint32_t )989,      (uint32_t )987, 
        (uint32_t )985,      (uint32_t )983,      (uint32_t )981,      (uint32_t )979, 
        (uint32_t )978,      (uint32_t )976,      (uint32_t )974,      (uint32_t )972, 
        (uint32_t )970,      (uint32_t )969,      (uint32_t )967,      (uint32_t )965, 
        (uint32_t )963,      (uint32_t )961,      (uint32_t )960,      (uint32_t )958, 
        (uint32_t )956,      (uint32_t )954,      (uint32_t )953,      (uint32_t )951, 
        (uint32_t )949,      (uint32_t )948,      (uint32_t )946,      (uint32_t )944, 
        (uint32_t )942,      (uint32_t )941,      (uint32_t )939,      (uint32_t )937, 
        (uint32_t )936,      (uint32_t )934,      (uint32_t )932,      (uint32_t )931, 
        (uint32_t )929,      (uint32_t )927,      (uint32_t )926,      (uint32_t )924, 
        (uint32_t )923,      (uint32_t )921,      (uint32_t )919,      (uint32_t )918, 
        (uint32_t )916,      (uint32_t )914,      (uint32_t )913,      (uint32_t )911, 
        (uint32_t )910,      (uint32_t )908,      (uint32_t )907,      (uint32_t )905, 
        (uint32_t )903,      (uint32_t )902,      (uint32_t )900,      (uint32_t )899, 
        (uint32_t )897,      (uint32_t )896,      (uint32_t )894,      (uint32_t )893, 
        (uint32_t )891,      (uint32_t )890,      (uint32_t )888,      (uint32_t )887, 
        (uint32_t )885,      (uint32_t )884,      (uint32_t )882,      (uint32_t )881, 
        (uint32_t )879,      (uint32_t )878,      (uint32_t )876,      (uint32_t )875, 
        (uint32_t )873,      (uint32_t )872,      (uint32_t )870,      (uint32_t )869, 
        (uint32_t )868,      (uint32_t )866,      (uint32_t )865,      (uint32_t )863, 
        (uint32_t )862,      (uint32_t )860,      (uint32_t )859,      (uint32_t )858, 
        (uint32_t )856,      (uint32_t )855,      (uint32_t )853,      (uint32_t )852, 
        (uint32_t )851,      (uint32_t )849,      (uint32_t )848,      (uint32_t )846, 
        (uint32_t )845,      (uint32_t )844,      (uint32_t )842,      (uint32_t )841, 
        (uint32_t )840,      (uint32_t )838,      (uint32_t )837,      (uint32_t )836, 
        (uint32_t )834,      (uint32_t )833,      (uint32_t )832,      (uint32_t )830, 
        (uint32_t )829,      (uint32_t )828,      (uint32_t )826,      (uint32_t )825, 
        (uint32_t )824,      (uint32_t )823,      (uint32_t )821,      (uint32_t )820, 
        (uint32_t )819,      (uint32_t )817,      (uint32_t )816,      (uint32_t )815, 
        (uint32_t )814,      (uint32_t )812,      (uint32_t )811,      (uint32_t )810, 
        (uint32_t )809,      (uint32_t )807,      (uint32_t )806,      (uint32_t )805, 
        (uint32_t )804,      (uint32_t )802,      (uint32_t )801,      (uint32_t )800, 
        (uint32_t )799,      (uint32_t )798,      (uint32_t )796,      (uint32_t )795, 
        (uint32_t )794,      (uint32_t )793,      (uint32_t )791,      (uint32_t )790, 
        (uint32_t )789,      (uint32_t )788,      (uint32_t )787,      (uint32_t )786, 
        (uint32_t )784,      (uint32_t )783,      (uint32_t )782,      (uint32_t )781, 
        (uint32_t )780,      (uint32_t )779,      (uint32_t )777,      (uint32_t )776, 
        (uint32_t )775,      (uint32_t )774,      (uint32_t )773,      (uint32_t )772, 
        (uint32_t )771,      (uint32_t )769,      (uint32_t )768,      (uint32_t )767, 
        (uint32_t )766,      (uint32_t )765,      (uint32_t )764,      (uint32_t )763, 
        (uint32_t )762,      (uint32_t )760,      (uint32_t )759,      (uint32_t )758, 
        (uint32_t )757,      (uint32_t )756,      (uint32_t )755,      (uint32_t )754, 
        (uint32_t )753,      (uint32_t )752,      (uint32_t )751,      (uint32_t )750, 
        (uint32_t )748,      (uint32_t )747,      (uint32_t )746,      (uint32_t )745, 
        (uint32_t )744,      (uint32_t )743,      (uint32_t )742,      (uint32_t )741, 
        (uint32_t )740,      (uint32_t )739,      (uint32_t )738,      (uint32_t )737, 
        (uint32_t )736,      (uint32_t )735,      (uint32_t )734,      (uint32_t )733, 
        (uint32_t )732,      (uint32_t )731,      (uint32_t )730,      (uint32_t )729, 
        (uint32_t )728,      (uint32_t )727,      (uint32_t )726,      (uint32_t )725, 
        (uint32_t )724,      (uint32_t )723,      (uint32_t )722,      (uint32_t )721, 
        (uint32_t )720,      (uint32_t )719,      (uint32_t )718,      (uint32_t )717, 
        (uint32_t )716,      (uint32_t )715,      (uint32_t )714,      (uint32_t )713, 
        (uint32_t )712,      (uint32_t )711,      (uint32_t )710,      (uint32_t )709, 
        (uint32_t )708,      (uint32_t )707,      (uint32_t )706,      (uint32_t )705, 
        (uint32_t )704,      (uint32_t )703,      (uint32_t )702,      (uint32_t )701, 
        (uint32_t )700,      (uint32_t )699,      (uint32_t )699,      (uint32_t )698, 
        (uint32_t )697,      (uint32_t )696,      (uint32_t )695,      (uint32_t )694, 
        (uint32_t )693,      (uint32_t )692,      (uint32_t )691,      (uint32_t )690, 
        (uint32_t )689,      (uint32_t )688,      (uint32_t )688,      (uint32_t )687, 
        (uint32_t )686,      (uint32_t )685,      (uint32_t )684,      (uint32_t )683, 
        (uint32_t )682,      (uint32_t )681,      (uint32_t )680,      (uint32_t )680, 
        (uint32_t )679,      (uint32_t )678,      (uint32_t )677,      (uint32_t )676, 
        (uint32_t )675,      (uint32_t )674,      (uint32_t )673,      (uint32_t )673, 
        (uint32_t )672,      (uint32_t )671,      (uint32_t )670,      (uint32_t )669, 
        (uint32_t )668,      (uint32_t )667,      (uint32_t )667,      (uint32_t )666, 
        (uint32_t )665,      (uint32_t )664,      (uint32_t )663,      (uint32_t )662, 
        (uint32_t )661,      (uint32_t )661,      (uint32_t )660,      (uint32_t )659, 
        (uint32_t )658,      (uint32_t )657,      (uint32_t )657,      (uint32_t )656, 
        (uint32_t )655,      (uint32_t )654,      (uint32_t )653,      (uint32_t )652, 
        (uint32_t )652,      (uint32_t )651,      (uint32_t )650,      (uint32_t )649, 
        (uint32_t )648,      (uint32_t )648,      (uint32_t )647,      (uint32_t )646, 
        (uint32_t )645,      (uint32_t )644,      (uint32_t )644,      (uint32_t )643, 
        (uint32_t )642,      (uint32_t )641,      (uint32_t )640,      (uint32_t )640, 
        (uint32_t )639,      (uint32_t )638,      (uint32_t )637,      (uint32_t )637, 
        (uint32_t )636,      (uint32_t )635,      (uint32_t )634,      (uint32_t )633, 
        (uint32_t )633,      (uint32_t )632,      (uint32_t )631,      (uint32_t )630, 
        (uint32_t )630,      (uint32_t )629,      (uint32_t )628,      (uint32_t )627, 
        (uint32_t )627,      (uint32_t )626,      (uint32_t )625,      (uint32_t )624, 
        (uint32_t )624,      (uint32_t )623,      (uint32_t )622,      (uint32_t )621, 
        (uint32_t )621,      (uint32_t )620,      (uint32_t )619,      (uint32_t )618, 
        (uint32_t )618,      (uint32_t )617,      (uint32_t )616,      (uint32_t )616, 
        (uint32_t )615,      (uint32_t )614,      (uint32_t )613,      (uint32_t )613, 
        (uint32_t )612,      (uint32_t )611,      (uint32_t )611,      (uint32_t )610, 
        (uint32_t )609,      (uint32_t )608,      (uint32_t )608,      (uint32_t )607, 
        (uint32_t )606,      (uint32_t )606,      (uint32_t )605,      (uint32_t )604, 
        (uint32_t )604,      (uint32_t )603,      (uint32_t )602,      (uint32_t )601, 
        (uint32_t )601,      (uint32_t )600,      (uint32_t )599,      (uint32_t )599, 
        (uint32_t )598,      (uint32_t )597,      (uint32_t )597,      (uint32_t )596, 
        (uint32_t )595,      (uint32_t )595,      (uint32_t )594,      (uint32_t )593, 
        (uint32_t )593,      (uint32_t )592,      (uint32_t )591,      (uint32_t )591, 
        (uint32_t )590,      (uint32_t )589,      (uint32_t )589,      (uint32_t )588, 
        (uint32_t )587,      (uint32_t )587,      (uint32_t )586,      (uint32_t )585, 
        (uint32_t )585,      (uint32_t )584,      (uint32_t )583,      (uint32_t )583, 
        (uint32_t )582,      (uint32_t )581,      (uint32_t )581,      (uint32_t )580, 
        (uint32_t )579,      (uint32_t )579,      (uint32_t )578,      (uint32_t )578, 
        (uint32_t )577,      (uint32_t )576,      (uint32_t )576,      (uint32_t )575, 
        (uint32_t )574,      (uint32_t )574,      (uint32_t )573,      (uint32_t )572, 
        (uint32_t )572,      (uint32_t )571,      (uint32_t )571,      (uint32_t )570, 
        (uint32_t )569,      (uint32_t )569,      (uint32_t )568,      (uint32_t )568, 
        (uint32_t )567,      (uint32_t )566,      (uint32_t )566,      (uint32_t )565, 
        (uint32_t )564,      (uint32_t )564,      (uint32_t )563,      (uint32_t )563, 
        (uint32_t )562,      (uint32_t )561,      (uint32_t )561,      (uint32_t )560, 
        (uint32_t )560,      (uint32_t )559,      (uint32_t )558,      (uint32_t )558, 
        (uint32_t )557,      (uint32_t )557,      (uint32_t )556,      (uint32_t )555, 
        (uint32_t )555,      (uint32_t )554,      (uint32_t )554,      (uint32_t )553, 
        (uint32_t )553,      (uint32_t )552,      (uint32_t )551,      (uint32_t )551, 
        (uint32_t )550,      (uint32_t )550,      (uint32_t )549,      (uint32_t )548, 
        (uint32_t )548,      (uint32_t )547,      (uint32_t )547,      (uint32_t )546, 
        (uint32_t )546,      (uint32_t )545,      (uint32_t )544,      (uint32_t )544, 
        (uint32_t )543,      (uint32_t )543,      (uint32_t )542,      (uint32_t )542, 
        (uint32_t )541,      (uint32_t )541,      (uint32_t )540,      (uint32_t )539, 
        (uint32_t )539,      (uint32_t )538,      (uint32_t )538,      (uint32_t )537, 
        (uint32_t )537,      (uint32_t )536,      (uint32_t )536,      (uint32_t )535, 
        (uint32_t )534,      (uint32_t )534,      (uint32_t )533,      (uint32_t )533, 
        (uint32_t )532,      (uint32_t )532,      (uint32_t )531,      (uint32_t )531, 
        (uint32_t )530,      (uint32_t )530,      (uint32_t )529,      (uint32_t )529, 
        (uint32_t )528,      (uint32_t )527,      (uint32_t )527,      (uint32_t )526, 
        (uint32_t )526,      (uint32_t )525,      (uint32_t )525,      (uint32_t )524, 
        (uint32_t )524,      (uint32_t )523,      (uint32_t )523,      (uint32_t )522, 
        (uint32_t )522,      (uint32_t )521,      (uint32_t )521,      (uint32_t )520, 
        (uint32_t )520,      (uint32_t )519,      (uint32_t )519,      (uint32_t )518, 
        (uint32_t )518,      (uint32_t )517,      (uint32_t )517,      (uint32_t )516, 
        (uint32_t )516,      (uint32_t )515,      (uint32_t )515,      (uint32_t )514, 
        (uint32_t )514};
#line 359 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static int LinearToGammaWeighted(uint8_t *src , uint8_t *a_ptr , uint32_t total_a ,
                                          int step , int rgb_stride ) 
{ 
  uint32_t sum ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 363
  __cil_tmp10 = GammaToLinear(*(src + (rgb_stride + step)));
  }
  {
#line 363
  __cil_tmp9 = GammaToLinear(*(src + rgb_stride));
  }
  {
#line 363
  __cil_tmp8 = GammaToLinear(*(src + step));
  }
  {
#line 363
  __cil_tmp7 = GammaToLinear(*(src + 0));
#line 363
  sum = (((unsigned int )*(a_ptr + 0) * __cil_tmp7 + (unsigned int )*(a_ptr + step) * __cil_tmp8) + (unsigned int )*(a_ptr + rgb_stride) * __cil_tmp9) + (unsigned int )*(a_ptr + (rgb_stride + step)) * __cil_tmp10;
#line 372
  __cil_tmp11 = LinearToGamma(sum * kInvAlpha[total_a] >> (kAlphaFix - 2), 0);
  }
#line 372
  return (__cil_tmp11);
}
}
#line 375 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static void ConvertRowToY(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                   int step , uint8_t *dst_y , int width , VP8Random *rg ) 
{ 
  int i ;
  int j ;
  int __cil_tmp10 ;

  {
#line 383
  j = 0;
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < width)) {
#line 383
      goto while_break;
    }
    {
#line 384
    __cil_tmp10 = RGBToY((int )*(r_ptr + j), (int )*(g_ptr + j), (int )*(b_ptr + j),
                         rg);
#line 384
    *(dst_y + i) = (uint8_t )__cil_tmp10;
    }
#line 383
    j += step;
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 388 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static void AccumulateRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                    uint8_t *a_ptr , int rgb_stride , uint16_t *dst ,
                                    int width ) 
{ 
  int i ;
  int j ;
  uint32_t a ;
  int r ;
  int g ;
  int b ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  uint32_t a___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  uint32_t __cil_tmp36 ;
  uint32_t __cil_tmp37 ;
  int __cil_tmp38 ;
  uint32_t __cil_tmp39 ;
  uint32_t __cil_tmp40 ;
  int __cil_tmp41 ;
  uint32_t __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;

  {
#line 396
  j = 0;
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i < width >> 1)) {
#line 396
      goto while_break;
    }
#line 397
    a = (uint32_t )(((int )*((a_ptr + j) + 0) + (int )*((a_ptr + j) + rgb_stride)) + ((int )*(((a_ptr + j) + 4) + 0) + (int )*(((a_ptr + j) + 4) + rgb_stride)));
#line 399
    if (a == 1020U) {
      _L: /* CIL Label */ 
      {
#line 400
      __cil_tmp17 = GammaToLinear(*((r_ptr + j) + (rgb_stride + 4)));
      }
      {
#line 400
      __cil_tmp16 = GammaToLinear(*((r_ptr + j) + rgb_stride));
      }
      {
#line 400
      __cil_tmp15 = GammaToLinear(*((r_ptr + j) + 4));
      }
      {
#line 400
      __cil_tmp14 = GammaToLinear(*((r_ptr + j) + 0));
#line 400
      __cil_tmp18 = LinearToGamma(((__cil_tmp14 + __cil_tmp15) + __cil_tmp16) + __cil_tmp17,
                                  0);
#line 400
      r = __cil_tmp18;
#line 401
      __cil_tmp22 = GammaToLinear(*((g_ptr + j) + (rgb_stride + 4)));
      }
      {
#line 401
      __cil_tmp21 = GammaToLinear(*((g_ptr + j) + rgb_stride));
      }
      {
#line 401
      __cil_tmp20 = GammaToLinear(*((g_ptr + j) + 4));
      }
      {
#line 401
      __cil_tmp19 = GammaToLinear(*((g_ptr + j) + 0));
#line 401
      __cil_tmp23 = LinearToGamma(((__cil_tmp19 + __cil_tmp20) + __cil_tmp21) + __cil_tmp22,
                                  0);
#line 401
      g = __cil_tmp23;
#line 402
      __cil_tmp27 = GammaToLinear(*((b_ptr + j) + (rgb_stride + 4)));
      }
      {
#line 402
      __cil_tmp26 = GammaToLinear(*((b_ptr + j) + rgb_stride));
      }
      {
#line 402
      __cil_tmp25 = GammaToLinear(*((b_ptr + j) + 4));
      }
      {
#line 402
      __cil_tmp24 = GammaToLinear(*((b_ptr + j) + 0));
#line 402
      __cil_tmp28 = LinearToGamma(((__cil_tmp24 + __cil_tmp25) + __cil_tmp26) + __cil_tmp27,
                                  0);
#line 402
      b = __cil_tmp28;
      }
    } else
#line 399
    if (a == 0U) {
#line 399
      goto _L;
    } else {
      {
#line 404
      r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
#line 405
      g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
#line 406
      b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
      }
    }
#line 408
    *(dst + 0) = (uint16_t )r;
#line 409
    *(dst + 1) = (uint16_t )g;
#line 410
    *(dst + 2) = (uint16_t )b;
#line 411
    *(dst + 3) = (uint16_t )a;
#line 396
    dst += 4;
#line 396
    j += 8;
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  if (width & 1) {
#line 414
    a___0 = 2U * (unsigned int )((int )*((a_ptr + j) + 0) + (int )*((a_ptr + j) + rgb_stride));
#line 416
    if (a___0 == 1020U) {
      _L___0: /* CIL Label */ 
      {
#line 417
      __cil_tmp37 = GammaToLinear(*((r_ptr + j) + rgb_stride));
      }
      {
#line 417
      __cil_tmp36 = GammaToLinear(*((r_ptr + j) + 0));
#line 417
      __cil_tmp38 = LinearToGamma(__cil_tmp36 + __cil_tmp37, 1);
#line 417
      r___0 = __cil_tmp38;
#line 418
      __cil_tmp40 = GammaToLinear(*((g_ptr + j) + rgb_stride));
      }
      {
#line 418
      __cil_tmp39 = GammaToLinear(*((g_ptr + j) + 0));
#line 418
      __cil_tmp41 = LinearToGamma(__cil_tmp39 + __cil_tmp40, 1);
#line 418
      g___0 = __cil_tmp41;
#line 419
      __cil_tmp43 = GammaToLinear(*((b_ptr + j) + rgb_stride));
      }
      {
#line 419
      __cil_tmp42 = GammaToLinear(*((b_ptr + j) + 0));
#line 419
      __cil_tmp44 = LinearToGamma(__cil_tmp42 + __cil_tmp43, 1);
#line 419
      b___0 = __cil_tmp44;
      }
    } else
#line 416
    if (a___0 == 0U) {
#line 416
      goto _L___0;
    } else {
      {
#line 421
      r___0 = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
#line 422
      g___0 = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
#line 423
      b___0 = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a___0, 0, rgb_stride);
      }
    }
#line 425
    *(dst + 0) = (uint16_t )r___0;
#line 426
    *(dst + 1) = (uint16_t )g___0;
#line 427
    *(dst + 2) = (uint16_t )b___0;
#line 428
    *(dst + 3) = (uint16_t )a___0;
  }
  return;
}
}
#line 432 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static void AccumulateRGB(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr ,
                                   int step , int rgb_stride , uint16_t *dst , int width ) 
{ 
  int i ;
  int j ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  int __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  int __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  uint32_t __cil_tmp23 ;
  int __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  uint32_t __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 438
  j = 0;
#line 438
  i = 0;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (i < width >> 1)) {
#line 438
      goto while_break;
    }
    {
#line 439
    __cil_tmp13 = GammaToLinear(*((r_ptr + j) + (rgb_stride + step)));
    }
    {
#line 439
    __cil_tmp12 = GammaToLinear(*((r_ptr + j) + rgb_stride));
    }
    {
#line 439
    __cil_tmp11 = GammaToLinear(*((r_ptr + j) + step));
    }
    {
#line 439
    __cil_tmp10 = GammaToLinear(*((r_ptr + j) + 0));
#line 439
    __cil_tmp14 = LinearToGamma(((__cil_tmp10 + __cil_tmp11) + __cil_tmp12) + __cil_tmp13,
                                0);
#line 439
    *(dst + 0) = (uint16_t )__cil_tmp14;
#line 440
    __cil_tmp18 = GammaToLinear(*((g_ptr + j) + (rgb_stride + step)));
    }
    {
#line 440
    __cil_tmp17 = GammaToLinear(*((g_ptr + j) + rgb_stride));
    }
    {
#line 440
    __cil_tmp16 = GammaToLinear(*((g_ptr + j) + step));
    }
    {
#line 440
    __cil_tmp15 = GammaToLinear(*((g_ptr + j) + 0));
#line 440
    __cil_tmp19 = LinearToGamma(((__cil_tmp15 + __cil_tmp16) + __cil_tmp17) + __cil_tmp18,
                                0);
#line 440
    *(dst + 1) = (uint16_t )__cil_tmp19;
#line 441
    __cil_tmp23 = GammaToLinear(*((b_ptr + j) + (rgb_stride + step)));
    }
    {
#line 441
    __cil_tmp22 = GammaToLinear(*((b_ptr + j) + rgb_stride));
    }
    {
#line 441
    __cil_tmp21 = GammaToLinear(*((b_ptr + j) + step));
    }
    {
#line 441
    __cil_tmp20 = GammaToLinear(*((b_ptr + j) + 0));
#line 441
    __cil_tmp24 = LinearToGamma(((__cil_tmp20 + __cil_tmp21) + __cil_tmp22) + __cil_tmp23,
                                0);
#line 441
    *(dst + 2) = (uint16_t )__cil_tmp24;
    }
#line 438
    dst += 4;
#line 438
    j += 2 * step;
#line 438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if (width & 1) {
    {
#line 450
    __cil_tmp26 = GammaToLinear(*((r_ptr + j) + rgb_stride));
    }
    {
#line 450
    __cil_tmp25 = GammaToLinear(*((r_ptr + j) + 0));
#line 450
    __cil_tmp27 = LinearToGamma(__cil_tmp25 + __cil_tmp26, 1);
#line 450
    *(dst + 0) = (uint16_t )__cil_tmp27;
#line 451
    __cil_tmp29 = GammaToLinear(*((g_ptr + j) + rgb_stride));
    }
    {
#line 451
    __cil_tmp28 = GammaToLinear(*((g_ptr + j) + 0));
#line 451
    __cil_tmp30 = LinearToGamma(__cil_tmp28 + __cil_tmp29, 1);
#line 451
    *(dst + 1) = (uint16_t )__cil_tmp30;
#line 452
    __cil_tmp32 = GammaToLinear(*((b_ptr + j) + rgb_stride));
    }
    {
#line 452
    __cil_tmp31 = GammaToLinear(*((b_ptr + j) + 0));
#line 452
    __cil_tmp33 = LinearToGamma(__cil_tmp31 + __cil_tmp32, 1);
#line 452
    *(dst + 2) = (uint16_t )__cil_tmp33;
    }
  }
  return;
}
}
#line 459 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
__inline static void ConvertRowsToUV(uint16_t *rgb , uint8_t *dst_u , uint8_t *dst_v ,
                                     int width , VP8Random *rg ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 465
  i = 0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < width)) {
#line 465
      goto while_break;
    }
#line 466
    r = (int )*(rgb + 0);
#line 466
    g = (int )*(rgb + 1);
    {
#line 466
    b = (int )*(rgb + 2);
#line 467
    __cil_tmp10 = RGBToU(r, g, b, rg);
#line 467
    *(dst_u + i) = (uint8_t )__cil_tmp10;
#line 468
    __cil_tmp11 = RGBToV(r, g, b, rg);
#line 468
    *(dst_v + i) = (uint8_t )__cil_tmp11;
    }
#line 465
    rgb += 4;
#line 465
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 472
extern void SharpYuvInit(VP8CPUInfo cpu_info_func ) ;
#line 474 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int ImportYUVAFromRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , uint8_t *a_ptr ,
                              int step , int rgb_stride , float dithering , int use_iterative_conversion ,
                              WebPPicture *picture ) 
{ 
  int y ;
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp14 ;
  int is_rgb ;
  int tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int uv_width ;
  int use_dsp ;
  uint16_t *tmp_rgb ;
  void *__cil_tmp22 ;
  uint8_t *dst_y ;
  uint8_t *dst_u ;
  uint8_t *dst_v ;
  uint8_t *dst_a ;
  VP8Random base_rg ;
  VP8Random *rg ;
  int __cil_tmp29 ;
  int rows_have_alpha ;
  int __cil_tmp31 ;
  int row_has_alpha ;
  int __cil_tmp33 ;

  {
  {
#line 484
  width = picture->width;
#line 485
  height = picture->height;
#line 486
  __cil_tmp14 = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
#line 486
  has_alpha = __cil_tmp14;
#line 487
  is_rgb = r_ptr < b_ptr;
  }
#line 489
  if (has_alpha) {
#line 489
    tmp = 4;
  } else {
#line 489
    tmp = 0;
  }
#line 489
  picture->colorspace = (WebPEncCSP )tmp;
#line 490
  picture->use_argb = 0;
#line 493
  if (width < kMinDimensionIterativeConversion) {
#line 495
    use_iterative_conversion = 0;
  } else
#line 493
  if (height < kMinDimensionIterativeConversion) {
#line 495
    use_iterative_conversion = 0;
  }
  {
#line 498
  __cil_tmp17 = WebPPictureAllocYUVA(picture);
  }
#line 498
  if (! __cil_tmp17) {
#line 499
    return (0);
  }
#line 501
  if (has_alpha) {

  }
#line 508
  if (use_iterative_conversion) {
    {
#line 509
    SharpYuvInit(VP8GetCPUInfo);
#line 510
    __cil_tmp18 = PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture);
    }
#line 510
    if (! __cil_tmp18) {
#line 511
      return (0);
    }
#line 513
    if (has_alpha) {
      {
#line 514
      (*WebPExtractAlpha)(a_ptr, rgb_stride, width, height, picture->a, picture->a_stride);
      }
    }
  } else {
    {
#line 518
    uv_width = (width + 1) >> 1;
#line 519
    use_dsp = step == 3;
#line 521
    __cil_tmp22 = WebPSafeMalloc((uint64_t )(4 * uv_width), sizeof(*tmp_rgb));
#line 521
    tmp_rgb = (uint16_t *)__cil_tmp22;
#line 523
    dst_y = picture->y;
#line 524
    dst_u = picture->u;
#line 525
    dst_v = picture->v;
#line 526
    dst_a = picture->a;
#line 529
    rg = (VP8Random *)((void *)0);
    }
#line 530
    if ((double )dithering > 0.) {
      {
#line 531
      VP8InitRandom(& base_rg, dithering);
#line 532
      rg = & base_rg;
#line 533
      use_dsp = 0;
      }
    }
    {
#line 535
    WebPInitConvertARGBToYUV();
#line 536
    InitGammaTables();
    }
#line 538
    if (tmp_rgb == (void *)0) {
      {
#line 539
      __cil_tmp29 = WebPEncodingSetError(picture, (WebPEncodingError )1);
      }
#line 539
      return (__cil_tmp29);
    }
#line 543
    y = 0;
    {
#line 543
    while (1) {
      while_continue: /* CIL Label */ ;
#line 543
      if (! (y < height >> 1)) {
#line 543
        goto while_break;
      }
#line 544
      rows_have_alpha = has_alpha;
#line 545
      if (use_dsp) {
#line 546
        if (is_rgb) {
          {
#line 547
          (*WebPConvertRGB24ToY)(r_ptr, dst_y, width);
#line 548
          (*WebPConvertRGB24ToY)(r_ptr + rgb_stride, dst_y + picture->y_stride, width);
          }
        } else {
          {
#line 551
          (*WebPConvertBGR24ToY)(b_ptr, dst_y, width);
#line 552
          (*WebPConvertBGR24ToY)(b_ptr + rgb_stride, dst_y + picture->y_stride, width);
          }
        }
      } else {
        {
#line 556
        ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
#line 557
        ConvertRowToY(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
                      step, dst_y + picture->y_stride, width, rg);
        }
      }
#line 562
      dst_y += 2 * picture->y_stride;
#line 563
      if (has_alpha) {
        {
#line 564
        __cil_tmp31 = (*WebPExtractAlpha)(a_ptr, rgb_stride, width, 2, dst_a, picture->a_stride);
        }
#line 564
        rows_have_alpha &= ! __cil_tmp31;
#line 566
        dst_a += 2 * picture->a_stride;
      }
#line 569
      if (! rows_have_alpha) {
        {
#line 570
        AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
        }
      } else {
        {
#line 572
        AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
        }
      }
#line 575
      if (rg == (void *)0) {
        {
#line 576
        (*WebPConvertRGBA32ToUV)(tmp_rgb, dst_u, dst_v, uv_width);
        }
      } else {
        {
#line 578
        ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
        }
      }
#line 580
      dst_u += picture->uv_stride;
#line 581
      dst_v += picture->uv_stride;
#line 582
      r_ptr += 2 * rgb_stride;
#line 583
      b_ptr += 2 * rgb_stride;
#line 584
      g_ptr += 2 * rgb_stride;
#line 585
      if (has_alpha) {
#line 585
        a_ptr += 2 * rgb_stride;
      }
#line 543
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 587
    if (height & 1) {
#line 588
      row_has_alpha = has_alpha;
#line 589
      if (use_dsp) {
#line 590
        if (r_ptr < b_ptr) {
          {
#line 591
          (*WebPConvertRGB24ToY)(r_ptr, dst_y, width);
          }
        } else {
          {
#line 593
          (*WebPConvertBGR24ToY)(b_ptr, dst_y, width);
          }
        }
      } else {
        {
#line 596
        ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
        }
      }
#line 598
      if (row_has_alpha) {
        {
#line 599
        __cil_tmp33 = (*WebPExtractAlpha)(a_ptr, 0, width, 1, dst_a, 0);
        }
#line 599
        row_has_alpha &= ! __cil_tmp33;
      }
#line 602
      if (! row_has_alpha) {
        {
#line 604
        AccumulateRGB(r_ptr, g_ptr, b_ptr, step, 0, tmp_rgb, width);
        }
      } else {
        {
#line 607
        AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, 0, tmp_rgb, width);
        }
      }
#line 610
      if (rg == (void *)0) {
        {
#line 611
        (*WebPConvertRGBA32ToUV)(tmp_rgb, dst_u, dst_v, uv_width);
        }
      } else {
        {
#line 613
        ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
        }
      }
    }
    {
#line 616
    WebPSafeFree(tmp_rgb);
    }
  }
#line 618
  return (1);
}
}
#line 629 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int PictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace , float dithering ,
                             int use_iterative_conversion ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  uint8_t *argb ;
  uint8_t *a ;
  uint8_t *r ;
  uint8_t *g ;
  uint8_t *b ;
  int __cil_tmp12 ;

  {
#line 631
  if (picture == (void *)0) {
#line 631
    return (0);
  }
#line 632
  if (picture->argb == (void *)0) {
    {
#line 633
    __cil_tmp5 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
#line 633
    return (__cil_tmp5);
  } else
#line 634
  if (((unsigned int )colorspace & 3U) != 0U) {
    {
#line 635
    __cil_tmp6 = WebPEncodingSetError(picture, (WebPEncodingError )4);
    }
#line 635
    return (__cil_tmp6);
  } else {
    {
#line 637
    argb = (uint8_t *)picture->argb;
#line 638
    a = argb + 3;
#line 639
    r = argb + 2;
#line 640
    g = argb + 1;
#line 641
    b = argb + 0;
#line 643
    picture->colorspace = (WebPEncCSP )0;
#line 644
    __cil_tmp12 = ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride, dithering,
                                     use_iterative_conversion, picture);
    }
#line 644
    return (__cil_tmp12);
  }
}
}
#line 649 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureARGBToYUVADithered(WebPPicture *picture , WebPEncCSP colorspace , float dithering ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 651
  __cil_tmp4 = PictureARGBToYUVA(picture, colorspace, dithering, 0);
  }
#line 651
  return (__cil_tmp4);
}
}
#line 654 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureARGBToYUVA(WebPPicture *picture , WebPEncCSP colorspace ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 655
  __cil_tmp3 = PictureARGBToYUVA(picture, colorspace, 0.f, 0);
  }
#line 655
  return (__cil_tmp3);
}
}
#line 658 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureSharpARGBToYUVA(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 659
  __cil_tmp2 = PictureARGBToYUVA(picture, (WebPEncCSP )0, 0.f, 1);
  }
#line 659
  return (__cil_tmp2);
}
}
#line 662 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureSmartARGBToYUVA(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 663
  __cil_tmp2 = WebPPictureSharpARGBToYUVA(picture);
  }
#line 663
  return (__cil_tmp2);
}
}
#line 669 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureYUVAToARGB(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int y ;
  int width ;
  int height ;
  int argb_stride ;
  uint8_t *dst ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *cur_y ;
  WebPUpsampleLinePairFunc upsample ;
  WebPUpsampleLinePairFunc __cil_tmp15 ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  uint32_t *argb_dst ;
  uint8_t *src ;
  int x ;

  {
#line 670
  if (picture == (void *)0) {
#line 670
    return (0);
  }
#line 671
  if (picture->y == (void *)0) {
    {
    {
    {
#line 672
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
    }
    }
#line 672
    return (__cil_tmp2);
  } else
#line 671
  if (picture->u == (void *)0) {
    {
    {
    {
#line 672
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
    }
    }
#line 672
    return (__cil_tmp2);
  } else
#line 671
  if (picture->v == (void *)0) {
    {
    {
    {
#line 672
    __cil_tmp2 = WebPEncodingSetError(picture, (WebPEncodingError )3);
    }
    }
    }
#line 672
    return (__cil_tmp2);
  }
#line 674
  if (picture->a == (void *)0) {
#line 674
    if ((unsigned int )picture->colorspace & 4U) {
      {
#line 675
      __cil_tmp3 = WebPEncodingSetError(picture, (WebPEncodingError )3);
      }
#line 675
      return (__cil_tmp3);
    }
  }
#line 677
  if (((unsigned int )picture->colorspace & 3U) != 0U) {
    {
#line 678
    __cil_tmp4 = WebPEncodingSetError(picture, (WebPEncodingError )4);
    }
#line 678
    return (__cil_tmp4);
  }
  {
#line 681
  __cil_tmp5 = WebPPictureAllocARGB(picture);
  }
#line 681
  if (! __cil_tmp5) {
#line 681
    return (0);
  }
#line 682
  picture->use_argb = 1;
#line 687
  width = picture->width;
#line 688
  height = picture->height;
#line 689
  argb_stride = 4 * picture->argb_stride;
#line 690
  dst = (uint8_t *)picture->argb;
#line 691
  cur_u = picture->u;
#line 691
  cur_v = picture->v;
  {
#line 691
  cur_y = picture->y;
#line 692
  __cil_tmp15 = WebPGetLinePairConverter(1);
#line 692
  upsample = __cil_tmp15;
#line 696
  (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst, (uint8_t *)((void *)0),
              width);
#line 697
  cur_y += picture->y_stride;
#line 698
  dst += argb_stride;
#line 700
  y = 1;
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! (y + 1 < height)) {
#line 700
      goto while_break;
    }
    {
#line 701
    top_u = cur_u;
#line 702
    top_v = cur_v;
#line 703
    cur_u += picture->uv_stride;
#line 704
    cur_v += picture->uv_stride;
#line 705
    (*upsample)(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v, dst,
                dst + argb_stride, width);
#line 707
    cur_y += 2 * picture->y_stride;
#line 708
    dst += 2 * argb_stride;
    }
#line 700
    y += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  if (height > 1) {
#line 711
    if (! (height & 1)) {
      {
#line 712
      (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst,
                  (uint8_t *)((void *)0), width);
      }
    }
  }
#line 715
  if ((unsigned int )picture->colorspace & 4U) {
#line 716
    y = 0;
    {
#line 716
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 716
      if (! (y < height)) {
#line 716
        goto while_break___0;
      }
#line 717
      argb_dst = picture->argb + y * picture->argb_stride;
#line 718
      src = picture->a + y * picture->a_stride;
#line 720
      x = 0;
      {
#line 720
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 720
        if (! (x < width)) {
#line 720
          goto while_break___1;
        }
#line 721
        *(argb_dst + x) = (*(argb_dst + x) & 16777215U) | ((uint32_t )*(src + x) << 24);
#line 720
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 716
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 726
  return (1);
}
}
#line 732 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
static int Import(WebPPicture *picture , uint8_t *rgb , int rgb_stride , int step ,
                  int swap_rb , int import_alpha ) 
{ 
  int y ;
  uint8_t *r_ptr ;
  int tmp ;
  uint8_t *g_ptr ;
  uint8_t *b_ptr ;
  int tmp___0 ;
  int width ;
  int height ;
  int __cil_tmp15 ;
  int tmp___1 ;
  uint8_t *a_ptr ;
  uint8_t *tmp___2 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  uint32_t *dst ;
  int do_copy ;
  uint32_t *dst___0 ;

  {
#line 737
  if (swap_rb) {
#line 737
    tmp = 2;
  } else {
#line 737
    tmp = 0;
  }
#line 737
  r_ptr = rgb + tmp;
#line 738
  g_ptr = rgb + 1;
#line 739
  if (swap_rb) {
#line 739
    tmp___0 = 0;
  } else {
#line 739
    tmp___0 = 2;
  }
#line 739
  b_ptr = rgb + tmp___0;
#line 740
  width = picture->width;
#line 741
  height = picture->height;
#line 743
  if (import_alpha) {
#line 743
    tmp___1 = 4;
  } else {
#line 743
    tmp___1 = 3;
  }
  {
#line 743
  __cil_tmp15 = abs(rgb_stride);
  }
#line 743
  if (__cil_tmp15 < tmp___1 * width) {
#line 743
    return (0);
  }
#line 745
  if (! picture->use_argb) {
#line 746
    if (import_alpha) {
#line 746
      tmp___2 = rgb + 3;
    } else {
#line 746
      tmp___2 = (uint8_t *)((void *)0);
    }
    {
#line 746
    a_ptr = tmp___2;
#line 747
    __cil_tmp19 = ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
                                     0.f, 0, picture);
    }
#line 747
    return (__cil_tmp19);
  }
  {
#line 750
  __cil_tmp20 = WebPPictureAlloc(picture);
  }
#line 750
  if (! __cil_tmp20) {
#line 750
    return (0);
  }
  {
#line 752
  VP8LDspInit();
#line 753
  WebPInitAlphaProcessing();
  }
#line 755
  if (import_alpha) {
#line 757
    dst = picture->argb;
#line 758
    do_copy = swap_rb;
#line 760
    if (do_copy) {
#line 761
      y = 0;
      {
#line 761
      while (1) {
        while_continue: /* CIL Label */ ;
#line 761
        if (! (y < height)) {
#line 761
          goto while_break;
        }
        {
#line 762
        memcpy(dst, rgb, (unsigned long )(width * 4));
#line 763
        rgb += rgb_stride;
#line 764
        dst += picture->argb_stride;
        }
#line 761
        y ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 767
      y = 0;
      {
#line 767
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 767
        if (! (y < height)) {
#line 767
          goto while_break___0;
        }
        {
#line 777
        (*VP8LConvertBGRAToRGBA)((uint32_t *)rgb, width, (uint8_t *)dst);
#line 779
        rgb += rgb_stride;
#line 780
        dst += picture->argb_stride;
        }
#line 767
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 784
    dst___0 = picture->argb;
#line 786
    y = 0;
    {
#line 786
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 786
      if (! (y < height)) {
#line 786
        goto while_break___1;
      }
      {
#line 787
      (*WebPPackRGB)(r_ptr, g_ptr, b_ptr, width, step, dst___0);
#line 788
      r_ptr += rgb_stride;
#line 789
      g_ptr += rgb_stride;
#line 790
      b_ptr += rgb_stride;
#line 791
      dst___0 += picture->argb_stride;
      }
#line 786
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 794
  return (1);
}
}
#line 801 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *bgr , int bgr_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 803
  if (picture != (void *)0 && bgr != (void *)0) {
    {
#line 803
    __cil_tmp4 = Import(picture, bgr, bgr_stride, 3, 1, 0);
#line 803
    tmp = __cil_tmp4;
    }
  } else {
#line 803
    tmp = 0;
  }
#line 803
  return (tmp);
}
}
#line 808 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *bgra , int bgra_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 810
  if (picture != (void *)0 && bgra != (void *)0) {
    {
#line 810
    __cil_tmp4 = Import(picture, bgra, bgra_stride, 4, 1, 1);
#line 810
    tmp = __cil_tmp4;
    }
  } else {
#line 810
    tmp = 0;
  }
#line 810
  return (tmp);
}
}
#line 816 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *bgrx , int bgrx_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 818
  if (picture != (void *)0 && bgrx != (void *)0) {
    {
#line 818
    __cil_tmp4 = Import(picture, bgrx, bgrx_stride, 4, 1, 0);
#line 818
    tmp = __cil_tmp4;
    }
  } else {
#line 818
    tmp = 0;
  }
#line 818
  return (tmp);
}
}
#line 825 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 827
  if (picture != (void *)0 && rgb != (void *)0) {
    {
#line 827
    __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 0, 0);
#line 827
    tmp = __cil_tmp4;
    }
  } else {
#line 827
    tmp = 0;
  }
#line 827
  return (tmp);
}
}
#line 832 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 834
  if (picture != (void *)0 && rgba != (void *)0) {
    {
#line 834
    __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 1);
#line 834
    tmp = __cil_tmp4;
    }
  } else {
#line 834
    tmp = 0;
  }
#line 834
  return (tmp);
}
}
#line 839 "/doner/libwebp/libwebp-31bea324/src/enc/picture_csp_enc.c"
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgbx , int rgbx_stride ) 
{ 
  int __cil_tmp4 ;
  int tmp ;

  {
#line 841
  if (picture != (void *)0 && rgbx != (void *)0) {
    {
#line 841
    __cil_tmp4 = Import(picture, rgbx, rgbx_stride, 4, 0, 0);
#line 841
    tmp = __cil_tmp4;
    }
  } else {
#line 841
    tmp = 0;
  }
#line 841
  return (tmp);
}
}
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 65 "../src/webp/mux_types.h"
__inline static void WebPDataInit(WebPData *webp_data ) 
{ 


  {
#line 66
  if (webp_data != (void *)0) {
    {
#line 67
    memset(webp_data, 0, sizeof(*webp_data));
    }
  }
  return;
}
}
#line 73 "../src/webp/mux_types.h"
__inline static void WebPDataClear(WebPData *webp_data ) 
{ 


  {
#line 74
  if (webp_data != (void *)0) {
    {
#line 75
    WebPFree((void *)webp_data->bytes);
#line 76
    WebPDataInit(webp_data);
    }
  }
  return;
}
}
#line 82 "../src/webp/mux_types.h"
__inline static int WebPDataCopy(WebPData *src , WebPData *dst ) 
{ 
  void *__cil_tmp3 ;

  {
#line 83
  if (src == (void *)0) {
#line 83
    return (0);
  } else
#line 83
  if (dst == (void *)0) {
#line 83
    return (0);
  }
  {
#line 84
  WebPDataInit(dst);
  }
#line 85
  if (src->bytes != (void *)0) {
#line 85
    if (src->size != 0UL) {
      {
#line 86
      __cil_tmp3 = WebPMalloc(src->size);
#line 86
      dst->bytes = (uint8_t *)__cil_tmp3;
      }
#line 87
      if (dst->bytes == (void *)0) {
#line 87
        return (0);
      }
      {
#line 88
      memcpy((void *)dst->bytes, src->bytes, src->size);
#line 89
      dst->size = src->size;
      }
    }
  }
#line 91
  return (1);
}
}
#line 29 "/doner/libwebp/libwebp-31bea324/examples/../examples/example_util.h"
uint32_t ExUtilGetUInt(char const   * const  v , int base , int * const  error ) ;
#line 30
int ExUtilGetInt(char const   * const  v , int base , int * const  error ) ;
#line 31
float ExUtilGetFloat(char const   * const  v , int * const  error ) ;
#line 37
int ExUtilGetInts(char const   *v , int base , int max_output , int output[] ) ;
#line 41
int ExUtilReadFileToWebPData(char const   * const  filename , WebPData * const  webp_data ) ;
#line 60
int ExUtilInitCommandLineArguments(int argc , char const   *argv[] , CommandLineArguments * const  args ) ;
#line 64
void ExUtilDeleteCommandLineArguments(CommandLineArguments * const  args ) ;
#line 35 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./metadata.h"
void MetadataInit(Metadata * const  metadata ) ;
#line 36
void MetadataPayloadDelete(MetadataPayload * const  payload ) ;
#line 37
void MetadataFree(Metadata * const  metadata ) ;
#line 40
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload * const  payload ) ;
#line 29 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./jpegdec.h"
int ReadJPEG(uint8_t * const  data , size_t data_size , struct WebPPicture * const  pic ,
             int keep_alpha , struct Metadata * const  metadata ) ;
#line 29 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./pngdec.h"
int ReadPNG(uint8_t * const  data , size_t data_size , struct WebPPicture * const  pic ,
            int keep_alpha , struct Metadata * const  metadata ) ;
#line 29 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./pnmdec.h"
int ReadPNM(uint8_t * const  data , size_t data_size , struct WebPPicture * const  pic ,
            int keep_alpha , struct Metadata * const  metadata ) ;
#line 29 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./tiffdec.h"
int ReadTIFF(uint8_t * const  data , size_t data_size , struct WebPPicture * const  pic ,
             int keep_alpha , struct Metadata * const  metadata ) ;
#line 30 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./webpdec.h"
void PrintWebPError(char const   * const  in_file , int status ) ;
#line 35
int LoadWebP(char const   * const  in_file , uint8_t **data , size_t *data_size ,
             WebPBitstreamFeatures *bitstream ) ;
#line 44
VP8StatusCode DecodeWebP(uint8_t * const  data , size_t data_size , WebPDecoderConfig * const  config ) ;
#line 48
VP8StatusCode DecodeWebPIncremental(uint8_t * const  data , size_t data_size , WebPDecoderConfig * const  config ) ;
#line 59
int ReadWebP(uint8_t * const  data , size_t data_size , struct WebPPicture * const  pic ,
             int keep_alpha , struct Metadata * const  metadata ) ;
#line 26 "/doner/libwebp/libwebp-31bea324/examples/../imageio/./wicdec.h"
int ReadPictureWithWIC(char const   * const  filename , struct WebPPicture * const  pic ,
                       int keep_alpha , struct Metadata * const  metadata ) ;
#line 45 "/doner/libwebp/libwebp-31bea324/examples/../imageio/image_dec.h"
char const   *WebPGetEnabledInputFileFormats(void) ;
#line 49
WebPInputFileFormat WebPGuessImageType(uint8_t * const  data , size_t data_size ) ;
#line 58
WebPImageReader WebPGetImageReader(WebPInputFileFormat format ) ;
#line 63
WebPImageReader WebPGuessImageReader(uint8_t * const  data , size_t data_size ) ;
#line 28 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h"
FILE *ImgIoUtilSetBinaryMode(FILE *file ) ;
#line 38
int ImgIoUtilReadFile(char const   * const  file_name , uint8_t **data , size_t *data_size ) ;
#line 42
int ImgIoUtilReadFromStdin(uint8_t **data , size_t *data_size ) ;
#line 46
int ImgIoUtilWriteFile(char const   * const  file_name , uint8_t *data , size_t data_size ) ;
#line 52
void ImgIoUtilCopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                        int width , int height ) ;
#line 58
int ImgIoUtilCheckSizeArgumentsOverflow(uint64_t stride , size_t height ) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 47 "/doner/libwebp/libwebp-31bea324/examples/./stopwatch.h"
__inline static void StopwatchReset(Stopwatch *watch ) 
{ 


  {
  {
#line 48
  gettimeofday(watch, (void *)0);
  }
  return;
}
}
#line 51 "/doner/libwebp/libwebp-31bea324/examples/./stopwatch.h"
__inline static double StopwatchReadAndReset(Stopwatch *watch ) 
{ 
  struct timeval old_value ;
  double delta_sec ;
  double delta_usec ;

  {
  {
#line 54
  memcpy(& old_value, watch, sizeof(old_value));
#line 55
  gettimeofday(watch, (void *)0);
#line 56
  delta_sec = (double )watch->tv_sec - (double )old_value.tv_sec;
#line 57
  delta_usec = (double )watch->tv_usec - (double )old_value.tv_usec;
  }
#line 58
  return (delta_sec + delta_usec / 1000000.);
}
}
#line 47 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int verbose  =    0;
#line 49 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int ReadYUV(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  int use_argb ;
  int uv_width ;
  int uv_height ;
  int y_plane_size ;
  int uv_plane_size ;
  size_t expected_data_size ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp ;

  {
#line 51
  use_argb = pic->use_argb;
#line 52
  uv_width = (pic->width + 1) / 2;
#line 53
  uv_height = (pic->height + 1) / 2;
#line 54
  y_plane_size = pic->width * pic->height;
#line 55
  uv_plane_size = uv_width * uv_height;
#line 56
  expected_data_size = (size_t )(y_plane_size + 2 * uv_plane_size);
#line 58
  if (data_size != expected_data_size) {
    {
#line 59
    fprintf(stderr, "input data doesn\'t have the expected size (%d instead of %d)\n",
            (int )data_size, (int )expected_data_size);
    }
#line 62
    return (0);
  }
  {
#line 65
  pic->use_argb = 0;
#line 66
  __cil_tmp10 = WebPPictureAlloc(pic);
  }
#line 66
  if (! __cil_tmp10) {
#line 66
    return (0);
  }
  {
#line 67
  ImgIoUtilCopyPlane(data, pic->width, pic->y, pic->y_stride, pic->width, pic->height);
#line 69
  ImgIoUtilCopyPlane(data + y_plane_size, uv_width, pic->u, pic->uv_stride, uv_width,
                     uv_height);
#line 71
  ImgIoUtilCopyPlane((data + y_plane_size) + uv_plane_size, uv_width, pic->v, pic->uv_stride,
                     uv_width, uv_height);
  }
#line 73
  if (use_argb) {
    {
#line 73
    __cil_tmp11 = WebPPictureYUVAToARGB(pic);
#line 73
    tmp = __cil_tmp11;
    }
  } else {
#line 73
    tmp = 1;
  }
#line 73
  return (tmp);
}
}
#line 104 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int ReadPicture(char const   *filename , WebPPicture *pic , int keep_alpha ,
                       Metadata *metadata ) 
{ 
  uint8_t *data ;
  size_t data_size ;
  int ok ;
  int __cil_tmp8 ;
  WebPImageReader reader ;
  WebPImageReader __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 106
  data = (uint8_t *)((void *)0);
#line 107
  data_size = (size_t )0;
#line 108
  ok = 0;
#line 110
  ok = ImgIoUtilReadFile(filename, & data, & data_size);
  }
#line 111
  if (! ok) {
#line 111
    goto End;
  }
#line 113
  if (pic->width == 0) {
    {
    {
#line 114
    __cil_tmp10 = WebPGuessImageReader(data, data_size);
    }
#line 114
    reader = __cil_tmp10;
    {
#line 115
    ok = (*reader)(data, data_size, pic, keep_alpha, metadata);
    }
    }
  } else
#line 113
  if (pic->height == 0) {
    {
    {
#line 114
    __cil_tmp10 = WebPGuessImageReader(data, data_size);
    }
#line 114
    reader = __cil_tmp10;
    {
#line 115
    ok = (*reader)(data, data_size, pic, keep_alpha, metadata);
    }
    }
  } else {
    {
#line 118
    ok = ReadYUV(data, data_size, pic);
    }
  }
  End: 
#line 121
  if (! ok) {
    {
#line 122
    fprintf(stderr, "Error! Could not process file %s\n", (char const   *)filename);
    }
  }
  {
#line 125
  WebPFree((void *)data);
  }
#line 126
  return (ok);
}
}
#line 131 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void AllocExtraInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  void *__cil_tmp4 ;

  {
  {
#line 132
  mb_w = (pic->width + 15) / 16;
#line 133
  mb_h = (pic->height + 15) / 16;
#line 134
  __cil_tmp4 = WebPMalloc((unsigned long )(mb_w * mb_h) * sizeof(*(pic->extra_info)));
#line 134
  pic->extra_info = (uint8_t *)__cil_tmp4;
  }
  return;
}
}
#line 138 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintByteCount(int const   bytes[4] , int total_size , int *totals ) 
{ 
  int s ;
  int total ;

  {
#line 141
  total = 0;
#line 142
  s = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (s < 4)) {
#line 142
      goto while_break;
    }
    {
#line 143
    fprintf(stderr, "| %7d ", bytes[s]);
#line 144
    total += bytes[s];
    }
#line 145
    if (totals) {
#line 145
      *(totals + s) += bytes[s];
    }
#line 142
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  fprintf(stderr, "| %7d  (%.1f%%)\n\230\001", total, (double )((100.f * (float )total) / (float )total_size));
  }
  return;
}
}
#line 150 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintPercents(int const   counts[4] ) 
{ 
  int s ;
  int total ;

  {
#line 152
  total = ((counts[0] + counts[1]) + counts[2]) + counts[3];
#line 153
  s = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (s < 4)) {
#line 153
      goto while_break;
    }
    {
#line 154
    fprintf(stderr, "|     %3d%%", (int )((100. * (double )counts[s]) / (double )total + 0.5));
    }
#line 153
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  fprintf(stderr, "| %7d\n", total);
  }
  return;
}
}
#line 159 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintValues(int const   values[4] ) 
{ 
  int s ;

  {
#line 161
  s = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (s < 4)) {
#line 161
      goto while_break;
    }
    {
#line 162
    fprintf(stderr, "| %7d ", values[s]);
    }
#line 161
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  fprintf(stderr, "|\n");
  }
  return;
}
}
#line 167 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintFullLosslessInfo(WebPAuxStats *stats , char const   *description ) 
{ 


  {
  {
#line 169
  fprintf(stderr, "Lossless-%s compressed size: %d bytes\n", description, stats->lossless_size);
#line 171
  fprintf(stderr, "  * Header size: %d bytes, image data size: %d\n", stats->lossless_hdr_size,
          stats->lossless_data_size);
  }
#line 173
  if (stats->lossless_features) {
    {
#line 174
    fprintf(stderr, "  * Lossless features used:");
    }
#line 175
    if (stats->lossless_features & 1U) {
      {
#line 175
      fprintf(stderr, " PREDICTION");
      }
    }
#line 176
    if (stats->lossless_features & 2U) {
      {
#line 176
      fprintf(stderr, " CROSS-COLOR-TRANSFORM");
      }
    }
#line 177
    if (stats->lossless_features & 4U) {
      {
#line 177
      fprintf(stderr, " SUBTRACT-GREEN");
      }
    }
#line 178
    if (stats->lossless_features & 8U) {
      {
#line 178
      fprintf(stderr, " PALETTE\220");
      }
    }
    {
#line 179
    fprintf(stderr, "\n");
    }
  }
  {
#line 181
  fprintf(stderr, "  * Precision Bits: histogram=%d transform=%d cache=%d\n", stats->histogram_bits,
          stats->transform_bits, stats->cache_bits);
  }
#line 183
  if (stats->palette_size > 0) {
    {
#line 184
    fprintf(stderr, "  * Palette size:   %d\n", stats->palette_size);
    }
  }
  return;
}
}
#line 188 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintExtraInfoLossless(WebPPicture *pic , int short_output , char const   *file_name ) 
{ 
  WebPAuxStats *stats ;

  {
#line 191
  stats = pic->stats;
#line 192
  if (short_output) {
    {
#line 193
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 195
    fprintf(stderr, "File:      %s\n", (char const   *)file_name);
#line 196
    fprintf(stderr, "Dimension: %d x %d\n", pic->width, pic->height);
#line 197
    fprintf(stderr, "Output:    %d bytes (%.2f bpp)\n", stats->coded_size, (double )(((8.f * (float )stats->coded_size) / (float )pic->width) / (float )pic->height));
#line 199
    PrintFullLosslessInfo(stats, "ARGB");
    }
  }
  return;
}
}
#line 203 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintExtraInfoLossy(WebPPicture *pic , int short_output , int full_details ,
                                char const   *file_name ) 
{ 
  WebPAuxStats *stats ;
  int num_i4 ;
  int num_i16 ;
  int num_skip ;
  int total ;
  char const   *tmp ;
  int totals[4] ;

  {
#line 206
  stats = pic->stats;
#line 207
  if (short_output) {
    {
#line 208
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 210
    num_i4 = stats->block_count[0];
#line 211
    num_i16 = stats->block_count[1];
#line 212
    num_skip = stats->block_count[2];
#line 213
    total = num_i4 + num_i16;
#line 214
    fprintf(stderr, "File:      %s\n", (char const   *)file_name);
    }
#line 215
    if (stats->alpha_data_size) {
#line 215
      tmp = " (with alpha)";
    } else {
#line 215
      tmp = "\220";
    }
    {
#line 215
    fprintf(stderr, "Dimension: %d x %d%s\n", pic->width, pic->height, tmp);
#line 218
    fprintf(stderr, "Output:    %d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n           (%.2f bpp)\n",
            stats->coded_size, (double )stats->PSNR[0], (double )stats->PSNR[1], (double )stats->PSNR[2],
            (double )stats->PSNR[3], (double )(((8.f * (float )stats->coded_size) / (float )pic->width) / (float )pic->height));
    }
#line 224
    if (total > 0) {
      {
#line 225
      totals[0] = 0;
#line 225
      totals[1] = 0;
#line 225
      totals[2] = 0;
#line 225
      totals[3] = 0;
#line 226
      fprintf(stderr, "block count:  intra4:     %6d  (%.2f%%)\n              intra16:    %6d  (%.2f%%)\n              skipped:    %6d  (%.2f%%)\n\230\001",
              num_i4, (double )((100.f * (float )num_i4) / (float )total), num_i16,
              (double )((100.f * (float )num_i16) / (float )total), num_skip, (double )((100.f * (float )num_skip) / (float )total));
#line 232
      fprintf(stderr, "bytes used:  header:         %6d  (%.1f%%)\n             mode-partition: %6d  (%.1f%%)\n",
              stats->header_bytes[0], (double )((100.f * (float )stats->header_bytes[0]) / (float )stats->coded_size),
              stats->header_bytes[1], (double )((100.f * (float )stats->header_bytes[1]) / (float )stats->coded_size));
      }
#line 238
      if (stats->alpha_data_size > 0) {
        {
#line 239
        fprintf(stderr, "             transparency:   %6d (%.1f dB)\n", stats->alpha_data_size,
                (double )stats->PSNR[4]);
        }
      }
      {
#line 242
      fprintf(stderr, " Residuals bytes  |segment 1|segment 2|segment 3|segment 4|  total\n");
      }
#line 245
      if (full_details) {
        {
#line 246
        fprintf(stderr, "  intra4-coeffs:  ");
#line 247
        PrintByteCount((int const   *)stats->residual_bytes[0], stats->coded_size,
                       (int *)totals);
#line 248
        fprintf(stderr, " intra16-coeffs:  ");
#line 249
        PrintByteCount((int const   *)stats->residual_bytes[1], stats->coded_size,
                       (int *)totals);
#line 250
        fprintf(stderr, "  chroma coeffs:  ");
#line 251
        PrintByteCount((int const   *)stats->residual_bytes[2], stats->coded_size,
                       (int *)totals);
        }
      }
      {
#line 253
      fprintf(stderr, "    macroblocks:  ");
#line 254
      PrintPercents((int const   *)stats->segment_size);
#line 255
      fprintf(stderr, "      quantizer:  ");
#line 256
      PrintValues((int const   *)stats->segment_quant);
#line 257
      fprintf(stderr, "   filter level:  ");
#line 258
      PrintValues((int const   *)stats->segment_level);
      }
#line 259
      if (full_details) {
        {
#line 260
        fprintf(stderr, "------------------+---------");
#line 261
        fprintf(stderr, "+---------+---------+---------+-----------------\n");
#line 262
        fprintf(stderr, " segments total:  ");
#line 263
        PrintByteCount((int const   [4])((int *)totals), stats->coded_size, (int *)((void *)0));
        }
      }
    }
#line 266
    if (stats->lossless_size > 0) {
      {
#line 267
      PrintFullLosslessInfo(stats, "alpha");
      }
    }
  }
  return;
}
}
#line 272 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintMapInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  int type ;
  int x ;
  int y ;
  int c ;

  {
#line 273
  if (pic->extra_info != (void *)0) {
#line 274
    mb_w = (pic->width + 15) / 16;
#line 275
    mb_h = (pic->height + 15) / 16;
#line 276
    type = pic->extra_info_type;
#line 278
    y = 0;
    {
#line 278
    while (1) {
      while_continue: /* CIL Label */ ;
#line 278
      if (! (y < mb_h)) {
#line 278
        goto while_break;
      }
#line 279
      x = 0;
      {
#line 279
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 279
        if (! (x < mb_w)) {
#line 279
          goto while_break___0;
        }
#line 280
        c = (int )*(pic->extra_info + (x + y * mb_w));
#line 281
        if (type == 1) {
          {
#line 282
          fprintf(stderr, "%c", (int )*("+." + c));
          }
        } else
#line 283
        if (type == 2) {
          {
#line 284
          fprintf(stderr, "%c", (int )*(".-*X" + c));
          }
        } else
#line 285
        if (type == 3) {
          {
#line 286
          fprintf(stderr, "%.2d ", c);
          }
        } else
#line 287
        if (type == 6) {
          {
          {
#line 288
          fprintf(stderr, "%3d ", c);
          }
          }
        } else
#line 287
        if (type == 7) {
          {
          {
#line 288
          fprintf(stderr, "%3d ", c);
          }
          }
        } else {
          {
#line 290
          fprintf(stderr, "0x%.2x ", c);
          }
        }
#line 279
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 293
      fprintf(stderr, "\n");
      }
#line 278
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 300 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int MyWriter(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  FILE *out ;
  unsigned long __cil_tmp5 ;
  unsigned long tmp ;

  {
#line 302
  out = (FILE *)pic->custom_ptr;
#line 303
  if (data_size) {
    {
#line 303
    __cil_tmp5 = fwrite(data, data_size, (unsigned long )1, out);
#line 303
    tmp = __cil_tmp5 == 1UL;
    }
  } else {
#line 303
    tmp = (unsigned long )1;
  }
#line 303
  return ((int )tmp);
}
}
#line 307 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int DumpPicture(WebPPicture *picture , char const   *PGM_name ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;
  int stride ;
  uint8_t *src_y ;
  uint8_t *src_u ;
  uint8_t *src_v ;
  uint8_t *src_a ;
  int alpha_height ;
  int __cil_tmp12 ;
  int tmp ;
  int height ;
  FILE *f ;
  FILE *__cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;

  {
  {
#line 309
  uv_width = (picture->width + 1) / 2;
#line 310
  uv_height = (picture->height + 1) / 2;
#line 311
  stride = (picture->width + 1) & -2;
#line 312
  src_y = picture->y;
#line 313
  src_u = picture->u;
#line 314
  src_v = picture->v;
#line 315
  src_a = picture->a;
#line 316
  __cil_tmp12 = WebPPictureHasTransparency(picture);
  }
#line 316
  if (__cil_tmp12) {
#line 316
    tmp = picture->height;
  } else {
#line 316
    tmp = 0;
  }
  {
#line 316
  alpha_height = tmp;
#line 318
  height = (picture->height + uv_height) + alpha_height;
#line 319
  __cil_tmp16 = fopen(PGM_name, "wb\001");
#line 319
  f = __cil_tmp16;
  }
#line 320
  if (f == (void *)0) {
#line 320
    return (0);
  }
  {
#line 321
  fprintf(f, "P5\n%d %d\n255\n", stride, height);
#line 322
  y = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (y < picture->height)) {
#line 322
      goto while_break;
    }
    {
#line 323
    __cil_tmp17 = fwrite(src_y, (unsigned long )picture->width, (unsigned long )1,
                         f);
    }
#line 323
    if (__cil_tmp17 != 1UL) {
#line 323
      return (0);
    }
#line 324
    if (picture->width & 1) {
      {
#line 324
      fputc(0, f);
      }
    }
#line 325
    src_y += picture->y_stride;
#line 322
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  y = 0;
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (y < uv_height)) {
#line 327
      goto while_break___0;
    }
    {
#line 328
    __cil_tmp18 = fwrite(src_u, (unsigned long )uv_width, (unsigned long )1, f);
    }
#line 328
    if (__cil_tmp18 != 1UL) {
#line 328
      return (0);
    }
    {
#line 329
    __cil_tmp19 = fwrite(src_v, (unsigned long )uv_width, (unsigned long )1, f);
    }
#line 329
    if (__cil_tmp19 != 1UL) {
#line 329
      return (0);
    }
#line 330
    src_u += picture->uv_stride;
#line 331
    src_v += picture->uv_stride;
#line 327
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 333
  y = 0;
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 333
    if (! (y < alpha_height)) {
#line 333
      goto while_break___1;
    }
    {
#line 334
    __cil_tmp20 = fwrite(src_a, (unsigned long )picture->width, (unsigned long )1,
                         f);
    }
#line 334
    if (__cil_tmp20 != 1UL) {
#line 334
      return (0);
    }
#line 335
    if (picture->width & 1) {
      {
#line 335
      fputc(0, f);
      }
    }
#line 336
    src_a += picture->a_stride;
#line 333
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 338
  fclose(f);
  }
#line 339
  return (1);
}
}
#line 352 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int const   kChunkHeaderSize  =    8;
#line 353 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int const   kTagSize  =    4;
#line 355 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void PrintMetadataInfo(Metadata *metadata , int metadata_written ) 
{ 


  {
#line 357
  if (metadata == (void *)0) {
#line 357
    return;
  } else
#line 357
  if (metadata_written == 0) {
#line 357
    return;
  }
  {
#line 359
  fprintf(stderr, "Metadata:\n");
  }
#line 360
  if (metadata_written & 2) {
    {
#line 361
    fprintf(stderr, "  * ICC profile:  %6d bytes\n", (int )metadata->iccp.size);
    }
  }
#line 363
  if (metadata_written & 1) {
    {
#line 364
    fprintf(stderr, "  * EXIF data:    %6d bytes\nmU", (int )metadata->exif.size);
    }
  }
#line 366
  if (metadata_written & 4) {
    {
#line 367
    fprintf(stderr, "  * XMP data:     %6d bytes\nmU", (int )metadata->xmp.size);
    }
  }
  return;
}
}
#line 372 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int WriteLE(FILE *out , uint32_t val , int num ) 
{ 
  uint8_t buf[4] ;
  int i ;
  unsigned long __cil_tmp6 ;

  {
#line 375
  i = 0;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i < num)) {
#line 375
      goto while_break;
    }
#line 376
    buf[i] = (uint8_t )(val & 255U);
#line 377
    val >>= 8;
#line 375
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  __cil_tmp6 = fwrite((uint8_t *)buf, (unsigned long )num, (unsigned long )1, out);
  }
#line 379
  return (__cil_tmp6 == 1UL);
}
}
#line 382 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int WriteLE24(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 383
  __cil_tmp3 = WriteLE(out, val, 3);
  }
#line 383
  return (__cil_tmp3);
}
}
#line 386 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int WriteLE32(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 387
  __cil_tmp3 = WriteLE(out, val, 4);
  }
#line 387
  return (__cil_tmp3);
}
}
#line 390 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int WriteMetadataChunk(FILE *out , char const   fourcc[4] , MetadataPayload *payload ) 
{ 
  uint8_t zero ;
  size_t need_padding ;
  int ok ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 392
  zero = (uint8_t )0;
#line 393
  need_padding = payload->size & 1UL;
#line 394
  __cil_tmp7 = fwrite(fourcc, (unsigned long )kTagSize, (unsigned long )1, out);
#line 394
  ok = __cil_tmp7 == 1UL;
#line 395
  __cil_tmp8 = WriteLE32(out, (uint32_t )payload->size);
#line 395
  ok = ok && __cil_tmp8;
#line 396
  __cil_tmp9 = fwrite(payload->bytes, payload->size, (unsigned long )1, out);
#line 396
  ok = ok && __cil_tmp9 == 1UL;
#line 397
  __cil_tmp10 = fwrite(& zero, need_padding, need_padding, out);
  }
#line 397
  return (ok && __cil_tmp10 == need_padding);
}
}
#line 402 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int UpdateFlagsAndSize(MetadataPayload *payload , int keep , int flag , uint32_t *vp8x_flags ,
                              uint64_t *metadata_size ) 
{ 


  {
#line 405
  if (payload->bytes != (void *)0) {
#line 405
    if (keep) {
#line 405
      if (payload->size > 0UL) {
#line 406
        *vp8x_flags |= (unsigned int )flag;
#line 407
        *metadata_size += ((unsigned long )kChunkHeaderSize + payload->size) + (payload->size & 1UL);
#line 408
        return (1);
      }
    }
  }
#line 410
  return (0);
}
}
#line 417 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int WriteWebPWithMetadata(FILE *out , WebPPicture *picture , WebPMemoryWriter *memory_writer ,
                                 Metadata *metadata , int keep_metadata , int *metadata_written ) 
{ 
  char const   kVP8XHeader[9] ;
  int kAlphaFlag ;
  int kEXIFFlag ;
  int kICCPFlag ;
  int kXMPFlag ;
  size_t kRiffHeaderSize ;
  size_t kMaxChunkPayload ;
  size_t kMinSize ;
  uint32_t flags ;
  uint64_t metadata_size ;
  int write_exif ;
  int __cil_tmp18 ;
  int write_iccp ;
  int __cil_tmp20 ;
  int write_xmp ;
  int __cil_tmp22 ;
  uint8_t *webp ;
  size_t webp_size ;
  int kVP8XChunkSize ;
  int has_vp8x ;
  int __cil_tmp27 ;
  uint32_t riff_size ;
  int tmp ;
  int ok ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int is_lossless ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;

  {
  {
#line 423
  kVP8XHeader = "VP8X\n";
#line 424
  kAlphaFlag = 16;
#line 425
  kEXIFFlag = 8;
#line 426
  kICCPFlag = 32;
#line 427
  kXMPFlag = 4;
#line 428
  kRiffHeaderSize = (size_t )12;
#line 429
  kMaxChunkPayload = (size_t )((-1 - kChunkHeaderSize) - 1);
#line 430
  kMinSize = kRiffHeaderSize + (unsigned long )kChunkHeaderSize;
#line 431
  flags = (uint32_t )0;
#line 432
  metadata_size = (uint64_t )0;
#line 433
  __cil_tmp18 = UpdateFlagsAndSize(& metadata->exif, ! (! (keep_metadata & 1)), kEXIFFlag,
                                   & flags, & metadata_size);
#line 433
  write_exif = __cil_tmp18;
#line 436
  __cil_tmp20 = UpdateFlagsAndSize(& metadata->iccp, ! (! (keep_metadata & 2)), kICCPFlag,
                                   & flags, & metadata_size);
#line 436
  write_iccp = __cil_tmp20;
#line 439
  __cil_tmp22 = UpdateFlagsAndSize(& metadata->xmp, ! (! (keep_metadata & 4)), kXMPFlag,
                                   & flags, & metadata_size);
#line 439
  write_xmp = __cil_tmp22;
#line 442
  webp = memory_writer->mem;
#line 443
  webp_size = memory_writer->size;
#line 445
  *metadata_written = 0;
  }
#line 447
  if (webp_size < kMinSize) {
#line 447
    return (0);
  }
#line 448
  if ((webp_size - (unsigned long )kChunkHeaderSize) + metadata_size > kMaxChunkPayload) {
    {
#line 449
    fprintf(stderr, "Error! Addition of metadata would exceed container size limit.\n");
    }
#line 451
    return (0);
  }
#line 454
  if (metadata_size > 0UL) {
    {
#line 455
    kVP8XChunkSize = 18;
#line 456
    __cil_tmp27 = memcmp(webp + kRiffHeaderSize, "VP8X", (unsigned long )kTagSize);
#line 456
    has_vp8x = ! __cil_tmp27;
    }
#line 457
    if (has_vp8x) {
#line 457
      tmp = 0;
    } else {
#line 457
      tmp = kVP8XChunkSize;
    }
    {
#line 457
    riff_size = (uint32_t )(((webp_size - (unsigned long )kChunkHeaderSize) + (unsigned long )tmp) + metadata_size);
#line 461
    __cil_tmp31 = fwrite(webp, (unsigned long )kTagSize, (unsigned long )1, out);
#line 461
    ok = __cil_tmp31 == 1UL;
#line 463
    __cil_tmp32 = WriteLE32(out, riff_size);
#line 463
    ok = ok && __cil_tmp32;
#line 464
    webp += kChunkHeaderSize;
#line 465
    webp_size -= (unsigned long )kChunkHeaderSize;
#line 467
    __cil_tmp33 = fwrite(webp, (unsigned long )kTagSize, (unsigned long )1, out);
#line 467
    ok = ok && __cil_tmp33 == 1UL;
#line 468
    webp += kTagSize;
#line 469
    webp_size -= (unsigned long )kTagSize;
    }
#line 470
    if (has_vp8x) {
      {
#line 471
      *(webp + kChunkHeaderSize) |= (int )((uint8_t )(flags & 255U));
#line 472
      __cil_tmp34 = fwrite(webp, (unsigned long )kVP8XChunkSize, (unsigned long )1,
                           out);
#line 472
      ok = ok && __cil_tmp34 == 1UL;
#line 473
      webp += kVP8XChunkSize;
#line 474
      webp_size -= (unsigned long )kVP8XChunkSize;
      }
    } else {
      {
#line 476
      __cil_tmp36 = memcmp(webp, "VP8L", (unsigned long )kTagSize);
#line 476
      is_lossless = ! __cil_tmp36;
      }
#line 477
      if (is_lossless) {
#line 480
        if ((int )*(webp + (kChunkHeaderSize + 4)) & (1 << 4)) {
#line 480
          flags |= (unsigned int )kAlphaFlag;
        }
      }
      {
#line 482
      __cil_tmp37 = fwrite((char const   *)kVP8XHeader, (unsigned long )kChunkHeaderSize,
                           (unsigned long )1, out);
#line 482
      ok = ok && __cil_tmp37 == 1UL;
#line 483
      __cil_tmp38 = WriteLE32(out, flags);
#line 483
      ok = ok && __cil_tmp38;
#line 484
      __cil_tmp39 = WriteLE24(out, (uint32_t )(picture->width - 1));
#line 484
      ok = ok && __cil_tmp39;
#line 485
      __cil_tmp40 = WriteLE24(out, (uint32_t )(picture->height - 1));
#line 485
      ok = ok && __cil_tmp40;
      }
    }
#line 487
    if (write_iccp) {
      {
#line 488
      __cil_tmp41 = WriteMetadataChunk(out, (char const   [4])"ICCP", & metadata->iccp);
#line 488
      ok = ok && __cil_tmp41;
#line 489
      *metadata_written |= 2;
      }
    }
    {
#line 492
    __cil_tmp42 = fwrite(webp, webp_size, (unsigned long )1, out);
#line 492
    ok = ok && __cil_tmp42 == 1UL;
    }
#line 493
    if (write_exif) {
      {
#line 494
      __cil_tmp43 = WriteMetadataChunk(out, (char const   [4])"EXIF", & metadata->exif);
#line 494
      ok = ok && __cil_tmp43;
#line 495
      *metadata_written |= 1;
      }
    }
#line 497
    if (write_xmp) {
      {
#line 498
      __cil_tmp44 = WriteMetadataChunk(out, (char const   [4])"XMP ", & metadata->xmp);
#line 498
      ok = ok && __cil_tmp44;
#line 499
      *metadata_written |= 4;
      }
    }
#line 501
    return (ok);
  }
  {
#line 505
  __cil_tmp45 = fwrite(webp, webp_size, (unsigned long )1, out);
  }
#line 505
  return (__cil_tmp45 == 1UL);
}
}
#line 510 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static int ProgressReport(int percent , WebPPicture *picture ) 
{ 


  {
  {
#line 511
  fprintf(stderr, "[%s]: %3d %%      \r", (char *)picture->user_data, percent);
  }
#line 513
  return (1);
}
}
#line 518 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void HelpShort(void) 
{ 


  {
  {
#line 519
  printf("Usage:\n\n\220");
#line 520
  printf("   cwebp [options] -q quality input.png -o output.webp\n\n\220");
#line 521
  printf("where quality is between 0 (poor) to 100 (very good).\n");
#line 522
  printf("Typical value is around 80.\n\n");
#line 523
  printf("Try -longhelp for an exhaustive list of advanced options.\n");
  }
  return;
}
}
#line 526 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static void HelpLong(void) 
{ 
  char const   *__cil_tmp1 ;

  {
  {
#line 527
  printf("Usage:\n");
#line 528
  printf(" cwebp [-preset <...>] [options] in_file [-o out_file]\n\n\220");
#line 529
  printf("If input size (-s) for an image is not specified, it is\nassumed to be a PNG, JPEG, TIFF or WebP file.\n/\022mU");
#line 531
  printf("Note: Animated PNG and WebP files are not supported.\n");
#line 535
  printf("\nOptions:\n/\022mU");
#line 536
  printf("  -h / -help ............. short help\n");
#line 537
  printf("  -H / -longhelp ......... long help\nU");
#line 538
  printf("  -q <float> ............. quality factor (0:small..100:big), default=75\nU");
#line 540
  printf("  -alpha_q <int> ......... transparency-compression quality (0..100),\n                           default=100\n");
#line 542
  printf("  -preset <string> ....... preset setting, one of:\n");
#line 543
  printf("                            default, photo, picture,\n");
#line 544
  printf("                            drawing, icon, text\n\220");
#line 545
  printf("     -preset must come first, as it overwrites other parameters\n\220");
#line 546
  printf("  -z <int> ............... activates lossless preset with given\n                           level in [0:fast, ..., 9:slowest]\n");
#line 548
  printf("\n\0300\022mU");
#line 549
  printf("  -m <int> ............... compression method (0=fast, 6=slowest), default=4\n#0\022mU");
#line 551
  printf("  -segments <int> ........ number of segments to use (1..4), default=4\n\022mU");
#line 553
  printf("  -size <int> ............ target size (in bytes)\n");
#line 554
  printf("  -psnr <float> .......... target PSNR (in dB. typically: 42)\n");
#line 555
  printf("\n\0350\022mU");
#line 556
  printf("  -s <int> <int> ......... input size (width x height) for YUV\n");
#line 557
  printf("  -sns <int> ............. spatial noise shaping (0:off, 100:max), default=50\n/\022mU");
#line 559
  printf("  -f <int> ............... filter strength (0=off..100), default=60\n\220");
#line 561
  printf("  -sharpness <int> ....... filter sharpness (0:most .. 7:least sharp), default=0\n");
#line 563
  printf("  -strong ................ use strong filter instead of simple (default)\nU");
#line 565
  printf("  -nostrong .............. use simple filter instead of strong\n");
#line 566
  printf("  -sharp_yuv ............. use sharper (and slower) RGB->YUV conversion\n");
#line 568
  printf("  -partition_limit <int> . limit quality to fit the 512k limit on\n\257\021mU");
#line 569
  printf("                           the first partition (0=no degradation ... 100=full)\n\022mU");
#line 571
  printf("  -pass <int> ............ analysis pass number (1..10)\n\220");
#line 572
  printf("  -qrange <min> <max> .... specifies the permissible quality range\n                           (default: 0 100)\n");
#line 574
  printf("  -crop <x> <y> <w> <h> .. crop picture with the given rectangle\n");
#line 575
  printf("  -resize <w> <h> ........ resize picture (*after* any cropping)\n");
#line 576
  printf("  -mt .................... use multi-threading if available\nmU");
#line 577
  printf("  -low_memory ............ reduce memory usage (slower encoding)\n,0\022mU");
#line 578
  printf("  -map <int> ............. print map of extra info\n");
#line 579
  printf("  -print_psnr ............ prints averaged PSNR distortion\n\022mU");
#line 580
  printf("  -print_ssim ............ prints averaged SSIM distortion\n\022mU");
#line 581
  printf("  -print_lsim ............ prints local-similarity distortion\n");
#line 582
  printf("  -d <file.pgm> .......... dump the compressed output (PGM file)\n");
#line 583
  printf("  -alpha_method <int> .... transparency-compression method (0..1), default=1\n");
#line 585
  printf("  -alpha_filter <string> . predictive filtering for alpha plane,\n\335/\022mU");
#line 586
  printf("                           one of: none, fast (default) or best\n\220");
#line 587
  printf("  -exact ................. preserve RGB values in transparent area, default=off\n");
#line 589
  printf("  -blend_alpha <hex> ..... blend colors against background color\n                           expressed as RGB values written in\n                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n                           green=0xe0 and blue=0xd0\n");
#line 593
  printf("  -noalpha ............... discard any transparency information\n\220");
#line 594
  printf("  -lossless .............. encode image losslessly, default=off\n\220");
#line 595
  printf("  -near_lossless <int> ... use near-lossless image preprocessing\n                           (0..100=off), default=100\n/\022mU");
#line 597
  printf("  -hint <string> ......... specify image characteristics hint,\n");
#line 598
  printf("                           one of: photo, picture or graph\n");
#line 600
  printf("\n\324/\022mU");
#line 601
  printf("  -metadata <string> ..... comma separated list of metadata to\n");
#line 602
  printf("                           ");
#line 603
  printf("copy from the input to the output if present.\n");
#line 604
  printf("                           Valid values: all, none (default), exif, icc, xmp\n\321/\022mU");
#line 607
  printf("\n");
#line 608
  printf("  -short ................. condense printed message\nmU");
#line 609
  printf("  -quiet ................. don\'t print anything\n");
#line 610
  printf("  -version ............... print version number and exit\n");
#line 612
  printf("  -noasm ................. disable all assembly optimizations\n");
#line 614
  printf("  -v ..................... verbose, e.g. print encoding/decoding times\n\022mU");
#line 616
  printf("  -progress .............. report encoding progress\n");
#line 617
  printf("\n\313/\022mU");
#line 618
  printf("Experimental Options:\n");
#line 619
  printf("  -jpeg_like ............. roughly match expected JPEG size\n");
#line 620
  printf("  -af .................... auto-adjust filter strength\n");
#line 621
  printf("  -pre <int> ............. pre-processing filter\nP0\022mU");
#line 622
  printf("\nU0\022mU");
#line 623
  __cil_tmp1 = WebPGetEnabledInputFileFormats();
#line 623
  printf("Supported input formats:\n  %s\n", __cil_tmp1);
  }
  return;
}
}
#line 629 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
static char const   * const  kErrorMessages[11]  = 
#line 629
  {      "OK",      "OUT_OF_MEMORY: Out of memory allocating objects",      "BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer\323\001 ",      "NULL_PARAMETER: NULL parameter passed to functionP", 
        "INVALID_CONFIGURATION: configuration is invalid",      "BAD_DIMENSION: Bad picture dimension. Maximum width and height allowed is 16383 pixels.\022mU",      "PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\nTo reduce the size of this partition, try using less segments with the -segments option, and eventually reduce the number of header bits using -partition_limit. More details are available in the manual (`man cwebp`)",      "PARTITION_OVERFLOW: Partition is too big to fit 16M\022mU", 
        "BAD_WRITE: Picture writer returned an I/O error",      "FILE_TOO_BIG: File would be too big to fit in 4Gj\260/\022mU",      "USER_ABORT: encoding abort requested by user"};
#line 650 "/doner/libwebp/libwebp-31bea324/examples/cwebp.c"
int main(int argc , char const   *argv[] ) 
{ 
  int return_value ;
  char const   *in_file ;
  char const   *out_file ;
  char const   *dump_file ;
  FILE *out ;
  int c ;
  int short_output ;
  int quiet ;
  int keep_alpha ;
  int blend_alpha ;
  uint32_t background_color ;
  int crop ;
  int crop_x ;
  int crop_y ;
  int crop_w ;
  int crop_h ;
  int resize_w ;
  int resize_h ;
  int lossless_preset ;
  int use_lossless_preset ;
  int show_progress ;
  int keep_metadata ;
  int metadata_written ;
  WebPPicture picture ;
  int print_distortion ;
  WebPPicture original_picture ;
  WebPConfig config ;
  WebPAuxStats stats ;
  WebPMemoryWriter memory_writer ;
  int use_memory_writer ;
  Metadata metadata ;
  Stopwatch stop_watch ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int parse_error ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  float __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  float __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int version ;
  int __cil_tmp119 ;
  int sharpyuv_version ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  WebPPreset preset ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  static struct __anonstruct_289 kTokens[5] ;
  size_t kNumTokens ;
  char const   *start ;
  char const   *end ;
  unsigned long __cil_tmp138 ;
  size_t i ;
  char const   *token ;
  char *__cil_tmp141 ;
  unsigned long __cil_tmp142 ;
  unsigned long __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  int __cil_tmp146 ;
  int __cil_tmp147 ;
  int __cil_tmp148 ;
  Metadata *tmp ;
  int __cil_tmp150 ;
  int (*tmp___0)(int percent , WebPPicture * const  picture ) ;
  double read_time ;
  double __cil_tmp153 ;
  int use_stdout ;
  int __cil_tmp155 ;
  FILE *__cil_tmp156 ;
  FILE *__cil_tmp157 ;
  FILE *tmp___1 ;
  int __cil_tmp159 ;
  WebPPicture picture_no_alpha ;
  int __cil_tmp161 ;
  int x ;
  int y ;
  uint32_t *argb_no_alpha ;
  int __cil_tmp165 ;
  int __cil_tmp166 ;
  int x___0 ;
  int y___0 ;
  uint32_t *argb_no_alpha___0 ;
  uint32_t *argb ;
  double preproc_time ;
  double __cil_tmp172 ;
  int __cil_tmp173 ;
  int __cil_tmp174 ;
  double encode_time ;
  double __cil_tmp176 ;
  int __cil_tmp177 ;
  int __cil_tmp178 ;
  int __cil_tmp179 ;
  int __cil_tmp180 ;
  int __cil_tmp181 ;
  struct __anonstruct_290 *iter ;
  struct __anonstruct_290 info[4] ;
  uint32_t unused1 ;
  uint64_t unused2 ;
  int __cil_tmp186 ;
  static char const   *distortion_names[3] ;
  float values[5] ;
  int __cil_tmp189 ;

  {
#line 651
  return_value = - 1;
#line 652
  in_file = (char const   *)((void *)0);
#line 652
  out_file = (char const   *)((void *)0);
#line 652
  dump_file = (char const   *)((void *)0);
#line 653
  out = (FILE *)((void *)0);
#line 655
  short_output = 0;
#line 656
  quiet = 0;
#line 657
  keep_alpha = 1;
#line 658
  blend_alpha = 0;
#line 659
  background_color = 16777215U;
#line 660
  crop = 0;
#line 660
  crop_x = 0;
#line 660
  crop_y = 0;
#line 660
  crop_w = 0;
#line 660
  crop_h = 0;
#line 661
  resize_w = 0;
  {
#line 661
  resize_h = 0;
#line 662
  lossless_preset = 6;
#line 663
  use_lossless_preset = - 1;
#line 664
  show_progress = 0;
#line 665
  keep_metadata = 0;
#line 666
  metadata_written = 0;
#line 668
  print_distortion = - 1;
#line 679
  MetadataInit(& metadata);
#line 680
  WebPMemoryWriterInit(& memory_writer);
#line 681
  __cil_tmp37 = WebPConfigInit(& config);
  }
  {
#line 681
  __cil_tmp36 = WebPPictureInit(& original_picture);
  }
  {
#line 681
  __cil_tmp35 = WebPPictureInit(& picture);
  }
#line 681
  if (! __cil_tmp35) {
    _L: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    {
#line 684
    fprintf(stderr, "Error! Version mismatch!\n");
    }
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;

#line 685
      return (- 1);
#line 685
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 681
  if (! __cil_tmp36) {
#line 681
    goto _L;
  } else
#line 681
  if (! __cil_tmp37) {
#line 681
    goto _L;
  }
#line 688
  if (argc == 1) {
    {
#line 689
    HelpShort();
    }
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 690
      return (0);
#line 690
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 693
  c = 1;
  {
#line 693
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 693
    if (! (c < argc)) {
#line 693
      goto while_break___1;
    }
    {
#line 694
    parse_error = 0;
#line 695
    __cil_tmp40 = strcmp(argv[c], "-help");
    }
    {
#line 695
    __cil_tmp39 = strcmp(argv[c], "-h");
    }
#line 695
    if (! __cil_tmp39) {
      _L___30: /* CIL Label */ 
      {
#line 696
      HelpShort();
      }
      {
#line 697
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 697
        return (0);
#line 697
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 695
    if (! __cil_tmp40) {
#line 695
      goto _L___30;
    } else {
      {
#line 698
      __cil_tmp42 = strcmp(argv[c], "-longhelp");
      }
      {
#line 698
      __cil_tmp41 = strcmp(argv[c], "-H");
      }
#line 698
      if (! __cil_tmp41) {
        _L___29: /* CIL Label */ 
        {
#line 699
        HelpLong();
        }
        {
#line 700
        while (1) {
          while_continue___3: /* CIL Label */ ;

#line 700
          return (0);
#line 700
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 698
      if (! __cil_tmp42) {
#line 698
        goto _L___29;
      } else {
        {
#line 701
        __cil_tmp43 = strcmp(argv[c], "-o");
        }
#line 701
        if (! __cil_tmp43) {
#line 701
          if (c + 1 < argc) {
#line 702
            c ++;
#line 702
            out_file = (char const   *)argv[c];
          } else {
#line 701
            goto _L___28;
          }
        } else {
          _L___28: /* CIL Label */ 
          {
#line 703
          __cil_tmp44 = strcmp(argv[c], "-d");
          }
#line 703
          if (! __cil_tmp44) {
#line 703
            if (c + 1 < argc) {
#line 704
              c ++;
#line 704
              dump_file = (char const   *)argv[c];
#line 705
              config.show_compressed = 1;
            } else {
#line 703
              goto _L___27;
            }
          } else {
            _L___27: /* CIL Label */ 
            {
#line 706
            __cil_tmp45 = strcmp(argv[c], "-print_psnr");
            }
#line 706
            if (! __cil_tmp45) {
#line 707
              config.show_compressed = 1;
#line 708
              print_distortion = 0;
            } else {
              {
#line 709
              __cil_tmp46 = strcmp(argv[c], "-print_ssim");
              }
#line 709
              if (! __cil_tmp46) {
#line 710
                config.show_compressed = 1;
#line 711
                print_distortion = 1;
              } else {
                {
#line 712
                __cil_tmp47 = strcmp(argv[c], "-print_lsim");
                }
#line 712
                if (! __cil_tmp47) {
#line 713
                  config.show_compressed = 1;
#line 714
                  print_distortion = 2;
                } else {
                  {
#line 715
                  __cil_tmp48 = strcmp(argv[c], "-short");
                  }
#line 715
                  if (! __cil_tmp48) {
#line 716
                    short_output ++;
                  } else {
                    {
#line 717
                    __cil_tmp49 = strcmp(argv[c], "-s");
                    }
#line 717
                    if (! __cil_tmp49) {
#line 717
                      if (c + 2 < argc) {
                        {
#line 718
                        c ++;
#line 718
                        __cil_tmp50 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 718
                        picture.width = __cil_tmp50;
#line 719
                        c ++;
#line 719
                        __cil_tmp51 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 719
                        picture.height = __cil_tmp51;
                        }
#line 720
                        if (picture.width > 16383) {
                          {
                          {
                          {
                          {
#line 722
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
                          }
                          }
                          }
#line 725
                          goto Error;
                        } else
#line 720
                        if (picture.width < 0) {
                          {
                          {
                          {
                          {
#line 722
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
                          }
                          }
                          }
#line 725
                          goto Error;
                        } else
#line 720
                        if (picture.height > 16383) {
                          {
                          {
                          {
                          {
#line 722
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
                          }
                          }
                          }
#line 725
                          goto Error;
                        } else
#line 720
                        if (picture.height < 0) {
                          {
                          {
                          {
                          {
#line 722
                          fprintf(stderr, "Specified dimension (%d x %d) is out of range.\n",
                                  picture.width, picture.height);
                          }
                          }
                          }
                          }
#line 725
                          goto Error;
                        }
                      } else {
#line 717
                        goto _L___26;
                      }
                    } else {
                      _L___26: /* CIL Label */ 
                      {
#line 727
                      __cil_tmp52 = strcmp(argv[c], "-m");
                      }
#line 727
                      if (! __cil_tmp52) {
#line 727
                        if (c + 1 < argc) {
                          {
#line 728
                          c ++;
#line 728
                          __cil_tmp53 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 728
                          config.method = __cil_tmp53;
#line 729
                          use_lossless_preset = 0;
                          }
                        } else {
#line 727
                          goto _L___25;
                        }
                      } else {
                        _L___25: /* CIL Label */ 
                        {
#line 730
                        __cil_tmp54 = strcmp(argv[c], "-q");
                        }
#line 730
                        if (! __cil_tmp54) {
#line 730
                          if (c + 1 < argc) {
                            {
#line 731
                            c ++;
#line 731
                            __cil_tmp55 = ExUtilGetFloat(argv[c], & parse_error);
#line 731
                            config.quality = __cil_tmp55;
#line 732
                            use_lossless_preset = 0;
                            }
                          } else {
#line 730
                            goto _L___24;
                          }
                        } else {
                          _L___24: /* CIL Label */ 
                          {
#line 733
                          __cil_tmp56 = strcmp(argv[c], "-z");
                          }
#line 733
                          if (! __cil_tmp56) {
#line 733
                            if (c + 1 < argc) {
                              {
#line 734
                              c ++;
#line 734
                              __cil_tmp57 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 734
                              lossless_preset = __cil_tmp57;
                              }
#line 735
                              if (use_lossless_preset != 0) {
#line 735
                                use_lossless_preset = 1;
                              }
                            } else {
#line 733
                              goto _L___23;
                            }
                          } else {
                            _L___23: /* CIL Label */ 
                            {
#line 736
                            __cil_tmp58 = strcmp(argv[c], "-alpha_q\220");
                            }
#line 736
                            if (! __cil_tmp58) {
#line 736
                              if (c + 1 < argc) {
                                {
#line 737
                                c ++;
#line 737
                                __cil_tmp59 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 737
                                config.alpha_quality = __cil_tmp59;
                                }
                              } else {
#line 736
                                goto _L___22;
                              }
                            } else {
                              _L___22: /* CIL Label */ 
                              {
#line 738
                              __cil_tmp60 = strcmp(argv[c], "-alpha_method");
                              }
#line 738
                              if (! __cil_tmp60) {
#line 738
                                if (c + 1 < argc) {
                                  {
#line 739
                                  c ++;
#line 739
                                  __cil_tmp61 = ExUtilGetInt(argv[c], 0, & parse_error);
#line 739
                                  config.alpha_compression = __cil_tmp61;
                                  }
                                } else {
#line 738
                                  goto _L___21;
                                }
                              } else {
                                _L___21: /* CIL Label */ 
                                {
#line 740
                                __cil_tmp62 = strcmp(argv[c], "-alpha_cleanup");
                                }
#line 740
                                if (! __cil_tmp62) {
#line 742
                                  config.exact = 0;
                                } else {
                                  {
#line 743
                                  __cil_tmp63 = strcmp(argv[c], "-exact");
                                  }
#line 743
                                  if (! __cil_tmp63) {
#line 744
                                    config.exact = 1;
                                  } else {
                                    {
#line 745
                                    __cil_tmp64 = strcmp(argv[c], "-blend_alpha");
                                    }
#line 745
                                    if (! __cil_tmp64) {
#line 745
                                      if (c + 1 < argc) {
                                        {
#line 746
                                        blend_alpha = 1;
#line 748
                                        c ++;
#line 748
                                        __cil_tmp65 = ExUtilGetInt(argv[c], 16, & parse_error);
#line 748
                                        background_color = (uint32_t )__cil_tmp65;
#line 749
                                        background_color &= 16777215U;
                                        }
                                      } else {
#line 745
                                        goto _L___20;
                                      }
                                    } else {
                                      _L___20: /* CIL Label */ 
                                      {
#line 750
                                      __cil_tmp66 = strcmp(argv[c], "-alpha_filter");
                                      }
#line 750
                                      if (! __cil_tmp66) {
#line 750
                                        if (c + 1 < argc) {
                                          {
#line 751
                                          c ++;
#line 752
                                          __cil_tmp67 = strcmp(argv[c], "none");
                                          }
#line 752
                                          if (! __cil_tmp67) {
#line 753
                                            config.alpha_filtering = 0;
                                          } else {
                                            {
#line 754
                                            __cil_tmp68 = strcmp(argv[c], "fast");
                                            }
#line 754
                                            if (! __cil_tmp68) {
#line 755
                                              config.alpha_filtering = 1;
                                            } else {
                                              {
#line 756
                                              __cil_tmp69 = strcmp(argv[c], "best");
                                              }
#line 756
                                              if (! __cil_tmp69) {
#line 757
                                                config.alpha_filtering = 2;
                                              } else {
                                                {
#line 759
                                                fprintf(stderr, "Error! Unrecognized alpha filter: %s\n",
                                                        argv[c]);
                                                }
#line 760
                                                goto Error;
                                              }
                                            }
                                          }
                                        } else {
#line 750
                                          goto _L___19;
                                        }
                                      } else {
                                        _L___19: /* CIL Label */ 
                                        {
#line 762
                                        __cil_tmp70 = strcmp(argv[c], "-noalpha\220");
                                        }
#line 762
                                        if (! __cil_tmp70) {
#line 763
                                          keep_alpha = 0;
                                        } else {
                                          {
#line 764
                                          __cil_tmp71 = strcmp(argv[c], "-lossless");
                                          }
#line 764
                                          if (! __cil_tmp71) {
#line 765
                                            config.lossless = 1;
                                          } else {
                                            {
#line 766
                                            __cil_tmp72 = strcmp(argv[c], "-near_lossless");
                                            }
#line 766
                                            if (! __cil_tmp72) {
#line 766
                                              if (c + 1 < argc) {
                                                {
#line 767
                                                c ++;
#line 767
                                                __cil_tmp73 = ExUtilGetInt(argv[c],
                                                                           0, & parse_error);
#line 767
                                                config.near_lossless = __cil_tmp73;
#line 768
                                                config.lossless = 1;
                                                }
                                              } else {
#line 766
                                                goto _L___18;
                                              }
                                            } else {
                                              _L___18: /* CIL Label */ 
                                              {
#line 769
                                              __cil_tmp74 = strcmp(argv[c], "-hint");
                                              }
#line 769
                                              if (! __cil_tmp74) {
#line 769
                                                if (c + 1 < argc) {
                                                  {
#line 770
                                                  c ++;
#line 771
                                                  __cil_tmp75 = strcmp(argv[c], "photo");
                                                  }
#line 771
                                                  if (! __cil_tmp75) {
#line 772
                                                    config.image_hint = (WebPImageHint )2;
                                                  } else {
                                                    {
#line 773
                                                    __cil_tmp76 = strcmp(argv[c],
                                                                         "picture");
                                                    }
#line 773
                                                    if (! __cil_tmp76) {
#line 774
                                                      config.image_hint = (WebPImageHint )1;
                                                    } else {
                                                      {
#line 775
                                                      __cil_tmp77 = strcmp(argv[c],
                                                                           "graph");
                                                      }
#line 775
                                                      if (! __cil_tmp77) {
#line 776
                                                        config.image_hint = (WebPImageHint )3;
                                                      } else {
                                                        {
#line 778
                                                        fprintf(stderr, "Error! Unrecognized image hint: %s\n",
                                                                argv[c]);
                                                        }
#line 779
                                                        goto Error;
                                                      }
                                                    }
                                                  }
                                                } else {
#line 769
                                                  goto _L___17;
                                                }
                                              } else {
                                                _L___17: /* CIL Label */ 
                                                {
#line 781
                                                __cil_tmp78 = strcmp(argv[c], "-size");
                                                }
#line 781
                                                if (! __cil_tmp78) {
#line 781
                                                  if (c + 1 < argc) {
                                                    {
#line 782
                                                    c ++;
#line 782
                                                    __cil_tmp79 = ExUtilGetInt(argv[c],
                                                                               0,
                                                                               & parse_error);
#line 782
                                                    config.target_size = __cil_tmp79;
                                                    }
                                                  } else {
#line 781
                                                    goto _L___16;
                                                  }
                                                } else {
                                                  _L___16: /* CIL Label */ 
                                                  {
#line 783
                                                  __cil_tmp80 = strcmp(argv[c], "-psnr");
                                                  }
#line 783
                                                  if (! __cil_tmp80) {
#line 783
                                                    if (c + 1 < argc) {
                                                      {
#line 784
                                                      c ++;
#line 784
                                                      __cil_tmp81 = ExUtilGetFloat(argv[c],
                                                                                   & parse_error);
#line 784
                                                      config.target_PSNR = __cil_tmp81;
                                                      }
                                                    } else {
#line 783
                                                      goto _L___15;
                                                    }
                                                  } else {
                                                    _L___15: /* CIL Label */ 
                                                    {
#line 785
                                                    __cil_tmp82 = strcmp(argv[c],
                                                                         "-sns");
                                                    }
#line 785
                                                    if (! __cil_tmp82) {
#line 785
                                                      if (c + 1 < argc) {
                                                        {
#line 786
                                                        c ++;
#line 786
                                                        __cil_tmp83 = ExUtilGetInt(argv[c],
                                                                                   0,
                                                                                   & parse_error);
#line 786
                                                        config.sns_strength = __cil_tmp83;
                                                        }
                                                      } else {
#line 785
                                                        goto _L___14;
                                                      }
                                                    } else {
                                                      _L___14: /* CIL Label */ 
                                                      {
#line 787
                                                      __cil_tmp84 = strcmp(argv[c],
                                                                           "-f");
                                                      }
#line 787
                                                      if (! __cil_tmp84) {
#line 787
                                                        if (c + 1 < argc) {
                                                          {
#line 788
                                                          c ++;
#line 788
                                                          __cil_tmp85 = ExUtilGetInt(argv[c],
                                                                                     0,
                                                                                     & parse_error);
#line 788
                                                          config.filter_strength = __cil_tmp85;
                                                          }
                                                        } else {
#line 787
                                                          goto _L___13;
                                                        }
                                                      } else {
                                                        _L___13: /* CIL Label */ 
                                                        {
#line 789
                                                        __cil_tmp86 = strcmp(argv[c],
                                                                             "-af");
                                                        }
#line 789
                                                        if (! __cil_tmp86) {
#line 790
                                                          config.autofilter = 1;
                                                        } else {
                                                          {
#line 791
                                                          __cil_tmp87 = strcmp(argv[c],
                                                                               "-jpeg_like");
                                                          }
#line 791
                                                          if (! __cil_tmp87) {
#line 792
                                                            config.emulate_jpeg_size = 1;
                                                          } else {
                                                            {
#line 793
                                                            __cil_tmp88 = strcmp(argv[c],
                                                                                 "-mt");
                                                            }
#line 793
                                                            if (! __cil_tmp88) {
#line 794
                                                              (config.thread_level) ++;
                                                            } else {
                                                              {
#line 795
                                                              __cil_tmp89 = strcmp(argv[c],
                                                                                   "-low_memory");
                                                              }
#line 795
                                                              if (! __cil_tmp89) {
#line 796
                                                                config.low_memory = 1;
                                                              } else {
                                                                {
#line 797
                                                                __cil_tmp90 = strcmp(argv[c],
                                                                                     "-strong");
                                                                }
#line 797
                                                                if (! __cil_tmp90) {
#line 798
                                                                  config.filter_type = 1;
                                                                } else {
                                                                  {
#line 799
                                                                  __cil_tmp91 = strcmp(argv[c],
                                                                                       "-nostrong");
                                                                  }
#line 799
                                                                  if (! __cil_tmp91) {
#line 800
                                                                    config.filter_type = 0;
                                                                  } else {
                                                                    {
#line 801
                                                                    __cil_tmp92 = strcmp(argv[c],
                                                                                         "-sharpness");
                                                                    }
#line 801
                                                                    if (! __cil_tmp92) {
#line 801
                                                                      if (c + 1 < argc) {
                                                                        {
#line 802
                                                                        c ++;
#line 802
                                                                        __cil_tmp93 = ExUtilGetInt(argv[c],
                                                                                                   0,
                                                                                                   & parse_error);
#line 802
                                                                        config.filter_sharpness = __cil_tmp93;
                                                                        }
                                                                      } else {
#line 801
                                                                        goto _L___12;
                                                                      }
                                                                    } else {
                                                                      _L___12: /* CIL Label */ 
                                                                      {
#line 803
                                                                      __cil_tmp94 = strcmp(argv[c],
                                                                                           "-sharp_yuv");
                                                                      }
#line 803
                                                                      if (! __cil_tmp94) {
#line 804
                                                                        config.use_sharp_yuv = 1;
                                                                      } else {
                                                                        {
#line 805
                                                                        __cil_tmp95 = strcmp(argv[c],
                                                                                             "-pass");
                                                                        }
#line 805
                                                                        if (! __cil_tmp95) {
#line 805
                                                                          if (c + 1 < argc) {
                                                                            {
#line 806
                                                                            c ++;
#line 806
                                                                            __cil_tmp96 = ExUtilGetInt(argv[c],
                                                                                                       0,
                                                                                                       & parse_error);
#line 806
                                                                            config.pass = __cil_tmp96;
                                                                            }
                                                                          } else {
#line 805
                                                                            goto _L___11;
                                                                          }
                                                                        } else {
                                                                          _L___11: /* CIL Label */ 
                                                                          {
#line 807
                                                                          __cil_tmp97 = strcmp(argv[c],
                                                                                               "-qrange");
                                                                          }
#line 807
                                                                          if (! __cil_tmp97) {
#line 807
                                                                            if (c + 2 < argc) {
                                                                              {
#line 808
                                                                              c ++;
#line 808
                                                                              __cil_tmp98 = ExUtilGetInt(argv[c],
                                                                                                         0,
                                                                                                         & parse_error);
#line 808
                                                                              config.qmin = __cil_tmp98;
#line 809
                                                                              c ++;
#line 809
                                                                              __cil_tmp99 = ExUtilGetInt(argv[c],
                                                                                                         0,
                                                                                                         & parse_error);
#line 809
                                                                              config.qmax = __cil_tmp99;
                                                                              }
#line 810
                                                                              if (config.qmin < 0) {
#line 810
                                                                                config.qmin = 0;
                                                                              }
#line 811
                                                                              if (config.qmax > 100) {
#line 811
                                                                                config.qmax = 100;
                                                                              }
                                                                            } else {
#line 807
                                                                              goto _L___10;
                                                                            }
                                                                          } else {
                                                                            _L___10: /* CIL Label */ 
                                                                            {
#line 812
                                                                            __cil_tmp100 = strcmp(argv[c],
                                                                                                  "-pre");
                                                                            }
#line 812
                                                                            if (! __cil_tmp100) {
#line 812
                                                                              if (c + 1 < argc) {
                                                                                {
#line 813
                                                                                c ++;
#line 813
                                                                                __cil_tmp101 = ExUtilGetInt(argv[c],
                                                                                                            0,
                                                                                                            & parse_error);
#line 813
                                                                                config.preprocessing = __cil_tmp101;
                                                                                }
                                                                              } else {
#line 812
                                                                                goto _L___9;
                                                                              }
                                                                            } else {
                                                                              _L___9: /* CIL Label */ 
                                                                              {
#line 814
                                                                              __cil_tmp102 = strcmp(argv[c],
                                                                                                    "-segments");
                                                                              }
#line 814
                                                                              if (! __cil_tmp102) {
#line 814
                                                                                if (c + 1 < argc) {
                                                                                  {
#line 815
                                                                                  c ++;
#line 815
                                                                                  __cil_tmp103 = ExUtilGetInt(argv[c],
                                                                                                              0,
                                                                                                              & parse_error);
#line 815
                                                                                  config.segments = __cil_tmp103;
                                                                                  }
                                                                                } else {
#line 814
                                                                                  goto _L___8;
                                                                                }
                                                                              } else {
                                                                                _L___8: /* CIL Label */ 
                                                                                {
#line 816
                                                                                __cil_tmp104 = strcmp(argv[c],
                                                                                                      "-partition_limit\220");
                                                                                }
#line 816
                                                                                if (! __cil_tmp104) {
#line 816
                                                                                  if (c + 1 < argc) {
                                                                                    {
#line 817
                                                                                    c ++;
#line 817
                                                                                    __cil_tmp105 = ExUtilGetInt(argv[c],
                                                                                                                0,
                                                                                                                & parse_error);
#line 817
                                                                                    config.partition_limit = __cil_tmp105;
                                                                                    }
                                                                                  } else {
#line 816
                                                                                    goto _L___7;
                                                                                  }
                                                                                } else {
                                                                                  _L___7: /* CIL Label */ 
                                                                                  {
#line 818
                                                                                  __cil_tmp106 = strcmp(argv[c],
                                                                                                        "-map");
                                                                                  }
#line 818
                                                                                  if (! __cil_tmp106) {
#line 818
                                                                                    if (c + 1 < argc) {
                                                                                      {
#line 819
                                                                                      c ++;
#line 819
                                                                                      __cil_tmp107 = ExUtilGetInt(argv[c],
                                                                                                                  0,
                                                                                                                  & parse_error);
#line 819
                                                                                      picture.extra_info_type = __cil_tmp107;
                                                                                      }
                                                                                    } else {
#line 818
                                                                                      goto _L___6;
                                                                                    }
                                                                                  } else {
                                                                                    _L___6: /* CIL Label */ 
                                                                                    {
#line 820
                                                                                    __cil_tmp108 = strcmp(argv[c],
                                                                                                          "-crop");
                                                                                    }
#line 820
                                                                                    if (! __cil_tmp108) {
#line 820
                                                                                      if (c + 4 < argc) {
                                                                                        {
#line 821
                                                                                        crop = 1;
#line 822
                                                                                        c ++;
#line 822
                                                                                        __cil_tmp109 = ExUtilGetInt(argv[c],
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 822
                                                                                        crop_x = __cil_tmp109;
#line 823
                                                                                        c ++;
#line 823
                                                                                        __cil_tmp110 = ExUtilGetInt(argv[c],
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 823
                                                                                        crop_y = __cil_tmp110;
#line 824
                                                                                        c ++;
#line 824
                                                                                        __cil_tmp111 = ExUtilGetInt(argv[c],
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 824
                                                                                        crop_w = __cil_tmp111;
#line 825
                                                                                        c ++;
#line 825
                                                                                        __cil_tmp112 = ExUtilGetInt(argv[c],
                                                                                                                    0,
                                                                                                                    & parse_error);
#line 825
                                                                                        crop_h = __cil_tmp112;
                                                                                        }
                                                                                      } else {
#line 820
                                                                                        goto _L___5;
                                                                                      }
                                                                                    } else {
                                                                                      _L___5: /* CIL Label */ 
                                                                                      {
#line 826
                                                                                      __cil_tmp113 = strcmp(argv[c],
                                                                                                            "-resize");
                                                                                      }
#line 826
                                                                                      if (! __cil_tmp113) {
#line 826
                                                                                        if (c + 2 < argc) {
                                                                                          {
#line 827
                                                                                          c ++;
#line 827
                                                                                          __cil_tmp114 = ExUtilGetInt(argv[c],
                                                                                                                      0,
                                                                                                                      & parse_error);
#line 827
                                                                                          resize_w = __cil_tmp114;
#line 828
                                                                                          c ++;
#line 828
                                                                                          __cil_tmp115 = ExUtilGetInt(argv[c],
                                                                                                                      0,
                                                                                                                      & parse_error);
#line 828
                                                                                          resize_h = __cil_tmp115;
                                                                                          }
                                                                                        } else {
#line 826
                                                                                          goto _L___4;
                                                                                        }
                                                                                      } else {
                                                                                        _L___4: /* CIL Label */ 
                                                                                        {
#line 830
                                                                                        __cil_tmp116 = strcmp(argv[c],
                                                                                                              "-noasm");
                                                                                        }
#line 830
                                                                                        if (! __cil_tmp116) {
#line 831
                                                                                          VP8GetCPUInfo = (void *)0;
                                                                                        } else {
                                                                                          {
#line 833
                                                                                          __cil_tmp117 = strcmp(argv[c],
                                                                                                                "-version\220");
                                                                                          }
#line 833
                                                                                          if (! __cil_tmp117) {
                                                                                            {
#line 834
                                                                                            __cil_tmp119 = WebPGetEncoderVersion();
#line 834
                                                                                            version = __cil_tmp119;
#line 835
                                                                                            __cil_tmp121 = SharpYuvGetVersion();
#line 835
                                                                                            sharpyuv_version = __cil_tmp121;
#line 836
                                                                                            printf("%d.%d.%d\n",
                                                                                                   (version >> 16) & 255,
                                                                                                   (version >> 8) & 255,
                                                                                                   version & 255);
#line 838
                                                                                            printf("libsharpyuv: %d.%d.%d\n",
                                                                                                   (sharpyuv_version >> 24) & 255,
                                                                                                   (sharpyuv_version >> 16) & 65535,
                                                                                                   sharpyuv_version & 255);
                                                                                            }
                                                                                            {
#line 841
                                                                                            while (1) {
                                                                                              while_continue___4: /* CIL Label */ ;

#line 841
                                                                                              return (0);
#line 841
                                                                                              goto while_break___4;
                                                                                            }
                                                                                            while_break___4: /* CIL Label */ ;
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 842
                                                                                            __cil_tmp122 = strcmp(argv[c],
                                                                                                                  "-progress");
                                                                                            }
#line 842
                                                                                            if (! __cil_tmp122) {
#line 843
                                                                                              show_progress = 1;
                                                                                            } else {
                                                                                              {
#line 844
                                                                                              __cil_tmp123 = strcmp(argv[c],
                                                                                                                    "-quiet");
                                                                                              }
#line 844
                                                                                              if (! __cil_tmp123) {
#line 845
                                                                                                quiet = 1;
                                                                                              } else {
                                                                                                {
#line 846
                                                                                                __cil_tmp124 = strcmp(argv[c],
                                                                                                                      "-preset");
                                                                                                }
#line 846
                                                                                                if (! __cil_tmp124) {
#line 846
                                                                                                  if (c + 1 < argc) {
                                                                                                    {
#line 848
                                                                                                    c ++;
#line 849
                                                                                                    __cil_tmp126 = strcmp(argv[c],
                                                                                                                          "default");
                                                                                                    }
#line 849
                                                                                                    if (! __cil_tmp126) {
#line 850
                                                                                                      preset = (WebPPreset )0;
                                                                                                    } else {
                                                                                                      {
#line 851
                                                                                                      __cil_tmp127 = strcmp(argv[c],
                                                                                                                            "photo");
                                                                                                      }
#line 851
                                                                                                      if (! __cil_tmp127) {
#line 852
                                                                                                        preset = (WebPPreset )2;
                                                                                                      } else {
                                                                                                        {
#line 853
                                                                                                        __cil_tmp128 = strcmp(argv[c],
                                                                                                                              "picture");
                                                                                                        }
#line 853
                                                                                                        if (! __cil_tmp128) {
#line 854
                                                                                                          preset = (WebPPreset )1;
                                                                                                        } else {
                                                                                                          {
#line 855
                                                                                                          __cil_tmp129 = strcmp(argv[c],
                                                                                                                                "drawing");
                                                                                                          }
#line 855
                                                                                                          if (! __cil_tmp129) {
#line 856
                                                                                                            preset = (WebPPreset )3;
                                                                                                          } else {
                                                                                                            {
#line 857
                                                                                                            __cil_tmp130 = strcmp(argv[c],
                                                                                                                                  "icon");
                                                                                                            }
#line 857
                                                                                                            if (! __cil_tmp130) {
#line 858
                                                                                                              preset = (WebPPreset )4;
                                                                                                            } else {
                                                                                                              {
#line 859
                                                                                                              __cil_tmp131 = strcmp(argv[c],
                                                                                                                                    "text");
                                                                                                              }
#line 859
                                                                                                              if (! __cil_tmp131) {
#line 860
                                                                                                                preset = (WebPPreset )5;
                                                                                                              } else {
                                                                                                                {
#line 862
                                                                                                                fprintf(stderr,
                                                                                                                        "Error! Unrecognized preset: %s\n",
                                                                                                                        argv[c]);
                                                                                                                }
#line 863
                                                                                                                goto Error;
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 865
                                                                                                    __cil_tmp132 = WebPConfigPreset(& config,
                                                                                                                                    preset,
                                                                                                                                    config.quality);
                                                                                                    }
#line 865
                                                                                                    if (! __cil_tmp132) {
                                                                                                      {
#line 866
                                                                                                      fprintf(stderr,
                                                                                                              "Error! Could initialize configuration with preset.\n");
                                                                                                      }
#line 867
                                                                                                      goto Error;
                                                                                                    }
                                                                                                  } else {
#line 846
                                                                                                    goto _L___3;
                                                                                                  }
                                                                                                } else {
                                                                                                  _L___3: /* CIL Label */ 
                                                                                                  {
#line 869
                                                                                                  __cil_tmp133 = strcmp(argv[c],
                                                                                                                        "-metadata");
                                                                                                  }
#line 869
                                                                                                  if (! __cil_tmp133) {
#line 869
                                                                                                    if (c + 1 < argc) {
#line 870
                                                                                                      kTokens[0].option = "all";
#line 870
                                                                                                      kTokens[0].flag = 7;
#line 870
                                                                                                      kTokens[1].option = "none";
#line 870
                                                                                                      kTokens[1].flag = 0;
#line 870
                                                                                                      kTokens[2].option = "exif";
#line 870
                                                                                                      kTokens[2].flag = 1;
#line 870
                                                                                                      kTokens[3].option = "icc";
#line 870
                                                                                                      kTokens[3].flag = 2;
#line 870
                                                                                                      kTokens[4].option = "xmp";
                                                                                                      {
#line 870
                                                                                                      kTokens[4].flag = 4;
#line 880
                                                                                                      kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
#line 881
                                                                                                      c ++;
#line 881
                                                                                                      start = argv[c];
#line 882
                                                                                                      __cil_tmp138 = strlen(start);
#line 882
                                                                                                      end = start + __cil_tmp138;
                                                                                                      }
                                                                                                      {
#line 884
                                                                                                      while (1) {
                                                                                                        while_continue___5: /* CIL Label */ ;
#line 884
                                                                                                        if (! (start < end)) {
#line 884
                                                                                                          goto while_break___5;
                                                                                                        }
                                                                                                        {
#line 886
                                                                                                        __cil_tmp141 = strchr(start,
                                                                                                                              ',');
#line 886
                                                                                                        token = (char const   *)__cil_tmp141;
                                                                                                        }
#line 887
                                                                                                        if (token == (void *)0) {
#line 887
                                                                                                          token = end;
                                                                                                        }
#line 889
                                                                                                        i = (size_t )0;
                                                                                                        {
#line 889
                                                                                                        while (1) {
                                                                                                          while_continue___6: /* CIL Label */ ;
#line 889
                                                                                                          if (! (i < kNumTokens)) {
#line 889
                                                                                                            goto while_break___6;
                                                                                                          }
                                                                                                          {
#line 890
                                                                                                          __cil_tmp143 = strlen(kTokens[i].option);
#line 890
                                                                                                          __cil_tmp144 = strncmp(start,
                                                                                                                                 kTokens[i].option,
                                                                                                                                 __cil_tmp143);
                                                                                                          }
                                                                                                          {
#line 890
                                                                                                          __cil_tmp142 = strlen(kTokens[i].option);
                                                                                                          }
#line 890
                                                                                                          if ((size_t )(token - start) == __cil_tmp142) {
#line 890
                                                                                                            if (! __cil_tmp144) {
#line 892
                                                                                                              if (kTokens[i].flag != 0) {
#line 893
                                                                                                                keep_metadata |= kTokens[i].flag;
                                                                                                              } else {
#line 895
                                                                                                                keep_metadata = 0;
                                                                                                              }
#line 897
                                                                                                              goto while_break___6;
                                                                                                            }
                                                                                                          }
#line 889
                                                                                                          i ++;
                                                                                                        }
                                                                                                        while_break___6: /* CIL Label */ ;
                                                                                                        }
#line 900
                                                                                                        if (i == kNumTokens) {
                                                                                                          {
#line 901
                                                                                                          fprintf(stderr,
                                                                                                                  "Error! Unknown metadata type \'%.*s\'\n",
                                                                                                                  (int )(token - start),
                                                                                                                  start);
                                                                                                          }
                                                                                                          {
#line 903
                                                                                                          while (1) {
                                                                                                            while_continue___7: /* CIL Label */ ;

#line 903
                                                                                                            return (- 1);
#line 903
                                                                                                            goto while_break___7;
                                                                                                          }
                                                                                                          while_break___7: /* CIL Label */ ;
                                                                                                          }
                                                                                                        }
#line 905
                                                                                                        start = token + 1;
                                                                                                      }
                                                                                                      while_break___5: /* CIL Label */ ;
                                                                                                      }
                                                                                                    } else {
#line 869
                                                                                                      goto _L___2;
                                                                                                    }
                                                                                                  } else {
                                                                                                    _L___2: /* CIL Label */ 
                                                                                                    {
#line 914
                                                                                                    __cil_tmp145 = strcmp(argv[c],
                                                                                                                          "-v");
                                                                                                    }
#line 914
                                                                                                    if (! __cil_tmp145) {
#line 915
                                                                                                      verbose = 1;
                                                                                                    } else {
                                                                                                      {
#line 916
                                                                                                      __cil_tmp146 = strcmp(argv[c],
                                                                                                                            "--");
                                                                                                      }
#line 916
                                                                                                      if (! __cil_tmp146) {
#line 917
                                                                                                        if (c + 1 < argc) {
#line 917
                                                                                                          c ++;
#line 917
                                                                                                          in_file = (char const   *)argv[c];
                                                                                                        }
#line 918
                                                                                                        goto while_break___1;
                                                                                                      } else
#line 919
                                                                                                      if ((int )*(argv[c] + 0) == 45) {
                                                                                                        {
#line 920
                                                                                                        fprintf(stderr,
                                                                                                                "Error! Unknown option \'%s\'\n",
                                                                                                                argv[c]);
#line 921
                                                                                                        HelpLong();
                                                                                                        }
                                                                                                        {
#line 922
                                                                                                        while (1) {
                                                                                                          while_continue___8: /* CIL Label */ ;

#line 922
                                                                                                          return (- 1);
#line 922
                                                                                                          goto while_break___8;
                                                                                                        }
                                                                                                        while_break___8: /* CIL Label */ ;
                                                                                                        }
                                                                                                      } else {
#line 924
                                                                                                        in_file = (char const   *)argv[c];
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 927
    if (parse_error) {
      {
#line 928
      HelpLong();
      }
      {
#line 929
      while (1) {
        while_continue___9: /* CIL Label */ ;

#line 929
        return (- 1);
#line 929
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 693
    c ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 932
  if (in_file == (void *)0) {
    {
#line 933
    fprintf(stderr, "No input file specified!\n");
#line 934
    HelpShort();
    }
#line 935
    goto Error;
  }
#line 938
  if (use_lossless_preset == 1) {
    {
#line 939
    __cil_tmp147 = WebPConfigLosslessPreset(& config, lossless_preset);
    }
#line 939
    if (! __cil_tmp147) {
      {
#line 940
      fprintf(stderr, "Invalid lossless preset (-z %d)\n\230\001", lossless_preset);
      }
#line 941
      goto Error;
    }
  }
#line 947
  if (! quiet) {
#line 947
    if (config.lossless == 1) {
#line 948
      if (config.target_size > 0) {
        {
        {
#line 949
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
        }
      } else
#line 948
      if (config.target_PSNR > (float )0) {
        {
        {
#line 949
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
        }
      }
#line 952
      if (config.partition_limit > 0) {
        {
#line 953
        fprintf(stderr, "Partition limit option is not required for lossless encoding. Ignoring this option!\n\220");
        }
      }
    }
  }
#line 959
  if (config.target_size > 0) {
    _L___31: /* CIL Label */ 
#line 960
    if (config.pass == 1) {
#line 960
      config.pass = 6;
    }
  } else
#line 959
  if (config.target_PSNR > (float )0) {
#line 959
    goto _L___31;
  }
  {
#line 963
  __cil_tmp148 = WebPValidateConfig(& config);
  }
#line 963
  if (! __cil_tmp148) {
    {
#line 964
    fprintf(stderr, "Error! Invalid configuration.\n");
    }
#line 965
    goto Error;
  }
#line 971
  picture.use_argb = (((config.lossless || config.use_sharp_yuv) || config.preprocessing > 0) || crop) || (resize_w | resize_h) > 0;
#line 974
  if (verbose) {
    {
#line 975
    StopwatchReset(& stop_watch);
    }
  }
#line 977
  if (keep_metadata == 0) {
#line 977
    tmp = (Metadata *)((void *)0);
  } else {
#line 977
    tmp = & metadata;
  }
  {
#line 977
  __cil_tmp150 = ReadPicture(in_file, & picture, keep_alpha, tmp);
  }
#line 977
  if (! __cil_tmp150) {
    {
#line 979
    fprintf(stderr, "Error! Cannot read input picture file \'%s\'\n\022mU", (char const   *)in_file);
    }
#line 981
    goto Error;
  }
#line 983
  if (show_progress && ! quiet) {
#line 983
    tmp___0 = & ProgressReport;
  } else {
#line 983
    tmp___0 = (int (*)(int  , WebPPicture * const   ))((void *)0);
  }
#line 983
  picture.progress_hook = tmp___0;
#line 985
  if (blend_alpha) {
    {
#line 986
    WebPBlendAlpha(& picture, background_color);
    }
  }
#line 989
  if (verbose) {
    {
#line 990
    __cil_tmp153 = StopwatchReadAndReset(& stop_watch);
#line 990
    read_time = __cil_tmp153;
#line 991
    fprintf(stderr, "Time to read input: %.3fs\n", read_time);
    }
  }
#line 998
  use_memory_writer = (out_file != (void *)0 && keep_metadata) || (((! quiet && print_distortion >= 0) && config.lossless) && config.near_lossless < 100);
#line 1003
  if (out_file != (void *)0) {
    {
#line 1004
    __cil_tmp155 = strcmp(out_file, "-");
#line 1004
    use_stdout = ! __cil_tmp155;
    }
#line 1005
    if (use_stdout) {
      {
#line 1005
      __cil_tmp156 = ImgIoUtilSetBinaryMode(stdout);
#line 1005
      tmp___1 = __cil_tmp156;
      }
    } else {
      {
#line 1005
      __cil_tmp157 = fopen(out_file, "wb");
#line 1005
      tmp___1 = __cil_tmp157;
      }
    }
#line 1005
    out = tmp___1;
#line 1006
    if (out == (void *)0) {
      {
#line 1007
      fprintf(stderr, "Error! Cannot open output file \'%s\'\n", (char const   *)out_file);
      }
#line 1009
      goto Error;
    } else
#line 1011
    if (! short_output) {
#line 1011
      if (! quiet) {
        {
#line 1012
        fprintf(stderr, "Saving file \'%s\'\n", (char const   *)out_file);
        }
      }
    }
#line 1015
    if (use_memory_writer) {
#line 1016
      picture.writer = & WebPMemoryWrite;
#line 1017
      picture.custom_ptr = (void *)(& memory_writer);
    } else {
#line 1019
      picture.writer = & MyWriter;
#line 1020
      picture.custom_ptr = (void *)out;
    }
  } else {
#line 1023
    out = (FILE *)((void *)0);
#line 1024
    if (use_memory_writer) {
#line 1025
      picture.writer = & WebPMemoryWrite;
#line 1026
      picture.custom_ptr = (void *)(& memory_writer);
    }
#line 1028
    if (! quiet) {
#line 1028
      if (! short_output) {
        {
#line 1029
        fprintf(stderr, "No output file specified (no -o flag). Encoding will\n");
#line 1030
        fprintf(stderr, "be performed, but its results discarded.\n\n");
        }
      }
    }
  }
#line 1033
  if (! quiet) {
#line 1034
    picture.stats = & stats;
#line 1035
    picture.user_data = (void *)in_file;
  }
#line 1039
  if (verbose) {
    {
#line 1040
    StopwatchReset(& stop_watch);
    }
  }
#line 1042
  if (crop != 0) {
    {
#line 1044
    __cil_tmp159 = WebPPictureView(& picture, crop_x, crop_y, crop_w, crop_h, & picture);
    }
#line 1044
    if (! __cil_tmp159) {
      {
#line 1045
      fprintf(stderr, "Error! Cannot crop picture\n");
      }
#line 1046
      goto Error;
    }
  }
#line 1049
  if ((resize_w | resize_h) > 0) {
#line 1051
    if (config.exact) {
      {
#line 1056
      __cil_tmp161 = WebPPictureCopy(& picture, & picture_no_alpha);
      }
#line 1056
      if (! __cil_tmp161) {
        {
#line 1057
        fprintf(stderr, "Error! Cannot copy temporary picture\n");
        }
#line 1058
        goto Error;
      }
#line 1064
      argb_no_alpha = picture_no_alpha.argb;
#line 1065
      y = 0;
      {
#line 1065
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1065
        if (! (y < picture_no_alpha.height)) {
#line 1065
          goto while_break___10;
        }
#line 1066
        x = 0;
        {
#line 1066
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1066
          if (! (x < picture_no_alpha.width)) {
#line 1066
            goto while_break___11;
          }
#line 1067
          *(argb_no_alpha + x) |= 4278190080U;
#line 1066
          x ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1069
        argb_no_alpha += picture_no_alpha.argb_stride;
#line 1065
        y ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1073
      __cil_tmp165 = WebPPictureRescale(& picture_no_alpha, resize_w, resize_h);
      }
#line 1073
      if (! __cil_tmp165) {
        {
#line 1074
        fprintf(stderr, "Error! Cannot resize temporary picture\n");
        }
#line 1075
        goto Error;
      }
    }
    {
#line 1079
    __cil_tmp166 = WebPPictureRescale(& picture, resize_w, resize_h);
    }
#line 1079
    if (! __cil_tmp166) {
      {
#line 1080
      fprintf(stderr, "Error! Cannot resize picture\n");
      }
#line 1081
      goto Error;
    }
#line 1084
    if (config.exact) {
#line 1086
      argb_no_alpha___0 = picture_no_alpha.argb;
#line 1087
      argb = picture.argb;
#line 1088
      y___0 = 0;
      {
#line 1088
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1088
        if (! (y___0 < picture_no_alpha.height)) {
#line 1088
          goto while_break___12;
        }
#line 1089
        x___0 = 0;
        {
#line 1089
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1089
          if (! (x___0 < picture_no_alpha.width)) {
#line 1089
            goto while_break___13;
          }
#line 1090
          *(argb + x___0) = (*(argb + x___0) & 4278190080U) | (*(argb_no_alpha___0 + x___0) & 16777215U);
#line 1089
          x___0 ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 1092
        argb_no_alpha___0 += picture_no_alpha.argb_stride;
#line 1093
        argb += picture.argb_stride;
#line 1088
        y___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1095
      WebPPictureFree(& picture_no_alpha);
      }
    }
  }
#line 1098
  if (verbose) {
#line 1098
    if (crop != 0) {
      {
      {
#line 1099
      __cil_tmp172 = StopwatchReadAndReset(& stop_watch);
      }
#line 1099
      preproc_time = __cil_tmp172;
      {
#line 1100
      fprintf(stderr, "Time to crop/resize picture: %.3fs\n", preproc_time);
      }
      }
    } else
#line 1098
    if ((resize_w | resize_h) > 0) {
      {
      {
#line 1099
      __cil_tmp172 = StopwatchReadAndReset(& stop_watch);
      }
#line 1099
      preproc_time = __cil_tmp172;
      {
#line 1100
      fprintf(stderr, "Time to crop/resize picture: %.3fs\n", preproc_time);
      }
      }
    }
  }
#line 1103
  if (picture.extra_info_type > 0) {
    {
#line 1104
    AllocExtraInfo(& picture);
    }
  }
  {
#line 1108
  __cil_tmp173 = WebPPictureCopy(& picture, & original_picture);
  }
#line 1108
  if (print_distortion >= 0) {
#line 1108
    if (! config.lossless) {
#line 1108
      if (! __cil_tmp173) {
        {
#line 1110
        fprintf(stderr, "Error! Cannot copy temporary picture\n");
        }
#line 1111
        goto Error;
      }
    }
  }
#line 1115
  if (verbose) {
    {
#line 1116
    StopwatchReset(& stop_watch);
    }
  }
  {
#line 1118
  __cil_tmp174 = WebPEncode(& config, & picture);
  }
#line 1118
  if (! __cil_tmp174) {
    {
#line 1119
    fprintf(stderr, "Error! Cannot encode picture as WebP\n");
#line 1120
    fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code, kErrorMessages[picture.error_code]);
    }
#line 1122
    goto Error;
  }
#line 1124
  if (verbose) {
    {
#line 1125
    __cil_tmp176 = StopwatchReadAndReset(& stop_watch);
#line 1125
    encode_time = __cil_tmp176;
#line 1126
    fprintf(stderr, "Time to encode picture: %.3fs\n", encode_time);
    }
  }
#line 1130
  if (! quiet) {
#line 1130
    if (print_distortion >= 0) {
#line 1130
      if (config.lossless) {
#line 1131
        if (config.near_lossless == 100) {
#line 1134
          original_picture = picture;
#line 1135
          original_picture.memory_argb_ = (void *)0;
#line 1135
          original_picture.memory_ = original_picture.memory_argb_;
        } else {
          {
#line 1140
          original_picture = picture;
#line 1141
          __cil_tmp177 = WebPPictureInit(& picture);
          }
#line 1141
          if (! __cil_tmp177) {
            {
#line 1142
            fprintf(stderr, "Error! Version mismatch!\n");
            }
#line 1143
            goto Error;
          }
          {
#line 1146
          picture.use_argb = 1;
#line 1147
          __cil_tmp178 = WebPPictureHasTransparency(& original_picture);
#line 1147
          __cil_tmp179 = ReadWebP(memory_writer.mem, memory_writer.size, & picture,
                                  __cil_tmp178, (struct Metadata *)((void *)0));
          }
#line 1147
          if (! __cil_tmp179) {
            {
#line 1151
            fprintf(stderr, "Error! Cannot decode encoded WebP bitstream\n");
#line 1152
            fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code,
                    kErrorMessages[picture.error_code]);
            }
#line 1154
            goto Error;
          }
#line 1156
          picture.stats = original_picture.stats;
        }
#line 1158
        original_picture.stats = (WebPAuxStats *)((void *)0);
      }
    }
  }
#line 1162
  if (dump_file) {
#line 1163
    if (picture.use_argb) {
      {
#line 1164
      fprintf(stderr, "Warning: can\'t dump file (-d option) in lossless mode.\n");
      }
    } else {
      {
#line 1166
      __cil_tmp180 = DumpPicture(& picture, dump_file);
      }
#line 1166
      if (! __cil_tmp180) {
        {
#line 1167
        fprintf(stderr, "Warning, couldn\'t dump picture %s\n", (char const   *)dump_file);
        }
      }
    }
  }
  {
#line 1172
  __cil_tmp181 = WriteWebPWithMetadata(out, & picture, & memory_writer, & metadata,
                                       keep_metadata, & metadata_written);
  }
#line 1172
  if (out != (void *)0) {
#line 1172
    if (use_memory_writer) {
#line 1172
      if (! __cil_tmp181) {
        {
#line 1175
        fprintf(stderr, "Error writing WebP file!\n");
        }
#line 1176
        goto Error;
      }
    }
  }
#line 1179
  if (out == (void *)0) {
#line 1179
    if (keep_metadata) {
#line 1181
      info[0].payload = & metadata.exif;
#line 1181
      info[0].flag = 1;
#line 1181
      info[1].payload = & metadata.iccp;
#line 1181
      info[1].flag = 2;
#line 1181
      info[2].payload = & metadata.xmp;
#line 1181
      info[2].flag = 4;
#line 1181
      info[3].payload = (MetadataPayload */* const  */)((void *)0);
#line 1181
      info[3].flag = 0;
#line 1188
      unused1 = (uint32_t )0;
#line 1189
      unused2 = (uint64_t )0;
#line 1191
      iter = (struct __anonstruct_290 *)info;
      {
#line 1191
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1191
        if (! (iter->payload != (void *)0)) {
#line 1191
          goto while_break___14;
        }
        {
#line 1192
        __cil_tmp186 = UpdateFlagsAndSize(iter->payload, ! (! (keep_metadata & iter->flag)),
                                          0, & unused1, & unused2);
        }
#line 1192
        if (__cil_tmp186) {
#line 1194
          metadata_written |= iter->flag;
        }
#line 1191
        iter ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
#line 1199
  if (! quiet) {
#line 1200
    if (! short_output) {
      _L___32: /* CIL Label */ 
#line 1201
      if (config.lossless) {
        {
#line 1202
        PrintExtraInfoLossless(& picture, short_output, in_file);
        }
      } else {
        {
#line 1204
        PrintExtraInfoLossy(& picture, short_output, config.low_memory, in_file);
        }
      }
    } else
#line 1200
    if (print_distortion < 0) {
#line 1200
      goto _L___32;
    }
#line 1207
    if (! short_output) {
#line 1207
      if (picture.extra_info_type > 0) {
        {
#line 1208
        PrintMapInfo(& picture);
        }
      }
    }
#line 1210
    if (print_distortion >= 0) {
      {
#line 1211
      distortion_names[0] = "PSNR";
#line 1211
      distortion_names[1] = "SSIM";
#line 1211
      distortion_names[2] = "LSIM";
#line 1213
      __cil_tmp189 = WebPPictureDistortion(& picture, & original_picture, print_distortion,
                                           (float *)values);
      }
#line 1213
      if (! __cil_tmp189) {
        {
#line 1215
        fprintf(stderr, "Error while computing the distortion.\n");
        }
#line 1216
        goto Error;
      }
#line 1218
      if (! short_output) {
        {
#line 1219
        fprintf(stderr, "%s: ", distortion_names[print_distortion]);
#line 1220
        fprintf(stderr, "B:%.2f G:%.2f R:%.2f A:%.2f  Total:%.2f\n\230\001", (double )values[0],
                (double )values[1], (double )values[2], (double )values[3], (double )values[4]);
        }
      } else {
        {
#line 1223
        fprintf(stderr, "%7d %.4f\n", (picture.stats)->coded_size, (double )values[4]);
        }
      }
    }
#line 1226
    if (! short_output) {
      {
#line 1227
      PrintMetadataInfo(& metadata, metadata_written);
      }
    }
  }
#line 1230
  return_value = 0;
  Error: 
  {
#line 1233
  WebPMemoryWriterClear(& memory_writer);
  }
  {
#line 1234
  WebPFree(picture.extra_info);
#line 1235
  MetadataFree(& metadata);
#line 1236
  WebPPictureFree(& picture);
#line 1237
  WebPPictureFree(& original_picture);
  }
#line 1238
  if (out != (void *)0) {
#line 1238
    if (out != stdout) {
      {
#line 1239
      fclose(out);
      }
    }
  }
  {
#line 1242
  while (1) {
    while_continue___15: /* CIL Label */ ;

#line 1242
    return (return_value);
#line 1242
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  return (0);
}
}
