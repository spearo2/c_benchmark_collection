/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 46 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef unsigned long size_t;
#line 74 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef int wchar_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef float _Float32;
#line 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef double _Float64;
#line 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef double _Float32x;
#line 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h"
typedef long double _Float64x;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_0 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_0 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_1 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_1 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_2 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_2 lldiv_t;
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_3 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_3 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__4 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 54 "/usr/include/time.h"
typedef __pid_t pid_t;
#line 14 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h"
typedef __builtin_va_list va_list;
#line 32 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_6 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_5 {
   int __count ;
   union __anonunion_6 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_5 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int OPJ_BOOL;
#line 120 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef char OPJ_CHAR;
#line 121 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef float OPJ_FLOAT32;
#line 122 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef double OPJ_FLOAT64;
#line 123 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef unsigned char OPJ_BYTE;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int8_t OPJ_INT8;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint8_t OPJ_UINT8;
#line 129 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int16_t OPJ_INT16;
#line 130 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint16_t OPJ_UINT16;
#line 131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int32_t OPJ_INT32;
#line 132 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint32_t OPJ_UINT32;
#line 133 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_INT64;
#line 134 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef uint64_t OPJ_UINT64;
#line 136 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef int64_t OPJ_OFF_T;
#line 139 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef size_t OPJ_SIZE_T;
#line 282
enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    OPJ_CINEMA2K = 3,
    OPJ_CINEMA4K = 4,
    OPJ_MCT = 33024
} ;
#line 287 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 293
enum CINEMA_MODE {
    OPJ_OFF = 0,
    OPJ_CINEMA2K_24 = 1,
    OPJ_CINEMA2K_48 = 2,
    OPJ_CINEMA4K_24 = 3
} ;
#line 298 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 303
enum PROG_ORDER {
    OPJ_PROG_UNKNOWN = -1,
    OPJ_LRCP = 0,
    OPJ_RLCP = 1,
    OPJ_RPCL = 2,
    OPJ_PCRL = 3,
    OPJ_CPRL = 4
} ;
#line 310 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 315
enum COLOR_SPACE {
    OPJ_CLRSPC_UNKNOWN = -1,
    OPJ_CLRSPC_UNSPECIFIED = 0,
    OPJ_CLRSPC_SRGB = 1,
    OPJ_CLRSPC_GRAY = 2,
    OPJ_CLRSPC_SYCC = 3,
    OPJ_CLRSPC_EYCC = 4,
    OPJ_CLRSPC_CMYK = 5
} ;
#line 323 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 328
enum CODEC_FORMAT {
    OPJ_CODEC_UNKNOWN = -1,
    OPJ_CODEC_J2K = 0,
    OPJ_CODEC_JPT = 1,
    OPJ_CODEC_JP2 = 2,
    OPJ_CODEC_JPP = 3,
    OPJ_CODEC_JPX = 4
} ;
#line 335 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 349 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 365 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_poc {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_INT32 tx0 ;
   OPJ_INT32 tx1 ;
   OPJ_INT32 ty0 ;
   OPJ_INT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 393 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_cparameters {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 544 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 552 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_dparameters {
   OPJ_UINT32 cp_reduce ;
   OPJ_UINT32 cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   OPJ_UINT32 DA_x0 ;
   OPJ_UINT32 DA_x1 ;
   OPJ_UINT32 DA_y0 ;
   OPJ_UINT32 DA_y1 ;
   OPJ_BOOL m_verbose ;
   OPJ_UINT32 tile_index ;
   OPJ_UINT32 nb_tile_to_decode ;
   OPJ_BOOL jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   unsigned int flags ;
};
#line 612 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 618 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void *opj_codec_t;
#line 637 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_read_fn)(void * , OPJ_SIZE_T  , void * );
#line 643 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_SIZE_T (*opj_stream_write_fn)(void * , OPJ_SIZE_T  , void * );
#line 649 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_OFF_T (*opj_stream_skip_fn)(OPJ_OFF_T  , void * );
#line 655 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef OPJ_BOOL (*opj_stream_seek_fn)(OPJ_OFF_T  , void * );
#line 661 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void (*opj_stream_free_user_data_fn)(void * );
#line 666 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef void *opj_stream_t;
#line 677 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 resno_decoded ;
   OPJ_UINT32 factor ;
   OPJ_INT32 *data ;
   OPJ_UINT16 alpha ;
};
#line 704 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 709 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image {
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 x1 ;
   OPJ_UINT32 y1 ;
   OPJ_UINT32 numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
};
#line 728 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 734 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_image_comptparm {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 x0 ;
   OPJ_UINT32 y0 ;
   OPJ_UINT32 prec ;
   OPJ_UINT32 bpp ;
   OPJ_UINT32 sgnd ;
};
#line 753 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 766 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_packet_info {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_ph_pos ;
   OPJ_OFF_T end_pos ;
   double disto ;
};
#line 775 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 782 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_marker_info {
   unsigned short type ;
   OPJ_OFF_T pos ;
   int len ;
};
#line 789 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_marker_info opj_marker_info_t;
#line 795 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 806 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 811 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 846 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 851 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 898 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 906 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tccp_info {
   OPJ_UINT32 compno ;
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   OPJ_UINT32 stepsizes_mant[97] ;
   OPJ_UINT32 stepsizes_expn[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
};
#line 936 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tccp_info opj_tccp_info_t;
#line 941 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_v2_info {
   int tileno ;
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 mct ;
   opj_tccp_info_t *tccp_info ;
};
#line 957 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_v2_info opj_tile_info_v2_t;
#line 962 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_info_v2 {
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 nbcomps ;
   opj_tile_info_v2_t m_default_tile_info ;
   opj_tile_info_v2_t *tile_info ;
};
#line 986 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_info_v2 opj_codestream_info_v2_t;
#line 992 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tp_index {
   OPJ_OFF_T start_pos ;
   OPJ_OFF_T end_header ;
   OPJ_OFF_T end_pos ;
};
#line 1000 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tp_index opj_tp_index_t;
#line 1005 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_tile_index {
   OPJ_UINT32 tileno ;
   OPJ_UINT32 nb_tps ;
   OPJ_UINT32 current_nb_tps ;
   OPJ_UINT32 current_tpsno ;
   opj_tp_index_t *tp_index ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_packet ;
   opj_packet_info_t *packet_index ;
};
#line 1032 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_tile_index opj_tile_index_t;
#line 1037 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_codestream_index {
   OPJ_OFF_T main_head_start ;
   OPJ_OFF_T main_head_end ;
   OPJ_UINT64 codestream_size ;
   OPJ_UINT32 marknum ;
   opj_marker_info_t *marker ;
   OPJ_UINT32 maxmarknum ;
   OPJ_UINT32 nb_of_tiles ;
   opj_tile_index_t *tile_index ;
};
#line 1060 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_codestream_index opj_codestream_index_t;
#line 1073 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_jp2_metadata {
   OPJ_INT32 not_used ;
};
#line 1077 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_metadata opj_jp2_metadata_t;
#line 1083 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_jp2_index {
   OPJ_INT32 not_used ;
};
#line 1087 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_jp2_index opj_jp2_index_t;
#line 217 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_includes.h"
typedef unsigned int OPJ_BITFIELD;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_8 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_8 imaxdiv_t;
#line 35 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h"
typedef long ptrdiff_t;
#line 19 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h"
struct __anonstruct_9 {
   long long __clang_max_align_nonce1 ;
   long double __clang_max_align_nonce2 ;
};
#line 24 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h"
typedef struct __anonstruct_9 max_align_t;
#line 50 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
struct opj_event_mgr {
   void *m_error_data ;
   void *m_warning_data ;
   void *m_info_data ;
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
typedef void (*opj_procedure)(void);
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
struct opj_procedure_list {
   OPJ_UINT32 m_nb_procedures ;
   OPJ_UINT32 m_nb_max_procedures ;
   opj_procedure *m_procedures ;
};
#line 71 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
typedef struct opj_procedure_list opj_procedure_list_t;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
struct opj_bio {
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   OPJ_BYTE *bp ;
   OPJ_UINT32 buf ;
   OPJ_UINT32 ct ;
};
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
typedef struct opj_bio opj_bio_t;
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
struct opj_stream_private {
   void *m_user_data ;
   opj_stream_free_user_data_fn m_free_user_data_fn ;
   OPJ_UINT64 m_user_data_length ;
   opj_stream_read_fn m_read_fn ;
   opj_stream_write_fn m_write_fn ;
   opj_stream_skip_fn m_skip_fn ;
   opj_stream_seek_fn m_seek_fn ;
   OPJ_BYTE *m_stored_data ;
   OPJ_BYTE *m_current_data ;
   OPJ_OFF_T (*m_opj_skip)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*m_opj_seek)(struct opj_stream_private * , OPJ_OFF_T  , struct opj_event_mgr * ) ;
   OPJ_SIZE_T m_bytes_in_buffer ;
   OPJ_OFF_T m_byte_offset ;
   OPJ_SIZE_T m_buffer_size ;
   OPJ_UINT32 m_status ;
};
#line 165 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
typedef struct opj_stream_private opj_stream_private_t;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
struct opj_mutex_t ;
#line 52 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_mutex_t opj_mutex_t;
#line 81
struct opj_cond_t ;
#line 81 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_cond_t opj_cond_t;
#line 141
struct opj_thread_t ;
#line 141 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_thread_t opj_thread_t;
#line 146 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_thread_fn)(void * );
#line 167
struct opj_tls_t ;
#line 167 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_tls_t opj_tls_t;
#line 177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_tls_free_func)(void * );
#line 195
struct opj_thread_pool_t ;
#line 195 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef struct opj_thread_pool_t opj_thread_pool_t;
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
typedef void (*opj_job_fn)(void * , opj_tls_t * );
#line 41 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.h"
struct opj_cp ;
#line 125 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
enum J2K_STATUS {
    J2K_STATE_NONE = 0,
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_DATA = 128,
    J2K_STATE_EOC = 256,
    J2K_STATE_ERR = 32768
} ;
#line 138 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 143
enum MCT_ELEMENT_TYPE {
    MCT_TYPE_INT16 = 0,
    MCT_TYPE_INT32 = 1,
    MCT_TYPE_FLOAT = 2,
    MCT_TYPE_DOUBLE = 3
} ;
#line 148 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum MCT_ELEMENT_TYPE J2K_MCT_ELEMENT_TYPE;
#line 153
enum MCT_ARRAY_TYPE {
    MCT_TYPE_DEPENDENCY = 0,
    MCT_TYPE_DECORRELATION = 1,
    MCT_TYPE_OFFSET = 2
} ;
#line 157 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum MCT_ARRAY_TYPE J2K_MCT_ARRAY_TYPE;
#line 164
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 167 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 172 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_stepsize {
   OPJ_INT32 expn ;
   OPJ_INT32 mant ;
};
#line 177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 182 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tccp {
   OPJ_UINT32 csty ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 cblkw ;
   OPJ_UINT32 cblkh ;
   OPJ_UINT32 cblksty ;
   OPJ_UINT32 qmfbid ;
   OPJ_UINT32 qntsty ;
   opj_stepsize_t stepsizes[97] ;
   OPJ_UINT32 numgbits ;
   OPJ_INT32 roishift ;
   OPJ_UINT32 prcw[33] ;
   OPJ_UINT32 prch[33] ;
   OPJ_INT32 m_dc_level_shift ;
};
#line 210 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 217 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_mct_data {
   J2K_MCT_ELEMENT_TYPE m_element_type ;
   J2K_MCT_ARRAY_TYPE m_array_type ;
   OPJ_UINT32 m_index ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_mct_data opj_mct_data_t;
#line 229 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_simple_mcc_decorrelation_data {
   OPJ_UINT32 m_index ;
   OPJ_UINT32 m_nb_comps ;
   opj_mct_data_t *m_decorrelation_array ;
   opj_mct_data_t *m_offset_array ;
   OPJ_BITFIELD m_is_irreversible ;
};
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_simple_mcc_decorrelation_data opj_simple_mcc_decorrelation_data_t;
#line 238 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_ppx_struct {
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
};
#line 241 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_ppx_struct opj_ppx;
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tcp {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 317 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 323
enum __anonenum__10 {
    RATE_DISTORTION_RATIO = 0,
    FIXED_DISTORTION_RATIO = 1,
    FIXED_LAYER = 2
} ;
#line 327 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef enum __anonenum__10 J2K_QUALITY_LAYER_ALLOCATION_STRATEGY;
#line 330 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_encoding_param {
   OPJ_UINT32 m_max_comp_size ;
   OPJ_INT32 m_tp_pos ;
   OPJ_INT32 *m_matrice ;
   OPJ_BYTE m_tp_flag ;
   J2K_QUALITY_LAYER_ALLOCATION_STRATEGY m_quality_layer_alloc_strategy ;
   OPJ_BITFIELD m_tp_on ;
};
#line 344 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_encoding_param opj_encoding_param_t;
#line 346 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_decoding_param {
   OPJ_UINT32 m_reduce ;
   OPJ_UINT32 m_layer ;
};
#line 352 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_decoding_param opj_decoding_param_t;
#line 406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_11 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 358 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_cp {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t *tcps ;
   union __anonunion_11 m_specific_param ;
   OPJ_BOOL strict ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 467 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 470 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_dec {
   OPJ_UINT32 m_state ;
   opj_tcp_t *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_numcomps_to_decode ;
   OPJ_UINT32 *m_comps_indices_to_decode ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 510 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec opj_j2k_dec_t;
#line 512 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_enc {
   OPJ_UINT32 m_current_poc_tile_part_number ;
   OPJ_UINT32 m_current_tile_part_number ;
   OPJ_BOOL m_TLM ;
   OPJ_BOOL m_Ttlmi_is_byte ;
   OPJ_OFF_T m_tlm_start ;
   OPJ_BYTE *m_tlm_sot_offsets_buffer ;
   OPJ_BYTE *m_tlm_sot_offsets_current ;
   OPJ_UINT32 m_total_tile_parts ;
   OPJ_BYTE *m_encoded_tile_data ;
   OPJ_UINT32 m_encoded_tile_size ;
   OPJ_BYTE *m_header_tile_data ;
   OPJ_UINT32 m_header_tile_data_size ;
   OPJ_BOOL m_PLT ;
   OPJ_UINT32 m_reserved_bytes_for_PLT ;
   OPJ_UINT32 m_nb_comps ;
};
#line 565 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_enc opj_j2k_enc_t;
#line 569
struct opj_tcd ;
#line 578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_12 {
   opj_j2k_dec_t m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 573 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_12 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd *m_tcd ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   unsigned int dump_state ;
};
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
enum __anonenum__13 {
    JP2_STATE_NONE = 0,
    JP2_STATE_SIGNATURE = 1,
    JP2_STATE_FILE_TYPE = 2,
    JP2_STATE_HEADER = 4,
    JP2_STATE_CODESTREAM = 8,
    JP2_STATE_END_CODESTREAM = 16,
    JP2_STATE_UNKNOWN = 2147483647
} ;
#line 82 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef enum __anonenum__13 JP2_STATE;
#line 84
enum __anonenum__14 {
    JP2_IMG_STATE_NONE = 0,
    JP2_IMG_STATE_UNKNOWN = 2147483647
} ;
#line 88 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef enum __anonenum__14 JP2_IMG_STATE;
#line 93 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef_info {
   OPJ_UINT16 cn ;
   OPJ_UINT16 typ ;
   OPJ_UINT16 asoc ;
};
#line 95 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 100 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   OPJ_UINT16 n ;
};
#line 103 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 108 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_cmap_comp {
   OPJ_UINT16 cmp ;
   OPJ_BYTE mtyp ;
   OPJ_BYTE pcol ;
};
#line 111 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_pclr {
   OPJ_UINT32 *entries ;
   OPJ_BYTE *channel_sign ;
   OPJ_BYTE *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   OPJ_UINT16 nr_entries ;
   OPJ_BYTE nr_channels ;
};
#line 123 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_color {
   OPJ_BYTE *icc_profile_buf ;
   OPJ_UINT32 icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   OPJ_BYTE jp2_has_colr ;
};
#line 135 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 140 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_comps {
   OPJ_UINT32 depth ;
   OPJ_UINT32 sgnd ;
   OPJ_UINT32 bpcc ;
};
#line 144 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2 {
   opj_j2k_t *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 198 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_box {
   OPJ_UINT32 length ;
   OPJ_UINT32 type ;
   OPJ_INT32 init_pos ;
};
#line 202 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 204 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler opj_jp2_header_handler_t;
#line 216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler {
   OPJ_BYTE *(*handler)(opj_jp2_t * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler opj_jp2_img_header_writer_handler_t;
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
struct opj_mqc_state {
   OPJ_UINT32 qeval ;
   OPJ_UINT32 mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
struct opj_mqc {
   OPJ_UINT32 c ;
   OPJ_UINT32 a ;
   OPJ_UINT32 ct ;
   OPJ_UINT32 end_of_byte_stream_counter ;
   OPJ_BYTE *bp ;
   OPJ_BYTE *start ;
   OPJ_BYTE *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
   OPJ_BYTE *lut_ctxno_zc_orient ;
   OPJ_BYTE backup[2] ;
};
#line 97 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_resolution {
   OPJ_UINT32 pdx ;
   OPJ_UINT32 pdy ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
};
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_comp {
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 68 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_iterator {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 x ;
   OPJ_UINT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   opj_event_mgr_t *manager ;
};
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   OPJ_INT32 value ;
   OPJ_INT32 low ;
   OPJ_UINT32 known ;
};
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
struct opj_tgt_tree {
   OPJ_UINT32 numleafsh ;
   OPJ_UINT32 numleafsv ;
   OPJ_UINT32 numnodes ;
   opj_tgt_node_t *nodes ;
   OPJ_UINT32 nodes_size ;
};
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 57 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_pass {
   OPJ_UINT32 rate ;
   OPJ_FLOAT64 distortiondec ;
   OPJ_UINT32 len ;
   OPJ_BITFIELD term ;
};
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 67 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_layer {
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 len ;
   OPJ_FLOAT64 disto ;
   OPJ_BYTE *data ;
};
#line 72 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 77 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_enc {
   OPJ_BYTE *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 data_size ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 numpassesinlayers ;
   OPJ_UINT32 totalpasses ;
};
#line 90 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 94 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_seg_data_chunk {
   OPJ_BYTE *data ;
   OPJ_UINT32 len ;
};
#line 100 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg_data_chunk opj_tcd_seg_data_chunk_t;
#line 105 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_seg {
   OPJ_UINT32 len ;
   OPJ_UINT32 numpasses ;
   OPJ_UINT32 real_num_passes ;
   OPJ_UINT32 maxpasses ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 newlen ;
};
#line 117 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 120 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_cblk_dec {
   opj_tcd_seg_t *segs ;
   opj_tcd_seg_data_chunk_t *chunks ;
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 Mb ;
   OPJ_UINT32 numbps ;
   OPJ_UINT32 numlenbits ;
   OPJ_UINT32 numnewpasses ;
   OPJ_UINT32 numsegs ;
   OPJ_UINT32 real_num_segs ;
   OPJ_UINT32 m_current_max_segs ;
   OPJ_UINT32 numchunks ;
   OPJ_UINT32 numchunksalloc ;
   OPJ_INT32 *decoded_data ;
};
#line 144 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 151 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
union __anonunion_15 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
   void *blocks ;
};
#line 147 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_precinct {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 cw ;
   OPJ_UINT32 ch ;
   union __anonunion_15 cblks ;
   OPJ_UINT32 block_size ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 159 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 162 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_band {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 bandno ;
   opj_tcd_precinct_t *precincts ;
   OPJ_UINT32 precincts_data_size ;
   OPJ_INT32 numbps ;
   OPJ_FLOAT32 stepsize ;
};
#line 173 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 176 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_resolution {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 pw ;
   OPJ_UINT32 ph ;
   OPJ_UINT32 numbands ;
   opj_tcd_band_t bands[3] ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
};
#line 191 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 194 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_tilecomp {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 numresolutions ;
   OPJ_UINT32 minimum_num_resolutions ;
   opj_tcd_resolution_t *resolutions ;
   OPJ_UINT32 resolutions_size ;
   OPJ_INT32 *data ;
   OPJ_BOOL ownsData ;
   size_t data_size_needed ;
   size_t data_size ;
   OPJ_INT32 *data_win ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_SIZE_T numpix ;
};
#line 227 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 233 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_tile {
   OPJ_INT32 x0 ;
   OPJ_INT32 y0 ;
   OPJ_INT32 x1 ;
   OPJ_INT32 y1 ;
   OPJ_UINT32 numcomps ;
   opj_tcd_tilecomp_t *comps ;
   OPJ_SIZE_T numpix ;
   OPJ_FLOAT64 distotile ;
   OPJ_FLOAT64 distolayer[100] ;
   OPJ_UINT32 packno ;
};
#line 242 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 247 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_image {
   opj_tcd_tile_t *tiles ;
};
#line 250 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 256 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcp_t *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
   OPJ_BOOL *used_component ;
};
#line 290 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 296 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd_marker_info {
   OPJ_BOOL need_PLT ;
   OPJ_UINT32 packet_count ;
   OPJ_UINT32 *p_packet_size ;
};
#line 306 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd_marker_info opj_tcd_marker_info_t;
#line 179 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
typedef OPJ_UINT32 opj_flag_t;
#line 184 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
struct opj_t1 {
   opj_mqc_t mqc ;
   OPJ_INT32 *data ;
   opj_flag_t *flags ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 datasize ;
   OPJ_UINT32 flagssize ;
   OPJ_BOOL encoder ;
   OPJ_BOOL mustuse_cblkdatabuffer ;
   OPJ_BYTE *cblkdatabuffer ;
   OPJ_UINT32 cblkdatabuffersize ;
};
#line 210 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
struct opj_t2 {
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 60 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
struct opj_sparse_array_int32 ;
#line 53 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
typedef struct opj_sparse_array_int32 opj_sparse_array_int32_t;
#line 48 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_decompression {
   OPJ_BOOL (*opj_read_header)(struct opj_stream_private * , void * , opj_image_t ** ,
                               struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode)(void * , struct opj_stream_private * , opj_image_t * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_read_tile_header)(void * , OPJ_UINT32 * , OPJ_UINT32 * , OPJ_INT32 * ,
                                    OPJ_INT32 * , OPJ_INT32 * , OPJ_INT32 * , OPJ_UINT32 * ,
                                    OPJ_BOOL * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_decode_tile_data)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  ,
                                    struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_decompress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   void (*opj_setup_decoder)(void * , opj_dparameters_t * ) ;
   void (*opj_decoder_set_strict_mode)(void * , OPJ_BOOL  ) ;
   OPJ_BOOL (*opj_set_decode_area)(void * , opj_image_t * , OPJ_INT32  , OPJ_INT32  ,
                                   OPJ_INT32  , OPJ_INT32  , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_get_decoded_tile)(void * , opj_stream_private_t * , opj_image_t * ,
                                    struct opj_event_mgr * , OPJ_UINT32  ) ;
   OPJ_BOOL (*opj_set_decoded_resolution_factor)(void * , OPJ_UINT32  , opj_event_mgr_t * ) ;
   OPJ_BOOL (*opj_set_decoded_components)(void * , OPJ_UINT32  , OPJ_UINT32 * , opj_event_mgr_t * ) ;
};
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_compression {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encoder_set_extra_options)(void * , char const   * const  * , struct opj_event_mgr * ) ;
};
#line 44 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
union __anonunion_16 {
   struct opj_decompression m_decompression ;
   struct opj_compression m_compression ;
};
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_codec_private {
   union __anonunion_16 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private opj_codec_private_t;
#line 197 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler ;
#line 1347 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 1350 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1371 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef void (*opj_j2k_mct_function)(void const   * , void * , OPJ_UINT32  );
#line 1395 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
struct opj_dec_memory_marker_handler {
   OPJ_UINT32 id ;
   OPJ_UINT32 states ;
   OPJ_BOOL (*handler)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 1406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
typedef struct opj_dec_memory_marker_handler opj_dec_memory_marker_handler_t;
#line 853 "/usr/include/math.h"
enum __anonenum__4___0 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 365 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_poc___0 {
   OPJ_UINT32 resno0 ;
   OPJ_UINT32 compno0 ;
   OPJ_UINT32 layno1 ;
   OPJ_UINT32 resno1 ;
   OPJ_UINT32 compno1 ;
   OPJ_UINT32 layno0 ;
   OPJ_UINT32 precno0 ;
   OPJ_UINT32 precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   OPJ_CHAR progorder[5] ;
   OPJ_UINT32 tile ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 layS ;
   OPJ_UINT32 resS ;
   OPJ_UINT32 compS ;
   OPJ_UINT32 prcS ;
   OPJ_UINT32 layE ;
   OPJ_UINT32 resE ;
   OPJ_UINT32 compE ;
   OPJ_UINT32 prcE ;
   OPJ_UINT32 txS ;
   OPJ_UINT32 txE ;
   OPJ_UINT32 tyS ;
   OPJ_UINT32 tyE ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   OPJ_UINT32 lay_t ;
   OPJ_UINT32 res_t ;
   OPJ_UINT32 comp_t ;
   OPJ_UINT32 prc_t ;
   OPJ_UINT32 tx0_t ;
   OPJ_UINT32 ty0_t ;
};
#line 388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_poc___0 opj_poc_t___0;
#line 393 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
struct opj_cparameters___0 {
   OPJ_BOOL tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t___0 POC[32] ;
   OPJ_UINT32 numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   OPJ_BOOL jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   OPJ_BOOL jpip_on ;
   void *mct_data ;
   int max_cs_size ;
   OPJ_UINT16 rsiz ;
};
#line 544 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
typedef struct opj_cparameters___0 opj_cparameters_t___0;
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_tcp___0 {
   OPJ_UINT32 csty ;
   OPJ_PROG_ORDER prg ;
   OPJ_UINT32 numlayers ;
   OPJ_UINT32 num_layers_to_decode ;
   OPJ_UINT32 mct ;
   OPJ_FLOAT32 rates[100] ;
   OPJ_UINT32 numpocs ;
   opj_poc_t___0 pocs[32] ;
   OPJ_UINT32 ppt_markers_count ;
   opj_ppx *ppt_markers ;
   OPJ_BYTE *ppt_data ;
   OPJ_BYTE *ppt_buffer ;
   OPJ_UINT32 ppt_data_size ;
   OPJ_UINT32 ppt_len ;
   OPJ_FLOAT32 distoratio[100] ;
   opj_tccp_t *tccps ;
   OPJ_INT32 m_current_tile_part_number ;
   OPJ_UINT32 m_nb_tile_parts ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_data_size ;
   OPJ_FLOAT64 *mct_norms ;
   OPJ_FLOAT32 *m_mct_decoding_matrix ;
   OPJ_FLOAT32 *m_mct_coding_matrix ;
   opj_mct_data_t *m_mct_records ;
   OPJ_UINT32 m_nb_mct_records ;
   OPJ_UINT32 m_nb_max_mct_records ;
   opj_simple_mcc_decorrelation_data_t *m_mcc_records ;
   OPJ_UINT32 m_nb_mcc_records ;
   OPJ_UINT32 m_nb_max_mcc_records ;
   OPJ_BITFIELD cod ;
   OPJ_BITFIELD ppt ;
   OPJ_BITFIELD POC ;
};
#line 317 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_tcp___0 opj_tcp_t___0;
#line 406 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_11___0 {
   opj_decoding_param_t m_dec ;
   opj_encoding_param_t m_enc ;
};
#line 358 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_cp___0 {
   OPJ_UINT16 rsiz ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tdx ;
   OPJ_UINT32 tdy ;
   OPJ_CHAR *comment ;
   OPJ_UINT32 tw ;
   OPJ_UINT32 th ;
   OPJ_UINT32 ppm_markers_count ;
   opj_ppx *ppm_markers ;
   OPJ_BYTE *ppm_data ;
   OPJ_UINT32 ppm_len ;
   OPJ_UINT32 ppm_data_read ;
   OPJ_BYTE *ppm_data_current ;
   OPJ_BYTE *ppm_buffer ;
   OPJ_BYTE *ppm_data_first ;
   OPJ_UINT32 ppm_data_size ;
   OPJ_INT32 ppm_store ;
   OPJ_INT32 ppm_previous ;
   opj_tcp_t___0 *tcps ;
   union __anonunion_11___0 m_specific_param ;
   OPJ_BOOL strict ;
   OPJ_BITFIELD ppm ;
   OPJ_BITFIELD m_is_decoder ;
   OPJ_BITFIELD allow_different_bit_depth_sign ;
};
#line 467 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_cp___0 opj_cp_t___0;
#line 470 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k_dec___0 {
   OPJ_UINT32 m_state ;
   opj_tcp_t___0 *m_default_tcp ;
   OPJ_BYTE *m_header_data ;
   OPJ_UINT32 m_header_data_size ;
   OPJ_UINT32 m_sot_length ;
   OPJ_UINT32 m_start_tile_x ;
   OPJ_UINT32 m_start_tile_y ;
   OPJ_UINT32 m_end_tile_x ;
   OPJ_UINT32 m_end_tile_y ;
   OPJ_INT32 m_tile_ind_to_dec ;
   OPJ_OFF_T m_last_sot_read_pos ;
   OPJ_BOOL m_last_tile_part ;
   OPJ_UINT32 m_numcomps_to_decode ;
   OPJ_UINT32 *m_comps_indices_to_decode ;
   OPJ_BITFIELD m_can_decode ;
   OPJ_BITFIELD m_discard_tiles ;
   OPJ_BITFIELD m_skip_data ;
   OPJ_BITFIELD m_nb_tile_parts_correction_checked ;
   OPJ_BITFIELD m_nb_tile_parts_correction ;
};
#line 510 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k_dec___0 opj_j2k_dec_t___0;
#line 578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
union __anonunion_12___0 {
   opj_j2k_dec_t___0 m_decoder ;
   opj_j2k_enc_t m_encoder ;
};
#line 573 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
struct opj_j2k___0 {
   OPJ_BOOL m_is_decoder ;
   union __anonunion_12___0 m_specific_param ;
   opj_image_t *m_private_image ;
   opj_image_t *m_output_image ;
   opj_cp_t___0 m_cp ;
   opj_procedure_list_t *m_procedure_list ;
   opj_procedure_list_t *m_validation_list ;
   opj_codestream_index_t *cstr_index ;
   OPJ_UINT32 m_current_tile_number ;
   struct opj_tcd___0 *m_tcd ;
   opj_thread_pool_t *m_tp ;
   OPJ_UINT32 ihdr_w ;
   OPJ_UINT32 ihdr_h ;
   unsigned int dump_state ;
};
#line 620 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
typedef struct opj_j2k___0 opj_j2k_t___0;
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2___0 {
   opj_j2k_t___0 *j2k ;
   struct opj_procedure_list *m_validation_list ;
   struct opj_procedure_list *m_procedure_list ;
   OPJ_UINT32 w ;
   OPJ_UINT32 h ;
   OPJ_UINT32 numcomps ;
   OPJ_UINT32 bpc ;
   OPJ_UINT32 C ;
   OPJ_UINT32 UnkC ;
   OPJ_UINT32 IPR ;
   OPJ_UINT32 meth ;
   OPJ_UINT32 approx ;
   OPJ_UINT32 enumcs ;
   OPJ_UINT32 precedence ;
   OPJ_UINT32 brand ;
   OPJ_UINT32 minversion ;
   OPJ_UINT32 numcl ;
   OPJ_UINT32 *cl ;
   opj_jp2_comps_t *comps ;
   OPJ_OFF_T j2k_codestream_offset ;
   OPJ_OFF_T jpip_iptr_offset ;
   OPJ_BOOL jpip_on ;
   OPJ_UINT32 jp2_state ;
   OPJ_UINT32 jp2_img_state ;
   opj_jp2_color_t color ;
   OPJ_BOOL ignore_pclr_cmap_cdef ;
   OPJ_BYTE has_jp2h ;
   OPJ_BYTE has_ihdr ;
};
#line 193 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2___0 opj_jp2_t___0;
#line 204 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_header_handler___0 {
   OPJ_UINT32 id ;
   OPJ_BOOL (*handler)(opj_jp2_t___0 * , OPJ_BYTE * , OPJ_UINT32  , opj_event_mgr_t * ) ;
};
#line 213 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_header_handler___0 opj_jp2_header_handler_t___0;
#line 216 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
struct opj_jp2_img_header_writer_handler___0 {
   OPJ_BYTE *(*handler)(opj_jp2_t___0 * , OPJ_UINT32 * ) ;
   OPJ_BYTE *m_data ;
   OPJ_UINT32 m_size ;
};
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
typedef struct opj_jp2_img_header_writer_handler___0 opj_jp2_img_header_writer_handler_t___0;
#line 73 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
struct opj_pi_iterator___0 {
   OPJ_BYTE tp_on ;
   OPJ_INT16 *include ;
   OPJ_UINT32 include_size ;
   OPJ_UINT32 step_l ;
   OPJ_UINT32 step_r ;
   OPJ_UINT32 step_c ;
   OPJ_UINT32 step_p ;
   OPJ_UINT32 compno ;
   OPJ_UINT32 resno ;
   OPJ_UINT32 precno ;
   OPJ_UINT32 layno ;
   OPJ_BOOL first ;
   opj_poc_t___0 poc ;
   OPJ_UINT32 numcomps ;
   opj_pi_comp_t *comps ;
   OPJ_UINT32 tx0 ;
   OPJ_UINT32 ty0 ;
   OPJ_UINT32 tx1 ;
   OPJ_UINT32 ty1 ;
   OPJ_UINT32 x ;
   OPJ_UINT32 y ;
   OPJ_UINT32 dx ;
   OPJ_UINT32 dy ;
   opj_event_mgr_t *manager ;
};
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
typedef struct opj_pi_iterator___0 opj_pi_iterator_t___0;
#line 256 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
struct opj_tcd___0 {
   OPJ_INT32 tp_pos ;
   OPJ_UINT32 tp_num ;
   OPJ_UINT32 cur_tp_num ;
   OPJ_UINT32 cur_totnum_tp ;
   OPJ_UINT32 cur_pino ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t___0 *cp ;
   opj_tcp_t___0 *tcp ;
   OPJ_UINT32 tcd_tileno ;
   OPJ_BITFIELD m_is_decoder ;
   opj_thread_pool_t *thread_pool ;
   OPJ_UINT32 win_x0 ;
   OPJ_UINT32 win_y0 ;
   OPJ_UINT32 win_x1 ;
   OPJ_UINT32 win_y1 ;
   OPJ_BOOL whole_tile_decoding ;
   OPJ_BOOL *used_component ;
};
#line 290 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
typedef struct opj_tcd___0 opj_tcd_t___0;
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
struct opj_t2___0 {
   opj_image_t *image ;
   opj_cp_t___0 *cp ;
};
#line 60 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
typedef struct opj_t2___0 opj_t2_t___0;
#line 127 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_compression___0 {
   OPJ_BOOL (*opj_start_compress)(void * , struct opj_stream_private * , struct opj_image * ,
                                  struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encode)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_write_tile)(void * , OPJ_UINT32  , OPJ_BYTE * , OPJ_UINT32  , struct opj_stream_private * ,
                              struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_end_compress)(void * , struct opj_stream_private * , struct opj_event_mgr * ) ;
   void (*opj_destroy)(void * ) ;
   OPJ_BOOL (*opj_setup_encoder)(void * , opj_cparameters_t___0 * , struct opj_image * ,
                                 struct opj_event_mgr * ) ;
   OPJ_BOOL (*opj_encoder_set_extra_options)(void * , char const   * const  * , struct opj_event_mgr * ) ;
};
#line 44 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
union __anonunion_16___0 {
   struct opj_decompression m_decompression ;
   struct opj_compression___0 m_compression ;
};
#line 42 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
struct opj_codec_private___0 {
   union __anonunion_16___0 m_codec_data ;
   void *m_codec ;
   opj_event_mgr_t m_event_mgr ;
   OPJ_BOOL is_decompressor ;
   void (*opj_dump_codec)(void * , OPJ_INT32  , FILE * ) ;
   opj_codestream_info_v2_t *(*opj_get_codec_info)(void * ) ;
   opj_codestream_index_t *(*opj_get_codec_index)(void * ) ;
   OPJ_BOOL (*opj_set_threads)(void * , OPJ_UINT32  ) ;
};
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_codec.h"
typedef struct opj_codec_private___0 opj_codec_private_t___0;
#line 853 "/usr/include/math.h"
enum __anonenum__4___1 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__7___1 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                  size_t __n ) ;
#line 47
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src ) ;
#line 125
extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src ) ;
#line 133
extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                   size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 784
extern int system(char const   *__command ) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__pwcs , char const   *__s ,
                                                     size_t __n ) ;
#line 936
extern  __attribute__((__nothrow__)) size_t wcstombs(char *__s , wchar_t *__pwcs ,
                                                     size_t __n ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 326
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 332
extern int printf(char const   *__format  , ...) ;
#line 334
extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__format 
                                                 , ...) ;
#line 341
extern int vfprintf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 349
extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__format ,
                                                  __gnuc_va_list __arg ) ;
#line 354
extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __maxlen , char const   *__format 
                                                  , ...) ;
#line 358
extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __maxlen , char const   *__format ,
                                                   __gnuc_va_list __arg ) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 564
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg )  __attribute__((__gnu_inline__)) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __arg ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 41
  __cil_tmp3 = vfprintf(stdout, __fmt, __arg);
  }
#line 41
  return (__cil_tmp3);
}
}
#line 47
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 66
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 68
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 68
  if (__cil_tmp2) {
    {
#line 68
    __cil_tmp3 = __uflow(__fp);
#line 68
    tmp = __cil_tmp3;
    }
  } else {
#line 68
    (__fp->_IO_read_ptr) ++;
#line 68
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 68
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 101
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 103
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 103
  if (__cil_tmp3) {
    {
#line 103
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 103
    tmp = __cil_tmp4;
    }
  } else {
#line 103
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 103
    (__stream->_IO_write_ptr) ++;
#line 103
    *__cil_tmp5 = (char )__c;
#line 103
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 103
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 1102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/openjpeg.h"
char const   *opj_version(void) ;
#line 1118
opj_image_t *opj_image_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                              OPJ_COLOR_SPACE clrspc ) ;
#line 1126
void opj_image_destroy(opj_image_t *image ) ;
#line 1137
opj_image_t *opj_image_tile_create(OPJ_UINT32 numcmpts , opj_image_cmptparm_t *cmptparms ,
                                   OPJ_COLOR_SPACE clrspc ) ;
#line 1149
void *opj_image_data_alloc(OPJ_SIZE_T size ) ;
#line 1159
void opj_image_data_free(void *ptr ) ;
#line 1174
opj_stream_t *opj_stream_default_create(OPJ_BOOL p_is_input ) ;
#line 1185
opj_stream_t *opj_stream_create(OPJ_SIZE_T p_buffer_size , OPJ_BOOL p_is_input ) ;
#line 1194
void opj_stream_destroy(opj_stream_t *p_stream ) ;
#line 1201
void opj_stream_set_read_function(opj_stream_t *p_stream , opj_stream_read_fn p_function ) ;
#line 1209
void opj_stream_set_write_function(opj_stream_t *p_stream , opj_stream_write_fn p_function ) ;
#line 1217
void opj_stream_set_skip_function(opj_stream_t *p_stream , opj_stream_skip_fn p_function ) ;
#line 1226
void opj_stream_set_seek_function(opj_stream_t *p_stream , opj_stream_seek_fn p_function ) ;
#line 1235
void opj_stream_set_user_data(opj_stream_t *p_stream , void *p_data , opj_stream_free_user_data_fn p_function ) ;
#line 1244
void opj_stream_set_user_data_length(opj_stream_t *p_stream , OPJ_UINT64 data_length ) ;
#line 1252
opj_stream_t *opj_stream_create_default_file_stream(char const   *fname , OPJ_BOOL p_is_read_stream ) ;
#line 1260
opj_stream_t *opj_stream_create_file_stream(char const   *fname , OPJ_SIZE_T p_buffer_size ,
                                            OPJ_BOOL p_is_read_stream ) ;
#line 1276
OPJ_BOOL opj_set_info_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                              void *p_user_data ) ;
#line 1285
OPJ_BOOL opj_set_warning_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                                 void *p_user_data ) ;
#line 1294
OPJ_BOOL opj_set_error_handler(opj_codec_t *p_codec , opj_msg_callback p_callback ,
                               void *p_user_data ) ;
#line 1310
opj_codec_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 1318
void opj_destroy_codec(opj_codec_t *p_codec ) ;
#line 1325
OPJ_BOOL opj_end_decompress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1333
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 1345
OPJ_BOOL opj_setup_decoder(opj_codec_t *p_codec , opj_dparameters_t *parameters ) ;
#line 1359
OPJ_BOOL opj_decoder_set_strict_mode(opj_codec_t *p_codec , OPJ_BOOL strict ) ;
#line 1380
OPJ_BOOL opj_codec_set_threads(opj_codec_t *p_codec , int num_threads ) ;
#line 1392
OPJ_BOOL opj_read_header(opj_stream_t *p_stream , opj_codec_t *p_codec , opj_image_t **p_image ) ;
#line 1422
OPJ_BOOL opj_set_decoded_components(opj_codec_t *p_codec , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                    OPJ_BOOL apply_color_transforms ) ;
#line 1449
OPJ_BOOL opj_set_decode_area(opj_codec_t *p_codec , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                             OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ) ;
#line 1462
OPJ_BOOL opj_decode(opj_codec_t *p_decompressor , opj_stream_t *p_stream , opj_image_t *p_image ) ;
#line 1476
OPJ_BOOL opj_get_decoded_tile(opj_codec_t *p_codec , opj_stream_t *p_stream , opj_image_t *p_image ,
                              OPJ_UINT32 tile_index ) ;
#line 1488
OPJ_BOOL opj_set_decoded_resolution_factor(opj_codec_t *p_codec , OPJ_UINT32 res_factor ) ;
#line 1503
OPJ_BOOL opj_write_tile(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                        OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1530
OPJ_BOOL opj_read_tile_header(opj_codec_t *p_codec , opj_stream_t *p_stream , OPJ_UINT32 *p_tile_index ,
                              OPJ_UINT32 *p_data_size , OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 ,
                              OPJ_INT32 *p_tile_x1 , OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                              OPJ_BOOL *p_should_go_on ) ;
#line 1553
OPJ_BOOL opj_decode_tile_data(opj_codec_t *p_codec , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                              OPJ_UINT32 p_data_size , opj_stream_t *p_stream ) ;
#line 1566
opj_codec_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 1589
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 1598
OPJ_BOOL opj_setup_encoder(opj_codec_t *p_codec , opj_cparameters_t *parameters ,
                           opj_image_t *image ) ;
#line 1631
OPJ_BOOL opj_encoder_set_extra_options(opj_codec_t *p_codec , char const   * const  *p_options ) ;
#line 1641
OPJ_BOOL opj_start_compress(opj_codec_t *p_codec , opj_image_t *p_image , opj_stream_t *p_stream ) ;
#line 1650
OPJ_BOOL opj_end_compress(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1660
OPJ_BOOL opj_encode(opj_codec_t *p_codec , opj_stream_t *p_stream ) ;
#line 1673
void opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info ) ;
#line 1685
void opj_dump_codec(opj_codec_t *p_codec , OPJ_INT32 info_flag , FILE *output_stream ) ;
#line 1697
opj_codestream_info_v2_t *opj_get_cstr_info(opj_codec_t *p_codec ) ;
#line 1708
opj_codestream_index_t *opj_get_cstr_index(opj_codec_t *p_codec ) ;
#line 1711
void opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index ) ;
#line 1723
opj_jp2_metadata_t *opj_get_jp2_metadata(opj_codec_t *p_codec ) ;
#line 1734
opj_jp2_index_t *opj_get_jp2_index(opj_codec_t *p_codec ) ;
#line 1753
OPJ_BOOL opj_set_MCT(opj_cparameters_t *parameters , OPJ_FLOAT32 *pEncodingMatrix ,
                     OPJ_INT32 *p_dc_shift , OPJ_UINT32 pNbComp ) ;
#line 1767
OPJ_BOOL opj_has_thread_support(void) ;
#line 1770
int opj_get_num_cpus(void) ;
#line 174 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_includes.h"
__inline static long opj_lrintf(float f ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 176
  __cil_tmp2 = lrintf(f);
  }
#line 176
  return (__cil_tmp2);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_clock.h"
OPJ_FLOAT64 opj_clock(void) ;
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_malloc.h"
void *opj_malloc(size_t size ) ;
#line 63
void *opj_calloc(size_t numOfElements , size_t sizeOfElements ) ;
#line 70
void *opj_aligned_malloc(size_t size ) ;
#line 71
void *opj_aligned_realloc(void *ptr , size_t size ) ;
#line 72
void opj_aligned_free(void *ptr ) ;
#line 79
void *opj_aligned_32_malloc(size_t size ) ;
#line 80
void *opj_aligned_32_realloc(void *ptr , size_t size ) ;
#line 88
void *opj_realloc(void *m , size_t s ) ;
#line 94
void opj_free(void *m ) ;
#line 89 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/event.h"
OPJ_BOOL opj_event_msg(opj_event_mgr_t *event_mgr , OPJ_INT32 event_type , char const   *fmt 
                       , ...) ;
#line 96
void opj_set_default_event_handler(opj_event_mgr_t *p_manager ) ;
#line 80 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/function_list.h"
opj_procedure_list_t *opj_procedure_list_create(void) ;
#line 87
void opj_procedure_list_destroy(opj_procedure_list_t *p_list ) ;
#line 98
OPJ_BOOL opj_procedure_list_add_procedure(opj_procedure_list_t *p_validation_list ,
                                          opj_procedure p_procedure , opj_event_mgr_t *p_manager ) ;
#line 108
OPJ_UINT32 opj_procedure_list_get_nb_procedures(opj_procedure_list_t *p_validation_list ) ;
#line 120
opj_procedure *opj_procedure_list_get_first_procedure(opj_procedure_list_t *p_validation_list ) ;
#line 130
void opj_procedure_list_clear(opj_procedure_list_t *p_validation_list ) ;
#line 76 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.h"
opj_bio_t *opj_bio_create(void) ;
#line 81
void opj_bio_destroy(opj_bio_t *bio ) ;
#line 87
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) ;
#line 94
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 101
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) ;
#line 108
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) ;
#line 115
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) ;
#line 123
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) ;
#line 129
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) ;
#line 135
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) ;
#line 176 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/cio.h"
void opj_write_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 186
void opj_read_bytes_BE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 196
void opj_write_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 206
void opj_read_bytes_LE(OPJ_BYTE *p_buffer , OPJ_UINT32 *p_value , OPJ_UINT32 p_nb_bytes ) ;
#line 215
void opj_write_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 222
void opj_write_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 p_value ) ;
#line 229
void opj_read_double_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 236
void opj_read_double_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT64 *p_value ) ;
#line 243
void opj_read_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 250
void opj_read_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 *p_value ) ;
#line 257
void opj_write_float_LE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 264
void opj_write_float_BE(OPJ_BYTE *p_buffer , OPJ_FLOAT32 p_value ) ;
#line 274
OPJ_SIZE_T opj_stream_read_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                OPJ_SIZE_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 285
OPJ_SIZE_T opj_stream_write_data(opj_stream_private_t *p_stream , OPJ_BYTE *p_buffer ,
                                 OPJ_SIZE_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 295
OPJ_BOOL opj_stream_flush(opj_stream_private_t *p_stream , struct opj_event_mgr *p_event_mgr ) ;
#line 305
OPJ_OFF_T opj_stream_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 315
OPJ_OFF_T opj_stream_tell(opj_stream_private_t *p_stream ) ;
#line 325
OPJ_OFF_T opj_stream_get_number_byte_left(opj_stream_private_t *p_stream ) ;
#line 335
OPJ_OFF_T opj_stream_write_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                                struct opj_event_mgr *p_event_mgr ) ;
#line 345
OPJ_OFF_T opj_stream_read_skip(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               struct opj_event_mgr *p_event_mgr ) ;
#line 355
OPJ_BOOL opj_stream_read_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                              struct opj_event_mgr *p_event_mgr ) ;
#line 365
OPJ_BOOL opj_stream_write_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size ,
                               struct opj_event_mgr *p_event_mgr ) ;
#line 375
OPJ_BOOL opj_stream_seek(opj_stream_private_t *p_stream , OPJ_OFF_T p_size , struct opj_event_mgr *p_event_mgr ) ;
#line 381
OPJ_BOOL opj_stream_has_seek(opj_stream_private_t *p_stream ) ;
#line 386
OPJ_SIZE_T opj_stream_default_read(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 392
OPJ_SIZE_T opj_stream_default_write(void *p_buffer , OPJ_SIZE_T p_nb_bytes , void *p_user_data ) ;
#line 398
OPJ_OFF_T opj_stream_default_skip(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 403
OPJ_BOOL opj_stream_default_seek(OPJ_OFF_T p_nb_bytes , void *p_user_data ) ;
#line 58 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/thread.h"
opj_mutex_t *opj_mutex_create(void) ;
#line 63
void opj_mutex_lock(opj_mutex_t *mutex ) ;
#line 68
void opj_mutex_unlock(opj_mutex_t *mutex ) ;
#line 73
void opj_mutex_destroy(opj_mutex_t *mutex ) ;
#line 87
opj_cond_t *opj_cond_create(void) ;
#line 120
void opj_cond_wait(opj_cond_t *cond , opj_mutex_t *mutex ) ;
#line 128
void opj_cond_signal(opj_cond_t *cond ) ;
#line 133
void opj_cond_destroy(opj_cond_t *cond ) ;
#line 154
opj_thread_t *opj_thread_create(opj_thread_fn thread_fn , void *user_data ) ;
#line 160
void opj_thread_join(opj_thread_t *thread ) ;
#line 174
void *opj_tls_get(opj_tls_t *tls , int key ) ;
#line 186
OPJ_BOOL opj_tls_set(opj_tls_t *tls , int key , void *value , opj_tls_free_func free_func ) ;
#line 207
opj_thread_pool_t *opj_thread_pool_create(int num_threads ) ;
#line 225
OPJ_BOOL opj_thread_pool_submit_job(opj_thread_pool_t *tp , opj_job_fn job_fn , void *user_data ) ;
#line 237
void opj_thread_pool_wait_completion(opj_thread_pool_t *tp , int max_remaining_jobs ) ;
#line 245
int opj_thread_pool_get_thread_count(opj_thread_pool_t *tp ) ;
#line 250
void opj_thread_pool_destroy(opj_thread_pool_t *tp ) ;
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/image.h"
opj_image_t *opj_image_create0(void) ;
#line 61
void opj_image_comp_header_update(opj_image_t *p_image , struct opj_cp *p_cp ) ;
#line 64
void opj_copy_image_header(opj_image_t *p_image_src , opj_image_t *p_image_dest ) ;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/invert.h"
OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 *pSrcMatrix , OPJ_FLOAT32 *pDestMatrix ,
                                OPJ_UINT32 nb_compo ) ;
#line 635 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.h"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 637
void opj_j2k_decoder_set_strict_mode(opj_j2k_t *j2k , OPJ_BOOL strict ) ;
#line 639
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) ;
#line 646
opj_j2k_t *opj_j2k_create_compress(void) ;
#line 649
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 657
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 668
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) ;
#line 682
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 693
void opj_j2k_destroy(opj_j2k_t *p_j2k ) ;
#line 700
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) ;
#line 711
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 732
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 755
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) ;
#line 773
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 784
opj_j2k_t *opj_j2k_create_decompress(void) ;
#line 795
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) ;
#line 806
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) ;
#line 816
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) ;
#line 826
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) ;
#line 835
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) ;
#line 845
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 851
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 857
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 870
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) ;
#line 884
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 894
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 908
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) ;
#line 917
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) ;
#line 921
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) ;
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/jp2.h"
void opj_jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 245
void opj_jp2_decoder_set_strict_mode(opj_jp2_t *jp2 , OPJ_BOOL strict ) ;
#line 253
OPJ_BOOL opj_jp2_set_threads(opj_jp2_t *jp2 , OPJ_UINT32 num_threads ) ;
#line 264
OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) ;
#line 279
OPJ_BOOL opj_jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ,
                               opj_event_mgr_t *p_manager ) ;
#line 291
OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_event_mgr_t *p_manager ) ;
#line 306
OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2 , opj_stream_private_t *stream , opj_image_t *p_image ,
                                opj_event_mgr_t *p_manager ) ;
#line 316
OPJ_BOOL opj_jp2_end_compress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 326
OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2 , opj_stream_private_t *cio , opj_event_mgr_t *p_manager ) ;
#line 340
OPJ_BOOL opj_jp2_read_header(opj_stream_private_t *p_stream , opj_jp2_t *jp2 , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) ;
#line 355
OPJ_BOOL opj_jp2_set_decoded_components(opj_jp2_t *jp2 , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) ;
#line 374
OPJ_BOOL opj_jp2_read_tile_header(opj_jp2_t *p_jp2 , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 396
OPJ_BOOL opj_jp2_write_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) ;
#line 414
OPJ_BOOL opj_jp2_decode_tile(opj_jp2_t *p_jp2 , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) ;
#line 426
opj_jp2_t *opj_jp2_create(OPJ_BOOL p_is_decoder ) ;
#line 432
void opj_jp2_destroy(opj_jp2_t *jp2 ) ;
#line 448
OPJ_BOOL opj_jp2_set_decode_area(opj_jp2_t *p_jp2 , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) ;
#line 457
OPJ_BOOL opj_jp2_get_tile(opj_jp2_t *p_jp2 , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) ;
#line 467
OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2 , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) ;
#line 480
OPJ_BOOL opj_jp2_encoder_set_extra_options(opj_jp2_t *p_jp2 , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) ;
#line 495
void jp2_dump(opj_jp2_t *p_jp2 , OPJ_INT32 flag , FILE *out_stream ) ;
#line 504
opj_codestream_info_v2_t *jp2_get_cstr_info(opj_jp2_t *p_jp2 ) ;
#line 513
opj_codestream_index_t *jp2_get_cstr_index(opj_jp2_t *p_jp2 ) ;
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc_inl.h"
__inline static OPJ_UINT32 opj_mqc_raw_decode(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 d ;
  OPJ_BYTE *__cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;

  {
#line 77
  if (mqc->ct == 0U) {
#line 80
    if (mqc->c == 255U) {
#line 81
      if ((int )*(mqc->bp) > 143) {
#line 82
        mqc->c = (OPJ_UINT32 )255;
#line 83
        mqc->ct = (OPJ_UINT32 )8;
      } else {
#line 85
        mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 86
        (mqc->bp) ++;
#line 87
        mqc->ct = (OPJ_UINT32 )7;
      }
    } else {
#line 90
      mqc->c = (OPJ_UINT32 )*(mqc->bp);
#line 91
      (mqc->bp) ++;
#line 92
      mqc->ct = (OPJ_UINT32 )8;
    }
  }
#line 95
  __cil_tmp5 = mqc->ct;
#line 95
  (mqc->ct) --;
#line 96
  d = ((OPJ_UINT32 )mqc->c >> mqc->ct) & 1U;
#line 98
  return (d);
}
}
#line 175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc_inl.h"
__inline static void opj_mqc_bytein(opj_mqc_t *mqc ) 
{ 
  OPJ_UINT32 l_c ;
  OPJ_UINT32 __cil_tmp3 ;
  OPJ_BYTE *__cil_tmp4 ;
  OPJ_BYTE *__cil_tmp5 ;

  {
#line 177
  l_c = (OPJ_UINT32 )*(mqc->bp + 1);
#line 177
  if ((int )*(mqc->bp) == 255) {
#line 177
    if (l_c > 143U) {
#line 177
      mqc->c += (unsigned int )65280;
#line 177
      mqc->ct = (OPJ_UINT32 )8;
#line 177
      (mqc->end_of_byte_stream_counter) ++;
    } else {
#line 177
      (mqc->bp) ++;
#line 177
      mqc->c += l_c << 9;
#line 177
      mqc->ct = (OPJ_UINT32 )7;
    }
  } else {
#line 177
    (mqc->bp) ++;
#line 177
    mqc->c += l_c << 8;
#line 177
    mqc->ct = (OPJ_UINT32 )8;
  }

  return;
}
}
#line 201
void opj_mqc_byteout(opj_mqc_t *mqc ) ;
#line 112 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mqc.h"
OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc ) ;
#line 118
void opj_mqc_resetstates(opj_mqc_t *mqc ) ;
#line 126
void opj_mqc_setstate(opj_mqc_t *mqc , OPJ_UINT32 ctxno , OPJ_UINT32 msb , OPJ_INT32 prob ) ;
#line 133
void opj_mqc_init_enc(opj_mqc_t *mqc , OPJ_BYTE *bp ) ;
#line 145
void opj_mqc_flush(opj_mqc_t *mqc ) ;
#line 151
void opj_mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 158
OPJ_UINT32 opj_mqc_bypass_get_extra_bytes(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 166
void opj_mqc_bypass_enc(opj_mqc_t *mqc , OPJ_UINT32 d ) ;
#line 172
void opj_mqc_bypass_flush_enc(opj_mqc_t *mqc , OPJ_BOOL erterm ) ;
#line 177
void opj_mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 192
void opj_mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 197
void opj_mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 202
void opj_mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 222
void opj_mqc_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 243
void opj_mqc_raw_init_dec(opj_mqc_t *mqc , OPJ_BYTE *bp , OPJ_UINT32 len , OPJ_UINT32 extra_writable_bytes ) ;
#line 255
void opq_mqc_finish_dec(opj_mqc_t *mqc ) ;
#line 128 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.h"
opj_pi_iterator_t *opj_pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                            J2K_T2_MODE t2_mode , opj_event_mgr_t *manager ) ;
#line 141
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 155
void opj_pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) ;
#line 172
opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *image , opj_cp_t *cp , OPJ_UINT32 tileno ,
                                        opj_event_mgr_t *manager ) ;
#line 182
void opj_pi_destroy(opj_pi_iterator_t *p_pi , OPJ_UINT32 p_nb_elements ) ;
#line 190
OPJ_BOOL opj_pi_next(opj_pi_iterator_t *pi ) ;
#line 198
OPJ_UINT32 opj_get_encoding_packet_count(opj_image_t *p_image , opj_cp_t *p_cp , OPJ_UINT32 p_tile_no ) ;
#line 86 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tgt.h"
opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh , OPJ_UINT32 numleafsv , opj_event_mgr_t *p_manager ) ;
#line 98
opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t *p_tree , OPJ_UINT32 p_num_leafs_h , OPJ_UINT32 p_num_leafs_v ,
                             opj_event_mgr_t *p_manager ) ;
#line 105
void opj_tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 110
void opj_tgt_reset(opj_tgt_tree_t *tree ) ;
#line 117
void opj_tgt_setvalue(opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 value ) ;
#line 127
void opj_tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno , OPJ_INT32 threshold ) ;
#line 139
OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , OPJ_UINT32 leafno ,
                          OPJ_INT32 threshold ) ;
#line 322 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/tcd.h"
opj_tcd_t *opj_tcd_create(OPJ_BOOL p_is_decoder ) ;
#line 328
void opj_tcd_destroy(opj_tcd_t *tcd ) ;
#line 335
opj_tcd_marker_info_t *opj_tcd_marker_info_create(OPJ_BOOL need_PLT ) ;
#line 342
void opj_tcd_marker_info_destroy(opj_tcd_marker_info_t *p_tcd_marker_info ) ;
#line 354
OPJ_BOOL opj_tcd_init(opj_tcd_t *p_tcd , opj_image_t *p_image , opj_cp_t *p_cp , opj_thread_pool_t *p_tp ) ;
#line 369
OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 375
OPJ_UINT32 opj_tcd_get_decoded_tile_size(opj_tcd_t *p_tcd , OPJ_BOOL take_into_account_partial_decoding ) ;
#line 390
OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , OPJ_BYTE *p_dest ,
                             OPJ_UINT32 *p_data_written , OPJ_UINT32 p_len , struct opj_codestream_info *p_cstr_info ,
                             opj_tcd_marker_info_t *p_marker_info , opj_event_mgr_t *p_manager ) ;
#line 417
OPJ_BOOL opj_tcd_decode_tile(opj_tcd_t *tcd , OPJ_UINT32 win_x0 , OPJ_UINT32 win_y0 ,
                             OPJ_UINT32 win_x1 , OPJ_UINT32 win_y1 , OPJ_UINT32 numcomps_to_decode ,
                             OPJ_UINT32 *comps_indices , OPJ_BYTE *src , OPJ_UINT32 len ,
                             OPJ_UINT32 tileno , opj_codestream_index_t *cstr_info ,
                             opj_event_mgr_t *manager ) ;
#line 434
OPJ_BOOL opj_tcd_update_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_dest , OPJ_UINT32 p_dest_length ) ;
#line 443
OPJ_SIZE_T opj_tcd_get_encoder_input_buffer_size(opj_tcd_t *p_tcd ) ;
#line 454
OPJ_BOOL opj_tcd_init_encode_tile(opj_tcd_t *p_tcd , OPJ_UINT32 p_tile_no , opj_event_mgr_t *p_manager ) ;
#line 462
OPJ_BOOL opj_tcd_copy_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_src , OPJ_SIZE_T p_src_length ) ;
#line 471
OPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec ) ;
#line 477
OPJ_BOOL opj_tcd_is_band_empty(opj_tcd_band_t *band ) ;
#line 480
void opj_tcd_reinit_segment(opj_tcd_seg_t *seg ) ;
#line 497
OPJ_BOOL opj_tcd_is_subband_area_of_interest(opj_tcd_t *tcd , OPJ_UINT32 compno ,
                                             OPJ_UINT32 resno , OPJ_UINT32 bandno ,
                                             OPJ_UINT32 x0 , OPJ_UINT32 y0 , OPJ_UINT32 x1 ,
                                             OPJ_UINT32 y1 ) ;
#line 224 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t1.h"
OPJ_BOOL opj_t1_encode_cblks(opj_tcd_t *tcd , opj_tcd_tile_t *tile , opj_tcp_t *tcp ,
                             OPJ_FLOAT64 *mct_norms , OPJ_UINT32 mct_numcomps ) ;
#line 240
void opj_t1_decode_cblks(opj_tcd_t *tcd , OPJ_BOOL *pret , opj_tcd_tilecomp_t *tilec ,
                         opj_tccp_t *tccp , opj_event_mgr_t *p_manager , opj_mutex_t *p_manager_mutex ,
                         OPJ_BOOL check_pterm ) ;
#line 255
opj_t1_t *opj_t1_create(OPJ_BOOL isEncoder ) ;
#line 262
void opj_t1_destroy(opj_t1_t *p_t1 ) ;
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/dwt.h"
OPJ_BOOL opj_dwt_encode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 72
OPJ_BOOL opj_dwt_decode(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 82
OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 89
OPJ_BOOL opj_dwt_encode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec ) ;
#line 98
OPJ_BOOL opj_dwt_decode_real(opj_tcd_t *p_tcd , opj_tcd_tilecomp_t *tilec , OPJ_UINT32 numres ) ;
#line 108
OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level , OPJ_UINT32 orient ) ;
#line 114
void opj_dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , OPJ_UINT32 prec ) ;
#line 83 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/t2.h"
OPJ_BOOL opj_t2_encode_packets(opj_t2_t *t2 , OPJ_UINT32 tileno , opj_tcd_tile_t *tile ,
                               OPJ_UINT32 maxlayers , OPJ_BYTE *dest , OPJ_UINT32 *p_data_written ,
                               OPJ_UINT32 len , opj_codestream_info_t *cstr_info ,
                               opj_tcd_marker_info_t *p_marker_info , OPJ_UINT32 tpnum ,
                               OPJ_INT32 tppos , OPJ_UINT32 pino , J2K_T2_MODE t2_mode ,
                               opj_event_mgr_t *p_manager ) ;
#line 112
OPJ_BOOL opj_t2_decode_packets(opj_tcd_t *tcd , opj_t2_t *t2 , OPJ_UINT32 tileno ,
                               opj_tcd_tile_t *tile , OPJ_BYTE *src , OPJ_UINT32 *p_data_read ,
                               OPJ_UINT32 len , opj_codestream_index_t *cstr_info ,
                               opj_event_mgr_t *p_manager ) ;
#line 129
opj_t2_t *opj_t2_create(opj_image_t *p_image , opj_cp_t *p_cp ) ;
#line 135
void opj_t2_destroy(opj_t2_t *t2 ) ;
#line 63 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/mct.h"
void opj_mct_encode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 72
void opj_mct_decode(OPJ_INT32 *c0 , OPJ_INT32 *c1 , OPJ_INT32 *c2 , OPJ_SIZE_T n ) ;
#line 79
OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno ) ;
#line 88
void opj_mct_encode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) ;
#line 98
void opj_mct_decode_real(OPJ_FLOAT32 *c0 , OPJ_FLOAT32 *c1 , OPJ_FLOAT32 *c2 , OPJ_SIZE_T n ) ;
#line 105
OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno ) ;
#line 116
OPJ_BOOL opj_mct_encode_custom(OPJ_BYTE *p_coding_data , OPJ_SIZE_T n , OPJ_BYTE **p_data ,
                               OPJ_UINT32 p_nb_comp , OPJ_UINT32 is_signed ) ;
#line 131
OPJ_BOOL opj_mct_decode_custom(OPJ_BYTE *pDecodingData , OPJ_SIZE_T n , OPJ_BYTE **pData ,
                               OPJ_UINT32 pNbComp , OPJ_UINT32 isSigned ) ;
#line 144
void opj_calculate_norms(OPJ_FLOAT64 *pNorms , OPJ_UINT32 p_nb_comps , OPJ_FLOAT32 *pMatrix ) ;
#line 150
OPJ_FLOAT64 *opj_mct_get_mct_norms(void) ;
#line 154
OPJ_FLOAT64 *opj_mct_get_mct_norms_real(void) ;
#line 56 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_min(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 58
  if (a < b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 65 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_min(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 67
  if (a < b) {
#line 67
    tmp = a;
  } else {
#line 67
    tmp = b;
  }
#line 67
  return (tmp);
}
}
#line 74 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_max(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 76
  if (a > b) {
#line 76
    tmp = a;
  } else {
#line 76
    tmp = b;
  }
#line 76
  return (tmp);
}
}
#line 83 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_max(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 85
  if (a > b) {
#line 85
    tmp = a;
  } else {
#line 85
    tmp = b;
  }
#line 85
  return (tmp);
}
}
#line 92 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_adds(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT64 sum ;

  {
#line 94
  sum = (OPJ_UINT64 )a + (OPJ_UINT64 )b;
#line 95
  return ((OPJ_UINT32 )(- ((OPJ_INT32 )(sum >> 32))) | (OPJ_UINT32 )sum);
}
}
#line 102 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_subs(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 tmp ;

  {
#line 104
  if (a >= b) {
#line 104
    tmp = a - b;
  } else {
#line 104
    tmp = (unsigned int )0;
  }
#line 104
  return (tmp);
}
}
#line 116 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_clamp(OPJ_INT32 a , OPJ_INT32 min , OPJ_INT32 max ) 
{ 


  {
#line 119
  if (a < min) {
#line 120
    return (min);
  }
#line 122
  if (a > max) {
#line 123
    return (max);
  }
#line 125
  return (a);
}
}
#line 137 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT64 opj_int64_clamp(OPJ_INT64 a , OPJ_INT64 min , OPJ_INT64 max ) 
{ 


  {
#line 140
  if (a < min) {
#line 141
    return (min);
  }
#line 143
  if (a > max) {
#line 144
    return (max);
  }
#line 146
  return (a);
}
}
#line 152 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_abs(OPJ_INT32 a ) 
{ 
  OPJ_INT32 tmp ;

  {
#line 154
  if (a < 0) {
#line 154
    tmp = - a;
  } else {
#line 154
    tmp = a;
  }
#line 154
  return (tmp);
}
}
#line 160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 163
  return ((OPJ_INT32 )((((OPJ_INT64 )a + (long )b) - 1L) / (long )b));
}
}
#line 170 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildiv(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 173
  return ((OPJ_UINT32 )((((OPJ_UINT64 )a + (unsigned long )b) - 1UL) / (unsigned long )b));
}
}
#line 180 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint64_ceildiv_res_uint32(OPJ_UINT64 a , OPJ_UINT64 b ) 
{ 


  {
#line 184
  return ((OPJ_UINT32 )(((a + b) - 1UL) / b));
}
}
#line 191 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 193
  return ((OPJ_INT32 )((((long )a + (1L << b)) - 1L) >> b));
}
}
#line 200 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int64_ceildivpow2(OPJ_INT64 a , OPJ_INT32 b ) 
{ 


  {
#line 202
  return ((OPJ_INT32 )(((a + (1L << b)) - 1L) >> b));
}
}
#line 209 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_ceildivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 211
  return ((OPJ_UINT32 )((((unsigned long )a + (1UL << b)) - 1UL) >> b));
}
}
#line 218 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a , OPJ_INT32 b ) 
{ 


  {
#line 220
  return (a >> b);
}
}
#line 227 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floordivpow2(OPJ_UINT32 a , OPJ_UINT32 b ) 
{ 


  {
#line 229
  return (a >> b);
}
}
#line 236 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a ) 
{ 
  OPJ_INT32 l ;
  OPJ_INT32 __cil_tmp3 ;

  {
#line 239
  l = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (a > 1)) {
#line 239
      goto while_break;
    }
#line 240
    a >>= 1;
#line 239
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (l);
}
}
#line 248 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_UINT32 opj_uint_floorlog2(OPJ_UINT32 a ) 
{ 
  OPJ_UINT32 l ;

  {
#line 251
  l = (OPJ_UINT32 )0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (a > 1U)) {
#line 251
      goto while_break;
    }
#line 252
    a >>= 1;
#line 251
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (l);
}
}
#line 263 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 268
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 270
  temp += (long )4096;
#line 273
  return ((OPJ_INT32 )(temp >> 13));
}
}
#line 276 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_fix_mul_t1(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  OPJ_INT64 temp ;

  {
#line 281
  temp = (OPJ_INT64 )a * (OPJ_INT64 )b;
#line 283
  temp += (long )4096;
#line 287
  return ((OPJ_INT32 )(temp >> 18));
}
}
#line 297 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_add_no_overflow(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  void *pa ;
  void *pb ;
  OPJ_UINT32 *upa ;
  OPJ_UINT32 *upb ;
  OPJ_UINT32 ures ;
  void *pures ;
  OPJ_INT32 *ipres ;

  {
#line 299
  pa = & a;
#line 300
  pb = & b;
#line 301
  upa = (OPJ_UINT32 *)pa;
#line 302
  upb = (OPJ_UINT32 *)pb;
#line 303
  ures = *upa + *upb;
#line 304
  pures = & ures;
#line 305
  ipres = (OPJ_INT32 *)pures;
#line 306
  return (*ipres);
}
}
#line 316 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/opj_intmath.h"
__inline static OPJ_INT32 opj_int_sub_no_overflow(OPJ_INT32 a , OPJ_INT32 b ) 
{ 
  void *pa ;
  void *pb ;
  OPJ_UINT32 *upa ;
  OPJ_UINT32 *upb ;
  OPJ_UINT32 ures ;
  void *pures ;
  OPJ_INT32 *ipres ;

  {
#line 318
  pa = & a;
#line 319
  pb = & b;
#line 320
  upa = (OPJ_UINT32 *)pa;
#line 321
  upb = (OPJ_UINT32 *)pb;
#line 322
  ures = *upa - *upb;
#line 323
  pures = & ures;
#line 324
  ipres = (OPJ_INT32 *)pures;
#line 325
  return (*ipres);
}
}
#line 62 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/sparse_array.h"
opj_sparse_array_int32_t *opj_sparse_array_int32_create(OPJ_UINT32 width , OPJ_UINT32 height ,
                                                        OPJ_UINT32 block_width , OPJ_UINT32 block_height ) ;
#line 70
void opj_sparse_array_int32_free(opj_sparse_array_int32_t *sa ) ;
#line 80
OPJ_BOOL opj_sparse_array_is_region_valid(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                          OPJ_UINT32 y0 , OPJ_UINT32 x1 , OPJ_UINT32 y1 ) ;
#line 102
OPJ_BOOL opj_sparse_array_int32_read(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                     OPJ_UINT32 y0 , OPJ_UINT32 x1 , OPJ_UINT32 y1 ,
                                     OPJ_INT32 *dest , OPJ_UINT32 dest_col_stride ,
                                     OPJ_UINT32 dest_line_stride , OPJ_BOOL forgiving ) ;
#line 129
OPJ_BOOL opj_sparse_array_int32_write(opj_sparse_array_int32_t *sa , OPJ_UINT32 x0 ,
                                      OPJ_UINT32 y0 , OPJ_UINT32 x1 , OPJ_UINT32 y1 ,
                                      OPJ_INT32 *src , OPJ_UINT32 src_col_stride ,
                                      OPJ_UINT32 src_line_stride , OPJ_BOOL forgiving ) ;
#line 55 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 61
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 74
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 87
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) ;
#line 95
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 102
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 109
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 121
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) ;
#line 128
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 134
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) ;
#line 145
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) ;
#line 159
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 171
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 179
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) ;
#line 186
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) ;
#line 197
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) ;
#line 205
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) ;
#line 212
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) ;
#line 219
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) ;
#line 231
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 246
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 262
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) ;
#line 274
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 289
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) ;
#line 303
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) ;
#line 318
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) ;
#line 328
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) ;
#line 340
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) ;
#line 351
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) ;
#line 358
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) ;
#line 363
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) ;
#line 367
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 372
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) ;
#line 375
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) ;
#line 387
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) ;
#line 389
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) ;
#line 397
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) ;
#line 400
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 407
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) ;
#line 421
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) ;
#line 425
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) ;
#line 440
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 450
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 461
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 472
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 484
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 495
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 506
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 517
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 531
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 542
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 556
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 567
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) ;
#line 576
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 588
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 599
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 613
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) ;
#line 624
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 638
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 647
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) ;
#line 656
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 667
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 678
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) ;
#line 685
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) ;
#line 695
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 703
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) ;
#line 710
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) ;
#line 720
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 732
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 744
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) ;
#line 756
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 768
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 782
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 794
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) ;
#line 804
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 815
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) ;
#line 826
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 840
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 860
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) ;
#line 875
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 892
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) ;
#line 907
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) ;
#line 911 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_update_tlm(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_part_size ) 
{ 


  {
#line 913
  if (p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte) {
    {
#line 914
    opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                       p_j2k->m_current_tile_number, (OPJ_UINT32 )1);
#line 916
    (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current) ++;
    }
  } else {
    {
#line 918
    opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                       p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 920
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 2;
    }
  }
  {
#line 923
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,
                     p_tile_part_size, (OPJ_UINT32 )4);
#line 925
  p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
  }
  return;
}
}
#line 938
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 953
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 965
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) ;
#line 989
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) ;
#line 1000
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1011
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1021
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) ;
#line 1035
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) ;
#line 1048
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1061
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1074
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) ;
#line 1087
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1099
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1111
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1116
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) ;
#line 1119
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1121
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1123
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1125
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1128
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1130
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) ;
#line 1132
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1134
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) ;
#line 1137
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1139
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1141
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) ;
#line 1143
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) ;
#line 1153
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) ;
#line 1164
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1175
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1189
static OPJ_BOOL opj_j2k_read_cap(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1201
static OPJ_BOOL opj_j2k_read_cpf(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) ;
#line 1214
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1225
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1236
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) ;
#line 1247
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) ;
#line 1265
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager ) ;
#line 1282
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) ;
#line 1297
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) ;
#line 1303
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1305
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) ;
#line 1307
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) ;
#line 1309
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) ;
#line 1311
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) ;
#line 1313
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) ;
#line 1315
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) ;
#line 1318
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) ;
#line 1321
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                       opj_event_mgr_t *p_manager ) ;
#line 1324
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters , opj_image_t *image ,
                                         opj_event_mgr_t *p_manager ) ;
#line 1338
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) ;
#line 1352 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 1364 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 MCT_ELEMENT_SIZE[4]  = {      (OPJ_UINT32 )2,      (OPJ_UINT32 )4,      (OPJ_UINT32 )4,      (OPJ_UINT32 )8};
#line 1374 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_float[4]  = {      & opj_j2k_read_int16_to_float,      & opj_j2k_read_int32_to_float,      & opj_j2k_read_float32_to_float,      & opj_j2k_read_float64_to_float};
#line 1381 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_read_functions_to_int32[4]  = {      & opj_j2k_read_int16_to_int32,      & opj_j2k_read_int32_to_int32,      & opj_j2k_read_float32_to_int32,      & opj_j2k_read_float64_to_int32};
#line 1388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_j2k_mct_function j2k_mct_write_functions_from_float[4]  = {      & opj_j2k_write_float_to_int16,      & opj_j2k_write_float_to_int32,      & opj_j2k_write_float_to_float,      & opj_j2k_write_float_to_float64};
#line 1408 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab[23]  = 
#line 1408
  {      {(OPJ_UINT32 )65424, (OPJ_UINT32 )12, & opj_j2k_read_sot}, 
        {(OPJ_UINT32 )65362, (OPJ_UINT32 )20, & opj_j2k_read_cod}, 
        {(OPJ_UINT32 )65363, (OPJ_UINT32 )20, & opj_j2k_read_coc}, 
        {(OPJ_UINT32 )65374, (OPJ_UINT32 )20, & opj_j2k_read_rgn}, 
        {(OPJ_UINT32 )65372, (OPJ_UINT32 )20, & opj_j2k_read_qcd}, 
        {(OPJ_UINT32 )65373, (OPJ_UINT32 )20, & opj_j2k_read_qcc}, 
        {(OPJ_UINT32 )65375, (OPJ_UINT32 )20, & opj_j2k_read_poc}, 
        {(OPJ_UINT32 )65361, (OPJ_UINT32 )2, & opj_j2k_read_siz}, 
        {(OPJ_UINT32 )65365, (OPJ_UINT32 )4, & opj_j2k_read_tlm}, 
        {(OPJ_UINT32 )65367, (OPJ_UINT32 )4, & opj_j2k_read_plm}, 
        {(OPJ_UINT32 )65368, (OPJ_UINT32 )16, & opj_j2k_read_plt}, 
        {(OPJ_UINT32 )65376, (OPJ_UINT32 )4, & opj_j2k_read_ppm}, 
        {(OPJ_UINT32 )65377, (OPJ_UINT32 )16, & opj_j2k_read_ppt}, 
        {(OPJ_UINT32 )65425, (OPJ_UINT32 )0, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * ,
                                                        OPJ_UINT32  , opj_event_mgr_t * ))0}, 
        {(OPJ_UINT32 )65379,
      (OPJ_UINT32 )4, & opj_j2k_read_crg}, 
        {(OPJ_UINT32 )65380, (OPJ_UINT32 )20, & opj_j2k_read_com}, 
        {(OPJ_UINT32 )65396, (OPJ_UINT32 )20, & opj_j2k_read_mct}, 
        {(OPJ_UINT32 )65400, (OPJ_UINT32 )4, & opj_j2k_read_cbd}, 
        {(OPJ_UINT32 )65360, (OPJ_UINT32 )4, & opj_j2k_read_cap}, 
        {(OPJ_UINT32 )65369, (OPJ_UINT32 )4, & opj_j2k_read_cpf}, 
        {(OPJ_UINT32 )65397, (OPJ_UINT32 )20, & opj_j2k_read_mcc}, 
        {(OPJ_UINT32 )65399, (OPJ_UINT32 )20, & opj_j2k_read_mco}, 
        {(OPJ_UINT32 )0, (OPJ_UINT32 )20, (OPJ_BOOL (*)(opj_j2k_t * , OPJ_BYTE * , OPJ_UINT32  ,
                                                     opj_event_mgr_t * ))0}};
#line 1447 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1450
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1451
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1455
  i = (OPJ_UINT32 )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (i < p_nb_elem)) {
#line 1455
      goto while_break;
    }
    {
#line 1456
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1458
    l_src_data += sizeof(OPJ_INT16 );
#line 1460
    __cil_tmp8 = l_dest_data;
#line 1460
    l_dest_data ++;
#line 1460
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1464 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_float(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1467
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1468
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1472
  i = (OPJ_UINT32 )0;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1472
    if (! (i < p_nb_elem)) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1475
    l_src_data += sizeof(OPJ_INT32 );
#line 1477
    __cil_tmp8 = l_dest_data;
#line 1477
    l_dest_data ++;
#line 1477
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1481 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1484
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1485
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1489
  i = (OPJ_UINT32 )0;
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1489
    if (! (i < p_nb_elem)) {
#line 1489
      goto while_break;
    }
    {
#line 1490
    opj_read_float_LE(l_src_data, & l_temp);
#line 1492
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1494
    __cil_tmp8 = l_dest_data;
#line 1494
    l_dest_data ++;
#line 1494
    *__cil_tmp8 = l_temp;
    }
#line 1489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1498 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_float(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_FLOAT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1501
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1502
  l_dest_data = (OPJ_FLOAT32 *)p_dest_data;
#line 1506
  i = (OPJ_UINT32 )0;
  {
#line 1506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1506
    if (! (i < p_nb_elem)) {
#line 1506
      goto while_break;
    }
    {
#line 1507
    opj_read_double_LE(l_src_data, & l_temp);
#line 1509
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1511
    __cil_tmp8 = l_dest_data;
#line 1511
    l_dest_data ++;
#line 1511
    *__cil_tmp8 = (OPJ_FLOAT32 )l_temp;
    }
#line 1506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1515 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int16_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1518
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1519
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1523
  i = (OPJ_UINT32 )0;
  {
#line 1523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1523
    if (! (i < p_nb_elem)) {
#line 1523
      goto while_break;
    }
    {
#line 1524
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )2);
#line 1526
    l_src_data += sizeof(OPJ_INT16 );
#line 1528
    __cil_tmp8 = l_dest_data;
#line 1528
    l_dest_data ++;
#line 1528
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1532 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_int32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                        OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1535
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1536
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1540
  i = (OPJ_UINT32 )0;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1540
    if (! (i < p_nb_elem)) {
#line 1540
      goto while_break;
    }
    {
#line 1541
    opj_read_bytes_LE(l_src_data, & l_temp, (OPJ_UINT32 )4);
#line 1543
    l_src_data += sizeof(OPJ_INT32 );
#line 1545
    __cil_tmp8 = l_dest_data;
#line 1545
    l_dest_data ++;
#line 1545
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1549 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float32_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1552
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1553
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1557
  i = (OPJ_UINT32 )0;
  {
#line 1557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1557
    if (! (i < p_nb_elem)) {
#line 1557
      goto while_break;
    }
    {
#line 1558
    opj_read_float_LE(l_src_data, & l_temp);
#line 1560
    l_src_data += sizeof(OPJ_FLOAT32 );
#line 1562
    __cil_tmp8 = l_dest_data;
#line 1562
    l_dest_data ++;
#line 1562
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1566 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_read_float64_to_int32(void const   *p_src_data , void *p_dest_data ,
                                          OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_src_data ;
  OPJ_INT32 *l_dest_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_INT32 *__cil_tmp8 ;

  {
#line 1569
  l_src_data = (OPJ_BYTE *)p_src_data;
#line 1570
  l_dest_data = (OPJ_INT32 *)p_dest_data;
#line 1574
  i = (OPJ_UINT32 )0;
  {
#line 1574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    if (! (i < p_nb_elem)) {
#line 1574
      goto while_break;
    }
    {
#line 1575
    opj_read_double_LE(l_src_data, & l_temp);
#line 1577
    l_src_data += sizeof(OPJ_FLOAT64 );
#line 1579
    __cil_tmp8 = l_dest_data;
#line 1579
    l_dest_data ++;
#line 1579
    *__cil_tmp8 = (OPJ_INT32 )l_temp;
    }
#line 1574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1583 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int16(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1586
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1587
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1591
  i = (OPJ_UINT32 )0;
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1591
    if (! (i < p_nb_elem)) {
#line 1591
      goto while_break;
    }
    {
#line 1592
    __cil_tmp8 = l_src_data;
#line 1592
    l_src_data ++;
#line 1592
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1594
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT16 ));
#line 1596
    l_dest_data += sizeof(OPJ_INT16 );
    }
#line 1591
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1600 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_int32(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1603
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1604
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1608
  i = (OPJ_UINT32 )0;
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (! (i < p_nb_elem)) {
#line 1608
      goto while_break;
    }
    {
#line 1609
    __cil_tmp8 = l_src_data;
#line 1609
    l_src_data ++;
#line 1609
    l_temp = (OPJ_UINT32 )*__cil_tmp8;
#line 1611
    opj_write_bytes_LE(l_dest_data, l_temp, (OPJ_UINT32 )sizeof(OPJ_INT32 ));
#line 1613
    l_dest_data += sizeof(OPJ_INT32 );
    }
#line 1608
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1617 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float(void const   *p_src_data , void *p_dest_data ,
                                         OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT32 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1620
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1621
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1625
  i = (OPJ_UINT32 )0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (i < p_nb_elem)) {
#line 1625
      goto while_break;
    }
    {
#line 1626
    __cil_tmp8 = l_src_data;
#line 1626
    l_src_data ++;
#line 1626
    l_temp = (OPJ_FLOAT32 )*__cil_tmp8;
#line 1628
    opj_write_float_LE(l_dest_data, l_temp);
#line 1630
    l_dest_data += sizeof(OPJ_FLOAT32 );
    }
#line 1625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1634 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_float_to_float64(void const   *p_src_data , void *p_dest_data ,
                                           OPJ_UINT32 p_nb_elem ) 
{ 
  OPJ_BYTE *l_dest_data ;
  OPJ_FLOAT32 *l_src_data ;
  OPJ_UINT32 i ;
  OPJ_FLOAT64 l_temp ;
  OPJ_FLOAT32 *__cil_tmp8 ;

  {
#line 1637
  l_dest_data = (OPJ_BYTE *)p_dest_data;
#line 1638
  l_src_data = (OPJ_FLOAT32 *)p_src_data;
#line 1642
  i = (OPJ_UINT32 )0;
  {
#line 1642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1642
    if (! (i < p_nb_elem)) {
#line 1642
      goto while_break;
    }
    {
#line 1643
    __cil_tmp8 = l_src_data;
#line 1643
    l_src_data ++;
#line 1643
    l_temp = (OPJ_FLOAT64 )*__cil_tmp8;
#line 1645
    opj_write_double_LE(l_dest_data, l_temp);
#line 1647
    l_dest_data += sizeof(OPJ_FLOAT64 );
    }
#line 1642
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1651 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
char const   *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 1654
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! ((int )po->enum_prog != -1)) {
#line 1654
      goto while_break;
    }
#line 1655
    if ((int )po->enum_prog == (int )prg_order) {
#line 1656
      return ((char const   *)po->str_prog);
    }
#line 1654
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1659
  return ((char const   *)po->str_prog);
}
}
#line 1662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_check_poc_val(opj_poc_t *p_pocs , OPJ_UINT32 tileno , OPJ_UINT32 p_nb_pocs ,
                                      OPJ_UINT32 p_nb_resolutions , OPJ_UINT32 p_num_comps ,
                                      OPJ_UINT32 p_num_layers , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 *packet_array ;
  OPJ_UINT32 index ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 layno ;
  OPJ_UINT32 i ;
  OPJ_UINT32 step_c ;
  OPJ_UINT32 step_r ;
  OPJ_UINT32 step_l ;
  OPJ_BOOL loss ;
  void *__cil_tmp18 ;
  opj_poc_t *poc ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 res_index ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 layno0 ;
  OPJ_UINT32 comp_index ;
  OPJ_UINT32 __cil_tmp25 ;

  {
  {
#line 1673
  step_c = (OPJ_UINT32 )1;
#line 1674
  step_r = p_num_comps * step_c;
#line 1675
  step_l = p_nb_resolutions * step_r;
#line 1676
  loss = 0;
#line 1680
  __cil_tmp18 = opj_calloc((size_t )step_l * (unsigned long )p_num_layers, sizeof(OPJ_UINT32 ));
#line 1680
  packet_array = (OPJ_UINT32 *)__cil_tmp18;
  }
#line 1682
  if (packet_array == (OPJ_UINT32 *)0) {
    {
#line 1683
    opj_event_msg(p_manager, 1, "Not enough memory for checking the poc values.\n");
    }
#line 1685
    return (0);
  }
#line 1689
  i = (OPJ_UINT32 )0;
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (! (i < p_nb_pocs)) {
#line 1689
      goto while_break;
    }
#line 1690
    poc = p_pocs + i;
#line 1691
    if (tileno + 1U == poc->tile) {
#line 1692
      index = step_r * poc->resno0;
#line 1695
      resno = poc->resno0;
      {
#line 1695
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1695
        if (! (resno < __cil_tmp20)) {
#line 1695
          goto while_break___0;
        }
#line 1697
        res_index = index + poc->compno0 * step_c;
#line 1700
        compno = poc->compno0;
        {
#line 1700
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1700
          if (! (compno < __cil_tmp22)) {
#line 1700
            goto while_break___1;
          }
#line 1703
          layno0 = (OPJ_UINT32 )0;
#line 1704
          comp_index = res_index + layno0 * step_l;
#line 1707
          layno = layno0;
          {
#line 1707
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1707
            if (! (layno < __cil_tmp25)) {
#line 1707
              goto while_break___2;
            }
#line 1709
            *(packet_array + comp_index) = (OPJ_UINT32 )1;
#line 1710
            comp_index += step_l;
#line 1708
            layno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1713
          res_index += step_c;
#line 1701
          compno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1716
        index += step_r;
#line 1696
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1689
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1721
  index = (OPJ_UINT32 )0;
#line 1722
  layno = (OPJ_UINT32 )0;
  {
#line 1722
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1722
    if (! (layno < p_num_layers)) {
#line 1722
      goto while_break___3;
    }
#line 1723
    resno = (OPJ_UINT32 )0;
    {
#line 1723
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1723
      if (! (resno < p_nb_resolutions)) {
#line 1723
        goto while_break___4;
      }
#line 1724
      compno = (OPJ_UINT32 )0;
      {
#line 1724
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1724
        if (! (compno < p_num_comps)) {
#line 1724
          goto while_break___5;
        }
#line 1725
        loss |= *(packet_array + index) != 1U;
#line 1733
        index += step_c;
#line 1724
        compno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1723
      resno ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1722
    layno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1738
  if (loss) {
    {
#line 1739
    opj_event_msg(p_manager, 1, "Missing packets possible loss of data\n");
    }
  }
  {
#line 1742
  opj_free(packet_array);
  }
#line 1744
  return (! loss);
}
}
#line 1749 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp , OPJ_UINT32 pino , OPJ_UINT32 tileno ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 tpnum ;
  opj_tcp_t *tcp ;
  opj_poc_t *l_current_poc ;
  char const   *__cil_tmp9 ;

  {
  {
#line 1752
  prog = (OPJ_CHAR *)0;
#line 1754
  tpnum = (OPJ_UINT32 )1;
#line 1755
  tcp = (opj_tcp_t *)0;
#line 1756
  l_current_poc = (opj_poc_t *)0;
#line 1763
  tcp = cp->tcps + tileno;
#line 1766
  l_current_poc = & tcp->pocs[pino];
#line 1770
  prog = (OPJ_CHAR *)opj_j2k_convert_progression_order(tcp->prg);
  }
#line 1773
  if ((int )cp->m_specific_param.m_enc.m_tp_on == 1) {
#line 1774
    i = 0;
    {
#line 1774
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1774
      if (! (i < 4)) {
#line 1774
        goto while_break;
      }
      {
#line 1777
      if ((int )*(prog + i) == 'C') {
#line 1777
        goto case_67;
      }
#line 1781
      if ((int )*(prog + i) == 'R') {
#line 1781
        goto case_82;
      }
#line 1785
      if ((int )*(prog + i) == 'P') {
#line 1785
        goto case_80;
      }
#line 1789
      if ((int )*(prog + i) == 'L') {
#line 1789
        goto case_76;
      }
#line 1775
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1778
      tpnum *= l_current_poc->compE;
#line 1779
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1782
      tpnum *= l_current_poc->resE;
#line 1783
      goto switch_break;
      case_80: /* CIL Label */ 
#line 1786
      tpnum *= l_current_poc->prcE;
#line 1787
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1790
      tpnum *= l_current_poc->layE;
#line 1791
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1794
      if ((int )cp->m_specific_param.m_enc.m_tp_flag == (int )*(prog + i)) {
#line 1795
        cp->m_specific_param.m_enc.m_tp_pos = i;
#line 1796
        goto while_break;
      }
#line 1774
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1800
    tpnum = (OPJ_UINT32 )1;
  }
#line 1803
  return (tpnum);
}
}
#line 1806 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_calculate_tp(opj_j2k_t *p_j2k , opj_cp_t *cp , OPJ_UINT32 *p_nb_tiles ,
                                     opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *tcp ;
  OPJ_UINT32 cur_totnum_tp ;
  OPJ_UINT32 tp_num ;
  OPJ_UINT32 __cil_tmp12 ;

  {
#line 1827
  l_nb_tiles = cp->tw * cp->th;
#line 1828
  *p_nb_tiles = (OPJ_UINT32 )0;
#line 1829
  tcp = cp->tcps;
#line 1866
  tileno = (OPJ_UINT32 )0;
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (! (tileno < l_nb_tiles)) {
#line 1866
      goto while_break;
    }
    {
#line 1867
    cur_totnum_tp = (OPJ_UINT32 )0;
#line 1869
    opj_pi_update_encoding_parameters(image, cp, tileno);
#line 1871
    pino = (OPJ_UINT32 )0;
    }
    {
#line 1871
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1871
      if (! (pino <= tcp->numpocs)) {
#line 1871
        goto while_break___0;
      }
      {
#line 1872
      __cil_tmp12 = opj_j2k_get_num_tp(cp, pino, tileno);
#line 1872
      tp_num = __cil_tmp12;
#line 1874
      *p_nb_tiles += tp_num;
#line 1876
      cur_totnum_tp += tp_num;
      }
#line 1871
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1878
    tcp->m_nb_tile_parts = cur_totnum_tp;
#line 1880
    tcp ++;
#line 1866
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1884
  return (1);
}
}
#line 1887 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_start_stream ;
  OPJ_SIZE_T __cil_tmp5 ;

  {
  {
#line 1892
  l_start_stream = (OPJ_BYTE *)0;
#line 1899
  l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 1902
  opj_write_bytes_LE(l_start_stream, (OPJ_UINT32 )65359, (OPJ_UINT32 )2);
#line 1904
  __cil_tmp5 = opj_stream_write_data(p_stream, l_start_stream, (OPJ_SIZE_T )2, p_manager);
  }
#line 1904
  if (__cil_tmp5 != 2UL) {
#line 1905
    return (0);
  }
#line 1918
  return (1);
}
}
#line 1927 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_soc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_data[2] ;
  OPJ_UINT32 l_marker ;
  OPJ_SIZE_T __cil_tmp6 ;
  OPJ_OFF_T __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;

  {
  {
#line 1940
  __cil_tmp6 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                    p_manager);
  }
#line 1940
  if (__cil_tmp6 != 2UL) {
#line 1941
    return (0);
  }
  {
#line 1944
  opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_marker, (OPJ_UINT32 )2);
  }
#line 1945
  if (l_marker != 65359U) {
#line 1946
    return (0);
  }
  {
#line 1950
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )2;
#line 1953
  __cil_tmp7 = opj_stream_tell(p_stream);
#line 1953
  (p_j2k->cstr_index)->main_head_start = __cil_tmp7 - 2L;
#line 1955
  opj_event_msg(p_manager, 4, "Start to read j2k main header (%ld).\n", (p_j2k->cstr_index)->main_head_start);
#line 1960
  __cil_tmp8 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )65359, (p_j2k->cstr_index)->main_head_start,
                                    (OPJ_UINT32 )2);
  }
#line 1960
  if (0 == __cil_tmp8) {
    {
#line 1962
    opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n\t\265U");
    }
#line 1963
    return (0);
  }
#line 1965
  return (1);
}
}
#line 1968 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_siz(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_size_len ;
  OPJ_BYTE *l_current_ptr ;
  opj_image_t *l_image ;
  opj_cp_t *cp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 1975
  l_image = (opj_image_t *)0;
#line 1976
  cp = (opj_cp_t *)0;
#line 1977
  l_img_comp = (opj_image_comp_t *)0;
#line 1984
  l_image = p_j2k->m_private_image;
#line 1985
  cp = & p_j2k->m_cp;
#line 1986
  l_size_len = 40U + 3U * l_image->numcomps;
#line 1987
  l_img_comp = l_image->comps;
#line 1989
  if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 1991
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_size_len);
#line 1991
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 1993
    if (! new_header_tile_data) {
      {
#line 1994
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 1995
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 1996
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 1997
      opj_event_msg(p_manager, 1, "Not enough memory for the SIZ marker\n");
      }
#line 1998
      return (0);
    }
#line 2000
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2001
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
  }
  {
#line 2004
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2007
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65361, (OPJ_UINT32 )2);
#line 2008
  l_current_ptr += 2;
#line 2010
  opj_write_bytes_LE(l_current_ptr, l_size_len - 2U, (OPJ_UINT32 )2);
#line 2011
  l_current_ptr += 2;
#line 2013
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )cp->rsiz, (OPJ_UINT32 )2);
#line 2014
  l_current_ptr += 2;
#line 2016
  opj_write_bytes_LE(l_current_ptr, l_image->x1, (OPJ_UINT32 )4);
#line 2017
  l_current_ptr += 4;
#line 2019
  opj_write_bytes_LE(l_current_ptr, l_image->y1, (OPJ_UINT32 )4);
#line 2020
  l_current_ptr += 4;
#line 2022
  opj_write_bytes_LE(l_current_ptr, l_image->x0, (OPJ_UINT32 )4);
#line 2023
  l_current_ptr += 4;
#line 2025
  opj_write_bytes_LE(l_current_ptr, l_image->y0, (OPJ_UINT32 )4);
#line 2026
  l_current_ptr += 4;
#line 2028
  opj_write_bytes_LE(l_current_ptr, cp->tdx, (OPJ_UINT32 )4);
#line 2029
  l_current_ptr += 4;
#line 2031
  opj_write_bytes_LE(l_current_ptr, cp->tdy, (OPJ_UINT32 )4);
#line 2032
  l_current_ptr += 4;
#line 2034
  opj_write_bytes_LE(l_current_ptr, cp->tx0, (OPJ_UINT32 )4);
#line 2035
  l_current_ptr += 4;
#line 2037
  opj_write_bytes_LE(l_current_ptr, cp->ty0, (OPJ_UINT32 )4);
#line 2038
  l_current_ptr += 4;
#line 2040
  opj_write_bytes_LE(l_current_ptr, l_image->numcomps, (OPJ_UINT32 )2);
#line 2041
  l_current_ptr += 2;
#line 2043
  i = (OPJ_UINT32 )0;
  }
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! (i < l_image->numcomps)) {
#line 2043
      goto while_break;
    }
    {
#line 2045
    opj_write_bytes_LE(l_current_ptr, (l_img_comp->prec - 1U) + (l_img_comp->sgnd << 7),
                       (OPJ_UINT32 )1);
#line 2047
    l_current_ptr ++;
#line 2049
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dx, (OPJ_UINT32 )1);
#line 2050
    l_current_ptr ++;
#line 2052
    opj_write_bytes_LE(l_current_ptr, l_img_comp->dy, (OPJ_UINT32 )1);
#line 2053
    l_current_ptr ++;
#line 2055
    l_img_comp ++;
    }
#line 2043
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2058
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_size_len, p_manager);
  }
#line 2058
  if (__cil_tmp12 != (unsigned long )l_size_len) {
#line 2061
    return (0);
  }
#line 2064
  return (1);
}
}
#line 2074 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_comp_remain ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_prec0 ;
  OPJ_UINT32 l_sgnd0 ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_image_comp_t *l_img_comp ;
  opj_tcp_t *l_current_tile_param ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_UINT32 siz_w ;
  OPJ_UINT32 siz_h ;
  void *__cil_tmp23 ;
  OPJ_UINT32 tmp ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 2087
  l_image = (opj_image_t *)0;
#line 2088
  l_cp = (opj_cp_t *)0;
#line 2089
  l_img_comp = (opj_image_comp_t *)0;
#line 2090
  l_current_tile_param = (opj_tcp_t *)0;
#line 2097
  l_image = p_j2k->m_private_image;
#line 2098
  l_cp = & p_j2k->m_cp;
#line 2101
  if (p_header_size < 36U) {
    {
#line 2102
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 2103
    return (0);
  }
#line 2106
  l_remaining_size = p_header_size - 36U;
#line 2107
  l_nb_comp = l_remaining_size / 3U;
#line 2108
  l_nb_comp_remain = l_remaining_size % 3U;
#line 2109
  if (l_nb_comp_remain != 0U) {
    {
#line 2110
    opj_event_msg(p_manager, 1, "Error with SIZ marker size\n");
    }
#line 2111
    return (0);
  }
  {
#line 2114
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 2116
  p_header_data += 2;
#line 2117
  l_cp->rsiz = (OPJ_UINT16 )l_tmp;
#line 2118
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x1), (OPJ_UINT32 )4);
#line 2119
  p_header_data += 4;
#line 2120
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y1), (OPJ_UINT32 )4);
#line 2121
  p_header_data += 4;
#line 2122
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->x0), (OPJ_UINT32 )4);
#line 2123
  p_header_data += 4;
#line 2124
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_image->y0), (OPJ_UINT32 )4);
#line 2125
  p_header_data += 4;
#line 2126
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdx), (OPJ_UINT32 )4);
#line 2128
  p_header_data += 4;
#line 2129
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tdy), (OPJ_UINT32 )4);
#line 2131
  p_header_data += 4;
#line 2132
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->tx0), (OPJ_UINT32 )4);
#line 2134
  p_header_data += 4;
#line 2135
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_cp->ty0), (OPJ_UINT32 )4);
#line 2137
  p_header_data += 4;
#line 2138
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& l_tmp), (OPJ_UINT32 )2);
#line 2140
  p_header_data += 2;
  }
#line 2141
  if (l_tmp < 16385U) {
#line 2142
    l_image->numcomps = (OPJ_UINT32 )((OPJ_UINT16 )l_tmp);
  } else {
    {
#line 2144
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is illegal -> %d\n",
                  l_tmp);
    }
#line 2146
    return (0);
  }
#line 2149
  if (l_image->numcomps != l_nb_comp) {
    {
#line 2150
    opj_event_msg(p_manager, 1, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n",
                  l_image->numcomps, l_nb_comp);
    }
#line 2153
    return (0);
  }
#line 2158
  if (l_image->x0 >= l_image->x1) {
    {
    {
#line 2159
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
    }
#line 2163
    return (0);
  } else
#line 2158
  if (l_image->y0 >= l_image->y1) {
    {
    {
#line 2159
    opj_event_msg(p_manager, 1, "Error with SIZ marker: negative or zero image size (%ld x %ld)\n",
                  (OPJ_INT64 )l_image->x1 - (long )l_image->x0, (OPJ_INT64 )l_image->y1 - (long )l_image->y0);
    }
    }
#line 2163
    return (0);
  }
#line 2166
  if (l_cp->tdx == 0U) {
    {
    {
#line 2167
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
    }
#line 2170
    return (0);
  } else
#line 2166
  if (l_cp->tdy == 0U) {
    {
    {
#line 2167
    opj_event_msg(p_manager, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  l_cp->tdx, l_cp->tdy);
    }
    }
#line 2170
    return (0);
  }
  {
#line 2174
  l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx);
#line 2175
  l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy);
  }
#line 2176
  if (l_cp->tx0 > l_image->x0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_cp->ty0 > l_image->y0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_tx1 <= l_image->x0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  } else
#line 2176
  if (l_ty1 <= l_image->y0) {
    {
    {
    {
    {
#line 2178
    opj_event_msg(p_manager, 1, "Error with SIZ marker: illegal tile offset\n");
    }
    }
    }
    }
#line 2180
    return (0);
  }
#line 2182
  if (! p_j2k->dump_state) {
#line 2185
    siz_w = l_image->x1 - l_image->x0;
#line 2186
    siz_h = l_image->y1 - l_image->y0;
#line 2188
    if (p_j2k->ihdr_w > 0U) {
#line 2188
      if (p_j2k->ihdr_h > 0U) {
#line 2188
        if (p_j2k->ihdr_w != siz_w) {
          {
          {
#line 2190
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
          }
#line 2193
          return (0);
        } else
#line 2188
        if (p_j2k->ihdr_h != siz_h) {
          {
          {
#line 2190
          opj_event_msg(p_manager, 1, "Error with SIZ marker: IHDR w(%u) h(%u) vs. SIZ w(%u) h(%u)\n",
                        p_j2k->ihdr_w, p_j2k->ihdr_h, siz_w, siz_h);
          }
          }
#line 2193
          return (0);
        }
      }
    }
  }
  {
#line 2239
  __cil_tmp23 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_image_comp_t ));
#line 2239
  l_image->comps = (opj_image_comp_t *)__cil_tmp23;
  }
#line 2241
  if (l_image->comps == (opj_image_comp_t *)0) {
    {
#line 2242
    l_image->numcomps = (OPJ_UINT32 )0;
#line 2243
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2245
    return (0);
  }
#line 2248
  l_img_comp = l_image->comps;
#line 2250
  l_prec0 = (OPJ_UINT32 )0;
#line 2251
  l_sgnd0 = (OPJ_UINT32 )0;
#line 2253
  i = (OPJ_UINT32 )0;
  {
#line 2253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2253
    if (! (i < l_image->numcomps)) {
#line 2253
      goto while_break;
    }
    {
#line 2255
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2256
    p_header_data ++;
#line 2257
    l_img_comp->prec = (tmp & 127U) + 1U;
#line 2258
    l_img_comp->sgnd = tmp >> 7;
    }
#line 2260
    if (p_j2k->dump_state == 0U) {
#line 2261
      if (i == 0U) {
#line 2262
        l_prec0 = l_img_comp->prec;
#line 2263
        l_sgnd0 = l_img_comp->sgnd;
      } else
#line 2264
      if (! l_cp->allow_different_bit_depth_sign) {
#line 2264
        if (l_img_comp->prec != l_prec0) {
          {
          {
#line 2266
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
          }
        } else
#line 2264
        if (l_img_comp->sgnd != l_sgnd0) {
          {
          {
#line 2266
          opj_event_msg(p_manager, 2, "Despite JP2 BPC!=255, precision and/or sgnd values for comp[%d] is different than comp[0]:\n        [0] prec(%d) sgnd(%d) [%d] prec(%d) sgnd(%d)\n",
                        i, l_prec0, l_sgnd0, i, l_img_comp->prec, l_img_comp->sgnd);
          }
          }
        }
      }
    }
    {
#line 2273
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2274
    p_header_data ++;
#line 2275
    l_img_comp->dx = (OPJ_UINT32 )tmp;
#line 2276
    opj_read_bytes_LE(p_header_data, & tmp, (OPJ_UINT32 )1);
#line 2277
    p_header_data ++;
#line 2278
    l_img_comp->dy = (OPJ_UINT32 )tmp;
    }
#line 2279
    if (l_img_comp->dx < 1U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dx > 255U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dy < 1U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    } else
#line 2279
    if (l_img_comp->dy > 255U) {
      {
      {
      {
      {
#line 2281
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\n\230\001",
                    i, l_img_comp->dx, l_img_comp->dy);
      }
      }
      }
      }
#line 2284
      return (0);
    }
#line 2289
    if (l_img_comp->prec > 31U) {
      {
#line 2290
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_img_comp->prec);
      }
#line 2293
      return (0);
    }
#line 2324
    l_img_comp->resno_decoded = (OPJ_UINT32 )0;
#line 2326
    l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce;
#line 2328
    l_img_comp ++;
#line 2253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2331
  if (l_cp->tdx == 0U) {
#line 2332
    return (0);
  } else
#line 2331
  if (l_cp->tdy == 0U) {
#line 2332
    return (0);
  }
  {
#line 2336
  __cil_tmp25 = opj_int_ceildiv((OPJ_INT32 )(l_image->x1 - l_cp->tx0), (OPJ_INT32 )l_cp->tdx);
#line 2336
  l_cp->tw = (OPJ_UINT32 )__cil_tmp25;
#line 2338
  __cil_tmp26 = opj_int_ceildiv((OPJ_INT32 )(l_image->y1 - l_cp->ty0), (OPJ_INT32 )l_cp->tdy);
#line 2338
  l_cp->th = (OPJ_UINT32 )__cil_tmp26;
  }
#line 2342
  if (l_cp->tw == 0U) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  } else
#line 2342
  if (l_cp->th == 0U) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  } else
#line 2342
  if (l_cp->tw > 65535U / l_cp->th) {
    {
    {
    {
#line 2343
    opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
                  l_cp->tw, l_cp->th);
    }
    }
    }
#line 2346
    return (0);
  }
#line 2348
  l_nb_tiles = l_cp->tw * l_cp->th;
#line 2351
  if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
    {
#line 2352
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
#line 2354
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
#line 2356
    __cil_tmp27 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0),
                                  (OPJ_INT32 )l_cp->tdx);
#line 2356
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp27;
#line 2359
    __cil_tmp28 = opj_int_ceildiv((OPJ_INT32 )(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0),
                                  (OPJ_INT32 )l_cp->tdy);
#line 2359
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp28;
    }
  } else {
#line 2363
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 2364
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 2365
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 2366
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
  }
  {
#line 2415
  __cil_tmp29 = opj_calloc((size_t )l_nb_tiles, sizeof(opj_tcp_t ));
#line 2415
  l_cp->tcps = (opj_tcp_t *)__cil_tmp29;
  }
#line 2416
  if (l_cp->tcps == (opj_tcp_t *)0) {
    {
#line 2417
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2419
    return (0);
  }
  {
#line 2435
  __cil_tmp30 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2435
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps = (opj_tccp_t *)__cil_tmp30;
  }
#line 2437
  if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps == (opj_tccp_t *)0) {
    {
#line 2438
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2440
    return (0);
  }
  {
#line 2443
  __cil_tmp31 = opj_calloc((size_t )10, sizeof(opj_mct_data_t ));
#line 2443
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records = (opj_mct_data_t *)__cil_tmp31;
  }
#line 2447
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mct_records) {
    {
#line 2448
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2450
    return (0);
  }
  {
#line 2452
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mct_records = (OPJ_UINT32 )10;
#line 2455
  __cil_tmp32 = opj_calloc((size_t )10, sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 2455
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp32;
  }
#line 2460
  if (! (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_mcc_records) {
    {
#line 2461
    opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
    }
#line 2463
    return (0);
  }
#line 2465
  (p_j2k->m_specific_param.m_decoder.m_default_tcp)->m_nb_max_mcc_records = (OPJ_UINT32 )10;
#line 2469
  i = (OPJ_UINT32 )0;
  {
#line 2469
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2469
    if (! (i < l_image->numcomps)) {
#line 2469
      goto while_break___0;
    }
#line 2470
    if (! (l_image->comps + i)->sgnd) {
#line 2471
      ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + i)->m_dc_level_shift = 1 << ((l_image->comps + i)->prec - 1U);
    }
#line 2469
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2476
  l_current_tile_param = l_cp->tcps;
#line 2477
  i = (OPJ_UINT32 )0;
  {
#line 2477
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2477
    if (! (i < l_nb_tiles)) {
#line 2477
      goto while_break___1;
    }
    {
#line 2478
    __cil_tmp33 = opj_calloc((size_t )l_image->numcomps, sizeof(opj_tccp_t ));
#line 2478
    l_current_tile_param->tccps = (opj_tccp_t *)__cil_tmp33;
    }
#line 2480
    if (l_current_tile_param->tccps == (opj_tccp_t *)0) {
      {
#line 2481
      opj_event_msg(p_manager, 1, "Not enough memory to take in charge SIZ marker\n");
      }
#line 2483
      return (0);
    }
#line 2486
    l_current_tile_param ++;
#line 2477
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2489
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )4;
#line 2490
  opj_image_comp_header_update(l_image, l_cp);
  }
#line 2492
  return (1);
}
}
#line 2495 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_com(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_comment_size ;
  OPJ_UINT32 l_total_com_size ;
  OPJ_CHAR *l_comment ;
  OPJ_BYTE *l_current_ptr ;
  unsigned long __cil_tmp8 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 2503
  l_current_ptr = (OPJ_BYTE *)0;
#line 2510
  l_comment = p_j2k->m_cp.comment;
#line 2511
  __cil_tmp8 = strlen(l_comment);
#line 2511
  l_comment_size = (OPJ_UINT32 )__cil_tmp8;
#line 2512
  l_total_com_size = l_comment_size + 6U;
  }
#line 2514
  if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2516
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_total_com_size);
#line 2516
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 2518
    if (! new_header_tile_data) {
      {
#line 2519
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2520
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2521
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2522
      opj_event_msg(p_manager, 1, "Not enough memory to write the COM marker\nH\t\265U");
      }
#line 2524
      return (0);
    }
#line 2526
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2527
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
  }
  {
#line 2530
  l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2532
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )65380, (OPJ_UINT32 )2);
#line 2533
  l_current_ptr += 2;
#line 2535
  opj_write_bytes_LE(l_current_ptr, l_total_com_size - 2U, (OPJ_UINT32 )2);
#line 2536
  l_current_ptr += 2;
#line 2538
  opj_write_bytes_LE(l_current_ptr, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 2540
  l_current_ptr += 2;
#line 2542
  memcpy(l_current_ptr, l_comment, (unsigned long )l_comment_size);
#line 2544
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_total_com_size, p_manager);
  }
#line 2544
  if (__cil_tmp11 != (unsigned long )l_total_com_size) {
#line 2547
    return (0);
  }
#line 2550
  return (1);
}
}
#line 2560 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_com(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 2576
  return (1);
}
}
#line 2579 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_code_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
  {
#line 2583
  l_cp = (opj_cp_t *)0;
#line 2584
  l_tcp = (opj_tcp_t *)0;
#line 2586
  l_current_data = (OPJ_BYTE *)0;
#line 2593
  l_cp = & p_j2k->m_cp;
#line 2594
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2595
  __cil_tmp9 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 2595
  l_code_size = 9U + __cil_tmp9;
#line 2597
  l_remaining_size = l_code_size;
  }
#line 2599
  if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2600
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_code_size);
#line 2600
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 2602
    if (! new_header_tile_data) {
      {
#line 2603
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2604
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2605
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2606
      opj_event_msg(p_manager, 1, "Not enough memory to write COD marker\n");
      }
#line 2607
      return (0);
    }
#line 2609
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2610
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
  }
  {
#line 2613
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 2615
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65362, (OPJ_UINT32 )2);
#line 2616
  l_current_data += 2;
#line 2618
  opj_write_bytes_LE(l_current_data, l_code_size - 2U, (OPJ_UINT32 )2);
#line 2619
  l_current_data += 2;
#line 2621
  opj_write_bytes_LE(l_current_data, l_tcp->csty, (OPJ_UINT32 )1);
#line 2622
  l_current_data ++;
#line 2624
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tcp->prg, (OPJ_UINT32 )1);
#line 2625
  l_current_data ++;
#line 2627
  opj_write_bytes_LE(l_current_data, l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2628
  l_current_data += 2;
#line 2630
  opj_write_bytes_LE(l_current_data, l_tcp->mct, (OPJ_UINT32 )1);
#line 2631
  l_current_data ++;
#line 2633
  l_remaining_size -= (unsigned int )9;
#line 2635
  __cil_tmp12 = opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                          l_current_data, & l_remaining_size, p_manager);
  }
#line 2635
  if (! __cil_tmp12) {
    {
#line 2637
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2638
    return (0);
  }
#line 2641
  if (l_remaining_size != 0U) {
    {
#line 2642
    opj_event_msg(p_manager, 1, "Error writing COD marker\n");
    }
#line 2643
    return (0);
  }
  {
#line 2646
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_code_size, p_manager);
  }
#line 2646
  if (__cil_tmp13 != (unsigned long )l_code_size) {
#line 2649
    return (0);
  }
#line 2652
  return (1);
}
}
#line 2662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cod(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp ;
  OPJ_BOOL __cil_tmp11 ;

  {
#line 2671
  l_cp = (opj_cp_t *)0;
#line 2672
  l_tcp = (opj_tcp_t *)0;
#line 2673
  l_image = (opj_image_t *)0;
#line 2680
  l_image = p_j2k->m_private_image;
#line 2681
  l_cp = & p_j2k->m_cp;
#line 2684
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2684
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2684
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2684
  l_tcp = tmp;
#line 2699
  l_tcp->cod = (OPJ_BITFIELD )1;
#line 2702
  if (p_header_size < 5U) {
    {
#line 2703
    opj_event_msg(p_manager, 1, "Error reading COD marker\n`H\t\265U");
    }
#line 2704
    return (0);
  }
  {
#line 2707
  opj_read_bytes_LE(p_header_data, & l_tcp->csty, (OPJ_UINT32 )1);
#line 2708
  p_header_data ++;
  }
#line 2710
  if ((l_tcp->csty & 4294967288U) != 0U) {
    {
#line 2712
    opj_event_msg(p_manager, 1, "Unknown Scod value in COD marker\n\237G\t\265U");
    }
#line 2713
    return (0);
  }
  {
#line 2715
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 2716
  p_header_data ++;
#line 2717
  l_tcp->prg = (OPJ_PROG_ORDER )l_tmp;
  }
#line 2719
  if ((int )l_tcp->prg > 4) {
    {
#line 2720
    opj_event_msg(p_manager, 1, "Unknown progression order in COD marker\n\220");
#line 2722
    l_tcp->prg = (OPJ_PROG_ORDER )-1;
    }
  }
  {
#line 2724
  opj_read_bytes_LE(p_header_data, & l_tcp->numlayers, (OPJ_UINT32 )2);
#line 2725
  p_header_data += 2;
  }
#line 2727
  if (l_tcp->numlayers < 1U) {
    {
    {
#line 2728
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp->numlayers);
    }
    }
#line 2731
    return (0);
  } else
#line 2727
  if (l_tcp->numlayers > 65535U) {
    {
    {
#line 2728
    opj_event_msg(p_manager, 1, "Invalid number of layers in COD marker : %d not in range [1-65535]\n",
                  l_tcp->numlayers);
    }
    }
#line 2731
    return (0);
  }
#line 2735
  if (l_cp->m_specific_param.m_dec.m_layer) {
#line 2736
    l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
  } else {
#line 2738
    l_tcp->num_layers_to_decode = l_tcp->numlayers;
  }
  {
#line 2741
  opj_read_bytes_LE(p_header_data, & l_tcp->mct, (OPJ_UINT32 )1);
#line 2742
  p_header_data ++;
  }
#line 2744
  if (l_tcp->mct > 1U) {
    {
#line 2745
    opj_event_msg(p_manager, 1, "Invalid multiple component transformation\nH\t\265U");
    }
#line 2747
    return (0);
  }
#line 2750
  p_header_size -= (unsigned int )5;
#line 2751
  i = (OPJ_UINT32 )0;
  {
#line 2751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2751
    if (! (i < l_image->numcomps)) {
#line 2751
      goto while_break;
    }
#line 2752
    (l_tcp->tccps + i)->csty = l_tcp->csty & 1U;
#line 2751
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2755
  __cil_tmp11 = opj_j2k_read_SPCod_SPCoc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2755
  if (! __cil_tmp11) {
    {
#line 2757
    opj_event_msg(p_manager, 1, "Error reading COD marker\n\214G\t\265U");
    }
#line 2758
    return (0);
  }
#line 2761
  if (p_header_size != 0U) {
    {
#line 2762
    opj_event_msg(p_manager, 1, "Error reading COD marker\n");
    }
#line 2763
    return (0);
  }
  {
#line 2767
  opj_j2k_copy_tile_component_parameters(p_j2k);
  }
#line 2786
  return (1);
}
}
#line 2789 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 l_comp_room ;
  int tmp ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 2802
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 2802
    tmp = 1;
  } else {
#line 2802
    tmp = 2;
  }
  {
#line 2802
  l_comp_room = (OPJ_UINT32 )tmp;
#line 2804
  __cil_tmp9 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 2804
  l_coc_size = (5U + l_comp_room) + __cil_tmp9;
  }
#line 2807
  if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 2814
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_coc_size);
#line 2814
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 2816
    if (! new_header_tile_data) {
      {
#line 2817
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 2818
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 2819
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 2820
      opj_event_msg(p_manager, 1, "Not enough memory to write COC marker\n");
      }
#line 2821
      return (0);
    }
#line 2823
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 2824
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
  }
  {
#line 2827
  opj_j2k_write_coc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 2831
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_coc_size, p_manager);
  }
#line 2831
  if (__cil_tmp12 != (unsigned long )l_coc_size) {
#line 2834
    return (0);
  }
#line 2837
  return (1);
}
}
#line 2840 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 2843
  l_cp = (opj_cp_t *)((void *)0);
#line 2844
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2849
  l_cp = & p_j2k->m_cp;
#line 2850
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2852
  if ((l_tcp->tccps + p_first_comp_no)->csty != (l_tcp->tccps + p_second_comp_no)->csty) {
#line 2853
    return (0);
  }
  {
#line 2857
  __cil_tmp6 = opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                           p_second_comp_no);
  }
#line 2857
  return (__cil_tmp6);
}
}
#line 2861 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_coc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  int tmp ;
  OPJ_UINT32 __cil_tmp14 ;

  {
#line 2868
  l_cp = (opj_cp_t *)0;
#line 2869
  l_tcp = (opj_tcp_t *)0;
#line 2871
  l_current_data = (OPJ_BYTE *)0;
#line 2872
  l_image = (opj_image_t *)0;
#line 2879
  l_cp = & p_j2k->m_cp;
#line 2880
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 2881
  l_image = p_j2k->m_private_image;
#line 2882
  if (l_image->numcomps <= 256U) {
#line 2882
    tmp = 1;
  } else {
#line 2882
    tmp = 2;
  }
  {
#line 2882
  l_comp_room = (OPJ_UINT32 )tmp;
#line 2884
  __cil_tmp14 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, p_j2k->m_current_tile_number,
                                             p_comp_no);
#line 2884
  l_coc_size = (5U + l_comp_room) + __cil_tmp14;
#line 2886
  l_remaining_size = l_coc_size;
#line 2888
  l_current_data = p_data;
#line 2890
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65363, (OPJ_UINT32 )2);
#line 2892
  l_current_data += 2;
#line 2894
  opj_write_bytes_LE(l_current_data, l_coc_size - 2U, (OPJ_UINT32 )2);
#line 2896
  l_current_data += 2;
#line 2898
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 2899
  l_current_data += l_comp_room;
#line 2901
  opj_write_bytes_LE(l_current_data, (l_tcp->tccps + p_comp_no)->csty, (OPJ_UINT32 )1);
#line 2903
  l_current_data ++;
#line 2905
  l_remaining_size -= 5U + l_comp_room;
#line 2906
  opj_j2k_write_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0, l_current_data,
                            & l_remaining_size, p_manager);
#line 2908
  *p_data_written = l_coc_size;
  }
  return;
}
}
#line 2911 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 2916
  l_max = (OPJ_UINT32 )0;
#line 2920
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 2921
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 2923
  i = (OPJ_UINT32 )0;
  {
#line 2923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2923
    if (! (i < l_nb_tiles)) {
#line 2923
      goto while_break;
    }
#line 2924
    j = (OPJ_UINT32 )0;
    {
#line 2924
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2924
      if (! (j < l_nb_comp)) {
#line 2924
        goto while_break___0;
      }
      {
#line 2925
      __cil_tmp7 = opj_j2k_get_SPCod_SPCoc_size(p_j2k, i, j);
#line 2925
      __cil_tmp8 = opj_uint_max(l_max, __cil_tmp7);
#line 2925
      l_max = __cil_tmp8;
      }
#line 2924
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2923
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2929
  return (6U + l_max);
}
}
#line 2939 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_coc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  opj_tcp_t *tmp ;
  int tmp___0 ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 2945
  l_cp = (opj_cp_t *)((void *)0);
#line 2946
  l_tcp = (opj_tcp_t *)((void *)0);
#line 2947
  l_image = (opj_image_t *)((void *)0);
#line 2956
  l_cp = & p_j2k->m_cp;
#line 2957
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 2957
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 2957
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 2957
  l_tcp = tmp;
#line 2961
  l_image = p_j2k->m_private_image;
#line 2963
  if (l_image->numcomps <= 256U) {
#line 2963
    tmp___0 = 1;
  } else {
#line 2963
    tmp___0 = 2;
  }
#line 2963
  l_comp_room = (OPJ_UINT32 )tmp___0;
#line 2966
  if (p_header_size < l_comp_room + 1U) {
    {
#line 2967
    opj_event_msg(p_manager, 1, "Error reading COC marker\n\361G\t\265U");
    }
#line 2968
    return (0);
  }
  {
#line 2970
  p_header_size -= l_comp_room + 1U;
#line 2972
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 2974
  p_header_data += l_comp_room;
  }
#line 2975
  if (l_comp_no >= l_image->numcomps) {
    {
#line 2976
    opj_event_msg(p_manager, 1, "Error reading COC marker (bad number of components)\n");
    }
#line 2978
    return (0);
  }
  {
#line 2981
  opj_read_bytes_LE(p_header_data, & (l_tcp->tccps + l_comp_no)->csty, (OPJ_UINT32 )1);
#line 2983
  p_header_data ++;
#line 2985
  __cil_tmp12 = opj_j2k_read_SPCod_SPCoc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                         p_manager);
  }
#line 2985
  if (! __cil_tmp12) {
    {
#line 2987
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2988
    return (0);
  }
#line 2991
  if (p_header_size != 0U) {
    {
#line 2992
    opj_event_msg(p_manager, 1, "Error reading COC marker\n");
    }
#line 2993
    return (0);
  }
#line 2995
  return (1);
}
}
#line 2998 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcd_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 3004
  l_current_data = (OPJ_BYTE *)0;
#line 3011
  __cil_tmp7 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0);
#line 3011
  l_qcd_size = 4U + __cil_tmp7;
#line 3013
  l_remaining_size = l_qcd_size;
  }
#line 3015
  if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3016
    __cil_tmp9 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_qcd_size);
#line 3016
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp9;
    }
#line 3018
    if (! new_header_tile_data) {
      {
#line 3019
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3020
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3021
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3022
      opj_event_msg(p_manager, 1, "Not enough memory to write QCD marker\n");
      }
#line 3023
      return (0);
    }
#line 3025
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3026
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
  }
  {
#line 3029
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 3031
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65372, (OPJ_UINT32 )2);
#line 3032
  l_current_data += 2;
#line 3034
  opj_write_bytes_LE(l_current_data, l_qcd_size - 2U, (OPJ_UINT32 )2);
#line 3035
  l_current_data += 2;
#line 3037
  l_remaining_size -= (unsigned int )4;
#line 3039
  __cil_tmp10 = opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, (OPJ_UINT32 )0,
                                        l_current_data, & l_remaining_size, p_manager);
  }
#line 3039
  if (! __cil_tmp10) {
    {
#line 3041
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3042
    return (0);
  }
#line 3045
  if (l_remaining_size != 0U) {
    {
#line 3046
    opj_event_msg(p_manager, 1, "Error writing QCD marker\n");
    }
#line 3047
    return (0);
  }
  {
#line 3050
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcd_size, p_manager);
  }
#line 3050
  if (__cil_tmp11 != (unsigned long )l_qcd_size) {
#line 3053
    return (0);
  }
#line 3056
  return (1);
}
}
#line 3066 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 3077
  __cil_tmp5 = opj_j2k_read_SQcd_SQcc(p_j2k, (OPJ_UINT32 )0, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 3077
  if (! __cil_tmp5) {
    {
#line 3079
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n");
    }
#line 3080
    return (0);
  }
#line 3083
  if (p_header_size != 0U) {
    {
#line 3084
    opj_event_msg(p_manager, 1, "Error reading QCD marker\n&I\t\265U");
    }
#line 3085
    return (0);
  }
  {
#line 3089
  opj_j2k_copy_tile_quantization_parameters(p_j2k);
  }
#line 3091
  return (1);
}
}
#line 3094 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_UINT32 __cil_tmp7 ;
  int tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
  {
#line 3107
  __cil_tmp7 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3107
  l_qcc_size = 5U + __cil_tmp7;
  }
#line 3109
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
#line 3109
    tmp = 0;
  } else {
#line 3109
    tmp = 1;
  }
#line 3109
  l_qcc_size += (unsigned int )tmp;
#line 3110
  l_remaining_size = l_qcc_size;
#line 3112
  if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3113
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_qcc_size);
#line 3113
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 3115
    if (! new_header_tile_data) {
      {
#line 3116
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3117
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3118
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3119
      opj_event_msg(p_manager, 1, "Not enough memory to write QCC marker\n");
      }
#line 3120
      return (0);
    }
#line 3122
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3123
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
  }
  {
#line 3126
  opj_j2k_write_qcc_in_memory(p_j2k, p_comp_no, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_remaining_size, p_manager);
#line 3130
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_qcc_size, p_manager);
  }
#line 3130
  if (__cil_tmp11 != (unsigned long )l_qcc_size) {
#line 3133
    return (0);
  }
#line 3136
  return (1);
}
}
#line 3139 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_first_comp_no ,
                                    OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 3142
  __cil_tmp4 = opj_j2k_compare_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no,
                                         p_second_comp_no);
  }
#line 3142
  return (__cil_tmp4);
}
}
#line 3146 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no ,
                                        OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_qcc_size ;
  OPJ_UINT32 l_remaining_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 __cil_tmp9 ;

  {
  {
#line 3154
  l_current_data = (OPJ_BYTE *)0;
#line 3160
  __cil_tmp9 = opj_j2k_get_SQcd_SQcc_size(p_j2k, p_j2k->m_current_tile_number, p_comp_no);
#line 3160
  l_qcc_size = 6U + __cil_tmp9;
#line 3162
  l_remaining_size = l_qcc_size;
#line 3164
  l_current_data = p_data;
#line 3166
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65373, (OPJ_UINT32 )2);
#line 3167
  l_current_data += 2;
  }
#line 3169
  if ((p_j2k->m_private_image)->numcomps <= 256U) {
    {
#line 3170
    l_qcc_size --;
#line 3172
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3173
    l_current_data += 2;
#line 3175
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )1);
#line 3176
    l_current_data ++;
#line 3179
    l_remaining_size -= (unsigned int )6;
    }
  } else {
    {
#line 3181
    opj_write_bytes_LE(l_current_data, l_qcc_size - 2U, (OPJ_UINT32 )2);
#line 3182
    l_current_data += 2;
#line 3184
    opj_write_bytes_LE(l_current_data, p_comp_no, (OPJ_UINT32 )2);
#line 3185
    l_current_data += 2;
#line 3187
    l_remaining_size -= (unsigned int )6;
    }
  }
  {
#line 3190
  opj_j2k_write_SQcd_SQcc(p_j2k, p_j2k->m_current_tile_number, p_comp_no, l_current_data,
                          & l_remaining_size, p_manager);
#line 3193
  *p_data_written = l_qcc_size;
  }
  return;
}
}
#line 3196 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_qcc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
  {
#line 3198
  __cil_tmp2 = opj_j2k_get_max_coc_size(p_j2k);
  }
#line 3198
  return (__cil_tmp2);
}
}
#line 3208 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_qcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_no ;
  OPJ_BOOL __cil_tmp7 ;

  {
#line 3221
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 3223
  if (l_num_comp <= 256U) {
#line 3224
    if (p_header_size < 1U) {
      {
#line 3225
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3226
      return (0);
    }
    {
#line 3228
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )1);
#line 3229
    p_header_data ++;
#line 3230
    p_header_size --;
    }
  } else {
#line 3232
    if (p_header_size < 2U) {
      {
#line 3233
      opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
      }
#line 3234
      return (0);
    }
    {
#line 3236
    opj_read_bytes_LE(p_header_data, & l_comp_no, (OPJ_UINT32 )2);
#line 3237
    p_header_data += 2;
#line 3238
    p_header_size -= (unsigned int )2;
    }
  }
#line 3267
  if (l_comp_no >= (p_j2k->m_private_image)->numcomps) {
    {
#line 3268
    opj_event_msg(p_manager, 1, "Invalid component number: %d, regarding the number of components %d\n",
                  l_comp_no, (p_j2k->m_private_image)->numcomps);
    }
#line 3271
    return (0);
  }
  {
#line 3274
  __cil_tmp7 = opj_j2k_read_SQcd_SQcc(p_j2k, l_comp_no, p_header_data, & p_header_size,
                                      p_manager);
  }
#line 3274
  if (! __cil_tmp7) {
    {
#line 3276
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3277
    return (0);
  }
#line 3280
  if (p_header_size != 0U) {
    {
#line 3281
    opj_event_msg(p_manager, 1, "Error reading QCC marker\n");
    }
#line 3282
    return (0);
  }
#line 3285
  return (1);
}
}
#line 3288 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_poc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  OPJ_UINT32 l_written_size ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_poc_room ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp11 ;
  OPJ_SIZE_T __cil_tmp12 ;

  {
#line 3296
  l_written_size = (OPJ_UINT32 )0;
#line 3297
  l_tcp = (opj_tcp_t *)0;
#line 3305
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3306
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3307
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3309
  if (l_nb_comp <= 256U) {
#line 3310
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3312
    l_poc_room = (OPJ_UINT32 )2;
  }
#line 3314
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3316
  if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 3317
    __cil_tmp11 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_poc_size);
#line 3317
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp11;
    }
#line 3319
    if (! new_header_tile_data) {
      {
#line 3320
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 3321
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 3322
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 3323
      opj_event_msg(p_manager, 1, "Not enough memory to write POC marker\n");
      }
#line 3324
      return (0);
    }
#line 3326
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 3327
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
  }
  {
#line 3330
  opj_j2k_write_poc_in_memory(p_j2k, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              & l_written_size, p_manager);
#line 3334
  __cil_tmp12 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_poc_size, p_manager);
  }
#line 3334
  if (__cil_tmp12 != (unsigned long )l_poc_size) {
#line 3337
    return (0);
  }
#line 3340
  return (1);
}
}
#line 3343 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_nb_poc ;
  OPJ_UINT32 l_poc_size ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_poc_t *l_current_poc ;
  OPJ_UINT32 l_poc_room ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;

  {
#line 3350
  l_current_data = (OPJ_BYTE *)0;
#line 3354
  l_image = (opj_image_t *)0;
#line 3355
  l_tcp = (opj_tcp_t *)0;
#line 3356
  l_tccp = (opj_tccp_t *)0;
#line 3357
  l_current_poc = (opj_poc_t *)0;
#line 3366
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 3367
  l_tccp = l_tcp->tccps + 0;
#line 3368
  l_image = p_j2k->m_private_image;
#line 3369
  l_nb_comp = l_image->numcomps;
#line 3370
  l_nb_poc = 1U + l_tcp->numpocs;
#line 3372
  if (l_nb_comp <= 256U) {
#line 3373
    l_poc_room = (OPJ_UINT32 )1;
  } else {
#line 3375
    l_poc_room = (OPJ_UINT32 )2;
  }
  {
#line 3378
  l_poc_size = 4U + (5U + 2U * l_poc_room) * l_nb_poc;
#line 3380
  l_current_data = p_data;
#line 3382
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65375, (OPJ_UINT32 )2);
#line 3384
  l_current_data += 2;
#line 3386
  opj_write_bytes_LE(l_current_data, l_poc_size - 2U, (OPJ_UINT32 )2);
#line 3388
  l_current_data += 2;
#line 3390
  l_current_poc = (opj_poc_t *)l_tcp->pocs;
#line 3391
  i = (OPJ_UINT32 )0;
  }
  {
#line 3391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3391
    if (! (i < l_nb_poc)) {
#line 3391
      goto while_break;
    }
    {
#line 3392
    opj_write_bytes_LE(l_current_data, l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3394
    l_current_data ++;
#line 3396
    opj_write_bytes_LE(l_current_data, l_current_poc->compno0, l_poc_room);
#line 3398
    l_current_data += l_poc_room;
#line 3400
    opj_write_bytes_LE(l_current_data, l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3402
    l_current_data += 2;
#line 3404
    opj_write_bytes_LE(l_current_data, l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3406
    l_current_data ++;
#line 3408
    opj_write_bytes_LE(l_current_data, l_current_poc->compno1, l_poc_room);
#line 3410
    l_current_data += l_poc_room;
#line 3412
    opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_current_poc->prg, (OPJ_UINT32 )1);
#line 3414
    l_current_data ++;
#line 3417
    __cil_tmp15 = opj_int_min((OPJ_INT32 )l_current_poc->layno1, (OPJ_INT32 )l_tcp->numlayers);
#line 3417
    l_current_poc->layno1 = (OPJ_UINT32 )__cil_tmp15;
#line 3419
    __cil_tmp16 = opj_int_min((OPJ_INT32 )l_current_poc->resno1, (OPJ_INT32 )l_tccp->numresolutions);
#line 3419
    l_current_poc->resno1 = (OPJ_UINT32 )__cil_tmp16;
#line 3421
    __cil_tmp17 = opj_int_min((OPJ_INT32 )l_current_poc->compno1, (OPJ_INT32 )l_nb_comp);
#line 3421
    l_current_poc->compno1 = (OPJ_UINT32 )__cil_tmp17;
#line 3424
    l_current_poc ++;
    }
#line 3391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3427
  *p_data_written = l_poc_size;
  return;
}
}
#line 3430 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k ) 
{ 
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max_poc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3432
  l_tcp = (opj_tcp_t *)0;
#line 3433
  l_nb_tiles = (OPJ_UINT32 )0;
#line 3434
  l_max_poc = (OPJ_UINT32 )0;
#line 3437
  l_tcp = p_j2k->m_cp.tcps;
#line 3438
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 3440
  i = (OPJ_UINT32 )0;
  {
#line 3440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3440
    if (! (i < l_nb_tiles)) {
#line 3440
      goto while_break;
    }
    {
#line 3441
    l_max_poc = opj_uint_max(l_max_poc, l_tcp->numpocs);
#line 3442
    l_tcp ++;
    }
#line 3440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3445
  l_max_poc ++;
#line 3447
  return (4U + 9U * l_max_poc);
}
}
#line 3450 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_max_toc_size(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 l_max ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 3454
  l_max = (OPJ_UINT32 )0;
#line 3455
  l_tcp = (opj_tcp_t *)0;
#line 3457
  l_tcp = p_j2k->m_cp.tcps;
#line 3458
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 3460
  i = (OPJ_UINT32 )0;
  {
#line 3460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3460
    if (! (i < l_nb_tiles)) {
#line 3460
      goto while_break;
    }
    {
#line 3461
    l_max = opj_uint_max(l_max, l_tcp->m_nb_tile_parts);
#line 3463
    l_tcp ++;
    }
#line 3460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3466
  return (12U * l_max);
}
}
#line 3469 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 l_nb_bytes ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_coc_bytes ;
  OPJ_UINT32 l_qcc_bytes ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_max_packet_count ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;

  {
  {
#line 3471
  l_nb_bytes = (OPJ_UINT32 )0;
#line 3475
  l_nb_comps = (p_j2k->m_private_image)->numcomps - 1U;
#line 3476
  __cil_tmp6 = opj_j2k_get_max_toc_size(p_j2k);
  }
#line 3476
  l_nb_bytes += __cil_tmp6;
#line 3478
  if (! ((int )p_j2k->m_cp.rsiz >= 3 && (int )p_j2k->m_cp.rsiz <= 6)) {
    {
#line 3479
    l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
#line 3480
    l_nb_bytes += l_nb_comps * l_coc_bytes;
#line 3482
    l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
#line 3483
    l_nb_bytes += l_nb_comps * l_qcc_bytes;
    }
  }
  {
#line 3486
  __cil_tmp9 = opj_j2k_get_max_poc_size(p_j2k);
  }
#line 3486
  l_nb_bytes += __cil_tmp9;
#line 3488
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
#line 3492
    l_cp = & p_j2k->m_cp;
#line 3493
    l_max_packet_count = (OPJ_UINT32 )0;
#line 3494
    i = (OPJ_UINT32 )0;
    {
#line 3494
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3494
      if (! (i < l_cp->th * l_cp->tw)) {
#line 3494
        goto while_break;
      }
      {
#line 3495
      __cil_tmp13 = opj_get_encoding_packet_count(p_j2k->m_private_image, l_cp, i);
#line 3495
      __cil_tmp14 = opj_uint_max(l_max_packet_count, __cil_tmp13);
#line 3495
      l_max_packet_count = __cil_tmp14;
      }
#line 3494
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3501
    __cil_tmp15 = opj_uint_ceildiv(l_max_packet_count, (OPJ_UINT32 )16382);
#line 3501
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT = 6U * __cil_tmp15;
#line 3504
    l_nb_bytes += 5U * l_max_packet_count;
    }
#line 3504
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT += l_nb_bytes;
#line 3506
    p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT += (unsigned int )1;
#line 3507
    l_nb_bytes += p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
  }
#line 3512
  return (l_nb_bytes);
}
}
#line 3523 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_poc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_tmp ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_old_poc_nb ;
  OPJ_UINT32 l_current_poc_nb ;
  OPJ_UINT32 l_current_poc_remaining ;
  OPJ_UINT32 l_chunk_size ;
  OPJ_UINT32 l_comp_room ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_poc_t *l_current_poc ;
  opj_tcp_t *tmp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;

  {
#line 3530
  l_image = (opj_image_t *)0;
#line 3534
  l_cp = (opj_cp_t *)0;
#line 3535
  l_tcp = (opj_tcp_t *)0;
#line 3536
  l_current_poc = (opj_poc_t *)0;
#line 3543
  l_image = p_j2k->m_private_image;
#line 3544
  l_nb_comp = l_image->numcomps;
#line 3545
  if (l_nb_comp <= 256U) {
#line 3546
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 3548
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 3550
  l_chunk_size = 5U + 2U * l_comp_room;
#line 3551
  l_current_poc_nb = p_header_size / l_chunk_size;
#line 3552
  l_current_poc_remaining = p_header_size % l_chunk_size;
#line 3554
  if (l_current_poc_nb <= 0U) {
    {
    {
#line 3555
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3556
    return (0);
  } else
#line 3554
  if (l_current_poc_remaining != 0U) {
    {
    {
#line 3555
    opj_event_msg(p_manager, 1, "Error reading POC marker\n");
    }
    }
#line 3556
    return (0);
  }
#line 3559
  l_cp = & p_j2k->m_cp;
#line 3560
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 3560
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 3560
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 3560
  l_tcp = tmp;
#line 3563
  if ((int )l_tcp->POC) {
#line 3563
    tmp___0 = l_tcp->numpocs + 1U;
  } else {
#line 3563
    tmp___0 = (unsigned int )0;
  }
#line 3563
  l_old_poc_nb = tmp___0;
#line 3564
  l_current_poc_nb += l_old_poc_nb;
#line 3566
  if (l_current_poc_nb >= 32U) {
    {
#line 3567
    opj_event_msg(p_manager, 1, "Too many POCs %d\n", l_current_poc_nb);
    }
#line 3568
    return (0);
  }
#line 3572
  l_tcp->POC = (OPJ_BITFIELD )1;
#line 3574
  l_current_poc = & l_tcp->pocs[l_old_poc_nb];
#line 3575
  i = l_old_poc_nb;
  {
#line 3575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3575
    if (! (i < l_current_poc_nb)) {
#line 3575
      goto while_break;
    }
    {
#line 3576
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno0, (OPJ_UINT32 )1);
#line 3578
    p_header_data ++;
#line 3579
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno0, l_comp_room);
#line 3581
    p_header_data += l_comp_room;
#line 3582
    opj_read_bytes_LE(p_header_data, & l_current_poc->layno1, (OPJ_UINT32 )2);
#line 3585
    l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
#line 3586
    p_header_data += 2;
#line 3587
    opj_read_bytes_LE(p_header_data, & l_current_poc->resno1, (OPJ_UINT32 )1);
#line 3589
    p_header_data ++;
#line 3590
    opj_read_bytes_LE(p_header_data, & l_current_poc->compno1, l_comp_room);
#line 3592
    p_header_data += l_comp_room;
#line 3593
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3595
    p_header_data ++;
#line 3596
    l_current_poc->prg = (OPJ_PROG_ORDER )l_tmp;
#line 3598
    l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
#line 3599
    l_current_poc ++;
    }
#line 3575
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3602
  l_tcp->numpocs = l_current_poc_nb - 1U;
#line 3603
  return (1);
}
}
#line 3614 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_crg(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;

  {
#line 3628
  l_nb_comp = (p_j2k->m_private_image)->numcomps;
#line 3630
  if (p_header_size != l_nb_comp * 4U) {
    {
#line 3631
    opj_event_msg(p_manager, 1, "Error reading CRG marker\n");
    }
#line 3632
    return (0);
  }
#line 3645
  return (1);
}
}
#line 3656 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_tlm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Ztlm ;
  OPJ_UINT32 l_Stlm ;
  OPJ_UINT32 l_ST ;
  OPJ_UINT32 l_SP ;
  OPJ_UINT32 l_tot_num_tp_remaining ;
  OPJ_UINT32 l_quotient ;
  OPJ_UINT32 l_Ptlm_size ;

  {
#line 3671
  if (p_header_size < 2U) {
    {
#line 3672
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n");
    }
#line 3673
    return (0);
  }
  {
#line 3675
  p_header_size -= (unsigned int )2;
#line 3677
  opj_read_bytes_LE(p_header_data, & l_Ztlm, (OPJ_UINT32 )1);
#line 3679
  p_header_data ++;
#line 3680
  opj_read_bytes_LE(p_header_data, & l_Stlm, (OPJ_UINT32 )1);
#line 3682
  p_header_data ++;
#line 3684
  l_ST = (l_Stlm >> 4) & 3U;
#line 3685
  l_SP = (l_Stlm >> 6) & 1U;
#line 3687
  l_Ptlm_size = (l_SP + 1U) * 2U;
#line 3688
  l_quotient = l_Ptlm_size + l_ST;
#line 3690
  l_tot_num_tp_remaining = p_header_size % l_quotient;
  }
#line 3692
  if (l_tot_num_tp_remaining != 0U) {
    {
#line 3693
    opj_event_msg(p_manager, 1, "Error reading TLM marker\n");
    }
#line 3694
    return (0);
  }
#line 3706
  return (1);
}
}
#line 3717 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 3731
  if (p_header_size < 1U) {
    {
#line 3732
    opj_event_msg(p_manager, 1, "Error reading PLM marker\n");
    }
#line 3733
    return (0);
  }
#line 3779
  return (1);
}
}
#line 3790 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_plt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_Zplt ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_packet_len ;
  OPJ_UINT32 i ;

  {
#line 3796
  l_packet_len = (OPJ_UINT32 )0;
#line 3805
  if (p_header_size < 1U) {
    {
#line 3806
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3807
    return (0);
  }
  {
#line 3810
  opj_read_bytes_LE(p_header_data, & l_Zplt, (OPJ_UINT32 )1);
#line 3811
  p_header_data ++;
#line 3812
  p_header_size --;
#line 3814
  i = (OPJ_UINT32 )0;
  }
  {
#line 3814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3814
    if (! (i < p_header_size)) {
#line 3814
      goto while_break;
    }
    {
#line 3815
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 3816
    p_header_data ++;
#line 3818
    l_packet_len |= l_tmp & 127U;
    }
#line 3819
    if (l_tmp & 128U) {
#line 3820
      l_packet_len <<= 7;
    } else {
#line 3823
      l_packet_len = (OPJ_UINT32 )0;
    }
#line 3814
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3827
  if (l_packet_len != 0U) {
    {
#line 3828
    opj_event_msg(p_manager, 1, "Error reading PLT marker\n");
    }
#line 3829
    return (0);
  }
#line 3832
  return (1);
}
}
#line 3844 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppm(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  OPJ_UINT32 l_Z_ppm ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp8 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppm_markers ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 3850
  l_cp = (opj_cp_t *)0;
#line 3859
  if (p_header_size < 2U) {
    {
#line 3860
    opj_event_msg(p_manager, 1, "Error reading PPM marker\n\206J\t\265U");
    }
#line 3861
    return (0);
  }
  {
#line 3864
  l_cp = & p_j2k->m_cp;
#line 3865
  l_cp->ppm = (OPJ_BITFIELD )1;
#line 3867
  opj_read_bytes_LE(p_header_data, & l_Z_ppm, (OPJ_UINT32 )1);
#line 3868
  p_header_data ++;
#line 3869
  p_header_size --;
  }
#line 3872
  if (l_cp->ppm_markers == (void *)0) {
    {
#line 3873
    l_newCount = l_Z_ppm + 1U;
#line 3876
    __cil_tmp8 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 3876
    l_cp->ppm_markers = (opj_ppx *)__cil_tmp8;
    }
#line 3877
    if (l_cp->ppm_markers == (void *)0) {
      {
#line 3878
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nU");
      }
#line 3879
      return (0);
    }
#line 3881
    l_cp->ppm_markers_count = l_newCount;
  } else
#line 3882
  if (l_cp->ppm_markers_count <= l_Z_ppm) {
    {
#line 3883
    l_newCount___0 = l_Z_ppm + 1U;
#line 3885
    __cil_tmp11 = opj_realloc(l_cp->ppm_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 3885
    new_ppm_markers = (opj_ppx *)__cil_tmp11;
    }
#line 3887
    if (new_ppm_markers == (void *)0) {
      {
#line 3889
      opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
      }
#line 3890
      return (0);
    }
    {
#line 3892
    l_cp->ppm_markers = new_ppm_markers;
#line 3893
    memset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0, (unsigned long )(l_newCount___0 - l_cp->ppm_markers_count) * sizeof(opj_ppx ));
#line 3895
    l_cp->ppm_markers_count = l_newCount___0;
    }
  }
#line 3898
  if ((l_cp->ppm_markers + l_Z_ppm)->m_data != (void *)0) {
    {
#line 3900
    opj_event_msg(p_manager, 1, "Zppm %u already read\n", l_Z_ppm);
    }
#line 3901
    return (0);
  }
  {
#line 3904
  __cil_tmp12 = opj_malloc((size_t )p_header_size);
#line 3904
  (l_cp->ppm_markers + l_Z_ppm)->m_data = (OPJ_BYTE *)__cil_tmp12;
  }
#line 3905
  if ((l_cp->ppm_markers + l_Z_ppm)->m_data == (void *)0) {
    {
#line 3907
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\n");
    }
#line 3908
    return (0);
  }
  {
#line 3910
  (l_cp->ppm_markers + l_Z_ppm)->m_data_size = p_header_size;
#line 3911
  memcpy((l_cp->ppm_markers + l_Z_ppm)->m_data, p_header_data, (unsigned long )p_header_size);
  }
#line 3913
  return (1);
}
}
#line 3922 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppm(opj_cp_t *p_cp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppm_data_size ;
  OPJ_UINT32 l_N_ppm_remaining ;
  OPJ_UINT32 l_N_ppm ;
  OPJ_UINT32 l_data_size ;
  OPJ_BYTE *l_data ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_N_ppm___0 ;
  OPJ_UINT32 l_data_size___0 ;
  OPJ_BYTE *l_data___0 ;

  {
#line 3931
  if (p_cp->ppm == 0U) {
#line 3932
    return (1);
  }
#line 3935
  l_ppm_data_size = 0U;
#line 3936
  l_N_ppm_remaining = 0U;
#line 3937
  i = 0U;
  {
#line 3937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3937
    if (! (i < p_cp->ppm_markers_count)) {
#line 3937
      goto while_break;
    }
#line 3938
    if ((p_cp->ppm_markers + i)->m_data != (void *)0) {
#line 3941
      l_data_size = (p_cp->ppm_markers + i)->m_data_size;
#line 3942
      l_data = (p_cp->ppm_markers + i)->m_data;
#line 3944
      if (l_N_ppm_remaining >= l_data_size) {
#line 3945
        l_N_ppm_remaining -= l_data_size;
#line 3946
        l_data_size = 0U;
      } else {
#line 3948
        l_data += l_N_ppm_remaining;
#line 3949
        l_data_size -= l_N_ppm_remaining;
#line 3950
        l_N_ppm_remaining = 0U;
      }
#line 3953
      if (l_data_size > 0U) {
        {
#line 3954
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3956
          if (l_data_size < 4U) {
            {
#line 3958
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 3959
            return (0);
          }
          {
#line 3961
          opj_read_bytes_LE(l_data, & l_N_ppm, (OPJ_UINT32 )4);
#line 3962
          l_data += 4;
#line 3963
          l_data_size -= (unsigned int )4;
#line 3964
          l_ppm_data_size += l_N_ppm;
          }
#line 3967
          if (l_data_size >= l_N_ppm) {
#line 3968
            l_data_size -= l_N_ppm;
#line 3969
            l_data += l_N_ppm;
          } else {
#line 3971
            l_N_ppm_remaining = l_N_ppm - l_data_size;
#line 3972
            l_data_size = 0U;
          }
#line 3954
          if (! (l_data_size > 0U)) {
#line 3954
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 3937
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3979
  if (l_N_ppm_remaining != 0U) {
    {
#line 3981
    opj_event_msg(p_manager, 1, "Corrupted PPM markers\n");
    }
#line 3982
    return (0);
  }
  {
#line 3985
  __cil_tmp9 = opj_malloc((size_t )l_ppm_data_size);
#line 3985
  p_cp->ppm_buffer = (OPJ_BYTE *)__cil_tmp9;
  }
#line 3986
  if (p_cp->ppm_buffer == (OPJ_BYTE *)0) {
    {
#line 3987
    opj_event_msg(p_manager, 1, "Not enough memory to read PPM marker\nU");
    }
#line 3988
    return (0);
  }
#line 3990
  p_cp->ppm_len = l_ppm_data_size;
#line 3991
  l_ppm_data_size = 0U;
#line 3992
  l_N_ppm_remaining = 0U;
#line 3993
  i = 0U;
  {
#line 3993
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3993
    if (! (i < p_cp->ppm_markers_count)) {
#line 3993
      goto while_break___1;
    }
#line 3994
    if ((p_cp->ppm_markers + i)->m_data != (void *)0) {
#line 3997
      l_data_size___0 = (p_cp->ppm_markers + i)->m_data_size;
#line 3998
      l_data___0 = (p_cp->ppm_markers + i)->m_data;
#line 4000
      if (l_N_ppm_remaining >= l_data_size___0) {
        {
#line 4001
        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_data_size___0);
#line 4002
        l_ppm_data_size += l_data_size___0;
#line 4003
        l_N_ppm_remaining -= l_data_size___0;
#line 4004
        l_data_size___0 = 0U;
        }
      } else {
        {
#line 4006
        memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_N_ppm_remaining);
#line 4007
        l_ppm_data_size += l_N_ppm_remaining;
#line 4008
        l_data___0 += l_N_ppm_remaining;
#line 4009
        l_data_size___0 -= l_N_ppm_remaining;
#line 4010
        l_N_ppm_remaining = 0U;
        }
      }
#line 4013
      if (l_data_size___0 > 0U) {
        {
#line 4014
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4016
          if (l_data_size___0 < 4U) {
            {
#line 4018
            opj_event_msg(p_manager, 1, "Not enough bytes to read Nppm\n");
            }
#line 4019
            return (0);
          }
          {
#line 4021
          opj_read_bytes_LE(l_data___0, & l_N_ppm___0, (OPJ_UINT32 )4);
#line 4022
          l_data___0 += 4;
#line 4023
          l_data_size___0 -= (unsigned int )4;
          }
#line 4025
          if (l_data_size___0 >= l_N_ppm___0) {
            {
#line 4026
            memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_N_ppm___0);
#line 4027
            l_ppm_data_size += l_N_ppm___0;
#line 4028
            l_data_size___0 -= l_N_ppm___0;
#line 4029
            l_data___0 += l_N_ppm___0;
            }
          } else {
            {
#line 4031
            memcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data___0, (unsigned long )l_data_size___0);
#line 4032
            l_ppm_data_size += l_data_size___0;
#line 4033
            l_N_ppm_remaining = l_N_ppm___0 - l_data_size___0;
#line 4034
            l_data_size___0 = 0U;
            }
          }
#line 4014
          if (! (l_data_size___0 > 0U)) {
#line 4014
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 4038
      opj_free((p_cp->ppm_markers + i)->m_data);
#line 4039
      (p_cp->ppm_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 4040
      (p_cp->ppm_markers + i)->m_data_size = 0U;
      }
    }
#line 3993
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4044
  p_cp->ppm_data = p_cp->ppm_buffer;
#line 4045
  p_cp->ppm_data_size = p_cp->ppm_len;
#line 4047
  p_cp->ppm_markers_count = 0U;
#line 4048
  opj_free(p_cp->ppm_markers);
#line 4049
  p_cp->ppm_markers = (opj_ppx *)((void *)0);
  }
#line 4051
  return (1);
}
}
#line 4062 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_ppt(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_Z_ppt ;
  OPJ_UINT32 l_newCount ;
  void *__cil_tmp9 ;
  OPJ_UINT32 l_newCount___0 ;
  opj_ppx *new_ppt_markers ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 4068
  l_cp = (opj_cp_t *)0;
#line 4069
  l_tcp = (opj_tcp_t *)0;
#line 4078
  if (p_header_size < 2U) {
    {
#line 4079
    opj_event_msg(p_manager, 1, "Error reading PPT marker\n\021K\t\265U");
    }
#line 4080
    return (0);
  }
#line 4083
  l_cp = & p_j2k->m_cp;
#line 4084
  if (l_cp->ppm) {
    {
#line 4085
    opj_event_msg(p_manager, 1, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
    }
#line 4087
    return (0);
  }
  {
#line 4090
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4091
  l_tcp->ppt = (OPJ_BITFIELD )1;
#line 4093
  opj_read_bytes_LE(p_header_data, & l_Z_ppt, (OPJ_UINT32 )1);
#line 4094
  p_header_data ++;
#line 4095
  p_header_size --;
  }
#line 4098
  if (l_tcp->ppt_markers == (void *)0) {
    {
#line 4099
    l_newCount = l_Z_ppt + 1U;
#line 4102
    __cil_tmp9 = opj_calloc((size_t )l_newCount, sizeof(opj_ppx ));
#line 4102
    l_tcp->ppt_markers = (opj_ppx *)__cil_tmp9;
    }
#line 4103
    if (l_tcp->ppt_markers == (void *)0) {
      {
#line 4104
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nU");
      }
#line 4105
      return (0);
    }
#line 4107
    l_tcp->ppt_markers_count = l_newCount;
  } else
#line 4108
  if (l_tcp->ppt_markers_count <= l_Z_ppt) {
    {
#line 4109
    l_newCount___0 = l_Z_ppt + 1U;
#line 4111
    __cil_tmp12 = opj_realloc(l_tcp->ppt_markers, (unsigned long )l_newCount___0 * sizeof(opj_ppx ));
#line 4111
    new_ppt_markers = (opj_ppx *)__cil_tmp12;
    }
#line 4113
    if (new_ppt_markers == (void *)0) {
      {
#line 4115
      opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nU");
      }
#line 4116
      return (0);
    }
    {
#line 4118
    l_tcp->ppt_markers = new_ppt_markers;
#line 4119
    memset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0, (unsigned long )(l_newCount___0 - l_tcp->ppt_markers_count) * sizeof(opj_ppx ));
#line 4121
    l_tcp->ppt_markers_count = l_newCount___0;
    }
  }
#line 4124
  if ((l_tcp->ppt_markers + l_Z_ppt)->m_data != (void *)0) {
    {
#line 4126
    opj_event_msg(p_manager, 1, "Zppt %u already read\nU", l_Z_ppt);
    }
#line 4127
    return (0);
  }
  {
#line 4130
  __cil_tmp13 = opj_malloc((size_t )p_header_size);
#line 4130
  (l_tcp->ppt_markers + l_Z_ppt)->m_data = (OPJ_BYTE *)__cil_tmp13;
  }
#line 4131
  if ((l_tcp->ppt_markers + l_Z_ppt)->m_data == (void *)0) {
    {
#line 4133
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nU");
    }
#line 4134
    return (0);
  }
  {
#line 4136
  (l_tcp->ppt_markers + l_Z_ppt)->m_data_size = p_header_size;
#line 4137
  memcpy((l_tcp->ppt_markers + l_Z_ppt)->m_data, p_header_data, (unsigned long )p_header_size);
  }
#line 4138
  return (1);
}
}
#line 4147 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_ppt_data_size ;
  void *__cil_tmp5 ;

  {
#line 4154
  if (p_tcp->ppt_buffer != (void *)0) {
    {
#line 4155
    opj_event_msg(p_manager, 1, "opj_j2k_merge_ppt() has already been called\n\265U");
    }
#line 4157
    return (0);
  }
#line 4160
  if (p_tcp->ppt == 0U) {
#line 4161
    return (1);
  }
#line 4164
  l_ppt_data_size = 0U;
#line 4165
  i = 0U;
  {
#line 4165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4165
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4165
      goto while_break;
    }
#line 4166
    l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4170
  __cil_tmp5 = opj_malloc((size_t )l_ppt_data_size);
#line 4170
  p_tcp->ppt_buffer = (OPJ_BYTE *)__cil_tmp5;
  }
#line 4171
  if (p_tcp->ppt_buffer == (OPJ_BYTE *)0) {
    {
#line 4172
    opj_event_msg(p_manager, 1, "Not enough memory to read PPT marker\nU");
    }
#line 4173
    return (0);
  }
#line 4175
  p_tcp->ppt_len = l_ppt_data_size;
#line 4176
  l_ppt_data_size = 0U;
#line 4177
  i = 0U;
  {
#line 4177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4177
    if (! (i < p_tcp->ppt_markers_count)) {
#line 4177
      goto while_break___0;
    }
#line 4178
    if ((p_tcp->ppt_markers + i)->m_data != (void *)0) {
      {
#line 4180
      memcpy(p_tcp->ppt_buffer + l_ppt_data_size, (p_tcp->ppt_markers + i)->m_data,
             (unsigned long )(p_tcp->ppt_markers + i)->m_data_size);
#line 4182
      l_ppt_data_size += (p_tcp->ppt_markers + i)->m_data_size;
#line 4185
      opj_free((p_tcp->ppt_markers + i)->m_data);
#line 4186
      (p_tcp->ppt_markers + i)->m_data = (OPJ_BYTE *)((void *)0);
#line 4187
      (p_tcp->ppt_markers + i)->m_data_size = 0U;
      }
    }
#line 4177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4191
  p_tcp->ppt_markers_count = 0U;
#line 4192
  opj_free(p_tcp->ppt_markers);
#line 4193
  p_tcp->ppt_markers = (opj_ppx *)((void *)0);
#line 4195
  p_tcp->ppt_data = p_tcp->ppt_buffer;
#line 4196
  p_tcp->ppt_data_size = p_tcp->ppt_len;
  }
#line 4197
  return (1);
}
}
#line 4200 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tlm_size ;
  OPJ_UINT32 size_per_tile_part ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp8 ;
  OPJ_OFF_T __cil_tmp9 ;
  int tmp ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 4205
  l_current_data = (OPJ_BYTE *)0;
#line 4216
  if (p_j2k->m_specific_param.m_encoder.m_total_tile_parts > 10921U) {
    {
#line 4218
    opj_event_msg(p_manager, 1, "A maximum of 10921 tile-parts are supported currently when writing TLM marker\n");
    }
#line 4221
    return (0);
  }
#line 4224
  if (p_j2k->m_specific_param.m_encoder.m_total_tile_parts <= 255U) {
#line 4225
    size_per_tile_part = (OPJ_UINT32 )5;
#line 4226
    p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte = 1;
  } else {
#line 4228
    size_per_tile_part = (OPJ_UINT32 )6;
#line 4229
    p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte = 0;
  }
#line 4232
  l_tlm_size = 6U + size_per_tile_part * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 4235
  if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 4236
    __cil_tmp8 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_tlm_size);
#line 4236
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp8;
    }
#line 4238
    if (! new_header_tile_data) {
      {
#line 4239
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 4240
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 4241
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 4242
      opj_event_msg(p_manager, 1, "Not enough memory to write TLM marker\n");
      }
#line 4243
      return (0);
    }
#line 4245
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 4246
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
  }
  {
#line 4248
  memset(p_j2k->m_specific_param.m_encoder.m_header_tile_data, 0, (unsigned long )l_tlm_size);
#line 4250
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 4254
  p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
#line 4256
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65365, (OPJ_UINT32 )2);
#line 4258
  l_current_data += 2;
#line 4260
  opj_write_bytes_LE(l_current_data, l_tlm_size - 2U, (OPJ_UINT32 )2);
#line 4262
  l_current_data += 2;
#line 4264
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 4266
  l_current_data ++;
  }
#line 4270
  if (size_per_tile_part == 5U) {
#line 4270
    tmp = 80;
  } else {
#line 4270
    tmp = 96;
  }
  {
#line 4270
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )tmp, (OPJ_UINT32 )1);
#line 4273
  l_current_data ++;
#line 4276
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 4276
  if (__cil_tmp11 != (unsigned long )l_tlm_size) {
#line 4279
    return (0);
  }
#line 4282
  return (1);
}
}
#line 4285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_data , OPJ_UINT32 total_data_size ,
                                  OPJ_UINT32 *p_data_written , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4300
  if (total_data_size < 12U) {
    {
#line 4301
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOT marker\n");
    }
#line 4303
    return (0);
  }
  {
#line 4306
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65424, (OPJ_UINT32 )2);
#line 4308
  p_data += 2;
#line 4310
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )10, (OPJ_UINT32 )2);
#line 4312
  p_data += 2;
#line 4314
  opj_write_bytes_LE(p_data, p_j2k->m_current_tile_number, (OPJ_UINT32 )2);
#line 4316
  p_data += 2;
#line 4319
  p_data += 4;
#line 4321
  opj_write_bytes_LE(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                     (OPJ_UINT32 )1);
#line 4324
  p_data ++;
#line 4326
  opj_write_bytes_LE(p_data, (p_j2k->m_cp.tcps + p_j2k->m_current_tile_number)->m_nb_tile_parts,
                     (OPJ_UINT32 )1);
#line 4329
  p_data ++;
#line 4340
  *p_data_written = (OPJ_UINT32 )12;
  }
#line 4342
  return (1);
}
}
#line 4345 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                       OPJ_UINT32 *p_tile_no , OPJ_UINT32 *p_tot_len ,
                                       OPJ_UINT32 *p_current_part , OPJ_UINT32 *p_num_parts ,
                                       opj_event_mgr_t *p_manager ) 
{ 


  {
#line 4358
  if (p_header_size != 8U) {
    {
#line 4359
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4360
    return (0);
  }
  {
#line 4363
  opj_read_bytes_LE(p_header_data, p_tile_no, (OPJ_UINT32 )2);
#line 4364
  p_header_data += 2;
#line 4365
  opj_read_bytes_LE(p_header_data, p_tot_len, (OPJ_UINT32 )4);
#line 4366
  p_header_data += 4;
#line 4367
  opj_read_bytes_LE(p_header_data, p_current_part, (OPJ_UINT32 )1);
#line 4368
  p_header_data ++;
#line 4369
  opj_read_bytes_LE(p_header_data, p_num_parts, (OPJ_UINT32 )1);
#line 4370
  p_header_data ++;
  }
#line 4371
  return (1);
}
}
#line 4374 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sot(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_num_parts ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  OPJ_BOOL __cil_tmp12 ;
  void *__cil_tmp13 ;
  opj_tp_index_t *new_tp_index ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  opj_tp_index_t *new_tp_index___0 ;
  void *__cil_tmp18 ;

  {
  {
#line 4379
  l_cp = (opj_cp_t *)0;
#line 4380
  l_tcp = (opj_tcp_t *)0;
#line 4381
  l_num_parts = (OPJ_UINT32 )0;
#line 4390
  __cil_tmp12 = opj_j2k_get_sot_values(p_header_data, p_header_size, & p_j2k->m_current_tile_number,
                                       & l_tot_len, & l_current_part, & l_num_parts,
                                       p_manager);
  }
#line 4390
  if (! __cil_tmp12) {
    {
#line 4393
    opj_event_msg(p_manager, 1, "Error reading SOT marker\n");
    }
#line 4394
    return (0);
  }
#line 4401
  l_cp = & p_j2k->m_cp;
#line 4404
  if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
    {
#line 4405
    opj_event_msg(p_manager, 1, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
    }
#line 4407
    return (0);
  }
#line 4410
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 4411
  l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
#line 4412
  l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
#line 4414
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec < 0) {
    _L: /* CIL Label */ 
#line 4427
    if (l_tcp->m_current_tile_part_number + 1 != (OPJ_INT32 )l_current_part) {
      {
#line 4428
      opj_event_msg(p_manager, 1, "Invalid tile part index for tile number %d. Got %d, expected %d\n",
                    p_j2k->m_current_tile_number, l_current_part, l_tcp->m_current_tile_part_number + 1);
      }
#line 4434
      return (0);
    }
  } else
#line 4414
  if (p_j2k->m_current_tile_number == (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec) {
#line 4414
    goto _L;
  }
#line 4438
  l_tcp->m_current_tile_part_number = (OPJ_INT32 )l_current_part;
#line 4472
  if (l_tot_len != 0U) {
#line 4472
    if (l_tot_len < 14U) {
#line 4473
      if (l_tot_len == 12U) {
        {
#line 4475
        opj_event_msg(p_manager, 2, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
        }
      } else {
        {
#line 4478
        opj_event_msg(p_manager, 1, "Psot value is not correct regards to the JPEG2000 norm: %d.\n\265U",
                      l_tot_len);
        }
#line 4480
        return (0);
      }
    }
  }
#line 4508
  if (! l_tot_len) {
    {
#line 4509
    opj_event_msg(p_manager, 4, "Psot value of the current tile-part is equal to zero, we assuming it is the last tile-part of the codestream.\nK\t\265U");
#line 4512
    p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
    }
  }
#line 4515
  if (l_tcp->m_nb_tile_parts != 0U) {
#line 4515
    if (l_current_part >= l_tcp->m_nb_tile_parts) {
      {
#line 4517
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the previous number of tile-part (%d), giving up\n",
                    l_current_part, l_tcp->m_nb_tile_parts);
#line 4521
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4522
      return (0);
    }
  }
#line 4525
  if (l_num_parts != 0U) {
#line 4527
    l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;
#line 4530
    if (l_tcp->m_nb_tile_parts) {
#line 4531
      if (l_current_part >= l_tcp->m_nb_tile_parts) {
        {
#line 4532
        opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (%d), giving up\n",
                      l_current_part, l_tcp->m_nb_tile_parts);
#line 4536
        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
        }
#line 4537
        return (0);
      }
    }
#line 4540
    if (l_current_part >= l_num_parts) {
      {
#line 4542
      opj_event_msg(p_manager, 1, "In SOT marker, TPSot (%d) is not valid regards to the current number of tile-part (header) (%d), giving up\n",
                    l_current_part, l_num_parts);
#line 4545
      p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
      }
#line 4546
      return (0);
    }
#line 4548
    l_tcp->m_nb_tile_parts = l_num_parts;
  }
#line 4552
  if (l_tcp->m_nb_tile_parts) {
#line 4553
    if (l_tcp->m_nb_tile_parts == l_current_part + 1U) {
#line 4554
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )1;
    }
  }
#line 4559
  if (! p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
#line 4561
    p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12U;
  } else {
#line 4565
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )0;
  }
#line 4568
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )16;
#line 4571
  if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
#line 4572
    p_j2k->m_specific_param.m_decoder.m_skip_data = ((l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x || l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x) || l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y) || l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y;
  } else {
#line 4579
    p_j2k->m_specific_param.m_decoder.m_skip_data = p_j2k->m_current_tile_number != (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
  }
#line 4585
  if (p_j2k->cstr_index) {
#line 4587
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tileno = p_j2k->m_current_tile_number;
#line 4589
    ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_tpsno = l_current_part;
#line 4592
    if (l_num_parts != 0U) {
#line 4593
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->nb_tps = l_num_parts;
#line 4595
      ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_num_parts;
#line 4598
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4599
        __cil_tmp13 = opj_calloc((size_t )l_num_parts, sizeof(opj_tp_index_t ));
#line 4599
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp13;
        }
#line 4601
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4602
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4604
          return (0);
        }
      } else {
        {
#line 4607
        __cil_tmp15 = opj_realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )l_num_parts * sizeof(opj_tp_index_t ));
#line 4607
        new_tp_index = (opj_tp_index_t *)__cil_tmp15;
        }
#line 4610
        if (! new_tp_index) {
          {
#line 4611
          opj_free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4612
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4613
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4615
          return (0);
        }
#line 4617
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index;
      }
    } else {
#line 4623
      if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
        {
#line 4624
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )10;
#line 4625
        __cil_tmp16 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps,
                                 sizeof(opj_tp_index_t ));
#line 4625
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)__cil_tmp16;
        }
#line 4629
        if (! ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index) {
          {
#line 4630
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4631
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4633
          return (0);
        }
      }
#line 4637
      if (l_current_part >= ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps) {
        {
#line 4640
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = l_current_part + 1U;
#line 4642
        __cil_tmp18 = opj_realloc(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index,
                                  (unsigned long )((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps * sizeof(opj_tp_index_t ));
#line 4642
        new_tp_index___0 = (opj_tp_index_t *)__cil_tmp18;
        }
#line 4646
        if (! new_tp_index___0) {
          {
#line 4647
          opj_free(((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index);
#line 4648
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = (opj_tp_index_t *)((void *)0);
#line 4649
          ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->current_nb_tps = (OPJ_UINT32 )0;
#line 4650
          opj_event_msg(p_manager, 1, "Not enough memory to read SOT marker. Tile index allocation failed\n");
          }
#line 4652
          return (0);
        }
#line 4654
        ((p_j2k->cstr_index)->tile_index + p_j2k->m_current_tile_number)->tp_index = new_tp_index___0;
      }
    }
  }
#line 4690
  return (1);
}
}
#line 4696 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_plt_in_memory(opj_j2k_t *p_j2k , opj_tcd_marker_info_t *marker_info ,
                                            OPJ_BYTE *p_data , OPJ_UINT32 *p_data_written ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE Zplt ;
  OPJ_UINT16 Lplt ;
  OPJ_BYTE *p_data_start ;
  OPJ_BYTE *p_data_Lplt ;
  OPJ_UINT32 i ;
  OPJ_BYTE var_bytes[5] ;
  OPJ_UINT8 var_bytes_size ;
  OPJ_UINT32 packet_size ;
  OPJ_UINT8 __cil_tmp14 ;
  OPJ_UINT8 __cil_tmp15 ;
  OPJ_BYTE __cil_tmp16 ;
  OPJ_UINT32 __cil_tmp17 ;

  {
  {
#line 4702
  Zplt = (OPJ_BYTE )0;
#line 4704
  p_data_start = p_data;
#line 4705
  p_data_Lplt = p_data + 2;
#line 4710
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4711
  p_data += 2;
#line 4714
  p_data += 2;
#line 4716
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4717
  p_data ++;
#line 4719
  Lplt = (OPJ_UINT16 )3;
#line 4721
  i = (OPJ_UINT32 )0;
  }
  {
#line 4721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4721
    if (! (i < marker_info->packet_count)) {
#line 4721
      goto while_break;
    }
#line 4723
    var_bytes_size = (OPJ_UINT8 )0;
#line 4724
    packet_size = *(marker_info->p_packet_size + i);
#line 4727
    var_bytes[var_bytes_size] = (OPJ_BYTE )(packet_size & 127U);
#line 4728
    var_bytes_size ++;
#line 4729
    packet_size >>= 7;
    {
#line 4730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4730
      if (! (packet_size > 0U)) {
#line 4730
        goto while_break___0;
      }
#line 4731
      var_bytes[var_bytes_size] = (OPJ_BYTE )((packet_size & 127U) | 128U);
#line 4732
      var_bytes_size ++;
#line 4733
      packet_size >>= 7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4738
    if ((int )Lplt + (int )var_bytes_size > 65535) {
#line 4739
      if ((int )Zplt == 255) {
        {
#line 4740
        opj_event_msg(p_manager, 1, "More than 255 PLT markers would be needed for current tile-part !\nL\t\265U");
        }
#line 4742
        return (0);
      }
      {
#line 4746
      opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
#line 4749
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )65368, (OPJ_UINT32 )2);
#line 4750
      p_data += 2;
#line 4753
      p_data_Lplt = p_data;
#line 4754
      p_data += 2;
#line 4756
      Zplt ++;
#line 4757
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )Zplt, (OPJ_UINT32 )1);
#line 4758
      p_data ++;
#line 4760
      Lplt = (OPJ_UINT16 )3;
      }
    }
#line 4763
    Lplt = (OPJ_UINT16 )((int )Lplt + (int )var_bytes_size);
    {
#line 4766
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4766
      if (! ((int )var_bytes_size > 0)) {
#line 4766
        goto while_break___1;
      }
      {
#line 4767
      opj_write_bytes_LE(p_data, (OPJ_UINT32 )var_bytes[(int )var_bytes_size - 1],
                         (OPJ_UINT32 )1);
#line 4768
      p_data ++;
      }
#line 4766
      var_bytes_size --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4721
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4772
  *p_data_written = (OPJ_UINT32 )(p_data - p_data_start);
#line 4775
  opj_write_bytes_LE(p_data_Lplt, (OPJ_UINT32 )Lplt, (OPJ_UINT32 )2);
  }
#line 4777
  return (1);
}
}
#line 4780 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k , opj_tcd_t *p_tile_coder , OPJ_BYTE *p_data ,
                                  OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                  opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_UINT32 l_remaining_data ;
  opj_tcd_marker_info_t *marker_info ;
  opj_tcd_marker_info_t *__cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_UINT32 l_data_written_PLT ;
  OPJ_BYTE *p_PLT_buffer ;
  void *__cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;

  {
#line 4789
  l_cstr_info = (opj_codestream_info_t *)0;
#line 4791
  marker_info = (opj_tcd_marker_info_t *)((void *)0);
#line 4800
  if (total_data_size < 4U) {
    {
#line 4801
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOD marker\n");
    }
#line 4803
    return (0);
  }
  {
#line 4806
  opj_write_bytes_LE(p_data, (OPJ_UINT32 )65427, (OPJ_UINT32 )2);
#line 4810
  l_remaining_data = total_data_size - 4U;
#line 4813
  p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number;
#line 4815
  p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
  }
#line 4846
  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0U) {
#line 4847
    ((p_tile_coder->tcd_image)->tiles)->packno = (OPJ_UINT32 )0;
  }
#line 4855
  *p_data_written = (OPJ_UINT32 )0;
#line 4857
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
    {
#line 4858
    marker_info = opj_tcd_marker_info_create(p_j2k->m_specific_param.m_encoder.m_PLT);
    }
#line 4860
    if (marker_info == (void *)0) {
      {
#line 4861
      opj_event_msg(p_manager, 1, "Cannot encode tile: opj_tcd_marker_info_create() failed\n\220");
      }
#line 4863
      return (0);
    }
  }
#line 4867
  if (l_remaining_data < p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT) {
    {
#line 4869
    opj_event_msg(p_manager, 1, "Not enough bytes in output buffer to write SOD marker\n");
#line 4871
    opj_tcd_marker_info_destroy(marker_info);
    }
#line 4872
    return (0);
  }
  {
#line 4874
  l_remaining_data -= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;
#line 4876
  __cil_tmp12 = opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data + 2,
                                    p_data_written, l_remaining_data, l_cstr_info,
                                    marker_info, p_manager);
  }
#line 4876
  if (! __cil_tmp12) {
    {
#line 4881
    opj_event_msg(p_manager, 1, "Cannot encode tile\n\t\265U");
#line 4882
    opj_tcd_marker_info_destroy(marker_info);
    }
#line 4883
    return (0);
  }
#line 4887
  *p_data_written += (unsigned int )2;
#line 4889
  if (p_j2k->m_specific_param.m_encoder.m_PLT) {
    {
#line 4890
    l_data_written_PLT = (OPJ_UINT32 )0;
#line 4891
    __cil_tmp15 = opj_malloc((size_t )p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);
#line 4891
    p_PLT_buffer = (OPJ_BYTE *)__cil_tmp15;
    }
#line 4893
    if (! p_PLT_buffer) {
      {
#line 4894
      opj_event_msg(p_manager, 1, "Cannot allocate memory\n");
#line 4895
      opj_tcd_marker_info_destroy(marker_info);
      }
#line 4896
      return (0);
    }
    {
#line 4898
    __cil_tmp16 = opj_j2k_write_plt_in_memory(p_j2k, marker_info, p_PLT_buffer, & l_data_written_PLT,
                                              p_manager);
    }
#line 4898
    if (! __cil_tmp16) {
      {
#line 4903
      opj_tcd_marker_info_destroy(marker_info);
#line 4904
      opj_free(p_PLT_buffer);
      }
#line 4905
      return (0);
    }
    {
#line 4912
    memmove(p_data + l_data_written_PLT, p_data, (unsigned long )*p_data_written);
#line 4913
    memcpy(p_data, p_PLT_buffer, (unsigned long )l_data_written_PLT);
#line 4914
    opj_free(p_PLT_buffer);
#line 4915
    *p_data_written += l_data_written_PLT;
    }
  }
  {
#line 4918
  opj_tcd_marker_info_destroy(marker_info);
  }
#line 4920
  return (1);
}
}
#line 4923 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_sod(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T l_current_read_size ;
  opj_codestream_index_t *l_cstr_index ;
  OPJ_BYTE **l_current_data ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 *l_tile_len ;
  OPJ_BOOL l_sot_length_pb_detected ;
  OPJ_OFF_T __cil_tmp10 ;
  OPJ_OFF_T __cil_tmp11 ;
  void *__cil_tmp12 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp14 ;
  OPJ_OFF_T l_current_pos ;
  OPJ_OFF_T __cil_tmp16 ;
  OPJ_UINT32 l_current_tile_part ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_SIZE_T __cil_tmp19 ;

  {
#line 4929
  l_cstr_index = (opj_codestream_index_t *)0;
#line 4930
  l_current_data = (OPJ_BYTE **)0;
#line 4931
  l_tcp = (opj_tcp_t *)0;
#line 4932
  l_tile_len = (OPJ_UINT32 *)0;
#line 4933
  l_sot_length_pb_detected = 0;
#line 4940
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 4942
  if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
    {
#line 4947
    __cil_tmp10 = opj_stream_get_number_byte_left(p_stream);
#line 4947
    p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32 )(__cil_tmp10 - 2L);
    }
  } else
#line 4951
  if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2U) {
#line 4952
    p_j2k->m_specific_param.m_decoder.m_sot_length -= (unsigned int )2;
  }
#line 4958
  l_current_data = & l_tcp->m_data;
#line 4959
  l_tile_len = & l_tcp->m_data_size;
#line 4962
  if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
    {
#line 4965
    __cil_tmp11 = opj_stream_get_number_byte_left(p_stream);
    }
#line 4965
    if ((OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length > __cil_tmp11) {
#line 4967
      if (p_j2k->m_cp.strict) {
        {
#line 4968
        opj_event_msg(p_manager, 1, "Tile part length size inconsistent with stream length\n");
        }
#line 4970
        return (0);
      } else {
        {
#line 4972
        opj_event_msg(p_manager, 2, "Tile part length size inconsistent with stream length\n");
        }
      }
    }
#line 4976
    if (p_j2k->m_specific_param.m_decoder.m_sot_length > 4294967293U) {
      {
#line 4978
      opj_event_msg(p_manager, 1, "p_j2k->m_specific_param.m_decoder.m_sot_length > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRAL\t\265U");
      }
#line 4981
      return (0);
    }
#line 4986
    if (! *l_current_data) {
      {
#line 4990
      __cil_tmp12 = opj_malloc((size_t )(p_j2k->m_specific_param.m_decoder.m_sot_length + 2U));
#line 4990
      *l_current_data = (OPJ_BYTE *)__cil_tmp12;
      }
    } else {
#line 4994
      if (*l_tile_len > 4294967293U - p_j2k->m_specific_param.m_decoder.m_sot_length) {
        {
#line 4996
        opj_event_msg(p_manager, 1, "*l_tile_len > UINT_MAX - OPJ_COMMON_CBLK_DATA_EXTRA - p_j2k->m_specific_param.m_decoder.m_sot_length\220");
        }
#line 4999
        return (0);
      }
      {
#line 5002
      __cil_tmp14 = opj_realloc(*l_current_data, (size_t )((*l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length) + 2U));
#line 5002
      l_new_current_data = (OPJ_BYTE *)__cil_tmp14;
      }
#line 5005
      if (! l_new_current_data) {
        {
#line 5006
        opj_free(*l_current_data);
        }
      }
#line 5012
      *l_current_data = l_new_current_data;
    }
#line 5015
    if (*l_current_data == (OPJ_BYTE *)0) {
      {
#line 5016
      opj_event_msg(p_manager, 1, "Not enough memory to decode tile\n");
      }
#line 5017
      return (0);
    }
  } else {
#line 5020
    l_sot_length_pb_detected = 1;
  }
#line 5024
  l_cstr_index = p_j2k->cstr_index;
#line 5025
  if (l_cstr_index) {
    {
#line 5026
    __cil_tmp16 = opj_stream_tell(p_stream);
#line 5026
    l_current_pos = __cil_tmp16 - 2L;
#line 5028
    l_current_tile_part = (l_cstr_index->tile_index + p_j2k->m_current_tile_number)->current_tpsno;
#line 5030
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_header = l_current_pos;
#line 5033
    ((l_cstr_index->tile_index + p_j2k->m_current_tile_number)->tp_index + l_current_tile_part)->end_pos = (l_current_pos + (long )p_j2k->m_specific_param.m_decoder.m_sot_length) + 2L;
#line 5037
    __cil_tmp18 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, l_cstr_index,
                                       (OPJ_UINT32 )65427, l_current_pos, p_j2k->m_specific_param.m_decoder.m_sot_length + 2U);
    }
#line 5037
    if (0 == __cil_tmp18) {
      {
#line 5042
      opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
      }
#line 5043
      return (0);
    }
  }
#line 5050
  if (! l_sot_length_pb_detected) {
    {
#line 5051
    l_current_read_size = opj_stream_read_data(p_stream, *l_current_data + *l_tile_len,
                                               (OPJ_SIZE_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                               p_manager);
    }
  } else {
#line 5057
    l_current_read_size = (OPJ_SIZE_T )0;
  }
#line 5060
  if (l_current_read_size != (unsigned long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
#line 5061
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
  } else {
#line 5063
    p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 5066
  *l_tile_len += (OPJ_UINT32 )l_current_read_size;
#line 5068
  return (1);
}
}
#line 5071 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no , OPJ_UINT32 p_comp_no ,
                                  OPJ_UINT32 nb_comps , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_rgn_size ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5079
  l_current_data = (OPJ_BYTE *)0;
#line 5081
  l_cp = (opj_cp_t *)0;
#line 5082
  l_tcp = (opj_tcp_t *)0;
#line 5083
  l_tccp = (opj_tccp_t *)0;
#line 5091
  l_cp = & p_j2k->m_cp;
#line 5092
  l_tcp = l_cp->tcps + p_tile_no;
#line 5093
  l_tccp = l_tcp->tccps + p_comp_no;
#line 5095
  if (nb_comps <= 256U) {
#line 5096
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 5098
    l_comp_room = (OPJ_UINT32 )2;
  }
  {
#line 5101
  l_rgn_size = 6U + l_comp_room;
#line 5103
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5105
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65374, (OPJ_UINT32 )2);
#line 5107
  l_current_data += 2;
#line 5109
  opj_write_bytes_LE(l_current_data, l_rgn_size - 2U, (OPJ_UINT32 )2);
#line 5111
  l_current_data += 2;
#line 5113
  opj_write_bytes_LE(l_current_data, p_comp_no, l_comp_room);
#line 5115
  l_current_data += l_comp_room;
#line 5117
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )1);
#line 5119
  l_current_data ++;
#line 5121
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )l_tccp->roishift, (OPJ_UINT32 )1);
#line 5123
  l_current_data ++;
#line 5125
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_rgn_size, p_manager);
  }
#line 5125
  if (__cil_tmp13 != (unsigned long )l_rgn_size) {
#line 5128
    return (0);
  }
#line 5131
  return (1);
}
}
#line 5134 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_eoc(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_SIZE_T __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 5144
  opj_write_bytes_LE(p_j2k->m_specific_param.m_encoder.m_header_tile_data, (OPJ_UINT32 )65497,
                     (OPJ_UINT32 )2);
#line 5155
  __cil_tmp4 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 5155
  if (__cil_tmp4 != 2UL) {
#line 5157
    return (0);
  }
  {
#line 5160
  __cil_tmp5 = opj_stream_flush(p_stream, p_manager);
  }
#line 5160
  if (! __cil_tmp5) {
#line 5161
    return (0);
  }
#line 5164
  return (1);
}
}
#line 5175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_rgn(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  opj_image_t *l_image ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_comp_room ;
  OPJ_UINT32 l_comp_no ;
  OPJ_UINT32 l_roi_sty ;
  opj_tcp_t *tmp ;

  {
#line 5182
  l_image = (opj_image_t *)0;
#line 5184
  l_cp = (opj_cp_t *)0;
#line 5185
  l_tcp = (opj_tcp_t *)0;
#line 5193
  l_image = p_j2k->m_private_image;
#line 5194
  l_nb_comp = l_image->numcomps;
#line 5196
  if (l_nb_comp <= 256U) {
#line 5197
    l_comp_room = (OPJ_UINT32 )1;
  } else {
#line 5199
    l_comp_room = (OPJ_UINT32 )2;
  }
#line 5202
  if (p_header_size != 2U + l_comp_room) {
    {
#line 5203
    opj_event_msg(p_manager, 1, "Error reading RGN marker\n");
    }
#line 5204
    return (0);
  }
#line 5207
  l_cp = & p_j2k->m_cp;
#line 5208
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5208
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 5208
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
  {
#line 5208
  l_tcp = tmp;
#line 5212
  opj_read_bytes_LE(p_header_data, & l_comp_no, l_comp_room);
#line 5213
  p_header_data += l_comp_room;
#line 5214
  opj_read_bytes_LE(p_header_data, & l_roi_sty, (OPJ_UINT32 )1);
#line 5216
  p_header_data ++;
  }
#line 5234
  if (l_comp_no >= l_nb_comp) {
    {
#line 5235
    opj_event_msg(p_manager, 1, "bad component number in RGN (%d when there are only %d)\n\230\001",
                  l_comp_no, l_nb_comp);
    }
#line 5238
    return (0);
  }
  {
#line 5241
  opj_read_bytes_LE(p_header_data, (OPJ_UINT32 *)(& (l_tcp->tccps + l_comp_no)->roishift),
                    (OPJ_UINT32 )1);
#line 5243
  p_header_data ++;
  }
#line 5245
  return (1);
}
}
#line 5249 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_tp_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5251
  return ((OPJ_FLOAT32 )((p_tcp->m_nb_tile_parts - 1U) * 14U));
}
}
#line 5254 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_FLOAT32 opj_j2k_get_default_stride(opj_tcp_t *p_tcp ) 
{ 


  {
#line 5257
  return ((OPJ_FLOAT32 )0);
}
}
#line 5260 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_rates(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  opj_tcp_t *l_tcp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  OPJ_INT32 l_x0 ;
  OPJ_INT32 l_y0 ;
  OPJ_INT32 l_x1 ;
  OPJ_INT32 l_y1 ;
  OPJ_FLOAT32 *l_rates ;
  OPJ_FLOAT32 l_sot_remove ;
  OPJ_UINT32 l_bits_empty ;
  OPJ_UINT32 l_size_pixel ;
  OPJ_UINT64 l_tile_size ;
  OPJ_UINT32 l_last_res ;
  OPJ_FLOAT32 (*l_tp_stride_func)(opj_tcp_t * ) ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_FLOAT32 l_offset ;
  OPJ_FLOAT32 __cil_tmp24 ;
  OPJ_INT32 __cil_tmp25 ;
  OPJ_INT32 __cil_tmp26 ;
  OPJ_INT32 __cil_tmp27 ;
  OPJ_INT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
  {
#line 5264
  l_cp = (opj_cp_t *)0;
#line 5265
  l_image = (opj_image_t *)0;
#line 5266
  l_tcp = (opj_tcp_t *)0;
#line 5267
  l_img_comp = (opj_image_comp_t *)0;
#line 5271
  l_rates = (OPJ_FLOAT32 *)0;
#line 5274
  l_tile_size = (OPJ_UINT64 )0;
#line 5276
  l_tp_stride_func = (OPJ_FLOAT32 (*)(opj_tcp_t * ))0;
#line 5285
  l_cp = & p_j2k->m_cp;
#line 5286
  l_image = p_j2k->m_private_image;
#line 5287
  l_tcp = l_cp->tcps;
#line 5289
  l_bits_empty = (8U * (l_image->comps)->dx) * (l_image->comps)->dy;
#line 5290
  l_size_pixel = l_image->numcomps * (l_image->comps)->prec;
#line 5291
  __cil_tmp22 = opj_stream_tell(p_stream);
#line 5291
  l_sot_remove = (OPJ_FLOAT32 )__cil_tmp22 / (OPJ_FLOAT32 )(l_cp->th * l_cp->tw);
  }
#line 5294
  if (l_cp->m_specific_param.m_enc.m_tp_on) {
#line 5295
    l_tp_stride_func = & opj_j2k_get_tp_stride;
  } else {
#line 5297
    l_tp_stride_func = & opj_j2k_get_default_stride;
  }
#line 5300
  i = (OPJ_UINT32 )0;
  {
#line 5300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5300
    if (! (i < l_cp->th)) {
#line 5300
      goto while_break;
    }
#line 5301
    j = (OPJ_UINT32 )0;
    {
#line 5301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5301
      if (! (j < l_cp->tw)) {
#line 5301
        goto while_break___0;
      }
      {
#line 5302
      __cil_tmp24 = (*l_tp_stride_func)(l_tcp);
#line 5302
      l_offset = (OPJ_FLOAT32 )__cil_tmp24 / (OPJ_FLOAT32 )l_tcp->numlayers;
#line 5306
      l_x0 = opj_int_max((OPJ_INT32 )(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32 )l_image->x0);
#line 5308
      l_y0 = opj_int_max((OPJ_INT32 )(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32 )l_image->y0);
#line 5310
      l_x1 = opj_int_min((OPJ_INT32 )(l_cp->tx0 + (j + 1U) * l_cp->tdx), (OPJ_INT32 )l_image->x1);
#line 5312
      l_y1 = opj_int_min((OPJ_INT32 )(l_cp->ty0 + (i + 1U) * l_cp->tdy), (OPJ_INT32 )l_image->y1);
#line 5315
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
#line 5318
      k = (OPJ_UINT32 )0;
      }
      {
#line 5318
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5318
        if (! (k < l_tcp->numlayers)) {
#line 5318
          goto while_break___1;
        }
#line 5319
        if (*l_rates > 0.f) {
#line 5320
          *l_rates = (OPJ_FLOAT32 )((((OPJ_FLOAT64 )l_size_pixel * (double )((OPJ_UINT32 )(l_x1 - l_x0))) * (double )((OPJ_UINT32 )(l_y1 - l_y0))) / (double )(*l_rates * (OPJ_FLOAT32 )l_bits_empty)) - l_offset;
        }
#line 5328
        l_rates ++;
#line 5318
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5331
      l_tcp ++;
#line 5301
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5336
  l_tcp = l_cp->tcps;
#line 5338
  i = (OPJ_UINT32 )0;
  {
#line 5338
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5338
    if (! (i < l_cp->th)) {
#line 5338
      goto while_break___2;
    }
#line 5339
    j = (OPJ_UINT32 )0;
    {
#line 5339
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5339
      if (! (j < l_cp->tw)) {
#line 5339
        goto while_break___3;
      }
#line 5340
      l_rates = (OPJ_FLOAT32 *)l_tcp->rates;
#line 5342
      if (*l_rates > 0.f) {
#line 5343
        *l_rates -= l_sot_remove;
#line 5345
        if (*l_rates < 30.f) {
#line 5346
          *l_rates = 30.f;
        }
      }
#line 5350
      l_rates ++;
#line 5352
      l_last_res = l_tcp->numlayers - 1U;
#line 5354
      k = (OPJ_UINT32 )1;
      {
#line 5354
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5354
        if (! (k < l_last_res)) {
#line 5354
          goto while_break___4;
        }
#line 5356
        if (*l_rates > 0.f) {
#line 5357
          *l_rates -= l_sot_remove;
#line 5359
          if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5360
            *l_rates = *(l_rates - 1) + 20.f;
          }
        }
#line 5364
        l_rates ++;
#line 5354
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5367
      if (*l_rates > 0.f) {
#line 5368
        *l_rates -= l_sot_remove + 2.f;
#line 5370
        if (*l_rates < *(l_rates - 1) + 10.f) {
#line 5371
          *l_rates = *(l_rates - 1) + 20.f;
        }
      }
#line 5375
      l_tcp ++;
#line 5339
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 5338
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5379
  l_img_comp = l_image->comps;
#line 5380
  l_tile_size = (OPJ_UINT64 )0;
#line 5382
  i = (OPJ_UINT32 )0;
  {
#line 5382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5382
    if (! (i < l_image->numcomps)) {
#line 5382
      goto while_break___5;
    }
    {
#line 5383
    __cil_tmp30 = opj_uint_ceildiv(l_cp->tdy, l_img_comp->dy);
    }
    {
#line 5383
    __cil_tmp29 = opj_uint_ceildiv(l_cp->tdx, l_img_comp->dx);
    }
#line 5383
    l_tile_size += ((OPJ_UINT64 )__cil_tmp29 * (unsigned long )__cil_tmp30) * (unsigned long )l_img_comp->prec;
#line 5389
    l_img_comp ++;
#line 5382
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 5398
  l_tile_size = (OPJ_UINT64 )(((double )l_tile_size * 1.4) / (double )8);
#line 5402
  l_tile_size += (unsigned long )500;
#line 5404
  __cil_tmp31 = opj_j2k_get_specific_header_sizes(p_j2k);
  }
#line 5404
  l_tile_size += (unsigned long )__cil_tmp31;
#line 5406
  if (l_tile_size > 4294967295UL) {
#line 5407
    l_tile_size = (OPJ_UINT64 )4294967295U;
  }
  {
#line 5410
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )l_tile_size;
#line 5411
  __cil_tmp32 = opj_malloc((size_t )p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
#line 5411
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)__cil_tmp32;
  }
#line 5413
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == (OPJ_BYTE *)0) {
    {
#line 5414
    opj_event_msg(p_manager, 1, "Not enough memory to allocate m_encoded_tile_data. %u MB required\n",
                  (OPJ_UINT32 )((l_tile_size / 1024UL) / 1024UL));
    }
#line 5417
    return (0);
  }
#line 5420
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 5421
    __cil_tmp33 = opj_malloc((size_t )(6U * p_j2k->m_specific_param.m_encoder.m_total_tile_parts));
#line 5421
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)__cil_tmp33;
    }
#line 5424
    if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
#line 5425
      return (0);
    }
#line 5428
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
  }
#line 5432
  return (1);
}
}
#line 5487 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                       struct opj_event_mgr *p_manager ) 
{ 
  OPJ_OFF_T __cil_tmp4 ;

  {
  {
#line 5498
  (p_j2k->cstr_index)->main_head_end = opj_stream_tell(p_stream);
  }
#line 5500
  return (1);
}
}
#line 5503 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_data_group(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                             struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_record ;
  opj_tcp_t *l_tcp ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 5517
  __cil_tmp8 = opj_j2k_write_cbd(p_j2k, p_stream, p_manager);
  }
#line 5517
  if (! __cil_tmp8) {
#line 5518
    return (0);
  }
#line 5521
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 5522
  l_mct_record = l_tcp->m_mct_records;
#line 5524
  i = (OPJ_UINT32 )0;
  {
#line 5524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5524
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5524
      goto while_break;
    }
    {
#line 5526
    __cil_tmp9 = opj_j2k_write_mct_record(p_j2k, l_mct_record, p_stream, p_manager);
    }
#line 5526
    if (! __cil_tmp9) {
#line 5527
      return (0);
    }
#line 5530
    l_mct_record ++;
#line 5524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5533
  l_mcc_record = l_tcp->m_mcc_records;
#line 5535
  i = (OPJ_UINT32 )0;
  {
#line 5535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5535
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5535
      goto while_break___0;
    }
    {
#line 5537
    __cil_tmp10 = opj_j2k_write_mcc_record(p_j2k, l_mcc_record, p_stream, p_manager);
    }
#line 5537
    if (! __cil_tmp10) {
#line 5538
      return (0);
    }
#line 5541
    l_mcc_record ++;
#line 5535
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5544
  __cil_tmp11 = opj_j2k_write_mco(p_j2k, p_stream, p_manager);
  }
#line 5544
  if (! __cil_tmp11) {
#line 5545
    return (0);
  }
#line 5548
  return (1);
}
}
#line 5551 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5563
  compno = (OPJ_UINT32 )1;
  {
#line 5563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5563
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5563
      goto while_break;
    }
    {
#line 5565
    __cil_tmp5 = opj_j2k_compare_coc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5565
    if (! __cil_tmp5) {
      {
#line 5566
      __cil_tmp6 = opj_j2k_write_coc(p_j2k, compno, p_stream, p_manager);
      }
#line 5566
      if (! __cil_tmp6) {
#line 5567
        return (0);
      }
    }
#line 5563
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5572
  return (1);
}
}
#line 5575 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5587
  compno = (OPJ_UINT32 )1;
  {
#line 5587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5587
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5587
      goto while_break;
    }
    {
#line 5589
    __cil_tmp5 = opj_j2k_compare_qcc(p_j2k, (OPJ_UINT32 )0, compno);
    }
#line 5589
    if (! __cil_tmp5) {
      {
#line 5590
      __cil_tmp6 = opj_j2k_write_qcc(p_j2k, compno, p_stream, p_manager);
      }
#line 5590
      if (! __cil_tmp6) {
#line 5591
        return (0);
      }
    }
#line 5587
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5595
  return (1);
}
}
#line 5598 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_regions(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                      struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_BOOL __cil_tmp6 ;

  {
#line 5603
  l_tccp = (opj_tccp_t *)0;
#line 5610
  l_tccp = (p_j2k->m_cp.tcps)->tccps;
#line 5612
  compno = (OPJ_UINT32 )0;
  {
#line 5612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5612
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 5612
      goto while_break;
    }
#line 5613
    if (l_tccp->roishift) {
      {
#line 5615
      __cil_tmp6 = opj_j2k_write_rgn(p_j2k, (OPJ_UINT32 )0, compno, (p_j2k->m_private_image)->numcomps,
                                     p_stream, p_manager);
      }
#line 5615
      if (! __cil_tmp6) {
#line 5617
        return (0);
      }
    }
#line 5621
    l_tccp ++;
#line 5612
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5624
  return (1);
}
}
#line 5627 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_epc(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  OPJ_OFF_T __cil_tmp5 ;

  {
#line 5631
  l_cstr_index = (opj_codestream_index_t *)0;
#line 5640
  l_cstr_index = p_j2k->cstr_index;
#line 5641
  if (l_cstr_index) {
    {
#line 5642
    __cil_tmp5 = opj_stream_tell(p_stream);
#line 5642
    l_cstr_index->codestream_size = (OPJ_UINT64 )__cil_tmp5;
#line 5647
    l_cstr_index->codestream_size -= (OPJ_UINT64 )l_cstr_index->main_head_start;
    }
  }
#line 5664
  return (1);
}
}
#line 5667 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_unk(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                 OPJ_UINT32 *output_marker , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_unknown_marker ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_UINT32 l_size_unk ;
  OPJ_SIZE_T __cil_tmp8 ;
  struct opj_dec_memory_marker_handler *__cil_tmp9 ;
  OPJ_BOOL res ;
  OPJ_OFF_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 5675
  l_size_unk = (OPJ_UINT32 )2;
#line 5682
  opj_event_msg(p_manager, 2, "Unknown marker\n");
  }
  {
#line 5684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5684
    if (! 1) {
#line 5684
      goto while_break;
    }
    {
#line 5686
    __cil_tmp8 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                      (OPJ_SIZE_T )2, p_manager);
    }
#line 5686
    if (__cil_tmp8 != 2UL) {
      {
#line 5688
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 5689
      return (0);
    }
    {
#line 5693
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_unknown_marker,
                      (OPJ_UINT32 )2);
    }
#line 5696
    if (! (l_unknown_marker < 65280U)) {
      {
#line 5699
      l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
      }
#line 5701
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 5702
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\nN\t\265U");
        }
#line 5704
        return (0);
      } else
#line 5706
      if (l_marker_handler->id != 0U) {
#line 5708
        if (l_marker_handler->id != 65424U) {
          {
#line 5709
          __cil_tmp11 = opj_stream_tell(p_stream);
#line 5709
          __cil_tmp12 = opj_j2k_add_mhmarker(p_j2k->cstr_index, (OPJ_UINT32 )0, (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp11 - l_size_unk),
                                             l_size_unk);
#line 5709
          res = __cil_tmp12;
          }
#line 5712
          if (res == 0) {
            {
#line 5713
            opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n\t\265U");
            }
#line 5714
            return (0);
          }
        }
#line 5717
        goto while_break;
      } else {
#line 5719
        l_size_unk += (unsigned int )2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5725
  *output_marker = l_marker_handler->id;
#line 5727
  return (1);
}
}
#line 5730 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mct_record(opj_j2k_t *p_j2k , opj_mct_data_t *p_mct_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_mct_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tmp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp9 ;
  OPJ_SIZE_T __cil_tmp10 ;

  {
#line 5736
  l_current_data = (OPJ_BYTE *)0;
#line 5744
  l_mct_size = 10U + p_mct_record->m_data_size;
#line 5746
  if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5747
    __cil_tmp9 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                             (size_t )l_mct_size);
#line 5747
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp9;
    }
#line 5749
    if (! new_header_tile_data) {
      {
#line 5750
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5751
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5752
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5753
      opj_event_msg(p_manager, 1, "Not enough memory to write MCT marker\n");
      }
#line 5754
      return (0);
    }
#line 5756
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5757
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
  }
  {
#line 5760
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5762
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65396, (OPJ_UINT32 )2);
#line 5764
  l_current_data += 2;
#line 5766
  opj_write_bytes_LE(l_current_data, l_mct_size - 2U, (OPJ_UINT32 )2);
#line 5768
  l_current_data += 2;
#line 5770
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5772
  l_current_data += 2;
#line 5775
  l_tmp = ((p_mct_record->m_index & 255U) | ((unsigned int )p_mct_record->m_array_type << 8)) | ((unsigned int )p_mct_record->m_element_type << 10);
#line 5778
  opj_write_bytes_LE(l_current_data, l_tmp, (OPJ_UINT32 )2);
#line 5779
  l_current_data += 2;
#line 5781
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5783
  l_current_data += 2;
#line 5785
  memcpy(l_current_data, p_mct_record->m_data, (unsigned long )p_mct_record->m_data_size);
#line 5787
  __cil_tmp10 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mct_size, p_manager);
  }
#line 5787
  if (__cil_tmp10 != (unsigned long )l_mct_size) {
#line 5790
    return (0);
  }
#line 5793
  return (1);
}
}
#line 5804 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mct(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_data ;
  opj_tcp_t *tmp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp12 ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  void *__cil_tmp14 ;

  {
#line 5811
  l_tcp = (opj_tcp_t *)0;
#line 5820
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 5820
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 5820
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 5820
  l_tcp = tmp;
#line 5824
  if (p_header_size < 2U) {
    {
#line 5825
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5826
    return (0);
  }
  {
#line 5830
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5831
  p_header_data += 2;
  }
#line 5832
  if (l_tmp != 0U) {
    {
#line 5833
    opj_event_msg(p_manager, 2, "Cannot take in charge mct data within multiple MCT records\n\t\265U");
    }
#line 5835
    return (1);
  }
#line 5838
  if (p_header_size <= 6U) {
    {
#line 5839
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n\225N\t\265U");
    }
#line 5840
    return (0);
  }
  {
#line 5844
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5845
  p_header_data += 2;
#line 5847
  l_indix = l_tmp & 255U;
#line 5848
  l_mct_data = l_tcp->m_mct_records;
#line 5850
  i = (OPJ_UINT32 )0;
  }
  {
#line 5850
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5850
    if (! (i < l_tcp->m_nb_mct_records)) {
#line 5850
      goto while_break;
    }
#line 5851
    if (l_mct_data->m_index == l_indix) {
#line 5852
      goto while_break;
    }
#line 5854
    l_mct_data ++;
#line 5850
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5858
  if (i == l_tcp->m_nb_mct_records) {
#line 5859
    if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
      {
#line 5861
      l_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 5863
      __cil_tmp12 = opj_realloc(l_tcp->m_mct_records, (unsigned long )l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 5863
      new_mct_records = (opj_mct_data_t *)__cil_tmp12;
      }
#line 5865
      if (! new_mct_records) {
        {
#line 5866
        opj_free(l_tcp->m_mct_records);
#line 5867
        l_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 5868
        l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 5869
        l_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
#line 5870
        opj_event_msg(p_manager, 1, "Not enough memory to read MCT marker\n");
        }
#line 5871
        return (0);
      }
#line 5876
      if (new_mct_records != l_tcp->m_mct_records) {
#line 5877
        i = (OPJ_UINT32 )0;
        {
#line 5877
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 5877
          if (! (i < l_tcp->m_nb_mcc_records)) {
#line 5877
            goto while_break___0;
          }
#line 5878
          l_mcc_record = l_tcp->m_mcc_records + i;
#line 5880
          if (l_mcc_record->m_decorrelation_array) {
#line 5881
            l_mcc_record->m_decorrelation_array = new_mct_records + (l_mcc_record->m_decorrelation_array - l_tcp->m_mct_records);
          }
#line 5886
          if (l_mcc_record->m_offset_array) {
#line 5887
            l_mcc_record->m_offset_array = new_mct_records + (l_mcc_record->m_offset_array - l_tcp->m_mct_records);
          }
#line 5877
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 5895
      l_tcp->m_mct_records = new_mct_records;
#line 5896
      l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5897
      memset(l_mct_data, 0, (unsigned long )(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 5901
    l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
#line 5902
    (l_tcp->m_nb_mct_records) ++;
  }
#line 5905
  if (l_mct_data->m_data) {
    {
#line 5906
    opj_free(l_mct_data->m_data);
#line 5907
    l_mct_data->m_data = (OPJ_BYTE *)0;
#line 5908
    l_mct_data->m_data_size = (OPJ_UINT32 )0;
    }
  }
  {
#line 5911
  l_mct_data->m_index = l_indix;
#line 5912
  l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE )((l_tmp >> 8) & 3U);
#line 5913
  l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )((l_tmp >> 10) & 3U);
#line 5915
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 5916
  p_header_data += 2;
  }
#line 5917
  if (l_tmp != 0U) {
    {
#line 5918
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple MCT markers\n");
    }
#line 5920
    return (1);
  }
  {
#line 5923
  p_header_size -= (unsigned int )6;
#line 5925
  __cil_tmp14 = opj_malloc((size_t )p_header_size);
#line 5925
  l_mct_data->m_data = (OPJ_BYTE *)__cil_tmp14;
  }
#line 5926
  if (! l_mct_data->m_data) {
    {
#line 5927
    opj_event_msg(p_manager, 1, "Error reading MCT marker\n");
    }
#line 5928
    return (0);
  }
  {
#line 5930
  memcpy(l_mct_data->m_data, p_header_data, (unsigned long )p_header_size);
#line 5932
  l_mct_data->m_data_size = p_header_size;
  }
#line 5934
  return (1);
}
}
#line 5937 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mcc_record(opj_j2k_t *p_j2k , struct opj_simple_mcc_decorrelation_data *p_mcc_record ,
                                         struct opj_stream_private *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_mcc_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_nb_bytes_for_comp ;
  OPJ_UINT32 l_mask ;
  OPJ_UINT32 l_tmcc ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp12 ;
  OPJ_SIZE_T __cil_tmp13 ;

  {
#line 5944
  l_current_data = (OPJ_BYTE *)0;
#line 5954
  if (p_mcc_record->m_nb_comps > 255U) {
#line 5955
    l_nb_bytes_for_comp = (OPJ_UINT32 )2;
#line 5956
    l_mask = (OPJ_UINT32 )32768;
  } else {
#line 5958
    l_nb_bytes_for_comp = (OPJ_UINT32 )1;
#line 5959
    l_mask = (OPJ_UINT32 )0;
  }
#line 5962
  l_mcc_size = (p_mcc_record->m_nb_comps * 2U) * l_nb_bytes_for_comp + 19U;
#line 5963
  if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 5964
    __cil_tmp12 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mcc_size);
#line 5964
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp12;
    }
#line 5966
    if (! new_header_tile_data) {
      {
#line 5967
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 5968
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 5969
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 5970
      opj_event_msg(p_manager, 1, "Not enough memory to write MCC marker\n");
      }
#line 5971
      return (0);
    }
#line 5973
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 5974
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
  }
  {
#line 5977
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 5979
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65397, (OPJ_UINT32 )2);
#line 5981
  l_current_data += 2;
#line 5983
  opj_write_bytes_LE(l_current_data, l_mcc_size - 2U, (OPJ_UINT32 )2);
#line 5985
  l_current_data += 2;
#line 5988
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5990
  l_current_data += 2;
#line 5992
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_index, (OPJ_UINT32 )1);
#line 5994
  l_current_data ++;
#line 5997
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )0, (OPJ_UINT32 )2);
#line 5999
  l_current_data += 2;
#line 6001
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )2);
#line 6003
  l_current_data += 2;
#line 6005
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )1, (OPJ_UINT32 )1);
#line 6007
  l_current_data ++;
#line 6009
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 6011
  l_current_data += 2;
#line 6013
  i = (OPJ_UINT32 )0;
  }
  {
#line 6013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6013
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 6013
      goto while_break;
    }
    {
#line 6014
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 6016
    l_current_data += l_nb_bytes_for_comp;
    }
#line 6013
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6019
  opj_write_bytes_LE(l_current_data, p_mcc_record->m_nb_comps | l_mask, (OPJ_UINT32 )2);
#line 6021
  l_current_data += 2;
#line 6023
  i = (OPJ_UINT32 )0;
  }
  {
#line 6023
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6023
    if (! (i < p_mcc_record->m_nb_comps)) {
#line 6023
      goto while_break___0;
    }
    {
#line 6024
    opj_write_bytes_LE(l_current_data, i, l_nb_bytes_for_comp);
#line 6026
    l_current_data += l_nb_bytes_for_comp;
    }
#line 6023
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6029
  l_tmcc = (! p_mcc_record->m_is_irreversible & 1U) << 16;
#line 6031
  if (p_mcc_record->m_decorrelation_array) {
#line 6032
    l_tmcc |= (p_mcc_record->m_decorrelation_array)->m_index;
  }
#line 6035
  if (p_mcc_record->m_offset_array) {
#line 6036
    l_tmcc |= (p_mcc_record->m_offset_array)->m_index << 8;
  }
  {
#line 6039
  opj_write_bytes_LE(l_current_data, l_tmcc, (OPJ_UINT32 )3);
#line 6041
  l_current_data += 3;
#line 6043
  __cil_tmp13 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mcc_size, p_manager);
  }
#line 6043
  if (__cil_tmp13 != (unsigned long )l_mcc_size) {
#line 6046
    return (0);
  }
#line 6049
  return (1);
}
}
#line 6052 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mcc(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_indix ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 l_nb_collections ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_bytes_by_comp ;
  OPJ_BOOL l_new_mcc ;
  opj_tcp_t *tmp ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp18 ;

  {
#line 6066
  l_new_mcc = 0;
#line 6073
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 6073
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 6073
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6073
  l_tcp = tmp;
#line 6077
  if (p_header_size < 2U) {
    {
#line 6078
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n\317N\t\265U");
    }
#line 6079
    return (0);
  }
  {
#line 6083
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 6084
  p_header_data += 2;
  }
#line 6085
  if (l_tmp != 0U) {
    {
#line 6086
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\n");
    }
#line 6088
    return (1);
  }
#line 6091
  if (p_header_size < 7U) {
    {
#line 6092
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 6093
    return (0);
  }
  {
#line 6096
  opj_read_bytes_LE(p_header_data, & l_indix, (OPJ_UINT32 )1);
#line 6098
  p_header_data ++;
#line 6100
  l_mcc_record = l_tcp->m_mcc_records;
#line 6102
  i = (OPJ_UINT32 )0;
  }
  {
#line 6102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6102
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 6102
      goto while_break;
    }
#line 6103
    if (l_mcc_record->m_index == l_indix) {
#line 6104
      goto while_break;
    }
#line 6106
    l_mcc_record ++;
#line 6102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6110
  if (i == l_tcp->m_nb_mcc_records) {
#line 6111
    if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
      {
#line 6113
      l_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 6115
      __cil_tmp18 = opj_realloc(l_tcp->m_mcc_records, (unsigned long )l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 6115
      new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp18;
      }
#line 6118
      if (! new_mcc_records) {
        {
#line 6119
        opj_free(l_tcp->m_mcc_records);
#line 6120
        l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 6121
        l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 6122
        l_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
#line 6123
        opj_event_msg(p_manager, 1, "Not enough memory to read MCC marker\n");
        }
#line 6124
        return (0);
      }
      {
#line 6126
      l_tcp->m_mcc_records = new_mcc_records;
#line 6127
      l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 6128
      memset(l_mcc_record, 0, (unsigned long )(l_tcp->m_nb_max_mcc_records - l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
      }
    }
#line 6131
    l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
#line 6132
    l_new_mcc = 1;
  }
  {
#line 6134
  l_mcc_record->m_index = l_indix;
#line 6137
  opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )2);
#line 6138
  p_header_data += 2;
  }
#line 6139
  if (l_tmp != 0U) {
    {
#line 6140
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple data spanning\nU");
    }
#line 6142
    return (1);
  }
  {
#line 6145
  opj_read_bytes_LE(p_header_data, & l_nb_collections, (OPJ_UINT32 )2);
#line 6147
  p_header_data += 2;
  }
#line 6149
  if (l_nb_collections > 1U) {
    {
#line 6150
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple collections\n");
    }
#line 6152
    return (1);
  }
#line 6155
  p_header_size -= (unsigned int )7;
#line 6157
  i = (OPJ_UINT32 )0;
  {
#line 6157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6157
    if (! (i < l_nb_collections)) {
#line 6157
      goto while_break___0;
    }
#line 6158
    if (p_header_size < 3U) {
      {
#line 6159
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n\032O\t\265U");
      }
#line 6160
      return (0);
    }
    {
#line 6163
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 6165
    p_header_data ++;
    }
#line 6167
    if (l_tmp != 1U) {
      {
#line 6168
      opj_event_msg(p_manager, 2, "Cannot take in charge collections other than array decorrelation\n\241O\t\265U");
      }
#line 6170
      return (1);
    }
    {
#line 6173
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 6175
    p_header_data += 2;
#line 6176
    p_header_size -= (unsigned int )3;
#line 6178
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 6179
    l_mcc_record->m_nb_comps = l_nb_comps & 32767U;
    }
#line 6181
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U) {
      {
#line 6182
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 6183
      return (0);
    }
#line 6186
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2U;
#line 6188
    j = (OPJ_UINT32 )0;
    {
#line 6188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6188
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 6188
        goto while_break___1;
      }
      {
#line 6189
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 6191
      p_header_data += l_nb_bytes_by_comp;
      }
#line 6193
      if (l_tmp != j) {
        {
#line 6194
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 6196
        return (1);
      }
#line 6188
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 6200
    opj_read_bytes_LE(p_header_data, & l_nb_comps, (OPJ_UINT32 )2);
#line 6201
    p_header_data += 2;
#line 6203
    l_nb_bytes_by_comp = 1U + (l_nb_comps >> 15);
#line 6204
    l_nb_comps &= (unsigned int )32767;
    }
#line 6206
    if (l_nb_comps != l_mcc_record->m_nb_comps) {
      {
#line 6207
      opj_event_msg(p_manager, 2, "Cannot take in charge collections without same number of indixes\n");
      }
#line 6209
      return (1);
    }
#line 6212
    if (p_header_size < l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U) {
      {
#line 6213
      opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
      }
#line 6214
      return (0);
    }
#line 6217
    p_header_size -= l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3U;
#line 6219
    j = (OPJ_UINT32 )0;
    {
#line 6219
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6219
      if (! (j < l_mcc_record->m_nb_comps)) {
#line 6219
        goto while_break___2;
      }
      {
#line 6220
      opj_read_bytes_LE(p_header_data, & l_tmp, l_nb_bytes_by_comp);
#line 6222
      p_header_data += l_nb_bytes_by_comp;
      }
#line 6224
      if (l_tmp != j) {
        {
#line 6225
        opj_event_msg(p_manager, 2, "Cannot take in charge collections with indix shuffle\n");
        }
#line 6227
        return (1);
      }
#line 6219
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6231
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )3);
#line 6232
    p_header_data += 3;
#line 6234
    l_mcc_record->m_is_irreversible = ! ((l_tmp >> 16) & 1U);
#line 6235
    l_mcc_record->m_decorrelation_array = (opj_mct_data_t *)0;
#line 6236
    l_mcc_record->m_offset_array = (opj_mct_data_t *)0;
#line 6238
    l_indix = l_tmp & 255U;
    }
#line 6239
    if (l_indix != 0U) {
#line 6240
      l_mct_data = l_tcp->m_mct_records;
#line 6241
      j = (OPJ_UINT32 )0;
      {
#line 6241
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6241
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 6241
          goto while_break___3;
        }
#line 6242
        if (l_mct_data->m_index == l_indix) {
#line 6243
          l_mcc_record->m_decorrelation_array = l_mct_data;
#line 6244
          goto while_break___3;
        }
#line 6246
        l_mct_data ++;
#line 6241
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6249
      if (l_mcc_record->m_decorrelation_array == (opj_mct_data_t *)0) {
        {
#line 6250
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6251
        return (0);
      }
    }
#line 6255
    l_indix = (l_tmp >> 8) & 255U;
#line 6256
    if (l_indix != 0U) {
#line 6257
      l_mct_data = l_tcp->m_mct_records;
#line 6258
      j = (OPJ_UINT32 )0;
      {
#line 6258
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 6258
        if (! (j < l_tcp->m_nb_mct_records)) {
#line 6258
          goto while_break___4;
        }
#line 6259
        if (l_mct_data->m_index == l_indix) {
#line 6260
          l_mcc_record->m_offset_array = l_mct_data;
#line 6261
          goto while_break___4;
        }
#line 6263
        l_mct_data ++;
#line 6258
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 6266
      if (l_mcc_record->m_offset_array == (opj_mct_data_t *)0) {
        {
#line 6267
        opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
        }
#line 6268
        return (0);
      }
    }
#line 6157
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6273
  if (p_header_size != 0U) {
    {
#line 6274
    opj_event_msg(p_manager, 1, "Error reading MCC marker\n");
    }
#line 6275
    return (0);
  }
#line 6278
  if (l_new_mcc) {
#line 6279
    (l_tcp->m_nb_mcc_records) ++;
  }
#line 6282
  return (1);
}
}
#line 6285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_mco(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_mco_size ;
  opj_tcp_t *l_tcp ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  OPJ_UINT32 i ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 6290
  l_current_data = (OPJ_BYTE *)0;
#line 6292
  l_tcp = (opj_tcp_t *)0;
#line 6301
  l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
#line 6303
  l_mco_size = 5U + l_tcp->m_nb_mcc_records;
#line 6304
  if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6306
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_mco_size);
#line 6306
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 6308
    if (! new_header_tile_data) {
      {
#line 6309
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6310
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6311
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6312
      opj_event_msg(p_manager, 1, "Not enough memory to write MCO marker\n");
      }
#line 6313
      return (0);
    }
#line 6315
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6316
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
  }
  {
#line 6318
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6321
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65399, (OPJ_UINT32 )2);
#line 6322
  l_current_data += 2;
#line 6324
  opj_write_bytes_LE(l_current_data, l_mco_size - 2U, (OPJ_UINT32 )2);
#line 6325
  l_current_data += 2;
#line 6327
  opj_write_bytes_LE(l_current_data, l_tcp->m_nb_mcc_records, (OPJ_UINT32 )1);
#line 6329
  l_current_data ++;
#line 6331
  l_mcc_record = l_tcp->m_mcc_records;
#line 6332
  i = (OPJ_UINT32 )0;
  }
  {
#line 6332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6332
    if (! (i < l_tcp->m_nb_mcc_records)) {
#line 6332
      goto while_break;
    }
    {
#line 6333
    opj_write_bytes_LE(l_current_data, l_mcc_record->m_index, (OPJ_UINT32 )1);
#line 6335
    l_current_data ++;
#line 6336
    l_mcc_record ++;
    }
#line 6332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6339
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_mco_size, p_manager);
  }
#line 6339
  if (__cil_tmp11 != (unsigned long )l_mco_size) {
#line 6342
    return (0);
  }
#line 6345
  return (1);
}
}
#line 6356 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_mco(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 i ;
  OPJ_UINT32 l_nb_stages ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_t *l_image ;
  opj_tcp_t *tmp ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 6373
  l_image = p_j2k->m_private_image;
#line 6374
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 6374
    tmp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
  } else {
#line 6374
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 6374
  l_tcp = tmp;
#line 6378
  if (p_header_size < 1U) {
    {
#line 6379
    opj_event_msg(p_manager, 1, "Error reading MCO marker\n\rP\t\265U");
    }
#line 6380
    return (0);
  }
  {
#line 6383
  opj_read_bytes_LE(p_header_data, & l_nb_stages, (OPJ_UINT32 )1);
#line 6385
  p_header_data ++;
  }
#line 6387
  if (l_nb_stages > 1U) {
    {
#line 6388
    opj_event_msg(p_manager, 2, "Cannot take in charge multiple transformation stages.\n");
    }
#line 6390
    return (1);
  }
#line 6393
  if (p_header_size != l_nb_stages + 1U) {
    {
#line 6394
    opj_event_msg(p_manager, 2, "Error reading MCO marker\n");
    }
#line 6395
    return (0);
  }
#line 6398
  l_tccp = l_tcp->tccps;
#line 6400
  i = (OPJ_UINT32 )0;
  {
#line 6400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6400
    if (! (i < l_image->numcomps)) {
#line 6400
      goto while_break;
    }
#line 6401
    l_tccp->m_dc_level_shift = 0;
#line 6402
    l_tccp ++;
#line 6400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6405
  if (l_tcp->m_mct_decoding_matrix) {
    {
#line 6406
    opj_free(l_tcp->m_mct_decoding_matrix);
#line 6407
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 6410
  i = (OPJ_UINT32 )0;
  {
#line 6410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6410
    if (! (i < l_nb_stages)) {
#line 6410
      goto while_break___0;
    }
    {
#line 6411
    opj_read_bytes_LE(p_header_data, & l_tmp, (OPJ_UINT32 )1);
#line 6412
    p_header_data ++;
#line 6414
    __cil_tmp12 = opj_j2k_add_mct(l_tcp, p_j2k->m_private_image, l_tmp);
    }
#line 6414
    if (! __cil_tmp12) {
#line 6415
      return (0);
    }
#line 6410
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6419
  return (1);
}
}
#line 6422 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t *p_tcp , opj_image_t *p_image , OPJ_UINT32 p_index ) 
{ 
  OPJ_UINT32 i ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_record ;
  opj_mct_data_t *l_deco_array ;
  opj_mct_data_t *l_offset_array ;
  OPJ_UINT32 l_data_size ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_offset_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_UINT32 *l_offset_data ;
  OPJ_UINT32 *l_current_offset_data ;
  opj_tccp_t *l_tccp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  OPJ_UINT32 *__cil_tmp17 ;

  {
#line 6436
  l_mcc_record = p_tcp->m_mcc_records;
#line 6438
  i = (OPJ_UINT32 )0;
  {
#line 6438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6438
    if (! (i < p_tcp->m_nb_mcc_records)) {
#line 6438
      goto while_break;
    }
#line 6439
    if (l_mcc_record->m_index == p_index) {
#line 6440
      goto while_break;
    }
#line 6438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6444
  if (i == p_tcp->m_nb_mcc_records) {
#line 6446
    return (1);
  }
#line 6449
  if (l_mcc_record->m_nb_comps != p_image->numcomps) {
#line 6451
    return (1);
  }
#line 6454
  l_deco_array = l_mcc_record->m_decorrelation_array;
#line 6456
  if (l_deco_array) {
#line 6457
    l_data_size = (MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps) * p_image->numcomps;
#line 6459
    if (l_deco_array->m_data_size != l_data_size) {
#line 6460
      return (0);
    }
    {
#line 6463
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 6464
    l_mct_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 6465
    __cil_tmp15 = opj_malloc((size_t )l_mct_size);
#line 6465
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp15;
    }
#line 6467
    if (! p_tcp->m_mct_decoding_matrix) {
#line 6468
      return (0);
    }
    {
#line 6471
    (*(j2k_mct_read_functions_to_float[l_deco_array->m_element_type]))(l_deco_array->m_data,
                                                                       p_tcp->m_mct_decoding_matrix,
                                                                       l_nb_elem);
    }
  }
#line 6475
  l_offset_array = l_mcc_record->m_offset_array;
#line 6477
  if (l_offset_array) {
#line 6478
    l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
#line 6480
    if (l_offset_array->m_data_size != l_data_size) {
#line 6481
      return (0);
    }
    {
#line 6484
    l_nb_elem = p_image->numcomps;
#line 6485
    l_offset_size = l_nb_elem * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 6486
    __cil_tmp16 = opj_malloc((size_t )l_offset_size);
#line 6486
    l_offset_data = (OPJ_UINT32 *)__cil_tmp16;
    }
#line 6488
    if (! l_offset_data) {
#line 6489
      return (0);
    }
    {
#line 6492
    (*(j2k_mct_read_functions_to_int32[l_offset_array->m_element_type]))(l_offset_array->m_data,
                                                                         l_offset_data,
                                                                         l_nb_elem);
#line 6495
    l_tccp = p_tcp->tccps;
#line 6496
    l_current_offset_data = l_offset_data;
#line 6498
    i = (OPJ_UINT32 )0;
    }
    {
#line 6498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6498
      if (! (i < p_image->numcomps)) {
#line 6498
        goto while_break___0;
      }
#line 6499
      __cil_tmp17 = l_current_offset_data;
#line 6499
      l_current_offset_data ++;
#line 6499
      l_tccp->m_dc_level_shift = (OPJ_INT32 )*__cil_tmp17;
#line 6500
      l_tccp ++;
#line 6498
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6503
    opj_free(l_offset_data);
    }
  }
#line 6506
  return (1);
}
}
#line 6509 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_cbd(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_cbd_size ;
  OPJ_BYTE *l_current_data ;
  opj_image_t *l_image ;
  opj_image_comp_t *l_comp ;
  OPJ_BYTE *new_header_tile_data ;
  void *__cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;

  {
#line 6515
  l_current_data = (OPJ_BYTE *)0;
#line 6516
  l_image = (opj_image_t *)0;
#line 6517
  l_comp = (opj_image_comp_t *)0;
#line 6524
  l_image = p_j2k->m_private_image;
#line 6525
  l_cbd_size = 6U + (p_j2k->m_private_image)->numcomps;
#line 6527
  if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
    {
#line 6528
    __cil_tmp10 = opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                              (size_t )l_cbd_size);
#line 6528
    new_header_tile_data = (OPJ_BYTE *)__cil_tmp10;
    }
#line 6530
    if (! new_header_tile_data) {
      {
#line 6531
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 6532
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)((void *)0);
#line 6533
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 6534
      opj_event_msg(p_manager, 1, "Not enough memory to write CBD marker\n");
      }
#line 6535
      return (0);
    }
#line 6537
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
#line 6538
    p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
  }
  {
#line 6541
  l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
#line 6543
  opj_write_bytes_LE(l_current_data, (OPJ_UINT32 )65400, (OPJ_UINT32 )2);
#line 6544
  l_current_data += 2;
#line 6546
  opj_write_bytes_LE(l_current_data, l_cbd_size - 2U, (OPJ_UINT32 )2);
#line 6547
  l_current_data += 2;
#line 6549
  opj_write_bytes_LE(l_current_data, l_image->numcomps, (OPJ_UINT32 )2);
#line 6550
  l_current_data += 2;
#line 6552
  l_comp = l_image->comps;
#line 6554
  i = (OPJ_UINT32 )0;
  }
  {
#line 6554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6554
    if (! (i < l_image->numcomps)) {
#line 6554
      goto while_break;
    }
    {
#line 6555
    opj_write_bytes_LE(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1U),
                       (OPJ_UINT32 )1);
#line 6557
    l_current_data ++;
#line 6559
    l_comp ++;
    }
#line 6554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6562
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,
                                      (OPJ_SIZE_T )l_cbd_size, p_manager);
  }
#line 6562
  if (__cil_tmp11 != (unsigned long )l_cbd_size) {
#line 6565
    return (0);
  }
#line 6568
  return (1);
}
}
#line 6578 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cbd(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_comp ;
  OPJ_UINT32 l_num_comp ;
  OPJ_UINT32 l_comp_def ;
  OPJ_UINT32 i ;
  opj_image_comp_t *l_comp ;

  {
#line 6587
  l_comp = (opj_image_comp_t *)0;
#line 6594
  l_num_comp = (p_j2k->m_private_image)->numcomps;
#line 6596
  if (p_header_size != (p_j2k->m_private_image)->numcomps + 2U) {
    {
#line 6597
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n-P\t\265U");
    }
#line 6598
    return (0);
  }
  {
#line 6601
  opj_read_bytes_LE(p_header_data, & l_nb_comp, (OPJ_UINT32 )2);
#line 6603
  p_header_data += 2;
  }
#line 6605
  if (l_nb_comp != l_num_comp) {
    {
#line 6606
    opj_event_msg(p_manager, 1, "Crror reading CBD marker\n");
    }
#line 6607
    return (0);
  }
#line 6610
  l_comp = (p_j2k->m_private_image)->comps;
#line 6611
  i = (OPJ_UINT32 )0;
  {
#line 6611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6611
    if (! (i < l_num_comp)) {
#line 6611
      goto while_break;
    }
    {
#line 6612
    opj_read_bytes_LE(p_header_data, & l_comp_def, (OPJ_UINT32 )1);
#line 6614
    p_header_data ++;
#line 6615
    l_comp->sgnd = (l_comp_def >> 7) & 1U;
#line 6616
    l_comp->prec = (l_comp_def & 127U) + 1U;
    }
#line 6618
    if (l_comp->prec > 31U) {
      {
#line 6619
      opj_event_msg(p_manager, 1, "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm. OpenJpeg only supports up to 31)\n",
                    i, l_comp->prec);
      }
#line 6622
      return (0);
    }
#line 6624
    l_comp ++;
#line 6611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6627
  return (1);
}
}
#line 6639 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cap(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6655
  return (1);
}
}
#line 6665 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_cpf(opj_j2k_t *p_j2k , OPJ_BYTE *p_header_data , OPJ_UINT32 p_header_size ,
                                 opj_event_mgr_t *p_manager ) 
{ 


  {
#line 6681
  return (1);
}
}
#line 6688 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 


  {
#line 6690
  if (j2k) {
#line 6690
    if (parameters) {
#line 6691
      j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
#line 6692
      j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
#line 6694
      j2k->dump_state = parameters->flags & 2U;
    }
  }
  return;
}
}
#line 6703 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_decoder_set_strict_mode(opj_j2k_t *j2k , OPJ_BOOL strict ) 
{ 


  {
#line 6705
  if (j2k) {
#line 6706
    j2k->m_cp.strict = strict;
  }
  return;
}
}
#line 6710 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k , OPJ_UINT32 num_threads ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  opj_thread_pool_t *__cil_tmp4 ;
  opj_thread_pool_t *__cil_tmp5 ;

  {
  {
#line 6714
  __cil_tmp3 = opj_has_thread_support();
  }
#line 6714
  if (j2k->m_tcd == (void *)0) {
#line 6714
    if (__cil_tmp3) {
      {
#line 6715
      opj_thread_pool_destroy(j2k->m_tp);
#line 6716
      j2k->m_tp = (opj_thread_pool_t *)((void *)0);
      }
#line 6717
      if (num_threads <= 2147483647U) {
        {
#line 6718
        j2k->m_tp = opj_thread_pool_create((int )num_threads);
        }
      }
#line 6720
      if (j2k->m_tp == (void *)0) {
        {
#line 6721
        j2k->m_tp = opj_thread_pool_create(0);
        }
#line 6722
        return (0);
      }
#line 6724
      return (1);
    }
  }
#line 6726
  return (0);
}
}
#line 6729 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_get_default_thread_count(void) 
{ 
  char const   *num_threads_str ;
  char *__cil_tmp2 ;
  int num_cpus ;
  int num_threads ;
  OPJ_BOOL __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 6731
  __cil_tmp2 = getenv("OPJ_NUM_THREADS");
#line 6731
  num_threads_str = (char const   *)__cil_tmp2;
#line 6735
  __cil_tmp5 = opj_has_thread_support();
  }
#line 6735
  if (num_threads_str == (void *)0) {
#line 6736
    return (0);
  } else
#line 6735
  if (! __cil_tmp5) {
#line 6736
    return (0);
  }
  {
#line 6738
  num_cpus = opj_get_num_cpus();
#line 6739
  __cil_tmp7 = strcmp(num_threads_str, "ALL_CPUS\220");
  }
#line 6739
  if (__cil_tmp7 == 0) {
#line 6740
    return (num_cpus);
  }
#line 6742
  if (num_cpus == 0) {
#line 6743
    num_cpus = 32;
  }
  {
#line 6745
  num_threads = atoi(num_threads_str);
  }
#line 6746
  if (num_threads < 0) {
#line 6747
    num_threads = 0;
  } else
#line 6748
  if (num_threads > 2 * num_cpus) {
#line 6749
    num_threads = 2 * num_cpus;
  }
#line 6751
  return (num_threads);
}
}
#line 6758 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_compress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  opj_procedure_list_t *__cil_tmp4 ;
  opj_procedure_list_t *__cil_tmp5 ;
  int __cil_tmp6 ;
  opj_thread_pool_t *__cil_tmp7 ;
  opj_thread_pool_t *__cil_tmp8 ;

  {
  {
#line 6760
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 6760
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 6761
  if (! l_j2k) {
#line 6762
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6766
  l_j2k->m_is_decoder = 0;
#line 6767
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )0;
#line 6769
  __cil_tmp3 = opj_malloc((size_t )1000);
#line 6769
  l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)__cil_tmp3;
  }
#line 6771
  if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 6772
    opj_j2k_destroy(l_j2k);
    }
#line 6773
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6776
  l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )1000;
#line 6780
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 6781
  if (! l_j2k->m_validation_list) {
    {
#line 6782
    opj_j2k_destroy(l_j2k);
    }
#line 6783
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6787
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 6788
  if (! l_j2k->m_procedure_list) {
    {
#line 6789
    opj_j2k_destroy(l_j2k);
    }
#line 6790
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 6793
  __cil_tmp6 = opj_j2k_get_default_thread_count();
#line 6793
  __cil_tmp7 = opj_thread_pool_create(__cil_tmp6);
#line 6793
  l_j2k->m_tp = __cil_tmp7;
  }
#line 6794
  if (! l_j2k->m_tp) {
    {
#line 6795
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 6797
  if (! l_j2k->m_tp) {
    {
#line 6798
    opj_j2k_destroy(l_j2k);
    }
#line 6799
    return ((opj_j2k_t *)((void *)0));
  }
#line 6802
  return (l_j2k);
}
}
#line 6805 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 6807
  (POC + 0)->tile = (OPJ_UINT32 )1;
#line 6808
  (POC + 0)->resno0 = (OPJ_UINT32 )0;
#line 6809
  (POC + 0)->compno0 = (OPJ_UINT32 )0;
#line 6810
  (POC + 0)->layno1 = (OPJ_UINT32 )1;
#line 6811
  (POC + 0)->resno1 = (OPJ_UINT32 )(numres - 1);
#line 6812
  (POC + 0)->compno1 = (OPJ_UINT32 )3;
#line 6813
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 6814
  (POC + 1)->tile = (OPJ_UINT32 )1;
#line 6815
  (POC + 1)->resno0 = (OPJ_UINT32 )(numres - 1);
#line 6816
  (POC + 1)->compno0 = (OPJ_UINT32 )0;
#line 6817
  (POC + 1)->layno1 = (OPJ_UINT32 )1;
#line 6818
  (POC + 1)->resno1 = (OPJ_UINT32 )numres;
#line 6819
  (POC + 1)->compno1 = (OPJ_UINT32 )3;
#line 6820
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 6821
  return (2);
}
}
#line 6824 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                          opj_event_mgr_t *p_manager ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 6831
  parameters->tile_size_on = 0;
#line 6832
  parameters->cp_tdx = 1;
#line 6833
  parameters->cp_tdy = 1;
#line 6836
  parameters->tp_flag = (char )'C';
#line 6837
  parameters->tp_on = (char )1;
#line 6840
  parameters->cp_tx0 = 0;
#line 6841
  parameters->cp_ty0 = 0;
#line 6842
  parameters->image_offset_x0 = 0;
#line 6843
  parameters->image_offset_y0 = 0;
#line 6846
  parameters->cblockw_init = 32;
#line 6847
  parameters->cblockh_init = 32;
#line 6850
  parameters->mode = 0;
#line 6853
  parameters->roi_compno = - 1;
#line 6856
  parameters->subsampling_dx = 1;
#line 6857
  parameters->subsampling_dy = 1;
#line 6860
  parameters->irreversible = 1;
#line 6863
  if (parameters->tcp_numlayers > 1) {
    {
#line 6864
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n1 single quality layer-> Number of layers forced to 1 (rather than %d)\n-> Rate of the last layer (%3.1f) will be used\230\001",
                  parameters->tcp_numlayers, (double )parameters->tcp_rates[parameters->tcp_numlayers - 1]);
#line 6871
    parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
#line 6872
    parameters->tcp_numlayers = 1;
    }
  }
  {
#line 6877
  if ((int )parameters->rsiz == 3) {
#line 6877
    goto case_3;
  }
#line 6887
  if ((int )parameters->rsiz == 4) {
#line 6887
    goto case_4;
  }
#line 6904
  goto switch_default;
  case_3: /* CIL Label */ 
#line 6878
  if (parameters->numresolution > 6) {
    {
#line 6879
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nNumber of decomposition levels <= 5\n-> Number of decomposition levels forced to 5 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6884
    parameters->numresolution = 6;
    }
  }
#line 6886
  goto switch_break;
  case_4: /* CIL Label */ 
#line 6888
  if (parameters->numresolution < 2) {
    {
#line 6889
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 1 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6894
    parameters->numresolution = 1;
    }
  } else
#line 6895
  if (parameters->numresolution > 7) {
    {
#line 6896
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nNumber of decomposition levels >= 1 && <= 6\n-> Number of decomposition levels forced to 6 (rather than %d)\n",
                  parameters->numresolution + 1);
#line 6901
    parameters->numresolution = 7;
    }
  }
#line 6903
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 6905
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6909
  parameters->csty |= 1;
#line 6910
  if (parameters->numresolution == 1) {
#line 6911
    parameters->res_spec = 1;
#line 6912
    parameters->prcw_init[0] = 128;
#line 6913
    parameters->prch_init[0] = 128;
  } else {
#line 6915
    parameters->res_spec = parameters->numresolution - 1;
#line 6916
    i = 0;
    {
#line 6916
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6916
      if (! (i < parameters->res_spec)) {
#line 6916
        goto while_break;
      }
#line 6917
      parameters->prcw_init[i] = 256;
#line 6918
      parameters->prch_init[i] = 256;
#line 6916
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6923
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 6926
  if ((int )parameters->rsiz == 4) {
    {
#line 6927
    __cil_tmp6 = opj_j2k_initialise_4K_poc((opj_poc_t *)parameters->POC, parameters->numresolution);
#line 6927
    parameters->numpocs = (OPJ_UINT32 )__cil_tmp6;
    }
  } else {
#line 6930
    parameters->numpocs = (OPJ_UINT32 )0;
  }
#line 6934
  parameters->cp_disto_alloc = 1;
#line 6935
  if (parameters->max_cs_size <= 0) {
    {
#line 6937
    parameters->max_cs_size = 1302083;
#line 6938
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6942
  if (parameters->max_cs_size > 1302083) {
    {
#line 6943
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1302083 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
#line 6947
    parameters->max_cs_size = 1302083;
    }
  }
#line 6950
  if (parameters->max_comp_size <= 0) {
    {
#line 6952
    parameters->max_comp_size = 1041666;
#line 6953
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\nAs no rate has been given, this limit will be used.\n");
    }
  } else
#line 6957
  if (parameters->max_comp_size > 1041666) {
    {
#line 6958
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\nMaximum 1041666 compressed bytes @ 24fps\n-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
#line 6962
    parameters->max_comp_size = 1041666;
    }
  }
#line 6965
  parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
  return;
}
}
#line 6972 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image , OPJ_UINT16 rsiz ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 6978
  if (image->numcomps != 3U) {
    {
#line 6979
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\n3 components-> Number of components of input image (%d) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  image->numcomps);
    }
#line 6985
    return (0);
  }
#line 6989
  i = (OPJ_UINT32 )0;
  {
#line 6989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6989
    if (! (i < image->numcomps)) {
#line 6989
      goto while_break;
    }
#line 6990
    if (((image->comps + i)->prec != 12U) | (image->comps + i)->sgnd) {
#line 6991
      signed_str = "signed";
#line 6992
      unsigned_str = "unsigned\f";
#line 6993
      if ((image->comps + i)->sgnd) {
#line 6993
        tmp = (char *)signed_str;
      } else {
#line 6993
        tmp = (char *)unsigned_str;
      }
      {
#line 6993
      tmp_str = tmp;
#line 6994
      opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nPrecision of each component shall be 12 bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-profile-3 codestream will be generated\n",
                    i, (image->comps + i)->prec, tmp_str);
      }
#line 7000
      return (0);
    }
#line 6989
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7006
  if ((int )rsiz == 3) {
#line 7006
    goto case_3;
  }
#line 7017
  if ((int )rsiz == 4) {
#line 7017
    goto case_4;
  }
#line 7028
  goto switch_default;
  case_3: /* CIL Label */ 
#line 7007
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1080U)) {
    {
#line 7008
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-3 (2k dc profile) requires:\nwidth <= 2048 and height <= 1080\n-> Input image size %d x %d is not compliant\n-> Non-profile-3 codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 7014
    return (0);
  }
#line 7016
  goto switch_break;
  case_4: /* CIL Label */ 
#line 7018
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 2160U)) {
    {
#line 7019
    opj_event_msg(p_manager, 2, "JPEG 2000 Profile-4 (4k dc profile) requires:\nwidth <= 4096 and height <= 2160\n-> Image size %d x %d is not compliant\n-> Non-profile-4 codestream will be generated\n\230\001",
                  (image->comps + 0)->w, (image->comps + 0)->h);
    }
#line 7025
    return (0);
  }
#line 7027
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 7029
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 7032
  return (1);
}
}
#line 7035 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static int opj_j2k_get_imf_max_NL(opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  OPJ_UINT32 XTsiz ;
  OPJ_UINT32 tmp ;

  {
#line 7039
  rsiz = parameters->rsiz;
#line 7040
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7041
  if (parameters->tile_size_on) {
#line 7041
    tmp = (OPJ_UINT32 )parameters->cp_tdx;
  } else {
#line 7041
    tmp = image->x1;
  }
#line 7041
  XTsiz = tmp;
  {
#line 7044
  if ((int )profile == 1024) {
#line 7044
    goto case_1024;
  }
#line 7046
  if ((int )profile == 1280) {
#line 7046
    goto case_1280;
  }
#line 7048
  if ((int )profile == 1536) {
#line 7048
    goto case_1536;
  }
#line 7050
  if ((int )profile == 1792) {
#line 7050
    goto case_1792;
  }
#line 7058
  if ((int )profile == 2048) {
#line 7058
    goto case_2048;
  }
#line 7068
  if ((int )profile == 2304) {
#line 7068
    goto case_2304;
  }
#line 7080
  goto switch_default;
  case_1024: /* CIL Label */ 
#line 7045
  return (5);
  case_1280: /* CIL Label */ 
#line 7047
  return (6);
  case_1536: /* CIL Label */ 
#line 7049
  return (7);
  case_1792: /* CIL Label */ 
#line 7051
  if (XTsiz >= 2048U) {
#line 7052
    return (5);
  } else
#line 7053
  if (XTsiz >= 1024U) {
#line 7054
    return (4);
  }
#line 7056
  goto switch_break;
  case_2048: /* CIL Label */ 
#line 7059
  if (XTsiz >= 4096U) {
#line 7060
    return (6);
  } else
#line 7061
  if (XTsiz >= 2048U) {
#line 7062
    return (5);
  } else
#line 7063
  if (XTsiz >= 1024U) {
#line 7064
    return (4);
  }
#line 7066
  goto switch_break;
  case_2304: /* CIL Label */ 
#line 7069
  if (XTsiz >= 8192U) {
#line 7070
    return (7);
  } else
#line 7071
  if (XTsiz >= 4096U) {
#line 7072
    return (6);
  } else
#line 7073
  if (XTsiz >= 2048U) {
#line 7074
    return (5);
  } else
#line 7075
  if (XTsiz >= 1024U) {
#line 7076
    return (4);
  }
#line 7078
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 7081
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 7083
  return (- 1);
}
}
#line 7086 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_set_imf_parameters(opj_cparameters_t *parameters , opj_image_t *image ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  int max_NL ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int i ;
  int __cil_tmp11 ;

  {
#line 7089
  rsiz = parameters->rsiz;
#line 7090
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7095
  if (parameters->cblockw_init == 64) {
#line 7095
    if (parameters->cblockh_init == 64) {
#line 7097
      parameters->cblockw_init = 32;
#line 7098
      parameters->cblockh_init = 32;
    }
  }
#line 7102
  parameters->tp_flag = (char )'C';
#line 7103
  parameters->tp_on = (char )1;
#line 7105
  if ((int )parameters->prog_order == 0) {
#line 7106
    parameters->prog_order = (OPJ_PROG_ORDER )4;
  }
#line 7109
  if ((int )profile == 1024) {
#line 7113
    parameters->irreversible = 1;
  } else
#line 7109
  if ((int )profile == 1280) {
#line 7113
    parameters->irreversible = 1;
  } else
#line 7109
  if ((int )profile == 1536) {
#line 7113
    parameters->irreversible = 1;
  }
#line 7117
  if (parameters->numresolution == 6) {
#line 7117
    if (image->x0 == 0U) {
#line 7117
      if (image->y0 == 0U) {
        {
#line 7120
        __cil_tmp7 = opj_j2k_get_imf_max_NL(parameters, image);
#line 7120
        max_NL = __cil_tmp7;
        }
#line 7121
        if (max_NL >= 0) {
#line 7121
          if (parameters->numresolution > max_NL) {
#line 7122
            parameters->numresolution = max_NL + 1;
          }
        }
#line 7126
        if (! parameters->tile_size_on) {
          {
#line 7127
          while (1) {
            while_continue: /* CIL Label */ ;
#line 7127
            if (! (parameters->numresolution > 0)) {
#line 7127
              goto while_break;
            }
#line 7128
            if (image->x1 < 1U << ((OPJ_UINT32 )parameters->numresolution - 1U)) {
#line 7129
              __cil_tmp8 = parameters->numresolution;
#line 7129
              (parameters->numresolution) --;
#line 7130
              goto while_continue;
            }
#line 7132
            if (image->y1 < 1U << ((OPJ_UINT32 )parameters->numresolution - 1U)) {
#line 7133
              __cil_tmp9 = parameters->numresolution;
#line 7133
              (parameters->numresolution) --;
#line 7134
              goto while_continue;
            }
#line 7136
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 7142
  if (parameters->csty == 0) {
#line 7143
    parameters->csty |= 1;
#line 7144
    if (parameters->numresolution == 1) {
#line 7145
      parameters->res_spec = 1;
#line 7146
      parameters->prcw_init[0] = 128;
#line 7147
      parameters->prch_init[0] = 128;
    } else {
#line 7150
      parameters->res_spec = parameters->numresolution - 1;
#line 7151
      i = 0;
      {
#line 7151
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 7151
        if (! (i < parameters->res_spec)) {
#line 7151
          goto while_break___0;
        }
#line 7152
        parameters->prcw_init[i] = 256;
#line 7153
        parameters->prch_init[i] = 256;
#line 7151
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 7160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT16 tabMaxSubLevelFromMainLevel[12]  = 
#line 7160
  {      (OPJ_UINT16 )15,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1,      (OPJ_UINT16 )1, 
        (OPJ_UINT16 )2,      (OPJ_UINT16 )3,      (OPJ_UINT16 )4,      (OPJ_UINT16 )5, 
        (OPJ_UINT16 )6,      (OPJ_UINT16 )7,      (OPJ_UINT16 )8,      (OPJ_UINT16 )9};
#line 7175 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_is_imf_compliant(opj_cparameters_t *parameters , opj_image_t *image ,
                                         opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT16 rsiz ;
  OPJ_UINT16 profile ;
  OPJ_UINT16 mainlevel ;
  OPJ_UINT16 sublevel ;
  int NL ;
  OPJ_UINT32 XTsiz ;
  OPJ_UINT32 tmp ;
  OPJ_BOOL ret ;
  char signed_str[7] ;
  char unsigned_str[9] ;
  char *tmp_str ;
  char *tmp___0 ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  int i___8 ;
  int __cil_tmp20 ;

  {
#line 7180
  rsiz = parameters->rsiz;
#line 7181
  profile = (OPJ_UINT16 )((int )rsiz & 65280);
#line 7182
  mainlevel = (OPJ_UINT16 )((int )rsiz & 15);
#line 7183
  sublevel = (OPJ_UINT16 )(((int )rsiz >> 4) & 15);
#line 7184
  NL = parameters->numresolution - 1;
#line 7185
  if (parameters->tile_size_on) {
#line 7185
    tmp = (OPJ_UINT32 )parameters->cp_tdx;
  } else {
#line 7185
    tmp = image->x1;
  }
#line 7185
  XTsiz = tmp;
#line 7187
  ret = 1;
#line 7190
  if ((int )mainlevel > 11) {
    {
#line 7191
    opj_event_msg(p_manager, 2, "IMF profile require mainlevel <= 11.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n",
                  (int )mainlevel);
#line 7196
    ret = 0;
    }
  } else
#line 7201
  if ((int )sublevel > (int )tabMaxSubLevelFromMainLevel[mainlevel]) {
    {
#line 7202
    opj_event_msg(p_manager, 2, "IMF profile require sublevel <= %d for mainlevel = %d.\n-> %d is thus not compliant\n-> Non-IMF codestream will be generated\n\t\265U",
                  (int )tabMaxSubLevelFromMainLevel[mainlevel], (int )mainlevel, (int )sublevel);
#line 7209
    ret = 0;
    }
  }
#line 7214
  if (image->numcomps > 3U) {
    {
#line 7215
    opj_event_msg(p_manager, 2, "IMF profiles require at most 3 components.\n-> Number of components of input image (%d) is not compliant\n-> Non-IMF codestream will be generated\n\230\001",
                  image->numcomps);
#line 7220
    ret = 0;
    }
  }
#line 7223
  if (image->x0 != 0U) {
    {
    {
#line 7224
    opj_event_msg(p_manager, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image->x0, image->y0 != 0U);
    }
#line 7229
    ret = 0;
    }
  } else
#line 7223
  if (image->y0 != 0U) {
    {
    {
#line 7224
    opj_event_msg(p_manager, 2, "IMF profiles require image origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  image->x0, image->y0 != 0U);
    }
#line 7229
    ret = 0;
    }
  }
#line 7232
  if (parameters->cp_tx0 != 0) {
    {
    {
#line 7233
    opj_event_msg(p_manager, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters->cp_tx0, parameters->cp_ty0);
    }
#line 7238
    ret = 0;
    }
  } else
#line 7232
  if (parameters->cp_ty0 != 0) {
    {
    {
#line 7233
    opj_event_msg(p_manager, 2, "IMF profiles require tile origin to be at 0,0.\n-> %d,%d is not compliant\n-> Non-IMF codestream will be generated\n",
                  parameters->cp_tx0, parameters->cp_ty0);
    }
#line 7238
    ret = 0;
    }
  }
#line 7241
  if (parameters->tile_size_on) {
#line 7242
    if ((int )profile == 1024) {
      _L___3: /* CIL Label */ 
      _L___4: /* CIL Label */ 
#line 7245
      if ((OPJ_UINT32 )parameters->cp_tdx < image->x1) {
        {
        {
#line 7247
        opj_event_msg(p_manager, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy, image->x1, image->y1);
        }
#line 7255
        ret = 0;
        }
      } else
#line 7245
      if ((OPJ_UINT32 )parameters->cp_tdy < image->y1) {
        {
        {
#line 7247
        opj_event_msg(p_manager, 2, "IMF 2K/4K/8K single tile profiles require tile to be greater or equal to image size.\n-> %d,%d is lesser than %d,%d\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy, image->x1, image->y1);
        }
#line 7255
        ret = 0;
        }
      }
    } else
#line 7242
    if ((int )profile == 1280) {
#line 7242
      goto _L___3;
    } else
#line 7242
    if ((int )profile == 1536) {
#line 7242
      goto _L___3;
    } else
#line 7258
    if ((OPJ_UINT32 )parameters->cp_tdx >= image->x1) {
#line 7258
      if (! ((OPJ_UINT32 )parameters->cp_tdy >= image->y1)) {
#line 7258
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 7261
    if (parameters->cp_tdx == 1024) {
#line 7261
      if (! (parameters->cp_tdy == 1024)) {
#line 7261
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 7264
    if (parameters->cp_tdx == 2048) {
#line 7264
      if (parameters->cp_tdy == 2048) {
#line 7264
        if (! ((int )profile == 1280)) {
#line 7264
          if (! ((int )profile == 1536)) {
#line 7264
            goto _L;
          }
        }
      } else {
#line 7264
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___0: /* CIL Label */ 
#line 7269
    if (parameters->cp_tdx == 4096) {
#line 7269
      if (parameters->cp_tdy == 4096) {
#line 7269
        if (! ((int )profile == 1536)) {
          {
          {
          {
#line 7274
          opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                        parameters->cp_tdx, parameters->cp_tdy);
          }
          }
#line 7283
          ret = 0;
          }
        }
      } else {
        {
        {
        {
#line 7274
        opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                      parameters->cp_tdx, parameters->cp_tdy);
        }
        }
#line 7283
        ret = 0;
        }
      }
    } else {
      {
      {
      {
#line 7274
      opj_event_msg(p_manager, 2, "IMF 2K_R/4K_R/8K_R single/multiple tile profiles require tile to be greater or equal to image size,\nor to be (1024,1024), or (2048,2048) for 4K_R/8K_R or (4096,4096) for 8K_R.\n-> %d,%d is non conformant\n-> Non-IMF codestream will be generated\n",
                    parameters->cp_tdx, parameters->cp_tdy);
      }
      }
#line 7283
      ret = 0;
      }
    }
  }
#line 7289
  i = (OPJ_UINT32 )0;
  {
#line 7289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7289
    if (! (i < image->numcomps)) {
#line 7289
      goto while_break;
    }
#line 7290
    if (! ((image->comps + i)->prec >= 8U && (image->comps + i)->prec <= 16U)) {
      _L___5: /* CIL Label */ 
#line 7292
      signed_str = "signed";
#line 7293
      unsigned_str = "unsigned\f";
#line 7294
      if ((image->comps + i)->sgnd) {
#line 7294
        tmp___0 = (char *)signed_str;
      } else {
#line 7294
        tmp___0 = (char *)unsigned_str;
      }
      {
#line 7294
      tmp_str = tmp___0;
#line 7295
      opj_event_msg(p_manager, 2, "IMF profiles require precision of each component to b in [8-16] bits unsigned-> At least component %d of input image (%d bits, %s) is not compliant\n-> Non-IMF codestream will be generated\n",
                    i, (image->comps + i)->prec, tmp_str);
#line 7300
      ret = 0;
      }
    } else
#line 7290
    if ((image->comps + i)->sgnd) {
#line 7290
      goto _L___5;
    }
#line 7289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7305
  i = (OPJ_UINT32 )0;
  {
#line 7305
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7305
    if (! (i < image->numcomps)) {
#line 7305
      goto while_break___0;
    }
#line 7306
    if (i == 0U) {
#line 7306
      if ((image->comps + i)->dx != 1U) {
        {
#line 7307
        opj_event_msg(p_manager, 2, "IMF profiles require XRSiz1 == 1. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                      (image->comps + i)->dx);
#line 7311
        ret = 0;
        }
      }
    }
#line 7313
    if (i == 1U) {
#line 7313
      if ((image->comps + i)->dx != 1U) {
#line 7313
        if ((image->comps + i)->dx != 2U) {
          {
#line 7314
          opj_event_msg(p_manager, 2, "IMF profiles require XRSiz2 == 1 or 2. Here it is set to %d.\n-> Non-IMF codestream will be generated\n",
                        (image->comps + i)->dx);
#line 7318
          ret = 0;
          }
        }
      }
    }
#line 7320
    if (i > 1U) {
#line 7320
      if ((image->comps + i)->dx != (image->comps + (i - 1U))->dx) {
        {
#line 7321
        opj_event_msg(p_manager, 2, "IMF profiles require XRSiz%d to be the same as XRSiz2. Here it is set to %d instead of %d.\n-> Non-IMF codestream will be generated\n",
                      i + 1U, (image->comps + i)->dx, (image->comps + (i - 1U))->dx);
#line 7326
        ret = 0;
        }
      }
    }
#line 7328
    if ((image->comps + i)->dy != 1U) {
      {
#line 7329
      opj_event_msg(p_manager, 2, "IMF profiles require YRsiz == 1. Here it is set to %d for component %d.\n-> Non-IMF codestream will be generated\n\230\001",
                    (image->comps + i)->dy, i);
#line 7334
      ret = 0;
      }
    }
#line 7305
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7341
  if ((int )profile == 1792) {
#line 7341
    goto case_1792;
  }
#line 7341
  if ((int )profile == 1024) {
#line 7341
    goto case_1792;
  }
#line 7353
  if ((int )profile == 2048) {
#line 7353
    goto case_2048;
  }
#line 7353
  if ((int )profile == 1280) {
#line 7353
    goto case_2048;
  }
#line 7365
  if ((int )profile == 2304) {
#line 7365
    goto case_2304;
  }
#line 7365
  if ((int )profile == 1536) {
#line 7365
    goto case_2304;
  }
#line 7339
  goto switch_break;
  case_1792: /* CIL Label */ 
  case_1024: /* CIL Label */ 
#line 7342
  if (((image->comps + 0)->w > 2048U) | ((image->comps + 0)->h > 1556U)) {
    {
#line 7343
    opj_event_msg(p_manager, 2, "IMF 2K/2K_R profile require:\nwidth <= 2048 and height <= 1556\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7349
    ret = 0;
    }
  }
#line 7351
  goto switch_break;
  case_2048: /* CIL Label */ 
  case_1280: /* CIL Label */ 
#line 7354
  if (((image->comps + 0)->w > 4096U) | ((image->comps + 0)->h > 3112U)) {
    {
#line 7355
    opj_event_msg(p_manager, 2, "IMF 4K/4K_R profile require:\nwidth <= 4096 and height <= 3112\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7361
    ret = 0;
    }
  }
#line 7363
  goto switch_break;
  case_2304: /* CIL Label */ 
  case_1536: /* CIL Label */ 
#line 7366
  if (((image->comps + 0)->w > 8192U) | ((image->comps + 0)->h > 6224U)) {
    {
#line 7367
    opj_event_msg(p_manager, 2, "IMF 8K/8K_R profile require:\nwidth <= 8192 and height <= 6224\n-> Input image size %d x %d is not compliant\n-> Non-IMF codestream will be generated\n",
                  (image->comps + 0)->w, (image->comps + 0)->h);
#line 7373
    ret = 0;
    }
  }
#line 7375
  goto switch_break;
#line 7378
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 7381
  if (parameters->roi_compno != -1) {
    {
#line 7382
    opj_event_msg(p_manager, 2, "IMF profile forbid RGN / region of interest marker.\n-> Compression parameters specify a ROI\n-> Non-IMF codestream will be generated\n");
#line 7386
    ret = 0;
    }
  }
#line 7389
  if (parameters->cblockw_init != 32) {
    {
    {
#line 7390
    opj_event_msg(p_manager, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters->cblockw_init, parameters->cblockh_init);
    }
#line 7396
    ret = 0;
    }
  } else
#line 7389
  if (parameters->cblockh_init != 32) {
    {
    {
#line 7390
    opj_event_msg(p_manager, 2, "IMF profile require code block size to be 32x32.\n-> Compression parameters set it to %dx%d.\n-> Non-IMF codestream will be generated\n",
                  parameters->cblockw_init, parameters->cblockh_init);
    }
#line 7396
    ret = 0;
    }
  }
#line 7399
  if ((int )parameters->prog_order != 4) {
    {
#line 7400
    opj_event_msg(p_manager, 2, "IMF profile require progression order to be CPRL.\n-> Compression parameters set it to %d.\n-> Non-IMF codestream will be generated\n",
                  (int )parameters->prog_order);
#line 7405
    ret = 0;
    }
  }
#line 7408
  if (parameters->numpocs != 0U) {
    {
#line 7409
    opj_event_msg(p_manager, 2, "IMF profile forbid POC markers.\n-> Compression parameters set %d POC.\n-> Non-IMF codestream will be generated\n",
                  parameters->numpocs);
#line 7414
    ret = 0;
    }
  }
#line 7418
  if (parameters->mode != 0) {
    {
#line 7419
    opj_event_msg(p_manager, 2, "IMF profile forbid mode switch in code block style.\n-> Compression parameters set code block style to %d.\n-> Non-IMF codestream will be generated\n",
                  parameters->mode);
#line 7424
    ret = 0;
    }
  }
#line 7427
  if ((int )profile == 1024) {
    _L___6: /* CIL Label */ 
    _L___7: /* CIL Label */ 
#line 7431
    if (parameters->irreversible != 1) {
      {
#line 7432
      opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 9-7 Irreversible Transform.\n-> Compression parameters set it to reversible.\n-> Non-IMF codestream will be generated\n");
#line 7436
      ret = 0;
      }
    }
  } else
#line 7427
  if ((int )profile == 1280) {
#line 7427
    goto _L___6;
  } else
#line 7427
  if ((int )profile == 1536) {
#line 7427
    goto _L___6;
  } else
#line 7440
  if (parameters->irreversible != 0) {
    {
#line 7441
    opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 5-3 reversible Transform.\n-> Compression parameters set it to irreversible.\n-> Non-IMF codestream will be generated\n");
#line 7445
    ret = 0;
    }
  }
#line 7450
  if (parameters->tcp_numlayers != 1) {
    {
#line 7451
    opj_event_msg(p_manager, 2, "IMF 2K/4K/8K profiles require 1 single quality layer.\n-> Number of layers is %d.\n-> Non-IMF codestream will be generated\n",
                  parameters->tcp_numlayers);
#line 7456
    ret = 0;
    }
  }
  {
#line 7461
  if ((int )profile == 1024) {
#line 7461
    goto case_1024___0;
  }
#line 7471
  if ((int )profile == 1280) {
#line 7471
    goto case_1280___0;
  }
#line 7481
  if ((int )profile == 1536) {
#line 7481
    goto case_1536___0;
  }
#line 7491
  if ((int )profile == 1792) {
#line 7491
    goto case_1792___0;
  }
#line 7513
  if ((int )profile == 2048) {
#line 7513
    goto case_2048___0;
  }
#line 7544
  if ((int )profile == 2304) {
#line 7544
    goto case_2304___0;
  }
#line 7584
  goto switch_default;
  case_1024___0: /* CIL Label */ 
#line 7462
  if (! (NL >= 1 && NL <= 5)) {
    {
#line 7463
    opj_event_msg(p_manager, 2, "IMF 2K profile requires 1 <= NL <= 5:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7468
    ret = 0;
    }
  }
#line 7470
  goto switch_break___0;
  case_1280___0: /* CIL Label */ 
#line 7472
  if (! (NL >= 1 && NL <= 6)) {
    {
#line 7473
    opj_event_msg(p_manager, 2, "IMF 4K profile requires 1 <= NL <= 6:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7478
    ret = 0;
    }
  }
#line 7480
  goto switch_break___0;
  case_1536___0: /* CIL Label */ 
#line 7482
  if (! (NL >= 1 && NL <= 7)) {
    {
#line 7483
    opj_event_msg(p_manager, 2, "IMF 8K profile requires 1 <= NL <= 7:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                  NL);
#line 7488
    ret = 0;
    }
  }
#line 7490
  goto switch_break___0;
  case_1792___0: /* CIL Label */ 
#line 7492
  if (XTsiz >= 2048U) {
#line 7493
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7494
      opj_event_msg(p_manager, 2, "IMF 2K_R profile requires 1 <= NL <= 5 for XTsiz >= 2048:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7499
      ret = 0;
      }
    }
  } else
#line 7501
  if (XTsiz >= 1024U) {
#line 7502
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7503
      opj_event_msg(p_manager, 2, "IMF 2K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7508
      ret = 0;
      }
    }
  }
#line 7511
  goto switch_break___0;
  case_2048___0: /* CIL Label */ 
#line 7514
  if (XTsiz >= 4096U) {
#line 7515
    if (! (NL >= 1 && NL <= 6)) {
      {
#line 7516
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz >= 4096:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7521
      ret = 0;
      }
    }
  } else
#line 7523
  if (XTsiz >= 2048U) {
#line 7524
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7525
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7530
      ret = 0;
      }
    }
  } else
#line 7532
  if (XTsiz >= 1024U) {
#line 7533
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7534
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7539
      ret = 0;
      }
    }
  }
#line 7542
  goto switch_break___0;
  case_2304___0: /* CIL Label */ 
#line 7545
  if (XTsiz >= 8192U) {
#line 7546
    if (! (NL >= 1 && NL <= 7)) {
      {
#line 7547
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 7 for XTsiz >= 8192:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7552
      ret = 0;
      }
    }
  } else
#line 7554
  if (XTsiz >= 4096U) {
#line 7555
    if (! (NL >= 1 && NL <= 6)) {
      {
#line 7556
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 6 for XTsiz in [4096,8192[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7561
      ret = 0;
      }
    }
  } else
#line 7563
  if (XTsiz >= 2048U) {
#line 7564
    if (! (NL >= 1 && NL <= 5)) {
      {
#line 7565
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 5 for XTsiz in [2048,4096[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7570
      ret = 0;
      }
    }
  } else
#line 7572
  if (XTsiz >= 1024U) {
#line 7573
    if (! (NL >= 1 && NL <= 4)) {
      {
#line 7574
      opj_event_msg(p_manager, 2, "IMF 4K_R profile requires 1 <= NL <= 4 for XTsiz in [1024,2048[:\n-> Number of decomposition levels is %d.\n-> Non-IMF codestream will be generated\n",
                    NL);
#line 7579
      ret = 0;
      }
    }
  }
#line 7582
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 7585
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 7588
  if (parameters->numresolution == 1) {
#line 7589
    if (parameters->res_spec != 1) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    } else
#line 7589
    if (parameters->prcw_init[0] != 128) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    } else
#line 7589
    if (parameters->prch_init[0] != 128) {
      {
      {
      {
#line 7592
      opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
      }
      }
#line 7596
      ret = 0;
      }
    }
  } else {
#line 7600
    i___8 = 0;
    {
#line 7600
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7600
      if (! (i___8 < parameters->res_spec)) {
#line 7600
        goto while_break___1;
      }
#line 7601
      if (parameters->prcw_init[i___8] != 256) {
        {
        {
#line 7603
        opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
        }
#line 7607
        ret = 0;
        }
      } else
#line 7601
      if (parameters->prch_init[i___8] != 256) {
        {
        {
#line 7603
        opj_event_msg(p_manager, 2, "IMF profiles require PPx = PPy = 7 for NLLL band, else 8.\n-> Supplied values are different from that.\n-> Non-IMF codestream will be generated\n");
        }
#line 7607
        ret = 0;
        }
      }
#line 7600
      i___8 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 7612
  return (ret);
}
}
#line 7616 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_encoder(opj_j2k_t *p_j2k , opj_cparameters_t *parameters ,
                               opj_image_t *image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 tileno ;
  OPJ_UINT32 numpocs_tile ;
  opj_cp_t *cp ;
  OPJ_UINT32 cblkw ;
  OPJ_UINT32 cblkh ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_BOOL deprecated_used ;
  OPJ_FLOAT32 rate_i_corr ;
  OPJ_FLOAT32 rate_i_m_1_corr ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_UINT32 __cil_tmp18 ;
  OPJ_FLOAT32 temp_size ;
  double __cil_tmp20 ;
  OPJ_FLOAT32 temp_rate ;
  OPJ_BOOL cap ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;
  size_t array_size ;
  void *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  void *__cil_tmp29 ;
  char const   comment[29] ;
  size_t clen ;
  unsigned long __cil_tmp32 ;
  char const   *version ;
  char const   *__cil_tmp34 ;
  size_t cp_comment_buf_size ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;
  OPJ_INT32 __cil_tmp38 ;
  OPJ_INT32 __cil_tmp39 ;
  void *__cil_tmp40 ;
  opj_tcp_t *tcp ;
  OPJ_BOOL fixed_distoratio ;
  OPJ_UINT32 __cil_tmp43 ;
  opj_poc_t *tcp_poc ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  void *__cil_tmp48 ;
  OPJ_UINT32 lMctSize ;
  OPJ_FLOAT32 *lTmpBuf ;
  void *__cil_tmp51 ;
  OPJ_INT32 *l_dc_shift ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  OPJ_BOOL __cil_tmp55 ;
  void *__cil_tmp56 ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_BOOL __cil_tmp59 ;
  opj_tccp_t *tccp___0 ;
  opj_image_comp_t *l_comp ;
  OPJ_UINT32 __cil_tmp62 ;
  opj_tccp_t *tccp___1 ;
  OPJ_INT32 __cil_tmp64 ;
  OPJ_INT32 __cil_tmp65 ;
  int tmp ;
  int tmp___0 ;
  OPJ_INT32 p ;
  OPJ_INT32 it_res ;
  OPJ_INT32 __cil_tmp70 ;
  OPJ_INT32 __cil_tmp71 ;
  OPJ_INT32 res_spec ;
  OPJ_INT32 size_prcw ;
  OPJ_INT32 size_prch ;
  OPJ_INT32 __cil_tmp75 ;
  OPJ_INT32 __cil_tmp76 ;
  OPJ_INT32 __cil_tmp77 ;
  OPJ_INT32 __cil_tmp78 ;
  OPJ_UINT32 __cil_tmp79 ;
  OPJ_UINT32 __cil_tmp80 ;
  OPJ_UINT32 __cil_tmp81 ;

  {
#line 7622
  cp = (opj_cp_t *)0;
#line 7625
  if (! p_j2k) {
#line 7626
    return (0);
  } else
#line 7625
  if (! parameters) {
#line 7626
    return (0);
  } else
#line 7625
  if (! image) {
#line 7626
    return (0);
  }
#line 7629
  if (parameters->numresolution <= 0) {
    {
    {
#line 7631
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 7634
    return (0);
  } else
#line 7629
  if (parameters->numresolution > 33) {
    {
    {
#line 7631
    opj_event_msg(p_manager, 1, "Invalid number of resolutions : %d not in range [1,%d]\n",
                  parameters->numresolution, 33);
    }
    }
#line 7634
    return (0);
  }
#line 7637
  if (parameters->cblockw_init < 4) {
    {
    {
#line 7638
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
    }
#line 7641
    return (0);
  } else
#line 7637
  if (parameters->cblockw_init > 1024) {
    {
    {
#line 7638
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
    }
#line 7641
    return (0);
  }
#line 7643
  if (parameters->cblockh_init < 4) {
    {
    {
#line 7644
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
    }
#line 7647
    return (0);
  } else
#line 7643
  if (parameters->cblockh_init > 1024) {
    {
    {
#line 7644
    opj_event_msg(p_manager, 1, "Invalid value for cblockh_init: %d not a power of 2 not in range [4,1024]\n",
                  parameters->cblockh_init);
    }
    }
#line 7647
    return (0);
  }
#line 7649
  if (parameters->cblockw_init * parameters->cblockh_init > 4096) {
    {
#line 7650
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init * cblockh_init: should be <= 4096\n");
    }
#line 7652
    return (0);
  }
  {
#line 7654
  __cil_tmp12 = opj_int_floorlog2(parameters->cblockw_init);
#line 7654
  cblkw = (OPJ_UINT32 )__cil_tmp12;
#line 7655
  __cil_tmp13 = opj_int_floorlog2(parameters->cblockh_init);
#line 7655
  cblkh = (OPJ_UINT32 )__cil_tmp13;
  }
#line 7656
  if (parameters->cblockw_init != 1 << cblkw) {
    {
#line 7657
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockw_init);
    }
#line 7660
    return (0);
  }
#line 7662
  if (parameters->cblockh_init != 1 << cblkh) {
    {
#line 7663
    opj_event_msg(p_manager, 1, "Invalid value for cblockw_init: %d not a power of 2 in range [4,1024]\n",
                  parameters->cblockh_init);
    }
#line 7666
    return (0);
  }
#line 7669
  if (parameters->cp_fixed_alloc) {
#line 7670
    if (parameters->cp_matrice == (void *)0) {
      {
#line 7671
      opj_event_msg(p_manager, 1, "cp_fixed_alloc set, but cp_matrice missing\n");
      }
#line 7673
      return (0);
    }
#line 7676
    if (parameters->tcp_numlayers > 10) {
      {
#line 7677
      opj_event_msg(p_manager, 1, "tcp_numlayers when cp_fixed_alloc set should not exceed %d\n\t\265U",
                    10);
      }
#line 7680
      return (0);
    }
#line 7682
    if (parameters->numresolution > 10) {
      {
#line 7683
      opj_event_msg(p_manager, 1, "numresolution when cp_fixed_alloc set should not exceed %d\n\t\265U",
                    10);
      }
#line 7686
      return (0);
    }
  }
#line 7690
  p_j2k->m_specific_param.m_encoder.m_nb_comps = image->numcomps;
#line 7693
  cp = & p_j2k->m_cp;
#line 7696
  cp->tw = (OPJ_UINT32 )1;
#line 7697
  cp->th = (OPJ_UINT32 )1;
#line 7700
  if ((int )parameters->rsiz == 0) {
#line 7702
    deprecated_used = 0;
    {
#line 7704
    if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 7704
      goto case_1;
    }
#line 7710
    if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 7710
      goto case_2;
    }
#line 7716
    if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 7716
      goto case_3;
    }
#line 7723
    goto switch_default;
    case_1: /* CIL Label */ 
#line 7705
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7706
    parameters->max_cs_size = 1302083;
#line 7707
    parameters->max_comp_size = 1041666;
#line 7708
    deprecated_used = 1;
#line 7709
    goto switch_break;
    case_2: /* CIL Label */ 
#line 7711
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7712
    parameters->max_cs_size = 651041;
#line 7713
    parameters->max_comp_size = 520833;
#line 7714
    deprecated_used = 1;
#line 7715
    goto switch_break;
    case_3: /* CIL Label */ 
#line 7717
    parameters->rsiz = (OPJ_UINT16 )4;
#line 7718
    parameters->max_cs_size = 1302083;
#line 7719
    parameters->max_comp_size = 1041666;
#line 7720
    deprecated_used = 1;
#line 7721
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 7724
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 7727
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )3) {
#line 7727
      goto case_3___0;
    }
#line 7731
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )4) {
#line 7731
      goto case_4;
    }
#line 7735
    if ((unsigned int )parameters->cp_rsiz == (unsigned int )33024) {
#line 7735
      goto case_33024;
    }
#line 7739
    goto switch_default___0;
    case_3___0: /* CIL Label */ 
#line 7728
    parameters->rsiz = (OPJ_UINT16 )3;
#line 7729
    deprecated_used = 1;
#line 7730
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 7732
    parameters->rsiz = (OPJ_UINT16 )4;
#line 7733
    deprecated_used = 1;
#line 7734
    goto switch_break___0;
    case_33024: /* CIL Label */ 
#line 7736
    parameters->rsiz = (OPJ_UINT16 )33024;
#line 7737
    deprecated_used = 1;
    switch_default___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 7740
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 7742
    if (deprecated_used) {
      {
#line 7743
      opj_event_msg(p_manager, 2, "Deprecated fields cp_cinema or cp_rsiz are used\nPlease consider using only the rsiz field\nSee openjpeg.h documentation for more details\n\220");
      }
    }
  }
#line 7751
  if (parameters->tcp_numlayers == 0) {
#line 7752
    parameters->tcp_numlayers = 1;
#line 7753
    parameters->cp_disto_alloc = 1;
#line 7754
    parameters->tcp_rates[0] = (float )0;
  }
#line 7757
  if (parameters->cp_disto_alloc) {
#line 7759
    i = (OPJ_UINT32 )1;
    {
#line 7759
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7759
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7759
        goto while_break;
      }
#line 7760
      rate_i_corr = parameters->tcp_rates[i];
#line 7761
      rate_i_m_1_corr = parameters->tcp_rates[i - 1U];
#line 7762
      if ((double )rate_i_corr <= 1.) {
#line 7763
        rate_i_corr = (OPJ_FLOAT32 )1.;
      }
#line 7765
      if ((double )rate_i_m_1_corr <= 1.) {
#line 7766
        rate_i_m_1_corr = (OPJ_FLOAT32 )1.;
      }
#line 7768
      if (rate_i_corr >= rate_i_m_1_corr) {
#line 7769
        if (rate_i_corr != parameters->tcp_rates[i]) {
#line 7769
          if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
            {
#line 7771
            opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n\205R\t\265U",
                          i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                          i - 1U, (double )parameters->tcp_rates[i - 1U], (double )rate_i_m_1_corr);
            }
          } else {
#line 7769
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 7776
        if (rate_i_corr != parameters->tcp_rates[i]) {
          {
#line 7777
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f (corrected as %f) should be strictly lesser than tcp_rates[%d]=%f\n",
                        i, (double )parameters->tcp_rates[i], (double )rate_i_corr,
                        i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        } else
#line 7782
        if (rate_i_m_1_corr != parameters->tcp_rates[i - 1U]) {
          {
#line 7783
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f (corrected as %f)\n",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U],
                        (double )rate_i_m_1_corr);
          }
        } else {
          {
#line 7789
          opj_event_msg(p_manager, 2, "tcp_rates[%d]=%f should be strictly lesser than tcp_rates[%d]=%f\nU",
                        i, (double )parameters->tcp_rates[i], i - 1U, (double )parameters->tcp_rates[i - 1U]);
          }
        }
      }
#line 7759
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 7797
  if (parameters->cp_fixed_quality) {
#line 7799
    i = (OPJ_UINT32 )1;
    {
#line 7799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7799
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7799
        goto while_break___0;
      }
#line 7800
      if (parameters->tcp_distoratio[i] < parameters->tcp_distoratio[i - 1U]) {
#line 7800
        if (! (i == (OPJ_UINT32 )parameters->tcp_numlayers - 1U && parameters->tcp_distoratio[i] == (float )0)) {
          {
#line 7803
          opj_event_msg(p_manager, 2, "tcp_distoratio[%d]=%f should be strictly greater than tcp_distoratio[%d]=%f\n\230\001",
                        i, (double )parameters->tcp_distoratio[i], i - 1U, (double )parameters->tcp_distoratio[i - 1U]);
          }
        }
      }
#line 7799
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7813
  if (parameters->max_cs_size <= 0) {
#line 7814
    if (parameters->tcp_rates[parameters->tcp_numlayers - 1] > (float )0) {
#line 7816
      temp_size = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->tcp_rates[parameters->tcp_numlayers - 1] * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 7820
      if (temp_size > (float )2147483647) {
#line 7821
        parameters->max_cs_size = 2147483647;
      } else {
        {
#line 7823
        __cil_tmp20 = floor((double )temp_size);
#line 7823
        parameters->max_cs_size = (int )__cil_tmp20;
        }
      }
    } else {
#line 7826
      parameters->max_cs_size = 0;
    }
  } else {
#line 7830
    cap = 0;
#line 7832
    if ((int )parameters->rsiz >= 1024) {
#line 7832
      if ((int )parameters->rsiz <= 2459) {
#line 7832
        if (parameters->max_cs_size > 0) {
#line 7832
          if (parameters->tcp_numlayers == 1) {
#line 7832
            if (parameters->tcp_rates[0] == (float )0) {
#line 7834
              parameters->tcp_rates[0] = (OPJ_FLOAT32 )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (OPJ_FLOAT32 )((((OPJ_UINT32 )parameters->max_cs_size * 8U) * (image->comps + 0)->dx) * (image->comps + 0)->dy);
            }
          }
        }
      }
    }
#line 7840
    temp_rate = (OPJ_FLOAT32 )(((((double )image->numcomps * (double )(image->comps + 0)->w) * (double )(image->comps + 0)->h) * (double )(image->comps + 0)->prec) / ((((double )parameters->max_cs_size * (double )8) * (double )(image->comps + 0)->dx) * (double )(image->comps + 0)->dy));
#line 7844
    i = (OPJ_UINT32 )0;
    {
#line 7844
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7844
      if (! (i < (OPJ_UINT32 )parameters->tcp_numlayers)) {
#line 7844
        goto while_break___1;
      }
#line 7845
      if (parameters->tcp_rates[i] < temp_rate) {
#line 7846
        parameters->tcp_rates[i] = temp_rate;
#line 7847
        cap = 1;
      }
#line 7844
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7850
    if (cap) {
      {
#line 7851
      opj_event_msg(p_manager, 2, "The desired maximum codestream size has limited\nat least one of the desired quality layers\n");
      }
    }
  }
#line 7857
  if ((int )parameters->rsiz >= 3) {
#line 7857
    if ((int )parameters->rsiz <= 6) {
#line 7858
      p_j2k->m_specific_param.m_encoder.m_TLM = 1;
    } else {
#line 7857
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 7857
  if ((int )parameters->rsiz >= 1024) {
#line 7857
    if ((int )parameters->rsiz <= 2459) {
#line 7858
      p_j2k->m_specific_param.m_encoder.m_TLM = 1;
    }
  }
#line 7863
  if ((int )parameters->rsiz >= 3) {
#line 7863
    if ((int )parameters->rsiz <= 6) {
#line 7864
      if ((int )parameters->rsiz == 5) {
        {
        {
#line 7866
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 7868
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else
#line 7864
      if ((int )parameters->rsiz == 6) {
        {
        {
#line 7866
        opj_event_msg(p_manager, 2, "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
        }
#line 7868
        parameters->rsiz = (OPJ_UINT16 )0;
        }
      } else {
        {
#line 7870
        opj_j2k_set_cinema_parameters(parameters, image, p_manager);
#line 7871
        __cil_tmp24 = opj_j2k_is_cinema_compliant(image, parameters->rsiz, p_manager);
        }
#line 7871
        if (! __cil_tmp24) {
#line 7872
          parameters->rsiz = (OPJ_UINT16 )0;
        }
      }
    } else {
#line 7863
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
#line 7875
  if ((int )parameters->rsiz == 7) {
    {
#line 7876
    opj_event_msg(p_manager, 2, "JPEG 2000 Long Term Storage profile not yet supported\n");
#line 7878
    parameters->rsiz = (OPJ_UINT16 )0;
    }
  } else
#line 7879
  if ((int )parameters->rsiz >= 256) {
#line 7879
    if ((int )parameters->rsiz <= 779) {
      {
#line 7880
      opj_event_msg(p_manager, 2, "JPEG 2000 Broadcast profiles not yet supported\n");
#line 7882
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7879
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 7883
  if ((int )parameters->rsiz >= 1024) {
#line 7883
    if ((int )parameters->rsiz <= 2459) {
      {
#line 7884
      opj_j2k_set_imf_parameters(parameters, image, p_manager);
#line 7885
      __cil_tmp25 = opj_j2k_is_imf_compliant(parameters, image, p_manager);
      }
#line 7885
      if (! __cil_tmp25) {
#line 7886
        parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else {
#line 7883
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 7888
  if ((int )parameters->rsiz & 32768) {
#line 7889
    if ((int )parameters->rsiz == 32768) {
      {
#line 7890
      opj_event_msg(p_manager, 2, "JPEG 2000 Part-2 profile defined\nbut no Part-2 extension enabled.\nProfile set to NONE.\n");
#line 7894
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    } else
#line 7895
    if ((int )parameters->rsiz != 33024) {
      {
#line 7896
      opj_event_msg(p_manager, 2, "Unsupported Part-2 extension enabled\nProfile set to NONE.\n");
#line 7899
      parameters->rsiz = (OPJ_UINT16 )0;
      }
    }
  }
#line 7906
  cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32 )parameters->max_comp_size;
#line 7908
  cp->rsiz = parameters->rsiz;
#line 7909
  if (parameters->cp_fixed_alloc) {
#line 7910
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )2;
  } else
#line 7911
  if (parameters->cp_fixed_quality) {
#line 7912
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )1;
  } else {
#line 7915
    cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy = (J2K_QUALITY_LAYER_ALLOCATION_STRATEGY )0;
  }
#line 7919
  if (parameters->cp_fixed_alloc) {
    {
#line 7920
    array_size = (((size_t )parameters->tcp_numlayers * (size_t )parameters->numresolution) * 3UL) * sizeof(OPJ_INT32 );
#line 7922
    __cil_tmp27 = opj_malloc(array_size);
#line 7922
    cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)__cil_tmp27;
    }
#line 7923
    if (! cp->m_specific_param.m_enc.m_matrice) {
      {
#line 7924
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of user encoding parameters matrix \n");
      }
#line 7926
      return (0);
    }
    {
#line 7928
    memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);
    }
  }
#line 7933
  cp->tdx = (OPJ_UINT32 )parameters->cp_tdx;
#line 7934
  cp->tdy = (OPJ_UINT32 )parameters->cp_tdy;
#line 7937
  cp->tx0 = (OPJ_UINT32 )parameters->cp_tx0;
#line 7938
  cp->ty0 = (OPJ_UINT32 )parameters->cp_ty0;
#line 7941
  if (parameters->cp_comment) {
    {
#line 7942
    __cil_tmp28 = strlen((char const   *)parameters->cp_comment);
#line 7942
    __cil_tmp29 = opj_malloc(__cil_tmp28 + 1UL);
#line 7942
    cp->comment = (char *)__cil_tmp29;
    }
#line 7943
    if (! cp->comment) {
      {
#line 7944
      opj_event_msg(p_manager, 1, "Not enough memory to allocate copy of comment string\n");
      }
#line 7946
      return (0);
    }
    {
#line 7948
    strcpy(cp->comment, (char const   *)parameters->cp_comment);
    }
  } else {
    {
#line 7951
    comment = "Created by OpenJPEG version \265U";
#line 7952
    __cil_tmp32 = strlen((char const   *)comment);
#line 7952
    clen = __cil_tmp32;
#line 7953
    __cil_tmp34 = opj_version();
#line 7953
    version = __cil_tmp34;
#line 7967
    __cil_tmp36 = strlen(version);
#line 7967
    cp_comment_buf_size = (clen + __cil_tmp36) + 1UL;
#line 7968
    __cil_tmp37 = opj_malloc(cp_comment_buf_size);
#line 7968
    cp->comment = (char *)__cil_tmp37;
    }
#line 7969
    if (! cp->comment) {
      {
#line 7970
      opj_event_msg(p_manager, 1, "Not enough memory to allocate comment string\n");
      }
#line 7972
      return (0);
    }
    {
#line 7974
    snprintf(cp->comment, cp_comment_buf_size, "%s%s\265U", (char const   *)comment,
             version);
    }
  }
#line 7983
  if (parameters->tile_size_on) {
#line 7984
    if (cp->tdx == 0U) {
      {
#line 7985
      opj_event_msg(p_manager, 1, "Invalid tile width\n\t\265U");
      }
#line 7986
      return (0);
    }
#line 7988
    if (cp->tdy == 0U) {
      {
#line 7989
      opj_event_msg(p_manager, 1, "Invalid tile height\n\265U");
      }
#line 7990
      return (0);
    }
    {
#line 7992
    __cil_tmp38 = opj_int_ceildiv((OPJ_INT32 )(image->x1 - cp->tx0), (OPJ_INT32 )cp->tdx);
#line 7992
    cp->tw = (OPJ_UINT32 )__cil_tmp38;
#line 7994
    __cil_tmp39 = opj_int_ceildiv((OPJ_INT32 )(image->y1 - cp->ty0), (OPJ_INT32 )cp->tdy);
#line 7994
    cp->th = (OPJ_UINT32 )__cil_tmp39;
    }
#line 7997
    if (cp->tw > 65535U / cp->th) {
      {
#line 7998
      opj_event_msg(p_manager, 1, "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\nS\t\265U",
                    cp->tw, cp->th);
      }
#line 8001
      return (0);
    }
  } else {
#line 8004
    cp->tdx = image->x1 - cp->tx0;
#line 8005
    cp->tdy = image->y1 - cp->ty0;
  }
#line 8008
  if (parameters->tp_on) {
#line 8009
    cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE )parameters->tp_flag;
#line 8010
    cp->m_specific_param.m_enc.m_tp_on = (OPJ_BITFIELD )1;
  }
  {
#line 8071
  __cil_tmp40 = opj_calloc((size_t )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 8071
  cp->tcps = (opj_tcp_t *)__cil_tmp40;
  }
#line 8072
  if (! cp->tcps) {
    {
#line 8073
    opj_event_msg(p_manager, 1, "Not enough memory to allocate tile coding parameters\n");
    }
#line 8075
    return (0);
  }
#line 8078
  tileno = (OPJ_UINT32 )0;
  {
#line 8078
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8078
    if (! (tileno < cp->tw * cp->th)) {
#line 8078
      goto while_break___2;
    }
#line 8079
    tcp = cp->tcps + tileno;
#line 8080
    fixed_distoratio = (unsigned int )cp->m_specific_param.m_enc.m_quality_layer_alloc_strategy == 1U;
#line 8083
    tcp->numlayers = (OPJ_UINT32 )parameters->tcp_numlayers;
#line 8085
    j = (OPJ_UINT32 )0;
    {
#line 8085
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 8085
      if (! (j < tcp->numlayers)) {
#line 8085
        goto while_break___3;
      }
#line 8086
      if ((int )cp->rsiz >= 3) {
#line 8086
        if ((int )cp->rsiz <= 6) {
          _L___13: /* CIL Label */ 
#line 8087
          if (fixed_distoratio) {
#line 8088
            tcp->distoratio[j] = parameters->tcp_distoratio[j];
          }
#line 8090
          tcp->rates[j] = parameters->tcp_rates[j];
        } else {
#line 8086
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 8086
      if ((int )cp->rsiz >= 1024) {
#line 8086
        if ((int )cp->rsiz <= 2459) {
#line 8086
          goto _L___13;
        } else {
#line 8086
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 8092
      if (fixed_distoratio) {
#line 8093
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 8095
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 8098
      if (! fixed_distoratio) {
#line 8098
        if ((double )tcp->rates[j] <= 1.) {
#line 8100
          tcp->rates[j] = (OPJ_FLOAT32 )0.;
        }
      }
#line 8085
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 8104
    tcp->csty = (OPJ_UINT32 )parameters->csty;
#line 8105
    tcp->prg = parameters->prog_order;
#line 8106
    tcp->mct = (OPJ_UINT32 )parameters->tcp_mct;
#line 8108
    numpocs_tile = (OPJ_UINT32 )0;
#line 8109
    tcp->POC = (OPJ_BITFIELD )0;
#line 8111
    if (parameters->numpocs) {
#line 8113
      i = (OPJ_UINT32 )0;
      {
#line 8113
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 8113
        if (! (i < parameters->numpocs)) {
#line 8113
          goto while_break___4;
        }
#line 8114
        if (tileno + 1U == parameters->POC[i].tile) {
#line 8115
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 8117
          if (parameters->POC[numpocs_tile].compno0 >= image->numcomps) {
            {
#line 8118
            opj_event_msg(p_manager, 1, "Invalid compno0 for POC %d\n", i);
            }
#line 8120
            return (0);
          }
          {
#line 8123
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 8124
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 8125
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 8126
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 8127
          tcp_poc->compno1 = opj_uint_min(parameters->POC[numpocs_tile].compno1, image->numcomps);
#line 8129
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 8130
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 8132
          numpocs_tile ++;
          }
        }
#line 8113
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 8136
      if (numpocs_tile) {
        {
#line 8139
        opj_j2k_check_poc_val((opj_poc_t *)parameters->POC, tileno, parameters->numpocs,
                              (OPJ_UINT32 )parameters->numresolution, image->numcomps,
                              (OPJ_UINT32 )parameters->tcp_numlayers, p_manager);
#line 8143
        tcp->POC = (OPJ_BITFIELD )1;
#line 8144
        tcp->numpocs = numpocs_tile - 1U;
        }
      }
    } else {
#line 8147
      tcp->numpocs = (OPJ_UINT32 )0;
    }
    {
#line 8150
    __cil_tmp48 = opj_calloc((size_t )image->numcomps, sizeof(opj_tccp_t ));
#line 8150
    tcp->tccps = (opj_tccp_t *)__cil_tmp48;
    }
#line 8151
    if (! tcp->tccps) {
      {
#line 8152
      opj_event_msg(p_manager, 1, "Not enough memory to allocate tile component coding parameters\n");
      }
#line 8154
      return (0);
    }
#line 8156
    if (parameters->mct_data) {
      {
#line 8158
      lMctSize = (image->numcomps * image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 8160
      __cil_tmp51 = opj_malloc((size_t )lMctSize);
#line 8160
      lTmpBuf = (OPJ_FLOAT32 *)__cil_tmp51;
#line 8161
      l_dc_shift = (OPJ_INT32 *)((OPJ_BYTE *)parameters->mct_data + lMctSize);
      }
#line 8164
      if (! lTmpBuf) {
        {
#line 8165
        opj_event_msg(p_manager, 1, "Not enough memory to allocate temp buffer\n");
        }
#line 8167
        return (0);
      }
      {
#line 8170
      tcp->mct = (OPJ_UINT32 )2;
#line 8171
      __cil_tmp53 = opj_malloc((size_t )lMctSize);
#line 8171
      tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)__cil_tmp53;
      }
#line 8172
      if (! tcp->m_mct_coding_matrix) {
        {
#line 8173
        opj_free(lTmpBuf);
#line 8174
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8175
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT coding matrix \n");
        }
#line 8177
        return (0);
      }
      {
#line 8179
      memcpy(tcp->m_mct_coding_matrix, parameters->mct_data, (unsigned long )lMctSize);
#line 8180
      memcpy(lTmpBuf, parameters->mct_data, (unsigned long )lMctSize);
#line 8182
      __cil_tmp54 = opj_malloc((size_t )lMctSize);
#line 8182
      tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp54;
      }
#line 8183
      if (! tcp->m_mct_decoding_matrix) {
        {
#line 8184
        opj_free(lTmpBuf);
#line 8185
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8186
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT decoding matrix \n");
        }
#line 8188
        return (0);
      }
      {
#line 8190
      __cil_tmp55 = opj_matrix_inversion_f(lTmpBuf, tcp->m_mct_decoding_matrix, image->numcomps);
      }
#line 8190
      if (__cil_tmp55 == 0) {
        {
#line 8192
        opj_free(lTmpBuf);
#line 8193
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8194
        opj_event_msg(p_manager, 1, "Failed to inverse encoder MCT decoding matrix \n");
        }
#line 8196
        return (0);
      }
      {
#line 8199
      __cil_tmp56 = opj_malloc((unsigned long )image->numcomps * sizeof(OPJ_FLOAT64 ));
#line 8199
      tcp->mct_norms = (OPJ_FLOAT64 *)__cil_tmp56;
      }
#line 8201
      if (! tcp->mct_norms) {
        {
#line 8202
        opj_free(lTmpBuf);
#line 8203
        lTmpBuf = (OPJ_FLOAT32 *)((void *)0);
#line 8204
        opj_event_msg(p_manager, 1, "Not enough memory to allocate encoder MCT norms \n");
        }
#line 8206
        return (0);
      }
      {
#line 8208
      opj_calculate_norms(tcp->mct_norms, image->numcomps, tcp->m_mct_decoding_matrix);
#line 8210
      opj_free(lTmpBuf);
#line 8212
      i = (OPJ_UINT32 )0;
      }
      {
#line 8212
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 8212
        if (! (i < image->numcomps)) {
#line 8212
          goto while_break___5;
        }
#line 8213
        tccp = tcp->tccps + i;
#line 8214
        tccp->m_dc_level_shift = *(l_dc_shift + i);
#line 8212
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 8217
      __cil_tmp59 = opj_j2k_setup_mct_encoding(tcp, image);
      }
#line 8217
      if (__cil_tmp59 == 0) {
        {
#line 8219
        opj_event_msg(p_manager, 1, "Failed to setup j2k mct encoding\n");
        }
#line 8220
        return (0);
      }
    } else {
#line 8223
      if (tcp->mct == 1U) {
#line 8223
        if (image->numcomps >= 3U) {
#line 8224
          if ((image->comps + 0)->dx != (image->comps + 1)->dx) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dx != (image->comps + 2)->dx) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dy != (image->comps + 1)->dy) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          } else
#line 8224
          if ((image->comps + 0)->dy != (image->comps + 2)->dy) {
            {
            {
            {
            {
#line 8228
            opj_event_msg(p_manager, 2, "Cannot perform MCT on components with different sizes. Disabling MCT.\n");
            }
            }
            }
#line 8230
            tcp->mct = (OPJ_UINT32 )0;
            }
          }
        }
      }
#line 8233
      i = (OPJ_UINT32 )0;
      {
#line 8233
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 8233
        if (! (i < image->numcomps)) {
#line 8233
          goto while_break___6;
        }
#line 8234
        tccp___0 = tcp->tccps + i;
#line 8235
        l_comp = image->comps + i;
#line 8237
        if (! l_comp->sgnd) {
#line 8238
          tccp___0->m_dc_level_shift = 1 << (l_comp->prec - 1U);
        }
#line 8233
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 8243
    i = (OPJ_UINT32 )0;
    {
#line 8243
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 8243
      if (! (i < image->numcomps)) {
#line 8243
        goto while_break___7;
      }
      {
#line 8244
      tccp___1 = tcp->tccps + i;
#line 8246
      tccp___1->csty = (OPJ_UINT32 )(parameters->csty & 1);
#line 8248
      tccp___1->numresolutions = (OPJ_UINT32 )parameters->numresolution;
#line 8249
      __cil_tmp64 = opj_int_floorlog2(parameters->cblockw_init);
#line 8249
      tccp___1->cblkw = (OPJ_UINT32 )__cil_tmp64;
#line 8250
      __cil_tmp65 = opj_int_floorlog2(parameters->cblockh_init);
#line 8250
      tccp___1->cblkh = (OPJ_UINT32 )__cil_tmp65;
#line 8251
      tccp___1->cblksty = (OPJ_UINT32 )parameters->mode;
      }
#line 8252
      if (parameters->irreversible) {
#line 8252
        tmp = 0;
      } else {
#line 8252
        tmp = 1;
      }
#line 8252
      tccp___1->qmfbid = (OPJ_UINT32 )tmp;
#line 8253
      if (parameters->irreversible) {
#line 8253
        tmp___0 = 2;
      } else {
#line 8253
        tmp___0 = 0;
      }
#line 8253
      tccp___1->qntsty = (OPJ_UINT32 )tmp___0;
#line 8255
      tccp___1->numgbits = (OPJ_UINT32 )2;
#line 8257
      if ((OPJ_INT32 )i == parameters->roi_compno) {
#line 8258
        tccp___1->roishift = parameters->roi_shift;
      } else {
#line 8260
        tccp___1->roishift = 0;
      }
#line 8263
      if (parameters->csty & 1) {
#line 8264
        p = 0;
#line 8266
        it_res = (OPJ_INT32 )tccp___1->numresolutions - 1;
        {
#line 8266
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 8266
          if (! (it_res >= 0)) {
#line 8266
            goto while_break___8;
          }
#line 8267
          if (p < parameters->res_spec) {
#line 8269
            if (parameters->prcw_init[p] < 1) {
#line 8270
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8272
              __cil_tmp70 = opj_int_floorlog2(parameters->prcw_init[p]);
#line 8272
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp70;
              }
            }
#line 8275
            if (parameters->prch_init[p] < 1) {
#line 8276
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8278
              __cil_tmp71 = opj_int_floorlog2(parameters->prch_init[p]);
#line 8278
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp71;
              }
            }
          } else {
#line 8282
            res_spec = parameters->res_spec;
#line 8283
            size_prcw = 0;
#line 8284
            size_prch = 0;
#line 8287
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8288
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 8291
            if (size_prcw < 1) {
#line 8292
              tccp___1->prcw[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8294
              __cil_tmp75 = opj_int_floorlog2(size_prcw);
#line 8294
              tccp___1->prcw[it_res] = (OPJ_UINT32 )__cil_tmp75;
              }
            }
#line 8297
            if (size_prch < 1) {
#line 8298
              tccp___1->prch[it_res] = (OPJ_UINT32 )1;
            } else {
              {
#line 8300
              __cil_tmp76 = opj_int_floorlog2(size_prch);
#line 8300
              tccp___1->prch[it_res] = (OPJ_UINT32 )__cil_tmp76;
              }
            }
          }
#line 8303
          p ++;
#line 8266
          __cil_tmp78 = it_res;
#line 8266
          it_res --;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
#line 8307
        j = (OPJ_UINT32 )0;
        {
#line 8307
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 8307
          if (! (j < tccp___1->numresolutions)) {
#line 8307
            goto while_break___9;
          }
#line 8308
          tccp___1->prcw[j] = (OPJ_UINT32 )15;
#line 8309
          tccp___1->prch[j] = (OPJ_UINT32 )15;
#line 8307
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      {
#line 8313
      opj_dwt_calc_explicit_stepsizes(tccp___1, (image->comps + i)->prec);
      }
#line 8243
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 8078
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 8317
  if (parameters->mct_data) {
    {
#line 8318
    opj_free(parameters->mct_data);
#line 8319
    parameters->mct_data = (void *)0;
    }
  }
#line 8321
  return (1);
}
}
#line 8324 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index , OPJ_UINT32 type ,
                                     OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 8330
  if (cstr_index->marknum + 1U > cstr_index->maxmarknum) {
    {
#line 8332
    cstr_index->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )cstr_index->maxmarknum);
#line 8334
    __cil_tmp6 = opj_realloc(cstr_index->marker, (unsigned long )cstr_index->maxmarknum * sizeof(opj_marker_info_t ));
#line 8334
    new_marker = (opj_marker_info_t *)__cil_tmp6;
    }
#line 8336
    if (! new_marker) {
      {
#line 8337
      opj_free(cstr_index->marker);
#line 8338
      cstr_index->marker = (opj_marker_info_t *)((void *)0);
#line 8339
      cstr_index->maxmarknum = (OPJ_UINT32 )0;
#line 8340
      cstr_index->marknum = (OPJ_UINT32 )0;
      }
#line 8342
      return (0);
    }
#line 8344
    cstr_index->marker = new_marker;
  }
#line 8348
  (cstr_index->marker + cstr_index->marknum)->type = (OPJ_UINT16 )type;
#line 8349
  (cstr_index->marker + cstr_index->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 8350
  (cstr_index->marker + cstr_index->marknum)->len = (OPJ_INT32 )len;
#line 8351
  (cstr_index->marknum) ++;
#line 8352
  return (1);
}
}
#line 8355 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno , opj_codestream_index_t *cstr_index ,
                                     OPJ_UINT32 type , OPJ_OFF_T pos , OPJ_UINT32 len ) 
{ 
  opj_marker_info_t *new_marker ;
  void *__cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 l_current_tile_part ;

  {
#line 8363
  if ((cstr_index->tile_index + tileno)->marknum + 1U > (cstr_index->tile_index + tileno)->maxmarknum) {
    {
#line 8366
    (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )((float )100 + (OPJ_FLOAT32 )(cstr_index->tile_index + tileno)->maxmarknum);
#line 8368
    __cil_tmp7 = opj_realloc((cstr_index->tile_index + tileno)->marker, (unsigned long )(cstr_index->tile_index + tileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 8368
    new_marker = (opj_marker_info_t *)__cil_tmp7;
    }
#line 8371
    if (! new_marker) {
      {
#line 8372
      opj_free((cstr_index->tile_index + tileno)->marker);
#line 8373
      (cstr_index->tile_index + tileno)->marker = (opj_marker_info_t *)((void *)0);
#line 8374
      (cstr_index->tile_index + tileno)->maxmarknum = (OPJ_UINT32 )0;
#line 8375
      (cstr_index->tile_index + tileno)->marknum = (OPJ_UINT32 )0;
      }
#line 8377
      return (0);
    }
#line 8379
    (cstr_index->tile_index + tileno)->marker = new_marker;
  }
#line 8383
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->type = (OPJ_UINT16 )type;
#line 8385
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->pos = (OPJ_OFF_T )((OPJ_INT32 )pos);
#line 8387
  ((cstr_index->tile_index + tileno)->marker + (cstr_index->tile_index + tileno)->marknum)->len = (OPJ_INT32 )len;
#line 8389
  ((cstr_index->tile_index + tileno)->marknum) ++;
#line 8391
  if (type == 65424U) {
#line 8392
    l_current_tile_part = (cstr_index->tile_index + tileno)->current_tpsno;
#line 8394
    if ((cstr_index->tile_index + tileno)->tp_index) {
#line 8395
      ((cstr_index->tile_index + tileno)->tp_index + l_current_tile_part)->start_pos = pos;
    }
  }
#line 8399
  return (1);
}
}
#line 8408 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8416
  return (1);
}
}
#line 8419 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_header(opj_stream_private_t *p_stream , opj_j2k_t *p_j2k , opj_image_t **p_image ,
                             opj_event_mgr_t *p_manager ) 
{ 
  opj_image_t *__cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  opj_image_t *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 8430
  p_j2k->m_private_image = opj_image_create0();
  }
#line 8431
  if (! p_j2k->m_private_image) {
#line 8432
    return (0);
  }
  {
#line 8436
  __cil_tmp6 = opj_j2k_setup_decoding_validation(p_j2k, p_manager);
  }
#line 8436
  if (! __cil_tmp6) {
    {
#line 8437
    opj_image_destroy(p_j2k->m_private_image);
#line 8438
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8439
    return (0);
  }
  {
#line 8443
  __cil_tmp7 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 8443
  if (! __cil_tmp7) {
    {
#line 8444
    opj_image_destroy(p_j2k->m_private_image);
#line 8445
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8446
    return (0);
  }
  {
#line 8450
  __cil_tmp8 = opj_j2k_setup_header_reading(p_j2k, p_manager);
  }
#line 8450
  if (! __cil_tmp8) {
    {
#line 8451
    opj_image_destroy(p_j2k->m_private_image);
#line 8452
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8453
    return (0);
  }
  {
#line 8457
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 8457
  if (! __cil_tmp9) {
    {
#line 8458
    opj_image_destroy(p_j2k->m_private_image);
#line 8459
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 8460
    return (0);
  }
  {
#line 8463
  *p_image = opj_image_create0();
  }
#line 8464
  if (! *p_image) {
#line 8465
    return (0);
  }
  {
#line 8469
  opj_copy_image_header(p_j2k->m_private_image, *p_image);
#line 8472
  __cil_tmp11 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
  }
#line 8472
  if (! __cil_tmp11) {
    {
#line 8473
    opj_image_destroy(*p_image);
#line 8474
    *p_image = (opj_image_t *)((void *)0);
    }
#line 8475
    return (0);
  }
#line 8478
  return (1);
}
}
#line 8481 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_reading(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 8488
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_read_header_procedure),
                                                p_manager);
  }
#line 8488
  if (! __cil_tmp3) {
#line 8490
    return (0);
  }
  {
#line 8494
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_copy_default_tcp_and_create_tcd),
                                                p_manager);
  }
#line 8494
  if (! __cil_tmp4) {
#line 8496
    return (0);
  }
#line 8499
  return (1);
}
}
#line 8502 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;

  {
  {
#line 8509
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_decoder),
                                                p_manager);
  }
#line 8509
  if (! __cil_tmp3) {
#line 8511
    return (0);
  }
  {
#line 8513
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_decoding_validation),
                                                p_manager);
  }
#line 8513
  if (! __cil_tmp4) {
#line 8515
    return (0);
  }
#line 8519
  return (1);
}
}
#line 8522 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_mct_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                       opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 8526
  l_is_valid = 1;
#line 8537
  if (((int )p_j2k->m_cp.rsiz & 33280) == 33280) {
#line 8538
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 8539
    l_tcp = p_j2k->m_cp.tcps;
#line 8541
    i = (OPJ_UINT32 )0;
    {
#line 8541
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8541
      if (! (i < l_nb_tiles)) {
#line 8541
        goto while_break;
      }
#line 8542
      if (l_tcp->mct == 2U) {
#line 8543
        l_tccp = l_tcp->tccps;
#line 8544
        l_is_valid &= l_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0;
#line 8546
        j = (OPJ_UINT32 )0;
        {
#line 8546
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 8546
          if (! (j < (p_j2k->m_private_image)->numcomps)) {
#line 8546
            goto while_break___0;
          }
#line 8547
          l_is_valid &= ! (l_tccp->qmfbid & 1U);
#line 8548
          l_tccp ++;
#line 8546
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 8551
      l_tcp ++;
#line 8541
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 8555
  return (l_is_valid);
}
}
#line 8558 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t *p_tcp , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_indix ;
  opj_mct_data_t *l_mct_deco_data ;
  opj_mct_data_t *l_mct_offset_data ;
  opj_simple_mcc_decorrelation_data_t *l_mcc_data ;
  OPJ_UINT32 l_mct_size ;
  OPJ_UINT32 l_nb_elem ;
  OPJ_FLOAT32 *l_data ;
  OPJ_FLOAT32 *l_current_data ;
  opj_tccp_t *l_tccp ;
  opj_mct_data_t *new_mct_records ;
  void *__cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  void *__cil_tmp16 ;
  opj_mct_data_t *new_mct_records___0 ;
  void *__cil_tmp18 ;
  OPJ_UINT32 __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  OPJ_FLOAT32 *__cil_tmp22 ;
  opj_simple_mcc_decorrelation_data_t *new_mcc_records ;
  void *__cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;

  {
#line 8561
  l_indix = (OPJ_UINT32 )1;
#line 8562
  l_mct_deco_data = (opj_mct_data_t *)0;
#line 8562
  l_mct_offset_data = (opj_mct_data_t *)0;
#line 8571
  if (p_tcp->mct != 2U) {
#line 8572
    return (1);
  }
#line 8575
  if (p_tcp->m_mct_decoding_matrix) {
#line 8576
    if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
      {
#line 8578
      p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 8580
      __cil_tmp14 = opj_realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8580
      new_mct_records = (opj_mct_data_t *)__cil_tmp14;
      }
#line 8582
      if (! new_mct_records) {
        {
#line 8583
        opj_free(p_tcp->m_mct_records);
#line 8584
        p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8585
        p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8586
        p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
        }
#line 8588
        return (0);
      }
      {
#line 8590
      p_tcp->m_mct_records = new_mct_records;
#line 8591
      l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8593
      memset(l_mct_deco_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
      }
    }
#line 8597
    l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8599
    if (l_mct_deco_data->m_data) {
      {
#line 8600
      opj_free(l_mct_deco_data->m_data);
#line 8601
      l_mct_deco_data->m_data = (OPJ_BYTE *)0;
      }
    }
    {
#line 8604
    __cil_tmp15 = l_indix;
#line 8604
    l_indix ++;
#line 8604
    l_mct_deco_data->m_index = __cil_tmp15;
#line 8605
    l_mct_deco_data->m_array_type = (J2K_MCT_ARRAY_TYPE )1;
#line 8606
    l_mct_deco_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8607
    l_nb_elem = p_image->numcomps * p_image->numcomps;
#line 8608
    l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
#line 8609
    __cil_tmp16 = opj_malloc((size_t )l_mct_size);
#line 8609
    l_mct_deco_data->m_data = (OPJ_BYTE *)__cil_tmp16;
    }
#line 8611
    if (! l_mct_deco_data->m_data) {
#line 8612
      return (0);
    }
    {
#line 8615
    (*(j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type]))(p_tcp->m_mct_decoding_matrix,
                                                                             l_mct_deco_data->m_data,
                                                                             l_nb_elem);
#line 8618
    l_mct_deco_data->m_data_size = l_mct_size;
#line 8619
    (p_tcp->m_nb_mct_records) ++;
    }
  }
#line 8622
  if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
    {
#line 8624
    p_tcp->m_nb_max_mct_records += (unsigned int )10;
#line 8625
    __cil_tmp18 = opj_realloc(p_tcp->m_mct_records, (unsigned long )p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t ));
#line 8625
    new_mct_records___0 = (opj_mct_data_t *)__cil_tmp18;
    }
#line 8627
    if (! new_mct_records___0) {
      {
#line 8628
      opj_free(p_tcp->m_mct_records);
#line 8629
      p_tcp->m_mct_records = (opj_mct_data_t *)((void *)0);
#line 8630
      p_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 8631
      p_tcp->m_nb_mct_records = (OPJ_UINT32 )0;
      }
#line 8633
      return (0);
    }
    {
#line 8635
    p_tcp->m_mct_records = new_mct_records___0;
#line 8636
    l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8638
    memset(l_mct_offset_data, 0, (unsigned long )(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t ));
    }
#line 8642
    if (l_mct_deco_data) {
#line 8643
      l_mct_deco_data = l_mct_offset_data - 1;
    }
  }
#line 8647
  l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
#line 8649
  if (l_mct_offset_data->m_data) {
    {
#line 8650
    opj_free(l_mct_offset_data->m_data);
#line 8651
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
  }
  {
#line 8654
  __cil_tmp19 = l_indix;
#line 8654
  l_indix ++;
#line 8654
  l_mct_offset_data->m_index = __cil_tmp19;
#line 8655
  l_mct_offset_data->m_array_type = (J2K_MCT_ARRAY_TYPE )2;
#line 8656
  l_mct_offset_data->m_element_type = (J2K_MCT_ELEMENT_TYPE )2;
#line 8657
  l_nb_elem = p_image->numcomps;
#line 8658
  l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
#line 8659
  __cil_tmp20 = opj_malloc((size_t )l_mct_size);
#line 8659
  l_mct_offset_data->m_data = (OPJ_BYTE *)__cil_tmp20;
  }
#line 8661
  if (! l_mct_offset_data->m_data) {
#line 8662
    return (0);
  }
  {
#line 8665
  __cil_tmp21 = opj_malloc((unsigned long )l_nb_elem * sizeof(OPJ_FLOAT32 ));
#line 8665
  l_data = (OPJ_FLOAT32 *)__cil_tmp21;
  }
#line 8666
  if (! l_data) {
    {
#line 8667
    opj_free(l_mct_offset_data->m_data);
#line 8668
    l_mct_offset_data->m_data = (OPJ_BYTE *)0;
    }
#line 8669
    return (0);
  }
#line 8672
  l_tccp = p_tcp->tccps;
#line 8673
  l_current_data = l_data;
#line 8675
  i = (OPJ_UINT32 )0;
  {
#line 8675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8675
    if (! (i < l_nb_elem)) {
#line 8675
      goto while_break;
    }
#line 8676
    __cil_tmp22 = l_current_data;
#line 8676
    l_current_data ++;
#line 8676
    *__cil_tmp22 = (OPJ_FLOAT32 )l_tccp->m_dc_level_shift;
#line 8677
    l_tccp ++;
#line 8675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8680
  (*(j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type]))(l_data,
                                                                             l_mct_offset_data->m_data,
                                                                             l_nb_elem);
#line 8683
  opj_free(l_data);
#line 8685
  l_mct_offset_data->m_data_size = l_mct_size;
#line 8687
  (p_tcp->m_nb_mct_records) ++;
  }
#line 8689
  if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
    {
#line 8691
    p_tcp->m_nb_max_mcc_records += (unsigned int )10;
#line 8692
    __cil_tmp24 = opj_realloc(p_tcp->m_mcc_records, (unsigned long )p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t ));
#line 8692
    new_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp24;
    }
#line 8695
    if (! new_mcc_records) {
      {
#line 8696
      opj_free(p_tcp->m_mcc_records);
#line 8697
      p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)((void *)0);
#line 8698
      p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 8699
      p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
      }
#line 8701
      return (0);
    }
    {
#line 8703
    p_tcp->m_mcc_records = new_mcc_records;
#line 8704
    l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 8705
    memset(l_mcc_data, 0, (unsigned long )(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t ));
    }
  }
#line 8710
  l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
#line 8711
  l_mcc_data->m_decorrelation_array = l_mct_deco_data;
#line 8712
  l_mcc_data->m_is_irreversible = (OPJ_BITFIELD )1;
#line 8713
  l_mcc_data->m_nb_comps = p_image->numcomps;
#line 8714
  __cil_tmp25 = l_indix;
#line 8714
  l_indix ++;
#line 8714
  l_mcc_data->m_index = __cil_tmp25;
#line 8715
  l_mcc_data->m_offset_array = l_mct_offset_data;
#line 8716
  (p_tcp->m_nb_mcc_records) ++;
#line 8718
  return (1);
}
}
#line 8721 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_decoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8730
  return (1);
}
}
#line 8733 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_build_encoder(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                      opj_event_mgr_t *p_manager ) 
{ 


  {
#line 8742
  return (1);
}
}
#line 8745 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_encoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 8749
  l_is_valid = 1;
#line 8760
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 8764
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 8766
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 8771
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions <= 0U) {
    {
    {
#line 8773
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 8775
    return (0);
  } else
#line 8771
  if (((p_j2k->m_cp.tcps)->tccps)->numresolutions > 32U) {
    {
    {
#line 8773
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
    }
#line 8775
    return (0);
  }
#line 8778
  if (p_j2k->m_cp.tdx < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8780
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\n");
    }
#line 8782
    return (0);
  }
#line 8785
  if (p_j2k->m_cp.tdy < (OPJ_UINT32 )(1 << (((p_j2k->m_cp.tcps)->tccps)->numresolutions - 1U))) {
    {
#line 8787
    opj_event_msg(p_manager, 1, "Number of resolutions is too high in comparison to the size of tiles\nU");
    }
#line 8789
    return (0);
  }
#line 8793
  return (l_is_valid);
}
}
#line 8796 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decoding_validation(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_is_valid ;

  {
#line 8801
  l_is_valid = 1;
#line 8816
  l_is_valid &= p_j2k->m_specific_param.m_decoder.m_state == 0U;
#line 8821
  l_is_valid &= p_j2k->m_procedure_list != (opj_procedure_list_t *)0;
#line 8823
  l_is_valid &= p_j2k->m_validation_list != (opj_procedure_list_t *)0;
#line 8826
  return (l_is_valid);
}
}
#line 8829 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_header_procedure(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  OPJ_BOOL l_has_siz ;
  OPJ_BOOL l_has_cod ;
  OPJ_BOOL l_has_qcd ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;
  struct opj_dec_memory_marker_handler *__cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  struct opj_dec_memory_marker_handler *__cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BYTE *new_header_data ;
  void *__cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_OFF_T __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_SIZE_T __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_OFF_T __cil_tmp24 ;

  {
  {
#line 8835
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 8836
  l_has_siz = 0;
#line 8837
  l_has_cod = 0;
#line 8838
  l_has_qcd = 0;
#line 8846
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )1;
#line 8849
  __cil_tmp10 = opj_j2k_read_soc(p_j2k, p_stream, p_manager);
  }
#line 8849
  if (! __cil_tmp10) {
    {
#line 8850
    opj_event_msg(p_manager, 1, "Expected a SOC marker \n");
    }
#line 8851
    return (0);
  }
  {
#line 8855
  __cil_tmp11 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                     (OPJ_SIZE_T )2, p_manager);
  }
#line 8855
  if (__cil_tmp11 != 2UL) {
    {
#line 8857
    opj_event_msg(p_manager, 1, "Stream too short\n");
    }
#line 8858
    return (0);
  }
  {
#line 8862
  opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                    (OPJ_UINT32 )2);
  }
  {
#line 8866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8866
    if (! (l_current_marker != 65424U)) {
#line 8866
      goto while_break;
    }
#line 8869
    if (l_current_marker < 65280U) {
      {
#line 8870
      opj_event_msg(p_manager, 1, "A marker ID was expected (0xff--) instead of %.8x\n",
                    l_current_marker);
      }
#line 8872
      return (0);
    }
    {
#line 8876
    l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
    }
#line 8879
    if (l_marker_handler->id == 0U) {
      {
#line 8880
      __cil_tmp13 = opj_j2k_read_unk(p_j2k, p_stream, & l_current_marker, p_manager);
      }
#line 8880
      if (! __cil_tmp13) {
        {
#line 8881
        opj_event_msg(p_manager, 1, "Unknown marker has been detected and generated error.\n");
        }
#line 8883
        return (0);
      }
#line 8886
      if (l_current_marker == 65424U) {
#line 8887
        goto while_break;
      } else {
        {
#line 8889
        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
        }
      }
    }
#line 8893
    if (l_marker_handler->id == 65361U) {
#line 8895
      l_has_siz = 1;
    }
#line 8897
    if (l_marker_handler->id == 65362U) {
#line 8899
      l_has_cod = 1;
    }
#line 8901
    if (l_marker_handler->id == 65372U) {
#line 8903
      l_has_qcd = 1;
    }
#line 8907
    if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
      {
#line 8908
      opj_event_msg(p_manager, 1, "Marker is not compliant with its position\nU\t\265U");
      }
#line 8910
      return (0);
    }
    {
#line 8914
    __cil_tmp15 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 8914
    if (__cil_tmp15 != 2UL) {
      {
#line 8916
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8917
      return (0);
    }
    {
#line 8921
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                      (OPJ_UINT32 )2);
    }
#line 8923
    if (l_marker_size < 2U) {
      {
#line 8924
      opj_event_msg(p_manager, 1, "Invalid marker size\n\265U");
      }
#line 8925
      return (0);
    }
#line 8927
    l_marker_size -= (unsigned int )2;
#line 8930
    if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
      {
#line 8931
      __cil_tmp17 = opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, (size_t )l_marker_size);
#line 8931
      new_header_data = (OPJ_BYTE *)__cil_tmp17;
      }
#line 8933
      if (! new_header_data) {
        {
#line 8934
        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 8935
        p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 8936
        p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 8937
        opj_event_msg(p_manager, 1, "Not enough memory to read header\nSU\t\265U");
        }
#line 8938
        return (0);
      }
#line 8940
      p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 8941
      p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
    }
    {
#line 8945
    __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )l_marker_size, p_manager);
    }
#line 8945
    if (__cil_tmp18 != (unsigned long )l_marker_size) {
      {
#line 8948
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 8949
      return (0);
    }
    {
#line 8953
    __cil_tmp19 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                 l_marker_size, p_manager);
    }
#line 8953
    if (! __cil_tmp19) {
      {
#line 8955
      opj_event_msg(p_manager, 1, "Marker handler function failed to read the marker segment\n");
      }
#line 8957
      return (0);
    }
    {
#line 8961
    __cil_tmp20 = opj_stream_tell(p_stream);
#line 8961
    __cil_tmp21 = opj_j2k_add_mhmarker(p_j2k->cstr_index, l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp20 - l_marker_size) - 4U),
                                       l_marker_size + 4U);
    }
#line 8961
    if (0 == __cil_tmp21) {
      {
#line 8966
      opj_event_msg(p_manager, 1, "Not enough memory to add mh marker\n\t\265U");
      }
#line 8967
      return (0);
    }
    {
#line 8971
    __cil_tmp22 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                       (OPJ_SIZE_T )2, p_manager);
    }
#line 8971
    if (__cil_tmp22 != 2UL) {
      {
#line 8973
      opj_event_msg(p_manager, 1, "Stream too short\n\237S\t\265U");
      }
#line 8974
      return (0);
    }
    {
#line 8978
    opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                      (OPJ_UINT32 )2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8982
  if (l_has_siz == 0) {
    {
#line 8983
    opj_event_msg(p_manager, 1, "required SIZ marker not found in main header\n");
    }
#line 8985
    return (0);
  }
#line 8987
  if (l_has_cod == 0) {
    {
#line 8988
    opj_event_msg(p_manager, 1, "required COD marker not found in main header\nU");
    }
#line 8990
    return (0);
  }
#line 8992
  if (l_has_qcd == 0) {
    {
#line 8993
    opj_event_msg(p_manager, 1, "required QCD marker not found in main header\n");
    }
#line 8995
    return (0);
  }
  {
#line 8998
  __cil_tmp23 = opj_j2k_merge_ppm(& p_j2k->m_cp, p_manager);
  }
#line 8998
  if (! __cil_tmp23) {
    {
#line 8999
    opj_event_msg(p_manager, 1, "Failed to merge PPM data\n");
    }
#line 9000
    return (0);
  }
  {
#line 9003
  opj_event_msg(p_manager, 4, "Main header has been correctly decoded.\n\220");
#line 9006
  __cil_tmp24 = opj_stream_tell(p_stream);
#line 9006
  (p_j2k->cstr_index)->main_head_end = (OPJ_OFF_T )((OPJ_UINT32 )__cil_tmp24 - 2U);
#line 9009
  p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
  }
#line 9011
  return (1);
}
}
#line 9014 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_exec(opj_j2k_t *p_j2k , opj_procedure_list_t *p_procedure_list ,
                             opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL (**l_procedure)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ) ;
  OPJ_BOOL l_result ;
  OPJ_UINT32 l_nb_proc ;
  OPJ_UINT32 i ;
  OPJ_UINT32 __cil_tmp9 ;
  opj_procedure *__cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 9019
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))0;
#line 9021
  l_result = 1;
#line 9030
  l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
#line 9031
  __cil_tmp10 = opj_procedure_list_get_first_procedure(p_procedure_list);
#line 9031
  l_procedure = (OPJ_BOOL (**)(opj_j2k_t * , opj_stream_private_t * , opj_event_mgr_t * ))__cil_tmp10;
#line 9034
  i = (OPJ_UINT32 )0;
  }
  {
#line 9034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9034
    if (! (i < l_nb_proc)) {
#line 9034
      goto while_break;
    }
    {
#line 9035
    __cil_tmp11 = (*(*l_procedure))(p_j2k, p_stream, p_manager);
#line 9035
    l_result = l_result && __cil_tmp11;
#line 9036
    l_procedure ++;
    }
#line 9034
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9040
  opj_procedure_list_clear(p_procedure_list);
  }
#line 9041
  return (l_result);
}
}
#line 9045 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                                        opj_event_mgr_t *p_manager ) 
{ 
  opj_tcp_t *l_tcp ;
  opj_tcp_t *l_default_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  opj_tccp_t *l_current_tccp ;
  OPJ_UINT32 l_tccp_size ;
  OPJ_UINT32 l_mct_size ;
  opj_image_t *l_image ;
  OPJ_UINT32 l_mcc_records_size ;
  OPJ_UINT32 l_mct_records_size ;
  opj_mct_data_t *l_src_mct_rec ;
  opj_mct_data_t *l_dest_mct_rec ;
  opj_simple_mcc_decorrelation_data_t *l_src_mcc_rec ;
  opj_simple_mcc_decorrelation_data_t *l_dest_mcc_rec ;
  OPJ_UINT32 l_offset ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tcd_t *__cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;

  {
#line 9050
  l_tcp = (opj_tcp_t *)0;
#line 9051
  l_default_tcp = (opj_tcp_t *)0;
#line 9054
  l_current_tccp = (opj_tccp_t *)0;
#line 9070
  l_image = p_j2k->m_private_image;
#line 9071
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 9072
  l_tcp = p_j2k->m_cp.tcps;
#line 9073
  l_tccp_size = l_image->numcomps * (OPJ_UINT32 )sizeof(opj_tccp_t );
#line 9074
  l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 9075
  l_mct_size = (l_image->numcomps * l_image->numcomps) * (OPJ_UINT32 )sizeof(OPJ_FLOAT32 );
#line 9079
  i = (OPJ_UINT32 )0;
  {
#line 9079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9079
    if (! (i < l_nb_tiles)) {
#line 9079
      goto while_break;
    }
    {
#line 9081
    l_current_tccp = l_tcp->tccps;
#line 9083
    memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t ));
#line 9085
    l_tcp->cod = (OPJ_BITFIELD )0;
#line 9086
    l_tcp->ppt = (OPJ_BITFIELD )0;
#line 9087
    l_tcp->ppt_data = (OPJ_BYTE *)0;
#line 9088
    l_tcp->m_current_tile_part_number = - 1;
#line 9090
    l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
#line 9091
    l_tcp->m_nb_max_mct_records = (OPJ_UINT32 )0;
#line 9092
    l_tcp->m_mct_records = (opj_mct_data_t *)0;
#line 9093
    l_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 9094
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 9096
    l_tcp->tccps = l_current_tccp;
    }
#line 9099
    if (l_default_tcp->m_mct_decoding_matrix) {
      {
#line 9100
      __cil_tmp20 = opj_malloc((size_t )l_mct_size);
#line 9100
      l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)__cil_tmp20;
      }
#line 9101
      if (! l_tcp->m_mct_decoding_matrix) {
#line 9102
        return (0);
      }
      {
#line 9104
      memcpy(l_tcp->m_mct_decoding_matrix, l_default_tcp->m_mct_decoding_matrix, (unsigned long )l_mct_size);
      }
    }
    {
#line 9109
    l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32 )sizeof(opj_mct_data_t );
#line 9111
    __cil_tmp21 = opj_malloc((size_t )l_mct_records_size);
#line 9111
    l_tcp->m_mct_records = (opj_mct_data_t *)__cil_tmp21;
    }
#line 9112
    if (! l_tcp->m_mct_records) {
#line 9113
      return (0);
    }
    {
#line 9115
    memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records, (unsigned long )l_mct_records_size);
#line 9118
    l_src_mct_rec = l_default_tcp->m_mct_records;
#line 9119
    l_dest_mct_rec = l_tcp->m_mct_records;
#line 9121
    j = (OPJ_UINT32 )0;
    }
    {
#line 9121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9121
      if (! (j < l_default_tcp->m_nb_mct_records)) {
#line 9121
        goto while_break___0;
      }
#line 9123
      if (l_src_mct_rec->m_data) {
        {
#line 9125
        __cil_tmp22 = opj_malloc((size_t )l_src_mct_rec->m_data_size);
#line 9125
        l_dest_mct_rec->m_data = (OPJ_BYTE *)__cil_tmp22;
        }
#line 9126
        if (! l_dest_mct_rec->m_data) {
#line 9127
          return (0);
        }
        {
#line 9129
        memcpy(l_dest_mct_rec->m_data, l_src_mct_rec->m_data, (unsigned long )l_src_mct_rec->m_data_size);
        }
      }
#line 9133
      l_src_mct_rec ++;
#line 9134
      l_dest_mct_rec ++;
#line 9136
      l_tcp->m_nb_max_mct_records += (unsigned int )1;
#line 9121
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9140
    l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32 )sizeof(opj_simple_mcc_decorrelation_data_t );
#line 9142
    __cil_tmp23 = opj_malloc((size_t )l_mcc_records_size);
#line 9142
    l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)__cil_tmp23;
    }
#line 9144
    if (! l_tcp->m_mcc_records) {
#line 9145
      return (0);
    }
    {
#line 9147
    memcpy(l_tcp->m_mcc_records, l_default_tcp->m_mcc_records, (unsigned long )l_mcc_records_size);
#line 9148
    l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;
#line 9151
    l_src_mcc_rec = l_default_tcp->m_mcc_records;
#line 9152
    l_dest_mcc_rec = l_tcp->m_mcc_records;
#line 9154
    j = (OPJ_UINT32 )0;
    }
    {
#line 9154
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 9154
      if (! (j < l_default_tcp->m_nb_max_mcc_records)) {
#line 9154
        goto while_break___1;
      }
#line 9156
      if (l_src_mcc_rec->m_decorrelation_array) {
#line 9157
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
#line 9159
        l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
      }
#line 9162
      if (l_src_mcc_rec->m_offset_array) {
#line 9163
        l_offset = (OPJ_UINT32 )(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
#line 9165
        l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
      }
#line 9168
      l_src_mcc_rec ++;
#line 9169
      l_dest_mcc_rec ++;
#line 9154
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 9173
    memcpy(l_current_tccp, l_default_tcp->tccps, (unsigned long )l_tccp_size);
#line 9176
    l_tcp ++;
    }
#line 9079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9180
  p_j2k->m_tcd = opj_tcd_create(1);
  }
#line 9181
  if (! p_j2k->m_tcd) {
#line 9182
    return (0);
  }
  {
#line 9185
  __cil_tmp25 = opj_tcd_init(p_j2k->m_tcd, l_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 9185
  if (! __cil_tmp25) {
    {
#line 9186
    opj_tcd_destroy(p_j2k->m_tcd);
#line 9187
    p_j2k->m_tcd = (struct opj_tcd *)0;
#line 9188
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n\023V\t\265U");
    }
#line 9189
    return (0);
  }
#line 9192
  return (1);
}
}
#line 9195 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static struct opj_dec_memory_marker_handler *opj_j2k_get_marker_handler(OPJ_UINT32 p_id ) 
{ 
  opj_dec_memory_marker_handler_t *e ;

  {
#line 9199
  e = (opj_dec_memory_marker_handler_t *)j2k_memory_marker_handler_tab;
  {
#line 9199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9199
    if (! (e->id != 0U)) {
#line 9199
      goto while_break;
    }
#line 9200
    if (e->id == p_id) {
#line 9201
      goto while_break;
    }
#line 9199
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9204
  return (e);
}
}
#line 9207 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void opj_j2k_destroy(opj_j2k_t *p_j2k ) 
{ 


  {
#line 9209
  if (p_j2k == (opj_j2k_t *)0) {
#line 9210
    return;
  }
#line 9213
  if (p_j2k->m_is_decoder) {
#line 9215
    if (p_j2k->m_specific_param.m_decoder.m_default_tcp != (opj_tcp_t *)0) {
      {
#line 9216
      opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 9217
      opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);
#line 9218
      p_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)0;
      }
    }
#line 9221
    if (p_j2k->m_specific_param.m_decoder.m_header_data != (OPJ_BYTE *)0) {
      {
#line 9222
      opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 9223
      p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)0;
#line 9224
      p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
      }
    }
    {
#line 9227
    opj_free(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode);
#line 9228
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)0;
#line 9229
    p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
    }
  } else {
#line 9233
    if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
      {
#line 9234
      opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 9235
      p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
      }
    }
#line 9238
    if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
      {
#line 9239
      opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 9240
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 9241
      p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
      }
    }
#line 9244
    if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
      {
#line 9245
      opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 9246
      p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
#line 9247
      p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
      }
    }
  }
  {
#line 9251
  opj_tcd_destroy(p_j2k->m_tcd);
#line 9253
  opj_j2k_cp_destroy(& p_j2k->m_cp);
#line 9254
  memset(& p_j2k->m_cp, 0, sizeof(opj_cp_t ));
#line 9256
  opj_procedure_list_destroy(p_j2k->m_procedure_list);
#line 9257
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 9259
  opj_procedure_list_destroy(p_j2k->m_validation_list);
#line 9260
  p_j2k->m_procedure_list = (opj_procedure_list_t *)0;
#line 9262
  j2k_destroy_cstr_index(p_j2k->cstr_index);
#line 9263
  p_j2k->cstr_index = (opj_codestream_index_t *)((void *)0);
#line 9265
  opj_image_destroy(p_j2k->m_private_image);
#line 9266
  p_j2k->m_private_image = (opj_image_t *)((void *)0);
#line 9268
  opj_image_destroy(p_j2k->m_output_image);
#line 9269
  p_j2k->m_output_image = (opj_image_t *)((void *)0);
#line 9271
  opj_thread_pool_destroy(p_j2k->m_tp);
#line 9272
  p_j2k->m_tp = (opj_thread_pool_t *)((void *)0);
#line 9274
  opj_free(p_j2k);
  }
  return;
}
}
#line 9277 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_destroy_cstr_index(opj_codestream_index_t *p_cstr_ind ) 
{ 
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 9279
  if (p_cstr_ind) {
#line 9281
    if (p_cstr_ind->marker) {
      {
#line 9282
      opj_free(p_cstr_ind->marker);
#line 9283
      p_cstr_ind->marker = (opj_marker_info_t *)((void *)0);
      }
    }
#line 9286
    if (p_cstr_ind->tile_index) {
#line 9287
      it_tile = (OPJ_UINT32 )0;
#line 9289
      it_tile = (OPJ_UINT32 )0;
      {
#line 9289
      while (1) {
        while_continue: /* CIL Label */ ;
#line 9289
        if (! (it_tile < p_cstr_ind->nb_of_tiles)) {
#line 9289
          goto while_break;
        }
#line 9291
        if ((p_cstr_ind->tile_index + it_tile)->packet_index) {
          {
#line 9292
          opj_free((p_cstr_ind->tile_index + it_tile)->packet_index);
#line 9293
          (p_cstr_ind->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
          }
        }
#line 9296
        if ((p_cstr_ind->tile_index + it_tile)->tp_index) {
          {
#line 9297
          opj_free((p_cstr_ind->tile_index + it_tile)->tp_index);
#line 9298
          (p_cstr_ind->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
          }
        }
#line 9301
        if ((p_cstr_ind->tile_index + it_tile)->marker) {
          {
#line 9302
          opj_free((p_cstr_ind->tile_index + it_tile)->marker);
#line 9303
          (p_cstr_ind->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
          }
        }
#line 9289
        it_tile ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 9308
      opj_free(p_cstr_ind->tile_index);
#line 9309
      p_cstr_ind->tile_index = (opj_tile_index_t *)((void *)0);
      }
    }
    {
#line 9312
    opj_free(p_cstr_ind);
    }
  }
  return;
}
}
#line 9316 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_destroy(opj_tcp_t *p_tcp ) 
{ 
  OPJ_UINT32 i ;
  opj_mct_data_t *l_mct_data ;
  OPJ_UINT32 i___0 ;

  {
#line 9318
  if (p_tcp == (opj_tcp_t *)0) {
#line 9319
    return;
  }
#line 9322
  if (p_tcp->ppt_markers != (opj_ppx *)0) {
#line 9324
    i = 0U;
    {
#line 9324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9324
      if (! (i < p_tcp->ppt_markers_count)) {
#line 9324
        goto while_break;
      }
#line 9325
      if ((p_tcp->ppt_markers + i)->m_data != (void *)0) {
        {
#line 9326
        opj_free((p_tcp->ppt_markers + i)->m_data);
        }
      }
#line 9324
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 9329
    p_tcp->ppt_markers_count = 0U;
#line 9330
    opj_free(p_tcp->ppt_markers);
#line 9331
    p_tcp->ppt_markers = (opj_ppx *)((void *)0);
    }
  }
#line 9334
  if (p_tcp->ppt_buffer != (OPJ_BYTE *)0) {
    {
#line 9335
    opj_free(p_tcp->ppt_buffer);
#line 9336
    p_tcp->ppt_buffer = (OPJ_BYTE *)0;
    }
  }
#line 9339
  if (p_tcp->tccps != (opj_tccp_t *)0) {
    {
#line 9340
    opj_free(p_tcp->tccps);
#line 9341
    p_tcp->tccps = (opj_tccp_t *)0;
    }
  }
#line 9344
  if (p_tcp->m_mct_coding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 9345
    opj_free(p_tcp->m_mct_coding_matrix);
#line 9346
    p_tcp->m_mct_coding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9349
  if (p_tcp->m_mct_decoding_matrix != (OPJ_FLOAT32 *)0) {
    {
#line 9350
    opj_free(p_tcp->m_mct_decoding_matrix);
#line 9351
    p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32 *)0;
    }
  }
#line 9354
  if (p_tcp->m_mcc_records) {
    {
#line 9355
    opj_free(p_tcp->m_mcc_records);
#line 9356
    p_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t *)0;
#line 9357
    p_tcp->m_nb_max_mcc_records = (OPJ_UINT32 )0;
#line 9358
    p_tcp->m_nb_mcc_records = (OPJ_UINT32 )0;
    }
  }
#line 9361
  if (p_tcp->m_mct_records) {
#line 9362
    l_mct_data = p_tcp->m_mct_records;
#line 9365
    i___0 = (OPJ_UINT32 )0;
    {
#line 9365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9365
      if (! (i___0 < p_tcp->m_nb_mct_records)) {
#line 9365
        goto while_break___0;
      }
#line 9366
      if (l_mct_data->m_data) {
        {
#line 9367
        opj_free(l_mct_data->m_data);
#line 9368
        l_mct_data->m_data = (OPJ_BYTE *)0;
        }
      }
#line 9371
      l_mct_data ++;
#line 9365
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9374
    opj_free(p_tcp->m_mct_records);
#line 9375
    p_tcp->m_mct_records = (opj_mct_data_t *)0;
    }
  }
#line 9378
  if (p_tcp->mct_norms != (OPJ_FLOAT64 *)0) {
    {
#line 9379
    opj_free(p_tcp->mct_norms);
#line 9380
    p_tcp->mct_norms = (OPJ_FLOAT64 *)0;
    }
  }
  {
#line 9383
  opj_j2k_tcp_data_destroy(p_tcp);
  }
  return;
}
}
#line 9387 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_tcp_data_destroy(opj_tcp_t *p_tcp ) 
{ 


  {
#line 9389
  if (p_tcp->m_data) {
    {
#line 9390
    opj_free(p_tcp->m_data);
#line 9391
    p_tcp->m_data = (OPJ_BYTE *)((void *)0);
#line 9392
    p_tcp->m_data_size = (OPJ_UINT32 )0;
    }
  }
  return;
}
}
#line 9396 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_cp_destroy(opj_cp_t *p_cp ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  opj_tcp_t *l_current_tile ;
  OPJ_UINT32 i ;
  OPJ_UINT32 i___0 ;

  {
#line 9399
  l_current_tile = (opj_tcp_t *)0;
#line 9401
  if (p_cp == (opj_cp_t *)0) {
#line 9402
    return;
  }
#line 9404
  if (p_cp->tcps != (opj_tcp_t *)0) {
#line 9406
    l_current_tile = p_cp->tcps;
#line 9407
    l_nb_tiles = p_cp->th * p_cp->tw;
#line 9409
    i = 0U;
    {
#line 9409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 9409
      if (! (i < l_nb_tiles)) {
#line 9409
        goto while_break;
      }
      {
#line 9410
      opj_j2k_tcp_destroy(l_current_tile);
#line 9411
      l_current_tile ++;
      }
#line 9409
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 9413
    opj_free(p_cp->tcps);
#line 9414
    p_cp->tcps = (opj_tcp_t *)0;
    }
  }
#line 9416
  if (p_cp->ppm_markers != (opj_ppx *)0) {
#line 9418
    i___0 = 0U;
    {
#line 9418
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9418
      if (! (i___0 < p_cp->ppm_markers_count)) {
#line 9418
        goto while_break___0;
      }
#line 9419
      if ((p_cp->ppm_markers + i___0)->m_data != (void *)0) {
        {
#line 9420
        opj_free((p_cp->ppm_markers + i___0)->m_data);
        }
      }
#line 9418
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9423
    p_cp->ppm_markers_count = 0U;
#line 9424
    opj_free(p_cp->ppm_markers);
#line 9425
    p_cp->ppm_markers = (opj_ppx *)((void *)0);
    }
  }
  {
#line 9427
  opj_free(p_cp->ppm_buffer);
#line 9428
  p_cp->ppm_buffer = (OPJ_BYTE *)0;
#line 9429
  p_cp->ppm_data = (OPJ_BYTE *)((void *)0);
#line 9431
  opj_free(p_cp->comment);
#line 9432
  p_cp->comment = (OPJ_CHAR *)0;
  }
#line 9433
  if (! p_cp->m_is_decoder) {
    {
#line 9434
    opj_free(p_cp->m_specific_param.m_enc.m_matrice);
#line 9435
    p_cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *)0;
    }
  }
  return;
}
}
#line 9439 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream ,
                                                      OPJ_UINT32 tile_no , OPJ_BOOL *p_correction_needed ,
                                                      opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BYTE l_header_data[10] ;
  OPJ_OFF_T l_stream_pos_backup ;
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  OPJ_UINT32 l_tile_no ;
  OPJ_UINT32 l_tot_len ;
  OPJ_UINT32 l_current_part ;
  OPJ_UINT32 l_num_parts ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_SIZE_T __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_OFF_T __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
  {
#line 9450
  *p_correction_needed = 0;
#line 9452
  __cil_tmp13 = opj_stream_has_seek(p_stream);
  }
#line 9452
  if (! __cil_tmp13) {
#line 9454
    return (1);
  }
  {
#line 9457
  l_stream_pos_backup = opj_stream_tell(p_stream);
  }
#line 9458
  if (l_stream_pos_backup == -1L) {
#line 9460
    return (1);
  }
  {
#line 9463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9463
    if (! 1) {
#line 9463
      goto while_break;
    }
    {
#line 9465
    __cil_tmp15 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9465
    if (__cil_tmp15 != 2UL) {
      {
#line 9467
      __cil_tmp16 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9467
      if (! __cil_tmp16) {
#line 9468
        return (0);
      }
#line 9470
      return (1);
    }
    {
#line 9474
    opj_read_bytes_LE((OPJ_BYTE *)l_header_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 9476
    if (l_current_marker != 65424U) {
      {
#line 9478
      __cil_tmp17 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9478
      if (! __cil_tmp17) {
#line 9479
        return (0);
      }
#line 9481
      return (1);
    }
    {
#line 9485
    __cil_tmp18 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9485
    if (__cil_tmp18 != 2UL) {
      {
#line 9486
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 9487
      return (0);
    }
    {
#line 9491
    opj_read_bytes_LE((OPJ_BYTE *)l_header_data, & l_marker_size, (OPJ_UINT32 )2);
    }
#line 9494
    if (l_marker_size != 10U) {
      {
#line 9495
      opj_event_msg(p_manager, 1, "Inconsistent marker size\n");
      }
#line 9496
      return (0);
    }
    {
#line 9498
    l_marker_size -= (unsigned int )2;
#line 9500
    __cil_tmp19 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_header_data, (OPJ_SIZE_T )l_marker_size,
                                       p_manager);
    }
#line 9500
    if (__cil_tmp19 != (unsigned long )l_marker_size) {
      {
#line 9502
      opj_event_msg(p_manager, 1, "Stream too short\n");
      }
#line 9503
      return (0);
    }
    {
#line 9506
    __cil_tmp20 = opj_j2k_get_sot_values((OPJ_BYTE *)l_header_data, l_marker_size,
                                         & l_tile_no, & l_tot_len, & l_current_part,
                                         & l_num_parts, p_manager);
    }
#line 9506
    if (! __cil_tmp20) {
#line 9508
      return (0);
    }
#line 9511
    if (l_tile_no == tile_no) {
#line 9513
      goto while_break;
    }
#line 9516
    if (l_tot_len < 14U) {
      {
#line 9519
      __cil_tmp21 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9519
      if (! __cil_tmp21) {
#line 9520
        return (0);
      }
#line 9522
      return (1);
    }
    {
#line 9524
    l_tot_len -= 12U;
#line 9526
    __cil_tmp22 = opj_stream_skip(p_stream, (OPJ_OFF_T )l_tot_len, p_manager);
    }
#line 9526
    if (__cil_tmp22 != (OPJ_OFF_T )l_tot_len) {
      {
#line 9529
      __cil_tmp23 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
      }
#line 9529
      if (! __cil_tmp23) {
#line 9530
        return (0);
      }
#line 9532
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9537
  if (l_current_part == l_num_parts) {
#line 9538
    *p_correction_needed = 1;
  }
  {
#line 9541
  __cil_tmp24 = opj_stream_seek(p_stream, l_stream_pos_backup, p_manager);
  }
#line 9541
  if (! __cil_tmp24) {
#line 9542
    return (0);
  }
#line 9544
  return (1);
}
}
#line 9547 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_read_tile_header(opj_j2k_t *p_j2k , OPJ_UINT32 *p_tile_index , OPJ_UINT32 *p_data_size ,
                                  OPJ_INT32 *p_tile_x0 , OPJ_INT32 *p_tile_y0 , OPJ_INT32 *p_tile_x1 ,
                                  OPJ_INT32 *p_tile_y1 , OPJ_UINT32 *p_nb_comps ,
                                  OPJ_BOOL *p_go_on , opj_stream_private_t *p_stream ,
                                  opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_UINT32 l_marker_size ;
  opj_dec_memory_marker_handler_t *l_marker_handler ;
  opj_tcp_t *l_tcp ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_OFF_T __cil_tmp17 ;
  OPJ_SIZE_T __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;
  struct opj_dec_memory_marker_handler *__cil_tmp20 ;
  OPJ_BYTE *new_header_data ;
  OPJ_OFF_T __cil_tmp22 ;
  void *__cil_tmp23 ;
  OPJ_SIZE_T __cil_tmp24 ;
  OPJ_BOOL __cil_tmp25 ;
  OPJ_OFF_T __cil_tmp26 ;
  OPJ_BOOL __cil_tmp27 ;
  OPJ_UINT32 sot_pos ;
  OPJ_OFF_T __cil_tmp29 ;
  OPJ_OFF_T __cil_tmp30 ;
  OPJ_SIZE_T __cil_tmp31 ;
  OPJ_OFF_T __cil_tmp32 ;
  OPJ_BOOL __cil_tmp33 ;
  OPJ_BOOL l_correction_needed ;
  OPJ_BOOL __cil_tmp35 ;
  OPJ_UINT32 l_tile_no ;
  OPJ_SIZE_T __cil_tmp37 ;
  OPJ_UINT32 l_tile_no___0 ;
  OPJ_BOOL __cil_tmp39 ;
  OPJ_BOOL __cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;

  {
#line 9557
  l_current_marker = (OPJ_UINT32 )65424;
#line 9559
  l_marker_handler = (opj_dec_memory_marker_handler_t *)0;
#line 9560
  l_tcp = (opj_tcp_t *)((void *)0);
#line 9561
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 9569
  if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 9570
    l_current_marker = (OPJ_UINT32 )65497;
  } else
#line 9573
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
#line 9574
    return (0);
  }
  {
#line 9578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9578
    if (! (! p_j2k->m_specific_param.m_decoder.m_can_decode && l_current_marker != 65497U)) {
#line 9578
      goto while_break;
    }
    {
#line 9582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9582
      if (! (l_current_marker != 65427U)) {
#line 9582
        goto while_break___0;
      }
      {
#line 9584
      __cil_tmp17 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9584
      if (__cil_tmp17 == 0L) {
#line 9585
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9586
        goto while_break___0;
      }
      {
#line 9590
      __cil_tmp18 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 9590
      if (__cil_tmp18 != 2UL) {
        {
#line 9592
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 9593
        return (0);
      }
      {
#line 9597
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_marker_size,
                        (OPJ_UINT32 )2);
      }
#line 9601
      if (l_marker_size < 2U) {
        {
#line 9602
        opj_event_msg(p_manager, 1, "Inconsistent marker size\noW\t\265U");
        }
#line 9603
        return (0);
      }
      {
#line 9607
      __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9607
      if (l_current_marker == 32896U) {
#line 9607
        if (__cil_tmp19 == 0L) {
#line 9609
          p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9610
          goto while_break___0;
        }
      }
#line 9614
      if (p_j2k->m_specific_param.m_decoder.m_state & 16U) {
#line 9615
        p_j2k->m_specific_param.m_decoder.m_sot_length -= l_marker_size + 2U;
      }
      {
#line 9617
      l_marker_size -= (unsigned int )2;
#line 9620
      l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
      }
#line 9623
      if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
        {
#line 9624
        opj_event_msg(p_manager, 1, "Marker is not compliant with its position\n");
        }
#line 9626
        return (0);
      }
#line 9631
      if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
        {
#line 9632
        new_header_data = (OPJ_BYTE *)((void *)0);
#line 9635
        __cil_tmp22 = opj_stream_get_number_byte_left(p_stream);
        }
#line 9635
        if ((OPJ_OFF_T )l_marker_size > __cil_tmp22) {
          {
#line 9636
          opj_event_msg(p_manager, 1, "Marker size inconsistent with stream length\n");
          }
#line 9638
          return (0);
        }
        {
#line 9640
        __cil_tmp23 = opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data,
                                  (size_t )l_marker_size);
#line 9640
        new_header_data = (OPJ_BYTE *)__cil_tmp23;
        }
#line 9642
        if (! new_header_data) {
          {
#line 9643
          opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
#line 9644
          p_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)((void *)0);
#line 9645
          p_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )0;
#line 9646
          opj_event_msg(p_manager, 1, "Not enough memory to read header\n");
          }
#line 9647
          return (0);
        }
#line 9649
        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
#line 9650
        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
      }
      {
#line 9654
      __cil_tmp24 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )l_marker_size, p_manager);
      }
#line 9654
      if (__cil_tmp24 != (unsigned long )l_marker_size) {
        {
#line 9657
        opj_event_msg(p_manager, 1, "Stream too short\n\177W\t\265U");
        }
#line 9658
        return (0);
      }
#line 9661
      if (! l_marker_handler->handler) {
        {
#line 9663
        opj_event_msg(p_manager, 1, "Not sure how that happened.\n");
        }
#line 9664
        return (0);
      }
      {
#line 9667
      __cil_tmp25 = (*(l_marker_handler->handler))(p_j2k, p_j2k->m_specific_param.m_decoder.m_header_data,
                                                   l_marker_size, p_manager);
      }
#line 9667
      if (! __cil_tmp25) {
        {
#line 9669
        opj_event_msg(p_manager, 1, "Fail to read the current marker segment (%#x)\n",
                      l_current_marker);
        }
#line 9671
        return (0);
      }
      {
#line 9675
      __cil_tmp26 = opj_stream_tell(p_stream);
#line 9675
      __cil_tmp27 = opj_j2k_add_tlmarker(p_j2k->m_current_tile_number, p_j2k->cstr_index,
                                         l_marker_handler->id, (OPJ_OFF_T )(((OPJ_UINT32 )__cil_tmp26 - l_marker_size) - 4U),
                                         l_marker_size + 4U);
      }
#line 9675
      if (0 == __cil_tmp27) {
        {
#line 9680
        opj_event_msg(p_manager, 1, "Not enough memory to add tl marker\n");
        }
#line 9681
        return (0);
      }
#line 9685
      if (l_marker_handler->id == 65424U) {
        {
#line 9686
        __cil_tmp29 = opj_stream_tell(p_stream);
#line 9686
        sot_pos = ((OPJ_UINT32 )__cil_tmp29 - l_marker_size) - 4U;
        }
#line 9688
        if ((long )sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos) {
#line 9689
          p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )sot_pos;
        }
      }
#line 9693
      if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
        {
#line 9695
        __cil_tmp30 = opj_stream_skip(p_stream, (OPJ_OFF_T )p_j2k->m_specific_param.m_decoder.m_sot_length,
                                      p_manager);
        }
#line 9695
        if (__cil_tmp30 != (long )p_j2k->m_specific_param.m_decoder.m_sot_length) {
          {
#line 9697
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 9698
          return (0);
        }
#line 9700
        l_current_marker = (OPJ_UINT32 )65427;
      } else {
        {
#line 9703
        __cil_tmp31 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                           (OPJ_SIZE_T )2, p_manager);
        }
#line 9703
        if (__cil_tmp31 != 2UL) {
          {
#line 9705
          opj_event_msg(p_manager, 1, "Stream too short\n");
          }
#line 9706
          return (0);
        }
        {
#line 9709
        opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                          (OPJ_UINT32 )2);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 9713
    __cil_tmp32 = opj_stream_get_number_byte_left(p_stream);
    }
#line 9713
    if (__cil_tmp32 == 0L) {
#line 9713
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9715
        goto while_break;
      }
    }
#line 9719
    if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
      {
#line 9721
      __cil_tmp33 = opj_j2k_read_sod(p_j2k, p_stream, p_manager);
      }
#line 9721
      if (! __cil_tmp33) {
#line 9722
        return (0);
      }
#line 9724
      if ((int )p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 9724
        if (! p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {
          {
#line 9729
          p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = (OPJ_BITFIELD )1;
#line 9730
          __cil_tmp35 = opj_j2k_need_nb_tile_parts_correction(p_stream, p_j2k->m_current_tile_number,
                                                              & l_correction_needed,
                                                              p_manager);
          }
#line 9730
          if (! __cil_tmp35) {
            {
#line 9732
            opj_event_msg(p_manager, 1, "opj_j2k_apply_nb_tile_parts_correction error\n");
            }
#line 9734
            return (0);
          }
#line 9736
          if (l_correction_needed) {
#line 9739
            p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9740
            p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = (OPJ_BITFIELD )1;
#line 9742
            l_tile_no = 0U;
            {
#line 9742
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 9742
              if (! (l_tile_no < l_nb_tiles)) {
#line 9742
                goto while_break___1;
              }
#line 9743
              if ((p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts != 0U) {
#line 9744
                (p_j2k->m_cp.tcps + l_tile_no)->m_nb_tile_parts += (unsigned int )1;
              }
#line 9742
              l_tile_no ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 9747
            opj_event_msg(p_manager, 2, "Non conformant codestream TPsot==TNsot.\n\220");
            }
          }
        }
      }
    } else {
#line 9753
      p_j2k->m_specific_param.m_decoder.m_skip_data = (OPJ_BITFIELD )0;
#line 9754
      p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9755
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
    }
#line 9758
    if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
      {
#line 9760
      __cil_tmp37 = opj_stream_read_data(p_stream, p_j2k->m_specific_param.m_decoder.m_header_data,
                                         (OPJ_SIZE_T )2, p_manager);
      }
#line 9760
      if (__cil_tmp37 != 2UL) {
#line 9766
        if (p_j2k->m_current_tile_number + 1U == l_nb_tiles) {
#line 9768
          l_tile_no___0 = 0U;
          {
#line 9768
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 9768
            if (! (l_tile_no___0 < l_nb_tiles)) {
#line 9768
              goto while_break___2;
            }
#line 9769
            if ((p_j2k->m_cp.tcps + l_tile_no___0)->m_current_tile_part_number == 0) {
#line 9769
              if ((p_j2k->m_cp.tcps + l_tile_no___0)->m_nb_tile_parts == 0U) {
#line 9771
                goto while_break___2;
              }
            }
#line 9768
            l_tile_no___0 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 9774
          if (l_tile_no___0 < l_nb_tiles) {
            {
#line 9775
            opj_event_msg(p_manager, 4, "Tile %u has TPsot == 0 and TNsot == 0, but no other tile-parts were found. EOC is also missing.\n\230\001",
                          l_tile_no___0);
#line 9780
            p_j2k->m_current_tile_number = l_tile_no___0;
#line 9781
            l_current_marker = (OPJ_UINT32 )65497;
#line 9782
            p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
            }
#line 9783
            goto while_break;
          }
        }
        {
#line 9787
        opj_event_msg(p_manager, 1, "Stream too short\n");
        }
#line 9788
        return (0);
      }
      {
#line 9792
      opj_read_bytes_LE(p_j2k->m_specific_param.m_decoder.m_header_data, & l_current_marker,
                        (OPJ_UINT32 )2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9798
  if (l_current_marker == 65497U) {
#line 9799
    if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
#line 9800
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 9801
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    }
  }
#line 9806
  if (! p_j2k->m_specific_param.m_decoder.m_can_decode) {
#line 9807
    l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
    {
#line 9809
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 9809
      if (! (l_tcp->m_data == (OPJ_BYTE *)0 && p_j2k->m_current_tile_number < l_nb_tiles)) {
#line 9809
        goto while_break___3;
      }
#line 9810
      (p_j2k->m_current_tile_number) ++;
#line 9811
      l_tcp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 9814
    if (p_j2k->m_current_tile_number == l_nb_tiles) {
#line 9815
      *p_go_on = 0;
#line 9816
      return (1);
    }
  }
  {
#line 9820
  __cil_tmp39 = opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number,
                                  p_manager);
  }
#line 9820
  if (! __cil_tmp39) {
    {
#line 9822
    opj_event_msg(p_manager, 1, "Failed to merge PPT data\n");
    }
#line 9823
    return (0);
  }
  {
#line 9826
  __cil_tmp40 = opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                         p_manager);
  }
#line 9826
  if (! __cil_tmp40) {
    {
#line 9828
    opj_event_msg(p_manager, 1, "Cannot decode tile, memory error\n");
    }
#line 9829
    return (0);
  }
  {
#line 9832
  opj_event_msg(p_manager, 4, "Header of tile %d / %d has been read.\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 9835
  *p_tile_index = p_j2k->m_current_tile_number;
#line 9836
  *p_go_on = 1;
  }
#line 9837
  if (p_data_size) {
    {
#line 9840
    *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd, 0);
    }
#line 9841
    if (*p_data_size == 4294967295U) {
#line 9842
      return (0);
    }
  }
#line 9845
  *p_tile_x0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x0;
#line 9846
  *p_tile_y0 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y0;
#line 9847
  *p_tile_x1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->x1;
#line 9848
  *p_tile_y1 = (((p_j2k->m_tcd)->tcd_image)->tiles)->y1;
#line 9849
  *p_nb_comps = (((p_j2k->m_tcd)->tcd_image)->tiles)->numcomps;
#line 9851
  p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )128;
#line 9853
  return (1);
}
}
#line 9856 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                             OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                             opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_current_marker ;
  OPJ_BYTE l_data[2] ;
  opj_tcp_t *l_tcp ;
  opj_image_t *l_image_for_bounds ;
  opj_image_t *tmp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_OFF_T __cil_tmp14 ;
  OPJ_SIZE_T __cil_tmp15 ;
  int tmp___0 ;
  int tmp___1 ;
  OPJ_OFF_T __cil_tmp18 ;

  {
#line 9873
  if (! (p_j2k->m_specific_param.m_decoder.m_state & 128U)) {
#line 9875
    return (0);
  } else
#line 9873
  if (p_tile_index != p_j2k->m_current_tile_number) {
#line 9875
    return (0);
  }
#line 9878
  l_tcp = p_j2k->m_cp.tcps + p_tile_index;
#line 9879
  if (! l_tcp->m_data) {
    {
#line 9880
    opj_j2k_tcp_destroy(l_tcp);
    }
#line 9881
    return (0);
  }
#line 9889
  if (p_j2k->m_output_image) {
#line 9889
    tmp = p_j2k->m_output_image;
  } else {
#line 9889
    tmp = p_j2k->m_private_image;
  }
  {
#line 9889
  l_image_for_bounds = tmp;
#line 9891
  __cil_tmp12 = opj_tcd_decode_tile(p_j2k->m_tcd, l_image_for_bounds->x0, l_image_for_bounds->y0,
                                    l_image_for_bounds->x1, l_image_for_bounds->y1,
                                    p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode,
                                    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode,
                                    l_tcp->m_data, l_tcp->m_data_size, p_tile_index,
                                    p_j2k->cstr_index, p_manager);
  }
#line 9891
  if (! __cil_tmp12) {
    {
#line 9902
    opj_j2k_tcp_destroy(l_tcp);
#line 9903
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
#line 9904
    opj_event_msg(p_manager, 1, "Failed to decode.\nX\t\265U");
    }
#line 9905
    return (0);
  }
#line 9911
  if (p_data != (void *)0) {
    {
#line 9912
    __cil_tmp13 = opj_tcd_update_tile_data(p_j2k->m_tcd, p_data, p_data_size);
    }
#line 9912
    if (! __cil_tmp13) {
#line 9913
      return (0);
    }
    {
#line 9920
    opj_j2k_tcp_data_destroy(l_tcp);
    }
  }
  {
#line 9923
  p_j2k->m_specific_param.m_decoder.m_can_decode = (OPJ_BITFIELD )0;
#line 9924
  p_j2k->m_specific_param.m_decoder.m_state &= ~ ((OPJ_UINT32 )128);
#line 9926
  __cil_tmp14 = opj_stream_get_number_byte_left(p_stream);
  }
#line 9926
  if (__cil_tmp14 == 0L) {
#line 9926
    if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 9928
      return (1);
    }
  }
#line 9931
  if (p_j2k->m_specific_param.m_decoder.m_state != 256U) {
    {
#line 9932
    __cil_tmp15 = opj_stream_read_data(p_stream, (OPJ_BYTE *)l_data, (OPJ_SIZE_T )2,
                                       p_manager);
    }
#line 9932
    if (__cil_tmp15 != 2UL) {
#line 9933
      if (p_j2k->m_cp.strict) {
#line 9933
        tmp___0 = 1;
      } else {
#line 9933
        tmp___0 = 2;
      }
      {
#line 9933
      opj_event_msg(p_manager, tmp___0, "Stream too short\n\031X\t\265U");
      }
#line 9935
      if (p_j2k->m_cp.strict) {
#line 9935
        tmp___1 = 0;
      } else {
#line 9935
        tmp___1 = 1;
      }
#line 9935
      return (tmp___1);
    }
    {
#line 9937
    opj_read_bytes_LE((OPJ_BYTE *)l_data, & l_current_marker, (OPJ_UINT32 )2);
    }
#line 9939
    if (l_current_marker == 65497U) {
#line 9940
      p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 9941
      p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )256;
    } else
#line 9942
    if (l_current_marker != 65424U) {
      {
#line 9943
      __cil_tmp18 = opj_stream_get_number_byte_left(p_stream);
      }
#line 9943
      if (__cil_tmp18 == 0L) {
        {
#line 9944
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )64;
#line 9945
        opj_event_msg(p_manager, 2, "Stream does not end with EOC\nU");
        }
#line 9946
        return (1);
      }
      {
#line 9948
      opj_event_msg(p_manager, 1, "Stream too short, expected SOT\n");
      }
#line 9949
      return (0);
    }
  }
#line 9953
  return (1);
}
}
#line 9956 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_data(opj_tcd_t *p_tcd , opj_image_t *p_output_image ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_width_src ;
  OPJ_UINT32 l_height_src ;
  OPJ_UINT32 l_width_dest ;
  OPJ_UINT32 l_height_dest ;
  OPJ_INT32 l_offset_x0_src ;
  OPJ_INT32 l_offset_y0_src ;
  OPJ_INT32 l_offset_x1_src ;
  OPJ_INT32 l_offset_y1_src ;
  OPJ_SIZE_T l_start_offset_src ;
  OPJ_UINT32 l_start_x_dest ;
  OPJ_UINT32 l_start_y_dest ;
  OPJ_UINT32 l_x0_dest ;
  OPJ_UINT32 l_y0_dest ;
  OPJ_UINT32 l_x1_dest ;
  OPJ_UINT32 l_y1_dest ;
  OPJ_SIZE_T l_start_offset_dest ;
  opj_image_comp_t *l_img_comp_src ;
  opj_image_comp_t *l_img_comp_dest ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_t *l_image_src ;
  OPJ_INT32 *l_dest_ptr ;
  OPJ_INT32 res_x0 ;
  OPJ_INT32 res_x1 ;
  OPJ_INT32 res_y0 ;
  OPJ_INT32 res_y1 ;
  OPJ_UINT32 src_data_stride ;
  OPJ_INT32 *p_src_data ;
  opj_tcd_resolution_t *l_res ;
  opj_tcd_resolution_t *l_res___0 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_SIZE_T l_width ;
  OPJ_SIZE_T l_height ;
  void *__cil_tmp38 ;
  OPJ_INT32 *l_src_ptr ;
  OPJ_UINT32 __cil_tmp40 ;

  {
#line 9968
  l_img_comp_src = (opj_image_comp_t *)0;
#line 9969
  l_img_comp_dest = (opj_image_comp_t *)0;
#line 9971
  l_tilec = (opj_tcd_tilecomp_t *)0;
#line 9972
  l_image_src = (opj_image_t *)0;
#line 9975
  l_tilec = ((p_tcd->tcd_image)->tiles)->comps;
#line 9976
  l_image_src = p_tcd->image;
#line 9977
  l_img_comp_src = l_image_src->comps;
#line 9979
  l_img_comp_dest = p_output_image->comps;
#line 9981
  i = (OPJ_UINT32 )0;
  {
#line 9981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9981
    if (! (i < l_image_src->numcomps)) {
#line 9981
      goto while_break;
    }
#line 9988
    l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
#line 9990
    if (p_tcd->whole_tile_decoding) {
#line 9991
      l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 9993
      res_x0 = l_res->x0;
#line 9994
      res_y0 = l_res->y0;
#line 9995
      res_x1 = l_res->x1;
#line 9996
      res_y1 = l_res->y1;
#line 9997
      src_data_stride = (OPJ_UINT32 )((l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x1 - (l_tilec->resolutions + (l_tilec->minimum_num_resolutions - 1U))->x0);
#line 10000
      p_src_data = l_tilec->data;
    } else {
#line 10002
      l_res___0 = l_tilec->resolutions + l_img_comp_src->resno_decoded;
#line 10004
      res_x0 = (OPJ_INT32 )l_res___0->win_x0;
#line 10005
      res_y0 = (OPJ_INT32 )l_res___0->win_y0;
#line 10006
      res_x1 = (OPJ_INT32 )l_res___0->win_x1;
#line 10007
      res_y1 = (OPJ_INT32 )l_res___0->win_y1;
#line 10008
      src_data_stride = l_res___0->win_x1 - l_res___0->win_x0;
#line 10009
      p_src_data = l_tilec->data_win;
    }
#line 10012
    if (p_src_data == (void *)0) {
#line 10014
      goto while_continue;
    }
    {
#line 10017
    l_width_src = (OPJ_UINT32 )(res_x1 - res_x0);
#line 10018
    l_height_src = (OPJ_UINT32 )(res_y1 - res_y0);
#line 10029
    l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);
#line 10030
    l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);
#line 10031
    l_x1_dest = l_x0_dest + l_img_comp_dest->w;
#line 10033
    l_y1_dest = l_y0_dest + l_img_comp_dest->h;
    }
#line 10049
    if (l_x0_dest < (OPJ_UINT32 )res_x0) {
#line 10050
      l_start_x_dest = (OPJ_UINT32 )res_x0 - l_x0_dest;
#line 10051
      l_offset_x0_src = 0;
#line 10053
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 10054
        l_width_dest = l_width_src;
#line 10055
        l_offset_x1_src = 0;
      } else {
#line 10057
        l_width_dest = l_x1_dest - (OPJ_UINT32 )res_x0;
#line 10058
        l_offset_x1_src = (OPJ_INT32 )(l_width_src - l_width_dest);
      }
    } else {
#line 10061
      l_start_x_dest = 0U;
#line 10062
      l_offset_x0_src = (OPJ_INT32 )l_x0_dest - res_x0;
#line 10064
      if (l_x1_dest >= (OPJ_UINT32 )res_x1) {
#line 10065
        l_width_dest = l_width_src - (OPJ_UINT32 )l_offset_x0_src;
#line 10066
        l_offset_x1_src = 0;
      } else {
#line 10068
        l_width_dest = l_img_comp_dest->w;
#line 10069
        l_offset_x1_src = res_x1 - (OPJ_INT32 )l_x1_dest;
      }
    }
#line 10073
    if (l_y0_dest < (OPJ_UINT32 )res_y0) {
#line 10074
      l_start_y_dest = (OPJ_UINT32 )res_y0 - l_y0_dest;
#line 10075
      l_offset_y0_src = 0;
#line 10077
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 10078
        l_height_dest = l_height_src;
#line 10079
        l_offset_y1_src = 0;
      } else {
#line 10081
        l_height_dest = l_y1_dest - (OPJ_UINT32 )res_y0;
#line 10082
        l_offset_y1_src = (OPJ_INT32 )(l_height_src - l_height_dest);
      }
    } else {
#line 10085
      l_start_y_dest = 0U;
#line 10086
      l_offset_y0_src = (OPJ_INT32 )l_y0_dest - res_y0;
#line 10088
      if (l_y1_dest >= (OPJ_UINT32 )res_y1) {
#line 10089
        l_height_dest = l_height_src - (OPJ_UINT32 )l_offset_y0_src;
#line 10090
        l_offset_y1_src = 0;
      } else {
#line 10092
        l_height_dest = l_img_comp_dest->h;
#line 10093
        l_offset_y1_src = res_y1 - (OPJ_INT32 )l_y1_dest;
      }
    }
#line 10097
    if (l_offset_x0_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_y0_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_x1_src < 0) {
#line 10099
      return (0);
    } else
#line 10097
    if (l_offset_y1_src < 0) {
#line 10099
      return (0);
    }
#line 10102
    if ((OPJ_INT32 )l_width_dest < 0) {
#line 10103
      return (0);
    } else
#line 10102
    if ((OPJ_INT32 )l_height_dest < 0) {
#line 10103
      return (0);
    }
#line 10108
    l_start_offset_src = (OPJ_SIZE_T )l_offset_x0_src + (OPJ_SIZE_T )l_offset_y0_src * (OPJ_SIZE_T )src_data_stride;
#line 10112
    l_start_offset_dest = (OPJ_SIZE_T )l_start_x_dest + (OPJ_SIZE_T )l_start_y_dest * (OPJ_SIZE_T )l_img_comp_dest->w;
#line 10116
    if (l_img_comp_dest->data == (void *)0) {
#line 10116
      if (l_start_offset_src == 0UL) {
#line 10116
        if (l_start_offset_dest == 0UL) {
#line 10116
          if (src_data_stride == l_img_comp_dest->w) {
#line 10116
            if (l_width_dest == l_img_comp_dest->w) {
#line 10116
              if (l_height_dest == l_img_comp_dest->h) {
#line 10123
                if (p_tcd->whole_tile_decoding) {
#line 10124
                  l_img_comp_dest->data = l_tilec->data;
#line 10125
                  l_tilec->data = (OPJ_INT32 *)((void *)0);
                } else {
#line 10127
                  l_img_comp_dest->data = l_tilec->data_win;
#line 10128
                  l_tilec->data_win = (OPJ_INT32 *)((void *)0);
                }
#line 10130
                goto while_continue;
              } else {
#line 10116
                goto _L;
              }
            } else {
#line 10116
              goto _L;
            }
          } else {
#line 10116
            goto _L;
          }
        } else {
#line 10116
          goto _L;
        }
      } else {
#line 10116
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___16: /* CIL Label */ 
    _L___17: /* CIL Label */ 
    _L___18: /* CIL Label */ 
    _L___19: /* CIL Label */ 
#line 10131
    if (l_img_comp_dest->data == (void *)0) {
#line 10132
      l_width = (OPJ_SIZE_T )l_img_comp_dest->w;
#line 10133
      l_height = (OPJ_SIZE_T )l_img_comp_dest->h;
#line 10135
      if (l_height == 0UL) {
#line 10138
        return (0);
      } else
#line 10135
      if (l_width > 0xffffffffffffffffUL / l_height) {
#line 10138
        return (0);
      } else
#line 10135
      if (l_width * l_height > 0xffffffffffffffffUL / sizeof(OPJ_INT32 )) {
#line 10138
        return (0);
      }
      {
#line 10140
      __cil_tmp38 = opj_image_data_alloc((l_width * l_height) * sizeof(OPJ_INT32 ));
#line 10140
      l_img_comp_dest->data = (OPJ_INT32 *)__cil_tmp38;
      }
#line 10142
      if (! l_img_comp_dest->data) {
#line 10143
        return (0);
      }
#line 10146
      if (l_img_comp_dest->w != l_width_dest) {
        {
        {
#line 10148
        memset(l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
        }
      } else
#line 10146
      if (l_img_comp_dest->h != l_height_dest) {
        {
        {
#line 10148
        memset(l_img_comp_dest->data, 0, ((OPJ_SIZE_T )l_img_comp_dest->w * (unsigned long )l_img_comp_dest->h) * sizeof(OPJ_INT32 ));
        }
        }
      }
    }
#line 10154
    l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
#line 10157
    l_src_ptr = p_src_data;
#line 10158
    l_src_ptr += l_start_offset_src;
#line 10160
    j = (OPJ_UINT32 )0;
    {
#line 10160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10160
      if (! (j < l_height_dest)) {
#line 10160
        goto while_break___0;
      }
      {
#line 10161
      memcpy(l_dest_ptr, l_src_ptr, (unsigned long )l_width_dest * sizeof(OPJ_INT32 ));
#line 10162
      l_dest_ptr += l_img_comp_dest->w;
#line 10163
      l_src_ptr += src_data_stride;
      }
#line 10160
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 9982
    l_tilec ++;
#line 9982
    l_img_comp_src ++;
#line 9982
    l_img_comp_dest ++;
#line 9982
    __cil_tmp40 = i;
#line 9982
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10170
  return (1);
}
}
#line 10173 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_h ;
  OPJ_INT32 l_w ;
  OPJ_INT32 __cil_tmp9 ;
  OPJ_INT32 __cil_tmp10 ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  opj_image_comp_t *__cil_tmp17 ;

  {
#line 10178
  l_img_comp = (opj_image_comp_t *)((void *)0);
#line 10180
  l_img_comp = p_image->comps;
#line 10181
  it_comp = (OPJ_UINT32 )0;
  {
#line 10181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10181
    if (! (it_comp < p_image->numcomps)) {
#line 10181
      goto while_break;
    }
#line 10183
    if (p_image->x0 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->y0 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->x1 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    } else
#line 10183
    if (p_image->y1 > 2147483647U) {
      {
      {
      {
      {
#line 10187
      opj_event_msg(p_manager, 1, "Image coordinates above INT_MAX are not supported\n");
      }
      }
      }
      }
#line 10189
      return (0);
    }
    {
#line 10192
    __cil_tmp9 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 10192
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp9;
#line 10194
    __cil_tmp10 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 10194
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp10;
#line 10196
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 10197
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 10199
    __cil_tmp14 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 10199
    __cil_tmp13 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 10199
    l_w = __cil_tmp13 - __cil_tmp14;
    }
#line 10201
    if (l_w < 0) {
      {
#line 10202
      opj_event_msg(p_manager, 1, "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
                    it_comp, l_w);
      }
#line 10205
      return (0);
    }
    {
#line 10207
    l_img_comp->w = (OPJ_UINT32 )l_w;
#line 10209
    __cil_tmp16 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 10209
    __cil_tmp15 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 10209
    l_h = __cil_tmp15 - __cil_tmp16;
    }
#line 10211
    if (l_h < 0) {
      {
#line 10212
      opj_event_msg(p_manager, 1, "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
                    it_comp, l_h);
      }
#line 10215
      return (0);
    }
#line 10217
    l_img_comp->h = (OPJ_UINT32 )l_h;
#line 10219
    l_img_comp ++;
#line 10181
    it_comp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10222
  return (1);
}
}
#line 10225 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_components(opj_j2k_t *p_j2k , OPJ_UINT32 numcomps , OPJ_UINT32 *comps_indices ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_BOOL *already_mapped ;
  void *__cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 10233
  if (p_j2k->m_private_image == (void *)0) {
    {
#line 10234
    opj_event_msg(p_manager, 1, "opj_read_header() should be called before opj_set_decoded_components().\n");
    }
#line 10237
    return (0);
  }
  {
#line 10240
  __cil_tmp7 = opj_calloc(sizeof(OPJ_BOOL ), (size_t )(p_j2k->m_private_image)->numcomps);
#line 10240
  already_mapped = (OPJ_BOOL *)__cil_tmp7;
  }
#line 10242
  if (already_mapped == (void *)0) {
#line 10243
    return (0);
  }
#line 10246
  i = (OPJ_UINT32 )0;
  {
#line 10246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10246
    if (! (i < numcomps)) {
#line 10246
      goto while_break;
    }
#line 10247
    if (*(comps_indices + i) >= (p_j2k->m_private_image)->numcomps) {
      {
#line 10248
      opj_event_msg(p_manager, 1, "Invalid component index: %u\n", *(comps_indices + i));
#line 10251
      opj_free(already_mapped);
      }
#line 10252
      return (0);
    }
#line 10254
    if (*(already_mapped + *(comps_indices + i))) {
      {
#line 10255
      opj_event_msg(p_manager, 1, "Component index %u used several times\n", *(comps_indices + i));
#line 10258
      opj_free(already_mapped);
      }
#line 10259
      return (0);
    }
#line 10261
    *(already_mapped + *(comps_indices + i)) = 1;
#line 10246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10263
  opj_free(already_mapped);
#line 10265
  opj_free(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode);
  }
#line 10266
  if (numcomps) {
    {
#line 10267
    __cil_tmp9 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 ));
#line 10267
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)__cil_tmp9;
    }
#line 10269
    if (p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode == (void *)0) {
#line 10270
      p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = (OPJ_UINT32 )0;
#line 10271
      return (0);
    }
    {
#line 10273
    memcpy(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode, comps_indices,
           (unsigned long )numcomps * sizeof(OPJ_UINT32 ));
    }
  } else {
#line 10277
    p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode = (OPJ_UINT32 *)((void *)0);
  }
#line 10279
  p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode = numcomps;
#line 10281
  return (1);
}
}
#line 10285 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decode_area(opj_j2k_t *p_j2k , opj_image_t *p_image , OPJ_INT32 p_start_x ,
                                 OPJ_INT32 p_start_y , OPJ_INT32 p_end_x , OPJ_INT32 p_end_y ,
                                 opj_event_mgr_t *p_manager ) 
{ 
  opj_cp_t *l_cp ;
  opj_image_t *l_image ;
  OPJ_BOOL ret ;
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;

  {
#line 10291
  l_cp = & p_j2k->m_cp;
#line 10292
  l_image = p_j2k->m_private_image;
#line 10296
  if ((p_j2k->m_cp.tcps + 0)->m_data != (void *)0) {
#line 10296
    if (p_j2k->m_cp.tw == 1U) {
#line 10296
      if (! (p_j2k->m_cp.th == 1U)) {
#line 10296
        goto _L;
      }
    } else {
#line 10296
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 10302
  if (p_j2k->m_specific_param.m_decoder.m_state != 8U) {
    {
#line 10303
    opj_event_msg(p_manager, 1, "Need to decode the main header before begin to decode the remaining codestream.\n\220");
    }
#line 10305
    return (0);
  }
#line 10310
  it_comp = (OPJ_UINT32 )0;
  {
#line 10310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10310
    if (! (it_comp < p_image->numcomps)) {
#line 10310
      goto while_break;
    }
#line 10311
    (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 10310
    it_comp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10314
  if (! p_start_x) {
#line 10314
    if (! p_start_y) {
#line 10314
      if (! p_end_x) {
#line 10314
        if (! p_end_y) {
          {
#line 10315
          opj_event_msg(p_manager, 4, "No decoded area parameters, set the decoded area to the whole image\n\265U");
#line 10318
          p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10319
          p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10320
          p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 10321
          p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 10323
          p_image->x0 = l_image->x0;
#line 10324
          p_image->y0 = l_image->y0;
#line 10325
          p_image->x1 = l_image->x1;
#line 10326
          p_image->y1 = l_image->y1;
#line 10328
          __cil_tmp12 = opj_j2k_update_image_dimensions(p_image, p_manager);
          }
#line 10328
          return (__cil_tmp12);
        }
      }
    }
  }
#line 10335
  if (p_start_x < 0) {
    {
#line 10336
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) should be >= 0.\n",
                  p_start_x);
    }
#line 10339
    return (0);
  } else
#line 10340
  if ((OPJ_UINT32 )p_start_x > l_image->x1) {
    {
#line 10341
    opj_event_msg(p_manager, 1, "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
                  p_start_x, l_image->x1);
    }
#line 10344
    return (0);
  } else
#line 10345
  if ((OPJ_UINT32 )p_start_x < l_image->x0) {
    {
#line 10346
    opj_event_msg(p_manager, 2, "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
                  p_start_x, l_image->x0);
#line 10349
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = (OPJ_UINT32 )0;
#line 10350
    p_image->x0 = l_image->x0;
    }
  } else {
#line 10352
    p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32 )p_start_x - l_cp->tx0) / l_cp->tdx;
#line 10354
    p_image->x0 = (OPJ_UINT32 )p_start_x;
  }
#line 10358
  if (p_start_y < 0) {
    {
#line 10359
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) should be >= 0.\n",
                  p_start_y);
    }
#line 10362
    return (0);
  } else
#line 10363
  if ((OPJ_UINT32 )p_start_y > l_image->y1) {
    {
#line 10364
    opj_event_msg(p_manager, 1, "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n\265U",
                  p_start_y, l_image->y1);
    }
#line 10367
    return (0);
  } else
#line 10368
  if ((OPJ_UINT32 )p_start_y < l_image->y0) {
    {
#line 10369
    opj_event_msg(p_manager, 2, "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\nU",
                  p_start_y, l_image->y0);
#line 10372
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = (OPJ_UINT32 )0;
#line 10373
    p_image->y0 = l_image->y0;
    }
  } else {
#line 10375
    p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32 )p_start_y - l_cp->ty0) / l_cp->tdy;
#line 10377
    p_image->y0 = (OPJ_UINT32 )p_start_y;
  }
#line 10381
  if (p_end_x <= 0) {
    {
#line 10382
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) should be > 0.\n\242X\t\265U",
                  p_end_x);
    }
#line 10385
    return (0);
  } else
#line 10386
  if ((OPJ_UINT32 )p_end_x < l_image->x0) {
    {
#line 10387
    opj_event_msg(p_manager, 1, "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n\230\001",
                  p_end_x, l_image->x0);
    }
#line 10390
    return (0);
  } else
#line 10391
  if ((OPJ_UINT32 )p_end_x > l_image->x1) {
    {
#line 10392
    opj_event_msg(p_manager, 2, "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
                  p_end_x, l_image->x1);
#line 10395
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
#line 10396
    p_image->x1 = l_image->x1;
    }
  } else {
    {
#line 10398
    __cil_tmp13 = opj_int_ceildiv(p_end_x - (OPJ_INT32 )l_cp->tx0, (OPJ_INT32 )l_cp->tdx);
#line 10398
    p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32 )__cil_tmp13;
#line 10400
    p_image->x1 = (OPJ_UINT32 )p_end_x;
    }
  }
#line 10404
  if (p_end_y <= 0) {
    {
#line 10405
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) should be > 0.\n",
                  p_end_y);
    }
#line 10408
    return (0);
  } else
#line 10409
  if ((OPJ_UINT32 )p_end_y < l_image->y0) {
    {
#line 10410
    opj_event_msg(p_manager, 1, "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
                  p_end_y, l_image->y0);
    }
#line 10413
    return (0);
  }
#line 10415
  if ((OPJ_UINT32 )p_end_y > l_image->y1) {
    {
#line 10416
    opj_event_msg(p_manager, 2, "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n\230\001",
                  p_end_y, l_image->y1);
#line 10419
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
#line 10420
    p_image->y1 = l_image->y1;
    }
  } else {
    {
#line 10422
    __cil_tmp14 = opj_int_ceildiv(p_end_y - (OPJ_INT32 )l_cp->ty0, (OPJ_INT32 )l_cp->tdy);
#line 10422
    p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32 )__cil_tmp14;
#line 10424
    p_image->y1 = (OPJ_UINT32 )p_end_y;
    }
  }
  {
#line 10428
  p_j2k->m_specific_param.m_decoder.m_discard_tiles = (OPJ_BITFIELD )1;
#line 10430
  ret = opj_j2k_update_image_dimensions(p_image, p_manager);
  }
#line 10432
  if (ret) {
    {
#line 10433
    opj_event_msg(p_manager, 4, "Setting decoding area to %d,%d,%d,%d\n", p_image->x0,
                  p_image->y0, p_image->x1, p_image->y1);
    }
  }
#line 10437
  return (ret);
}
}
#line 10440 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_j2k_t *opj_j2k_create_decompress(void) 
{ 
  opj_j2k_t *l_j2k ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  opj_codestream_index_t *__cil_tmp5 ;
  opj_procedure_list_t *__cil_tmp6 ;
  opj_procedure_list_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  opj_thread_pool_t *__cil_tmp9 ;
  opj_thread_pool_t *__cil_tmp10 ;

  {
  {
#line 10442
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_j2k_t ));
#line 10442
  l_j2k = (opj_j2k_t *)__cil_tmp2;
  }
#line 10443
  if (! l_j2k) {
#line 10444
    return ((opj_j2k_t *)0);
  }
  {
#line 10447
  l_j2k->m_is_decoder = 1;
#line 10448
  l_j2k->m_cp.m_is_decoder = (OPJ_BITFIELD )1;
#line 10451
  l_j2k->m_cp.allow_different_bit_depth_sign = (OPJ_BITFIELD )1;
#line 10454
  l_j2k->m_cp.strict = 1;
#line 10460
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_tcp_t ));
#line 10460
  l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t *)__cil_tmp3;
  }
#line 10462
  if (! l_j2k->m_specific_param.m_decoder.m_default_tcp) {
    {
#line 10463
    opj_j2k_destroy(l_j2k);
    }
#line 10464
    return ((opj_j2k_t *)0);
  }
  {
#line 10467
  __cil_tmp4 = opj_calloc((size_t )1, (size_t )1000);
#line 10467
  l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *)__cil_tmp4;
  }
#line 10469
  if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
    {
#line 10470
    opj_j2k_destroy(l_j2k);
    }
#line 10471
    return ((opj_j2k_t *)0);
  }
  {
#line 10474
  l_j2k->m_specific_param.m_decoder.m_header_data_size = (OPJ_UINT32 )1000;
#line 10477
  l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = - 1;
#line 10479
  l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = (OPJ_OFF_T )0;
#line 10482
  l_j2k->cstr_index = opj_j2k_create_cstr_index();
  }
#line 10483
  if (! l_j2k->cstr_index) {
    {
#line 10484
    opj_j2k_destroy(l_j2k);
    }
#line 10485
    return ((opj_j2k_t *)0);
  }
  {
#line 10489
  l_j2k->m_validation_list = opj_procedure_list_create();
  }
#line 10490
  if (! l_j2k->m_validation_list) {
    {
#line 10491
    opj_j2k_destroy(l_j2k);
    }
#line 10492
    return ((opj_j2k_t *)0);
  }
  {
#line 10496
  l_j2k->m_procedure_list = opj_procedure_list_create();
  }
#line 10497
  if (! l_j2k->m_procedure_list) {
    {
#line 10498
    opj_j2k_destroy(l_j2k);
    }
#line 10499
    return ((opj_j2k_t *)0);
  }
  {
#line 10502
  __cil_tmp8 = opj_j2k_get_default_thread_count();
#line 10502
  __cil_tmp9 = opj_thread_pool_create(__cil_tmp8);
#line 10502
  l_j2k->m_tp = __cil_tmp9;
  }
#line 10503
  if (! l_j2k->m_tp) {
    {
#line 10504
    l_j2k->m_tp = opj_thread_pool_create(0);
    }
  }
#line 10506
  if (! l_j2k->m_tp) {
    {
#line 10507
    opj_j2k_destroy(l_j2k);
    }
#line 10508
    return ((opj_j2k_t *)((void *)0));
  }
#line 10511
  return (l_j2k);
}
}
#line 10514 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static opj_codestream_index_t *opj_j2k_create_cstr_index(void) 
{ 
  opj_codestream_index_t *cstr_index ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 10516
  __cil_tmp2 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 10516
  cstr_index = (opj_codestream_index_t *)__cil_tmp2;
  }
#line 10518
  if (! cstr_index) {
#line 10519
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 10522
  cstr_index->maxmarknum = (OPJ_UINT32 )100;
#line 10523
  cstr_index->marknum = (OPJ_UINT32 )0;
#line 10524
  __cil_tmp3 = opj_calloc((size_t )cstr_index->maxmarknum, sizeof(opj_marker_info_t ));
#line 10524
  cstr_index->marker = (opj_marker_info_t *)__cil_tmp3;
  }
#line 10526
  if (! cstr_index->marker) {
    {
#line 10527
    opj_free(cstr_index);
    }
#line 10528
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 10531
  cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
#line 10533
  return (cstr_index);
}
}
#line 10536 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                               OPJ_UINT32 p_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 10540
  l_cp = (opj_cp_t *)0;
#line 10541
  l_tcp = (opj_tcp_t *)0;
#line 10542
  l_tccp = (opj_tccp_t *)0;
#line 10547
  l_cp = & p_j2k->m_cp;
#line 10548
  l_tcp = l_cp->tcps + p_tile_no;
#line 10549
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10555
  if (l_tccp->csty & 1U) {
#line 10556
    return (5U + l_tccp->numresolutions);
  } else {
#line 10558
    return ((OPJ_UINT32 )5);
  }
}
}
#line 10562 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                            OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;

  {
#line 10566
  l_cp = (opj_cp_t *)((void *)0);
#line 10567
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10568
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 10569
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 10574
  l_cp = & p_j2k->m_cp;
#line 10575
  l_tcp = l_cp->tcps + p_tile_no;
#line 10576
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 10577
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 10579
  if (l_tccp0->numresolutions != l_tccp1->numresolutions) {
#line 10580
    return (0);
  }
#line 10582
  if (l_tccp0->cblkw != l_tccp1->cblkw) {
#line 10583
    return (0);
  }
#line 10585
  if (l_tccp0->cblkh != l_tccp1->cblkh) {
#line 10586
    return (0);
  }
#line 10588
  if (l_tccp0->cblksty != l_tccp1->cblksty) {
#line 10589
    return (0);
  }
#line 10591
  if (l_tccp0->qmfbid != l_tccp1->qmfbid) {
#line 10592
    return (0);
  }
#line 10594
  if ((l_tccp0->csty & 1U) != (l_tccp1->csty & 1U)) {
#line 10595
    return (0);
  }
#line 10598
  i = 0U;
  {
#line 10598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10598
    if (! (i < l_tccp0->numresolutions)) {
#line 10598
      goto while_break;
    }
#line 10599
    if (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {
#line 10600
      return (0);
    }
#line 10602
    if (l_tccp0->prch[i] != l_tccp1->prch[i]) {
#line 10603
      return (0);
    }
#line 10598
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10606
  return (1);
}
}
#line 10609 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                          OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;

  {
#line 10617
  l_cp = (opj_cp_t *)0;
#line 10618
  l_tcp = (opj_tcp_t *)0;
#line 10619
  l_tccp = (opj_tccp_t *)0;
#line 10627
  l_cp = & p_j2k->m_cp;
#line 10628
  l_tcp = l_cp->tcps + p_tile_no;
#line 10629
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10635
  if (*p_header_size < 5U) {
    {
#line 10636
    opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\nZ\t\265U");
    }
#line 10637
    return (0);
  }
  {
#line 10640
  opj_write_bytes_LE(p_data, l_tccp->numresolutions - 1U, (OPJ_UINT32 )1);
#line 10641
  p_data ++;
#line 10643
  opj_write_bytes_LE(p_data, l_tccp->cblkw - 2U, (OPJ_UINT32 )1);
#line 10644
  p_data ++;
#line 10646
  opj_write_bytes_LE(p_data, l_tccp->cblkh - 2U, (OPJ_UINT32 )1);
#line 10647
  p_data ++;
#line 10649
  opj_write_bytes_LE(p_data, l_tccp->cblksty, (OPJ_UINT32 )1);
#line 10651
  p_data ++;
#line 10653
  opj_write_bytes_LE(p_data, l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 10655
  p_data ++;
#line 10657
  *p_header_size -= 5U;
  }
#line 10659
  if (l_tccp->csty & 1U) {
#line 10661
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 10662
      opj_event_msg(p_manager, 1, "Error writing SPCod SPCoc element\nZ\t\265U");
      }
#line 10663
      return (0);
    }
#line 10666
    i = (OPJ_UINT32 )0;
    {
#line 10666
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10666
      if (! (i < l_tccp->numresolutions)) {
#line 10666
        goto while_break;
      }
      {
#line 10667
      opj_write_bytes_LE(p_data, l_tccp->prcw[i] + (l_tccp->prch[i] << 4), (OPJ_UINT32 )1);
#line 10669
      p_data ++;
      }
#line 10666
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 10672
    *p_header_size -= l_tccp->numresolutions;
  }
#line 10675
  return (1);
}
}
#line 10678 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(opj_j2k_t *p_j2k , OPJ_UINT32 compno , OPJ_BYTE *p_header_data ,
                                         OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 l_tmp ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  opj_tcp_t *tmp ;

  {
#line 10685
  l_cp = (opj_cp_t *)((void *)0);
#line 10686
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10687
  l_tccp = (opj_tccp_t *)((void *)0);
#line 10688
  l_current_ptr = (OPJ_BYTE *)((void *)0);
#line 10695
  l_cp = & p_j2k->m_cp;
#line 10696
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 10696
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 10696
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10696
  l_tcp = tmp;
#line 10703
  l_tccp = l_tcp->tccps + compno;
#line 10704
  l_current_ptr = p_header_data;
#line 10707
  if (*p_header_size < 5U) {
    {
#line 10708
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\nZ\t\265U");
    }
#line 10709
    return (0);
  }
  {
#line 10713
  opj_read_bytes_LE(l_current_ptr, & l_tccp->numresolutions, (OPJ_UINT32 )1);
#line 10714
  (l_tccp->numresolutions) ++;
  }
#line 10715
  if (l_tccp->numresolutions > 33U) {
    {
#line 10716
    opj_event_msg(p_manager, 1, "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
                  l_tccp->numresolutions, 33);
    }
#line 10719
    return (0);
  }
#line 10721
  l_current_ptr ++;
#line 10724
  if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
    {
#line 10725
    opj_event_msg(p_manager, 1, "Error decoding component %d.\nThe number of resolutions to remove (%d) is greater or equal than the number of resolutions of this component (%d)\nModify the cp_reduce parameter.\n\n",
                  compno, l_cp->m_specific_param.m_dec.m_reduce, l_tccp->numresolutions);
#line 10730
    p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )32768;
    }
#line 10732
    return (0);
  }
  {
#line 10736
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkw, (OPJ_UINT32 )1);
#line 10737
  l_current_ptr ++;
#line 10738
  l_tccp->cblkw += (unsigned int )2;
#line 10741
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblkh, (OPJ_UINT32 )1);
#line 10742
  l_current_ptr ++;
#line 10743
  l_tccp->cblkh += (unsigned int )2;
  }
#line 10745
  if (l_tccp->cblkw > 10U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  } else
#line 10745
  if (l_tccp->cblkh > 10U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  } else
#line 10745
  if (l_tccp->cblkw + l_tccp->cblkh > 12U) {
    {
    {
    {
#line 10747
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n");
    }
    }
    }
#line 10749
    return (0);
  }
  {
#line 10753
  opj_read_bytes_LE(l_current_ptr, & l_tccp->cblksty, (OPJ_UINT32 )1);
#line 10754
  l_current_ptr ++;
  }
#line 10755
  if ((l_tccp->cblksty & 128U) != 0U) {
    {
#line 10757
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element. Unsupported Mixed HT code-block style found\n");
    }
#line 10759
    return (0);
  }
  {
#line 10763
  opj_read_bytes_LE(l_current_ptr, & l_tccp->qmfbid, (OPJ_UINT32 )1);
#line 10764
  l_current_ptr ++;
  }
#line 10766
  if (l_tccp->qmfbid > 1U) {
    {
#line 10767
    opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element, Invalid transformation found\n\220");
    }
#line 10769
    return (0);
  }
#line 10772
  *p_header_size -= 5U;
#line 10775
  if (l_tccp->csty & 1U) {
#line 10776
    if (*p_header_size < l_tccp->numresolutions) {
      {
#line 10777
      opj_event_msg(p_manager, 1, "Error reading SPCod SPCoc element\nZ\t\265U");
      }
#line 10778
      return (0);
    }
#line 10782
    i = (OPJ_UINT32 )0;
    {
#line 10782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10782
      if (! (i < l_tccp->numresolutions)) {
#line 10782
        goto while_break;
      }
      {
#line 10783
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 10784
      l_current_ptr ++;
      }
#line 10786
      if (i != 0U) {
#line 10786
        if ((l_tmp & 15U) == 0U) {
          {
          {
#line 10787
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
          }
#line 10788
          return (0);
        } else
#line 10786
        if (l_tmp >> 4 == 0U) {
          {
          {
#line 10787
          opj_event_msg(p_manager, 1, "Invalid precinct size\n");
          }
          }
#line 10788
          return (0);
        }
      }
#line 10790
      l_tccp->prcw[i] = l_tmp & 15U;
#line 10791
      l_tccp->prch[i] = l_tmp >> 4;
#line 10782
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 10794
    *p_header_size -= l_tccp->numresolutions;
  } else {
#line 10797
    i = (OPJ_UINT32 )0;
    {
#line 10797
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10797
      if (! (i < l_tccp->numresolutions)) {
#line 10797
        goto while_break___0;
      }
#line 10798
      l_tccp->prcw[i] = (OPJ_UINT32 )15;
#line 10799
      l_tccp->prch[i] = (OPJ_UINT32 )15;
#line 10797
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 10827
  return (1);
}
}
#line 10830 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_component_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_prc_size ;
  opj_tcp_t *tmp ;

  {
#line 10834
  l_cp = (opj_cp_t *)((void *)0);
#line 10835
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10836
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 10836
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 10842
  l_cp = & p_j2k->m_cp;
#line 10843
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 10843
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 10843
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 10843
  l_tcp = tmp;
#line 10848
  l_ref_tccp = l_tcp->tccps + 0;
#line 10849
  l_copied_tccp = l_ref_tccp + 1;
#line 10850
  l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32 )sizeof(OPJ_UINT32 );
#line 10852
  i = (OPJ_UINT32 )1;
  {
#line 10852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10852
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 10852
      goto while_break;
    }
    {
#line 10853
    l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
#line 10854
    l_copied_tccp->cblkw = l_ref_tccp->cblkw;
#line 10855
    l_copied_tccp->cblkh = l_ref_tccp->cblkh;
#line 10856
    l_copied_tccp->cblksty = l_ref_tccp->cblksty;
#line 10857
    l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
#line 10858
    memcpy((OPJ_UINT32 *)l_copied_tccp->prcw, (OPJ_UINT32 *)l_ref_tccp->prcw, (unsigned long )l_prc_size);
#line 10859
    memcpy((OPJ_UINT32 *)l_copied_tccp->prch, (OPJ_UINT32 *)l_ref_tccp->prch, (unsigned long )l_prc_size);
#line 10860
    l_copied_tccp ++;
    }
#line 10852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 10864 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                             OPJ_UINT32 p_comp_no ) 
{ 
  OPJ_UINT32 l_num_bands ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp ;

  {
#line 10870
  l_cp = (opj_cp_t *)0;
#line 10871
  l_tcp = (opj_tcp_t *)0;
#line 10872
  l_tccp = (opj_tccp_t *)0;
#line 10877
  l_cp = & p_j2k->m_cp;
#line 10878
  l_tcp = l_cp->tcps + p_tile_no;
#line 10879
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10885
  if (l_tccp->qntsty == 1U) {
#line 10885
    tmp = (unsigned int )1;
  } else {
#line 10885
    tmp = l_tccp->numresolutions * 3U - 2U;
  }
#line 10885
  l_num_bands = tmp;
#line 10888
  if (l_tccp->qntsty == 0U) {
#line 10889
    return (1U + l_num_bands);
  } else {
#line 10891
    return (1U + 2U * l_num_bands);
  }
}
}
#line 10895 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                          OPJ_UINT32 p_first_comp_no , OPJ_UINT32 p_second_comp_no ) 
{ 
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp0 ;
  opj_tccp_t *l_tccp1 ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;

  {
#line 10898
  l_cp = (opj_cp_t *)((void *)0);
#line 10899
  l_tcp = (opj_tcp_t *)((void *)0);
#line 10900
  l_tccp0 = (opj_tccp_t *)((void *)0);
#line 10901
  l_tccp1 = (opj_tccp_t *)((void *)0);
#line 10907
  l_cp = & p_j2k->m_cp;
#line 10908
  l_tcp = l_cp->tcps + p_tile_no;
#line 10909
  l_tccp0 = l_tcp->tccps + p_first_comp_no;
#line 10910
  l_tccp1 = l_tcp->tccps + p_second_comp_no;
#line 10912
  if (l_tccp0->qntsty != l_tccp1->qntsty) {
#line 10913
    return (0);
  }
#line 10915
  if (l_tccp0->numgbits != l_tccp1->numgbits) {
#line 10916
    return (0);
  }
#line 10918
  if (l_tccp0->qntsty == 1U) {
#line 10919
    l_num_bands = 1U;
  } else {
#line 10921
    l_num_bands = l_tccp0->numresolutions * 3U - 2U;
#line 10922
    if (l_num_bands != l_tccp1->numresolutions * 3U - 2U) {
#line 10923
      return (0);
    }
  }
#line 10927
  l_band_no = (OPJ_UINT32 )0;
  {
#line 10927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10927
    if (! (l_band_no < l_num_bands)) {
#line 10927
      goto while_break;
    }
#line 10928
    if (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn) {
#line 10929
      return (0);
    }
#line 10927
    l_band_no ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10932
  if (l_tccp0->qntsty != 0U) {
#line 10933
    l_band_no = (OPJ_UINT32 )0;
    {
#line 10933
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10933
      if (! (l_band_no < l_num_bands)) {
#line 10933
        goto while_break___0;
      }
#line 10934
      if (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant) {
#line 10935
        return (0);
      }
#line 10933
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 10939
  return (1);
}
}
#line 10943 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_no ,
                                        OPJ_UINT32 p_comp_no , OPJ_BYTE *p_data ,
                                        OPJ_UINT32 *p_header_size , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_header_size ;
  OPJ_UINT32 l_band_no ;
  OPJ_UINT32 l_num_bands ;
  OPJ_UINT32 l_expn ;
  OPJ_UINT32 l_mant ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  unsigned int tmp ;

  {
#line 10954
  l_cp = (opj_cp_t *)0;
#line 10955
  l_tcp = (opj_tcp_t *)0;
#line 10956
  l_tccp = (opj_tccp_t *)0;
#line 10964
  l_cp = & p_j2k->m_cp;
#line 10965
  l_tcp = l_cp->tcps + p_tile_no;
#line 10966
  l_tccp = l_tcp->tccps + p_comp_no;
#line 10972
  if (l_tccp->qntsty == 1U) {
#line 10972
    tmp = (unsigned int )1;
  } else {
#line 10972
    tmp = l_tccp->numresolutions * 3U - 2U;
  }
#line 10972
  l_num_bands = tmp;
#line 10975
  if (l_tccp->qntsty == 0U) {
#line 10976
    l_header_size = 1U + l_num_bands;
#line 10978
    if (*p_header_size < l_header_size) {
      {
#line 10979
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10980
      return (0);
    }
    {
#line 10983
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 10985
    p_data ++;
#line 10987
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 10987
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10987
      if (! (l_band_no < l_num_bands)) {
#line 10987
        goto while_break;
      }
      {
#line 10988
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 10989
      opj_write_bytes_LE(p_data, l_expn << 3, (OPJ_UINT32 )1);
#line 10990
      p_data ++;
      }
#line 10987
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 10993
    l_header_size = 1U + 2U * l_num_bands;
#line 10995
    if (*p_header_size < l_header_size) {
      {
#line 10996
      opj_event_msg(p_manager, 1, "Error writing SQcd SQcc element\n\220");
      }
#line 10997
      return (0);
    }
    {
#line 11000
    opj_write_bytes_LE(p_data, l_tccp->qntsty + (l_tccp->numgbits << 5), (OPJ_UINT32 )1);
#line 11002
    p_data ++;
#line 11004
    l_band_no = (OPJ_UINT32 )0;
    }
    {
#line 11004
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11004
      if (! (l_band_no < l_num_bands)) {
#line 11004
        goto while_break___0;
      }
      {
#line 11005
      l_expn = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].expn;
#line 11006
      l_mant = (OPJ_UINT32 )l_tccp->stepsizes[l_band_no].mant;
#line 11008
      opj_write_bytes_LE(p_data, (l_expn << 11) + l_mant, (OPJ_UINT32 )2);
#line 11009
      p_data += 2;
      }
#line 11004
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 11013
  *p_header_size -= l_header_size;
#line 11015
  return (1);
}
}
#line 11018 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k , OPJ_UINT32 p_comp_no , OPJ_BYTE *p_header_data ,
                                       OPJ_UINT32 *p_header_size , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_band_no ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_tccp ;
  OPJ_BYTE *l_current_ptr ;
  OPJ_UINT32 l_tmp ;
  OPJ_UINT32 l_num_band ;
  opj_tcp_t *tmp ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 __cil_tmp16 ;
  OPJ_INT32 tmp___1 ;
  OPJ_UINT32 __cil_tmp18 ;

  {
#line 11027
  l_cp = (opj_cp_t *)0;
#line 11028
  l_tcp = (opj_tcp_t *)0;
#line 11029
  l_tccp = (opj_tccp_t *)0;
#line 11030
  l_current_ptr = (OPJ_BYTE *)0;
#line 11038
  l_cp = & p_j2k->m_cp;
#line 11040
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 11040
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 11040
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 11040
  l_tcp = tmp;
#line 11048
  l_tccp = l_tcp->tccps + p_comp_no;
#line 11049
  l_current_ptr = p_header_data;
#line 11051
  if (*p_header_size < 1U) {
    {
#line 11052
    opj_event_msg(p_manager, 1, "Error reading SQcd or SQcc element\n");
    }
#line 11053
    return (0);
  }
  {
#line 11055
  *p_header_size -= (unsigned int )1;
#line 11057
  opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 11058
  l_current_ptr ++;
#line 11060
  l_tccp->qntsty = l_tmp & 31U;
#line 11061
  l_tccp->numgbits = l_tmp >> 5;
  }
#line 11062
  if (l_tccp->qntsty == 1U) {
#line 11063
    l_num_band = (OPJ_UINT32 )1;
  } else {
#line 11065
    if (l_tccp->qntsty == 0U) {
#line 11065
      tmp___0 = *p_header_size;
    } else {
#line 11065
      tmp___0 = *p_header_size / 2U;
    }
#line 11065
    l_num_band = tmp___0;
#line 11069
    if (l_num_band > 97U) {
      {
#line 11070
      opj_event_msg(p_manager, 2, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to OPJ_J2K_MAXBANDS (%d) and skip the rest. \n",
                    l_num_band, 97, 97);
      }
    }
  }
#line 11101
  if (l_tccp->qntsty == 0U) {
#line 11102
    l_band_no = (OPJ_UINT32 )0;
    {
#line 11102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11102
      if (! (l_band_no < l_num_band)) {
#line 11102
        goto while_break;
      }
      {
#line 11103
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )1);
#line 11104
      l_current_ptr ++;
      }
#line 11105
      if (l_band_no < 97U) {
#line 11106
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 3);
#line 11107
        l_tccp->stepsizes[l_band_no].mant = 0;
      }
#line 11102
      l_band_no ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 11110
    *p_header_size -= l_num_band;
  } else {
#line 11112
    l_band_no = (OPJ_UINT32 )0;
    {
#line 11112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11112
      if (! (l_band_no < l_num_band)) {
#line 11112
        goto while_break___0;
      }
      {
#line 11113
      opj_read_bytes_LE(l_current_ptr, & l_tmp, (OPJ_UINT32 )2);
#line 11114
      l_current_ptr += 2;
      }
#line 11115
      if (l_band_no < 97U) {
#line 11116
        l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32 )(l_tmp >> 11);
#line 11117
        l_tccp->stepsizes[l_band_no].mant = (OPJ_INT32 )(l_tmp & 2047U);
      }
#line 11112
      l_band_no ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11120
    *p_header_size -= 2U * l_num_band;
  }
#line 11124
  if (l_tccp->qntsty == 1U) {
#line 11125
    l_band_no = (OPJ_UINT32 )1;
    {
#line 11125
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 11125
      if (! (l_band_no < 97U)) {
#line 11125
        goto while_break___1;
      }
#line 11126
      if ((OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U) > 0) {
#line 11126
        tmp___1 = (OPJ_INT32 )l_tccp->stepsizes[0].expn - (OPJ_INT32 )((l_band_no - 1U) / 3U);
      } else {
#line 11126
        tmp___1 = 0;
      }
#line 11126
      l_tccp->stepsizes[l_band_no].expn = tmp___1;
#line 11130
      l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
#line 11125
      l_band_no ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 11134
  return (1);
}
}
#line 11137 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_copy_tile_quantization_parameters(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 i ;
  opj_cp_t *l_cp ;
  opj_tcp_t *l_tcp ;
  opj_tccp_t *l_ref_tccp ;
  opj_tccp_t *l_copied_tccp ;
  OPJ_UINT32 l_size ;
  opj_tcp_t *tmp ;

  {
#line 11140
  l_cp = (opj_cp_t *)((void *)0);
#line 11141
  l_tcp = (opj_tcp_t *)((void *)0);
#line 11142
  l_ref_tccp = (opj_tccp_t *)((void *)0);
#line 11143
  l_copied_tccp = (opj_tccp_t *)((void *)0);
#line 11149
  l_cp = & p_j2k->m_cp;
#line 11150
  if (p_j2k->m_specific_param.m_decoder.m_state == 16U) {
#line 11150
    tmp = l_cp->tcps + p_j2k->m_current_tile_number;
  } else {
#line 11150
    tmp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
  }
#line 11150
  l_tcp = tmp;
#line 11154
  l_ref_tccp = l_tcp->tccps + 0;
#line 11155
  l_copied_tccp = l_ref_tccp + 1;
#line 11156
  l_size = (OPJ_UINT32 )(97UL * sizeof(opj_stepsize_t ));
#line 11158
  i = (OPJ_UINT32 )1;
  {
#line 11158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11158
    if (! (i < (p_j2k->m_private_image)->numcomps)) {
#line 11158
      goto while_break;
    }
    {
#line 11159
    l_copied_tccp->qntsty = l_ref_tccp->qntsty;
#line 11160
    l_copied_tccp->numgbits = l_ref_tccp->numgbits;
#line 11161
    memcpy((opj_stepsize_t *)l_copied_tccp->stepsizes, (opj_stepsize_t *)l_ref_tccp->stepsizes,
           (unsigned long )l_size);
#line 11162
    l_copied_tccp ++;
    }
#line 11158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 11166 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_tile_info(opj_tcp_t *l_default_tile , OPJ_INT32 numcomps ,
                                   FILE *out_stream ) 
{ 
  OPJ_INT32 compno ;
  opj_tccp_t *l_tccp ;
  OPJ_UINT32 resno ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  OPJ_UINT32 __cil_tmp9 ;
  int tmp ;
  OPJ_INT32 __cil_tmp11 ;
  OPJ_INT32 __cil_tmp12 ;

  {
#line 11169
  if (l_default_tile) {
    {
#line 11172
    fprintf(out_stream, "\t default tile {\n");
#line 11173
    fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
#line 11174
    fprintf(out_stream, "\t\t prg=%#x\n\t\265U", (int )l_default_tile->prg);
#line 11175
    fprintf(out_stream, "\t\t numlayers=%d\n\230\001", l_default_tile->numlayers);
#line 11176
    fprintf(out_stream, "\t\t mct=%x\n[\t\265U", l_default_tile->mct);
#line 11178
    compno = 0;
    }
    {
#line 11178
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11178
      if (! (compno < numcomps)) {
#line 11178
        goto while_break;
      }
      {
#line 11179
      l_tccp = l_default_tile->tccps + compno;
#line 11184
      fprintf(out_stream, "\t\t comp %d {\nU", compno);
#line 11185
      fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
#line 11186
      fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
#line 11187
      fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
#line 11188
      fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
#line 11189
      fprintf(out_stream, "\t\t\t cblksty=%#x\n\230\001", l_tccp->cblksty);
#line 11190
      fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
#line 11192
      fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
#line 11193
      resno = (OPJ_UINT32 )0;
      }
      {
#line 11193
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 11193
        if (! (resno < l_tccp->numresolutions)) {
#line 11193
          goto while_break___0;
        }
        {
#line 11194
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->prcw[resno], l_tccp->prch[resno]);
        }
#line 11193
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 11196
      fprintf(out_stream, "\nO[\t\265U");
#line 11199
      fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
#line 11200
      fprintf(out_stream, "\t\t\t numgbits=%d\n\230\001", l_tccp->numgbits);
#line 11201
      fprintf(out_stream, "\t\t\t stepsizes (m,e)=\265U");
      }
#line 11202
      if (l_tccp->qntsty == 1U) {
#line 11202
        tmp = 1;
      } else {
#line 11202
        tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
      }
#line 11202
      numbands = tmp;
#line 11204
      bandno = 0;
      {
#line 11204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 11204
        if (! (bandno < numbands)) {
#line 11204
          goto while_break___1;
        }
        {
#line 11205
        fprintf(out_stream, "(%d,%d) \230\001", l_tccp->stepsizes[bandno].mant, l_tccp->stepsizes[bandno].expn);
        }
#line 11204
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 11208
      fprintf(out_stream, "\n");
#line 11211
      fprintf(out_stream, "\t\t\t roishift=%d\n\230\001", l_tccp->roishift);
#line 11213
      fprintf(out_stream, "\t\t }\nU");
      }
#line 11178
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 11215
    fprintf(out_stream, "\t }\n");
    }
  }
  return;
}
}
#line 11219 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump(opj_j2k_t *p_j2k , OPJ_INT32 flag , FILE *out_stream ) 
{ 
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  opj_tcp_t *l_tcp ;

  {
#line 11222
  if (flag & 128) {
    {
    {
#line 11223
    fprintf(out_stream, "Wrong flag\n\t\265U");
    }
    }
#line 11224
    return;
  } else
#line 11222
  if (flag & 256) {
    {
    {
#line 11223
    fprintf(out_stream, "Wrong flag\n\t\265U");
    }
    }
#line 11224
    return;
  }
#line 11228
  if (flag & 1) {
#line 11229
    if (p_j2k->m_private_image) {
      {
#line 11230
      j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
      }
    }
  }
#line 11235
  if (flag & 2) {
#line 11236
    if (p_j2k->m_private_image) {
      {
#line 11237
      opj_j2k_dump_MH_info(p_j2k, out_stream);
      }
    }
  }
#line 11241
  if (flag & 8) {
#line 11242
    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 11244
    l_tcp = p_j2k->m_cp.tcps;
#line 11245
    if (p_j2k->m_private_image) {
#line 11246
      i = (OPJ_UINT32 )0;
      {
#line 11246
      while (1) {
        while_continue: /* CIL Label */ ;
#line 11246
        if (! (i < l_nb_tiles)) {
#line 11246
          goto while_break;
        }
        {
#line 11247
        opj_j2k_dump_tile_info(l_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                               out_stream);
#line 11249
        l_tcp ++;
        }
#line 11246
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 11255
  if (flag & 4) {

  }
#line 11260
  if (flag & 16) {
    {
#line 11261
    opj_j2k_dump_MH_index(p_j2k, out_stream);
    }
  }
#line 11265
  if (flag & 32) {

  }
  return;
}
}
#line 11271 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_index(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 
  opj_codestream_index_t *cstr_index ;
  OPJ_UINT32 it_marker ;
  OPJ_UINT32 it_tile ;
  OPJ_UINT32 it_tile_part ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 l_acc_nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 nb_of_tile_part ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 11273
  cstr_index = p_j2k->cstr_index;
#line 11276
  fprintf(out_stream, "Codestream index from main header: {\n");
#line 11278
  fprintf(out_stream, "\t Main header start position=%li\n\t Main header end position=%li\n",
          cstr_index->main_head_start, cstr_index->main_head_end);
#line 11282
  fprintf(out_stream, "\t Marker list: {\n");
  }
#line 11284
  if (cstr_index->marker) {
#line 11285
    it_marker = (OPJ_UINT32 )0;
    {
#line 11285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11285
      if (! (it_marker < cstr_index->marknum)) {
#line 11285
        goto while_break;
      }
      {
#line 11286
      fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )(cstr_index->marker + it_marker)->type,
              (cstr_index->marker + it_marker)->pos, (cstr_index->marker + it_marker)->len);
      }
#line 11285
      it_marker ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 11293
  fprintf(out_stream, "\t }\n");
  }
#line 11295
  if (cstr_index->tile_index) {
#line 11298
    l_acc_nb_of_tile_part = (OPJ_UINT32 )0;
#line 11299
    it_tile = (OPJ_UINT32 )0;
    {
#line 11299
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11299
      if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 11299
        goto while_break___0;
      }
#line 11300
      l_acc_nb_of_tile_part += (cstr_index->tile_index + it_tile)->nb_tps;
#line 11299
      it_tile ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11303
    if (l_acc_nb_of_tile_part) {
      {
#line 11304
      fprintf(out_stream, "\t Tile index: {\n\220");
#line 11306
      it_tile = (OPJ_UINT32 )0;
      }
      {
#line 11306
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 11306
        if (! (it_tile < cstr_index->nb_of_tiles)) {
#line 11306
          goto while_break___1;
        }
        {
#line 11307
        nb_of_tile_part = (cstr_index->tile_index + it_tile)->nb_tps;
#line 11309
        fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
        }
#line 11312
        if ((cstr_index->tile_index + it_tile)->tp_index) {
#line 11313
          it_tile_part = (OPJ_UINT32 )0;
          {
#line 11313
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 11313
            if (! (it_tile_part < nb_of_tile_part)) {
#line 11313
              goto while_break___2;
            }
            {
#line 11314
            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%li, end_header=%li, end_pos=%li.\n",
                    it_tile_part, ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->start_pos,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_header,
                    ((cstr_index->tile_index + it_tile)->tp_index + it_tile_part)->end_pos);
            }
#line 11313
            it_tile_part ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 11323
        if ((cstr_index->tile_index + it_tile)->marker) {
#line 11324
          it_marker = (OPJ_UINT32 )0;
          {
#line 11324
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 11324
            if (! (it_marker < (cstr_index->tile_index + it_tile)->marknum)) {
#line 11324
              goto while_break___3;
            }
            {
#line 11326
            fprintf(out_stream, "\t\t type=%#x, pos=%li, len=%d\n", (int )((cstr_index->tile_index + it_tile)->marker + it_marker)->type,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->pos,
                    ((cstr_index->tile_index + it_tile)->marker + it_marker)->len);
            }
#line 11325
            it_marker ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 11306
        it_tile ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 11333
      fprintf(out_stream, "\t }\n");
      }
    }
  }
  {
#line 11337
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11342 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_dump_MH_info(opj_j2k_t *p_j2k , FILE *out_stream ) 
{ 


  {
  {
#line 11345
  fprintf(out_stream, "Codestream info from main header: {\n");
#line 11347
  fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
#line 11348
  fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
#line 11349
  fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
#line 11350
  opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp, (OPJ_INT32 )(p_j2k->m_private_image)->numcomps,
                         out_stream);
#line 11352
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11355 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump_image_header(opj_image_t *img_header , OPJ_BOOL dev_dump_flag , FILE *out_stream ) 
{ 
  char tab[2] ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 11360
  if (dev_dump_flag) {
    {
#line 11361
    fprintf(stdout, "[DEV] Dump an image_header struct {\n");
#line 11362
    tab[0] = (char )'\000';
    }
  } else {
    {
#line 11364
    fprintf(out_stream, "Image info {\n");
#line 11365
    tab[0] = (char )'\t';
#line 11366
    tab[1] = (char )'\000';
    }
  }
  {
#line 11369
  fprintf(out_stream, "%s x0=%d, y0=%d\n\230\001", (char *)tab, img_header->x0, img_header->y0);
#line 11370
  fprintf(out_stream, "%s x1=%d, y1=%d\n\230\001", (char *)tab, img_header->x1, img_header->y1);
#line 11372
  fprintf(out_stream, "%s numcomps=%d\n", (char *)tab, img_header->numcomps);
  }
#line 11374
  if (img_header->comps) {
#line 11376
    compno = (OPJ_UINT32 )0;
    {
#line 11376
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11376
      if (! (compno < img_header->numcomps)) {
#line 11376
        goto while_break;
      }
      {
#line 11377
      fprintf(out_stream, "%s\t component %d {\n", (char *)tab, compno);
#line 11378
      j2k_dump_image_comp_header(img_header->comps + compno, dev_dump_flag, out_stream);
#line 11380
      fprintf(out_stream, "%s}\n", (char *)tab);
      }
#line 11376
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 11384
  fprintf(out_stream, "}\n");
  }
  return;
}
}
#line 11387 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
void j2k_dump_image_comp_header(opj_image_comp_t *comp_header , OPJ_BOOL dev_dump_flag ,
                                FILE *out_stream ) 
{ 
  char tab[3] ;

  {
#line 11392
  if (dev_dump_flag) {
    {
#line 11393
    fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
#line 11394
    tab[0] = (char )'\000';
    }
  } else {
#line 11396
    tab[0] = (char )'\t';
#line 11397
    tab[1] = (char )'\t';
#line 11398
    tab[2] = (char )'\000';
  }
  {
#line 11401
  fprintf(out_stream, "%s dx=%d, dy=%d\n\230\001", (char *)tab, comp_header->dx, comp_header->dy);
#line 11402
  fprintf(out_stream, "%s prec=%d\n", (char *)tab, comp_header->prec);
#line 11403
  fprintf(out_stream, "%s sgnd=%d\n", (char *)tab, comp_header->sgnd);
  }
#line 11405
  if (dev_dump_flag) {
    {
#line 11406
    fprintf(out_stream, "}\n");
    }
  }
  return;
}
}
#line 11410 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_codestream_info_v2_t *j2k_get_cstr_info(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 numcomps ;
  opj_tcp_t *l_default_tile ;
  opj_codestream_info_v2_t *cstr_info ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_tccp_t *l_tccp ;
  opj_tccp_info_t *l_tccp_info ;
  OPJ_INT32 bandno ;
  OPJ_INT32 numbands ;
  int tmp ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;

  {
  {
#line 11413
  numcomps = (p_j2k->m_private_image)->numcomps;
#line 11415
  __cil_tmp6 = opj_calloc((size_t )1, sizeof(opj_codestream_info_v2_t ));
#line 11415
  cstr_info = (opj_codestream_info_v2_t *)__cil_tmp6;
  }
#line 11417
  if (! cstr_info) {
#line 11418
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
  {
#line 11421
  cstr_info->nbcomps = (p_j2k->m_private_image)->numcomps;
#line 11423
  cstr_info->tx0 = p_j2k->m_cp.tx0;
#line 11424
  cstr_info->ty0 = p_j2k->m_cp.ty0;
#line 11425
  cstr_info->tdx = p_j2k->m_cp.tdx;
#line 11426
  cstr_info->tdy = p_j2k->m_cp.tdy;
#line 11427
  cstr_info->tw = p_j2k->m_cp.tw;
#line 11428
  cstr_info->th = p_j2k->m_cp.th;
#line 11430
  cstr_info->tile_info = (opj_tile_info_v2_t *)((void *)0);
#line 11432
  l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
#line 11434
  cstr_info->m_default_tile_info.csty = l_default_tile->csty;
#line 11435
  cstr_info->m_default_tile_info.prg = l_default_tile->prg;
#line 11436
  cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
#line 11437
  cstr_info->m_default_tile_info.mct = l_default_tile->mct;
#line 11439
  __cil_tmp7 = opj_calloc((size_t )cstr_info->nbcomps, sizeof(opj_tccp_info_t ));
#line 11439
  cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t *)__cil_tmp7;
  }
#line 11441
  if (! cstr_info->m_default_tile_info.tccp_info) {
    {
#line 11442
    opj_destroy_cstr_info(& cstr_info);
    }
#line 11443
    return ((opj_codestream_info_v2_t *)((void *)0));
  }
#line 11446
  compno = (OPJ_UINT32 )0;
  {
#line 11446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11446
    if (! (compno < numcomps)) {
#line 11446
      goto while_break;
    }
#line 11447
    l_tccp = l_default_tile->tccps + compno;
#line 11448
    l_tccp_info = cstr_info->m_default_tile_info.tccp_info + compno;
#line 11453
    l_tccp_info->csty = l_tccp->csty;
#line 11454
    l_tccp_info->numresolutions = l_tccp->numresolutions;
#line 11455
    l_tccp_info->cblkw = l_tccp->cblkw;
#line 11456
    l_tccp_info->cblkh = l_tccp->cblkh;
#line 11457
    l_tccp_info->cblksty = l_tccp->cblksty;
#line 11458
    l_tccp_info->qmfbid = l_tccp->qmfbid;
#line 11459
    if (l_tccp->numresolutions < 33U) {
      {
#line 11460
      memcpy((OPJ_UINT32 *)l_tccp_info->prch, (OPJ_UINT32 *)l_tccp->prch, (unsigned long )l_tccp->numresolutions);
#line 11461
      memcpy((OPJ_UINT32 *)l_tccp_info->prcw, (OPJ_UINT32 *)l_tccp->prcw, (unsigned long )l_tccp->numresolutions);
      }
    }
#line 11465
    l_tccp_info->qntsty = l_tccp->qntsty;
#line 11466
    l_tccp_info->numgbits = l_tccp->numgbits;
#line 11468
    if (l_tccp->qntsty == 1U) {
#line 11468
      tmp = 1;
    } else {
#line 11468
      tmp = (OPJ_INT32 )l_tccp->numresolutions * 3 - 2;
    }
#line 11468
    numbands = tmp;
#line 11470
    if (numbands < 97) {
#line 11471
      bandno = 0;
      {
#line 11471
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 11471
        if (! (bandno < numbands)) {
#line 11471
          goto while_break___0;
        }
#line 11472
        l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].mant;
#line 11474
        l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32 )l_tccp->stepsizes[bandno].expn;
#line 11471
        bandno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 11480
    l_tccp_info->roishift = l_tccp->roishift;
#line 11446
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11483
  return (cstr_info);
}
}
#line 11486 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
opj_codestream_index_t *j2k_get_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  opj_codestream_index_t *l_cstr_index ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  OPJ_UINT32 it_tile ;
  void *__cil_tmp7 ;
  OPJ_UINT32 it_tile_free ;
  OPJ_UINT32 __cil_tmp9 ;
  void *__cil_tmp10 ;
  OPJ_UINT32 it_tile_free___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;

  {
  {
#line 11488
  __cil_tmp3 = opj_calloc((size_t )1, sizeof(opj_codestream_index_t ));
#line 11488
  l_cstr_index = (opj_codestream_index_t *)__cil_tmp3;
  }
#line 11490
  if (! l_cstr_index) {
#line 11491
    return ((opj_codestream_index_t *)((void *)0));
  }
  {
#line 11494
  l_cstr_index->main_head_start = (p_j2k->cstr_index)->main_head_start;
#line 11495
  l_cstr_index->main_head_end = (p_j2k->cstr_index)->main_head_end;
#line 11496
  l_cstr_index->codestream_size = (p_j2k->cstr_index)->codestream_size;
#line 11498
  l_cstr_index->marknum = (p_j2k->cstr_index)->marknum;
#line 11499
  __cil_tmp4 = opj_malloc((unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
#line 11499
  l_cstr_index->marker = (opj_marker_info_t *)__cil_tmp4;
  }
#line 11501
  if (! l_cstr_index->marker) {
    {
#line 11502
    opj_free(l_cstr_index);
    }
#line 11503
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11506
  if ((p_j2k->cstr_index)->marker) {
    {
#line 11507
    memcpy(l_cstr_index->marker, (p_j2k->cstr_index)->marker, (unsigned long )l_cstr_index->marknum * sizeof(opj_marker_info_t ));
    }
  } else {
    {
#line 11510
    opj_free(l_cstr_index->marker);
#line 11511
    l_cstr_index->marker = (opj_marker_info_t *)((void *)0);
    }
  }
  {
#line 11514
  l_cstr_index->nb_of_tiles = (p_j2k->cstr_index)->nb_of_tiles;
#line 11515
  __cil_tmp5 = opj_calloc((size_t )l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11515
  l_cstr_index->tile_index = (opj_tile_index_t *)__cil_tmp5;
  }
#line 11517
  if (! l_cstr_index->tile_index) {
    {
#line 11518
    opj_free(l_cstr_index->marker);
#line 11519
    opj_free(l_cstr_index);
    }
#line 11520
    return ((opj_codestream_index_t *)((void *)0));
  }
#line 11523
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 11524
    opj_free(l_cstr_index->tile_index);
#line 11525
    l_cstr_index->tile_index = (opj_tile_index_t *)((void *)0);
    }
  } else {
#line 11527
    it_tile = (OPJ_UINT32 )0;
#line 11528
    it_tile = (OPJ_UINT32 )0;
    {
#line 11528
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11528
      if (! (it_tile < l_cstr_index->nb_of_tiles)) {
#line 11528
        goto while_break;
      }
      {
#line 11531
      (l_cstr_index->tile_index + it_tile)->marknum = ((p_j2k->cstr_index)->tile_index + it_tile)->marknum;
#line 11534
      __cil_tmp7 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
#line 11534
      (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp7;
      }
#line 11538
      if (! (l_cstr_index->tile_index + it_tile)->marker) {
#line 11541
        it_tile_free = (OPJ_UINT32 )0;
        {
#line 11541
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 11541
          if (! (it_tile_free < it_tile)) {
#line 11541
            goto while_break___0;
          }
          {
#line 11542
          opj_free((l_cstr_index->tile_index + it_tile_free)->marker);
          }
#line 11541
          it_tile_free ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 11545
        opj_free(l_cstr_index->tile_index);
#line 11546
        opj_free(l_cstr_index->marker);
#line 11547
        opj_free(l_cstr_index);
        }
#line 11548
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11551
      if (((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
        {
#line 11552
        memcpy((l_cstr_index->tile_index + it_tile)->marker, ((p_j2k->cstr_index)->tile_index + it_tile)->marker,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->marknum * sizeof(opj_marker_info_t ));
        }
      } else {
        {
#line 11556
        opj_free((l_cstr_index->tile_index + it_tile)->marker);
#line 11557
        (l_cstr_index->tile_index + it_tile)->marker = (opj_marker_info_t *)((void *)0);
        }
      }
      {
#line 11561
      (l_cstr_index->tile_index + it_tile)->nb_tps = ((p_j2k->cstr_index)->tile_index + it_tile)->nb_tps;
#line 11564
      __cil_tmp10 = opj_malloc((unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
#line 11564
      (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)__cil_tmp10;
      }
#line 11568
      if (! (l_cstr_index->tile_index + it_tile)->tp_index) {
#line 11571
        it_tile_free___0 = (OPJ_UINT32 )0;
        {
#line 11571
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 11571
          if (! (it_tile_free___0 < it_tile)) {
#line 11571
            goto while_break___1;
          }
          {
#line 11572
          opj_free((l_cstr_index->tile_index + it_tile_free___0)->marker);
#line 11573
          opj_free((l_cstr_index->tile_index + it_tile_free___0)->tp_index);
          }
#line 11571
          it_tile_free___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 11576
        opj_free(l_cstr_index->tile_index);
#line 11577
        opj_free(l_cstr_index->marker);
#line 11578
        opj_free(l_cstr_index);
        }
#line 11579
        return ((opj_codestream_index_t *)((void *)0));
      }
#line 11582
      if (((p_j2k->cstr_index)->tile_index + it_tile)->tp_index) {
        {
#line 11583
        memcpy((l_cstr_index->tile_index + it_tile)->tp_index, ((p_j2k->cstr_index)->tile_index + it_tile)->tp_index,
               (unsigned long )(l_cstr_index->tile_index + it_tile)->nb_tps * sizeof(opj_tp_index_t ));
        }
      } else {
        {
#line 11587
        opj_free((l_cstr_index->tile_index + it_tile)->tp_index);
#line 11588
        (l_cstr_index->tile_index + it_tile)->tp_index = (opj_tp_index_t *)((void *)0);
        }
      }
#line 11592
      (l_cstr_index->tile_index + it_tile)->nb_packet = (OPJ_UINT32 )0;
#line 11593
      (l_cstr_index->tile_index + it_tile)->packet_index = (opj_packet_info_t *)((void *)0);
#line 11528
      it_tile ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 11598
  return (l_cstr_index);
}
}
#line 11601 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k ) 
{ 
  OPJ_UINT32 it_tile ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  OPJ_UINT32 __cil_tmp5 ;

  {
  {
#line 11603
  it_tile = (OPJ_UINT32 )0;
#line 11605
  (p_j2k->cstr_index)->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 11606
  __cil_tmp3 = opj_calloc((size_t )(p_j2k->cstr_index)->nb_of_tiles, sizeof(opj_tile_index_t ));
#line 11606
  (p_j2k->cstr_index)->tile_index = (opj_tile_index_t *)__cil_tmp3;
  }
#line 11608
  if (! (p_j2k->cstr_index)->tile_index) {
#line 11609
    return (0);
  }
#line 11612
  it_tile = (OPJ_UINT32 )0;
  {
#line 11612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11612
    if (! (it_tile < (p_j2k->cstr_index)->nb_of_tiles)) {
#line 11612
      goto while_break;
    }
    {
#line 11613
    ((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum = (OPJ_UINT32 )100;
#line 11614
    ((p_j2k->cstr_index)->tile_index + it_tile)->marknum = (OPJ_UINT32 )0;
#line 11615
    __cil_tmp4 = opj_calloc((size_t )((p_j2k->cstr_index)->tile_index + it_tile)->maxmarknum,
                            sizeof(opj_marker_info_t ));
#line 11615
    ((p_j2k->cstr_index)->tile_index + it_tile)->marker = (opj_marker_info_t *)__cil_tmp4;
    }
#line 11618
    if (! ((p_j2k->cstr_index)->tile_index + it_tile)->marker) {
#line 11619
      return (0);
    }
#line 11612
    it_tile ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11623
  return (1);
}
}
#line 11626 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_are_all_used_components_decoded(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_BOOL decoded_all_used_components ;
  OPJ_UINT32 dec_compno ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 11630
  decoded_all_used_components = 1;
#line 11632
  if (p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode) {
#line 11633
    compno = (OPJ_UINT32 )0;
    {
#line 11633
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11633
      if (! (compno < p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11633
        goto while_break;
      }
#line 11635
      dec_compno = *(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode + compno);
#line 11637
      if (((p_j2k->m_output_image)->comps + dec_compno)->data == (void *)0) {
        {
#line 11638
        opj_event_msg(p_manager, 2, "Failed to decode component %d\n", dec_compno);
#line 11640
        decoded_all_used_components = 0;
        }
      }
#line 11634
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 11644
    compno = (OPJ_UINT32 )0;
    {
#line 11644
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11644
      if (! (compno < (p_j2k->m_output_image)->numcomps)) {
#line 11644
        goto while_break___0;
      }
#line 11645
      if (((p_j2k->m_output_image)->comps + compno)->data == (void *)0) {
        {
#line 11646
        opj_event_msg(p_manager, 2, "Failed to decode component %d\n", compno);
#line 11648
        decoded_all_used_components = 0;
        }
      }
#line 11644
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 11653
  if (decoded_all_used_components == 0) {
    {
#line 11654
    opj_event_msg(p_manager, 1, "Failed to decode all used components\n");
    }
#line 11655
    return (0);
  }
#line 11658
  return (1);
}
}
#line 11662 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_tiles(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                     opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 nr_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_OFF_T __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;

  {
#line 11666
  l_go_on = 1;
#line 11670
  nr_tiles = (OPJ_UINT32 )0;
#line 11674
  if (p_j2k->m_cp.tw == 1U) {
#line 11674
    if (p_j2k->m_cp.th == 1U) {
#line 11674
      if (p_j2k->m_cp.tx0 == 0U) {
#line 11674
        if (p_j2k->m_cp.ty0 == 0U) {
#line 11674
          if ((p_j2k->m_output_image)->x0 == 0U) {
#line 11674
            if ((p_j2k->m_output_image)->y0 == 0U) {
#line 11674
              if ((p_j2k->m_output_image)->x1 == p_j2k->m_cp.tdx) {
#line 11674
                if ((p_j2k->m_output_image)->y1 == p_j2k->m_cp.tdy) {
                  {
#line 11681
                  __cil_tmp13 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no,
                                                         (OPJ_UINT32 *)((void *)0),
                                                         & l_tile_x0, & l_tile_y0,
                                                         & l_tile_x1, & l_tile_y1,
                                                         & l_nb_comps, & l_go_on,
                                                         p_stream, p_manager);
                  }
#line 11681
                  if (! __cil_tmp13) {
#line 11690
                    return (0);
                  }
                  {
#line 11693
                  __cil_tmp14 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                                    (OPJ_UINT32 )0, p_stream, p_manager);
                  }
#line 11693
                  if (! __cil_tmp14) {
                    {
#line 11695
                    opj_event_msg(p_manager, 1, "Failed to decode tile 1/1\n");
                    }
#line 11696
                    return (0);
                  }
#line 11700
                  i = (OPJ_UINT32 )0;
                  {
#line 11700
                  while (1) {
                    while_continue: /* CIL Label */ ;
#line 11700
                    if (! (i < (p_j2k->m_output_image)->numcomps)) {
#line 11700
                      goto while_break;
                    }
                    {
#line 11701
                    opj_image_data_free(((p_j2k->m_output_image)->comps + i)->data);
#line 11702
                    ((p_j2k->m_output_image)->comps + i)->data = ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data;
#line 11704
                    ((p_j2k->m_output_image)->comps + i)->resno_decoded = (((p_j2k->m_tcd)->image)->comps + i)->resno_decoded;
#line 11706
                    ((((p_j2k->m_tcd)->tcd_image)->tiles)->comps + i)->data = (OPJ_INT32 *)((void *)0);
                    }
#line 11700
                    i ++;
                  }
                  while_break: /* CIL Label */ ;
                  }
#line 11709
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 11712
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 11712
    if (! 1) {
#line 11712
      goto while_break___0;
    }
#line 11713
    if ((p_j2k->m_cp.tcps + 0)->m_data != (void *)0) {
#line 11713
      if (p_j2k->m_cp.tw == 1U) {
#line 11713
        if (p_j2k->m_cp.th == 1U) {
#line 11715
          l_current_tile_no = (OPJ_UINT32 )0;
#line 11716
          p_j2k->m_current_tile_number = (OPJ_UINT32 )0;
#line 11717
          p_j2k->m_specific_param.m_decoder.m_state |= (unsigned int )128;
        } else {
#line 11713
          goto _L;
        }
      } else {
#line 11713
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 11719
      __cil_tmp16 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                             & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                             & l_tile_y1, & l_nb_comps, & l_go_on,
                                             p_stream, p_manager);
      }
#line 11719
      if (! __cil_tmp16) {
#line 11728
        return (0);
      }
#line 11731
      if (! l_go_on) {
#line 11732
        goto while_break___0;
      }
    }
    {
#line 11736
    __cil_tmp17 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 11736
    if (! __cil_tmp17) {
      {
#line 11738
      opj_event_msg(p_manager, 1, "Failed to decode tile %d/%d\n\265U", l_current_tile_no + 1U,
                    p_j2k->m_cp.th * p_j2k->m_cp.tw);
      }
#line 11740
      return (0);
    }
    {
#line 11743
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nU", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 11746
    __cil_tmp18 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 11746
    if (! __cil_tmp18) {
#line 11748
      return (0);
    }
#line 11751
    if (p_j2k->m_cp.tw == 1U) {
#line 11751
      if (p_j2k->m_cp.th == 1U) {
#line 11751
        if (! (! ((((p_j2k->m_output_image)->x0 == (p_j2k->m_private_image)->x0 && (p_j2k->m_output_image)->y0 == (p_j2k->m_private_image)->y0) && (p_j2k->m_output_image)->x1 == (p_j2k->m_private_image)->x1) && (p_j2k->m_output_image)->y1 == (p_j2k->m_private_image)->y1))) {
          {
          {
          {
#line 11758
          opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 11758
        opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 11758
      opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
      }
      }
      }
    }
    {
#line 11761
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
#line 11764
    __cil_tmp19 = opj_stream_get_number_byte_left(p_stream);
    }
#line 11764
    if (__cil_tmp19 == 0L) {
#line 11764
      if (p_j2k->m_specific_param.m_decoder.m_state == 64U) {
#line 11766
        goto while_break___0;
      }
    }
#line 11768
    nr_tiles ++;
#line 11768
    if (nr_tiles == p_j2k->m_cp.th * p_j2k->m_cp.tw) {
#line 11769
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 11773
  __cil_tmp20 = opj_j2k_are_all_used_components_decoded(p_j2k, p_manager);
  }
#line 11773
  if (! __cil_tmp20) {
#line 11774
    return (0);
  }
#line 11777
  return (1);
}
}
#line 11783 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 11790
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_tiles),
                                                p_manager);
  }
#line 11790
  if (! __cil_tmp3) {
#line 11792
    return (0);
  }
#line 11796
  return (1);
}
}
#line 11802 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_decode_one_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL l_go_on ;
  OPJ_UINT32 l_current_tile_no ;
  OPJ_UINT32 l_tile_no_to_dec ;
  OPJ_INT32 l_tile_x0 ;
  OPJ_INT32 l_tile_y0 ;
  OPJ_INT32 l_tile_x1 ;
  OPJ_INT32 l_tile_y1 ;
  OPJ_UINT32 l_nb_comps ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_UINT32 i ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 11806
  l_go_on = 1;
#line 11815
  if (! (p_j2k->cstr_index)->tile_index) {
    {
#line 11816
    __cil_tmp14 = opj_j2k_allocate_tile_element_cstr_index(p_j2k);
    }
#line 11816
    if (! __cil_tmp14) {
#line 11817
      return (0);
    }
  }
#line 11821
  l_tile_no_to_dec = (OPJ_UINT32 )p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
#line 11823
  if ((p_j2k->cstr_index)->tile_index) {
#line 11824
    if (((p_j2k->cstr_index)->tile_index)->tp_index) {
#line 11825
      if (! ((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->nb_tps) {
        {
#line 11828
        __cil_tmp15 = opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos + 2L,
                                           p_manager);
        }
#line 11828
        if (! __cil_tmp15) {
          {
#line 11830
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
          }
#line 11831
          return (0);
        }
      } else {
        {
#line 11834
        __cil_tmp16 = opj_stream_read_seek(p_stream, (((p_j2k->cstr_index)->tile_index + l_tile_no_to_dec)->tp_index + 0)->start_pos + 2L,
                                           p_manager);
        }
#line 11834
        if (! __cil_tmp16) {
          {
#line 11837
          opj_event_msg(p_manager, 1, "Problem with seek function\n");
          }
#line 11838
          return (0);
        }
      }
#line 11842
      if (p_j2k->m_specific_param.m_decoder.m_state == 256U) {
#line 11843
        p_j2k->m_specific_param.m_decoder.m_state = (OPJ_UINT32 )8;
      }
    }
  }
#line 11851
  l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
#line 11852
  i = (OPJ_UINT32 )0;
  {
#line 11852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11852
    if (! (i < l_nb_tiles)) {
#line 11852
      goto while_break;
    }
#line 11853
    (p_j2k->m_cp.tcps + i)->m_current_tile_part_number = - 1;
#line 11852
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 11856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 11856
    if (! 1) {
#line 11856
      goto while_break___0;
    }
    {
#line 11857
    __cil_tmp17 = opj_j2k_read_tile_header(p_j2k, & l_current_tile_no, (OPJ_UINT32 *)((void *)0),
                                           & l_tile_x0, & l_tile_y0, & l_tile_x1,
                                           & l_tile_y1, & l_nb_comps, & l_go_on, p_stream,
                                           p_manager);
    }
#line 11857
    if (! __cil_tmp17) {
#line 11866
      return (0);
    }
#line 11869
    if (! l_go_on) {
#line 11870
      goto while_break___0;
    }
    {
#line 11873
    __cil_tmp18 = opj_j2k_decode_tile(p_j2k, l_current_tile_no, (OPJ_BYTE *)((void *)0),
                                      (OPJ_UINT32 )0, p_stream, p_manager);
    }
#line 11873
    if (! __cil_tmp18) {
#line 11875
      return (0);
    }
    {
#line 11877
    opj_event_msg(p_manager, 4, "Tile %d/%d has been decoded.\nU", l_current_tile_no + 1U,
                  p_j2k->m_cp.th * p_j2k->m_cp.tw);
#line 11880
    __cil_tmp19 = opj_j2k_update_image_data(p_j2k->m_tcd, p_j2k->m_output_image);
    }
#line 11880
    if (! __cil_tmp19) {
#line 11882
      return (0);
    }
    {
#line 11884
    opj_j2k_tcp_data_destroy(p_j2k->m_cp.tcps + l_current_tile_no);
#line 11886
    opj_event_msg(p_manager, 4, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1U);
    }
#line 11889
    if (l_current_tile_no == l_tile_no_to_dec) {
      {
#line 11891
      __cil_tmp20 = opj_stream_read_seek(p_stream, (p_j2k->cstr_index)->main_head_end + 2L,
                                         p_manager);
      }
#line 11891
      if (! __cil_tmp20) {
        {
#line 11893
        opj_event_msg(p_manager, 1, "Problem with seek function\n");
        }
#line 11894
        return (0);
      }
#line 11896
      goto while_break___0;
    } else {
      {
#line 11898
      opj_event_msg(p_manager, 2, "Tile read, decoded and updated is not the desired one (%d vs %d).\n",
                    l_current_tile_no + 1U, l_tile_no_to_dec + 1U);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 11905
  __cil_tmp21 = opj_j2k_are_all_used_components_decoded(p_j2k, p_manager);
  }
#line 11905
  if (! __cil_tmp21) {
#line 11906
    return (0);
  }
#line 11909
  return (1);
}
}
#line 11915 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_decoding_tile(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 11922
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_decode_one_tile),
                                                p_manager);
  }
#line 11922
  if (! __cil_tmp3) {
#line 11924
    return (0);
  }
#line 11928
  return (1);
}
}
#line 11931 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_move_data_from_codec_to_output_image(opj_j2k_t *p_j2k , opj_image_t *p_image ) 
{ 
  OPJ_UINT32 compno ;
  opj_image_comp_t *newcomps ;
  void *__cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 src_compno ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 __cil_tmp10 ;

  {
#line 11937
  if (p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode > 0U) {
    {
#line 11938
    __cil_tmp5 = opj_malloc((unsigned long )p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode * sizeof(opj_image_comp_t ));
#line 11938
    newcomps = (opj_image_comp_t *)__cil_tmp5;
    }
#line 11942
    if (newcomps == (void *)0) {
      {
#line 11943
      opj_image_destroy(p_j2k->m_private_image);
#line 11944
      p_j2k->m_private_image = (opj_image_t *)((void *)0);
      }
#line 11945
      return (0);
    }
#line 11947
    compno = (OPJ_UINT32 )0;
    {
#line 11947
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11947
      if (! (compno < p_image->numcomps)) {
#line 11947
        goto while_break;
      }
      {
#line 11948
      opj_image_data_free((p_image->comps + compno)->data);
#line 11949
      (p_image->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11947
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 11951
    compno = (OPJ_UINT32 )0;
    {
#line 11951
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11951
      if (! (compno < p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode)) {
#line 11951
        goto while_break___0;
      }
      {
#line 11953
      src_compno = *(p_j2k->m_specific_param.m_decoder.m_comps_indices_to_decode + compno);
#line 11955
      memcpy(newcomps + compno, (p_j2k->m_output_image)->comps + src_compno, sizeof(opj_image_comp_t ));
#line 11958
      (newcomps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + src_compno)->resno_decoded;
#line 11960
      (newcomps + compno)->data = ((p_j2k->m_output_image)->comps + src_compno)->data;
#line 11961
      ((p_j2k->m_output_image)->comps + src_compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11952
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11963
    compno = (OPJ_UINT32 )0;
    {
#line 11963
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 11963
      if (! (compno < p_image->numcomps)) {
#line 11963
        goto while_break___1;
      }
      {
#line 11965
      opj_image_data_free(((p_j2k->m_output_image)->comps + compno)->data);
#line 11966
      ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11963
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 11968
    p_image->numcomps = p_j2k->m_specific_param.m_decoder.m_numcomps_to_decode;
#line 11969
    opj_free(p_image->comps);
#line 11970
    p_image->comps = newcomps;
    }
  } else {
#line 11972
    compno = (OPJ_UINT32 )0;
    {
#line 11972
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 11972
      if (! (compno < p_image->numcomps)) {
#line 11972
        goto while_break___2;
      }
      {
#line 11973
      (p_image->comps + compno)->resno_decoded = ((p_j2k->m_output_image)->comps + compno)->resno_decoded;
#line 11975
      opj_image_data_free((p_image->comps + compno)->data);
#line 11976
      (p_image->comps + compno)->data = ((p_j2k->m_output_image)->comps + compno)->data;
#line 11985
      ((p_j2k->m_output_image)->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 11972
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 11988
  return (1);
}
}
#line 11991 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_decode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_BOOL __cil_tmp6 ;
  opj_image_t *__cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;

  {
#line 11996
  if (! p_image) {
#line 11997
    return (0);
  }
#line 12004
  if (p_j2k->m_private_image != (void *)0) {
#line 12004
    if (p_j2k->m_cp.m_specific_param.m_dec.m_reduce > 0U) {
#line 12004
      if ((p_j2k->m_private_image)->numcomps > 0U) {
#line 12004
        if (((p_j2k->m_private_image)->comps + 0)->factor == p_j2k->m_cp.m_specific_param.m_dec.m_reduce) {
#line 12004
          if (p_image->numcomps > 0U) {
#line 12004
            if ((p_image->comps + 0)->factor == 0U) {
#line 12004
              if ((p_image->comps + 0)->data == (void *)0) {
#line 12017
                it_comp = (OPJ_UINT32 )0;
                {
#line 12017
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 12017
                  if (! (it_comp < p_image->numcomps)) {
#line 12017
                    goto while_break;
                  }
#line 12018
                  (p_image->comps + it_comp)->factor = p_j2k->m_cp.m_specific_param.m_dec.m_reduce;
#line 12017
                  it_comp ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 12020
                __cil_tmp6 = opj_j2k_update_image_dimensions(p_image, p_manager);
                }
#line 12020
                if (! __cil_tmp6) {
#line 12021
                  return (0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 12025
  if (p_j2k->m_output_image == (void *)0) {
    {
#line 12026
    p_j2k->m_output_image = opj_image_create0();
    }
#line 12027
    if (! p_j2k->m_output_image) {
#line 12028
      return (0);
    }
  }
  {
#line 12031
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 12034
  __cil_tmp8 = opj_j2k_setup_decoding(p_j2k, p_manager);
  }
#line 12034
  if (! __cil_tmp8) {
#line 12035
    return (0);
  }
  {
#line 12039
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12039
  if (! __cil_tmp9) {
    {
#line 12040
    opj_image_destroy(p_j2k->m_private_image);
#line 12041
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 12042
    return (0);
  }
  {
#line 12046
  __cil_tmp10 = opj_j2k_move_data_from_codec_to_output_image(p_j2k, p_image);
  }
#line 12046
  return (__cil_tmp10);
}
}
#line 12049 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_get_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_image_t *p_image ,
                          opj_event_mgr_t *p_manager , OPJ_UINT32 tile_index ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_tile_x ;
  OPJ_UINT32 l_tile_y ;
  opj_image_comp_t *l_img_comp ;
  OPJ_INT32 l_comp_x1 ;
  OPJ_INT32 l_comp_y1 ;
  OPJ_INT32 __cil_tmp12 ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_INT32 __cil_tmp17 ;
  OPJ_INT32 __cil_tmp18 ;
  OPJ_INT32 __cil_tmp19 ;
  opj_image_comp_t *__cil_tmp20 ;
  opj_image_t *__cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;
  OPJ_BOOL __cil_tmp23 ;
  OPJ_BOOL __cil_tmp24 ;

  {
#line 12059
  if (! p_image) {
    {
#line 12060
    opj_event_msg(p_manager, 1, "We need an image previously created.\n");
    }
#line 12061
    return (0);
  }
#line 12064
  if (p_image->numcomps < (p_j2k->m_private_image)->numcomps) {
    {
#line 12065
    opj_event_msg(p_manager, 1, "Image has less components than codestream.\n");
    }
#line 12067
    return (0);
  }
#line 12070
  if (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) {
    {
#line 12071
    opj_event_msg(p_manager, 1, "Tile index provided by the user is incorrect %d (max = %d) \n",
                  tile_index, p_j2k->m_cp.tw * p_j2k->m_cp.th - 1U);
    }
#line 12074
    return (0);
  }
#line 12078
  l_tile_x = tile_index % p_j2k->m_cp.tw;
#line 12079
  l_tile_y = tile_index / p_j2k->m_cp.tw;
#line 12081
  p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 12082
  if (p_image->x0 < (p_j2k->m_private_image)->x0) {
#line 12083
    p_image->x0 = (p_j2k->m_private_image)->x0;
  }
#line 12085
  p_image->x1 = (l_tile_x + 1U) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
#line 12086
  if (p_image->x1 > (p_j2k->m_private_image)->x1) {
#line 12087
    p_image->x1 = (p_j2k->m_private_image)->x1;
  }
#line 12090
  p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 12091
  if (p_image->y0 < (p_j2k->m_private_image)->y0) {
#line 12092
    p_image->y0 = (p_j2k->m_private_image)->y0;
  }
#line 12094
  p_image->y1 = (l_tile_y + 1U) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
#line 12095
  if (p_image->y1 > (p_j2k->m_private_image)->y1) {
#line 12096
    p_image->y1 = (p_j2k->m_private_image)->y1;
  }
#line 12099
  l_img_comp = p_image->comps;
#line 12100
  compno = (OPJ_UINT32 )0;
  {
#line 12100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12100
    if (! (compno < (p_j2k->m_private_image)->numcomps)) {
#line 12100
      goto while_break;
    }
    {
#line 12103
    l_img_comp->factor = ((p_j2k->m_private_image)->comps + compno)->factor;
#line 12105
    __cil_tmp12 = opj_int_ceildiv((OPJ_INT32 )p_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 12105
    l_img_comp->x0 = (OPJ_UINT32 )__cil_tmp12;
#line 12107
    __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )p_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 12107
    l_img_comp->y0 = (OPJ_UINT32 )__cil_tmp13;
#line 12109
    l_comp_x1 = opj_int_ceildiv((OPJ_INT32 )p_image->x1, (OPJ_INT32 )l_img_comp->dx);
#line 12110
    l_comp_y1 = opj_int_ceildiv((OPJ_INT32 )p_image->y1, (OPJ_INT32 )l_img_comp->dy);
#line 12112
    __cil_tmp17 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->x0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 12112
    __cil_tmp16 = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32 )l_img_comp->factor);
#line 12112
    l_img_comp->w = (OPJ_UINT32 )(__cil_tmp16 - __cil_tmp17);
#line 12115
    __cil_tmp19 = opj_int_ceildivpow2((OPJ_INT32 )l_img_comp->y0, (OPJ_INT32 )l_img_comp->factor);
    }
    {
#line 12115
    __cil_tmp18 = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32 )l_img_comp->factor);
#line 12115
    l_img_comp->h = (OPJ_UINT32 )(__cil_tmp18 - __cil_tmp19);
#line 12119
    l_img_comp ++;
    }
#line 12100
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12122
  if (p_image->numcomps > (p_j2k->m_private_image)->numcomps) {
#line 12126
    compno = (p_j2k->m_private_image)->numcomps;
    {
#line 12126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12126
      if (! (compno < p_image->numcomps)) {
#line 12126
        goto while_break___0;
      }
      {
#line 12128
      opj_image_data_free((p_image->comps + compno)->data);
#line 12129
      (p_image->comps + compno)->data = (OPJ_INT32 *)((void *)0);
      }
#line 12127
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 12131
    p_image->numcomps = (p_j2k->m_private_image)->numcomps;
  }
#line 12135
  if (p_j2k->m_output_image) {
    {
#line 12136
    opj_image_destroy(p_j2k->m_output_image);
    }
  }
  {
#line 12140
  p_j2k->m_output_image = opj_image_create0();
  }
#line 12141
  if (! p_j2k->m_output_image) {
#line 12142
    return (0);
  }
  {
#line 12144
  opj_copy_image_header(p_image, p_j2k->m_output_image);
#line 12146
  p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32 )tile_index;
#line 12149
  __cil_tmp22 = opj_j2k_setup_decoding_tile(p_j2k, p_manager);
  }
#line 12149
  if (! __cil_tmp22) {
#line 12150
    return (0);
  }
  {
#line 12154
  __cil_tmp23 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12154
  if (! __cil_tmp23) {
    {
#line 12155
    opj_image_destroy(p_j2k->m_private_image);
#line 12156
    p_j2k->m_private_image = (opj_image_t *)((void *)0);
    }
#line 12157
    return (0);
  }
  {
#line 12161
  __cil_tmp24 = opj_j2k_move_data_from_codec_to_output_image(p_j2k, p_image);
  }
#line 12161
  return (__cil_tmp24);
}
}
#line 12164 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k , OPJ_UINT32 res_factor ,
                                               opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 max_res ;
  OPJ_UINT32 __cil_tmp6 ;

  {
#line 12170
  p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
#line 12172
  if (p_j2k->m_private_image) {
#line 12173
    if ((p_j2k->m_private_image)->comps) {
#line 12174
      if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
#line 12175
        if ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps) {
#line 12176
          it_comp = (OPJ_UINT32 )0;
          {
#line 12176
          while (1) {
            while_continue: /* CIL Label */ ;
#line 12176
            if (! (it_comp < (p_j2k->m_private_image)->numcomps)) {
#line 12176
              goto while_break;
            }
#line 12177
            max_res = ((p_j2k->m_specific_param.m_decoder.m_default_tcp)->tccps + it_comp)->numresolutions;
#line 12179
            if (res_factor >= max_res) {
              {
#line 12180
              opj_event_msg(p_manager, 1, "Resolution factor is greater than the maximum resolution in the component.\n");
              }
#line 12182
              return (0);
            }
#line 12184
            ((p_j2k->m_private_image)->comps + it_comp)->factor = res_factor;
#line 12176
            it_comp ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 12186
          return (1);
        }
      }
    }
  }
#line 12192
  return (0);
}
}
#line 12197 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encoder_set_extra_options(opj_j2k_t *p_j2k , char const   * const  *p_options ,
                                           opj_event_mgr_t *p_manager ) 
{ 
  char const   * const  *p_option_iter ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  OPJ_UINT32 tileno ;
  opj_cp_t *cp ;
  int numgbits ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  OPJ_UINT32 i ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;

  {
#line 12204
  if (p_options == (void *)0) {
#line 12205
    return (1);
  }
#line 12208
  p_option_iter = p_options;
  {
#line 12208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12208
    if (! (*p_option_iter != (void *)0)) {
#line 12208
      goto while_break;
    }
    {
#line 12209
    __cil_tmp5 = strncmp(*p_option_iter, "PLT=", (unsigned long )4);
    }
#line 12209
    if (__cil_tmp5 == 0) {
      {
#line 12210
      __cil_tmp6 = strcmp(*p_option_iter, "PLT=YES");
      }
#line 12210
      if (__cil_tmp6 == 0) {
#line 12211
        p_j2k->m_specific_param.m_encoder.m_PLT = 1;
      } else {
        {
#line 12212
        __cil_tmp7 = strcmp(*p_option_iter, "PLT=NO");
        }
#line 12212
        if (__cil_tmp7 == 0) {
#line 12213
          p_j2k->m_specific_param.m_encoder.m_PLT = 0;
        } else {
          {
#line 12215
          opj_event_msg(p_manager, 1, "Invalid value for option: %s.\n", *p_option_iter);
          }
#line 12217
          return (0);
        }
      }
    } else {
      {
#line 12219
      __cil_tmp8 = strncmp(*p_option_iter, "TLM=", (unsigned long )4);
      }
#line 12219
      if (__cil_tmp8 == 0) {
        {
#line 12220
        __cil_tmp9 = strcmp(*p_option_iter, "TLM=YES");
        }
#line 12220
        if (__cil_tmp9 == 0) {
#line 12221
          p_j2k->m_specific_param.m_encoder.m_TLM = 1;
        } else {
          {
#line 12222
          __cil_tmp10 = strcmp(*p_option_iter, "TLM=NO");
          }
#line 12222
          if (__cil_tmp10 == 0) {
#line 12223
            p_j2k->m_specific_param.m_encoder.m_TLM = 0;
          } else {
            {
#line 12225
            opj_event_msg(p_manager, 1, "Invalid value for option: %s.\n", *p_option_iter);
            }
#line 12227
            return (0);
          }
        }
      } else {
        {
#line 12229
        __cil_tmp11 = strlen("GUARD_BITS=");
#line 12229
        __cil_tmp12 = strncmp(*p_option_iter, "GUARD_BITS=", __cil_tmp11);
        }
#line 12229
        if (__cil_tmp12 == 0) {
          {
#line 12231
          cp = & p_j2k->m_cp;
#line 12231
          cp = cp;
#line 12233
          __cil_tmp16 = strlen("GUARD_BITS=");
#line 12233
          __cil_tmp17 = atoi(*p_option_iter + __cil_tmp16);
#line 12233
          numgbits = __cil_tmp17;
          }
#line 12234
          if (numgbits < 0) {
            {
            {
#line 12235
            opj_event_msg(p_manager, 1, "Invalid value for option: %s. Should be in [0,7]\n",
                          *p_option_iter);
            }
            }
#line 12237
            return (0);
          } else
#line 12234
          if (numgbits > 7) {
            {
            {
#line 12235
            opj_event_msg(p_manager, 1, "Invalid value for option: %s. Should be in [0,7]\n",
                          *p_option_iter);
            }
            }
#line 12237
            return (0);
          }
#line 12240
          tileno = (OPJ_UINT32 )0;
          {
#line 12240
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 12240
            if (! (tileno < cp->tw * cp->th)) {
#line 12240
              goto while_break___0;
            }
#line 12242
            tcp = cp->tcps + tileno;
#line 12243
            i = (OPJ_UINT32 )0;
            {
#line 12243
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 12243
              if (! (i < p_j2k->m_specific_param.m_encoder.m_nb_comps)) {
#line 12243
                goto while_break___1;
              }
#line 12244
              tccp = tcp->tccps + i;
#line 12245
              tccp->numgbits = (OPJ_UINT32 )numgbits;
#line 12243
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 12240
            tileno ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 12249
          opj_event_msg(p_manager, 1, "Invalid option: %s.\n", *p_option_iter);
          }
#line 12251
          return (0);
        }
      }
    }
#line 12208
    p_option_iter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12255
  return (1);
}
}
#line 12260 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_encode(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 l_nb_tiles ;
  OPJ_SIZE_T l_max_tile_size ;
  OPJ_SIZE_T l_current_tile_size ;
  OPJ_BYTE *l_current_data ;
  OPJ_BOOL l_reuse_data ;
  opj_tcd_t *p_tcd ;
  opj_image_comp_t *l_img_comp ;
  OPJ_BOOL __cil_tmp13 ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp___0 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_SIZE_T __cil_tmp17 ;
  OPJ_BYTE *l_new_current_data ;
  void *__cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;

  {
#line 12266
  l_max_tile_size = (OPJ_SIZE_T )0;
#line 12267
  l_current_data = (OPJ_BYTE *)0;
#line 12268
  l_reuse_data = 0;
#line 12269
  p_tcd = (opj_tcd_t *)0;
#line 12276
  p_tcd = p_j2k->m_tcd;
#line 12278
  l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
#line 12279
  if (l_nb_tiles == 1U) {
#line 12280
    l_reuse_data = 1;
#line 12282
    j = (OPJ_UINT32 )0;
    {
#line 12282
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12282
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 12282
        goto while_break;
      }
#line 12283
      l_img_comp = (p_tcd->image)->comps + j;
#line 12284
      if (((size_t )l_img_comp->data & 15UL) != 0UL) {
#line 12286
        l_reuse_data = 0;
      }
#line 12282
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 12291
  i = (OPJ_UINT32 )0;
  {
#line 12291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 12291
    if (! (i < l_nb_tiles)) {
#line 12291
      goto while_break___0;
    }
    {
#line 12292
    __cil_tmp13 = opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager);
    }
#line 12292
    if (! __cil_tmp13) {
#line 12293
      if (l_current_data) {
        {
#line 12294
        opj_free(l_current_data);
        }
      }
#line 12296
      return (0);
    }
#line 12301
    j = (OPJ_UINT32 )0;
    {
#line 12301
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12301
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 12301
        goto while_break___1;
      }
#line 12302
      l_tilec = ((p_tcd->tcd_image)->tiles)->comps + j;
#line 12303
      if (l_reuse_data) {
#line 12304
        l_img_comp___0 = (p_tcd->image)->comps + j;
#line 12305
        l_tilec->data = l_img_comp___0->data;
#line 12306
        l_tilec->ownsData = 0;
      } else {
        {
#line 12308
        __cil_tmp16 = opj_alloc_tile_component_data(l_tilec);
        }
#line 12308
        if (! __cil_tmp16) {
          {
#line 12309
          opj_event_msg(p_manager, 1, "Error allocating tile component data.");
          }
#line 12310
          if (l_current_data) {
            {
#line 12311
            opj_free(l_current_data);
            }
          }
#line 12313
          return (0);
        }
      }
#line 12301
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 12317
    l_current_tile_size = opj_tcd_get_encoder_input_buffer_size(p_j2k->m_tcd);
    }
#line 12318
    if (! l_reuse_data) {
#line 12319
      if (l_current_tile_size > l_max_tile_size) {
        {
#line 12320
        __cil_tmp19 = opj_realloc(l_current_data, l_current_tile_size);
#line 12320
        l_new_current_data = (OPJ_BYTE *)__cil_tmp19;
        }
#line 12322
        if (! l_new_current_data) {
#line 12323
          if (l_current_data) {
            {
#line 12324
            opj_free(l_current_data);
            }
          }
          {
#line 12326
          opj_event_msg(p_manager, 1, "Not enough memory to encode all tiles\n");
          }
#line 12327
          return (0);
        }
#line 12329
        l_current_data = l_new_current_data;
#line 12330
        l_max_tile_size = l_current_tile_size;
      }
#line 12332
      if (l_current_data == (void *)0) {
#line 12336
        return (0);
      }
      {
#line 12342
      opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);
#line 12345
      __cil_tmp20 = opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data, l_current_tile_size);
      }
#line 12345
      if (! __cil_tmp20) {
        {
#line 12347
        opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
#line 12349
        opj_free(l_current_data);
        }
#line 12350
        return (0);
      }
    }
    {
#line 12354
    __cil_tmp21 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 12354
    if (! __cil_tmp21) {
#line 12355
      if (l_current_data) {
        {
#line 12356
        opj_free(l_current_data);
        }
      }
#line 12358
      return (0);
    }
#line 12291
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 12362
  if (l_current_data) {
    {
#line 12363
    opj_free(l_current_data);
    }
  }
#line 12365
  return (1);
}
}
#line 12368 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_end_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                              opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 12373
  __cil_tmp4 = opj_j2k_setup_end_compress(p_j2k, p_manager);
  }
#line 12373
  if (! __cil_tmp4) {
#line 12374
    return (0);
  }
  {
#line 12377
  __cil_tmp5 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12377
  if (! __cil_tmp5) {
#line 12378
    return (0);
  }
#line 12381
  return (1);
}
}
#line 12384 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                opj_image_t *p_image , opj_event_mgr_t *p_manager ) 
{ 
  opj_image_t *__cil_tmp5 ;
  OPJ_UINT32 it_comp ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;

  {
  {
#line 12394
  p_j2k->m_private_image = opj_image_create0();
  }
#line 12395
  if (! p_j2k->m_private_image) {
    {
#line 12396
    opj_event_msg(p_manager, 1, "Failed to allocate image header.\220");
    }
#line 12397
    return (0);
  }
  {
#line 12399
  opj_copy_image_header(p_image, p_j2k->m_private_image);
  }
#line 12402
  if (p_image->comps) {
#line 12404
    it_comp = (OPJ_UINT32 )0;
    {
#line 12404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12404
      if (! (it_comp < p_image->numcomps)) {
#line 12404
        goto while_break;
      }
#line 12405
      if ((p_image->comps + it_comp)->data) {
#line 12406
        ((p_j2k->m_private_image)->comps + it_comp)->data = (p_image->comps + it_comp)->data;
#line 12407
        (p_image->comps + it_comp)->data = (OPJ_INT32 *)((void *)0);
      }
#line 12404
      it_comp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 12414
  __cil_tmp8 = opj_j2k_setup_encoding_validation(p_j2k, p_manager);
  }
#line 12414
  if (! __cil_tmp8) {
#line 12415
    return (0);
  }
  {
#line 12419
  __cil_tmp9 = opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream, p_manager);
  }
#line 12419
  if (! __cil_tmp9) {
#line 12420
    return (0);
  }
  {
#line 12424
  __cil_tmp10 = opj_j2k_setup_header_writing(p_j2k, p_manager);
  }
#line 12424
  if (! __cil_tmp10) {
#line 12425
    return (0);
  }
  {
#line 12429
  __cil_tmp11 = opj_j2k_exec(p_j2k, p_j2k->m_procedure_list, p_stream, p_manager);
  }
#line 12429
  if (! __cil_tmp11) {
#line 12430
    return (0);
  }
#line 12433
  return (1);
}
}
#line 12436 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_pre_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index ,
                                       opj_stream_private_t *p_stream , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp5 ;

  {
#line 12442
  if (p_tile_index != p_j2k->m_current_tile_number) {
    {
#line 12443
    opj_event_msg(p_manager, 1, "The given tile index does not match.");
    }
#line 12444
    return (0);
  }
  {
#line 12447
  opj_event_msg(p_manager, 4, "tile number %d / %d\n", p_j2k->m_current_tile_number + 1U,
                p_j2k->m_cp.tw * p_j2k->m_cp.th);
#line 12450
  p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = (OPJ_UINT32 )0;
#line 12451
  (p_j2k->m_tcd)->cur_totnum_tp = (p_j2k->m_cp.tcps + p_tile_index)->m_nb_tile_parts;
#line 12452
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12455
  __cil_tmp5 = opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number,
                                        p_manager);
  }
#line 12455
  if (! __cil_tmp5) {
#line 12457
    return (0);
  }
#line 12460
  return (1);
}
}
#line 12463 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_get_tile_dimensions(opj_image_t *l_image , opj_tcd_tilecomp_t *l_tilec ,
                                    opj_image_comp_t *l_img_comp , OPJ_UINT32 *l_size_comp ,
                                    OPJ_UINT32 *l_width , OPJ_UINT32 *l_height , OPJ_UINT32 *l_offset_x ,
                                    OPJ_UINT32 *l_offset_y , OPJ_UINT32 *l_image_width ,
                                    OPJ_UINT32 *l_stride , OPJ_UINT32 *l_tile_offset ) 
{ 
  OPJ_UINT32 l_remaining ;
  OPJ_INT32 __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;

  {
#line 12476
  *l_size_comp = l_img_comp->prec >> 3;
#line 12477
  l_remaining = l_img_comp->prec & 7U;
#line 12478
  if (l_remaining) {
#line 12479
    *l_size_comp += (unsigned int )1;
  }
#line 12482
  if (*l_size_comp == 3U) {
#line 12483
    *l_size_comp = (OPJ_UINT32 )4;
  }
  {
#line 12486
  *l_width = (OPJ_UINT32 )(l_tilec->x1 - l_tilec->x0);
#line 12487
  *l_height = (OPJ_UINT32 )(l_tilec->y1 - l_tilec->y0);
#line 12488
  __cil_tmp13 = opj_int_ceildiv((OPJ_INT32 )l_image->x0, (OPJ_INT32 )l_img_comp->dx);
#line 12488
  *l_offset_x = (OPJ_UINT32 )__cil_tmp13;
#line 12490
  __cil_tmp14 = opj_int_ceildiv((OPJ_INT32 )l_image->y0, (OPJ_INT32 )l_img_comp->dy);
#line 12490
  *l_offset_y = (OPJ_UINT32 )__cil_tmp14;
#line 12492
  __cil_tmp15 = opj_int_ceildiv((OPJ_INT32 )l_image->x1 - (OPJ_INT32 )l_image->x0,
                                (OPJ_INT32 )l_img_comp->dx);
#line 12492
  *l_image_width = (OPJ_UINT32 )__cil_tmp15;
#line 12494
  *l_stride = *l_image_width - *l_width;
#line 12495
  *l_tile_offset = ((OPJ_UINT32 )l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32 )l_tilec->y0 - *l_offset_y) * *l_image_width;
  }
  return;
}
}
#line 12499 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static void opj_j2k_get_tile_data(opj_tcd_t *p_tcd , OPJ_BYTE *p_data ) 
{ 
  OPJ_UINT32 i ;
  OPJ_UINT32 j ;
  OPJ_UINT32 k ;
  opj_image_t *l_image ;
  OPJ_INT32 *l_src_ptr ;
  opj_tcd_tilecomp_t *l_tilec ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 l_size_comp ;
  OPJ_UINT32 l_width ;
  OPJ_UINT32 l_height ;
  OPJ_UINT32 l_offset_x ;
  OPJ_UINT32 l_offset_y ;
  OPJ_UINT32 l_image_width ;
  OPJ_UINT32 l_stride ;
  OPJ_UINT32 l_tile_offset ;
  OPJ_CHAR *l_dest_ptr ;
  OPJ_INT16 *l_dest_ptr___0 ;
  OPJ_INT16 *__cil_tmp20 ;
  OPJ_INT32 *__cil_tmp21 ;
  OPJ_INT16 *__cil_tmp22 ;
  OPJ_INT32 *__cil_tmp23 ;
  OPJ_INT32 *l_dest_ptr___1 ;
  OPJ_INT32 *__cil_tmp25 ;
  OPJ_INT32 *__cil_tmp26 ;

  {
#line 12501
  k = (OPJ_UINT32 )0;
#line 12503
  i = (OPJ_UINT32 )0;
  {
#line 12503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12503
    if (! (i < (p_tcd->image)->numcomps)) {
#line 12503
      goto while_break;
    }
    {
#line 12504
    l_image = p_tcd->image;
#line 12506
    l_tilec = ((p_tcd->tcd_image)->tiles)->comps + i;
#line 12507
    l_img_comp = l_image->comps + i;
#line 12511
    opj_get_tile_dimensions(l_image, l_tilec, l_img_comp, & l_size_comp, & l_width,
                            & l_height, & l_offset_x, & l_offset_y, & l_image_width,
                            & l_stride, & l_tile_offset);
#line 12523
    l_src_ptr = l_img_comp->data + l_tile_offset;
    }
    {
#line 12526
    if (l_size_comp == (OPJ_UINT32 )1) {
#line 12526
      goto case_1;
    }
#line 12551
    if (l_size_comp == (OPJ_UINT32 )2) {
#line 12551
      goto case_2;
    }
#line 12572
    if (l_size_comp == (OPJ_UINT32 )4) {
#line 12572
      goto case_4;
    }
#line 12525
    goto switch_break;
    case_1: /* CIL Label */ 
#line 12527
    l_dest_ptr = (OPJ_CHAR *)p_data;
#line 12528
    if (l_img_comp->sgnd) {
#line 12529
      j = (OPJ_UINT32 )0;
      {
#line 12529
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 12529
        if (! (j < l_height)) {
#line 12529
          goto while_break___0;
        }
#line 12530
        k = (OPJ_UINT32 )0;
        {
#line 12530
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 12530
          if (! (k < l_width)) {
#line 12530
            goto while_break___1;
          }
#line 12531
          *l_dest_ptr = (OPJ_CHAR )*l_src_ptr;
#line 12532
          l_dest_ptr ++;
#line 12533
          l_src_ptr ++;
#line 12530
          k ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 12535
        l_src_ptr += l_stride;
#line 12529
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 12538
      j = (OPJ_UINT32 )0;
      {
#line 12538
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 12538
        if (! (j < l_height)) {
#line 12538
          goto while_break___2;
        }
#line 12539
        k = (OPJ_UINT32 )0;
        {
#line 12539
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 12539
          if (! (k < l_width)) {
#line 12539
            goto while_break___3;
          }
#line 12540
          *l_dest_ptr = (OPJ_CHAR )(*l_src_ptr & 255);
#line 12541
          l_dest_ptr ++;
#line 12542
          l_src_ptr ++;
#line 12539
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 12544
        l_src_ptr += l_stride;
#line 12538
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 12548
    p_data = (OPJ_BYTE *)l_dest_ptr;
#line 12550
    goto switch_break;
    case_2: /* CIL Label */ 
#line 12552
    l_dest_ptr___0 = (OPJ_INT16 *)p_data;
#line 12553
    if (l_img_comp->sgnd) {
#line 12554
      j = (OPJ_UINT32 )0;
      {
#line 12554
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 12554
        if (! (j < l_height)) {
#line 12554
          goto while_break___4;
        }
#line 12555
        k = (OPJ_UINT32 )0;
        {
#line 12555
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 12555
          if (! (k < l_width)) {
#line 12555
            goto while_break___5;
          }
#line 12556
          __cil_tmp21 = l_src_ptr;
#line 12556
          l_src_ptr ++;
#line 12556
          __cil_tmp20 = l_dest_ptr___0;
#line 12556
          l_dest_ptr___0 ++;
#line 12556
          *__cil_tmp20 = (OPJ_INT16 )*__cil_tmp21;
#line 12555
          k ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 12558
        l_src_ptr += l_stride;
#line 12554
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 12561
      j = (OPJ_UINT32 )0;
      {
#line 12561
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 12561
        if (! (j < l_height)) {
#line 12561
          goto while_break___6;
        }
#line 12562
        k = (OPJ_UINT32 )0;
        {
#line 12562
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 12562
          if (! (k < l_width)) {
#line 12562
            goto while_break___7;
          }
#line 12563
          __cil_tmp23 = l_src_ptr;
#line 12563
          l_src_ptr ++;
#line 12563
          __cil_tmp22 = l_dest_ptr___0;
#line 12563
          l_dest_ptr___0 ++;
#line 12563
          *__cil_tmp22 = (OPJ_INT16 )(*__cil_tmp23 & 65535);
#line 12562
          k ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 12565
        l_src_ptr += l_stride;
#line 12561
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 12569
    p_data = (OPJ_BYTE *)l_dest_ptr___0;
#line 12571
    goto switch_break;
    case_4: /* CIL Label */ 
#line 12573
    l_dest_ptr___1 = (OPJ_INT32 *)p_data;
#line 12574
    j = (OPJ_UINT32 )0;
    {
#line 12574
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 12574
      if (! (j < l_height)) {
#line 12574
        goto while_break___8;
      }
#line 12575
      k = (OPJ_UINT32 )0;
      {
#line 12575
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 12575
        if (! (k < l_width)) {
#line 12575
          goto while_break___9;
        }
#line 12576
        __cil_tmp26 = l_src_ptr;
#line 12576
        l_src_ptr ++;
#line 12576
        __cil_tmp25 = l_dest_ptr___1;
#line 12576
        l_dest_ptr___1 ++;
#line 12576
        *__cil_tmp25 = *__cil_tmp26;
#line 12575
        k ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 12578
      l_src_ptr += l_stride;
#line 12574
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 12581
    p_data = (OPJ_BYTE *)l_dest_ptr___1;
#line 12583
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 12503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 12588 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                        opj_event_mgr_t *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_BYTE *l_current_data ;
  OPJ_UINT32 l_tile_size ;
  OPJ_UINT32 l_available_data ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_SIZE_T __cil_tmp10 ;

  {
  {
#line 12593
  l_current_data = (OPJ_BYTE *)0;
#line 12594
  l_tile_size = (OPJ_UINT32 )0;
#line 12600
  l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
#line 12601
  l_available_data = l_tile_size;
#line 12602
  l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
#line 12604
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12605
  __cil_tmp8 = opj_j2k_write_first_tile_part(p_j2k, l_current_data, & l_nb_bytes_written,
                                             l_available_data, p_stream, p_manager);
  }
#line 12605
  if (! __cil_tmp8) {
#line 12607
    return (0);
  }
  {
#line 12609
  l_current_data += l_nb_bytes_written;
#line 12610
  l_available_data -= l_nb_bytes_written;
#line 12612
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12613
  __cil_tmp9 = opj_j2k_write_all_tile_parts(p_j2k, l_current_data, & l_nb_bytes_written,
                                            l_available_data, p_stream, p_manager);
  }
#line 12613
  if (! __cil_tmp9) {
#line 12615
    return (0);
  }
  {
#line 12618
  l_available_data -= l_nb_bytes_written;
#line 12619
  l_nb_bytes_written = l_tile_size - l_available_data;
#line 12621
  __cil_tmp10 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
                                      (OPJ_SIZE_T )l_nb_bytes_written, p_manager);
  }
#line 12621
  if (__cil_tmp10 != (unsigned long )l_nb_bytes_written) {
#line 12624
    return (0);
  }
#line 12627
  (p_j2k->m_current_tile_number) ++;
#line 12629
  return (1);
}
}
#line 12632 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_end_compress(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;

  {
  {
#line 12640
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_eoc),
                                                p_manager);
  }
#line 12640
  if (! __cil_tmp3) {
#line 12642
    return (0);
  }
#line 12645
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12646
    __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_updated_tlm),
                                                  p_manager);
    }
#line 12646
    if (! __cil_tmp4) {
#line 12648
      return (0);
    }
  }
  {
#line 12652
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_epc),
                                                p_manager);
  }
#line 12652
  if (! __cil_tmp5) {
#line 12654
    return (0);
  }
  {
#line 12656
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_end_encoding),
                                                p_manager);
  }
#line 12656
  if (! __cil_tmp6) {
#line 12658
    return (0);
  }
  {
#line 12660
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_destroy_header_memory),
                                                p_manager);
  }
#line 12660
  if (! __cil_tmp7) {
#line 12662
    return (0);
  }
#line 12664
  return (1);
}
}
#line 12667 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_encoding_validation(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 12674
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_build_encoder),
                                                p_manager);
  }
#line 12674
  if (! __cil_tmp3) {
#line 12676
    return (0);
  }
  {
#line 12678
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_encoding_validation),
                                                p_manager);
  }
#line 12678
  if (! __cil_tmp4) {
#line 12680
    return (0);
  }
  {
#line 12684
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure )(& opj_j2k_mct_validation),
                                                p_manager);
  }
#line 12684
  if (! __cil_tmp5) {
#line 12686
    return (0);
  }
#line 12689
  return (1);
}
}
#line 12692 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_setup_header_writing(opj_j2k_t *p_j2k , opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;
  OPJ_BOOL __cil_tmp7 ;
  OPJ_BOOL __cil_tmp8 ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_BOOL __cil_tmp14 ;
  OPJ_BOOL __cil_tmp15 ;
  OPJ_BOOL __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;

  {
  {
#line 12699
  __cil_tmp3 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_init_info),
                                                p_manager);
  }
#line 12699
  if (! __cil_tmp3) {
#line 12701
    return (0);
  }
  {
#line 12703
  __cil_tmp4 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_soc),
                                                p_manager);
  }
#line 12703
  if (! __cil_tmp4) {
#line 12705
    return (0);
  }
  {
#line 12707
  __cil_tmp5 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_siz),
                                                p_manager);
  }
#line 12707
  if (! __cil_tmp5) {
#line 12709
    return (0);
  }
  {
#line 12711
  __cil_tmp6 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_cod),
                                                p_manager);
  }
#line 12711
  if (! __cil_tmp6) {
#line 12713
    return (0);
  }
  {
#line 12715
  __cil_tmp7 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_qcd),
                                                p_manager);
  }
#line 12715
  if (! __cil_tmp7) {
#line 12717
    return (0);
  }
  {
#line 12719
  __cil_tmp8 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_all_coc),
                                                p_manager);
  }
#line 12719
  if (! __cil_tmp8) {
#line 12721
    return (0);
  }
  {
#line 12723
  __cil_tmp9 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_all_qcc),
                                                p_manager);
  }
#line 12723
  if (! __cil_tmp9) {
#line 12725
    return (0);
  }
#line 12728
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12729
    __cil_tmp10 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_tlm),
                                                   p_manager);
    }
#line 12729
    if (! __cil_tmp10) {
#line 12731
      return (0);
    }
#line 12734
    if ((int )p_j2k->m_cp.rsiz == 4) {
      {
#line 12735
      __cil_tmp11 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_poc),
                                                     p_manager);
      }
#line 12735
      if (! __cil_tmp11) {
#line 12737
        return (0);
      }
    }
  }
  {
#line 12742
  __cil_tmp12 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_regions),
                                                 p_manager);
  }
#line 12742
  if (! __cil_tmp12) {
#line 12744
    return (0);
  }
#line 12747
  if (p_j2k->m_cp.comment != (OPJ_CHAR *)0) {
    {
#line 12748
    __cil_tmp13 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_com),
                                                   p_manager);
    }
#line 12748
    if (! __cil_tmp13) {
#line 12750
      return (0);
    }
  }
#line 12755
  if (((int )p_j2k->m_cp.rsiz & 33024) == 33024) {
    {
#line 12757
    __cil_tmp14 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_write_mct_data_group),
                                                   p_manager);
    }
#line 12757
    if (! __cil_tmp14) {
#line 12759
      return (0);
    }
  }
#line 12764
  if (p_j2k->cstr_index) {
    {
#line 12765
    __cil_tmp15 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_get_end_header),
                                                   p_manager);
    }
#line 12765
    if (! __cil_tmp15) {
#line 12767
      return (0);
    }
  }
  {
#line 12771
  __cil_tmp16 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_create_tcd),
                                                 p_manager);
  }
#line 12771
  if (! __cil_tmp16) {
#line 12773
    return (0);
  }
  {
#line 12775
  __cil_tmp17 = opj_procedure_list_add_procedure(p_j2k->m_procedure_list, (opj_procedure )(& opj_j2k_update_rates),
                                                 p_manager);
  }
#line 12775
  if (! __cil_tmp17) {
#line 12777
    return (0);
  }
#line 12780
  return (1);
}
}
#line 12783 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                              OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                              opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_BYTE *l_begin_data ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;

  {
  {
#line 12790
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12792
  l_begin_data = (OPJ_BYTE *)0;
#line 12794
  l_tcd = (opj_tcd_t *)0;
#line 12795
  l_cp = (opj_cp_t *)0;
#line 12797
  l_tcd = p_j2k->m_tcd;
#line 12798
  l_cp = & p_j2k->m_cp;
#line 12800
  l_tcd->cur_pino = (OPJ_UINT32 )0;
#line 12803
  p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = (OPJ_UINT32 )0;
#line 12808
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12809
  l_begin_data = p_data;
#line 12810
  __cil_tmp12 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                  p_stream, p_manager);
  }
#line 12810
  if (! __cil_tmp12) {
#line 12813
    return (0);
  }
#line 12816
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 12817
  p_data += l_current_nb_bytes_written;
#line 12818
  total_data_size -= l_current_nb_bytes_written;
#line 12820
  if (! ((int )l_cp->rsiz >= 3 && (int )l_cp->rsiz <= 6)) {
#line 12838
    if ((l_cp->tcps + p_j2k->m_current_tile_number)->POC) {
      {
#line 12839
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12840
      opj_j2k_write_poc_in_memory(p_j2k, p_data, & l_current_nb_bytes_written, p_manager);
#line 12842
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12843
      p_data += l_current_nb_bytes_written;
#line 12844
      total_data_size -= l_current_nb_bytes_written;
      }
    }
  }
  {
#line 12848
  l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12849
  __cil_tmp13 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                  total_data_size, p_stream, p_manager);
  }
#line 12849
  if (! __cil_tmp13) {
#line 12851
    return (0);
  }
  {
#line 12854
  l_nb_bytes_written += l_current_nb_bytes_written;
#line 12855
  *p_data_written = l_nb_bytes_written;
#line 12858
  opj_write_bytes_LE(l_begin_data + 6, l_nb_bytes_written, (OPJ_UINT32 )4);
  }
#line 12861
  if (p_j2k->m_specific_param.m_encoder.m_TLM) {
    {
#line 12862
    opj_j2k_update_tlm(p_j2k, l_nb_bytes_written);
    }
  }
#line 12865
  return (1);
}
}
#line 12868 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k , OPJ_BYTE *p_data ,
                                             OPJ_UINT32 *p_data_written , OPJ_UINT32 total_data_size ,
                                             opj_stream_private_t *p_stream , struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 tilepartno ;
  OPJ_UINT32 l_nb_bytes_written ;
  OPJ_UINT32 l_current_nb_bytes_written ;
  OPJ_UINT32 l_part_tile_size ;
  OPJ_UINT32 tot_num_tp ;
  OPJ_UINT32 pino ;
  OPJ_BYTE *l_begin_data ;
  opj_tcp_t *l_tcp ;
  opj_tcd_t *l_tcd ;
  opj_cp_t *l_cp ;
  OPJ_UINT32 __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_UINT32 __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_BOOL __cil_tmp22 ;

  {
  {
#line 12876
  tilepartno = (OPJ_UINT32 )0;
#line 12877
  l_nb_bytes_written = (OPJ_UINT32 )0;
#line 12884
  l_tcp = (opj_tcp_t *)0;
#line 12885
  l_tcd = (opj_tcd_t *)0;
#line 12886
  l_cp = (opj_cp_t *)0;
#line 12888
  l_tcd = p_j2k->m_tcd;
#line 12889
  l_cp = & p_j2k->m_cp;
#line 12890
  l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
#line 12893
  tot_num_tp = opj_j2k_get_num_tp(l_cp, (OPJ_UINT32 )0, p_j2k->m_current_tile_number);
#line 12896
  (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12897
  tilepartno = (OPJ_UINT32 )1;
  }
  {
#line 12897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12897
    if (! (tilepartno < tot_num_tp)) {
#line 12897
      goto while_break;
    }
    {
#line 12898
    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12899
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12900
    l_part_tile_size = (OPJ_UINT32 )0;
#line 12901
    l_begin_data = p_data;
#line 12903
    __cil_tmp18 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                    p_stream, p_manager);
    }
#line 12903
    if (! __cil_tmp18) {
#line 12908
      return (0);
    }
    {
#line 12911
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 12912
    p_data += l_current_nb_bytes_written;
#line 12913
    total_data_size -= l_current_nb_bytes_written;
#line 12914
    l_part_tile_size += l_current_nb_bytes_written;
#line 12916
    l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12917
    __cil_tmp19 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                    total_data_size, p_stream, p_manager);
    }
#line 12917
    if (! __cil_tmp19) {
#line 12919
      return (0);
    }
    {
#line 12922
    p_data += l_current_nb_bytes_written;
#line 12923
    l_nb_bytes_written += l_current_nb_bytes_written;
#line 12924
    total_data_size -= l_current_nb_bytes_written;
#line 12925
    l_part_tile_size += l_current_nb_bytes_written;
#line 12928
    opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
    }
#line 12931
    if (p_j2k->m_specific_param.m_encoder.m_TLM) {
      {
#line 12932
      opj_j2k_update_tlm(p_j2k, l_part_tile_size);
      }
    }
#line 12935
    (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12897
    tilepartno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12938
  pino = (OPJ_UINT32 )1;
  {
#line 12938
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 12938
    if (! (pino <= l_tcp->numpocs)) {
#line 12938
      goto while_break___0;
    }
    {
#line 12939
    l_tcd->cur_pino = pino;
#line 12942
    tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);
#line 12943
    tilepartno = (OPJ_UINT32 )0;
    }
    {
#line 12943
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12943
      if (! (tilepartno < tot_num_tp)) {
#line 12943
        goto while_break___1;
      }
      {
#line 12944
      p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
#line 12945
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12946
      l_part_tile_size = (OPJ_UINT32 )0;
#line 12947
      l_begin_data = p_data;
#line 12949
      __cil_tmp21 = opj_j2k_write_sot(p_j2k, p_data, total_data_size, & l_current_nb_bytes_written,
                                      p_stream, p_manager);
      }
#line 12949
      if (! __cil_tmp21) {
#line 12953
        return (0);
      }
      {
#line 12956
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12957
      p_data += l_current_nb_bytes_written;
#line 12958
      total_data_size -= l_current_nb_bytes_written;
#line 12959
      l_part_tile_size += l_current_nb_bytes_written;
#line 12961
      l_current_nb_bytes_written = (OPJ_UINT32 )0;
#line 12963
      __cil_tmp22 = opj_j2k_write_sod(p_j2k, l_tcd, p_data, & l_current_nb_bytes_written,
                                      total_data_size, p_stream, p_manager);
      }
#line 12963
      if (! __cil_tmp22) {
#line 12965
        return (0);
      }
      {
#line 12968
      l_nb_bytes_written += l_current_nb_bytes_written;
#line 12969
      p_data += l_current_nb_bytes_written;
#line 12970
      total_data_size -= l_current_nb_bytes_written;
#line 12971
      l_part_tile_size += l_current_nb_bytes_written;
#line 12974
      opj_write_bytes_LE(l_begin_data + 6, l_part_tile_size, (OPJ_UINT32 )4);
      }
#line 12977
      if (p_j2k->m_specific_param.m_encoder.m_TLM) {
        {
#line 12978
        opj_j2k_update_tlm(p_j2k, l_part_tile_size);
        }
      }
#line 12981
      (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number) ++;
#line 12943
      tilepartno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 12938
    pino ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 12985
  *p_data_written = l_nb_bytes_written;
#line 12987
  return (1);
}
}
#line 12990 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_write_updated_tlm(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                          struct opj_event_mgr *p_manager ) 
{ 
  OPJ_UINT32 l_tlm_size ;
  OPJ_OFF_T l_tlm_position ;
  OPJ_OFF_T l_current_position ;
  OPJ_UINT32 size_per_tile_part ;
  int tmp ;
  OPJ_OFF_T __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_SIZE_T __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
#line 13003
  if (p_j2k->m_specific_param.m_encoder.m_Ttlmi_is_byte) {
#line 13003
    tmp = 5;
  } else {
#line 13003
    tmp = 6;
  }
  {
#line 13003
  size_per_tile_part = (OPJ_UINT32 )tmp;
#line 13004
  l_tlm_size = size_per_tile_part * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
#line 13006
  l_tlm_position = 6L + p_j2k->m_specific_param.m_encoder.m_tlm_start;
#line 13007
  l_current_position = opj_stream_tell(p_stream);
#line 13009
  __cil_tmp10 = opj_stream_seek(p_stream, l_tlm_position, p_manager);
  }
#line 13009
  if (! __cil_tmp10) {
#line 13010
    return (0);
  }
  {
#line 13013
  __cil_tmp11 = opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,
                                      (OPJ_SIZE_T )l_tlm_size, p_manager);
  }
#line 13013
  if (__cil_tmp11 != (unsigned long )l_tlm_size) {
#line 13016
    return (0);
  }
  {
#line 13019
  __cil_tmp12 = opj_stream_seek(p_stream, l_current_position, p_manager);
  }
#line 13019
  if (! __cil_tmp12) {
#line 13020
    return (0);
  }
#line 13023
  return (1);
}
}
#line 13026 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_end_encoding(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                     struct opj_event_mgr *p_manager ) 
{ 


  {
  {
#line 13038
  opj_tcd_destroy(p_j2k->m_tcd);
#line 13039
  p_j2k->m_tcd = (struct opj_tcd *)0;
  }
#line 13041
  if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
    {
#line 13042
    opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
#line 13043
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = (OPJ_BYTE *)0;
#line 13044
    p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = (OPJ_BYTE *)0;
    }
  }
#line 13047
  if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
    {
#line 13048
    opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
#line 13049
    p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 13052
  p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = (OPJ_UINT32 )0;
#line 13054
  return (1);
}
}
#line 13060 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_destroy_header_memory(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                              opj_event_mgr_t *p_manager ) 
{ 


  {
#line 13073
  if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
    {
#line 13074
    opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
#line 13075
    p_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *)0;
    }
  }
#line 13078
  p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = (OPJ_UINT32 )0;
#line 13080
  return (1);
}
}
#line 13083 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_init_info(opj_j2k_t *p_j2k , struct opj_stream_private *p_stream ,
                                  struct opj_event_mgr *p_manager ) 
{ 
  opj_codestream_info_t *l_cstr_info ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 13087
  l_cstr_info = (opj_codestream_info_t *)0;
#line 13136
  __cil_tmp5 = opj_j2k_calculate_tp(p_j2k, & p_j2k->m_cp, & p_j2k->m_specific_param.m_encoder.m_total_tile_parts,
                                    p_j2k->m_private_image, p_manager);
  }
#line 13136
  return (__cil_tmp5);
}
}
#line 13148 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
static OPJ_BOOL opj_j2k_create_tcd(opj_j2k_t *p_j2k , opj_stream_private_t *p_stream ,
                                   opj_event_mgr_t *p_manager ) 
{ 
  opj_tcd_t *__cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;

  {
  {
#line 13160
  p_j2k->m_tcd = opj_tcd_create(0);
  }
#line 13162
  if (! p_j2k->m_tcd) {
    {
#line 13163
    opj_event_msg(p_manager, 1, "Not enough memory to create Tile Coder\n");
    }
#line 13164
    return (0);
  }
  {
#line 13167
  __cil_tmp5 = opj_tcd_init(p_j2k->m_tcd, p_j2k->m_private_image, & p_j2k->m_cp, p_j2k->m_tp);
  }
#line 13167
  if (! __cil_tmp5) {
    {
#line 13169
    opj_tcd_destroy(p_j2k->m_tcd);
#line 13170
    p_j2k->m_tcd = (struct opj_tcd *)0;
    }
#line 13171
    return (0);
  }
#line 13174
  return (1);
}
}
#line 13177 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/j2k.c"
OPJ_BOOL opj_j2k_write_tile(opj_j2k_t *p_j2k , OPJ_UINT32 p_tile_index , OPJ_BYTE *p_data ,
                            OPJ_UINT32 p_data_size , opj_stream_private_t *p_stream ,
                            opj_event_mgr_t *p_manager ) 
{ 
  OPJ_BOOL __cil_tmp7 ;
  OPJ_UINT32 j ;
  opj_tcd_tilecomp_t *l_tilec ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;

  {
  {
#line 13184
  __cil_tmp7 = opj_j2k_pre_write_tile(p_j2k, p_tile_index, p_stream, p_manager);
  }
#line 13184
  if (! __cil_tmp7) {
    {
#line 13185
    opj_event_msg(p_manager, 1, "Error while opj_j2k_pre_write_tile with tile index = %d\n\230\001",
                  p_tile_index);
    }
#line 13187
    return (0);
  } else {
#line 13191
    j = (OPJ_UINT32 )0;
    {
#line 13191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 13191
      if (! (j < ((p_j2k->m_tcd)->image)->numcomps)) {
#line 13191
        goto while_break;
      }
      {
#line 13192
      l_tilec = (((p_j2k->m_tcd)->tcd_image)->tiles)->comps + j;
#line 13194
      __cil_tmp10 = opj_alloc_tile_component_data(l_tilec);
      }
#line 13194
      if (! __cil_tmp10) {
        {
#line 13195
        opj_event_msg(p_manager, 1, "Error allocating tile component data.");
        }
#line 13196
        return (0);
      }
#line 13191
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 13201
    __cil_tmp11 = opj_tcd_copy_tile_data(p_j2k->m_tcd, p_data, (OPJ_SIZE_T )p_data_size);
    }
#line 13201
    if (! __cil_tmp11) {
      {
#line 13202
      opj_event_msg(p_manager, 1, "Size mismatch between tile data and sent data.");
      }
#line 13204
      return (0);
    }
    {
#line 13206
    __cil_tmp12 = opj_j2k_post_write_tile(p_j2k, p_stream, p_manager);
    }
#line 13206
    if (! __cil_tmp12) {
      {
#line 13207
      opj_event_msg(p_manager, 1, "Error while opj_j2k_post_write_tile with tile index = %d\n",
                    p_tile_index);
      }
#line 13209
      return (0);
    }
  }
#line 13213
  return (1);
}
}
#line 54 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t___0 *pi ) ;
#line 60
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t___0 *pi ) ;
#line 66
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t___0 *pi ) ;
#line 72
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t___0 *pi ) ;
#line 78
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t___0 *pi ) ;
#line 94
static void opj_pi_update_encode_poc_and_final(opj_cp_t___0 *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_UINT32 p_tx0 , OPJ_UINT32 p_tx1 ,
                                               OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 120
static void opj_pi_update_encode_not_poc(opj_cp_t___0 *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_UINT32 p_tx0 ,
                                         OPJ_UINT32 p_tx1 , OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                         OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                         OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) ;
#line 146
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                        OPJ_UINT32 p_tileno , OPJ_UINT32 *p_tx0 ,
                                        OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 , OPJ_UINT32 *p_ty1 ,
                                        OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                        OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) ;
#line 178
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_UINT32 *p_tx0 ,
                                            OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 ,
                                            OPJ_UINT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) ;
#line 199
static opj_pi_iterator_t___0 *opj_pi_create(opj_image_t *image , opj_cp_t___0 *cp ,
                                            OPJ_UINT32 tileno , opj_event_mgr_t *manager ) ;
#line 206
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 213
static void opj_pi_update_decode_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) ;
#line 221
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) ;
#line 237 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 239
  comp = (opj_pi_comp_t *)((void *)0);
#line 240
  res = (opj_pi_resolution_t *)((void *)0);
#line 241
  index = (OPJ_UINT32 )0;
#line 243
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 245
    opj_event_msg(pi->manager, 1, "opj_pi_next_lrcp(): invalid compno0/compno1\n");
    }
    }
#line 247
    return (0);
  } else
#line 243
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 245
    opj_event_msg(pi->manager, 1, "opj_pi_next_lrcp(): invalid compno0/compno1\n");
    }
    }
#line 247
    return (0);
  }
#line 250
  if (! pi->first) {
#line 251
    comp = pi->comps + pi->compno;
#line 252
    res = comp->resolutions + pi->resno;
#line 253
    goto LABEL_SKIP;
  } else {
#line 255
    pi->first = 0;
  }
#line 258
  pi->layno = pi->poc.layno0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (pi->layno < pi->poc.layno1)) {
#line 258
      goto while_break;
    }
#line 259
    pi->resno = pi->poc.resno0;
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      if (! (pi->resno < pi->poc.resno1)) {
#line 259
        goto while_break___0;
      }
#line 261
      pi->compno = pi->poc.compno0;
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        if (! (pi->compno < pi->poc.compno1)) {
#line 261
          goto while_break___1;
        }
#line 262
        comp = pi->comps + pi->compno;
#line 263
        if (pi->resno >= comp->numresolutions) {
#line 264
          goto while_continue___1;
        }
#line 266
        res = comp->resolutions + pi->resno;
#line 267
        if (! pi->tp_on) {
#line 268
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 270
        pi->precno = pi->poc.precno0;
        {
#line 270
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 270
          if (! (pi->precno < pi->poc.precno1)) {
#line 270
            goto while_break___2;
          }
#line 271
          index = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 279
          if (index >= pi->include_size) {
            {
#line 280
            opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
            }
#line 281
            return (0);
          }
#line 283
          if (! *(pi->include + index)) {
#line 284
            *(pi->include + index) = (OPJ_INT16 )1;
#line 285
            return (1);
          }
          LABEL_SKIP: ;
#line 270
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 261
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 260
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 297 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_UINT32 __cil_tmp6 ;
  OPJ_UINT32 __cil_tmp7 ;
  OPJ_UINT32 __cil_tmp8 ;

  {
#line 299
  comp = (opj_pi_comp_t *)((void *)0);
#line 300
  res = (opj_pi_resolution_t *)((void *)0);
#line 301
  index = (OPJ_UINT32 )0;
#line 303
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 305
    opj_event_msg(pi->manager, 1, "opj_pi_next_rlcp(): invalid compno0/compno1\n\265U");
    }
    }
#line 307
    return (0);
  } else
#line 303
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 305
    opj_event_msg(pi->manager, 1, "opj_pi_next_rlcp(): invalid compno0/compno1\n\265U");
    }
    }
#line 307
    return (0);
  }
#line 310
  if (! pi->first) {
#line 311
    comp = pi->comps + pi->compno;
#line 312
    res = comp->resolutions + pi->resno;
#line 313
    goto LABEL_SKIP;
  } else {
#line 315
    pi->first = 0;
  }
#line 318
  pi->resno = pi->poc.resno0;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 318
    if (! (pi->resno < pi->poc.resno1)) {
#line 318
      goto while_break;
    }
#line 319
    pi->layno = pi->poc.layno0;
    {
#line 319
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 319
      if (! (pi->layno < pi->poc.layno1)) {
#line 319
        goto while_break___0;
      }
#line 320
      pi->compno = pi->poc.compno0;
      {
#line 320
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 320
        if (! (pi->compno < pi->poc.compno1)) {
#line 320
          goto while_break___1;
        }
#line 321
        comp = pi->comps + pi->compno;
#line 322
        if (pi->resno >= comp->numresolutions) {
#line 323
          goto while_continue___1;
        }
#line 325
        res = comp->resolutions + pi->resno;
#line 326
        if (! pi->tp_on) {
#line 327
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 329
        pi->precno = pi->poc.precno0;
        {
#line 329
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 329
          if (! (pi->precno < pi->poc.precno1)) {
#line 329
            goto while_break___2;
          }
#line 330
          index = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 332
          if (index >= pi->include_size) {
            {
#line 333
            opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
            }
#line 334
            return (0);
          }
#line 336
          if (! *(pi->include + index)) {
#line 337
            *(pi->include + index) = (OPJ_INT16 )1;
#line 338
            return (1);
          }
          LABEL_SKIP: ;
#line 329
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 320
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 319
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 318
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return (0);
}
}
#line 350 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;

  {
#line 352
  comp = (opj_pi_comp_t *)((void *)0);
#line 353
  res = (opj_pi_resolution_t *)((void *)0);
#line 354
  index = (OPJ_UINT32 )0;
#line 356
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 358
    opj_event_msg(pi->manager, 1, "opj_pi_next_rpcl(): invalid compno0/compno1\n");
    }
    }
#line 360
    return (0);
  } else
#line 356
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 358
    opj_event_msg(pi->manager, 1, "opj_pi_next_rpcl(): invalid compno0/compno1\n");
    }
    }
#line 360
    return (0);
  }
#line 363
  if (! pi->first) {
#line 364
    goto LABEL_SKIP;
  } else {
#line 367
    pi->first = 0;
#line 368
    pi->dx = (OPJ_UINT32 )0;
#line 369
    pi->dy = (OPJ_UINT32 )0;
#line 370
    compno = (OPJ_UINT32 )0;
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;
#line 370
      if (! (compno < pi->numcomps)) {
#line 370
        goto while_break;
      }
#line 371
      comp = pi->comps + compno;
#line 372
      resno = (OPJ_UINT32 )0;
      {
#line 372
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 372
        if (! (resno < comp->numresolutions)) {
#line 372
          goto while_break___0;
        }
#line 374
        res = comp->resolutions + resno;
#line 375
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 375
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 377
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 378
            if (! pi->dx) {
#line 378
              tmp = dx;
            } else {
              {
#line 378
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 378
              tmp = __cil_tmp9;
              }
            }
#line 378
            pi->dx = tmp;
          }
        }
#line 380
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 380
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 382
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 383
            if (! pi->dy) {
#line 383
              tmp___0 = dy;
            } else {
              {
#line 383
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 383
              tmp___0 = __cil_tmp11;
              }
            }
#line 383
            pi->dy = tmp___0;
          }
        }
#line 372
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 370
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 387
    if (pi->dx == 0U) {
#line 388
      return (0);
    } else
#line 387
    if (pi->dy == 0U) {
#line 388
      return (0);
    }
  }
#line 391
  if (! pi->tp_on) {
#line 392
    pi->poc.ty0 = pi->ty0;
#line 393
    pi->poc.tx0 = pi->tx0;
#line 394
    pi->poc.ty1 = pi->ty1;
#line 395
    pi->poc.tx1 = pi->tx1;
  }
#line 397
  pi->resno = pi->poc.resno0;
  {
#line 397
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 397
    if (! (pi->resno < pi->poc.resno1)) {
#line 397
      goto while_break___1;
    }
#line 398
    pi->y = (OPJ_UINT32 )pi->poc.ty0;
    {
#line 398
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 398
      if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 398
        goto while_break___2;
      }
#line 400
      pi->x = (OPJ_UINT32 )pi->poc.tx0;
      {
#line 400
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 400
        if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 400
          goto while_break___3;
        }
#line 402
        pi->compno = pi->poc.compno0;
        {
#line 402
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 402
          if (! (pi->compno < pi->poc.compno1)) {
#line 402
            goto while_break___4;
          }
#line 408
          comp = pi->comps + pi->compno;
#line 409
          if (pi->resno >= comp->numresolutions) {
#line 410
            goto while_continue___4;
          }
#line 412
          res = comp->resolutions + pi->resno;
#line 413
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 415
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 417
            goto while_continue___4;
          } else
#line 415
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 417
            goto while_continue___4;
          }
          {
#line 420
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 422
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 424
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 426
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 428
          rpx = res->pdx + levelno;
#line 429
          rpy = res->pdy + levelno;
          }
#line 431
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 433
            goto while_continue___4;
          } else
#line 431
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 433
            goto while_continue___4;
          }
#line 437
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 440
            goto while_continue___4;
          }
#line 442
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 445
            goto while_continue___4;
          }
#line 448
          if (res->pw == 0U) {
#line 449
            goto while_continue___4;
          } else
#line 448
          if (res->ph == 0U) {
#line 449
            goto while_continue___4;
          }
#line 452
          if (trx0 == trx1) {
#line 453
            goto while_continue___4;
          } else
#line 452
          if (try0 == try1) {
#line 453
            goto while_continue___4;
          }
          {
#line 456
          __cil_tmp30 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 456
          __cil_tmp28 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 456
          __cil_tmp29 = opj_uint_floordivpow2(__cil_tmp28, res->pdx);
#line 456
          prci = __cil_tmp29 - __cil_tmp30;
#line 459
          __cil_tmp33 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 459
          __cil_tmp31 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 459
          __cil_tmp32 = opj_uint_floordivpow2(__cil_tmp31, res->pdy);
#line 459
          prcj = __cil_tmp32 - __cil_tmp33;
#line 462
          pi->precno = prci + prcj * res->pw;
#line 463
          pi->layno = pi->poc.layno0;
          }
          {
#line 463
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 463
            if (! (pi->layno < pi->poc.layno1)) {
#line 463
              goto while_break___5;
            }
#line 464
            index = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 466
            if (index >= pi->include_size) {
              {
#line 467
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 468
              return (0);
            }
#line 470
            if (! *(pi->include + index)) {
#line 471
              *(pi->include + index) = (OPJ_INT16 )1;
#line 472
              return (1);
            }
            LABEL_SKIP: ;
#line 463
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 402
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 401
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 399
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 397
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 482
  return (0);
}
}
#line 485 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp9 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp11 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 __cil_tmp14 ;
  OPJ_UINT32 __cil_tmp15 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;
  OPJ_UINT32 __cil_tmp36 ;
  OPJ_UINT32 __cil_tmp37 ;

  {
#line 487
  comp = (opj_pi_comp_t *)((void *)0);
#line 488
  res = (opj_pi_resolution_t *)((void *)0);
#line 489
  index = (OPJ_UINT32 )0;
#line 491
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 493
    opj_event_msg(pi->manager, 1, "opj_pi_next_pcrl(): invalid compno0/compno1\n");
    }
    }
#line 495
    return (0);
  } else
#line 491
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 493
    opj_event_msg(pi->manager, 1, "opj_pi_next_pcrl(): invalid compno0/compno1\n");
    }
    }
#line 495
    return (0);
  }
#line 498
  if (! pi->first) {
#line 499
    comp = pi->comps + pi->compno;
#line 500
    goto LABEL_SKIP;
  } else {
#line 503
    pi->first = 0;
#line 504
    pi->dx = (OPJ_UINT32 )0;
#line 505
    pi->dy = (OPJ_UINT32 )0;
#line 506
    compno = (OPJ_UINT32 )0;
    {
#line 506
    while (1) {
      while_continue: /* CIL Label */ ;
#line 506
      if (! (compno < pi->numcomps)) {
#line 506
        goto while_break;
      }
#line 507
      comp = pi->comps + compno;
#line 508
      resno = (OPJ_UINT32 )0;
      {
#line 508
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 508
        if (! (resno < comp->numresolutions)) {
#line 508
          goto while_break___0;
        }
#line 510
        res = comp->resolutions + resno;
#line 511
        if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 511
          if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 513
            dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 514
            if (! pi->dx) {
#line 514
              tmp = dx;
            } else {
              {
#line 514
              __cil_tmp9 = opj_uint_min(pi->dx, dx);
#line 514
              tmp = __cil_tmp9;
              }
            }
#line 514
            pi->dx = tmp;
          }
        }
#line 516
        if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 516
          if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 518
            dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 519
            if (! pi->dy) {
#line 519
              tmp___0 = dy;
            } else {
              {
#line 519
              __cil_tmp11 = opj_uint_min(pi->dy, dy);
#line 519
              tmp___0 = __cil_tmp11;
              }
            }
#line 519
            pi->dy = tmp___0;
          }
        }
#line 508
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 506
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 523
    if (pi->dx == 0U) {
#line 524
      return (0);
    } else
#line 523
    if (pi->dy == 0U) {
#line 524
      return (0);
    }
  }
#line 527
  if (! pi->tp_on) {
#line 528
    pi->poc.ty0 = pi->ty0;
#line 529
    pi->poc.tx0 = pi->tx0;
#line 530
    pi->poc.ty1 = pi->ty1;
#line 531
    pi->poc.tx1 = pi->tx1;
  }
#line 533
  pi->y = (OPJ_UINT32 )pi->poc.ty0;
  {
#line 533
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 533
    if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 533
      goto while_break___1;
    }
#line 535
    pi->x = (OPJ_UINT32 )pi->poc.tx0;
    {
#line 535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 535
      if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 535
        goto while_break___2;
      }
#line 537
      pi->compno = pi->poc.compno0;
      {
#line 537
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 537
        if (! (pi->compno < pi->poc.compno1)) {
#line 537
          goto while_break___3;
        }
#line 538
        comp = pi->comps + pi->compno;
#line 539
        pi->resno = pi->poc.resno0;
        {
#line 539
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 539
          if (! (pi->resno < __cil_tmp15)) {
#line 539
            goto while_break___4;
          }
#line 546
          res = comp->resolutions + pi->resno;
#line 547
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 549
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 551
            goto while_continue___4;
          } else
#line 549
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 551
            goto while_continue___4;
          }
          {
#line 554
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 556
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 558
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 560
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 562
          rpx = res->pdx + levelno;
#line 563
          rpy = res->pdy + levelno;
          }
#line 565
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 567
            goto while_continue___4;
          } else
#line 565
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 567
            goto while_continue___4;
          }
#line 571
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 574
            goto while_continue___4;
          }
#line 576
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 579
            goto while_continue___4;
          }
#line 582
          if (res->pw == 0U) {
#line 583
            goto while_continue___4;
          } else
#line 582
          if (res->ph == 0U) {
#line 583
            goto while_continue___4;
          }
#line 586
          if (trx0 == trx1) {
#line 587
            goto while_continue___4;
          } else
#line 586
          if (try0 == try1) {
#line 587
            goto while_continue___4;
          }
          {
#line 590
          __cil_tmp31 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 590
          __cil_tmp29 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 590
          __cil_tmp30 = opj_uint_floordivpow2(__cil_tmp29, res->pdx);
#line 590
          prci = __cil_tmp30 - __cil_tmp31;
#line 593
          __cil_tmp34 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 593
          __cil_tmp32 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 593
          __cil_tmp33 = opj_uint_floordivpow2(__cil_tmp32, res->pdy);
#line 593
          prcj = __cil_tmp33 - __cil_tmp34;
#line 596
          pi->precno = prci + prcj * res->pw;
#line 597
          pi->layno = pi->poc.layno0;
          }
          {
#line 597
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 597
            if (! (pi->layno < pi->poc.layno1)) {
#line 597
              goto while_break___5;
            }
#line 598
            index = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 600
            if (index >= pi->include_size) {
              {
#line 601
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 602
              return (0);
            }
#line 604
            if (! *(pi->include + index)) {
#line 605
              *(pi->include + index) = (OPJ_INT16 )1;
#line 606
              return (1);
            }
            LABEL_SKIP: ;
#line 597
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 540
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 537
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 536
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 534
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 616
  return (0);
}
}
#line 619 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t___0 *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  OPJ_UINT32 index ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 dx ;
  OPJ_UINT32 dy ;
  OPJ_UINT32 __cil_tmp8 ;
  OPJ_UINT32 tmp ;
  OPJ_UINT32 __cil_tmp10 ;
  OPJ_UINT32 tmp___0 ;
  OPJ_UINT32 __cil_tmp12 ;
  OPJ_UINT32 __cil_tmp13 ;
  OPJ_UINT32 levelno ;
  OPJ_UINT32 trx0 ;
  OPJ_UINT32 try0 ;
  OPJ_UINT32 trx1 ;
  OPJ_UINT32 try1 ;
  OPJ_UINT32 rpx ;
  OPJ_UINT32 rpy ;
  OPJ_UINT32 prci ;
  OPJ_UINT32 prcj ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 __cil_tmp29 ;
  OPJ_UINT32 __cil_tmp30 ;
  OPJ_UINT32 __cil_tmp31 ;
  OPJ_UINT32 __cil_tmp32 ;
  OPJ_UINT32 __cil_tmp33 ;
  OPJ_UINT32 __cil_tmp34 ;
  OPJ_UINT32 __cil_tmp35 ;

  {
#line 621
  comp = (opj_pi_comp_t *)((void *)0);
#line 622
  res = (opj_pi_resolution_t *)((void *)0);
#line 623
  index = (OPJ_UINT32 )0;
#line 625
  if (pi->poc.compno0 >= pi->numcomps) {
    {
    {
#line 627
    opj_event_msg(pi->manager, 1, "opj_pi_next_cprl(): invalid compno0/compno1\n\265U");
    }
    }
#line 629
    return (0);
  } else
#line 625
  if (pi->poc.compno1 >= pi->numcomps + 1U) {
    {
    {
#line 627
    opj_event_msg(pi->manager, 1, "opj_pi_next_cprl(): invalid compno0/compno1\n\265U");
    }
    }
#line 629
    return (0);
  }
#line 632
  if (! pi->first) {
#line 633
    comp = pi->comps + pi->compno;
#line 634
    goto LABEL_SKIP;
  } else {
#line 636
    pi->first = 0;
  }
#line 639
  pi->compno = pi->poc.compno0;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (pi->compno < pi->poc.compno1)) {
#line 639
      goto while_break;
    }
#line 641
    comp = pi->comps + pi->compno;
#line 642
    pi->dx = (OPJ_UINT32 )0;
#line 643
    pi->dy = (OPJ_UINT32 )0;
#line 644
    resno = (OPJ_UINT32 )0;
    {
#line 644
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 644
      if (! (resno < comp->numresolutions)) {
#line 644
        goto while_break___0;
      }
#line 646
      res = comp->resolutions + resno;
#line 647
      if (((res->pdx + comp->numresolutions) - 1U) - resno < 32U) {
#line 647
        if (comp->dx <= 4294967295U / (1U << (((res->pdx + comp->numresolutions) - 1U) - resno))) {
#line 649
          dx = comp->dx * (1U << (((res->pdx + comp->numresolutions) - 1U) - resno));
#line 650
          if (! pi->dx) {
#line 650
            tmp = dx;
          } else {
            {
#line 650
            __cil_tmp8 = opj_uint_min(pi->dx, dx);
#line 650
            tmp = __cil_tmp8;
            }
          }
#line 650
          pi->dx = tmp;
        }
      }
#line 652
      if (((res->pdy + comp->numresolutions) - 1U) - resno < 32U) {
#line 652
        if (comp->dy <= 4294967295U / (1U << (((res->pdy + comp->numresolutions) - 1U) - resno))) {
#line 654
          dy = comp->dy * (1U << (((res->pdy + comp->numresolutions) - 1U) - resno));
#line 655
          if (! pi->dy) {
#line 655
            tmp___0 = dy;
          } else {
            {
#line 655
            __cil_tmp10 = opj_uint_min(pi->dy, dy);
#line 655
            tmp___0 = __cil_tmp10;
            }
          }
#line 655
          pi->dy = tmp___0;
        }
      }
#line 644
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 658
    if (pi->dx == 0U) {
#line 659
      return (0);
    } else
#line 658
    if (pi->dy == 0U) {
#line 659
      return (0);
    }
#line 661
    if (! pi->tp_on) {
#line 662
      pi->poc.ty0 = pi->ty0;
#line 663
      pi->poc.tx0 = pi->tx0;
#line 664
      pi->poc.ty1 = pi->ty1;
#line 665
      pi->poc.tx1 = pi->tx1;
    }
#line 667
    pi->y = (OPJ_UINT32 )pi->poc.ty0;
    {
#line 667
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 667
      if (! (pi->y < (OPJ_UINT32 )pi->poc.ty1)) {
#line 667
        goto while_break___1;
      }
#line 669
      pi->x = (OPJ_UINT32 )pi->poc.tx0;
      {
#line 669
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 669
        if (! (pi->x < (OPJ_UINT32 )pi->poc.tx1)) {
#line 669
          goto while_break___2;
        }
#line 671
        pi->resno = pi->poc.resno0;
        {
#line 671
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 671
          if (! (pi->resno < __cil_tmp13)) {
#line 671
            goto while_break___3;
          }
#line 678
          res = comp->resolutions + pi->resno;
#line 679
          levelno = (comp->numresolutions - 1U) - pi->resno;
#line 681
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << levelno) >> levelno) != comp->dx) {
#line 683
            goto while_continue___3;
          } else
#line 681
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << levelno) >> levelno) != comp->dy) {
#line 683
            goto while_continue___3;
          }
          {
#line 686
          trx0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx0, (OPJ_UINT64 )comp->dx << levelno);
#line 688
          try0 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty0, (OPJ_UINT64 )comp->dy << levelno);
#line 690
          trx1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->tx1, (OPJ_UINT64 )comp->dx << levelno);
#line 692
          try1 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->ty1, (OPJ_UINT64 )comp->dy << levelno);
#line 694
          rpx = res->pdx + levelno;
#line 695
          rpy = res->pdy + levelno;
          }
#line 697
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dx << rpx) >> rpx) != comp->dx) {
#line 699
            goto while_continue___3;
          } else
#line 697
          if ((OPJ_UINT32 )(((OPJ_UINT64 )comp->dy << rpy) >> rpy) != comp->dy) {
#line 699
            goto while_continue___3;
          }
#line 703
          if (! ((OPJ_UINT64 )pi->y % ((OPJ_UINT64 )comp->dy << rpy) == 0UL || (pi->y == pi->ty0 && ((OPJ_UINT64 )try0 << levelno) % (1UL << rpy)))) {
#line 706
            goto while_continue___3;
          }
#line 708
          if (! ((OPJ_UINT64 )pi->x % ((OPJ_UINT64 )comp->dx << rpx) == 0UL || (pi->x == pi->tx0 && ((OPJ_UINT64 )trx0 << levelno) % (1UL << rpx)))) {
#line 711
            goto while_continue___3;
          }
#line 714
          if (res->pw == 0U) {
#line 715
            goto while_continue___3;
          } else
#line 714
          if (res->ph == 0U) {
#line 715
            goto while_continue___3;
          }
#line 718
          if (trx0 == trx1) {
#line 719
            goto while_continue___3;
          } else
#line 718
          if (try0 == try1) {
#line 719
            goto while_continue___3;
          }
          {
#line 722
          __cil_tmp29 = opj_uint_floordivpow2(trx0, res->pdx);
          }
          {
#line 722
          __cil_tmp27 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->x, (OPJ_UINT64 )comp->dx << levelno);
#line 722
          __cil_tmp28 = opj_uint_floordivpow2(__cil_tmp27, res->pdx);
#line 722
          prci = __cil_tmp28 - __cil_tmp29;
#line 725
          __cil_tmp32 = opj_uint_floordivpow2(try0, res->pdy);
          }
          {
#line 725
          __cil_tmp30 = opj_uint64_ceildiv_res_uint32((OPJ_UINT64 )pi->y, (OPJ_UINT64 )comp->dy << levelno);
#line 725
          __cil_tmp31 = opj_uint_floordivpow2(__cil_tmp30, res->pdy);
#line 725
          prcj = __cil_tmp31 - __cil_tmp32;
#line 728
          pi->precno = (OPJ_UINT32 )(prci + prcj * res->pw);
#line 729
          pi->layno = pi->poc.layno0;
          }
          {
#line 729
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 729
            if (! (pi->layno < pi->poc.layno1)) {
#line 729
              goto while_break___4;
            }
#line 730
            index = ((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p;
#line 732
            if (index >= pi->include_size) {
              {
#line 733
              opj_event_msg(pi->manager, 1, "Invalid access to pi->include");
              }
#line 734
              return (0);
            }
#line 736
            if (! *(pi->include + index)) {
#line 737
              *(pi->include + index) = (OPJ_INT16 )1;
#line 738
              return (1);
            }
            LABEL_SKIP: ;
#line 729
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 672
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 670
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 668
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 639
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return (0);
}
}
#line 751 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_get_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                        OPJ_UINT32 p_tileno , OPJ_UINT32 *p_tx0 ,
                                        OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 , OPJ_UINT32 *p_ty1 ,
                                        OPJ_UINT32 *p_dx_min , OPJ_UINT32 *p_dy_min ,
                                        OPJ_UINT32 *p_max_prec , OPJ_UINT32 *p_max_res ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 __cil_tmp21 ;
  OPJ_UINT32 __cil_tmp22 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_rx0 ;
  OPJ_UINT32 l_ry0 ;
  OPJ_UINT32 l_rx1 ;
  OPJ_UINT32 l_ry1 ;
  OPJ_UINT32 l_px0 ;
  OPJ_UINT32 l_py0 ;
  OPJ_UINT32 l_px1 ;
  OPJ_UINT32 py1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 l_product ;
  OPJ_UINT32 l_tcx0 ;
  OPJ_UINT32 l_tcy0 ;
  OPJ_UINT32 l_tcx1 ;
  OPJ_UINT32 l_tcy1 ;
  OPJ_UINT32 __cil_tmp45 ;
  OPJ_UINT32 __cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_UINT64 l_dx ;
  OPJ_UINT64 l_dy ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 __cil_tmp52 ;
  OPJ_UINT32 __cil_tmp53 ;
  OPJ_UINT32 __cil_tmp54 ;
  OPJ_UINT32 __cil_tmp55 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 766
  l_tcp = (opj_tcp_t___0 *)0;
#line 767
  l_tccp = (opj_tccp_t *)0;
#line 768
  l_img_comp = (opj_image_comp_t *)0;
#line 782
  l_tcp = p_cp->tcps + p_tileno;
#line 783
  l_img_comp = p_image->comps;
#line 784
  l_tccp = l_tcp->tccps;
#line 787
  p = p_tileno % p_cp->tw;
#line 788
  q = p_tileno / p_cp->tw;
#line 791
  l_tx0 = p_cp->tx0 + p * p_cp->tdx;
#line 793
  *p_tx0 = opj_uint_max(l_tx0, p_image->x0);
#line 794
  __cil_tmp22 = opj_uint_adds(l_tx0, p_cp->tdx);
#line 794
  __cil_tmp23 = opj_uint_min(__cil_tmp22, p_image->x1);
#line 794
  *p_tx1 = __cil_tmp23;
#line 795
  l_ty0 = p_cp->ty0 + q * p_cp->tdy;
#line 797
  *p_ty0 = opj_uint_max(l_ty0, p_image->y0);
#line 798
  __cil_tmp25 = opj_uint_adds(l_ty0, p_cp->tdy);
#line 798
  __cil_tmp26 = opj_uint_min(__cil_tmp25, p_image->y1);
#line 798
  *p_ty1 = __cil_tmp26;
#line 801
  *p_max_prec = (OPJ_UINT32 )0;
#line 802
  *p_max_res = (OPJ_UINT32 )0;
#line 805
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 806
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 808
  compno = (OPJ_UINT32 )0;
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (compno < p_image->numcomps)) {
#line 808
      goto while_break;
    }
    {
#line 818
    l_tcx0 = opj_uint_ceildiv(*p_tx0, l_img_comp->dx);
#line 819
    l_tcy0 = opj_uint_ceildiv(*p_ty0, l_img_comp->dy);
#line 820
    l_tcx1 = opj_uint_ceildiv(*p_tx1, l_img_comp->dx);
#line 821
    l_tcy1 = opj_uint_ceildiv(*p_ty1, l_img_comp->dy);
    }
#line 823
    if (l_tccp->numresolutions > *p_max_res) {
#line 824
      *p_max_res = l_tccp->numresolutions;
    }
#line 828
    resno = (OPJ_UINT32 )0;
    {
#line 828
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 828
      if (! (resno < l_tccp->numresolutions)) {
#line 828
        goto while_break___0;
      }
#line 832
      l_pdx = l_tccp->prcw[resno];
#line 833
      l_pdy = l_tccp->prch[resno];
#line 835
      l_dx = (unsigned long )l_img_comp->dx * (1UL << (((l_pdx + l_tccp->numresolutions) - 1U) - resno));
#line 837
      l_dy = (unsigned long )l_img_comp->dy * (1UL << (((l_pdy + l_tccp->numresolutions) - 1U) - resno));
#line 841
      if (l_dx <= 4294967295UL) {
        {
#line 842
        *p_dx_min = opj_uint_min(*p_dx_min, (OPJ_UINT32 )l_dx);
        }
      }
#line 844
      if (l_dy <= 4294967295UL) {
        {
#line 845
        *p_dy_min = opj_uint_min(*p_dy_min, (OPJ_UINT32 )l_dy);
        }
      }
      {
#line 849
      l_level_no = (l_tccp->numresolutions - 1U) - resno;
#line 851
      l_rx0 = opj_uint_ceildivpow2(l_tcx0, l_level_no);
#line 852
      l_ry0 = opj_uint_ceildivpow2(l_tcy0, l_level_no);
#line 853
      l_rx1 = opj_uint_ceildivpow2(l_tcx1, l_level_no);
#line 854
      l_ry1 = opj_uint_ceildivpow2(l_tcy1, l_level_no);
#line 856
      __cil_tmp57 = opj_uint_floordivpow2(l_rx0, l_pdx);
#line 856
      l_px0 = __cil_tmp57 << l_pdx;
#line 857
      __cil_tmp58 = opj_uint_floordivpow2(l_ry0, l_pdy);
#line 857
      l_py0 = __cil_tmp58 << l_pdy;
#line 858
      __cil_tmp59 = opj_uint_ceildivpow2(l_rx1, l_pdx);
#line 858
      l_px1 = __cil_tmp59 << l_pdx;
#line 860
      __cil_tmp60 = opj_uint_ceildivpow2(l_ry1, l_pdy);
#line 860
      py1 = __cil_tmp60 << l_pdy;
      }
#line 862
      if (l_rx0 == l_rx1) {
#line 862
        tmp = (unsigned int )0;
      } else {
#line 862
        tmp = (l_px1 - l_px0) >> l_pdx;
      }
#line 862
      l_pw = tmp;
#line 863
      if (l_ry0 == l_ry1) {
#line 863
        tmp___0 = (unsigned int )0;
      } else {
#line 863
        tmp___0 = (py1 - l_py0) >> l_pdy;
      }
#line 863
      l_ph = tmp___0;
#line 865
      l_product = l_pw * l_ph;
#line 868
      if (l_product > *p_max_prec) {
#line 869
        *p_max_prec = l_product;
      }
#line 828
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 872
    l_img_comp ++;
#line 873
    l_tccp ++;
#line 808
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 878 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_get_all_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 tileno , OPJ_UINT32 *p_tx0 ,
                                            OPJ_UINT32 *p_tx1 , OPJ_UINT32 *p_ty0 ,
                                            OPJ_UINT32 *p_ty1 , OPJ_UINT32 *p_dx_min ,
                                            OPJ_UINT32 *p_dy_min , OPJ_UINT32 *p_max_prec ,
                                            OPJ_UINT32 *p_max_res , OPJ_UINT32 **p_resolutions ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  opj_tcp_t___0 *tcp ;
  opj_tccp_t *l_tccp ;
  opj_image_comp_t *l_img_comp ;
  OPJ_UINT32 *lResolutionPtr ;
  OPJ_UINT32 p ;
  OPJ_UINT32 q ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 __cil_tmp23 ;
  OPJ_UINT32 __cil_tmp24 ;
  OPJ_UINT32 __cil_tmp25 ;
  OPJ_UINT32 __cil_tmp26 ;
  OPJ_UINT32 __cil_tmp27 ;
  OPJ_UINT32 __cil_tmp28 ;
  OPJ_UINT32 l_level_no ;
  OPJ_UINT32 l_rx0 ;
  OPJ_UINT32 l_ry0 ;
  OPJ_UINT32 l_rx1 ;
  OPJ_UINT32 l_ry1 ;
  OPJ_UINT32 l_px0 ;
  OPJ_UINT32 l_py0 ;
  OPJ_UINT32 l_px1 ;
  OPJ_UINT32 py1 ;
  OPJ_UINT32 l_product ;
  OPJ_UINT32 l_tcx0 ;
  OPJ_UINT32 l_tcy0 ;
  OPJ_UINT32 l_tcx1 ;
  OPJ_UINT32 l_tcy1 ;
  OPJ_UINT32 l_pdx ;
  OPJ_UINT32 l_pdy ;
  OPJ_UINT32 l_pw ;
  OPJ_UINT32 l_ph ;
  OPJ_UINT32 *tmp ;
  OPJ_UINT32 __cil_tmp48 ;
  OPJ_UINT32 __cil_tmp49 ;
  OPJ_UINT32 __cil_tmp50 ;
  OPJ_UINT32 __cil_tmp51 ;
  OPJ_UINT32 l_dx ;
  OPJ_UINT32 l_dy ;
  OPJ_UINT32 *__cil_tmp54 ;
  OPJ_UINT32 *__cil_tmp55 ;
  OPJ_UINT32 __cil_tmp56 ;
  OPJ_UINT32 __cil_tmp57 ;
  OPJ_UINT32 __cil_tmp58 ;
  OPJ_UINT32 __cil_tmp59 ;
  OPJ_UINT32 __cil_tmp60 ;
  OPJ_UINT32 __cil_tmp61 ;
  OPJ_UINT32 __cil_tmp62 ;
  OPJ_UINT32 __cil_tmp63 ;
  OPJ_UINT32 __cil_tmp64 ;
  OPJ_UINT32 __cil_tmp65 ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  OPJ_UINT32 *__cil_tmp68 ;
  OPJ_UINT32 *__cil_tmp69 ;

  {
  {
#line 895
  tcp = (opj_tcp_t___0 *)0;
#line 896
  l_tccp = (opj_tccp_t *)0;
#line 897
  l_img_comp = (opj_image_comp_t *)0;
#line 914
  tcp = p_cp->tcps + tileno;
#line 915
  l_tccp = tcp->tccps;
#line 916
  l_img_comp = p_image->comps;
#line 919
  p = tileno % p_cp->tw;
#line 920
  q = tileno / p_cp->tw;
#line 923
  l_tx0 = p_cp->tx0 + p * p_cp->tdx;
#line 925
  *p_tx0 = opj_uint_max(l_tx0, p_image->x0);
#line 926
  __cil_tmp24 = opj_uint_adds(l_tx0, p_cp->tdx);
#line 926
  __cil_tmp25 = opj_uint_min(__cil_tmp24, p_image->x1);
#line 926
  *p_tx1 = __cil_tmp25;
#line 927
  l_ty0 = p_cp->ty0 + q * p_cp->tdy;
#line 929
  *p_ty0 = opj_uint_max(l_ty0, p_image->y0);
#line 930
  __cil_tmp27 = opj_uint_adds(l_ty0, p_cp->tdy);
#line 930
  __cil_tmp28 = opj_uint_min(__cil_tmp27, p_image->y1);
#line 930
  *p_ty1 = __cil_tmp28;
#line 933
  *p_max_prec = (OPJ_UINT32 )0;
#line 934
  *p_max_res = (OPJ_UINT32 )0;
#line 937
  *p_dx_min = (OPJ_UINT32 )2147483647;
#line 938
  *p_dy_min = (OPJ_UINT32 )2147483647;
#line 940
  compno = (OPJ_UINT32 )0;
  }
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    if (! (compno < p_image->numcomps)) {
#line 940
      goto while_break;
    }
#line 949
    if (p_resolutions) {
#line 949
      tmp = *(p_resolutions + compno);
    } else {
#line 949
      tmp = (OPJ_UINT32 *)((void *)0);
    }
    {
#line 949
    lResolutionPtr = tmp;
#line 951
    l_tcx0 = opj_uint_ceildiv(*p_tx0, l_img_comp->dx);
#line 952
    l_tcy0 = opj_uint_ceildiv(*p_ty0, l_img_comp->dy);
#line 953
    l_tcx1 = opj_uint_ceildiv(*p_tx1, l_img_comp->dx);
#line 954
    l_tcy1 = opj_uint_ceildiv(*p_ty1, l_img_comp->dy);
    }
#line 956
    if (l_tccp->numresolutions > *p_max_res) {
#line 957
      *p_max_res = l_tccp->numresolutions;
    }
#line 961
    l_level_no = l_tccp->numresolutions;
#line 962
    resno = (OPJ_UINT32 )0;
    {
#line 962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 962
      if (! (resno < l_tccp->numresolutions)) {
#line 962
        goto while_break___0;
      }
#line 965
      l_level_no --;
#line 968
      l_pdx = l_tccp->prcw[resno];
#line 969
      l_pdy = l_tccp->prch[resno];
#line 970
      if (lResolutionPtr) {
#line 971
        __cil_tmp54 = lResolutionPtr;
#line 971
        lResolutionPtr ++;
#line 971
        *__cil_tmp54 = l_pdx;
#line 972
        __cil_tmp55 = lResolutionPtr;
#line 972
        lResolutionPtr ++;
#line 972
        *__cil_tmp55 = l_pdy;
      }
#line 974
      if (l_pdx + l_level_no < 32U) {
#line 974
        if (l_img_comp->dx <= 4294967295U / (1U << (l_pdx + l_level_no))) {
          {
#line 976
          l_dx = l_img_comp->dx * (1U << (l_pdx + l_level_no));
#line 978
          *p_dx_min = opj_uint_min(*p_dx_min, l_dx);
          }
        }
      }
#line 980
      if (l_pdy + l_level_no < 32U) {
#line 980
        if (l_img_comp->dy <= 4294967295U / (1U << (l_pdy + l_level_no))) {
          {
#line 982
          l_dy = l_img_comp->dy * (1U << (l_pdy + l_level_no));
#line 983
          *p_dy_min = opj_uint_min(*p_dy_min, l_dy);
          }
        }
      }
      {
#line 987
      l_rx0 = opj_uint_ceildivpow2(l_tcx0, l_level_no);
#line 988
      l_ry0 = opj_uint_ceildivpow2(l_tcy0, l_level_no);
#line 989
      l_rx1 = opj_uint_ceildivpow2(l_tcx1, l_level_no);
#line 990
      l_ry1 = opj_uint_ceildivpow2(l_tcy1, l_level_no);
#line 991
      __cil_tmp62 = opj_uint_floordivpow2(l_rx0, l_pdx);
#line 991
      l_px0 = __cil_tmp62 << l_pdx;
#line 992
      __cil_tmp63 = opj_uint_floordivpow2(l_ry0, l_pdy);
#line 992
      l_py0 = __cil_tmp63 << l_pdy;
#line 993
      __cil_tmp64 = opj_uint_ceildivpow2(l_rx1, l_pdx);
#line 993
      l_px1 = __cil_tmp64 << l_pdx;
#line 994
      __cil_tmp65 = opj_uint_ceildivpow2(l_ry1, l_pdy);
#line 994
      py1 = __cil_tmp65 << l_pdy;
      }
#line 995
      if (l_rx0 == l_rx1) {
#line 995
        tmp___0 = (unsigned int )0;
      } else {
#line 995
        tmp___0 = (l_px1 - l_px0) >> l_pdx;
      }
#line 995
      l_pw = tmp___0;
#line 996
      if (l_ry0 == l_ry1) {
#line 996
        tmp___1 = (unsigned int )0;
      } else {
#line 996
        tmp___1 = (py1 - l_py0) >> l_pdy;
      }
#line 996
      l_ph = tmp___1;
#line 997
      if (lResolutionPtr) {
#line 998
        __cil_tmp68 = lResolutionPtr;
#line 998
        lResolutionPtr ++;
#line 998
        *__cil_tmp68 = l_pw;
#line 999
        __cil_tmp69 = lResolutionPtr;
#line 999
        lResolutionPtr ++;
#line 999
        *__cil_tmp69 = l_ph;
      }
#line 1001
      l_product = l_pw * l_ph;
#line 1004
      if (l_product > *p_max_prec) {
#line 1005
        *p_max_prec = l_product;
      }
#line 962
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1009
    l_tccp ++;
#line 1010
    l_img_comp ++;
#line 940
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1014 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static opj_pi_iterator_t___0 *opj_pi_create(opj_image_t *image , opj_cp_t___0 *cp ,
                                            OPJ_UINT32 tileno , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 l_poc_bound ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *tcp ;
  opj_tccp_t *tccp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp15 ;

  {
  {
#line 1025
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1026
  tcp = (opj_tcp_t___0 *)0;
#line 1027
  tccp = (opj_tccp_t *)0;
#line 1030
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1038
  tcp = cp->tcps + tileno;
#line 1039
  l_poc_bound = tcp->numpocs + 1U;
#line 1042
  __cil_tmp12 = opj_calloc((size_t )l_poc_bound, sizeof(opj_pi_iterator_t___0 ));
#line 1042
  l_pi = (opj_pi_iterator_t___0 *)__cil_tmp12;
  }
#line 1044
  if (! l_pi) {
#line 1045
    return ((opj_pi_iterator_t___0 *)((void *)0));
  }
#line 1048
  l_current_pi = l_pi;
#line 1049
  pino = (OPJ_UINT32 )0;
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1049
    if (! (pino < l_poc_bound)) {
#line 1049
      goto while_break;
    }
    {
#line 1051
    l_current_pi->manager = manager;
#line 1053
    __cil_tmp13 = opj_calloc((size_t )image->numcomps, sizeof(opj_pi_comp_t ));
#line 1053
    l_current_pi->comps = (opj_pi_comp_t *)__cil_tmp13;
    }
#line 1055
    if (! l_current_pi->comps) {
      {
#line 1056
      opj_pi_destroy(l_pi, l_poc_bound);
      }
#line 1057
      return ((opj_pi_iterator_t___0 *)((void *)0));
    }
#line 1060
    l_current_pi->numcomps = image->numcomps;
#line 1062
    compno = (OPJ_UINT32 )0;
    {
#line 1062
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1062
      if (! (compno < image->numcomps)) {
#line 1062
        goto while_break___0;
      }
      {
#line 1063
      comp = l_current_pi->comps + compno;
#line 1065
      tccp = tcp->tccps + compno;
#line 1067
      __cil_tmp15 = opj_calloc((size_t )tccp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 1067
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp15;
      }
#line 1069
      if (! comp->resolutions) {
        {
#line 1070
        opj_pi_destroy(l_pi, l_poc_bound);
        }
#line 1071
        return ((opj_pi_iterator_t___0 *)0);
      }
#line 1074
      comp->numresolutions = tccp->numresolutions;
#line 1062
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1076
    l_current_pi ++;
#line 1049
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  return (l_pi);
}
}
#line 1081 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_poc_and_final(opj_cp_t___0 *p_cp , OPJ_UINT32 p_tileno ,
                                               OPJ_UINT32 p_tx0 , OPJ_UINT32 p_tx1 ,
                                               OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                               OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                               OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t___0 *l_tcp ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;
  OPJ_UINT32 tmp ;

  {
#line 1095
  l_tcp = (opj_tcp_t___0 *)0;
#line 1097
  l_current_poc = (opj_poc_t___0 *)0;
#line 1109
  l_tcp = p_cp->tcps + p_tileno;
#line 1111
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1115
  l_current_poc = (opj_poc_t___0 *)l_tcp->pocs;
#line 1117
  l_current_poc->compS = l_current_poc->compno0;
#line 1118
  l_current_poc->compE = l_current_poc->compno1;
#line 1119
  l_current_poc->resS = l_current_poc->resno0;
#line 1120
  l_current_poc->resE = l_current_poc->resno1;
#line 1121
  l_current_poc->layE = l_current_poc->layno1;
#line 1124
  l_current_poc->layS = (OPJ_UINT32 )0;
#line 1125
  l_current_poc->prg = l_current_poc->prg1;
#line 1126
  l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1128
  l_current_poc->prcE = p_max_prec;
#line 1129
  l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1130
  l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1131
  l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1132
  l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1133
  l_current_poc->dx = p_dx_min;
#line 1134
  l_current_poc->dy = p_dy_min;
#line 1136
  l_current_poc ++;
#line 1137
  pino = (OPJ_UINT32 )1;
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! (pino < l_poc_bound)) {
#line 1137
      goto while_break;
    }
#line 1138
    l_current_poc->compS = l_current_poc->compno0;
#line 1139
    l_current_poc->compE = l_current_poc->compno1;
#line 1140
    l_current_poc->resS = l_current_poc->resno0;
#line 1141
    l_current_poc->resE = l_current_poc->resno1;
#line 1142
    l_current_poc->layE = l_current_poc->layno1;
#line 1143
    l_current_poc->prg = l_current_poc->prg1;
#line 1144
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1146
    if (l_current_poc->layE > (l_current_poc - 1)->layE) {
#line 1146
      tmp = l_current_poc->layE;
    } else {
#line 1146
      tmp = (unsigned int )0;
    }
#line 1146
    l_current_poc->layS = tmp;
#line 1149
    l_current_poc->prcE = p_max_prec;
#line 1150
    l_current_poc->txS = (OPJ_UINT32 )p_tx0;
#line 1151
    l_current_poc->txE = (OPJ_UINT32 )p_tx1;
#line 1152
    l_current_poc->tyS = (OPJ_UINT32 )p_ty0;
#line 1153
    l_current_poc->tyE = (OPJ_UINT32 )p_ty1;
#line 1154
    l_current_poc->dx = p_dx_min;
#line 1155
    l_current_poc->dy = p_dy_min;
#line 1156
    l_current_poc ++;
#line 1137
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1160 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_encode_not_poc(opj_cp_t___0 *p_cp , OPJ_UINT32 p_num_comps ,
                                         OPJ_UINT32 p_tileno , OPJ_UINT32 p_tx0 ,
                                         OPJ_UINT32 p_tx1 , OPJ_UINT32 p_ty0 , OPJ_UINT32 p_ty1 ,
                                         OPJ_UINT32 p_max_prec , OPJ_UINT32 p_max_res ,
                                         OPJ_UINT32 p_dx_min , OPJ_UINT32 p_dy_min ) 
{ 
  OPJ_UINT32 pino ;
  opj_tcp_t___0 *l_tcp ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 l_poc_bound ;

  {
#line 1175
  l_tcp = (opj_tcp_t___0 *)0;
#line 1177
  l_current_poc = (opj_poc_t___0 *)0;
#line 1186
  l_tcp = p_cp->tcps + p_tileno;
#line 1189
  l_poc_bound = l_tcp->numpocs + 1U;
#line 1193
  l_current_poc = (opj_poc_t___0 *)l_tcp->pocs;
#line 1195
  pino = (OPJ_UINT32 )0;
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1195
    if (! (pino < l_poc_bound)) {
#line 1195
      goto while_break;
    }
#line 1196
    l_current_poc->compS = (OPJ_UINT32 )0;
#line 1197
    l_current_poc->compE = p_num_comps;
#line 1198
    l_current_poc->resS = (OPJ_UINT32 )0;
#line 1199
    l_current_poc->resE = p_max_res;
#line 1200
    l_current_poc->layS = (OPJ_UINT32 )0;
#line 1201
    l_current_poc->layE = l_tcp->numlayers;
#line 1202
    l_current_poc->prg = l_tcp->prg;
#line 1203
    l_current_poc->prcS = (OPJ_UINT32 )0;
#line 1204
    l_current_poc->prcE = p_max_prec;
#line 1205
    l_current_poc->txS = p_tx0;
#line 1206
    l_current_poc->txE = p_tx1;
#line 1207
    l_current_poc->tyS = p_ty0;
#line 1208
    l_current_poc->tyE = p_ty1;
#line 1209
    l_current_poc->dx = p_dx_min;
#line 1210
    l_current_poc->dy = p_dy_min;
#line 1211
    l_current_poc ++;
#line 1195
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1215 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                     OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t___0 *l_current_pi ;
  opj_poc_t___0 *l_current_poc ;
  OPJ_UINT32 __cil_tmp9 ;

  {
#line 1226
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1227
  l_current_poc = (opj_poc_t___0 *)0;
#line 1236
  l_bound = p_tcp->numpocs + 1U;
#line 1237
  l_current_pi = p_pi;
#line 1238
  l_current_poc = (opj_poc_t___0 *)p_tcp->pocs;
#line 1240
  pino = (OPJ_UINT32 )0;
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    if (! (pino < l_bound)) {
#line 1240
      goto while_break;
    }
    {
#line 1241
    l_current_pi->poc.prg = l_current_poc->prg;
#line 1242
    l_current_pi->first = 1;
#line 1244
    l_current_pi->poc.resno0 = l_current_poc->resno0;
#line 1246
    l_current_pi->poc.compno0 = l_current_poc->compno0;
#line 1248
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1249
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1250
    l_current_pi->poc.resno1 = l_current_poc->resno1;
#line 1252
    l_current_pi->poc.compno1 = l_current_poc->compno1;
#line 1254
    l_current_pi->poc.layno1 = opj_uint_min(l_current_poc->layno1, p_tcp->numlayers);
#line 1256
    l_current_pi->poc.precno1 = p_max_precision;
#line 1257
    l_current_pi ++;
#line 1258
    l_current_poc ++;
    }
#line 1240
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1262 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static void opj_pi_update_decode_not_poc(opj_pi_iterator_t___0 *p_pi , opj_tcp_t___0 *p_tcp ,
                                         OPJ_UINT32 p_max_precision , OPJ_UINT32 p_max_res ) 
{ 
  OPJ_UINT32 pino ;
  OPJ_UINT32 l_bound ;
  opj_pi_iterator_t___0 *l_current_pi ;

  {
#line 1273
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1279
  l_bound = p_tcp->numpocs + 1U;
#line 1280
  l_current_pi = p_pi;
#line 1282
  pino = (OPJ_UINT32 )0;
  {
#line 1282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1282
    if (! (pino < l_bound)) {
#line 1282
      goto while_break;
    }
#line 1283
    l_current_pi->poc.prg = p_tcp->prg;
#line 1284
    l_current_pi->first = 1;
#line 1285
    l_current_pi->poc.resno0 = (OPJ_UINT32 )0;
#line 1286
    l_current_pi->poc.compno0 = (OPJ_UINT32 )0;
#line 1287
    l_current_pi->poc.layno0 = (OPJ_UINT32 )0;
#line 1288
    l_current_pi->poc.precno0 = (OPJ_UINT32 )0;
#line 1289
    l_current_pi->poc.resno1 = p_max_res;
#line 1290
    l_current_pi->poc.compno1 = l_current_pi->numcomps;
#line 1291
    l_current_pi->poc.layno1 = p_tcp->numlayers;
#line 1292
    l_current_pi->poc.precno1 = p_max_precision;
#line 1293
    l_current_pi ++;
#line 1282
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1299 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
static OPJ_BOOL opj_pi_check_next_level(OPJ_INT32 pos , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                                        OPJ_UINT32 pino , OPJ_CHAR *prog ) 
{ 
  OPJ_INT32 i ;
  opj_tcp_t___0 *tcps ;
  opj_poc_t___0 *tcp ;
  OPJ_BOOL __cil_tmp9 ;
  OPJ_BOOL __cil_tmp10 ;
  OPJ_BOOL __cil_tmp11 ;
  OPJ_BOOL __cil_tmp12 ;
  OPJ_BOOL __cil_tmp13 ;
  OPJ_INT32 __cil_tmp14 ;

  {
#line 1306
  tcps = cp->tcps + tileno;
#line 1307
  tcp = & tcps->pocs[pino];
#line 1309
  if (pos >= 0) {
#line 1310
    i = pos;
    {
#line 1310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1310
      if (! (i >= 0)) {
#line 1310
        goto while_break;
      }
      {
#line 1312
      if ((int )*(prog + i) == 'R') {
#line 1312
        goto case_82;
      }
#line 1323
      if ((int )*(prog + i) == 'C') {
#line 1323
        goto case_67;
      }
#line 1334
      if ((int )*(prog + i) == 'L') {
#line 1334
        goto case_76;
      }
#line 1345
      if ((int )*(prog + i) == 'P') {
#line 1345
        goto case_80;
      }
#line 1348
      if ((int )*(prog + i) == 1) {
#line 1348
        goto case_1;
      }
#line 1348
      if ((int )*(prog + i) == 0) {
#line 1348
        goto case_1;
      }
#line 1359
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1313
      if (tcp->res_t == tcp->resE) {
        {
#line 1314
        __cil_tmp9 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1314
        if (__cil_tmp9) {
#line 1315
          return (1);
        } else {
#line 1317
          return (0);
        }
      } else {
#line 1320
        return (1);
      }
#line 1322
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1324
      if (tcp->comp_t == tcp->compE) {
        {
#line 1325
        __cil_tmp10 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1325
        if (__cil_tmp10) {
#line 1326
          return (1);
        } else {
#line 1328
          return (0);
        }
      } else {
#line 1331
        return (1);
      }
#line 1333
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1335
      if (tcp->lay_t == tcp->layE) {
        {
#line 1336
        __cil_tmp11 = opj_pi_check_next_level(pos - 1, cp, tileno, pino, prog);
        }
#line 1336
        if (__cil_tmp11) {
#line 1337
          return (1);
        } else {
#line 1339
          return (0);
        }
      } else {
#line 1342
        return (1);
      }
#line 1344
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1348
      if ((int )tcp->prg == 1) {
#line 1348
        goto case_1;
      }
#line 1348
      if ((int )tcp->prg == 0) {
#line 1348
        goto case_1;
      }
#line 1359
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1349
      if (tcp->prc_t == tcp->prcE) {
        {
#line 1350
        __cil_tmp12 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
        }
#line 1350
        if (__cil_tmp12) {
#line 1351
          return (1);
        } else {
#line 1353
          return (0);
        }
      } else {
#line 1356
        return (1);
      }
#line 1358
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1360
      if (tcp->tx0_t == tcp->txE) {
#line 1362
        if (tcp->ty0_t == tcp->tyE) {
          {
#line 1363
          __cil_tmp13 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
          }
#line 1363
          if (__cil_tmp13) {
#line 1364
            return (1);
          } else {
#line 1366
            return (0);
          }
        } else {
#line 1369
          return (1);
        }
      } else {
#line 1372
        return (1);
      }
#line 1374
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 1310
      __cil_tmp14 = i;
#line 1310
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1379
  return (0);
}
}
#line 1388 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
opj_pi_iterator_t___0 *opj_pi_create_decode(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                            OPJ_UINT32 p_tile_no , opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  opj_pi_iterator_t___0 *__cil_tmp34 ;
  void *__cil_tmp35 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp37 ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 __cil_tmp41 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp43 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 __cil_tmp47 ;

  {
  {
#line 1393
  numcomps = p_image->numcomps;
#line 1413
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1414
  l_tcp = (opj_tcp_t___0 *)0;
#line 1415
  l_tccp = (opj_tccp_t *)0;
#line 1416
  l_current_comp = (opj_pi_comp_t *)0;
#line 1417
  l_img_comp = (opj_image_comp_t *)0;
#line 1418
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1419
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1427
  l_tcp = p_cp->tcps + p_tile_no;
#line 1428
  l_bound = l_tcp->numpocs + 1U;
#line 1430
  l_data_stride = (OPJ_UINT32 )132;
#line 1431
  __cil_tmp32 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1431
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp32;
  }
#line 1433
  if (! l_tmp_data) {
#line 1435
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1437
  __cil_tmp33 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1437
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp33;
  }
#line 1439
  if (! l_tmp_ptr) {
    {
#line 1441
    opj_free(l_tmp_data);
    }
#line 1442
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1446
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no, manager);
  }
#line 1447
  if (! l_pi) {
    {
#line 1448
    opj_free(l_tmp_data);
#line 1449
    opj_free(l_tmp_ptr);
    }
#line 1450
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1453
  l_encoding_value_ptr = l_tmp_data;
#line 1456
  compno = (OPJ_UINT32 )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (compno < numcomps)) {
#line 1455
      goto while_break;
    }
#line 1457
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1458
    l_encoding_value_ptr += l_data_stride;
#line 1456
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1461
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1465
  l_step_p = (OPJ_UINT32 )1;
#line 1466
  l_step_c = l_max_prec * l_step_p;
#line 1467
  l_step_r = numcomps * l_step_c;
#line 1468
  l_step_l = l_max_res * l_step_r;
#line 1471
  l_current_pi = l_pi;
#line 1476
  l_current_pi->include = (OPJ_INT16 *)0;
  }
#line 1477
  if (l_step_l <= 4294967295U / (l_tcp->numlayers + 1U)) {
    {
#line 1478
    l_current_pi->include_size = (l_tcp->numlayers + 1U) * l_step_l;
#line 1479
    __cil_tmp35 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1479
    l_current_pi->include = (OPJ_INT16 *)__cil_tmp35;
    }
  }
#line 1483
  if (! l_current_pi->include) {
    {
#line 1484
    opj_free(l_tmp_data);
#line 1485
    opj_free(l_tmp_ptr);
#line 1486
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1487
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1491
  l_current_comp = l_current_pi->comps;
#line 1492
  l_img_comp = p_image->comps;
#line 1493
  l_tccp = l_tcp->tccps;
#line 1495
  l_current_pi->tx0 = l_tx0;
#line 1496
  l_current_pi->ty0 = l_ty0;
#line 1497
  l_current_pi->tx1 = l_tx1;
#line 1498
  l_current_pi->ty1 = l_ty1;
#line 1503
  l_current_pi->step_p = l_step_p;
#line 1504
  l_current_pi->step_c = l_step_c;
#line 1505
  l_current_pi->step_r = l_step_r;
#line 1506
  l_current_pi->step_l = l_step_l;
#line 1510
  compno = (OPJ_UINT32 )0;
  {
#line 1509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1509
    if (! (compno < numcomps)) {
#line 1509
      goto while_break___0;
    }
#line 1511
    l_res = l_current_comp->resolutions;
#line 1512
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1514
    l_current_comp->dx = l_img_comp->dx;
#line 1515
    l_current_comp->dy = l_img_comp->dy;
#line 1518
    resno = (OPJ_UINT32 )0;
    {
#line 1517
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1517
      if (! (resno < l_current_comp->numresolutions)) {
#line 1517
        goto while_break___1;
      }
#line 1519
      __cil_tmp37 = l_encoding_value_ptr;
#line 1519
      l_encoding_value_ptr ++;
#line 1519
      l_res->pdx = *__cil_tmp37;
#line 1520
      __cil_tmp38 = l_encoding_value_ptr;
#line 1520
      l_encoding_value_ptr ++;
#line 1520
      l_res->pdy = *__cil_tmp38;
#line 1521
      __cil_tmp39 = l_encoding_value_ptr;
#line 1521
      l_encoding_value_ptr ++;
#line 1521
      l_res->pw = *__cil_tmp39;
#line 1522
      __cil_tmp40 = l_encoding_value_ptr;
#line 1522
      l_encoding_value_ptr ++;
#line 1522
      l_res->ph = *__cil_tmp40;
#line 1523
      l_res ++;
#line 1518
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1525
    l_current_comp ++;
#line 1526
    l_img_comp ++;
#line 1527
    l_tccp ++;
#line 1510
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1529
  l_current_pi ++;
#line 1531
  pino = (OPJ_UINT32 )1;
  {
#line 1531
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1531
    if (! (pino < l_bound)) {
#line 1531
      goto while_break___2;
    }
#line 1532
    l_current_comp = l_current_pi->comps;
#line 1533
    l_img_comp = p_image->comps;
#line 1534
    l_tccp = l_tcp->tccps;
#line 1536
    l_current_pi->tx0 = l_tx0;
#line 1537
    l_current_pi->ty0 = l_ty0;
#line 1538
    l_current_pi->tx1 = l_tx1;
#line 1539
    l_current_pi->ty1 = l_ty1;
#line 1542
    l_current_pi->step_p = l_step_p;
#line 1543
    l_current_pi->step_c = l_step_c;
#line 1544
    l_current_pi->step_r = l_step_r;
#line 1545
    l_current_pi->step_l = l_step_l;
#line 1549
    compno = (OPJ_UINT32 )0;
    {
#line 1548
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1548
      if (! (compno < numcomps)) {
#line 1548
        goto while_break___3;
      }
#line 1550
      l_res___0 = l_current_comp->resolutions;
#line 1551
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1553
      l_current_comp->dx = l_img_comp->dx;
#line 1554
      l_current_comp->dy = l_img_comp->dy;
#line 1557
      resno = (OPJ_UINT32 )0;
      {
#line 1556
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1556
        if (! (resno < l_current_comp->numresolutions)) {
#line 1556
          goto while_break___4;
        }
#line 1558
        __cil_tmp43 = l_encoding_value_ptr;
#line 1558
        l_encoding_value_ptr ++;
#line 1558
        l_res___0->pdx = *__cil_tmp43;
#line 1559
        __cil_tmp44 = l_encoding_value_ptr;
#line 1559
        l_encoding_value_ptr ++;
#line 1559
        l_res___0->pdy = *__cil_tmp44;
#line 1560
        __cil_tmp45 = l_encoding_value_ptr;
#line 1560
        l_encoding_value_ptr ++;
#line 1560
        l_res___0->pw = *__cil_tmp45;
#line 1561
        __cil_tmp46 = l_encoding_value_ptr;
#line 1561
        l_encoding_value_ptr ++;
#line 1561
        l_res___0->ph = *__cil_tmp46;
#line 1562
        l_res___0 ++;
#line 1557
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1564
      l_current_comp ++;
#line 1565
      l_img_comp ++;
#line 1566
      l_tccp ++;
#line 1549
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1569
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1570
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1571
    l_current_pi ++;
#line 1531
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1573
  opj_free(l_tmp_data);
#line 1574
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1575
  opj_free(l_tmp_ptr);
#line 1576
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1577
  if (l_tcp->POC) {
    {
#line 1579
    opj_pi_update_decode_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  } else {
    {
#line 1581
    opj_pi_update_decode_not_poc(l_pi, l_tcp, l_max_prec, l_max_res);
    }
  }
#line 1583
  return (l_pi);
}
}
#line 1587 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
OPJ_UINT32 opj_get_encoding_packet_count(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                         OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;

  {
  {
#line 1602
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  (OPJ_UINT32 **)((void *)0));
  }
#line 1605
  return ((((p_cp->tcps + p_tile_no)->numlayers * l_max_prec) * p_image->numcomps) * l_max_res);
}
}
#line 1610 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
opj_pi_iterator_t___0 *opj_pi_initialise_encode(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                                OPJ_UINT32 p_tile_no , J2K_T2_MODE p_t2_mode ,
                                                opj_event_mgr_t *manager ) 
{ 
  OPJ_UINT32 numcomps ;
  OPJ_UINT32 pino ;
  OPJ_UINT32 compno ;
  OPJ_UINT32 resno ;
  OPJ_UINT32 *l_tmp_data ;
  OPJ_UINT32 **l_tmp_ptr ;
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  OPJ_UINT32 l_bound ;
  OPJ_UINT32 l_step_p ;
  OPJ_UINT32 l_step_c ;
  OPJ_UINT32 l_step_r ;
  OPJ_UINT32 l_step_l ;
  OPJ_UINT32 l_data_stride ;
  opj_pi_iterator_t___0 *l_pi ;
  opj_tcp_t___0 *l_tcp ;
  opj_tccp_t *l_tccp ;
  opj_pi_comp_t *l_current_comp ;
  opj_image_comp_t *l_img_comp ;
  opj_pi_iterator_t___0 *l_current_pi ;
  OPJ_UINT32 *l_encoding_value_ptr ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  opj_pi_iterator_t___0 *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_pi_resolution_t *l_res ;
  OPJ_UINT32 *__cil_tmp38 ;
  OPJ_UINT32 *__cil_tmp39 ;
  OPJ_UINT32 *__cil_tmp40 ;
  OPJ_UINT32 *__cil_tmp41 ;
  OPJ_UINT32 __cil_tmp42 ;
  opj_pi_resolution_t *l_res___0 ;
  OPJ_UINT32 *__cil_tmp44 ;
  OPJ_UINT32 *__cil_tmp45 ;
  OPJ_UINT32 *__cil_tmp46 ;
  OPJ_UINT32 *__cil_tmp47 ;
  OPJ_UINT32 __cil_tmp48 ;

  {
  {
#line 1616
  numcomps = p_image->numcomps;
#line 1636
  l_pi = (opj_pi_iterator_t___0 *)0;
#line 1637
  l_tcp = (opj_tcp_t___0 *)0;
#line 1638
  l_tccp = (opj_tccp_t *)0;
#line 1639
  l_current_comp = (opj_pi_comp_t *)0;
#line 1640
  l_img_comp = (opj_image_comp_t *)0;
#line 1641
  l_current_pi = (opj_pi_iterator_t___0 *)0;
#line 1642
  l_encoding_value_ptr = (OPJ_UINT32 *)0;
#line 1650
  l_tcp = p_cp->tcps + p_tile_no;
#line 1651
  l_bound = l_tcp->numpocs + 1U;
#line 1653
  l_data_stride = (OPJ_UINT32 )132;
#line 1654
  __cil_tmp33 = opj_malloc((unsigned long )(l_data_stride * numcomps) * sizeof(OPJ_UINT32 ));
#line 1654
  l_tmp_data = (OPJ_UINT32 *)__cil_tmp33;
  }
#line 1656
  if (! l_tmp_data) {
#line 1657
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1660
  __cil_tmp34 = opj_malloc((unsigned long )numcomps * sizeof(OPJ_UINT32 *));
#line 1660
  l_tmp_ptr = (OPJ_UINT32 **)__cil_tmp34;
  }
#line 1662
  if (! l_tmp_ptr) {
    {
#line 1663
    opj_free(l_tmp_data);
    }
#line 1664
    return ((opj_pi_iterator_t___0 *)0);
  }
  {
#line 1668
  l_pi = opj_pi_create(p_image, p_cp, p_tile_no, manager);
  }
#line 1669
  if (! l_pi) {
    {
#line 1670
    opj_free(l_tmp_data);
#line 1671
    opj_free(l_tmp_ptr);
    }
#line 1672
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1675
  l_encoding_value_ptr = l_tmp_data;
#line 1677
  compno = (OPJ_UINT32 )0;
  {
#line 1677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1677
    if (! (compno < numcomps)) {
#line 1677
      goto while_break;
    }
#line 1678
    *(l_tmp_ptr + compno) = l_encoding_value_ptr;
#line 1679
    l_encoding_value_ptr += l_data_stride;
#line 1677
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1683
  opj_get_all_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                                  & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res,
                                  l_tmp_ptr);
#line 1687
  l_step_p = (OPJ_UINT32 )1;
#line 1688
  l_step_c = l_max_prec * l_step_p;
#line 1689
  l_step_r = numcomps * l_step_c;
#line 1690
  l_step_l = l_max_res * l_step_r;
#line 1693
  l_pi->tp_on = (OPJ_BYTE )p_cp->m_specific_param.m_enc.m_tp_on;
#line 1694
  l_current_pi = l_pi;
#line 1697
  l_current_pi->include_size = l_tcp->numlayers * l_step_l;
#line 1698
  __cil_tmp36 = opj_calloc((size_t )l_current_pi->include_size, sizeof(OPJ_INT16 ));
#line 1698
  l_current_pi->include = (OPJ_INT16 *)__cil_tmp36;
  }
#line 1700
  if (! l_current_pi->include) {
    {
#line 1701
    opj_free(l_tmp_data);
#line 1702
    opj_free(l_tmp_ptr);
#line 1703
    opj_pi_destroy(l_pi, l_bound);
    }
#line 1704
    return ((opj_pi_iterator_t___0 *)0);
  }
#line 1708
  l_current_comp = l_current_pi->comps;
#line 1709
  l_img_comp = p_image->comps;
#line 1710
  l_tccp = l_tcp->tccps;
#line 1711
  l_current_pi->tx0 = l_tx0;
#line 1712
  l_current_pi->ty0 = l_ty0;
#line 1713
  l_current_pi->tx1 = l_tx1;
#line 1714
  l_current_pi->ty1 = l_ty1;
#line 1715
  l_current_pi->dx = l_dx_min;
#line 1716
  l_current_pi->dy = l_dy_min;
#line 1717
  l_current_pi->step_p = l_step_p;
#line 1718
  l_current_pi->step_c = l_step_c;
#line 1719
  l_current_pi->step_r = l_step_r;
#line 1720
  l_current_pi->step_l = l_step_l;
#line 1723
  compno = (OPJ_UINT32 )0;
  {
#line 1723
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1723
    if (! (compno < numcomps)) {
#line 1723
      goto while_break___0;
    }
#line 1724
    l_res = l_current_comp->resolutions;
#line 1725
    l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1727
    l_current_comp->dx = l_img_comp->dx;
#line 1728
    l_current_comp->dy = l_img_comp->dy;
#line 1731
    resno = (OPJ_UINT32 )0;
    {
#line 1731
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1731
      if (! (resno < l_current_comp->numresolutions)) {
#line 1731
        goto while_break___1;
      }
#line 1732
      __cil_tmp38 = l_encoding_value_ptr;
#line 1732
      l_encoding_value_ptr ++;
#line 1732
      l_res->pdx = *__cil_tmp38;
#line 1733
      __cil_tmp39 = l_encoding_value_ptr;
#line 1733
      l_encoding_value_ptr ++;
#line 1733
      l_res->pdy = *__cil_tmp39;
#line 1734
      __cil_tmp40 = l_encoding_value_ptr;
#line 1734
      l_encoding_value_ptr ++;
#line 1734
      l_res->pw = *__cil_tmp40;
#line 1735
      __cil_tmp41 = l_encoding_value_ptr;
#line 1735
      l_encoding_value_ptr ++;
#line 1735
      l_res->ph = *__cil_tmp41;
#line 1736
      l_res ++;
#line 1731
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1739
    l_current_comp ++;
#line 1740
    l_img_comp ++;
#line 1741
    l_tccp ++;
#line 1723
    compno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1743
  l_current_pi ++;
#line 1745
  pino = (OPJ_UINT32 )1;
  {
#line 1745
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1745
    if (! (pino < l_bound)) {
#line 1745
      goto while_break___2;
    }
#line 1746
    l_current_comp = l_current_pi->comps;
#line 1747
    l_img_comp = p_image->comps;
#line 1748
    l_tccp = l_tcp->tccps;
#line 1750
    l_current_pi->tx0 = l_tx0;
#line 1751
    l_current_pi->ty0 = l_ty0;
#line 1752
    l_current_pi->tx1 = l_tx1;
#line 1753
    l_current_pi->ty1 = l_ty1;
#line 1754
    l_current_pi->dx = l_dx_min;
#line 1755
    l_current_pi->dy = l_dy_min;
#line 1756
    l_current_pi->step_p = l_step_p;
#line 1757
    l_current_pi->step_c = l_step_c;
#line 1758
    l_current_pi->step_r = l_step_r;
#line 1759
    l_current_pi->step_l = l_step_l;
#line 1762
    compno = (OPJ_UINT32 )0;
    {
#line 1762
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1762
      if (! (compno < numcomps)) {
#line 1762
        goto while_break___3;
      }
#line 1763
      l_res___0 = l_current_comp->resolutions;
#line 1764
      l_encoding_value_ptr = *(l_tmp_ptr + compno);
#line 1766
      l_current_comp->dx = l_img_comp->dx;
#line 1767
      l_current_comp->dy = l_img_comp->dy;
#line 1769
      resno = (OPJ_UINT32 )0;
      {
#line 1769
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1769
        if (! (resno < l_current_comp->numresolutions)) {
#line 1769
          goto while_break___4;
        }
#line 1770
        __cil_tmp44 = l_encoding_value_ptr;
#line 1770
        l_encoding_value_ptr ++;
#line 1770
        l_res___0->pdx = *__cil_tmp44;
#line 1771
        __cil_tmp45 = l_encoding_value_ptr;
#line 1771
        l_encoding_value_ptr ++;
#line 1771
        l_res___0->pdy = *__cil_tmp45;
#line 1772
        __cil_tmp46 = l_encoding_value_ptr;
#line 1772
        l_encoding_value_ptr ++;
#line 1772
        l_res___0->pw = *__cil_tmp46;
#line 1773
        __cil_tmp47 = l_encoding_value_ptr;
#line 1773
        l_encoding_value_ptr ++;
#line 1773
        l_res___0->ph = *__cil_tmp47;
#line 1774
        l_res___0 ++;
#line 1769
        resno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1776
      l_current_comp ++;
#line 1777
      l_img_comp ++;
#line 1778
      l_tccp ++;
#line 1762
      compno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1782
    l_current_pi->include = (l_current_pi - 1)->include;
#line 1783
    l_current_pi->include_size = (l_current_pi - 1)->include_size;
#line 1784
    l_current_pi ++;
#line 1745
    pino ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1787
  opj_free(l_tmp_data);
#line 1788
  l_tmp_data = (OPJ_UINT32 *)0;
#line 1789
  opj_free(l_tmp_ptr);
#line 1790
  l_tmp_ptr = (OPJ_UINT32 **)0;
  }
#line 1792
  if ((int )l_tcp->POC) {
#line 1792
    if ((int )p_cp->rsiz >= 3) {
#line 1792
      if ((int )p_cp->rsiz <= 6) {
        {
        {
#line 1793
        opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                           l_max_prec, l_max_res, l_dx_min, l_dy_min);
        }
        }
      } else {
#line 1792
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1792
    if ((unsigned int )p_t2_mode == 1U) {
      {
      {
#line 1793
      opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                         l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
      }
    } else {
      {
      {
#line 1796
      opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0,
                                   l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
      }
      }
    }
  } else {
    {
    {
#line 1796
    opj_pi_update_encode_not_poc(p_cp, numcomps, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                 l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
    }
  }
#line 1800
  return (l_pi);
}
}
#line 1803 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_create_encode(opj_pi_iterator_t___0 *pi , opj_cp_t___0 *cp , OPJ_UINT32 tileno ,
                          OPJ_UINT32 pino , OPJ_UINT32 tpnum , OPJ_INT32 tppos , J2K_T2_MODE t2_mode ) 
{ 
  OPJ_CHAR *prog ;
  OPJ_INT32 i ;
  OPJ_UINT32 incr_top ;
  OPJ_UINT32 resetX ;
  opj_tcp_t___0 *tcps ;
  opj_poc_t___0 *tcp ;
  char const   *__cil_tmp14 ;
  OPJ_INT32 __cil_tmp15 ;
  OPJ_INT32 __cil_tmp16 ;
  OPJ_BOOL __cil_tmp17 ;
  OPJ_BOOL __cil_tmp18 ;
  OPJ_BOOL __cil_tmp19 ;
  OPJ_BOOL __cil_tmp20 ;
  OPJ_BOOL __cil_tmp21 ;
  OPJ_INT32 __cil_tmp22 ;

  {
#line 1813
  incr_top = (OPJ_UINT32 )1;
  {
#line 1813
  resetX = (OPJ_UINT32 )0;
#line 1814
  tcps = cp->tcps + tileno;
#line 1815
  tcp = & tcps->pocs[pino];
#line 1817
  prog = (OPJ_CHAR *)opj_j2k_convert_progression_order(tcp->prg);
#line 1819
  (pi + pino)->first = 1;
#line 1820
  (pi + pino)->poc.prg = tcp->prg;
  }
#line 1822
  if (! ((int )cp->m_specific_param.m_enc.m_tp_on && ((((! ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6) && ! ((int )cp->rsiz >= 1024 && (int )cp->rsiz <= 2459)) && (unsigned int )t2_mode == 1U) || ((int )cp->rsiz >= 3 && (int )cp->rsiz <= 6)) || ((int )cp->rsiz >= 1024 && (int )cp->rsiz <= 2459)))) {
#line 1825
    (pi + pino)->poc.resno0 = tcp->resS;
#line 1826
    (pi + pino)->poc.resno1 = tcp->resE;
#line 1827
    (pi + pino)->poc.compno0 = tcp->compS;
#line 1828
    (pi + pino)->poc.compno1 = tcp->compE;
#line 1829
    (pi + pino)->poc.layno0 = tcp->layS;
#line 1830
    (pi + pino)->poc.layno1 = tcp->layE;
#line 1831
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 1832
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 1833
    (pi + pino)->poc.tx0 = tcp->txS;
#line 1834
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 1835
    (pi + pino)->poc.tx1 = tcp->txE;
#line 1836
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else {
#line 1838
    i = tppos + 1;
    {
#line 1838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1838
      if (! (i < 4)) {
#line 1838
        goto while_break;
      }
      {
#line 1840
      if ((int )*(prog + i) == 'R') {
#line 1840
        goto case_82;
      }
#line 1844
      if ((int )*(prog + i) == 'C') {
#line 1844
        goto case_67;
      }
#line 1848
      if ((int )*(prog + i) == 'L') {
#line 1848
        goto case_76;
      }
#line 1852
      if ((int )*(prog + i) == 'P') {
#line 1852
        goto case_80;
      }
#line 1855
      if ((int )*(prog + i) == 1) {
#line 1855
        goto case_1;
      }
#line 1855
      if ((int )*(prog + i) == 0) {
#line 1855
        goto case_1;
      }
#line 1859
      goto switch_default;
      case_82: /* CIL Label */ 
#line 1841
      (pi + pino)->poc.resno0 = tcp->resS;
#line 1842
      (pi + pino)->poc.resno1 = tcp->resE;
#line 1843
      goto switch_break;
      case_67: /* CIL Label */ 
#line 1845
      (pi + pino)->poc.compno0 = tcp->compS;
#line 1846
      (pi + pino)->poc.compno1 = tcp->compE;
#line 1847
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1849
      (pi + pino)->poc.layno0 = tcp->layS;
#line 1850
      (pi + pino)->poc.layno1 = tcp->layE;
#line 1851
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1855
      if ((int )tcp->prg == 1) {
#line 1855
        goto case_1;
      }
#line 1855
      if ((int )tcp->prg == 0) {
#line 1855
        goto case_1;
      }
#line 1859
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1856
      (pi + pino)->poc.precno0 = tcp->prcS;
#line 1857
      (pi + pino)->poc.precno1 = tcp->prcE;
#line 1858
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 1860
      (pi + pino)->poc.tx0 = tcp->txS;
#line 1861
      (pi + pino)->poc.ty0 = tcp->tyS;
#line 1862
      (pi + pino)->poc.tx1 = tcp->txE;
#line 1863
      (pi + pino)->poc.ty1 = tcp->tyE;
#line 1864
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1866
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1838
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1870
    if (tpnum == 0U) {
#line 1871
      i = tppos;
      {
#line 1871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1871
        if (! (i >= 0)) {
#line 1871
          goto while_break___0;
        }
        {
#line 1873
        if ((int )*(prog + i) == 'C') {
#line 1873
          goto case_67___0;
        }
#line 1879
        if ((int )*(prog + i) == 'R') {
#line 1879
          goto case_82___0;
        }
#line 1885
        if ((int )*(prog + i) == 'L') {
#line 1885
          goto case_76___0;
        }
#line 1891
        if ((int )*(prog + i) == 'P') {
#line 1891
          goto case_80___0;
        }
#line 1894
        if ((int )*(prog + i) == 1) {
#line 1894
          goto case_1___0;
        }
#line 1894
        if ((int )*(prog + i) == 0) {
#line 1894
          goto case_1___0;
        }
#line 1900
        goto switch_default___0;
        case_67___0: /* CIL Label */ 
#line 1874
        tcp->comp_t = tcp->compS;
#line 1875
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1876
        (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1877
        tcp->comp_t += (unsigned int )1;
#line 1878
        goto switch_break___1;
        case_82___0: /* CIL Label */ 
#line 1880
        tcp->res_t = tcp->resS;
#line 1881
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 1882
        (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1883
        tcp->res_t += (unsigned int )1;
#line 1884
        goto switch_break___1;
        case_76___0: /* CIL Label */ 
#line 1886
        tcp->lay_t = tcp->layS;
#line 1887
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1888
        (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1889
        tcp->lay_t += (unsigned int )1;
#line 1890
        goto switch_break___1;
        case_80___0: /* CIL Label */ 
        {
#line 1894
        if ((int )tcp->prg == 1) {
#line 1894
          goto case_1___0;
        }
#line 1894
        if ((int )tcp->prg == 0) {
#line 1894
          goto case_1___0;
        }
#line 1900
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 1895
        tcp->prc_t = tcp->prcS;
#line 1896
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 1897
        (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 1898
        tcp->prc_t += (unsigned int )1;
#line 1899
        goto switch_break___2;
        switch_default___0: /* CIL Label */ 
#line 1901
        tcp->tx0_t = tcp->txS;
#line 1902
        tcp->ty0_t = tcp->tyS;
#line 1903
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 1904
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 1905
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 1906
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 1907
        tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 1908
        tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 1909
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 1911
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1871
        __cil_tmp16 = i;
#line 1871
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1914
      incr_top = (OPJ_UINT32 )1;
    } else {
#line 1916
      i = tppos;
      {
#line 1916
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1916
        if (! (i >= 0)) {
#line 1916
          goto while_break___1;
        }
        {
#line 1918
        if ((int )*(prog + i) == 'C') {
#line 1918
          goto case_67___1;
        }
#line 1922
        if ((int )*(prog + i) == 'R') {
#line 1922
          goto case_82___1;
        }
#line 1926
        if ((int )*(prog + i) == 'L') {
#line 1926
          goto case_76___1;
        }
#line 1930
        if ((int )*(prog + i) == 'P') {
#line 1930
          goto case_80___1;
        }
#line 1933
        if ((int )*(prog + i) == 1) {
#line 1933
          goto case_1___1;
        }
#line 1933
        if ((int )*(prog + i) == 0) {
#line 1933
          goto case_1___1;
        }
#line 1937
        goto switch_default___1;
        case_67___1: /* CIL Label */ 
#line 1919
        (pi + pino)->poc.compno0 = tcp->comp_t - 1U;
#line 1920
        (pi + pino)->poc.compno1 = tcp->comp_t;
#line 1921
        goto switch_break___3;
        case_82___1: /* CIL Label */ 
#line 1923
        (pi + pino)->poc.resno0 = tcp->res_t - 1U;
#line 1924
        (pi + pino)->poc.resno1 = tcp->res_t;
#line 1925
        goto switch_break___3;
        case_76___1: /* CIL Label */ 
#line 1927
        (pi + pino)->poc.layno0 = tcp->lay_t - 1U;
#line 1928
        (pi + pino)->poc.layno1 = tcp->lay_t;
#line 1929
        goto switch_break___3;
        case_80___1: /* CIL Label */ 
        {
#line 1933
        if ((int )tcp->prg == 1) {
#line 1933
          goto case_1___1;
        }
#line 1933
        if ((int )tcp->prg == 0) {
#line 1933
          goto case_1___1;
        }
#line 1937
        goto switch_default___1;
        case_1___1: /* CIL Label */ 
        case_0___1: /* CIL Label */ 
#line 1934
        (pi + pino)->poc.precno0 = tcp->prc_t - 1U;
#line 1935
        (pi + pino)->poc.precno1 = tcp->prc_t;
#line 1936
        goto switch_break___4;
        switch_default___1: /* CIL Label */ 
#line 1938
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 1939
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 1940
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 1941
        (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 1942
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 1944
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 1946
        if (incr_top == 1U) {
          {
#line 1948
          if ((int )*(prog + i) == 'R') {
#line 1948
            goto case_82___2;
          }
#line 1966
          if ((int )*(prog + i) == 'C') {
#line 1966
            goto case_67___2;
          }
#line 1984
          if ((int )*(prog + i) == 'L') {
#line 1984
            goto case_76___2;
          }
#line 2002
          if ((int )*(prog + i) == 'P') {
#line 2002
            goto case_80___2;
          }
#line 2005
          if ((int )*(prog + i) == 1) {
#line 2005
            goto case_1___2;
          }
#line 2005
          if ((int )*(prog + i) == 0) {
#line 2005
            goto case_1___2;
          }
#line 2023
          goto switch_default___2;
          case_82___2: /* CIL Label */ 
#line 1949
          if (tcp->res_t == tcp->resE) {
            {
#line 1950
            __cil_tmp17 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1950
            if (__cil_tmp17) {
#line 1951
              tcp->res_t = tcp->resS;
#line 1952
              (pi + pino)->poc.resno0 = tcp->res_t;
#line 1953
              (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1954
              tcp->res_t += (unsigned int )1;
#line 1955
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1957
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1960
            (pi + pino)->poc.resno0 = tcp->res_t;
#line 1961
            (pi + pino)->poc.resno1 = tcp->res_t + 1U;
#line 1962
            tcp->res_t += (unsigned int )1;
#line 1963
            incr_top = (OPJ_UINT32 )0;
          }
#line 1965
          goto switch_break___5;
          case_67___2: /* CIL Label */ 
#line 1967
          if (tcp->comp_t == tcp->compE) {
            {
#line 1968
            __cil_tmp18 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1968
            if (__cil_tmp18) {
#line 1969
              tcp->comp_t = tcp->compS;
#line 1970
              (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1971
              (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1972
              tcp->comp_t += (unsigned int )1;
#line 1973
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1975
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1978
            (pi + pino)->poc.compno0 = tcp->comp_t;
#line 1979
            (pi + pino)->poc.compno1 = tcp->comp_t + 1U;
#line 1980
            tcp->comp_t += (unsigned int )1;
#line 1981
            incr_top = (OPJ_UINT32 )0;
          }
#line 1983
          goto switch_break___5;
          case_76___2: /* CIL Label */ 
#line 1985
          if (tcp->lay_t == tcp->layE) {
            {
#line 1986
            __cil_tmp19 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 1986
            if (__cil_tmp19) {
#line 1987
              tcp->lay_t = tcp->layS;
#line 1988
              (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1989
              (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1990
              tcp->lay_t += (unsigned int )1;
#line 1991
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 1993
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 1996
            (pi + pino)->poc.layno0 = tcp->lay_t;
#line 1997
            (pi + pino)->poc.layno1 = tcp->lay_t + 1U;
#line 1998
            tcp->lay_t += (unsigned int )1;
#line 1999
            incr_top = (OPJ_UINT32 )0;
          }
#line 2001
          goto switch_break___5;
          case_80___2: /* CIL Label */ 
          {
#line 2005
          if ((int )tcp->prg == 1) {
#line 2005
            goto case_1___2;
          }
#line 2005
          if ((int )tcp->prg == 0) {
#line 2005
            goto case_1___2;
          }
#line 2023
          goto switch_default___2;
          case_1___2: /* CIL Label */ 
          case_0___2: /* CIL Label */ 
#line 2006
          if (tcp->prc_t == tcp->prcE) {
            {
#line 2007
            __cil_tmp20 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
            }
#line 2007
            if (__cil_tmp20) {
#line 2008
              tcp->prc_t = tcp->prcS;
#line 2009
              (pi + pino)->poc.precno0 = tcp->prc_t;
#line 2010
              (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 2011
              tcp->prc_t += (unsigned int )1;
#line 2012
              incr_top = (OPJ_UINT32 )1;
            } else {
#line 2014
              incr_top = (OPJ_UINT32 )0;
            }
          } else {
#line 2017
            (pi + pino)->poc.precno0 = tcp->prc_t;
#line 2018
            (pi + pino)->poc.precno1 = tcp->prc_t + 1U;
#line 2019
            tcp->prc_t += (unsigned int )1;
#line 2020
            incr_top = (OPJ_UINT32 )0;
          }
#line 2022
          goto switch_break___6;
          switch_default___2: /* CIL Label */ 
#line 2024
          if (tcp->tx0_t >= tcp->txE) {
#line 2025
            if (tcp->ty0_t >= tcp->tyE) {
              {
#line 2026
              __cil_tmp21 = opj_pi_check_next_level(i - 1, cp, tileno, pino, prog);
              }
#line 2026
              if (__cil_tmp21) {
#line 2027
                tcp->ty0_t = tcp->tyS;
#line 2028
                (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 2029
                (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 2030
                tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 2031
                incr_top = (OPJ_UINT32 )1;
#line 2032
                resetX = (OPJ_UINT32 )1;
              } else {
#line 2034
                incr_top = (OPJ_UINT32 )0;
#line 2035
                resetX = (OPJ_UINT32 )0;
              }
            } else {
#line 2038
              (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 2039
              (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 2040
              tcp->ty0_t = (OPJ_UINT32 )(pi + pino)->poc.ty1;
#line 2041
              incr_top = (OPJ_UINT32 )0;
#line 2042
              resetX = (OPJ_UINT32 )1;
            }
#line 2044
            if (resetX == 1U) {
#line 2045
              tcp->tx0_t = tcp->txS;
#line 2046
              (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 2047
              (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 2048
              tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
            }
          } else {
#line 2051
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 2052
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 2053
            tcp->tx0_t = (OPJ_UINT32 )(pi + pino)->poc.tx1;
#line 2054
            incr_top = (OPJ_UINT32 )0;
          }
#line 2056
          goto switch_break___6;
          switch_break___6: /* CIL Label */ ;
          }
#line 2058
          goto switch_break___5;
          switch_break___5: /* CIL Label */ ;
          }
        }
#line 1916
        __cil_tmp22 = i;
#line 1916
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 2066 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_destroy(opj_pi_iterator_t___0 *p_pi , OPJ_UINT32 p_nb_elements ) 
{ 
  OPJ_UINT32 compno ;
  OPJ_UINT32 pino ;
  opj_pi_iterator_t___0 *l_current_pi ;
  opj_pi_comp_t *l_current_component ;
  OPJ_UINT32 __cil_tmp7 ;

  {
#line 2070
  l_current_pi = p_pi;
#line 2071
  if (p_pi) {
#line 2072
    if (p_pi->include) {
      {
#line 2073
      opj_free(p_pi->include);
#line 2074
      p_pi->include = (OPJ_INT16 *)0;
      }
    }
#line 2076
    pino = (OPJ_UINT32 )0;
    {
#line 2076
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2076
      if (! (pino < p_nb_elements)) {
#line 2076
        goto while_break;
      }
#line 2077
      if (l_current_pi->comps) {
#line 2078
        l_current_component = l_current_pi->comps;
#line 2079
        compno = (OPJ_UINT32 )0;
        {
#line 2079
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2079
          if (! (compno < l_current_pi->numcomps)) {
#line 2079
            goto while_break___0;
          }
#line 2080
          if (l_current_component->resolutions) {
            {
#line 2081
            opj_free(l_current_component->resolutions);
#line 2082
            l_current_component->resolutions = (opj_pi_resolution_t *)0;
            }
          }
#line 2085
          l_current_component ++;
#line 2079
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 2087
        opj_free(l_current_pi->comps);
#line 2088
        l_current_pi->comps = (opj_pi_comp_t *)0;
        }
      }
#line 2090
      l_current_pi ++;
#line 2076
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2092
    opj_free(p_pi);
    }
  }
  return;
}
}
#line 2098 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
void opj_pi_update_encoding_parameters(opj_image_t *p_image , opj_cp_t___0 *p_cp ,
                                       OPJ_UINT32 p_tile_no ) 
{ 
  OPJ_UINT32 l_max_res ;
  OPJ_UINT32 l_max_prec ;
  OPJ_UINT32 l_tx0 ;
  OPJ_UINT32 l_tx1 ;
  OPJ_UINT32 l_ty0 ;
  OPJ_UINT32 l_ty1 ;
  OPJ_UINT32 l_dx_min ;
  OPJ_UINT32 l_dy_min ;
  opj_tcp_t___0 *l_tcp ;

  {
  {
#line 2109
  l_tcp = (opj_tcp_t___0 *)0;
#line 2116
  l_tcp = p_cp->tcps + p_tile_no;
#line 2119
  opj_get_encoding_parameters(p_image, p_cp, p_tile_no, & l_tx0, & l_tx1, & l_ty0,
                              & l_ty1, & l_dx_min, & l_dy_min, & l_max_prec, & l_max_res);
  }
#line 2122
  if (l_tcp->POC) {
    {
#line 2123
    opj_pi_update_encode_poc_and_final(p_cp, p_tile_no, l_tx0, l_tx1, l_ty0, l_ty1,
                                       l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  } else {
    {
#line 2126
    opj_pi_update_encode_not_poc(p_cp, p_image->numcomps, p_tile_no, l_tx0, l_tx1,
                                 l_ty0, l_ty1, l_max_prec, l_max_res, l_dx_min, l_dy_min);
    }
  }
  return;
}
}
#line 2131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/pi.c"
OPJ_BOOL opj_pi_next(opj_pi_iterator_t___0 *pi ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;
  OPJ_BOOL __cil_tmp4 ;
  OPJ_BOOL __cil_tmp5 ;
  OPJ_BOOL __cil_tmp6 ;

  {
  {
#line 2134
  if ((int )pi->poc.prg == 0) {
#line 2134
    goto case_0;
  }
#line 2136
  if ((int )pi->poc.prg == 1) {
#line 2136
    goto case_1;
  }
#line 2138
  if ((int )pi->poc.prg == 2) {
#line 2138
    goto case_2;
  }
#line 2140
  if ((int )pi->poc.prg == 3) {
#line 2140
    goto case_3;
  }
#line 2142
  if ((int )pi->poc.prg == 4) {
#line 2142
    goto case_4;
  }
#line 2144
  if ((int )pi->poc.prg == -1) {
#line 2144
    goto case_neg_1;
  }
#line 2133
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2135
  __cil_tmp2 = opj_pi_next_lrcp(pi);
  }
#line 2135
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 2137
  __cil_tmp3 = opj_pi_next_rlcp(pi);
  }
#line 2137
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 2139
  __cil_tmp4 = opj_pi_next_rpcl(pi);
  }
#line 2139
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 2141
  __cil_tmp5 = opj_pi_next_pcrl(pi);
  }
#line 2141
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 2143
  __cil_tmp6 = opj_pi_next_cprl(pi);
  }
#line 2143
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 2145
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 2148
  return (0);
}
}
#line 51 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) ;
#line 57
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) ;
#line 63
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) ;
#line 75 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 77
  bio->buf = (bio->buf << 8) & 65535U;
#line 78
  if (bio->buf == 65280U) {
#line 78
    tmp = 7;
  } else {
#line 78
    tmp = 8;
  }
#line 78
  bio->ct = (OPJ_UINT32 )tmp;
#line 79
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 80
    return (0);
  }
#line 82
  __cil_tmp3 = bio->bp;
#line 82
  (bio->bp) ++;
#line 82
  *__cil_tmp3 = (OPJ_BYTE )(bio->buf >> 8);
#line 83
  return (1);
}
}
#line 86 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  OPJ_BYTE *__cil_tmp3 ;

  {
#line 88
  bio->buf = (bio->buf << 8) & 65535U;
#line 89
  if (bio->buf == 65280U) {
#line 89
    tmp = 7;
  } else {
#line 89
    tmp = 8;
  }
#line 89
  bio->ct = (OPJ_UINT32 )tmp;
#line 90
  if ((OPJ_SIZE_T )bio->bp >= (OPJ_SIZE_T )bio->end) {
#line 91
    return (0);
  }
#line 93
  __cil_tmp3 = bio->bp;
#line 93
  (bio->bp) ++;
#line 93
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 94
  return (1);
}
}
#line 97 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio ) 
{ 
  OPJ_UINT32 __cil_tmp2 ;

  {
#line 99
  if (bio->ct == 0U) {
    {
#line 100
    opj_bio_bytein(bio);
    }
  }
#line 103
  __cil_tmp2 = bio->ct;
#line 103
  (bio->ct) --;
#line 104
  return ((bio->buf >> bio->ct) & 1U);
}
}
#line 113 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
opj_bio_t *opj_bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 115
  __cil_tmp2 = opj_malloc(sizeof(opj_bio_t ));
#line 115
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 116
  return (bio);
}
}
#line 119 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 121
  if (bio) {
    {
#line 122
    opj_free(bio);
    }
  }
  return;
}
}
#line 126 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
ptrdiff_t opj_bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 128
  return (bio->bp - bio->start);
}
}
#line 131 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_init_enc(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (OPJ_UINT32 )0;
#line 137
  bio->ct = (OPJ_UINT32 )8;
  return;
}
}
#line 140 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_init_dec(opj_bio_t *bio , OPJ_BYTE *bp , OPJ_UINT32 len ) 
{ 


  {
#line 142
  bio->start = bp;
#line 143
  bio->end = bp + len;
#line 144
  bio->bp = bp;
#line 145
  bio->buf = (OPJ_UINT32 )0;
#line 146
  bio->ct = (OPJ_UINT32 )0;
  return;
}
}
#line 149 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_putbit(opj_bio_t *bio , OPJ_UINT32 b ) 
{ 
  OPJ_UINT32 __cil_tmp3 ;

  {
#line 151
  if (bio->ct == 0U) {
    {
#line 152
    opj_bio_byteout(bio);
    }
  }
#line 155
  __cil_tmp3 = bio->ct;
#line 155
  (bio->ct) --;
#line 156
  bio->buf |= b << bio->ct;
  return;
}
}
#line 159 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
void opj_bio_write(opj_bio_t *bio , OPJ_UINT32 v , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_INT32 __cil_tmp5 ;

  {
#line 164
  i = (OPJ_INT32 )n - 1;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i >= 0)) {
#line 164
      goto while_break;
    }
    {
#line 165
    opj_bio_putbit(bio, (v >> i) & 1U);
    }
#line 164
    __cil_tmp5 = i;
#line 164
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 169 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_UINT32 opj_bio_read(opj_bio_t *bio , OPJ_UINT32 n ) 
{ 
  OPJ_INT32 i ;
  OPJ_UINT32 v ;
  OPJ_UINT32 __cil_tmp5 ;
  OPJ_INT32 __cil_tmp6 ;

  {
#line 181
  v = 0U;
#line 182
  i = (OPJ_INT32 )n - 1;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i >= 0)) {
#line 182
      goto while_break;
    }
    {
#line 183
    __cil_tmp5 = opj_bio_getbit(bio);
    }
#line 183
    v |= __cil_tmp5 << i;
#line 182
    __cil_tmp6 = i;
#line 182
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (v);
}
}
#line 189 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_flush(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;
  OPJ_BOOL __cil_tmp3 ;

  {
  {
#line 191
  __cil_tmp2 = opj_bio_byteout(bio);
  }
#line 191
  if (! __cil_tmp2) {
#line 192
    return (0);
  }
#line 194
  if (bio->ct == 7U) {
    {
#line 195
    __cil_tmp3 = opj_bio_byteout(bio);
    }
#line 195
    if (! __cil_tmp3) {
#line 196
      return (0);
    }
  }
#line 199
  return (1);
}
}
#line 202 "/doner/openjpeg/openjpeg-c0cb119c/src/lib/openjp2/bio.c"
OPJ_BOOL opj_bio_inalign(opj_bio_t *bio ) 
{ 
  OPJ_BOOL __cil_tmp2 ;

  {
#line 204
  if ((bio->buf & 255U) == 255U) {
    {
#line 205
    __cil_tmp2 = opj_bio_bytein(bio);
    }
#line 205
    if (! __cil_tmp2) {
#line 206
      return (0);
    }
  }
#line 209
  bio->ct = (OPJ_UINT32 )0;
#line 210
  return (1);
}
}
