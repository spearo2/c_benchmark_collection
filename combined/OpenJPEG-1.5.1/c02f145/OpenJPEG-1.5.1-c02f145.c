/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__3 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__3 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_6 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_6 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_7 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_7 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_8 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_8 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_9 {
   unsigned long long __wseq ;
   struct __anonstruct_10 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_12 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_11 {
   unsigned long long __g1_start ;
   struct __anonstruct_12 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_9  ;
   unsigned long long __wseq ;
   struct __anonstruct_10 __wseq32 ;
   union __anonunion_11  ;
   unsigned long long __g1_start ;
   struct __anonstruct_12 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_20 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_20 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 6 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__39 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__40 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 63 "../../libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "../../libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "../../libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "../../libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "../../libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "../../libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "../../libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 172 "../../libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 183 "../../libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 190 "../../libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "../../libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "../../libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "../../libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "../../libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "../../libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "../../libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "../../libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "../../libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "../../libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "../../libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "../../libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "../../libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "../../libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "../../libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "../../libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "../../libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "../../libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "../../libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "../../libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "../../libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "../../libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "../../libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "../../libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "../../libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "../../libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "../../libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "../../libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "../../libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "../../libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "../../libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "../../libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 36 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   opj_bool rawSigned ;
};
#line 48 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 68 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 73 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
typedef struct dircnt dircnt_t;
#line 76 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 86 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__41 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__42 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef unsigned short WORD;
#line 513 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef unsigned int DWORD;
#line 515 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct __anonstruct_43 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 521 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef struct __anonstruct_43 BITMAPFILEHEADER_t;
#line 523 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct __anonstruct_44 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 535 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef struct __anonstruct_44 BITMAPINFOHEADER_t;
#line 1472 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__39___0 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 853
enum __anonenum__39___1 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__40___0 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 100 "../../libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "../../libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "../../libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "../../libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "../../libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "../../libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "../../libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "../../libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "../../libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "../../libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "../../libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "../../libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "../../libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "../../libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "../../libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "../../libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "../../libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "../../libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "../../libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "../../libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "../../libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "../../libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 853 "/usr/include/math.h"
enum __anonenum__41___0 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 853
enum __anonenum__41___1 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 853
enum __anonenum__39___2 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__40___1 {
    DT_UNKNOWN___1 = 0,
    DT_FIFO___1 = 1,
    DT_CHR___1 = 2,
    DT_DIR___1 = 4,
    DT_BLK___1 = 6,
    DT_REG___1 = 8,
    DT_LNK___1 = 10,
    DT_SOCK___1 = 12,
    DT_WHT___1 = 14
} ;
#line 72 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
struct img_folder___0 {
   char *imgdirpath ;
   char *out_format ;
   char set_imgdir ;
   char set_out_format ;
   float *rates ;
};
#line 83 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
typedef struct img_folder___0 img_fol_t___0;
#line 46 "/usr/include/ctype.h"
enum __anonenum__42___0 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 18 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20
int opj_optopt ;
#line 21
int opj_optreset ;
#line 22
char *opj_optarg ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 45 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_opterr  =    1;
#line 46 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_optind  =    1;
#line 53 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 57
  opj_opterr = 1;
#line 58
  opj_optind = 1;
  return;
}
}
#line 65 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 67
  place = (char *)EMSG;
#line 68
  oli = (char *)((void *)0);
#line 70
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 71
    opj_optreset = 0;
#line 72
    place = *(nargv + opj_optind);
#line 72
    if (opj_optind >= nargc) {
#line 73
      place = (char *)EMSG;
#line 74
      return (- 1);
    } else
#line 72
    if ((int )*place != 45) {
#line 73
      place = (char *)EMSG;
#line 74
      return (- 1);
    }
#line 76
    place ++;
#line 76
    if ((int )*(place + 1)) {
#line 76
      if ((int )*place == 45) {
#line 77
        opj_optind ++;
#line 78
        place = (char *)EMSG;
#line 79
        return (- 1);
      }
    }
  } else
#line 70
  if (! *place) {
#line 70
    goto _L;
  }
  {
#line 82
  oli = strchr(ostr, opj_optopt);
  }
#line 82
  __cil_tmp6 = place;
#line 82
  place ++;
#line 82
  opj_optopt = (int )*__cil_tmp6;
#line 82
  if (! oli) {
    _L___0: /* CIL Label */ 
#line 88
    if (opj_optopt == 45) {
#line 89
      return (- 1);
    }
#line 90
    if (! *place) {
#line 91
      opj_optind ++;
    }
#line 92
    if (opj_opterr) {
#line 92
      if ((int )*ostr != 58) {
        {
#line 93
        fprintf(stderr, "%s: illegal option -- %c\n\261h\r`U", *(nargv + 0), opj_optopt);
        }
#line 95
        return ((int )'?');
      }
    }
  } else
#line 82
  if (opj_optopt == 58) {
#line 82
    goto _L___0;
  }
#line 98
  oli ++;
#line 98
  if ((int )*oli != 58) {
#line 99
    opj_optarg = (char *)((void *)0);
#line 100
    if (! *place) {
#line 101
      opj_optind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      opj_optarg = place;
    } else {
#line 105
      opj_optind ++;
#line 105
      if (nargc <= opj_optind) {
#line 106
        place = (char *)EMSG;
#line 107
        if ((int )*ostr == 58) {
#line 108
          return ((int )':');
        }
#line 109
        if (opj_opterr) {
          {
#line 110
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 113
          return ((int )'?');
        }
      } else {
#line 116
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 117
    place = (char *)EMSG;
#line 118
    opj_optind ++;
  }
#line 120
  return (opj_optopt);
}
}
#line 124 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 129
  param = (char )1;
  again: 
#line 132
  if (! argv[opj_optind]) {
#line 133
    return (- 1);
  } else
#line 132
  if (opj_optind >= argc) {
#line 133
    return (- 1);
  } else
#line 132
  if ((int )*(argv[opj_optind]) != 45) {
#line 133
    return (- 1);
  }
#line 135
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 135
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 136
      if (opj_optind >= argc - 1) {
#line 137
        param = (char )0;
      } else
#line 140
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 141
        param = (char )0;
      } else {
#line 144
        param = (char )2;
      }
    }
  }
#line 149
  if ((int )param == 0) {
#line 150
    opj_optind ++;
#line 151
    return ((int )'?');
  }
#line 154
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 155
    arg = argv[opj_optind] + 1;
#line 157
    o = longopts;
#line 158
    len = (int )sizeof(*(longopts + 0));
#line 160
    if ((int )param > 1) {
#line 161
      arg = argv[opj_optind + 1];
#line 162
      opj_optind ++;
    } else {
#line 165
      arg = argv[opj_optind] + 1;
    }
    {
#line 167
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 167
    if (__cil_tmp15 > 1UL) {
#line 168
      i = 0;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! (i < totlen)) {
#line 168
          goto while_break;
        }
        {
#line 169
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 169
        if (! __cil_tmp16) {
#line 170
          if (o->has_arg == 0) {
#line 171
            if (argv[opj_optind + 1]) {
#line 171
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 172
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 173
                opj_optind ++;
                }
              }
            }
          } else {
#line 176
            opj_optarg = argv[opj_optind + 1];
#line 177
            if (opj_optarg) {
#line 178
              if ((int )*(opj_optarg + 0) == 45) {
#line 179
                if (opj_opterr) {
                  {
#line 180
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 181
                  return ((int )'?');
                }
              }
            }
#line 185
            if (! opj_optarg) {
#line 185
              if (o->has_arg == 1) {
#line 186
                if (opj_opterr) {
                  {
#line 187
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 188
                  return ((int )'?');
                }
              }
            }
#line 191
            opj_optind ++;
          }
#line 193
          opj_optind ++;
#line 194
          if (o->flag) {
#line 195
            *(o->flag) = o->val;
          } else {
#line 197
            return (o->val);
          }
#line 198
          return (0);
        }
#line 168
        __cil_tmp17 = o;
#line 168
        o ++;
#line 168
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 201
      fprintf(stderr, "Invalid option %s\n", arg);
#line 202
      opj_optind ++;
      }
#line 203
      return ((int )'?');
    } else {
#line 205
      if ((int )*optstring == 58) {
#line 205
        return (':');
      }
#line 206
      if (lastidx != opj_optind) {
#line 207
        lastidx = opj_optind;
#line 207
        lastofs = 0;
      }
      {
#line 209
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 210
      tmp = strchr(optstring, opj_optopt);
      }
#line 210
      if (tmp) {
#line 211
        if ((int )*tmp == 0) {
#line 212
          opj_optind ++;
#line 213
          goto again;
        }
#line 215
        if ((int )*(tmp + 1) == 58) {
#line 216
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 217
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 217
            if (! *opj_optarg) {
#line 217
              opj_optarg = (char *)0;
            }
#line 218
            goto found;
          } else
#line 216
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 216
            goto _L;
          }
#line 220
          opj_optarg = argv[opj_optind + 1];
#line 221
          if (opj_optarg) {
#line 222
            if ((int )*(opj_optarg + 0) == 45) {
#line 223
              if (opj_opterr) {
                {
#line 224
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 225
                return ((int )'?');
              }
            }
          }
#line 229
          if (! opj_optarg) {
#line 230
            if (opj_opterr) {
              {
#line 231
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 232
              return ((int )'?');
            }
          }
#line 235
          opj_optind ++;
        } else {
#line 237
          lastofs ++;
#line 238
          return (opj_optopt);
        }
        found: 
#line 241
        opj_optind ++;
#line 242
        return (opj_optopt);
      } else {
        {
#line 244
        fprintf(stderr, "Invalid option %s\n", arg);
#line 245
        opj_optind ++;
        }
#line 246
        return ((int )'?');
      }
    }
  }
  {
#line 251
  fprintf(stderr, "Invalid option\n");
#line 252
  opj_optind ++;
  }
#line 253
  return ((int )'?');

}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 732 "../../libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 51 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 78
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 79
extern opj_image_t *pngtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 42 "/doner/openjpeg/openjpeg-c02f145/applications/codec/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 35 "../../applications/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 36
extern void color_apply_icc_profile(opj_image_t *image ) ;
#line 88 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void decode_help_display(void) 
{ 


  {
  {
#line 89
  fprintf(stdout, "HELP for j2k_to_image\n----\n\n`U");
#line 90
  fprintf(stdout, "- the -h option displays this help information on screen\n\n\201\r`U");
#line 93
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n\001");
#line 99
  fprintf(stdout, "\n\235\001");
#line 100
  fprintf(stdout, "\n\244\001");
#line 101
  fprintf(stdout, "  -ImgDir \n\r`U");
#line 102
  fprintf(stdout, "\tImage file Directory path \n");
#line 103
  fprintf(stdout, "  -OutFor \n\r`U");
#line 104
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 105
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 106
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA formats\nU");
#line 107
  fprintf(stdout, "  -i <compressed file>\n");
#line 108
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n`U");
#line 109
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 110
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 111
  fprintf(stdout, "  -o <decompressed file>\n");
#line 112
  fprintf(stdout, "    REQUIRED\n");
#line 113
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA files\n");
#line 114
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 115
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 116
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 117
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 118
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 119
  fprintf(stdout, "    will be written to the file.\n");
#line 120
  fprintf(stdout, "  -r <reduce factor>\n");
#line 121
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 122
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 123
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 124
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 125
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 126
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 127
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 128
  fprintf(stdout, "    are decoded.\n");
#line 129
  fprintf(stdout, "  -x  \n");
#line 130
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 131
  fprintf(stdout, "\n");
#line 142
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 147 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 150
  num_images = 0;
#line 154
  dir = opendir((char const   *)imgdirpath);
  }
#line 155
  if (! dir) {
    {
#line 156
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 157
    return (0);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    content = readdir(dir);
    }
#line 160
    if (! (content != (void *)0)) {
#line 160
      goto while_break;
    }
    {
#line 161
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 161
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 161
    if (__cil_tmp7 == 0) {
#line 162
      goto while_continue;
    } else
#line 161
    if (__cil_tmp8 == 0) {
#line 162
      goto while_continue;
    }
#line 163
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (num_images);
}
}
#line 168 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 171
  i = 0;
#line 175
  dir = opendir((char const   *)imgdirpath);
  }
#line 176
  if (! dir) {
    {
#line 177
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 178
    return (1);
  } else {
    {
#line 180
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    content = readdir(dir);
    }
#line 183
    if (! (content != (void *)0)) {
#line 183
      goto while_break;
    }
    {
#line 184
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 184
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 184
    if (__cil_tmp8 == 0) {
#line 185
      goto while_continue;
    } else
#line 184
    if (__cil_tmp9 == 0) {
#line 185
      goto while_continue;
    }
    {
#line 187
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 188
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (0);
}
}
#line 193 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[14] ;
  static int const   format[14] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 195
  extension[0] = "pgx";
#line 195
  extension[1] = "pnm";
#line 195
  extension[2] = "pgm";
#line 195
  extension[3] = "ppm";
#line 195
  extension[4] = "bmp\r`U";
#line 195
  extension[5] = "tif";
#line 195
  extension[6] = "raw\r`U";
#line 195
  extension[7] = "tga";
#line 195
  extension[8] = "png\r`U";
#line 195
  extension[9] = "j2k\r`U";
#line 195
  extension[10] = "jp2\r`U";
#line 195
  extension[11] = "jpt\r`U";
#line 195
  extension[12] = "j2c\r`U";
#line 195
  extension[13] = "jpc\r`U";
#line 196
  format[0] = 11;
#line 196
  format[1] = 10;
#line 196
  format[2] = 10;
#line 196
  format[3] = 10;
#line 196
  format[4] = 12;
#line 196
  format[5] = 14;
#line 196
  format[6] = 15;
#line 196
  format[7] = 16;
#line 196
  format[8] = 17;
#line 196
  format[9] = 0;
#line 196
  format[10] = 1;
#line 196
  format[11] = 2;
#line 196
  format[12] = 0;
#line 196
  format[13] = 0;
#line 197
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 197
  ext = __cil_tmp6;
  }
#line 198
  if (ext == (void *)0) {
#line 199
    return (- 1);
  }
#line 200
  ext ++;
#line 201
  if (ext) {
#line 202
    i = (unsigned int )0;
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 202
        goto while_break;
      }
      {
#line 203
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
      }
#line 203
      if (__cil_tmp8 == 0) {
#line 204
        return (format[i]);
      }
#line 202
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 209
  return (- 1);
}
}
#line 212 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 214
  temp1 = "\002";
#line 216
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 217
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 218
  parameters->decod_format = get_file_format((char *)image_filename);
  }
#line 219
  if (parameters->decod_format == -1) {
#line 220
    return ((char )1);
  }
  {
#line 221
  sprintf((char *)infilename, "%s/%sU", img_fol->imgdirpath, (char *)image_filename);
#line 222
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 225
  __cil_tmp12 = strtok((char *)image_filename, ".\227\206\r`U");
#line 225
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 226
    if (! (temp_p != (void *)0)) {
#line 226
      goto while_break;
    }
    {
#line 227
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 228
    sprintf((char *)temp1, ".%s\r`U", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if ((int )img_fol->set_out_format == 1) {
    {
#line 231
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 232
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 234
  return ((char )0);
}
}
#line 238 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char const   optlist[12] ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp14 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *index___1 ;

  {
#line 241
  long_option[0].name = "ImgDir";
#line 241
  long_option[0].has_arg = 1;
#line 241
  long_option[0].flag = (int *)((void *)0);
#line 241
  long_option[0].val = 'y';
#line 241
  long_option[1].name = "OutFor";
#line 241
  long_option[1].has_arg = 1;
#line 241
  long_option[1].flag = (int *)((void *)0);
#line 241
  long_option[1].val = 'O';
#line 246
  optlist = "i:o:r:l:x:h";
#line 254
  totlen = (int )sizeof(long_option);
#line 255
  img_fol->set_out_format = (char )0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 258
    if (c == -1) {
#line 259
      goto while_break;
    }
    {
#line 261
    if (c == 'i') {
#line 261
      goto case_105;
    }
#line 268
    if (c == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 0) {
#line 268
      goto case_2;
    }
#line 282
    if (c == 'o') {
#line 282
      goto case_111;
    }
#line 293
    if (c == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 11) {
#line 293
      goto case_17;
    }
#line 305
    if (c == 'O') {
#line 305
      goto case_79;
    }
#line 313
    if (c == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (c == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (c == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (c == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (c == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (c == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (c == 17) {
#line 331
      goto case_17___0;
    }
#line 345
    if (c == 'r') {
#line 345
      goto case_114;
    }
#line 354
    if (c == 'l') {
#line 354
      goto case_108;
    }
#line 362
    if (c == 'h') {
#line 362
      goto case_104;
    }
#line 368
    if (c == 'y') {
#line 368
      goto case_121;
    }
#line 376
    if (c == 'x') {
#line 376
      goto case_120;
    }
#line 456
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 263
    infile = opj_optarg;
#line 264
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 268
    if (parameters->decod_format == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 0) {
#line 268
      goto case_2;
    }
#line 270
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 269
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 271
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 274
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 276
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 278
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 284
    outfile = opj_optarg;
#line 285
    parameters->cod_format = get_file_format(outfile);
    }
    {
#line 293
    if (parameters->cod_format == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 11) {
#line 293
      goto case_17;
    }
#line 295
    goto switch_default___0;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 294
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 296
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n|\r`U",
            outfile);
    }
#line 297
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 299
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 301
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 308
    of = opj_optarg;
#line 309
    sprintf((char *)outformat, ".%s", of);
#line 310
    img_fol->set_out_format = (char )1;
#line 311
    parameters->cod_format = get_file_format((char *)outformat);
    }
    {
#line 313
    if (parameters->cod_format == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (parameters->cod_format == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (parameters->cod_format == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (parameters->cod_format == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (parameters->cod_format == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (parameters->cod_format == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (parameters->cod_format == 17) {
#line 331
      goto case_17___0;
    }
#line 334
    goto switch_default___1;
    case_11___0: /* CIL Label */ 
#line 314
    img_fol->out_format = "pgx";
#line 315
    goto switch_break___2;
    case_10___0: /* CIL Label */ 
#line 317
    img_fol->out_format = "ppm";
#line 318
    goto switch_break___2;
    case_12___0: /* CIL Label */ 
#line 320
    img_fol->out_format = "bmp";
#line 321
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 323
    img_fol->out_format = "tif";
#line 324
    goto switch_break___2;
    case_15___0: /* CIL Label */ 
#line 326
    img_fol->out_format = "raw";
#line 327
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
#line 329
    img_fol->out_format = "raw";
#line 330
    goto switch_break___2;
    case_17___0: /* CIL Label */ 
#line 332
    img_fol->out_format = "png";
#line 333
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 335
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            (char *)outformat);
    }
#line 336
    return (1);
#line 337
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 340
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 347
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_reduce);
    }
#line 349
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 356
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_layer);
    }
#line 358
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 363
    decode_help_display();
    }
#line 364
    return (1);
    case_121: /* CIL Label */ 
    {
#line 370
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 370
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 370
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 371
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 372
    img_fol->set_imgdir = (char )1;
    }
#line 374
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 378
    index___1 = opj_optarg;
#line 379
    strncpy(indexfilename, (char const   *)index___1, (unsigned long )4096);
    }
#line 381
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 457
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, opj_optarg);
    }
#line 458
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 256
    if (! (c != -1)) {
#line 256
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  if ((int )img_fol->set_imgdir == 1) {
#line 464
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 465
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 466
      return (1);
    }
#line 468
    if ((int )img_fol->set_out_format == 0) {
      {
#line 469
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 470
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 471
      return (1);
    }
#line 473
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 474
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 475
      return (1);
    }
  } else
#line 478
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 481
    return (1);
  } else
#line 478
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 481
    return (1);
  }
#line 485
  return (0);
}
}
#line 493 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 494
  stream = (FILE *)client_data;
#line 495
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 500 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 501
  stream = (FILE *)client_data;
#line 502
  fprintf(stream, "[WARNING] %s`U", msg);
  }
  return;
}
}
#line 507 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 509
  fprintf(stdout, "[INFO] %s\206\207\r`U", msg);
  }
  return;
}
}
#line 514 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char __cil_tmp25 ;
  FILE *__cil_tmp26 ;
  long __cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  opj_dinfo_t *__cil_tmp30 ;
  opj_cio_t *__cil_tmp31 ;
  opj_image_t *__cil_tmp32 ;
  opj_image_t *__cil_tmp33 ;
  opj_bool bSuccess ;
  int __cil_tmp35 ;
  opj_dinfo_t *__cil_tmp36 ;
  opj_cio_t *__cil_tmp37 ;
  opj_image_t *__cil_tmp38 ;
  opj_image_t *__cil_tmp39 ;
  opj_bool bSuccess___0 ;
  int __cil_tmp41 ;
  opj_dinfo_t *__cil_tmp42 ;
  opj_cio_t *__cil_tmp43 ;
  opj_image_t *__cil_tmp44 ;
  opj_image_t *__cil_tmp45 ;
  opj_bool bSuccess___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 518
  image = (opj_image_t *)((void *)0);
#line 519
  fsrc = (FILE *)((void *)0);
#line 520
  src = (unsigned char *)((void *)0);
#line 524
  dirptr = (dircnt_t *)((void *)0);
#line 525
  dinfo = (opj_dinfo_t *)((void *)0);
#line 526
  cio = (opj_cio_t *)((void *)0);
#line 531
  memset(& event_mgr, 0, sizeof(opj_event_mgr_t ));
#line 532
  event_mgr.error_handler = & error_callback;
#line 533
  event_mgr.warning_handler = & warning_callback;
#line 534
  event_mgr.info_handler = & info_callback;
#line 537
  opj_set_default_decoder_parameters(& parameters);
#line 540
  *((char *)indexfilename) = (char )0;
#line 541
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 544
  __cil_tmp18 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 544
  if (__cil_tmp18 == 1) {
#line 545
    return (1);
  }
#line 549
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 550
    num_images = get_num_images(img_fol.imgdirpath);
#line 552
    __cil_tmp20 = malloc(sizeof(dircnt_t ));
#line 552
    dirptr = (dircnt_t *)__cil_tmp20;
    }
#line 553
    if (dirptr) {
      {
#line 554
      __cil_tmp21 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 554
      dirptr->filename_buf = (char *)__cil_tmp21;
#line 555
      __cil_tmp22 = malloc((unsigned long )num_images * sizeof(char *));
#line 555
      dirptr->filename = (char **)__cil_tmp22;
      }
#line 557
      if (! dirptr->filename_buf) {
#line 558
        return (1);
      }
#line 560
      i = 0;
      {
#line 560
      while (1) {
        while_continue: /* CIL Label */ ;
#line 560
        if (! (i < num_images)) {
#line 560
          goto while_break;
        }
#line 561
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 560
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 564
    __cil_tmp24 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 564
    if (__cil_tmp24 == 1) {
#line 565
      return (1);
    }
#line 567
    if (num_images == 0) {
      {
#line 568
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 569
      return (1);
    }
  } else {
#line 572
    num_images = 1;
  }
#line 576
  imageno = 0;
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 576
    if (! (imageno < num_images)) {
#line 576
      goto while_break___0;
    }
    {
#line 577
    image = (opj_image_t *)((void *)0);
#line 578
    fprintf(stderr, "\n\333\207\r`U");
    }
#line 580
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 581
      __cil_tmp25 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 581
      if (__cil_tmp25) {
        {
#line 582
        fprintf(stderr, "skipping file...\n");
        }
#line 583
        goto while_continue___0;
      }
    }
    {
#line 589
    fsrc = fopen((char const   *)((char *)parameters.infile), "rb");
    }
#line 590
    if (! fsrc) {
      {
#line 591
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.infile);
      }
#line 592
      return (1);
    }
    {
#line 594
    fseek(fsrc, (long )0, 2);
#line 595
    __cil_tmp27 = ftell(fsrc);
#line 595
    file_length = (int )__cil_tmp27;
#line 596
    fseek(fsrc, (long )0, 0);
#line 597
    __cil_tmp28 = malloc((unsigned long )file_length);
#line 597
    src = (unsigned char *)__cil_tmp28;
#line 598
    __cil_tmp29 = fread(src, (unsigned long )1, (unsigned long )file_length, fsrc);
    }
#line 598
    if (__cil_tmp29 != (size_t )file_length) {
      {
#line 600
      free(src);
#line 601
      fclose(fsrc);
#line 602
      fprintf(stderr, "\nERROR: fread return a number of element different from the expected.\n");
      }
#line 603
      return (1);
    }
    {
#line 605
    fclose(fsrc);
    }
    {
#line 611
    if (parameters.decod_format == 0) {
#line 611
      goto case_0;
    }
#line 654
    if (parameters.decod_format == 1) {
#line 654
      goto case_1;
    }
#line 697
    if (parameters.decod_format == 2) {
#line 697
      goto case_2;
    }
#line 740
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 616
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 619
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 622
    opj_setup_decoder(dinfo, & parameters);
#line 625
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 628
    if (*((char *)indexfilename)) {
      {
#line 629
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 631
      image = opj_decode(dinfo, cio);
      }
    }
#line 632
    if (! image) {
      {
#line 633
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 634
      opj_destroy_decompress(dinfo);
#line 635
      opj_cio_close(cio);
#line 636
      free(src);
      }
#line 637
      return (1);
    }
    {
#line 641
    opj_cio_close(cio);
    }
#line 644
    if (*((char *)indexfilename)) {
      {
#line 646
      bSuccess = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 647
      if (bSuccess) {
        {
#line 648
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 652
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 659
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 662
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 665
    opj_setup_decoder(dinfo, & parameters);
#line 668
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 671
    if (*((char *)indexfilename)) {
      {
#line 672
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 674
      image = opj_decode(dinfo, cio);
      }
    }
#line 675
    if (! image) {
      {
#line 676
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 677
      opj_destroy_decompress(dinfo);
#line 678
      opj_cio_close(cio);
#line 679
      free(src);
      }
#line 680
      return (1);
    }
    {
#line 684
    opj_cio_close(cio);
    }
#line 687
    if (*((char *)indexfilename)) {
      {
#line 689
      bSuccess___0 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 690
      if (bSuccess___0) {
        {
#line 691
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 695
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 702
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 705
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 708
    opj_setup_decoder(dinfo, & parameters);
#line 711
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 714
    if (*((char *)indexfilename)) {
      {
#line 715
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 717
      image = opj_decode(dinfo, cio);
      }
    }
#line 718
    if (! image) {
      {
#line 719
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 720
      opj_destroy_decompress(dinfo);
#line 721
      opj_cio_close(cio);
#line 722
      free(src);
      }
#line 723
      return (1);
    }
    {
#line 727
    opj_cio_close(cio);
    }
#line 730
    if (*((char *)indexfilename)) {
      {
#line 732
      bSuccess___1 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 733
      if (bSuccess___1) {
        {
#line 734
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 738
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 741
    fprintf(stderr, "skipping file..\n\220");
    }
#line 742
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 746
    free(src);
#line 747
    src = (unsigned char *)((void *)0);
    }
#line 749
    if ((int )image->color_space == 3) {
      {
#line 751
      color_sycc_to_rgb(image);
      }
    }
#line 754
    if (image->icc_profile_buf) {
      {
#line 760
      free(image->icc_profile_buf);
#line 761
      image->icc_profile_buf = (unsigned char *)((void *)0);
#line 761
      image->icc_profile_len = 0;
      }
    }
    {
#line 767
    if (parameters.cod_format == 10) {
#line 767
      goto case_10;
    }
#line 776
    if (parameters.cod_format == 11) {
#line 776
      goto case_11;
    }
#line 785
    if (parameters.cod_format == 12) {
#line 785
      goto case_12;
    }
#line 803
    if (parameters.cod_format == 15) {
#line 803
      goto case_15;
    }
#line 812
    if (parameters.cod_format == 16) {
#line 812
      goto case_16;
    }
#line 833
    goto switch_default___0;
    case_10: /* CIL Label */ 
    {
#line 768
    __cil_tmp48 = imagetopnm(image, (char const   *)((char *)parameters.outfile));
    }
#line 768
    if (__cil_tmp48) {
      {
#line 769
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 772
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 774
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 777
    __cil_tmp49 = imagetopgx(image, (char const   *)((char *)parameters.outfile));
    }
#line 777
    if (__cil_tmp49) {
      {
#line 778
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 781
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 783
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 786
    __cil_tmp50 = imagetobmp(image, (char const   *)((char *)parameters.outfile));
    }
#line 786
    if (__cil_tmp50) {
      {
#line 787
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 790
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 792
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 804
    __cil_tmp51 = imagetoraw(image, (char const   *)((char *)parameters.outfile));
    }
#line 804
    if (__cil_tmp51) {
      {
#line 805
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 808
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 810
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 813
    __cil_tmp52 = imagetotga(image, (char const   *)((char *)parameters.outfile));
    }
#line 813
    if (__cil_tmp52) {
      {
#line 814
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 817
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 819
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 834
    fprintf(stderr, "Outfile %s not generated\n", (char *)parameters.outfile);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 838
    if (dinfo) {
      {
#line 839
      opj_destroy_decompress(dinfo);
      }
    }
#line 842
    if (*((char *)indexfilename)) {
      {
#line 843
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 845
    opj_image_destroy(image);
    }
#line 576
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 848
  return (0);
}
}
#line 43 "/doner/openjpeg/openjpeg-c02f145/applications/codec/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int start_pos ;
  int end_ph_pos ;
  int end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___2 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___3 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___4 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___5 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___6 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___7 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 45
  stream = (FILE *)((void *)0);
#line 46
  total_disto = (double )0;
#line 57
  if (! cstr_info) {
#line 58
    return (1);
  }
  {
#line 60
  stream = fopen((char const   *)index___0, "w");
  }
#line 61
  if (! stream) {
    {
#line 62
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 63
    return (1);
  }
#line 66
  if ((cstr_info->tile + 0)->distotile) {
#line 67
    disto_on = (char )1;
  } else {
#line 69
    disto_on = (char )0;
  }
#line 71
  if ((cstr_info->tile + 0)->numpix) {
#line 72
    numpix_on = (char )1;
  } else {
#line 74
    numpix_on = (char )0;
  }
  {
#line 76
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 77
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 78
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 80
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 81
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 82
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 84
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (resno >= 0)) {
#line 84
      goto while_break;
    }
    {
#line 85
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 84
    __cil_tmp17 = resno;
#line 84
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  fprintf(stream, "\n");
#line 91
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 93
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 94
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 96
  fprintf(stream, "\nINFO ON TILES\n");
#line 97
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 98
  if (disto_on) {
    {
#line 99
    fprintf(stream, "         disto");
    }
  }
#line 100
  if (numpix_on) {
    {
#line 101
    fprintf(stream, "     nbpix");
    }
  }
#line 102
  if ((int )disto_on) {
#line 102
    if ((int )numpix_on) {
      {
#line 103
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 104
  fprintf(stream, "\n");
#line 106
  tileno = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 113
    if (disto_on) {
      {
#line 114
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 115
    if (numpix_on) {
      {
#line 116
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 117
    if ((int )disto_on) {
#line 117
      if ((int )numpix_on) {
        {
#line 118
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 119
    fprintf(stream, "\n");
    }
#line 106
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  tileno = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 122
      goto while_break___1;
    }
#line 124
    disto = (double )0;
#line 125
    max_numdecompos = 0;
#line 126
    pack_nb = 0;
#line 128
    compno = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (compno < cstr_info->numcomps)) {
#line 128
        goto while_break___2;
      }
#line 129
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 130
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 128
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 134
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 135
    tilepartno = 0;
    }
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 135
        goto while_break___3;
      }
      {
#line 136
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 135
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 145
    if ((int )cstr_info->prog == 0) {
      {
#line 146
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 147
      if (disto_on) {
        {
#line 148
        fprintf(stream, " disto");
        }
      }
      {
#line 149
      fprintf(stream, "\n");
#line 151
      layno = 0;
      }
      {
#line 151
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 151
        if (! (layno < cstr_info->numlayers)) {
#line 151
          goto while_break___4;
        }
#line 152
        resno = 0;
        {
#line 152
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 152
          if (! (resno < max_numdecompos + 1)) {
#line 152
            goto while_break___5;
          }
#line 153
          compno = 0;
          {
#line 153
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 153
            if (! (compno < cstr_info->numcomps)) {
#line 153
              goto while_break___6;
            }
#line 155
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 156
              goto while_break___6;
            }
#line 157
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 158
            precno = 0;
            {
#line 158
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 158
              if (! (precno < prec_max)) {
#line 158
                goto while_break___7;
              }
              {
#line 159
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 160
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 161
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 162
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 163
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 165
              if (disto_on) {
                {
#line 166
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 167
              fprintf(stream, "\n");
#line 168
              total_disto += disto;
#line 169
              pack_nb ++;
              }
#line 158
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 153
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 152
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 151
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 176
    if ((int )cstr_info->prog == 1) {
      {
#line 177
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 178
      if (disto_on) {
        {
#line 179
        fprintf(stream, " disto");
        }
      }
      {
#line 180
      fprintf(stream, "\n");
#line 182
      resno = 0;
      }
      {
#line 182
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 182
        if (! (resno < max_numdecompos + 1)) {
#line 182
          goto while_break___8;
        }
#line 183
        layno = 0;
        {
#line 183
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 183
          if (! (layno < cstr_info->numlayers)) {
#line 183
            goto while_break___9;
          }
#line 184
          compno = 0;
          {
#line 184
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 184
            if (! (compno < cstr_info->numcomps)) {
#line 184
              goto while_break___10;
            }
#line 186
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 187
              goto while_break___10;
            }
#line 188
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 189
            precno = 0;
            {
#line 189
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 189
              if (! (precno < prec_max___0)) {
#line 189
                goto while_break___11;
              }
              {
#line 190
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 191
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 192
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 193
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 194
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d", pack_nb, tileno,
                      resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
              }
#line 196
              if (disto_on) {
                {
#line 197
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 198
              fprintf(stream, "\n");
#line 199
              total_disto += disto;
#line 200
              pack_nb ++;
              }
#line 189
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 184
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 183
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 182
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 207
    if ((int )cstr_info->prog == 2) {
      {
#line 209
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 210
      if (disto_on) {
        {
#line 211
        fprintf(stream, " disto");
        }
      }
      {
#line 212
      fprintf(stream, "\n");
#line 214
      resno = 0;
      }
      {
#line 214
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 214
        if (! (resno < max_numdecompos + 1)) {
#line 214
          goto while_break___12;
        }
#line 215
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 216
        precno = 0;
        {
#line 216
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 216
          if (! (precno < numprec)) {
#line 216
            goto while_break___13;
          }
          {
#line 218
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 218
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 219
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          y0___2 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 220
          x1 = x0 + cstr_info->tile_x;
#line 221
          y1___3 = y0___2 + cstr_info->tile_y;
#line 222
          compno = 0;
          }
          {
#line 222
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 222
            if (! (compno < cstr_info->numcomps)) {
#line 222
              goto while_break___14;
            }
            {
#line 223
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 224
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 224
            pcx = (int )__cil_tmp47;
#line 225
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcy = (int )__cil_tmp49;
#line 226
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 226
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 227
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_y = (int )__cil_tmp53;
            }
#line 228
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 229
              goto while_break___14;
            }
#line 230
            y = y0___2;
            {
#line 230
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 230
              if (! (y < y1___3)) {
#line 230
                goto while_break___15;
              }
#line 231
              if (precno_y * pcy == y) {
#line 232
                x = x0;
                {
#line 232
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 232
                  if (! (x < x1)) {
#line 232
                    goto while_break___16;
                  }
#line 233
                  if (precno_x * pcx == x) {
#line 234
                    layno = 0;
                    {
#line 234
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 234
                      if (! (layno < cstr_info->numlayers)) {
#line 234
                        goto while_break___17;
                      }
                      {
#line 235
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 236
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 237
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 238
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 239
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d", pack_nb,
                              tileno, resno, precno, compno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 241
                      if (disto_on) {
                        {
#line 242
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 243
                      fprintf(stream, "\n");
#line 244
                      total_disto += disto;
#line 245
                      pack_nb ++;
                      }
#line 234
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 232
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 230
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 222
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 216
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 214
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 256
    if ((int )cstr_info->prog == 3) {
      {
#line 258
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 258
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 259
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      y0___4 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 260
      x1___0 = x0___0 + cstr_info->tile_x;
#line 261
      y1___5 = y0___4 + cstr_info->tile_y;
#line 264
      max_numprec = 0;
#line 265
      resno = 0;
      }
      {
#line 265
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 265
        if (! (resno < max_numdecompos + 1)) {
#line 265
          goto while_break___18;
        }
#line 266
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 267
        if (numprec___0 > max_numprec) {
#line 268
          max_numprec = numprec___0;
        }
#line 265
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 271
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 272
      if (disto_on) {
        {
#line 273
        fprintf(stream, " disto");
        }
      }
      {
#line 274
      fprintf(stream, "\n");
#line 276
      precno = 0;
      }
      {
#line 276
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 276
        if (! (precno < max_numprec)) {
#line 276
          goto while_break___19;
        }
#line 277
        compno = 0;
        {
#line 277
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 277
          if (! (compno < cstr_info->numcomps)) {
#line 277
            goto while_break___20;
          }
#line 278
          resno = 0;
          {
#line 278
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 278
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 278
              goto while_break___21;
            }
            {
#line 279
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 280
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 281
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 281
            pcx___0 = (int )__cil_tmp73;
#line 282
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcy___0 = (int )__cil_tmp75;
#line 283
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 283
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 284
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_y___0 = (int )__cil_tmp79;
            }
#line 285
            if (precno >= numprec___1) {
#line 286
              goto while_continue___21;
            }
#line 287
            y = y0___4;
            {
#line 287
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 287
              if (! (y < y1___5)) {
#line 287
                goto while_break___22;
              }
#line 288
              if (precno_y___0 * pcy___0 == y) {
#line 289
                x = x0___0;
                {
#line 289
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 289
                  if (! (x < x1___0)) {
#line 289
                    goto while_break___23;
                  }
#line 290
                  if (precno_x___0 * pcx___0 == x) {
#line 291
                    layno = 0;
                    {
#line 291
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 291
                      if (! (layno < cstr_info->numlayers)) {
#line 291
                        goto while_break___24;
                      }
                      {
#line 292
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 293
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 294
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 295
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 296
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, precno, compno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 298
                      if (disto_on) {
                        {
#line 299
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 300
                      fprintf(stream, "\n");
#line 301
                      total_disto += disto;
#line 302
                      pack_nb ++;
                      }
#line 291
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 289
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 287
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 278
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 277
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 276
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 315
      max_numprec___0 = 0;
#line 316
      resno = 0;
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! (resno < max_numdecompos + 1)) {
#line 316
          goto while_break___25;
        }
#line 317
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 318
        if (numprec___2 > max_numprec___0) {
#line 319
          max_numprec___0 = numprec___2;
        }
#line 316
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 322
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 323
      if (disto_on) {
        {
#line 324
        fprintf(stream, " disto");
        }
      }
      {
#line 325
      fprintf(stream, "\n");
#line 327
      compno = 0;
      }
      {
#line 327
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 327
        if (! (compno < cstr_info->numcomps)) {
#line 327
          goto while_break___26;
        }
        {
#line 329
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 329
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 330
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        y0___6 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 331
        x1___1 = x0___1 + cstr_info->tile_x;
#line 332
        y1___7 = y0___6 + cstr_info->tile_y;
#line 334
        precno = 0;
        }
        {
#line 334
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 334
          if (! (precno < max_numprec___0)) {
#line 334
            goto while_break___27;
          }
#line 335
          resno = 0;
          {
#line 335
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 335
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 335
              goto while_break___28;
            }
            {
#line 336
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 337
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 338
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 338
            pcx___1 = (int )__cil_tmp99;
#line 339
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcy___1 = (int )__cil_tmp101;
#line 340
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 340
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 341
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_y___1 = (int )__cil_tmp105;
            }
#line 342
            if (precno >= numprec___3) {
#line 343
              goto while_continue___28;
            }
#line 345
            y = y0___6;
            {
#line 345
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 345
              if (! (y < y1___7)) {
#line 345
                goto while_break___29;
              }
#line 346
              if (precno_y___1 * pcy___1 == y) {
#line 347
                x = x0___1;
                {
#line 347
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 347
                  if (! (x < x1___1)) {
#line 347
                    goto while_break___30;
                  }
#line 348
                  if (precno_x___1 * pcx___1 == x) {
#line 349
                    layno = 0;
                    {
#line 349
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 349
                      if (! (layno < cstr_info->numlayers)) {
#line 349
                        goto while_break___31;
                      }
                      {
#line 350
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 351
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 352
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 353
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 354
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, compno, precno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 356
                      if (disto_on) {
                        {
#line 357
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 358
                      fprintf(stream, "\n");
#line 359
                      total_disto += disto;
#line 360
                      pack_nb ++;
                      }
#line 349
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 347
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 345
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 335
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 334
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 327
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 122
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  if (disto_on) {
    {
#line 373
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 374
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 378
  if (cstr_info->marknum) {
    {
#line 379
    fprintf(stream, "\nMARKER LIST\n");
#line 380
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 381
    fprintf(stream, "type\tstart_pos    length\n");
#line 382
    x = 0;
    }
    {
#line 382
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 382
      if (! (x < cstr_info->marknum)) {
#line 382
        goto while_break___32;
      }
      {
#line 383
      fprintf(stream, "%X\t%9d %9d\n", (int )(cstr_info->marker + x)->type, (cstr_info->marker + x)->pos,
              (cstr_info->marker + x)->len);
      }
#line 382
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 386
  fclose(stream);
#line 388
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 390
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 124
    return (0);
  }
  {
#line 126
  id_len = (unsigned char )*(tga + 0);
#line 127
  cmap_type = (unsigned char )*(tga + 1);
#line 128
  image_type = (unsigned char )*(tga + 2);
#line 129
  cmap_index = get_ushort(*((unsigned short *)(tga + 3)));
#line 130
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 131
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 134
  x_origin = get_ushort(*((unsigned short *)(tga + 8)));
#line 135
  y_origin = get_ushort(*((unsigned short *)(tga + 10)));
#line 136
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 137
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 138
  pixel_depth = (unsigned char )*(tga + 16);
#line 139
  image_desc = (unsigned char )*(tga + 17);
#line 141
  free(tga);
#line 143
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 144
  *width = (unsigned int )image_w;
#line 145
  *height = (unsigned int )image_h;
  }
#line 148
  if (id_len) {
    {
#line 150
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 150
    id = (unsigned char *)__cil_tmp29;
#line 151
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 151
    if (! __cil_tmp30) {
      {
#line 153
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 154
      free(id);
      }
#line 155
      return (0);
    }
    {
#line 157
    free(id);
    }
  }
#line 163
  if ((int )image_type > 8) {
    {
#line 165
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 166
    return (0);
  }
#line 169
  *flip_image = ! ((int )image_desc & 32);
#line 172
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 174
  if (palette_size > 0) {
    {
#line 176
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 177
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 179
  return (1);
}
}
#line 192 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 199
  if (! bits_per_pixel) {
#line 200
    return (0);
  } else
#line 199
  if (! width) {
#line 200
    return (0);
  } else
#line 199
  if (! height) {
#line 200
    return (0);
  }
#line 202
  pixel_depth = (unsigned char )0;
#line 204
  if (bits_per_pixel < 256) {
#line 205
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 207
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerU");
    }
#line 208
    return (0);
  }
  {
#line 210
  uc0 = (unsigned char )0;
#line 212
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 212
  if (__cil_tmp13 != 1UL) {
#line 212
    goto fails;
  }
  {
#line 213
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 213
  if (__cil_tmp14 != 1UL) {
#line 213
    goto fails;
  }
  {
#line 215
  image_type = (unsigned char )2;
#line 216
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 216
  if (__cil_tmp15 != 1UL) {
#line 216
    goto fails;
  }
  {
#line 218
  us0 = (unsigned short )0;
#line 219
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 219
  if (__cil_tmp16 != 1UL) {
#line 219
    goto fails;
  }
  {
#line 220
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 220
  if (__cil_tmp17 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp18 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 223
  if (__cil_tmp19 != 1UL) {
#line 223
    goto fails;
  }
  {
#line 224
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp20 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  image_w = (unsigned short )width;
#line 227
  image_h = (unsigned short )height;
#line 230
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 230
  if (__cil_tmp21 != 1UL) {
#line 230
    goto fails;
  }
  {
#line 231
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 231
  if (__cil_tmp22 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 239
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 239
  if (__cil_tmp23 != 1UL) {
#line 239
    goto fails;
  }
#line 241
  image_desc = (unsigned char )8;
#line 243
  if (flip_image) {
#line 244
    image_desc |= 32;
  }
  {
#line 245
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 245
  if (__cil_tmp24 != 1UL) {
#line 245
    goto fails;
  }
#line 247
  return (1);
  fails: 
  {
#line 250
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 251
  return (0);
}
}
#line 254 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  opj_bool mono ;
  opj_bool save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;
  opj_image_t *__cil_tmp24 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int index___8 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
  {
#line 259
  flip_image = 0;
#line 268
  f = fopen(filename, "rb\261\r`U");
  }
#line 269
  if (! f) {
    {
#line 270
    fprintf(stderr, "Failed to open %s for reading !!\n|\261\r`U", filename);
    }
#line 271
    return ((opj_image_t *)0);
  }
  {
#line 274
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 274
  if (! __cil_tmp20) {
#line 275
    return ((opj_image_t *)((void *)0));
  }
#line 278
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
#line 279
    return ((opj_image_t *)((void *)0));
  }
  {
#line 282
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 284
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 285
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 287
  if (mono) {
#line 288
    color_space = (OPJ_COLOR_SPACE )2;
#line 289
    if (save_alpha) {
#line 289
      tmp = 2;
    } else {
#line 289
      tmp = 1;
    }
#line 289
    numcomps = tmp;
  } else {
#line 292
    if (save_alpha) {
#line 292
      tmp___0 = 4;
    } else {
#line 292
      tmp___0 = 3;
    }
#line 292
    numcomps = tmp___0;
#line 293
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 296
  subsampling_dx = parameters->subsampling_dx;
#line 297
  subsampling_dy = parameters->subsampling_dy;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < numcomps)) {
#line 299
      goto while_break;
    }
#line 300
    cmptparm[i].prec = 8;
#line 301
    cmptparm[i].bpp = 8;
#line 302
    cmptparm[i].sgnd = 0;
#line 303
    cmptparm[i].dx = subsampling_dx;
#line 304
    cmptparm[i].dy = subsampling_dy;
#line 305
    cmptparm[i].w = (int )image_width;
#line 306
    cmptparm[i].h = (int )image_height;
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 312
  if (! image) {
#line 313
    return ((opj_image_t *)((void *)0));
  }
#line 316
  image->x0 = parameters->image_offset_x0;
#line 317
  image->y0 = parameters->image_offset_y0;
#line 318
  if (! image->x0) {
#line 318
    tmp___1 = (image_width - 1U) * (unsigned int )subsampling_dx + 1U;
  } else {
#line 318
    tmp___1 = ((unsigned int )image->x0 + (image_width - 1U) * (unsigned int )subsampling_dx) + 1U;
  }
#line 318
  image->x1 = (int )tmp___1;
#line 319
  if (! image->y0) {
#line 319
    tmp___2 = (image_height - 1U) * (unsigned int )subsampling_dy + 1U;
  } else {
#line 319
    tmp___2 = ((unsigned int )image->y0 + (image_height - 1U) * (unsigned int )subsampling_dy) + 1U;
  }
#line 319
  image->y1 = (int )tmp___2;
#line 322
  y = (unsigned int )0;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (y < image_height)) {
#line 322
      goto while_break___0;
    }
#line 326
    if (flip_image) {
#line 327
      index___8 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 329
      index___8 = (int )(y * image_width);
    }
#line 331
    if (numcomps == 3) {
#line 333
      x = (unsigned int )0;
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 333
        if (! (x < image_width)) {
#line 333
          goto while_break___1;
        }
        {
#line 337
        __cil_tmp31 = fread(& b, (unsigned long )1, (unsigned long )1, f);
        }
#line 337
        if (! __cil_tmp31) {
          {
#line 339
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 340
          opj_image_destroy(image);
          }
#line 341
          return ((opj_image_t *)((void *)0));
        }
        {
#line 343
        __cil_tmp32 = fread(& g, (unsigned long )1, (unsigned long )1, f);
        }
#line 343
        if (! __cil_tmp32) {
          {
#line 345
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 346
          opj_image_destroy(image);
          }
#line 347
          return ((opj_image_t *)((void *)0));
        }
        {
#line 349
        __cil_tmp33 = fread(& r, (unsigned long )1, (unsigned long )1, f);
        }
#line 349
        if (! __cil_tmp33) {
          {
#line 351
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 352
          opj_image_destroy(image);
          }
#line 353
          return ((opj_image_t *)((void *)0));
        }
#line 356
        *((image->comps + 0)->data + index___8) = (int )r;
#line 357
        *((image->comps + 1)->data + index___8) = (int )g;
#line 358
        *((image->comps + 2)->data + index___8) = (int )b;
#line 359
        index___8 ++;
#line 333
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 362
    if (numcomps == 4) {
#line 364
      x = (unsigned int )0;
      {
#line 364
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 364
        if (! (x < image_width)) {
#line 364
          goto while_break___2;
        }
        {
#line 367
        __cil_tmp40 = fread(& b___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 367
        if (! __cil_tmp40) {
          {
#line 369
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 370
          opj_image_destroy(image);
          }
#line 371
          return ((opj_image_t *)((void *)0));
        }
        {
#line 373
        __cil_tmp41 = fread(& g___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 373
        if (! __cil_tmp41) {
          {
#line 375
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 376
          opj_image_destroy(image);
          }
#line 377
          return ((opj_image_t *)((void *)0));
        }
        {
#line 379
        __cil_tmp42 = fread(& r___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 379
        if (! __cil_tmp42) {
          {
#line 381
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 382
          opj_image_destroy(image);
          }
#line 383
          return ((opj_image_t *)((void *)0));
        }
        {
#line 385
        __cil_tmp43 = fread(& a, (unsigned long )1, (unsigned long )1, f);
        }
#line 385
        if (! __cil_tmp43) {
          {
#line 387
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 388
          opj_image_destroy(image);
          }
#line 389
          return ((opj_image_t *)((void *)0));
        }
#line 392
        *((image->comps + 0)->data + index___8) = (int )r___0;
#line 393
        *((image->comps + 1)->data + index___8) = (int )g___0;
#line 394
        *((image->comps + 2)->data + index___8) = (int )b___0;
#line 395
        *((image->comps + 3)->data + index___8) = (int )a;
#line 396
        index___8 ++;
#line 364
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 400
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 322
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 403
  return (image);
}
}
#line 406 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  opj_bool write_alpha ;
  int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  FILE *__cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___9 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
  {
#line 417
  fdest = fopen(outfile, "wb");
  }
#line 418
  if (! fdest) {
    {
#line 419
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 420
    return (1);
  }
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < image->numcomps - 1)) {
#line 423
      goto while_break;
    }
#line 424
    if ((image->comps + 0)->dx != (image->comps + (i + 1))->dx) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->dy != (image->comps + (i + 1))->dy) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->prec != (image->comps + (i + 1))->prec) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    }
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  width = (image->comps + 0)->w;
#line 433
  height = (image->comps + 0)->h;
#line 436
  write_alpha = image->numcomps == 2 || image->numcomps == 4;
#line 439
  if (write_alpha) {
#line 439
    tmp = 32;
  } else {
#line 439
    tmp = 24;
  }
  {
#line 439
  bpp = tmp;
#line 440
  __cil_tmp25 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 440
  if (! __cil_tmp25) {
#line 441
    return (1);
  }
#line 443
  alpha_channel = (unsigned int )(image->numcomps - 1);
#line 445
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 447
  if ((image->comps + 0)->sgnd) {
#line 447
    tmp___0 = 1 << ((image->comps + 0)->prec - 1);
  } else {
#line 447
    tmp___0 = 0;
  }
#line 447
  adjustR = tmp___0;
#line 448
  if ((image->comps + 1)->sgnd) {
#line 448
    tmp___1 = 1 << ((image->comps + 1)->prec - 1);
  } else {
#line 448
    tmp___1 = 0;
  }
#line 448
  adjustG = tmp___1;
#line 449
  if ((image->comps + 2)->sgnd) {
#line 449
    tmp___2 = 1 << ((image->comps + 2)->prec - 1);
  } else {
#line 449
    tmp___2 = 0;
  }
#line 449
  adjustB = tmp___2;
#line 451
  y = 0;
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 451
    if (! (y < height)) {
#line 451
      goto while_break___0;
    }
#line 452
    index___9 = (unsigned int )(y * width);
#line 454
    x = 0;
    {
#line 454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 454
      if (! (x < width)) {
#line 454
        goto while_break___1;
      }
#line 455
      r = (float )(*((image->comps + 0)->data + index___9) + adjustR);
#line 457
      if (image->numcomps > 2) {
#line 458
        g = (float )(*((image->comps + 1)->data + index___9) + adjustG);
#line 459
        b = (float )(*((image->comps + 2)->data + index___9) + adjustB);
      } else {
#line 462
        g = r;
#line 463
        b = r;
      }
      {
#line 467
      value = (unsigned char )(b * scale);
#line 468
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 469
      if (res < 1UL) {
        {
#line 470
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 471
        return (1);
      }
      {
#line 474
      value = (unsigned char )(g * scale);
#line 475
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 476
      if (res < 1UL) {
        {
#line 477
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 478
        return (1);
      }
      {
#line 481
      value = (unsigned char )(r * scale);
#line 482
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 483
      if (res < 1UL) {
        {
#line 484
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 485
        return (1);
      }
#line 488
      if (write_alpha) {
        {
#line 489
        a = (float )*((image->comps + alpha_channel)->data + index___9);
#line 490
        value = (unsigned char )(a * scale);
#line 491
        res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 492
        if (res < 1UL) {
          {
#line 493
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 494
          return (1);
        }
      }
#line 454
      __cil_tmp35 = index___9;
#line 454
      index___9 ++;
#line 454
      __cil_tmp34 = x;
#line 454
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 451
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 500
  return (0);
}
}
#line 537 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  int x ;
  int y ;
  int index___10 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  FILE *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  opj_image_t *__cil_tmp84 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  DWORD __cil_tmp102 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp105 ;
  opj_image_t *__cil_tmp106 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned char pixel_index ;
  int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int x___12 ;
  unsigned int y___13 ;
  unsigned int max ;
  int i___14 ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp129 ;
  void *__cil_tmp130 ;
  void *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  int tmp___6 ;
  int tmp___7 ;
  int __cil_tmp138 ;
  opj_image_t *__cil_tmp139 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  unsigned char *__cil_tmp147 ;
  int __cil_tmp148 ;
  int __cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  unsigned char *__cil_tmp154 ;
  unsigned int __cil_tmp155 ;
  unsigned char *__cil_tmp156 ;
  int *__cil_tmp157 ;
  unsigned int __cil_tmp158 ;
  unsigned char *__cil_tmp159 ;
  int *__cil_tmp160 ;
  int *__cil_tmp161 ;
  int *__cil_tmp162 ;

  {
  {
#line 539
  subsampling_dx = parameters->subsampling_dx;
#line 540
  subsampling_dy = parameters->subsampling_dy;
#line 545
  image = (opj_image_t *)((void *)0);
#line 552
  PAD = (unsigned int )0;
#line 555
  gray_scale = 1;
#line 559
  IN = fopen(filename, "rb\262\r`U");
  }
#line 560
  if (! IN) {
    {
#line 562
    fprintf(stderr, "Failed to open %s for reading !!\n\215\262\r`U", filename);
    }
#line 563
    return ((opj_image_t *)((void *)0));
  }
  {
#line 566
  __cil_tmp29 = getc(IN);
#line 566
  File_h.bfType = (WORD )__cil_tmp29;
#line 567
  __cil_tmp30 = getc(IN);
#line 567
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 569
  if ((int )File_h.bfType != 19778) {
    {
#line 571
    fprintf(stderr, "Error, not a BMP file!\n");
#line 572
    fclose(IN);
    }
#line 573
    return ((opj_image_t *)((void *)0));
  }
  {
#line 577
  __cil_tmp31 = getc(IN);
#line 577
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 578
  __cil_tmp32 = getc(IN);
#line 578
  File_h.bfSize = (unsigned int )(__cil_tmp32 << 8) + File_h.bfSize;
#line 579
  __cil_tmp33 = getc(IN);
#line 579
  File_h.bfSize = (unsigned int )(__cil_tmp33 << 16) + File_h.bfSize;
#line 580
  __cil_tmp34 = getc(IN);
#line 580
  File_h.bfSize = (unsigned int )(__cil_tmp34 << 24) + File_h.bfSize;
#line 582
  __cil_tmp35 = getc(IN);
#line 582
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 583
  __cil_tmp36 = getc(IN);
#line 583
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 585
  __cil_tmp37 = getc(IN);
#line 585
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 586
  __cil_tmp38 = getc(IN);
#line 586
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 588
  __cil_tmp39 = getc(IN);
#line 588
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 589
  __cil_tmp40 = getc(IN);
#line 589
  File_h.bfOffBits = (unsigned int )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 590
  __cil_tmp41 = getc(IN);
#line 590
  File_h.bfOffBits = (unsigned int )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 591
  __cil_tmp42 = getc(IN);
#line 591
  File_h.bfOffBits = (unsigned int )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 596
  __cil_tmp43 = getc(IN);
#line 596
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 597
  __cil_tmp44 = getc(IN);
#line 597
  Info_h.biSize = (unsigned int )(__cil_tmp44 << 8) + Info_h.biSize;
#line 598
  __cil_tmp45 = getc(IN);
#line 598
  Info_h.biSize = (unsigned int )(__cil_tmp45 << 16) + Info_h.biSize;
#line 599
  __cil_tmp46 = getc(IN);
#line 599
  Info_h.biSize = (unsigned int )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 601
  if (Info_h.biSize != 40U) {
    {
#line 603
    fprintf(stderr, "Error, unknown BMP header size %d\n\262\r`U", Info_h.biSize);
#line 604
    fclose(IN);
    }
#line 605
    return ((opj_image_t *)((void *)0));
  }
  {
#line 607
  __cil_tmp47 = getc(IN);
#line 607
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 608
  __cil_tmp48 = getc(IN);
#line 608
  Info_h.biWidth = (unsigned int )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 609
  __cil_tmp49 = getc(IN);
#line 609
  Info_h.biWidth = (unsigned int )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 610
  __cil_tmp50 = getc(IN);
#line 610
  Info_h.biWidth = (unsigned int )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 611
  w = (int )Info_h.biWidth;
#line 613
  __cil_tmp51 = getc(IN);
#line 613
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 614
  __cil_tmp52 = getc(IN);
#line 614
  Info_h.biHeight = (unsigned int )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 615
  __cil_tmp53 = getc(IN);
#line 615
  Info_h.biHeight = (unsigned int )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 616
  __cil_tmp54 = getc(IN);
#line 616
  Info_h.biHeight = (unsigned int )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 617
  h = (int )Info_h.biHeight;
#line 619
  __cil_tmp55 = getc(IN);
#line 619
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 620
  __cil_tmp56 = getc(IN);
#line 620
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 622
  __cil_tmp57 = getc(IN);
#line 622
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 623
  __cil_tmp58 = getc(IN);
#line 623
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 625
  __cil_tmp59 = getc(IN);
#line 625
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 626
  __cil_tmp60 = getc(IN);
#line 626
  Info_h.biCompression = (unsigned int )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 627
  __cil_tmp61 = getc(IN);
#line 627
  Info_h.biCompression = (unsigned int )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 628
  __cil_tmp62 = getc(IN);
#line 628
  Info_h.biCompression = (unsigned int )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 630
  __cil_tmp63 = getc(IN);
#line 630
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 631
  __cil_tmp64 = getc(IN);
#line 631
  Info_h.biSizeImage = (unsigned int )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 632
  __cil_tmp65 = getc(IN);
#line 632
  Info_h.biSizeImage = (unsigned int )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 633
  __cil_tmp66 = getc(IN);
#line 633
  Info_h.biSizeImage = (unsigned int )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 635
  __cil_tmp67 = getc(IN);
#line 635
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 636
  __cil_tmp68 = getc(IN);
#line 636
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 637
  __cil_tmp69 = getc(IN);
#line 637
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 638
  __cil_tmp70 = getc(IN);
#line 638
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 640
  __cil_tmp71 = getc(IN);
#line 640
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 641
  __cil_tmp72 = getc(IN);
#line 641
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 642
  __cil_tmp73 = getc(IN);
#line 642
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 643
  __cil_tmp74 = getc(IN);
#line 643
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 645
  __cil_tmp75 = getc(IN);
#line 645
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 646
  __cil_tmp76 = getc(IN);
#line 646
  Info_h.biClrUsed = (unsigned int )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 647
  __cil_tmp77 = getc(IN);
#line 647
  Info_h.biClrUsed = (unsigned int )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 648
  __cil_tmp78 = getc(IN);
#line 648
  Info_h.biClrUsed = (unsigned int )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 650
  __cil_tmp79 = getc(IN);
#line 650
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 651
  __cil_tmp80 = getc(IN);
#line 651
  Info_h.biClrImportant = (unsigned int )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 652
  __cil_tmp81 = getc(IN);
#line 652
  Info_h.biClrImportant = (unsigned int )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 653
  __cil_tmp82 = getc(IN);
#line 653
  Info_h.biClrImportant = (unsigned int )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 657
  if ((int )Info_h.biBitCount == 24) {
    {
#line 659
    numcomps = 3;
#line 660
    color_space = (OPJ_COLOR_SPACE )1;
#line 662
    memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 663
    i = 0;
    }
    {
#line 663
    while (1) {
      while_continue: /* CIL Label */ ;
#line 663
      if (! (i < numcomps)) {
#line 663
        goto while_break;
      }
#line 665
      cmptparm[i].prec = 8;
#line 666
      cmptparm[i].bpp = 8;
#line 667
      cmptparm[i].sgnd = 0;
#line 668
      cmptparm[i].dx = subsampling_dx;
#line 669
      cmptparm[i].dy = subsampling_dy;
#line 670
      cmptparm[i].w = w;
#line 671
      cmptparm[i].h = h;
#line 663
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 674
    image = opj_image_create(numcomps, & cmptparm[0], color_space);
    }
#line 675
    if (! image) {
      {
#line 677
      fclose(IN);
      }
#line 678
      return ((opj_image_t *)((void *)0));
    }
#line 682
    image->x0 = parameters->image_offset_x0;
#line 683
    image->y0 = parameters->image_offset_y0;
#line 684
    if (! image->x0) {
#line 684
      tmp = (w - 1) * subsampling_dx + 1;
    } else {
#line 684
      tmp = (image->x0 + (w - 1) * subsampling_dx) + 1;
    }
#line 684
    image->x1 = tmp;
#line 685
    if (! image->y0) {
#line 685
      tmp___0 = (h - 1) * subsampling_dy + 1;
    } else {
#line 685
      tmp___0 = (image->y0 + (h - 1) * subsampling_dy) + 1;
    }
    {
#line 685
    image->y1 = tmp___0;
#line 690
    fseek(IN, (long )0, 0);
#line 691
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 693
    W = Info_h.biWidth;
#line 694
    H = Info_h.biHeight;
    }
#line 698
    if ((3U * W) % 4U) {
#line 698
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 698
      tmp___1 = (unsigned int )0;
    }
    {
#line 698
    PAD = tmp___1;
#line 700
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 700
    RGB = (unsigned char *)__cil_tmp88;
#line 703
    __cil_tmp89 = fread(RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 703
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 705
      free(RGB);
#line 706
      opj_image_destroy(image);
#line 707
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 708
      return ((opj_image_t *)((void *)0));
    }
#line 711
    index___10 = 0;
#line 713
    y = 0;
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 713
      if (! (y < (int )H)) {
#line 713
        goto while_break___0;
      }
#line 715
      scanline = RGB + (3U * W + PAD) * ((H - 1U) - (unsigned int )y);
#line 716
      x = 0;
      {
#line 716
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 716
        if (! (x < (int )W)) {
#line 716
          goto while_break___1;
        }
#line 718
        pixel = scanline + 3 * x;
#line 719
        *((image->comps + 0)->data + index___10) = (int )*(pixel + 2);
#line 720
        *((image->comps + 1)->data + index___10) = (int )*(pixel + 1);
#line 721
        *((image->comps + 2)->data + index___10) = (int )*(pixel + 0);
#line 722
        index___10 ++;
#line 716
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 713
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 725
    free(RGB);
    }
  } else
#line 728
  if ((int )Info_h.biBitCount == 8) {
#line 728
    if (Info_h.biCompression == 0U) {
#line 730
      if (Info_h.biClrUsed == 0U) {
#line 730
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 732
      if (Info_h.biClrUsed > 256U) {
#line 732
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 734
      __cil_tmp95 = malloc(256UL * sizeof(unsigned char ));
#line 734
      table_R = (unsigned char *)__cil_tmp95;
#line 735
      __cil_tmp96 = malloc(256UL * sizeof(unsigned char ));
#line 735
      table_G = (unsigned char *)__cil_tmp96;
#line 736
      __cil_tmp97 = malloc(256UL * sizeof(unsigned char ));
#line 736
      table_B = (unsigned char *)__cil_tmp97;
#line 738
      has_color = 0;
#line 739
      j = (unsigned int )0;
      }
      {
#line 739
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 739
        if (! (j < Info_h.biClrUsed)) {
#line 739
          goto while_break___2;
        }
        {
#line 741
        __cil_tmp98 = getc(IN);
#line 741
        *(table_B + j) = (unsigned char )__cil_tmp98;
#line 742
        __cil_tmp99 = getc(IN);
#line 742
        *(table_G + j) = (unsigned char )__cil_tmp99;
#line 743
        __cil_tmp100 = getc(IN);
#line 743
        *(table_R + j) = (unsigned char )__cil_tmp100;
#line 744
        getc(IN);
#line 745
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 739
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 748
      if (has_color) {
#line 748
        gray_scale = 0;
      }
      {
#line 751
      fseek(IN, (long )0, 0);
#line 752
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 754
      W = Info_h.biWidth;
#line 755
      H = Info_h.biHeight;
      }
#line 756
      if (Info_h.biWidth % 2U) {
#line 757
        W ++;
      }
#line 759
      if (gray_scale) {
#line 759
        tmp___2 = 1;
      } else {
#line 759
        tmp___2 = 3;
      }
#line 759
      numcomps = tmp___2;
#line 760
      if (gray_scale) {
#line 760
        tmp___3 = 2;
      } else {
#line 760
        tmp___3 = 1;
      }
      {
#line 760
      color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 762
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 763
      i = 0;
      }
      {
#line 763
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 763
        if (! (i < numcomps)) {
#line 763
          goto while_break___3;
        }
#line 765
        cmptparm[i].prec = 8;
#line 766
        cmptparm[i].bpp = 8;
#line 767
        cmptparm[i].sgnd = 0;
#line 768
        cmptparm[i].dx = subsampling_dx;
#line 769
        cmptparm[i].dy = subsampling_dy;
#line 770
        cmptparm[i].w = w;
#line 771
        cmptparm[i].h = h;
#line 763
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 774
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 775
      if (! image) {
        {
#line 777
        fclose(IN);
#line 778
        free(table_R);
#line 778
        free(table_G);
#line 778
        free(table_B);
        }
#line 779
        return ((opj_image_t *)((void *)0));
      }
#line 783
      image->x0 = parameters->image_offset_x0;
#line 784
      image->y0 = parameters->image_offset_y0;
#line 785
      if (! image->x0) {
#line 785
        tmp___4 = (w - 1) * subsampling_dx + 1;
      } else {
#line 785
        tmp___4 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 785
      image->x1 = tmp___4;
#line 786
      if (! image->y0) {
#line 786
        tmp___5 = (h - 1) * subsampling_dy + 1;
      } else {
#line 786
        tmp___5 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 786
      image->y1 = tmp___5;
#line 790
      __cil_tmp109 = malloc((unsigned long )(W * H) * sizeof(unsigned char ));
#line 790
      RGB = (unsigned char *)__cil_tmp109;
#line 792
      __cil_tmp110 = fread(RGB, sizeof(unsigned char ), (unsigned long )(W * H), IN);
      }
#line 792
      if (__cil_tmp110 != (unsigned long )(W * H)) {
        {
#line 794
        free(table_R);
#line 795
        free(table_G);
#line 796
        free(table_B);
#line 797
        free(RGB);
#line 798
        opj_image_destroy(image);
#line 799
        fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
        }
#line 800
        return ((opj_image_t *)((void *)0));
      }
#line 802
      if (gray_scale) {
#line 804
        index___10 = 0;
#line 805
        j = (unsigned int )0;
        {
#line 805
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 805
          if (! (j < W * H)) {
#line 805
            goto while_break___4;
          }
#line 807
          if (j % W < W - 1U) {
#line 807
            if (Info_h.biWidth % 2U) {
#line 809
              *((image->comps + 0)->data + index___10) = (int )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
              index___10 ++;
            } else {
#line 807
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 807
          if (! (Info_h.biWidth % 2U)) {
#line 809
            *((image->comps + 0)->data + index___10) = (int )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
            index___10 ++;
          }
#line 805
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 818
        index___10 = 0;
#line 819
        j = (unsigned int )0;
        {
#line 819
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 819
          if (! (j < W * H)) {
#line 819
            goto while_break___5;
          }
#line 821
          if (j % W < W - 1U) {
#line 821
            if (Info_h.biWidth % 2U) {
#line 824
              pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
              *((image->comps + 0)->data + index___10) = (int )*(table_R + pixel_index);
#line 827
              *((image->comps + 1)->data + index___10) = (int )*(table_G + pixel_index);
#line 828
              *((image->comps + 2)->data + index___10) = (int )*(table_B + pixel_index);
#line 829
              index___10 ++;
            } else {
#line 821
              goto _L___11;
            }
          } else
          _L___11: /* CIL Label */ 
#line 821
          if (! (Info_h.biWidth % 2U)) {
#line 824
            pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
            *((image->comps + 0)->data + index___10) = (int )*(table_R + pixel_index);
#line 827
            *((image->comps + 1)->data + index___10) = (int )*(table_G + pixel_index);
#line 828
            *((image->comps + 2)->data + index___10) = (int )*(table_B + pixel_index);
#line 829
            index___10 ++;
          }
#line 819
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 833
      free(RGB);
#line 834
      free(table_R);
#line 835
      free(table_G);
#line 836
      free(table_B);
      }
    } else {
#line 728
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 839
  if ((int )Info_h.biBitCount == 8) {
#line 839
    if (Info_h.biCompression == 1U) {
#line 847
      if (Info_h.biClrUsed == 0U) {
#line 848
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 849
      if (Info_h.biClrUsed > 256U) {
#line 850
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 852
      __cil_tmp129 = malloc(256UL * sizeof(unsigned char ));
#line 852
      table_R = (unsigned char *)__cil_tmp129;
#line 853
      __cil_tmp130 = malloc(256UL * sizeof(unsigned char ));
#line 853
      table_G = (unsigned char *)__cil_tmp130;
#line 854
      __cil_tmp131 = malloc(256UL * sizeof(unsigned char ));
#line 854
      table_B = (unsigned char *)__cil_tmp131;
#line 856
      has_color = 0;
#line 857
      j = (unsigned int )0;
      }
      {
#line 857
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 857
        if (! (j < Info_h.biClrUsed)) {
#line 857
          goto while_break___6;
        }
        {
#line 859
        __cil_tmp132 = getc(IN);
#line 859
        *(table_B + j) = (unsigned char )__cil_tmp132;
#line 860
        __cil_tmp133 = getc(IN);
#line 860
        *(table_G + j) = (unsigned char )__cil_tmp133;
#line 861
        __cil_tmp134 = getc(IN);
#line 861
        *(table_R + j) = (unsigned char )__cil_tmp134;
#line 862
        getc(IN);
#line 863
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 857
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 866
      if (has_color) {
#line 867
        gray_scale = 0;
      }
#line 869
      if (gray_scale) {
#line 869
        tmp___6 = 1;
      } else {
#line 869
        tmp___6 = 3;
      }
#line 869
      numcomps = tmp___6;
#line 870
      if (gray_scale) {
#line 870
        tmp___7 = 2;
      } else {
#line 870
        tmp___7 = 1;
      }
      {
#line 870
      color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 872
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 873
      i___14 = 0;
      }
      {
#line 873
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 873
        if (! (i___14 < numcomps)) {
#line 873
          goto while_break___7;
        }
#line 875
        cmptparm[i___14].prec = 8;
#line 876
        cmptparm[i___14].bpp = 8;
#line 877
        cmptparm[i___14].sgnd = 0;
#line 878
        cmptparm[i___14].dx = subsampling_dx;
#line 879
        cmptparm[i___14].dy = subsampling_dy;
#line 880
        cmptparm[i___14].w = w;
#line 881
        cmptparm[i___14].h = h;
#line 873
        i___14 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 884
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 885
      if (! image) {
        {
#line 887
        fclose(IN);
#line 888
        free(table_R);
#line 889
        free(table_G);
#line 890
        free(table_B);
        }
#line 891
        return ((opj_image_t *)((void *)0));
      }
#line 895
      image->x0 = parameters->image_offset_x0;
#line 896
      image->y0 = parameters->image_offset_y0;
#line 897
      if (! image->x0) {
#line 897
        tmp___8 = (w - 1) * subsampling_dx + 1;
      } else {
#line 897
        tmp___8 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 897
      image->x1 = tmp___8;
#line 899
      if (! image->y0) {
#line 899
        tmp___9 = (h - 1) * subsampling_dy + 1;
      } else {
#line 899
        tmp___9 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 899
      image->y1 = tmp___9;
#line 905
      fseek(IN, (long )0, 0);
#line 906
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 908
      W = Info_h.biWidth;
#line 909
      H = Info_h.biHeight;
#line 910
      __cil_tmp142 = calloc((unsigned long )1, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 910
      RGB = (unsigned char *)__cil_tmp142;
#line 911
      beyond = RGB + W * H;
#line 912
      pix = beyond - W;
#line 913
      y___13 = (unsigned int )0;
#line 913
      x___12 = y___13;
      }
      {
#line 915
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 915
        if (! (y___13 < H)) {
#line 915
          goto while_break___8;
        }
        {
#line 917
        c = getc(IN);
        }
#line 919
        if (c) {
          {
#line 921
          c1 = getc(IN);
#line 923
          i___14 = 0;
          }
          {
#line 923
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 923
            if (! (pix < beyond && (i___14 < c && x___12 < W))) {
#line 923
              goto while_break___9;
            }
#line 924
            *pix = (unsigned char )c1;
#line 923
            __cil_tmp147 = pix;
#line 923
            pix ++;
#line 923
            __cil_tmp146 = x___12;
#line 923
            x___12 ++;
#line 923
            __cil_tmp145 = i___14;
#line 923
            i___14 ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        } else {
          {
#line 928
          c = getc(IN);
          }
#line 930
          if (c == 0) {
#line 932
            x___12 = (unsigned int )0;
#line 933
            y___13 ++;
#line 934
            pix = (RGB + x___12) + ((H - y___13) - 1U) * W;
          } else
#line 936
          if (c == 1) {
#line 937
            goto while_break___8;
          } else
#line 938
          if (c == 2) {
            {
#line 940
            c = getc(IN);
#line 941
            x___12 += (unsigned int )c;
#line 942
            c = getc(IN);
#line 943
            y___13 += (unsigned int )c;
#line 944
            pix = (RGB + ((H - y___13) - 1U) * W) + x___12;
            }
          } else {
#line 948
            i___14 = 0;
            {
#line 949
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 949
              if (! (pix < beyond && (i___14 < c && x___12 < W))) {
#line 949
                goto while_break___10;
              }
              {
#line 951
              c1 = getc(IN);
#line 952
              *pix = (unsigned char )c1;
              }
#line 949
              __cil_tmp154 = pix;
#line 949
              pix ++;
#line 949
              __cil_tmp153 = x___12;
#line 949
              x___12 ++;
#line 949
              __cil_tmp152 = i___14;
#line 949
              i___14 ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 954
            if (c & 1) {
              {
#line 955
              getc(IN);
              }
            }
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 960
      if (gray_scale) {
#line 962
        gray = (image->comps + 0)->data;
#line 963
        pix = RGB;
#line 964
        max = W * H;
        {
#line 966
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 966
          __cil_tmp155 = max;
#line 966
          max --;
#line 966
          if (! __cil_tmp155) {
#line 966
            goto while_break___11;
          }
#line 968
          __cil_tmp156 = pix;
#line 968
          pix ++;
#line 968
          uc = *__cil_tmp156;
#line 970
          __cil_tmp157 = gray;
#line 970
          gray ++;
#line 970
          *__cil_tmp157 = (int )*(table_R + uc);
        }
        while_break___11: /* CIL Label */ ;
        }
      } else {
#line 977
        red = (image->comps + 0)->data;
#line 978
        green = (image->comps + 1)->data;
#line 979
        blue = (image->comps + 2)->data;
#line 980
        pix = RGB;
#line 981
        max = W * H;
        {
#line 983
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 983
          __cil_tmp158 = max;
#line 983
          max --;
#line 983
          if (! __cil_tmp158) {
#line 983
            goto while_break___12;
          }
#line 985
          __cil_tmp159 = pix;
#line 985
          pix ++;
#line 985
          uc = *__cil_tmp159;
#line 987
          __cil_tmp160 = red;
#line 987
          red ++;
#line 987
          *__cil_tmp160 = (int )*(table_R + uc);
#line 988
          __cil_tmp161 = green;
#line 988
          green ++;
#line 988
          *__cil_tmp161 = (int )*(table_G + uc);
#line 989
          __cil_tmp162 = blue;
#line 989
          blue ++;
#line 989
          *__cil_tmp162 = (int )*(table_B + uc);
        }
        while_break___12: /* CIL Label */ ;
        }
      }
      {
#line 992
      free(RGB);
#line 993
      free(table_R);
#line 994
      free(table_G);
#line 995
      free(table_B);
      }
    } else {
      {
      {
#line 999
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
  } else {
    {
    {
#line 999
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
    }
  }
  {
#line 1003
  fclose(IN);
  }
#line 1004
  return (image);
}
}
#line 1007 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 1010
  fdest = (FILE *)((void *)0);
#line 1013
  if ((image->comps + 0)->prec < 8) {
    {
#line 1014
    fprintf(stderr, "Unsupported precision: %d\n", (image->comps + 0)->prec);
    }
#line 1015
    return (1);
  }
#line 1017
  if (image->numcomps >= 3) {
#line 1017
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1017
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1017
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1017
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1017
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1017
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1028
                fdest = fopen(outfile, "wb");
                }
#line 1029
                if (! fdest) {
                  {
#line 1030
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1031
                  return (1);
                }
                {
#line 1034
                w = (image->comps + 0)->w;
#line 1035
                h = (image->comps + 0)->h;
#line 1037
                fprintf(fdest, "BM\264\r`U");
#line 1041
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1046
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1047
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1051
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1052
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1056
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1060
                fprintf(fdest, "%c%c`U", 1, (1 >> 8) & 255);
#line 1061
                fprintf(fdest, "%c%c`U", 24, (24 >> 8) & 255);
#line 1062
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1063
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1067
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1068
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1069
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1070
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1072
                if ((image->comps + 0)->prec > 8) {
                  {
#line 1073
                  adjustR = (image->comps + 0)->prec - 8;
#line 1074
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1077
                  adjustR = 0;
                }
#line 1078
                if ((image->comps + 1)->prec > 8) {
                  {
#line 1079
                  adjustG = (image->comps + 1)->prec - 8;
#line 1080
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1083
                  adjustG = 0;
                }
#line 1084
                if ((image->comps + 2)->prec > 8) {
                  {
#line 1085
                  adjustB = (image->comps + 2)->prec - 8;
#line 1086
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1089
                  adjustB = 0;
                }
#line 1091
                i = 0;
                {
#line 1091
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1091
                  if (! (i < w * h)) {
#line 1091
                    goto while_break;
                  }
#line 1095
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1096
                  if ((image->comps + 0)->sgnd) {
#line 1096
                    tmp = 1 << ((image->comps + 0)->prec - 1);
                  } else {
#line 1096
                    tmp = 0;
                  }
#line 1096
                  r += tmp;
#line 1097
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1098
                  if (r > 255) {
#line 1098
                    r = 255;
                  } else
#line 1098
                  if (r < 0) {
#line 1098
                    r = 0;
                  }
#line 1099
                  rc = (unsigned char )r;
#line 1101
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1102
                  if ((image->comps + 1)->sgnd) {
#line 1102
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1);
                  } else {
#line 1102
                    tmp___0 = 0;
                  }
#line 1102
                  g += tmp___0;
#line 1103
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1104
                  if (g > 255) {
#line 1104
                    g = 255;
                  } else
#line 1104
                  if (g < 0) {
#line 1104
                    g = 0;
                  }
#line 1105
                  gc = (unsigned char )g;
#line 1107
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1108
                  if ((image->comps + 2)->sgnd) {
#line 1108
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1);
                  } else {
#line 1108
                    tmp___1 = 0;
                  }
#line 1108
                  b += tmp___1;
#line 1109
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1110
                  if (b > 255) {
#line 1110
                    b = 255;
                  } else
#line 1110
                  if (b < 0) {
#line 1110
                    b = 0;
                  }
                  {
#line 1111
                  bc = (unsigned char )b;
#line 1113
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1115
                  if ((i + 1) % w == 0) {
#line 1116
                    if ((3 * w) % 4) {
#line 1116
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1116
                      tmp___2 = 0;
                    }
#line 1116
                    pad = tmp___2;
                    {
#line 1116
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1116
                      if (! (pad > 0)) {
#line 1116
                        goto while_break___0;
                      }
                      {
#line 1117
                      fprintf(fdest, "%c", 0);
                      }
#line 1116
                      __cil_tmp22 = pad;
#line 1116
                      pad --;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
#line 1091
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 1120
                fclose(fdest);
                }
              } else {
#line 1017
                goto _L;
              }
            } else {
#line 1017
              goto _L;
            }
          } else {
#line 1017
            goto _L;
          }
        } else {
#line 1017
          goto _L;
        }
      } else {
#line 1017
        goto _L;
      }
    } else {
#line 1017
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___16: /* CIL Label */ 
    _L___17: /* CIL Label */ 
    _L___18: /* CIL Label */ 
    _L___19: /* CIL Label */ 
    _L___20: /* CIL Label */ 
    {
#line 1127
    fdest = fopen(outfile, "wb");
#line 1128
    w = (image->comps + 0)->w;
#line 1129
    h = (image->comps + 0)->h;
#line 1131
    fprintf(fdest, "BM\263\r`U");
#line 1135
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1139
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1140
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1146
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1147
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1151
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1155
    fprintf(fdest, "%c%c`U", 1, (1 >> 8) & 255);
#line 1156
    fprintf(fdest, "%c%c`U", 8, (8 >> 8) & 255);
#line 1157
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1158
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1162
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1163
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1164
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1165
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1167
    if ((image->comps + 0)->prec > 8) {
      {
#line 1168
      adjustR = (image->comps + 0)->prec - 8;
#line 1169
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1171
      adjustR = 0;
    }
#line 1173
    i = 0;
    {
#line 1173
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1173
      if (! (i < 256)) {
#line 1173
        goto while_break___1;
      }
      {
#line 1174
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 1173
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1177
    i = 0;
    {
#line 1177
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1177
      if (! (i < w * h)) {
#line 1177
        goto while_break___2;
      }
#line 1180
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1181
      if ((image->comps + 0)->sgnd) {
#line 1181
        tmp___3 = 1 << ((image->comps + 0)->prec - 1);
      } else {
#line 1181
        tmp___3 = 0;
      }
#line 1181
      r___0 += tmp___3;
#line 1182
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1183
      if (r___0 > 255) {
#line 1183
        r___0 = 255;
      } else
#line 1183
      if (r___0 < 0) {
#line 1183
        r___0 = 0;
      }
      {
#line 1185
      fprintf(fdest, "%c", (int )((unsigned char )r___0));
      }
#line 1187
      if ((i + 1) % w == 0) {
#line 1188
        if (w % 4) {
#line 1188
          tmp___4 = 4 - w % 4;
        } else {
#line 1188
          tmp___4 = 0;
        }
#line 1188
        pad = tmp___4;
        {
#line 1188
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1188
          if (! (pad > 0)) {
#line 1188
            goto while_break___3;
          }
          {
#line 1189
          fprintf(fdest, "%c", 0);
          }
#line 1188
          __cil_tmp29 = pad;
#line 1188
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1177
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1192
    fclose(fdest);
    }
  }
#line 1195
  return (0);
}
}
#line 1205 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1208
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1208
  if (! __cil_tmp3) {
    {
#line 1210
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1211
    return ((unsigned char )0);
  }
#line 1213
  return (c1);
}
}
#line 1216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1219
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1219
  if (! __cil_tmp5) {
    {
#line 1221
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1222
    return ((unsigned short )0);
  }
  {
#line 1224
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1224
  if (! __cil_tmp6) {
    {
#line 1226
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1227
    return ((unsigned short )0);
  }
#line 1229
  if (bigendian) {
#line 1230
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1232
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1235 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1238
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1238
  if (! __cil_tmp7) {
    {
#line 1240
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1241
    return ((unsigned int )0);
  }
  {
#line 1243
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1243
  if (! __cil_tmp8) {
    {
#line 1245
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1246
    return ((unsigned int )0);
  }
  {
#line 1248
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1248
  if (! __cil_tmp9) {
    {
#line 1250
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1251
    return ((unsigned int )0);
  }
  {
#line 1253
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp10) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
#line 1258
  if (bigendian) {
#line 1259
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1261
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1264 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  opj_image_t *__cil_tmp29 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 1265
  f = (FILE *)((void *)0);
#line 1270
  image = (opj_image_t *)((void *)0);
#line 1278
  comp = (opj_image_comp_t *)((void *)0);
#line 1280
  numcomps = 1;
#line 1281
  color_space = (OPJ_COLOR_SPACE )2;
#line 1283
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1285
  max = 0;
#line 1287
  f = fopen(filename, "rb\266\r`U");
  }
#line 1288
  if (! f) {
    {
#line 1289
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1290
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1293
  fseek(f, (long )0, 0);
#line 1294
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d\266\r`U", (char *)temp,
                       & endian1, & endian2, (char *)signtmp, & prec, (char *)temp,
                       & w, (char *)temp, & h);
  }
#line 1294
  if (__cil_tmp25 != 9) {
    {
#line 1295
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1296
    return ((opj_image_t *)((void *)0));
  }
#line 1299
  i = 0;
#line 1300
  sign = (char )'+';
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if (! ((int )signtmp[i] != 0)) {
#line 1301
      goto while_break;
    }
#line 1302
    if ((int )signtmp[i] == 45) {
#line 1302
      sign = (char )'-';
    }
#line 1303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1306
  fgetc(f);
  }
#line 1307
  if ((int )endian1 == 77) {
#line 1307
    if ((int )endian2 == 76) {
#line 1308
      bigendian = 1;
    } else {
#line 1307
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1309
  if ((int )endian2 == 77) {
#line 1309
    if ((int )endian1 == 76) {
#line 1310
      bigendian = 0;
    } else {
      {
      {
#line 1312
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      }
#line 1313
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1312
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
#line 1313
    return ((opj_image_t *)((void *)0));
  }
#line 1318
  cmptparm.x0 = parameters->image_offset_x0;
#line 1319
  cmptparm.y0 = parameters->image_offset_y0;
#line 1320
  if (! cmptparm.x0) {
#line 1320
    tmp = (w - 1) * parameters->subsampling_dx + 1;
  } else {
#line 1320
    tmp = (cmptparm.x0 + (w - 1) * parameters->subsampling_dx) + 1;
  }
#line 1320
  cmptparm.w = tmp;
#line 1321
  if (! cmptparm.y0) {
#line 1321
    tmp___0 = (h - 1) * parameters->subsampling_dy + 1;
  } else {
#line 1321
    tmp___0 = (cmptparm.y0 + (h - 1) * parameters->subsampling_dy) + 1;
  }
#line 1321
  cmptparm.h = tmp___0;
#line 1323
  if ((int )sign == 45) {
#line 1324
    cmptparm.sgnd = 1;
  } else {
#line 1326
    cmptparm.sgnd = 0;
  }
#line 1328
  if (prec < 8) {
#line 1330
    force8 = 1;
#line 1331
    ushift = 8 - prec;
#line 1331
    dshift = prec - ushift;
#line 1332
    if (cmptparm.sgnd) {
#line 1332
      adjustS = 1 << (prec - 1);
    } else {
#line 1332
      adjustS = 0;
    }
#line 1333
    cmptparm.sgnd = 0;
#line 1334
    prec = 8;
  } else {
#line 1336
    adjustS = 0;
#line 1336
    force8 = adjustS;
#line 1336
    dshift = force8;
#line 1336
    ushift = dshift;
  }
  {
#line 1338
  cmptparm.prec = prec;
#line 1339
  cmptparm.bpp = prec;
#line 1340
  cmptparm.dx = parameters->subsampling_dx;
#line 1341
  cmptparm.dy = parameters->subsampling_dy;
#line 1344
  image = opj_image_create(numcomps, & cmptparm, color_space);
  }
#line 1345
  if (! image) {
    {
#line 1346
    fclose(f);
    }
#line 1347
    return ((opj_image_t *)((void *)0));
  }
#line 1350
  image->x0 = cmptparm.x0;
#line 1351
  image->y0 = cmptparm.x0;
#line 1352
  image->x1 = cmptparm.w;
#line 1353
  image->y1 = cmptparm.h;
#line 1357
  comp = image->comps + 0;
#line 1359
  i = 0;
  {
#line 1359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1359
    if (! (i < w * h)) {
#line 1359
      goto while_break___0;
    }
#line 1361
    if (force8) {
      {
#line 1363
      __cil_tmp31 = readuchar(f);
#line 1363
      v = (int )__cil_tmp31 + adjustS;
#line 1364
      v = (v << ushift) + (v >> dshift);
#line 1365
      *(comp->data + i) = (int )((unsigned char )v);
      }
#line 1367
      if (v > max) {
#line 1367
        max = v;
      }
#line 1369
      goto while_continue___0;
    }
#line 1371
    if (comp->prec == 8) {
#line 1372
      if (! comp->sgnd) {
        {
#line 1373
        __cil_tmp32 = readuchar(f);
#line 1373
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1375
        __cil_tmp33 = readuchar(f);
#line 1375
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1377
    if (comp->prec <= 16) {
#line 1378
      if (! comp->sgnd) {
        {
#line 1379
        __cil_tmp34 = readushort(f, bigendian);
#line 1379
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1381
        __cil_tmp35 = readushort(f, bigendian);
#line 1381
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1384
    if (! comp->sgnd) {
      {
#line 1385
      __cil_tmp36 = readuint(f, bigendian);
#line 1385
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1387
      __cil_tmp37 = readuint(f, bigendian);
#line 1387
      v = (int )__cil_tmp37;
      }
    }
#line 1390
    if (v > max) {
#line 1391
      max = v;
    }
#line 1392
    *(comp->data + i) = v;
#line 1359
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1394
  fclose(f);
#line 1395
  __cil_tmp39 = int_floorlog2(max);
#line 1395
  comp->bpp = __cil_tmp39 + 1;
  }
#line 1397
  return (image);
}
}
#line 1400 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp15 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp18 ;
  FILE *__cil_tmp19 ;
  int tmp ;
  int v ;
  char byte ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 1403
  fdest = (FILE *)((void *)0);
#line 1405
  compno = 0;
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (compno < image->numcomps)) {
#line 1405
      goto while_break;
    }
    {
#line 1406
    comp = image->comps + compno;
#line 1408
    name = (char *)bname;
#line 1409
    nbytes = 0;
#line 1411
    __cil_tmp15 = strlen(outfile);
#line 1411
    olen = __cil_tmp15;
#line 1412
    dotpos = olen - 4UL;
#line 1413
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1414
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1416
      fprintf(stderr, "ERROR -> Impossible happen.");
      }
#line 1417
      return (1);
    }
#line 1419
    if (total > 256UL) {
      {
#line 1420
      __cil_tmp18 = malloc(total + 1UL);
#line 1420
      name = (char *)__cil_tmp18;
      }
    }
    {
#line 1422
    strncpy(name, outfile, dotpos);
#line 1424
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1428
    fdest = fopen((char const   *)name, "wb\266\r`U");
    }
#line 1429
    if (! fdest) {
      {
#line 1430
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1431
      return (1);
    }
#line 1434
    if (total > 256UL) {
      {
#line 1435
      free(name);
      }
    }
#line 1438
    w = (image->comps + compno)->w;
#line 1439
    h = (image->comps + compno)->h;
#line 1441
    if (comp->sgnd) {
#line 1441
      tmp = '-';
    } else {
#line 1441
      tmp = '+';
    }
    {
#line 1441
    fprintf(fdest, "PG ML %c %d %d %d\n", tmp, comp->prec, w, h);
    }
#line 1442
    if (comp->prec <= 8) {
#line 1443
      nbytes = 1;
    } else
#line 1444
    if (comp->prec <= 16) {
#line 1445
      nbytes = 2;
    } else {
#line 1447
      nbytes = 4;
    }
#line 1449
    i = 0;
    {
#line 1449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1449
      if (! (i < w * h)) {
#line 1449
        goto while_break___0;
      }
#line 1450
      v = *((image->comps + compno)->data + i);
#line 1451
      j = nbytes - 1;
      {
#line 1451
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1451
        if (! (j >= 0)) {
#line 1451
          goto while_break___1;
        }
        {
#line 1452
        byte = (char )(v >> j * 8);
#line 1453
        res = fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1454
        if (res < 1UL) {
          {
#line 1455
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1456
          return (1);
        }
#line 1451
        __cil_tmp24 = j;
#line 1451
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1449
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1460
    fclose(fdest);
    }
#line 1405
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (0);
}
}
#line 1479 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1481
    if (! *s) {
#line 1481
      goto while_break;
    }
#line 1483
    if ((int )*s == 10) {
#line 1483
      return ((char *)((void *)0));
    } else
#line 1483
    if ((int )*s == 13) {
#line 1483
      return ((char *)((void *)0));
    }
    {
#line 1484
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1484
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1484
      s ++;
#line 1484
      goto while_continue;
    }
#line 1485
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  return ((char *)((void *)0));
}
}
#line 1490 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1495
  *out_n = 0;
#line 1495
  s = start;
#line 1497
  s = skip_white(start);
  }
#line 1498
  if (s == (void *)0) {
#line 1498
    return ((char *)((void *)0));
  }
#line 1499
  start = s;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! *s) {
#line 1501
      goto while_break;
    }
    {
#line 1503
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1503
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1503
      goto while_break;
    }
#line 1504
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  c = *s;
#line 1506
  *s = (char )0;
#line 1506
  *out_n = atoi((char const   *)start);
#line 1506
  *s = c;
  }
#line 1507
  return (s);
}
}
#line 1510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_idf(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1515
  s = skip_white(start);
  }
#line 1516
  if (s == (void *)0) {
#line 1516
    return ((char *)((void *)0));
  }
#line 1517
  start = s;
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (! *s) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1521
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    } else
#line 1521
    if ((int )*s == 95) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    }
#line 1522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1524
  c = *s;
#line 1524
  *s = (char )0;
#line 1524
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1524
  *s = c;
  }
#line 1525
  return (s);
}
}
#line 1528 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1535
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1535
  if (__cil_tmp11 == (void *)0) {
    {
#line 1537
    fprintf(stderr, "\nWARNING: fgets return a NULL value\r`U");
    }
#line 1538
    return;
  }
#line 1541
  if ((int )line[0] != 80) {
    {
#line 1543
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1543
    return;
  }
  {
#line 1545
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1546
  if (format < 1) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  } else
#line 1546
  if (format > 7) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  }
#line 1551
  ph->format = format;
#line 1552
  have_wh = 0;
#line 1552
  end = have_wh;
#line 1552
  ttype = end;
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1554
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1554
    if (! __cil_tmp13) {
#line 1554
      goto while_break;
    }
#line 1556
    if ((int )*((char *)line) == 35) {
#line 1556
      goto while_continue;
    }
#line 1558
    s = (char *)line;
#line 1560
    if (format == 7) {
      {
#line 1562
      s = skip_idf(s, (char *)idf);
      }
#line 1564
      if (s == (void *)0) {
#line 1564
        return;
      } else
#line 1564
      if ((int )*s == 0) {
#line 1564
        return;
      }
      {
#line 1566
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1566
      if (__cil_tmp15 == 0) {
#line 1568
        end = 1;
#line 1568
        goto while_break;
      }
      {
#line 1570
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHU");
      }
#line 1570
      if (__cil_tmp16 == 0) {
        {
#line 1572
        s = skip_int(s, & ph->width);
        }
#line 1573
        if (s == (void *)0) {
#line 1573
          return;
        } else
#line 1573
        if ((int )*s == 0) {
#line 1573
          return;
        }
#line 1575
        goto while_continue;
      }
      {
#line 1577
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1577
      if (__cil_tmp18 == 0) {
        {
#line 1579
        s = skip_int(s, & ph->height);
        }
#line 1580
        if (s == (void *)0) {
#line 1580
          return;
        } else
#line 1580
        if ((int )*s == 0) {
#line 1580
          return;
        }
#line 1582
        goto while_continue;
      }
      {
#line 1584
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTHU");
      }
#line 1584
      if (__cil_tmp20 == 0) {
        {
#line 1586
        s = skip_int(s, & ph->depth);
        }
#line 1587
        if (s == (void *)0) {
#line 1587
          return;
        } else
#line 1587
        if ((int )*s == 0) {
#line 1587
          return;
        }
#line 1589
        goto while_continue;
      }
      {
#line 1591
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1591
      if (__cil_tmp22 == 0) {
        {
#line 1593
        s = skip_int(s, & ph->maxval);
        }
#line 1594
        if (s == (void *)0) {
#line 1594
          return;
        } else
#line 1594
        if ((int )*s == 0) {
#line 1594
          return;
        }
#line 1596
        goto while_continue;
      }
      {
#line 1598
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1598
      if (__cil_tmp24 == 0) {
        {
#line 1600
        s = skip_idf(s, (char *)type);
        }
#line 1601
        if (s == (void *)0) {
#line 1601
          return;
        } else
#line 1601
        if ((int )*s == 0) {
#line 1601
          return;
        }
        {
#line 1603
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1603
        if (__cil_tmp26 == 0) {
#line 1605
          ph->bw = (char )1;
#line 1605
          ttype = 1;
#line 1605
          goto while_continue;
        }
        {
#line 1607
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE\223");
        }
#line 1607
        if (__cil_tmp27 == 0) {
#line 1609
          ph->gray = (char )1;
#line 1609
          ttype = 1;
#line 1609
          goto while_continue;
        }
        {
#line 1611
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1611
        if (__cil_tmp28 == 0) {
#line 1613
          ph->graya = (char )1;
#line 1613
          ttype = 1;
#line 1613
          goto while_continue;
        }
        {
#line 1615
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1615
        if (__cil_tmp29 == 0) {
#line 1617
          ph->rgb = (char )1;
#line 1617
          ttype = 1;
#line 1617
          goto while_continue;
        }
        {
#line 1619
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\001");
        }
#line 1619
        if (__cil_tmp30 == 0) {
#line 1621
          ph->rgba = (char )1;
#line 1621
          ttype = 1;
#line 1621
          goto while_continue;
        }
        {
#line 1623
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1624
        return;
      }
      {
#line 1626
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n\001", (char *)idf);
      }
#line 1627
      return;
    }
#line 1630
    if (! have_wh) {
      {
#line 1632
      s = skip_int(s, & ph->width);
#line 1634
      s = skip_int(s, & ph->height);
#line 1636
      have_wh = 1;
      }
#line 1638
      if (format == 1) {
#line 1638
        goto while_break;
      } else
#line 1638
      if (format == 4) {
#line 1638
        goto while_break;
      }
#line 1640
      goto while_continue;
    }
#line 1642
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___21: /* CIL Label */ 
      _L___22: /* CIL Label */ 
      {
#line 1645
      s = skip_int(s, & ph->maxval);
      }
#line 1647
      if (ph->maxval > 65535) {
#line 1647
        return;
      }
    } else
#line 1642
    if (format == 3) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 5) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 6) {
#line 1642
      goto _L;
    }
#line 1649
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1651
  if (format == 2) {
    _L___23: /* CIL Label */ 
    _L___24: /* CIL Label */ 
#line 1653
    if (ph->maxval < 1) {
#line 1653
      return;
    } else
#line 1653
    if (ph->maxval > 65535) {
#line 1653
      return;
    }
  } else
#line 1651
  if (format == 3) {
#line 1651
    goto _L___23;
  } else
#line 1651
  if (format > 4) {
#line 1651
    goto _L___23;
  }
#line 1655
  if (ph->width < 1) {
#line 1655
    return;
  } else
#line 1655
  if (ph->height < 1) {
#line 1655
    return;
  }
#line 1657
  if (format == 7) {
#line 1659
    if (! end) {
      {
#line 1661
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1661
      return;
    }
#line 1663
    if (ph->depth < 1) {
#line 1663
      return;
    } else
#line 1663
    if (ph->depth > 4) {
#line 1663
      return;
    }
#line 1665
    if (ph->width) {
#line 1665
      if (ph->height) {
#line 1665
        if (ph->depth & ph->maxval) {
#line 1665
          if (ttype) {
#line 1666
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1670
  if (format != 1) {
#line 1670
    if (format != 4) {
#line 1672
      if (ph->width) {
#line 1672
        if (ph->height) {
#line 1672
          if (ph->maxval) {
#line 1672
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1670
      goto _L___25;
    }
  } else {
    _L___25: /* CIL Label */ 
#line 1676
    if (ph->width) {
#line 1676
      if (ph->height) {
#line 1676
        ph->ok = (char )1;
      }
    }
#line 1677
    ph->maxval = 255;
  }
  return;
}
}
#line 1682 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1684
  if (val < 2) {
#line 1684
    return (1);
  }
#line 1685
  if (val < 4) {
#line 1685
    return (2);
  }
#line 1686
  if (val < 8) {
#line 1686
    return (3);
  }
#line 1687
  if (val < 16) {
#line 1687
    return (4);
  }
#line 1688
  if (val < 32) {
#line 1688
    return (5);
  }
#line 1689
  if (val < 64) {
#line 1689
    return (6);
  }
#line 1690
  if (val < 128) {
#line 1690
    return (7);
  }
#line 1691
  if (val < 256) {
#line 1691
    return (8);
  }
#line 1692
  if (val < 512) {
#line 1692
    return (9);
  }
#line 1693
  if (val < 1024) {
#line 1693
    return (10);
  }
#line 1694
  if (val < 2048) {
#line 1694
    return (11);
  }
#line 1695
  if (val < 4096) {
#line 1695
    return (12);
  }
#line 1696
  if (val < 8192) {
#line 1696
    return (13);
  }
#line 1697
  if (val < 16384) {
#line 1697
    return (14);
  }
#line 1698
  if (val < 32768) {
#line 1698
    return (15);
  }
#line 1699
  return (16);
}
}
#line 1702 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  FILE *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned int index___26 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int index___27 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1703
  subsampling_dx = parameters->subsampling_dx;
#line 1704
  subsampling_dy = parameters->subsampling_dy;
#line 1706
  fp = (FILE *)((void *)0);
#line 1710
  image = (opj_image_t *)((void *)0);
#line 1713
  fp = fopen(filename, "rb");
  }
#line 1713
  if (fp == (void *)0) {
    {
#line 1715
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1716
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1718
  memset(& header_info, 0, sizeof(struct pnm_header ));
#line 1720
  read_pnm_header(fp, & header_info);
  }
#line 1722
  if (! header_info.ok) {
    {
#line 1722
    fclose(fp);
    }
#line 1722
    return ((opj_image_t *)((void *)0));
  }
#line 1724
  format = header_info.format;
  {
#line 1729
  if (format == 4) {
#line 1729
    goto case_4;
  }
#line 1729
  if (format == 1) {
#line 1729
    goto case_4;
  }
#line 1734
  if (format == 5) {
#line 1734
    goto case_5;
  }
#line 1734
  if (format == 2) {
#line 1734
    goto case_5;
  }
#line 1739
  if (format == 6) {
#line 1739
    goto case_6;
  }
#line 1739
  if (format == 3) {
#line 1739
    goto case_6;
  }
#line 1743
  if (format == 7) {
#line 1743
    goto case_7;
  }
#line 1747
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1730
  numcomps = 1;
#line 1731
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1735
  numcomps = 1;
#line 1736
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1740
  numcomps = 3;
#line 1741
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1744
  numcomps = header_info.depth;
#line 1745
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1747
  fclose(fp);
  }
#line 1747
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1749
  if (numcomps < 3) {
#line 1750
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1752
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1754
  prec = has_prec(header_info.maxval);
  }
#line 1756
  if (prec < 8) {
#line 1756
    prec = 8;
  }
  {
#line 1758
  w = header_info.width;
#line 1759
  h = header_info.height;
#line 1760
  subsampling_dx = parameters->subsampling_dx;
#line 1761
  subsampling_dy = parameters->subsampling_dy;
#line 1763
  memset(& cmptparm[0], 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1765
  i = 0;
  }
  {
#line 1765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1765
    if (! (i < numcomps)) {
#line 1765
      goto while_break;
    }
#line 1767
    cmptparm[i].prec = prec;
#line 1768
    cmptparm[i].bpp = prec;
#line 1769
    cmptparm[i].sgnd = 0;
#line 1770
    cmptparm[i].dx = subsampling_dx;
#line 1771
    cmptparm[i].dy = subsampling_dy;
#line 1772
    cmptparm[i].w = w;
#line 1773
    cmptparm[i].h = h;
#line 1765
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1775
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 1777
  if (! image) {
    {
#line 1777
    fclose(fp);
    }
#line 1777
    return ((opj_image_t *)((void *)0));
  }
#line 1780
  image->x0 = parameters->image_offset_x0;
#line 1781
  image->y0 = parameters->image_offset_y0;
#line 1782
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 1783
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 1785
  if (format == 2) {
    _L___30: /* CIL Label */ 
#line 1789
    i = 0;
    {
#line 1789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1789
      if (! (i < w * h)) {
#line 1789
        goto while_break___0;
      }
#line 1791
      compno = 0;
      {
#line 1791
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1791
        if (! (compno < numcomps)) {
#line 1791
          goto while_break___1;
        }
        {
#line 1793
        index___26 = (unsigned int )0;
#line 1794
        __cil_tmp22 = fscanf(fp, "%u", & index___26);
        }
#line 1794
        if (__cil_tmp22 != 1) {
          {
#line 1795
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1797
        *((image->comps + compno)->data + i) = (int )((index___26 * 255U) / (unsigned int )header_info.maxval);
#line 1791
        compno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1789
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1785
  if (format == 3) {
#line 1785
    goto _L___30;
  } else
#line 1802
  if (format == 5) {
    _L: /* CIL Label */ 
    _L___29: /* CIL Label */ 
#line 1810
    one = (unsigned char )(prec < 9);
#line 1812
    i = 0;
    {
#line 1812
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1812
      if (! (i < w * h)) {
#line 1812
        goto while_break___2;
      }
#line 1814
      compno = 0;
      {
#line 1814
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1814
        if (! (compno < numcomps)) {
#line 1814
          goto while_break___3;
        }
        {
#line 1816
        __cil_tmp28 = fread(& c0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1816
        if (! __cil_tmp28) {
          {
#line 1817
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1818
        if (one) {
#line 1820
          *((image->comps + compno)->data + i) = (int )c0;
        } else {
          {
#line 1824
          __cil_tmp29 = fread(& c1, (unsigned long )1, (unsigned long )1, fp);
          }
#line 1824
          if (! __cil_tmp29) {
            {
#line 1825
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1827
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1814
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1812
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1802
  if (format == 6) {
#line 1802
    goto _L;
  } else
#line 1802
  if (format == 7) {
#line 1802
    if ((int )header_info.gray) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.graya) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgb) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgba) {
#line 1802
      goto _L;
    } else {
#line 1802
      goto _L___28;
    }
  } else
  _L___28: /* CIL Label */ 
#line 1833
  if (format == 1) {
#line 1835
    i = 0;
    {
#line 1835
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1835
      if (! (i < w * h)) {
#line 1835
        goto while_break___4;
      }
      {
#line 1839
      __cil_tmp33 = fscanf(fp, "%u", & index___27);
      }
#line 1839
      if (__cil_tmp33 != 1) {
        {
#line 1840
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1842
      if (index___27) {
#line 1842
        tmp = 0;
      } else {
#line 1842
        tmp = 255;
      }
#line 1842
      *((image->comps + 0)->data + i) = tmp;
#line 1835
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1846
  if (format == 4) {
#line 1851
    i = 0;
#line 1852
    y = 0;
    {
#line 1852
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1852
      if (! (y < h)) {
#line 1852
        goto while_break___5;
      }
#line 1854
      bit = - 1;
#line 1854
      uc = (unsigned char )0;
#line 1856
      x = 0;
      {
#line 1856
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1856
        if (! (x < w)) {
#line 1856
          goto while_break___6;
        }
#line 1858
        if (bit == -1) {
          {
#line 1860
          bit = 7;
#line 1861
          __cil_tmp40 = getc(fp);
#line 1861
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1863
        if (((int )uc >> bit) & 1) {
#line 1863
          tmp___0 = 0;
        } else {
#line 1863
          tmp___0 = 255;
        }
#line 1863
        *((image->comps + 0)->data + i) = tmp___0;
#line 1864
        bit --;
#line 1864
        i ++;
#line 1856
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1852
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1869
  if (format == 7) {
#line 1869
    if ((int )header_info.bw) {
#line 1873
      i = 0;
      {
#line 1873
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1873
        if (! (i < w * h)) {
#line 1873
          goto while_break___7;
        }
        {
#line 1875
        __cil_tmp43 = fread(& uc___0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1875
        if (! __cil_tmp43) {
          {
#line 1876
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1877
        if ((int )uc___0 & 1) {
#line 1877
          tmp___1 = 0;
        } else {
#line 1877
          tmp___1 = 255;
        }
#line 1877
        *((image->comps + 0)->data + i) = tmp___1;
#line 1873
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 1880
  fclose(fp);
  }
#line 1882
  return (image);
}
}
#line 1885 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  int compno ;
  int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  FILE *__cil_tmp27 ;
  char const   *tt ;
  char const   *tmp___31 ;
  char const   *__cil_tmp30 ;
  int tmp___32 ;
  char const   *__cil_tmp32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  FILE *__cil_tmp42 ;
  char const   *__cil_tmp43 ;
  int tmp___36 ;
  int *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;

  {
#line 1893
  fdest = (FILE *)((void *)0);
#line 1894
  tmp = outfile;
#line 1896
  alpha = (int *)((void *)0);
#line 1897
  prec = (image->comps + 0)->prec;
#line 1897
  if (prec > 16) {
    {
#line 1899
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n",
            "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c", 1900,
            prec);
    }
#line 1901
    return (1);
  }
#line 1903
  has_alpha = 0;
#line 1903
  two = has_alpha;
#line 1903
  fails = 1;
#line 1904
  ncomp = image->numcomps;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    if (! *tmp) {
#line 1906
      goto while_break;
    }
#line 1906
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  tmp -= 2;
#line 1907
  want_gray = (int )*tmp == 103 || (int )*tmp == 71;
#line 1908
  ncomp = image->numcomps;
#line 1910
  if (want_gray) {
#line 1910
    ncomp = 1;
  }
#line 1912
  if (ncomp == 2) {
    _L: /* CIL Label */ 
    {
#line 1922
    fdest = fopen(outfile, "wb\267\r`U");
    }
#line 1924
    if (! fdest) {
      {
#line 1926
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1927
      return (fails);
    }
#line 1929
    two = prec > 8;
#line 1930
    triple = ncomp > 2;
#line 1931
    wr = (image->comps + 0)->w;
#line 1931
    hr = (image->comps + 0)->h;
#line 1932
    max = (1 << prec) - 1;
#line 1932
    has_alpha = ncomp == 4 || ncomp == 2;
#line 1934
    red = (image->comps + 0)->data;
#line 1936
    if (triple) {
#line 1938
      green = (image->comps + 1)->data;
#line 1939
      blue = (image->comps + 2)->data;
    } else {
#line 1941
      blue = (int *)((void *)0);
#line 1941
      green = blue;
    }
#line 1943
    if (has_alpha) {
#line 1945
      if (triple) {
#line 1945
        tmp___31 = "RGB_ALPHA";
      } else {
#line 1945
        tmp___31 = "GRAYSCALE_ALPHA";
      }
      {
#line 1945
      tt = tmp___31;
#line 1947
      __cil_tmp30 = opj_version();
#line 1947
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 1950
      alpha = (image->comps + (ncomp - 1))->data;
      }
#line 1951
      if ((image->comps + (ncomp - 1))->sgnd) {
#line 1951
        tmp___32 = 1 << ((image->comps + (ncomp - 1))->prec - 1);
      } else {
#line 1951
        tmp___32 = 0;
      }
#line 1951
      adjustA = tmp___32;
    } else {
      {
#line 1956
      __cil_tmp32 = opj_version();
#line 1956
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp32, wr, hr, max);
#line 1958
      adjustA = 0;
      }
    }
#line 1960
    if ((image->comps + 0)->sgnd) {
#line 1960
      tmp___33 = 1 << ((image->comps + 0)->prec - 1);
    } else {
#line 1960
      tmp___33 = 0;
    }
#line 1960
    adjustR = tmp___33;
#line 1962
    if (triple) {
#line 1964
      if ((image->comps + 1)->sgnd) {
#line 1964
        tmp___34 = 1 << ((image->comps + 1)->prec - 1);
      } else {
#line 1964
        tmp___34 = 0;
      }
#line 1964
      adjustG = tmp___34;
#line 1965
      if ((image->comps + 2)->sgnd) {
#line 1965
        tmp___35 = 1 << ((image->comps + 2)->prec - 1);
      } else {
#line 1965
        tmp___35 = 0;
      }
#line 1965
      adjustB = tmp___35;
    } else {
#line 1967
      adjustB = 0;
#line 1967
      adjustG = adjustB;
    }
#line 1969
    i = 0;
    {
#line 1969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1969
      if (! (i < wr * hr)) {
#line 1969
        goto while_break___0;
      }
#line 1971
      if (two) {
        {
#line 1973
        v = *red + adjustR;
#line 1973
        red ++;
#line 1975
        fprintf(fdest, "%c%c`U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 1977
        if (triple) {
          {
#line 1979
          v = *green + adjustG;
#line 1979
          green ++;
#line 1981
          fprintf(fdest, "%c%c`U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 1983
          v = *blue + adjustB;
#line 1983
          blue ++;
#line 1985
          fprintf(fdest, "%c%c`U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1989
        if (has_alpha) {
          {
#line 1991
          v = *alpha + adjustA;
#line 1991
          alpha ++;
#line 1993
          fprintf(fdest, "%c%c`U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1995
        goto while_continue___0;
      }
      {
#line 2001
      __cil_tmp36 = red;
#line 2001
      red ++;
#line 2001
      fprintf(fdest, "%c", (int )((unsigned char )*__cil_tmp36));
      }
#line 2002
      if (triple) {
#line 2003
        __cil_tmp37 = green;
#line 2003
        green ++;
        {
#line 2003
        __cil_tmp38 = blue;
#line 2003
        blue ++;
#line 2003
        fprintf(fdest, "%c%c`U", (int )((unsigned char )*__cil_tmp37), (int )((unsigned char )*__cil_tmp38));
        }
      }
#line 2005
      if (has_alpha) {
        {
#line 2006
        __cil_tmp39 = alpha;
#line 2006
        alpha ++;
#line 2006
        fprintf(fdest, "%c\267\r`U", (int )((unsigned char )*__cil_tmp39));
        }
      }
#line 1969
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2010
    fclose(fdest);
    }
#line 2010
    return (0);
  } else
#line 1912
  if (ncomp > 2) {
#line 1912
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1912
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1912
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1912
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1912
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1912
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1912
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2015
  if (image->numcomps > ncomp) {
    {
#line 2017
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2018
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2020
  __cil_tmp40 = strlen(outfile);
#line 2020
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2020
  destname = (char *)__cil_tmp41;
#line 2022
  compno = 0;
  }
  {
#line 2022
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2022
    if (! (compno < ncomp)) {
#line 2022
      goto while_break___1;
    }
#line 2024
    if (ncomp > 1) {
      {
#line 2025
      sprintf(destname, "%d.%s", compno, outfile);
      }
    } else {
      {
#line 2027
      sprintf(destname, "%s", outfile);
      }
    }
    {
#line 2029
    fdest = fopen((char const   *)destname, "wb");
    }
#line 2030
    if (! fdest) {
      {
#line 2032
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2033
      free(destname);
      }
#line 2034
      return (1);
    }
    {
#line 2036
    wr = (image->comps + compno)->w;
#line 2036
    hr = (image->comps + compno)->h;
#line 2037
    prec = (image->comps + compno)->prec;
#line 2038
    max = (1 << prec) - 1;
#line 2040
    __cil_tmp43 = opj_version();
#line 2040
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp43, wr, hr, max);
#line 2043
    red = (image->comps + compno)->data;
    }
#line 2044
    if ((image->comps + compno)->sgnd) {
#line 2044
      tmp___36 = 1 << ((image->comps + compno)->prec - 1);
    } else {
#line 2044
      tmp___36 = 0;
    }
#line 2044
    adjustR = tmp___36;
#line 2047
    if (prec > 8) {
#line 2049
      i = 0;
      {
#line 2049
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2049
        if (! (i < wr * hr)) {
#line 2049
          goto while_break___2;
        }
        {
#line 2051
        v = *red + adjustR;
#line 2051
        red ++;
#line 2053
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2055
        if (has_alpha) {
          {
#line 2057
          __cil_tmp45 = alpha;
#line 2057
          alpha ++;
#line 2057
          v = *__cil_tmp45;
#line 2059
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2049
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2065
      i = 0;
      {
#line 2065
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2065
        if (! (i < wr * hr)) {
#line 2065
          goto while_break___3;
        }
        {
#line 2067
        fprintf(fdest, "%c\270\r`U", (int )((unsigned char )(*red + adjustR)));
#line 2067
        red ++;
        }
#line 2065
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2070
    fclose(fdest);
    }
#line 2022
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2072
  free(destname);
  }
#line 2074
  return (0);
}
}
#line 2792 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_image_t *__cil_tmp19 ;
  unsigned char value ;
  unsigned long __cil_tmp21 ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned short value___0 ;
  unsigned char temp ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int tmp___0 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;

  {
#line 2793
  subsampling_dx = parameters->subsampling_dx;
#line 2794
  subsampling_dy = parameters->subsampling_dy;
#line 2796
  f = (FILE *)((void *)0);
#line 2800
  image = (opj_image_t *)((void *)0);
#line 2803
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2805
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
#line 2806
    fprintf(stderr, "Please use the Format option -F:\n\202\267\r`U");
#line 2807
    fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 2808
    fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 2809
    fprintf(stderr, "Aborting\n");
    }
#line 2810
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2813
  f = fopen(filename, "rb");
  }
#line 2814
  if (! f) {
    {
#line 2815
    fprintf(stderr, "Failed to open %s for reading !!\n\300\270\r`U", filename);
#line 2816
    fprintf(stderr, "Aborting\n\277\270\r`U");
    }
#line 2817
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2819
  numcomps = raw_cp->rawComp;
#line 2820
  color_space = (OPJ_COLOR_SPACE )1;
#line 2821
  w = raw_cp->rawWidth;
#line 2822
  h = raw_cp->rawHeight;
#line 2823
  __cil_tmp17 = malloc((unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2823
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp17;
#line 2826
  memset(cmptparm + 0, 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2827
  i = 0;
  }
  {
#line 2827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2827
    if (! (i < numcomps)) {
#line 2827
      goto while_break;
    }
#line 2828
    (cmptparm + i)->prec = raw_cp->rawBitDepth;
#line 2829
    (cmptparm + i)->bpp = raw_cp->rawBitDepth;
#line 2830
    (cmptparm + i)->sgnd = raw_cp->rawSigned;
#line 2831
    (cmptparm + i)->dx = subsampling_dx;
#line 2832
    (cmptparm + i)->dy = subsampling_dy;
#line 2833
    (cmptparm + i)->w = w;
#line 2834
    (cmptparm + i)->h = h;
#line 2827
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2837
  image = opj_image_create(numcomps, cmptparm + 0, color_space);
  }
#line 2838
  if (! image) {
    {
#line 2839
    fclose(f);
    }
#line 2840
    return ((opj_image_t *)((void *)0));
  }
#line 2843
  image->x0 = parameters->image_offset_x0;
#line 2844
  image->y0 = parameters->image_offset_y0;
#line 2845
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 2846
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 2848
  if (raw_cp->rawBitDepth <= 8) {
#line 2850
    value = (unsigned char )0;
#line 2851
    compno = 0;
    {
#line 2851
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2851
      if (! (compno < numcomps)) {
#line 2851
        goto while_break___0;
      }
#line 2852
      i = 0;
      {
#line 2852
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2852
        if (! (i < w * h)) {
#line 2852
          goto while_break___1;
        }
        {
#line 2853
        __cil_tmp21 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 2853
        if (! __cil_tmp21) {
          {
#line 2854
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2855
          return ((opj_image_t *)((void *)0));
        }
#line 2857
        if (raw_cp->rawSigned) {
#line 2857
          tmp = (int )((char )value);
        } else {
#line 2857
          tmp = (int )value;
        }
#line 2857
        *((image->comps + compno)->data + i) = tmp;
#line 2852
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2851
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 2861
  if (raw_cp->rawBitDepth <= 16) {
#line 2864
    compno = 0;
    {
#line 2864
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2864
      if (! (compno < numcomps)) {
#line 2864
        goto while_break___2;
      }
#line 2865
      i = 0;
      {
#line 2865
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2865
        if (! (i < w * h)) {
#line 2865
          goto while_break___3;
        }
        {
#line 2867
        __cil_tmp27 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2867
        if (! __cil_tmp27) {
          {
#line 2868
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2869
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2871
        value___0 = (unsigned short )((int )temp << 8);
#line 2872
        __cil_tmp28 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2872
        if (! __cil_tmp28) {
          {
#line 2873
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2874
          return ((opj_image_t *)((void *)0));
        }
#line 2876
        value___0 += (int )temp;
#line 2877
        if (raw_cp->rawSigned) {
#line 2877
          tmp___0 = (int )((short )value___0);
        } else {
#line 2877
          tmp___0 = (int )value___0;
        }
#line 2877
        *((image->comps + compno)->data + i) = tmp___0;
#line 2865
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2864
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 2882
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n");
    }
#line 2883
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2886
  __cil_tmp32 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 2886
  if (__cil_tmp32) {
    {
#line 2887
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
  }
  {
#line 2889
  fclose(f);
  }
#line 2891
  return (image);
}
}
#line 2894 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  FILE *rawFile ;
  size_t res ;
  int compno ;
  int w ;
  int h ;
  int line ;
  int row ;
  int *ptr ;
  FILE *__cil_tmp11 ;
  char const   *tmp ;
  signed char curr ;
  int mask ;
  unsigned long __cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char curr___0 ;
  int mask___0 ;
  unsigned long __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  short curr___1 ;
  int mask___1 ;
  unsigned char temp ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned short curr___2 ;
  int mask___2 ;
  unsigned char temp___0 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 2896
  rawFile = (FILE *)((void *)0);
#line 2903
  if ((image->numcomps * image->x1) * image->y1 == 0) {
    {
#line 2905
    fprintf(stderr, "\nError: invalid raw image parameters\n");
    }
#line 2906
    return (1);
  }
  {
#line 2909
  rawFile = fopen(outfile, "wb\271\r`U");
  }
#line 2910
  if (! rawFile) {
    {
#line 2911
    fprintf(stderr, "Failed to open %s for writing !!\ng\270\r`U", outfile);
    }
#line 2912
    return (1);
  }
  {
#line 2915
  fprintf(stdout, "Raw image characteristics: %d components\n", image->numcomps);
#line 2917
  compno = 0;
  }
  {
#line 2917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2917
    if (! (compno < image->numcomps)) {
#line 2917
      goto while_break;
    }
#line 2919
    if ((image->comps + compno)->sgnd == 1) {
#line 2919
      tmp = "signed";
    } else {
#line 2919
      tmp = "unsigned\220";
    }
    {
#line 2919
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 2922
    w = (image->comps + compno)->w;
#line 2923
    h = (image->comps + compno)->h;
    }
#line 2925
    if ((image->comps + compno)->prec <= 8) {
#line 2927
      if ((image->comps + compno)->sgnd == 1) {
#line 2930
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2931
        ptr = (image->comps + compno)->data;
#line 2932
        line = 0;
        {
#line 2932
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2932
          if (! (line < h)) {
#line 2932
            goto while_break___0;
          }
#line 2933
          row = 0;
          {
#line 2933
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2933
            if (! (row < w)) {
#line 2933
              goto while_break___1;
            }
            {
#line 2934
            curr = (signed char )(*ptr & mask);
#line 2935
            res = fwrite(& curr, sizeof(signed char ), (unsigned long )1, rawFile);
            }
#line 2936
            if (res < 1UL) {
              {
#line 2937
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2938
              return (1);
            }
#line 2940
            ptr ++;
#line 2933
            row ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2932
          line ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 2944
      if ((image->comps + compno)->sgnd == 0) {
#line 2947
        mask___0 = (1 << (image->comps + compno)->prec) - 1;
#line 2948
        ptr = (image->comps + compno)->data;
#line 2949
        line = 0;
        {
#line 2949
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2949
          if (! (line < h)) {
#line 2949
            goto while_break___2;
          }
#line 2950
          row = 0;
          {
#line 2950
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2950
            if (! (row < w)) {
#line 2950
              goto while_break___3;
            }
            {
#line 2951
            curr___0 = (unsigned char )(*ptr & mask___0);
#line 2952
            res = fwrite(& curr___0, sizeof(unsigned char ), (unsigned long )1, rawFile);
            }
#line 2953
            if (res < 1UL) {
              {
#line 2954
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2955
              return (1);
            }
#line 2957
            ptr ++;
#line 2950
            row ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2949
          line ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 2962
    if ((image->comps + compno)->prec <= 16) {
#line 2964
      if ((image->comps + compno)->sgnd == 1) {
#line 2967
        mask___1 = (1 << (image->comps + compno)->prec) - 1;
#line 2968
        ptr = (image->comps + compno)->data;
#line 2969
        line = 0;
        {
#line 2969
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2969
          if (! (line < h)) {
#line 2969
            goto while_break___4;
          }
#line 2970
          row = 0;
          {
#line 2970
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2970
            if (! (row < w)) {
#line 2970
              goto while_break___5;
            }
            {
#line 2972
            curr___1 = (short )(*ptr & mask___1);
#line 2973
            temp = (unsigned char )((int )curr___1 >> 8);
#line 2974
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2975
            if (res < 1UL) {
              {
#line 2976
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2977
              return (1);
            }
            {
#line 2979
            temp = (unsigned char )curr___1;
#line 2980
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2981
            if (res < 1UL) {
              {
#line 2982
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2983
              return (1);
            }
#line 2985
            ptr ++;
#line 2970
            row ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2969
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2989
      if ((image->comps + compno)->sgnd == 0) {
#line 2992
        mask___2 = (1 << (image->comps + compno)->prec) - 1;
#line 2993
        ptr = (image->comps + compno)->data;
#line 2994
        line = 0;
        {
#line 2994
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2994
          if (! (line < h)) {
#line 2994
            goto while_break___6;
          }
#line 2995
          row = 0;
          {
#line 2995
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2995
            if (! (row < w)) {
#line 2995
              goto while_break___7;
            }
            {
#line 2997
            curr___2 = (unsigned short )(*ptr & mask___2);
#line 2998
            temp___0 = (unsigned char )((int )curr___2 >> 8);
#line 2999
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3000
            if (res < 1UL) {
              {
#line 3001
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3002
              return (1);
            }
            {
#line 3004
            temp___0 = (unsigned char )curr___2;
#line 3005
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3006
            if (res < 1UL) {
              {
#line 3007
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3008
              return (1);
            }
#line 3010
            ptr ++;
#line 2995
            row ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2994
          line ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    } else
#line 3015
    if ((image->comps + compno)->prec <= 32) {
      {
#line 3017
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
      }
#line 3018
      return (1);
    } else {
      {
#line 3022
      fprintf(stderr, "Error: invalid precision: %d\nU", (image->comps + compno)->prec);
      }
#line 3023
      return (1);
    }
#line 2917
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3026
  fclose(rawFile);
  }
#line 3027
  return (0);
}
}
#line 62 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 67
  cb -= offset;
#line 67
  cr -= offset;
#line 68
  r = y + (int )(1.402 * (double )((float )cr));
#line 69
  if (r < 0) {
#line 69
    r = 0;
  } else
#line 69
  if (r > upb) {
#line 69
    r = upb;
  }
#line 69
  *out_r = r;
#line 71
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 72
  if (g < 0) {
#line 72
    g = 0;
  } else
#line 72
  if (g > upb) {
#line 72
    g = upb;
  }
#line 72
  *out_g = g;
#line 74
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 75
  if (b < 0) {
#line 75
    b = 0;
  } else
#line 75
  if (b > upb) {
#line 75
    b = upb;
  }
#line 75
  *out_b = b;
  return;
}
}
#line 78 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 84
  i = (img->comps + 0)->prec;
#line 85
  offset = 1 << (i - 1);
#line 85
  upb = (1 << i) - 1;
#line 87
  maxw = (img->comps + 0)->w;
#line 87
  maxh = (img->comps + 0)->h;
#line 88
  max = maxw * maxh;
#line 90
  y = (int const   *)(img->comps + 0)->data;
#line 91
  cb = (int const   *)(img->comps + 1)->data;
#line 92
  cr = (int const   *)(img->comps + 2)->data;
#line 94
  __cil_tmp17 = malloc(sizeof(int ) * (unsigned long )max);
#line 94
  r = (int *)__cil_tmp17;
#line 94
  d0 = r;
#line 95
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 95
  g = (int *)__cil_tmp18;
#line 95
  d1 = g;
#line 96
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 96
  b = (int *)__cil_tmp19;
#line 96
  d2 = b;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < max)) {
#line 98
      goto while_break;
    }
    {
#line 100
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 102
    y ++;
#line 102
    cb ++;
#line 102
    cr ++;
#line 102
    r ++;
#line 102
    g ++;
#line 102
    b ++;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  free((img->comps + 0)->data);
#line 104
  (img->comps + 0)->data = d0;
#line 105
  free((img->comps + 1)->data);
#line 105
  (img->comps + 1)->data = d1;
#line 106
  free((img->comps + 2)->data);
#line 106
  (img->comps + 2)->data = d2;
  }
  return;
}
}
#line 110 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 117
  i = (img->comps + 0)->prec;
#line 118
  offset = 1 << (i - 1);
#line 118
  upb = (1 << i) - 1;
#line 120
  maxw = (img->comps + 0)->w;
#line 120
  maxh = (img->comps + 0)->h;
#line 121
  max = maxw * maxh;
#line 123
  y = (int const   *)(img->comps + 0)->data;
#line 124
  cb = (int const   *)(img->comps + 1)->data;
#line 125
  cr = (int const   *)(img->comps + 2)->data;
#line 127
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 127
  r = (int *)__cil_tmp18;
#line 127
  d0 = r;
#line 128
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 128
  g = (int *)__cil_tmp19;
#line 128
  d1 = g;
#line 129
  __cil_tmp20 = malloc(sizeof(int ) * (unsigned long )max);
#line 129
  b = (int *)__cil_tmp20;
#line 129
  d2 = b;
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < maxh)) {
#line 131
      goto while_break;
    }
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! (j < maxw)) {
#line 133
        goto while_break___0;
      }
      {
#line 135
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 137
      y ++;
#line 137
      r ++;
#line 137
      g ++;
#line 137
      b ++;
#line 139
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 141
      y ++;
#line 141
      r ++;
#line 141
      g ++;
#line 141
      b ++;
#line 141
      cb ++;
#line 141
      cr ++;
      }
#line 133
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((img->comps + 0)->data);
#line 144
  (img->comps + 0)->data = d0;
#line 145
  free((img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  free((img->comps + 2)->data);
#line 146
  (img->comps + 2)->data = d2;
#line 148
  (img->comps + 1)->w = maxw;
#line 148
  (img->comps + 1)->h = maxh;
#line 149
  (img->comps + 2)->w = maxw;
#line 149
  (img->comps + 2)->h = maxh;
#line 150
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 151
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 152
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 153
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 164
  i = (img->comps + 0)->prec;
#line 165
  offset = 1 << (i - 1);
#line 165
  upb = (1 << i) - 1;
#line 167
  maxw = (img->comps + 0)->w;
#line 167
  maxh = (img->comps + 0)->h;
#line 168
  max = maxw * maxh;
#line 170
  y = (int const   *)(img->comps + 0)->data;
#line 171
  cb = (int const   *)(img->comps + 1)->data;
#line 172
  cr = (int const   *)(img->comps + 2)->data;
#line 174
  __cil_tmp22 = malloc(sizeof(int ) * (unsigned long )max);
#line 174
  r = (int *)__cil_tmp22;
#line 174
  d0 = r;
#line 175
  __cil_tmp23 = malloc(sizeof(int ) * (unsigned long )max);
#line 175
  g = (int *)__cil_tmp23;
#line 175
  d1 = g;
#line 176
  __cil_tmp24 = malloc(sizeof(int ) * (unsigned long )max);
#line 176
  b = (int *)__cil_tmp24;
#line 176
  d2 = b;
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < maxh)) {
#line 178
      goto while_break;
    }
#line 180
    ny = y + maxw;
#line 181
    nr = r + maxw;
#line 181
    ng = g + maxw;
#line 181
    nb = b + maxw;
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < maxw)) {
#line 183
        goto while_break___0;
      }
      {
#line 185
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 187
      y ++;
#line 187
      r ++;
#line 187
      g ++;
#line 187
      b ++;
#line 189
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 191
      y ++;
#line 191
      r ++;
#line 191
      g ++;
#line 191
      b ++;
#line 193
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 195
      ny ++;
#line 195
      nr ++;
#line 195
      ng ++;
#line 195
      nb ++;
#line 197
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 199
      ny ++;
#line 199
      nr ++;
#line 199
      ng ++;
#line 199
      nb ++;
#line 199
      cb ++;
#line 199
      cr ++;
      }
#line 183
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 201
    y += maxw;
#line 201
    r += maxw;
#line 201
    g += maxw;
#line 201
    b += maxw;
#line 178
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  free((img->comps + 0)->data);
#line 203
  (img->comps + 0)->data = d0;
#line 204
  free((img->comps + 1)->data);
#line 204
  (img->comps + 1)->data = d1;
#line 205
  free((img->comps + 2)->data);
#line 205
  (img->comps + 2)->data = d2;
#line 207
  (img->comps + 1)->w = maxw;
#line 207
  (img->comps + 1)->h = maxh;
#line 208
  (img->comps + 2)->w = maxw;
#line 208
  (img->comps + 2)->h = maxh;
#line 209
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 210
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 211
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 212
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 218
  if (img->numcomps < 3) {
#line 220
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 221
    return;
  }
#line 224
  if ((img->comps + 0)->dx == 1) {
#line 224
    if ((img->comps + 1)->dx == 2) {
#line 224
      if ((img->comps + 2)->dx == 2) {
#line 224
        if ((img->comps + 0)->dy == 1) {
#line 224
          if ((img->comps + 1)->dy == 2) {
#line 224
            if ((img->comps + 2)->dy == 2) {
              {
#line 231
              sycc420_to_rgb(img);
              }
            } else {
#line 224
              goto _L___41;
            }
          } else {
#line 224
            goto _L___41;
          }
        } else {
#line 224
          goto _L___41;
        }
      } else {
#line 224
        goto _L___41;
      }
    } else {
#line 224
      goto _L___41;
    }
  } else
  _L___41: /* CIL Label */ 
  _L___42: /* CIL Label */ 
  _L___43: /* CIL Label */ 
  _L___44: /* CIL Label */ 
  _L___45: /* CIL Label */ 
#line 234
  if ((img->comps + 0)->dx == 1) {
#line 234
    if ((img->comps + 1)->dx == 2) {
#line 234
      if ((img->comps + 2)->dx == 2) {
#line 234
        if ((img->comps + 0)->dy == 1) {
#line 234
          if ((img->comps + 1)->dy == 1) {
#line 234
            if ((img->comps + 2)->dy == 1) {
              {
#line 241
              sycc422_to_rgb(img);
              }
            } else {
#line 234
              goto _L;
            }
          } else {
#line 234
            goto _L;
          }
        } else {
#line 234
          goto _L;
        }
      } else {
#line 234
        goto _L;
      }
    } else {
#line 234
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___37: /* CIL Label */ 
  _L___38: /* CIL Label */ 
  _L___39: /* CIL Label */ 
  _L___40: /* CIL Label */ 
#line 244
  if ((img->comps + 0)->dx == 1) {
#line 244
    if ((img->comps + 1)->dx == 1) {
#line 244
      if ((img->comps + 2)->dx == 1) {
#line 244
        if ((img->comps + 0)->dy == 1) {
#line 244
          if ((img->comps + 1)->dy == 1) {
#line 244
            if ((img->comps + 2)->dy == 1) {
              {
#line 251
              sycc444_to_rgb(img);
              }
            } else {
              {
              {
              {
              {
              {
              {
#line 255
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                      256);
              }
              }
              }
              }
              }
              }
#line 257
              return;
            }
          } else {
            {
            {
            {
            {
            {
            {
#line 255
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                    256);
            }
            }
            }
            }
            }
            }
#line 257
            return;
          }
        } else {
          {
          {
          {
          {
          {
          {
#line 255
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                  256);
          }
          }
          }
          }
          }
          }
#line 257
          return;
        }
      } else {
        {
        {
        {
        {
        {
        {
#line 255
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                256);
        }
        }
        }
        }
        }
        }
#line 257
        return;
      }
    } else {
      {
      {
      {
      {
      {
      {
#line 255
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
              256);
      }
      }
      }
      }
      }
      }
#line 257
      return;
    }
  } else {
    {
    {
    {
    {
    {
    {
#line 255
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
            256);
    }
    }
    }
    }
    }
    }
#line 257
    return;
  }
#line 259
  img->color_space = (OPJ_COLOR_SPACE )1;
  return;
}
}
#line 53 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
static char EMSG___0[1]  = {      "\250"};
#line 379 "../../libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "../../libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 103 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_dump.c"
static void j2k_dump_image(FILE *fd , opj_image_t *img ) ;
#line 104
static void j2k_dump_cp(FILE *fd , opj_image_t *img , opj_cp_t *cp ) ;
#line 604 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_dump.c"
static void j2k_dump_image(FILE *fd , opj_image_t *img ) 
{ 
  int compno ;
  opj_image_comp_t *comp ;
  int __cil_tmp5 ;

  {
  {
#line 606
  fprintf(fd, "image {\n\220");
#line 607
  fprintf(fd, "  x0=%d, y0=%d, x1=%d, y1=%d\n", img->x0, img->y0, img->x1, img->y1);
#line 608
  fprintf(fd, "  numcomps=%d\n", img->numcomps);
#line 609
  compno = 0;
  }
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! (compno < img->numcomps)) {
#line 609
      goto while_break;
    }
    {
#line 610
    comp = img->comps + compno;
#line 611
    fprintf(fd, "  comp %d {\n", compno);
#line 612
    fprintf(fd, "    dx=%d, dy=%d\n", comp->dx, comp->dy);
#line 613
    fprintf(fd, "    prec=%d\n", comp->prec);
#line 615
    fprintf(fd, "    sgnd=%d\n", comp->sgnd);
#line 616
    fprintf(fd, "  }\n");
    }
#line 609
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 618
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 621 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_dump.c"
static void j2k_dump_cp(FILE *fd , opj_image_t *img , opj_cp_t *cp ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int bandno ;
  int resno ;
  int numbands ;
  opj_tcp_t *tcp ;
  int __cil_tmp11 ;
  opj_tccp_t *tccp ;
  int tmp ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 623
  fprintf(fd, "coding parameters {\n`U");
#line 624
  fprintf(fd, "  tx0=%d, ty0=%d\n", cp->tx0, cp->ty0);
#line 625
  fprintf(fd, "  tdx=%d, tdy=%d\n\237\377\r`U", cp->tdx, cp->tdy);
#line 626
  fprintf(fd, "  tw=%d, th=%d\n", cp->tw, cp->th);
#line 627
  tileno = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (tileno < cp->tw * cp->th)) {
#line 627
      goto while_break;
    }
    {
#line 628
    tcp = cp->tcps + tileno;
#line 629
    fprintf(fd, "  tile %d {\n", tileno);
#line 630
    fprintf(fd, "    csty=%x\n", tcp->csty);
#line 631
    fprintf(fd, "    prg=%d\n\r`U", (int )tcp->prg);
#line 632
    fprintf(fd, "    numlayers=%d\n\247\377\r`U", tcp->numlayers);
#line 633
    fprintf(fd, "    mct=%d\n\r`U", tcp->mct);
#line 634
    fprintf(fd, "    rates=");
#line 635
    layno = 0;
    }
    {
#line 635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 635
      if (! (layno < tcp->numlayers)) {
#line 635
        goto while_break___0;
      }
      {
#line 636
      fprintf(fd, "%.1f ", (double )tcp->rates[layno]);
      }
#line 635
      layno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 638
    fprintf(fd, "\n\030\363\r`U");
#line 639
    compno = 0;
    }
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 639
      if (! (compno < img->numcomps)) {
#line 639
        goto while_break___1;
      }
      {
#line 640
      tccp = tcp->tccps + compno;
#line 641
      fprintf(fd, "    comp %d {\n", compno);
#line 642
      fprintf(fd, "      csty=%x\n", tccp->csty);
#line 643
      fprintf(fd, "      numresolutions=%d\n\230\001", tccp->numresolutions);
#line 644
      fprintf(fd, "      cblkw=%d\n", tccp->cblkw);
#line 645
      fprintf(fd, "      cblkh=%d\n", tccp->cblkh);
#line 646
      fprintf(fd, "      cblksty=%x\n", tccp->cblksty);
#line 647
      fprintf(fd, "      qmfbid=%d\n\230\001", tccp->qmfbid);
#line 648
      fprintf(fd, "      qntsty=%d\n\230\001", tccp->qntsty);
#line 649
      fprintf(fd, "      numgbits=%d\n", tccp->numgbits);
#line 650
      fprintf(fd, "      roishift=%d\n\376\r`U", tccp->roishift);
#line 651
      fprintf(fd, "      stepsizes=\220");
      }
#line 652
      if (tccp->qntsty == 1) {
#line 652
        tmp = 1;
      } else {
#line 652
        tmp = tccp->numresolutions * 3 - 2;
      }
#line 652
      numbands = tmp;
#line 653
      bandno = 0;
      {
#line 653
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 653
        if (! (bandno < numbands)) {
#line 653
          goto while_break___2;
        }
        {
#line 654
        fprintf(fd, "(%d,%d) \230\001", tccp->stepsizes[bandno].mant, tccp->stepsizes[bandno].expn);
        }
#line 653
        bandno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 657
      fprintf(fd, "\n\342\376\r`U");
      }
#line 659
      if (tccp->csty & 1) {
        {
#line 660
        fprintf(fd, "      prcw=");
#line 661
        resno = 0;
        }
        {
#line 661
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 661
          if (! (resno < tccp->numresolutions)) {
#line 661
            goto while_break___3;
          }
          {
#line 662
          fprintf(fd, "%d \r`U", tccp->prcw[resno]);
          }
#line 661
          resno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 664
        fprintf(fd, "\n5\377\r`U");
#line 665
        fprintf(fd, "      prch=\r`U");
#line 666
        resno = 0;
        }
        {
#line 666
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 666
          if (! (resno < tccp->numresolutions)) {
#line 666
            goto while_break___4;
          }
          {
#line 667
          fprintf(fd, "%d \r`U", tccp->prch[resno]);
          }
#line 666
          resno ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 669
        fprintf(fd, "\n");
        }
      }
      {
#line 671
      fprintf(fd, "    }\n");
      }
#line 639
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 673
    fprintf(fd, "  }\n");
    }
#line 627
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 53 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
static char EMSG___1[1]  = {      "\250"};
#line 85 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
void encode_help_display(void) 
{ 


  {
  {
#line 86
  fprintf(stdout, "HELP for image_to_j2k\n----\n\n`U");
#line 87
  fprintf(stdout, "- the -h option displays this help information on screen\n\nP\016`U");
#line 90
  fprintf(stdout, "List of parameters for the JPEG 2000 encoder:\n\001");
#line 96
  fprintf(stdout, "\n\222\001");
#line 97
  fprintf(stdout, "REMARKS:\n7Q\016`U");
#line 98
  fprintf(stdout, "---------\nQ\016`U");
#line 99
  fprintf(stdout, "\nxN\016`U");
#line 100
  fprintf(stdout, "The markers written to the main_header are : SOC SIZ COD QCD COM.\n\001");
#line 101
  fprintf(stdout, "COD and QCD never appear in the tile_header.\nU");
#line 102
  fprintf(stdout, "\n\375R\016`U");
#line 103
  fprintf(stdout, "By default:\n`U");
#line 104
  fprintf(stdout, "------------\nU");
#line 105
  fprintf(stdout, "\n\255S\016`U");
#line 106
  fprintf(stdout, " * Lossless\n");
#line 107
  fprintf(stdout, " * 1 tile\nT\016`U");
#line 108
  fprintf(stdout, " * Size of precinct : 2^15 x 2^15 (means 1 precinct)\nU");
#line 109
  fprintf(stdout, " * Size of code-block : 64 x 64\n\220");
#line 110
  fprintf(stdout, " * Number of resolutions: 6\n");
#line 111
  fprintf(stdout, " * No SOP marker in the codestream\n");
#line 112
  fprintf(stdout, " * No EPH marker in the codestream\n");
#line 113
  fprintf(stdout, " * No sub-sampling in x or y direction\n");
#line 114
  fprintf(stdout, " * No mode switch activated\n");
#line 115
  fprintf(stdout, " * Progression order: LRCP\n");
#line 116
  fprintf(stdout, " * No index file\n");
#line 117
  fprintf(stdout, " * No ROI upshifted\n");
#line 118
  fprintf(stdout, " * No offset of the origin of the image\n\220");
#line 119
  fprintf(stdout, " * No offset of the origin of the tiles\n\220");
#line 120
  fprintf(stdout, " * Reversible DWT 5-3\n");
#line 126
  fprintf(stdout, "\n");
#line 127
  fprintf(stdout, "Parameters:\n");
#line 128
  fprintf(stdout, "------------\n");
#line 129
  fprintf(stdout, "\n");
#line 130
  fprintf(stdout, "Required Parameters (except with -h):\n");
#line 131
  fprintf(stdout, "One of the two options -ImgDir or -i must be used\n");
#line 132
  fprintf(stdout, "\n");
#line 133
  fprintf(stdout, "-ImgDir      : Image file Directory path (example ../Images) \n");
#line 134
  fprintf(stdout, "    When using this option -OutFor must be used\n\220");
#line 135
  fprintf(stdout, "\n");
#line 136
  fprintf(stdout, "-OutFor \n");
#line 137
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 138
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 139
  fprintf(stdout, "    Currently accepts PBM, PGM, PPM, PNM, PAM, PGX, PNG, BMP, TIF, RAW and TGA formats\n");
#line 140
  fprintf(stdout, "\n");
#line 141
  fprintf(stdout, "-i           : source file  (-i source.pnm also *pbm, *.pgm, *.ppm, *.pam, *.pgx, *png, *.bmp, *.tif, *.raw, *.tga) \n");
#line 142
  fprintf(stdout, "    When using this option -o must be used\n");
#line 143
  fprintf(stdout, "\n");
#line 144
  fprintf(stdout, "-o           : destination file (-o dest.j2k or .jp2) \n");
#line 145
  fprintf(stdout, "\n");
#line 146
  fprintf(stdout, "Optional Parameters:\n");
#line 147
  fprintf(stdout, "\n");
#line 148
  fprintf(stdout, "-h           : display the help information \n ");
#line 149
  fprintf(stdout, "\n");
#line 150
  fprintf(stdout, "-cinema2K    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
#line 151
  fprintf(stdout, "\t  Need to specify the frames per second for a 2K resolution. Only 24 or 48 fps is allowed\n");
#line 152
  fprintf(stdout, "\n");
#line 153
  fprintf(stdout, "-cinema4K    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
#line 154
  fprintf(stdout, "\t  Frames per second not required. Default value is 24fps\n");
#line 155
  fprintf(stdout, "\n");
#line 156
  fprintf(stdout, "-r           : different compression ratios for successive layers (-r 20,10,5)\n \220");
#line 157
  fprintf(stdout, "\t         - The rate specified for each quality level is the desired \n");
#line 158
  fprintf(stdout, "\t           compression factor.\n\220");
#line 159
  fprintf(stdout, "\t\t   Example: -r 20,10,1 means quality 1: compress 20x, \n");
#line 160
  fprintf(stdout, "\t\t     quality 2: compress 10x and quality 3: compress lossless\n\220");
#line 161
  fprintf(stdout, "\n");
#line 162
  fprintf(stdout, "               (options -r and -q cannot be used together)\n \001");
#line 163
  fprintf(stdout, "\n");
#line 165
  fprintf(stdout, "-q           : different psnr for successive layers (-q 30,40,50) \n \245\f");
#line 167
  fprintf(stdout, "               (options -r and -q cannot be used together)\n ,");
#line 169
  fprintf(stdout, "\n");
#line 170
  fprintf(stdout, "-n           : number of resolutions (-n 3) \nE");
#line 171
  fprintf(stdout, "\n");
#line 172
  fprintf(stdout, "-b           : size of code block (-b 32,32) \n");
#line 173
  fprintf(stdout, "\n\235");
#line 174
  fprintf(stdout, "-c           : size of precinct (-c 128,128) \n");
#line 175
  fprintf(stdout, "\n\255");
#line 176
  fprintf(stdout, "-t           : size of tile (-t 512,512) \n");
#line 177
  fprintf(stdout, "\n\314");
#line 178
  fprintf(stdout, "-p           : progression order (-p LRCP) [LRCP, RLCP, RPCL, PCRL, CPRL] \n");
#line 179
  fprintf(stdout, "\n\333");
#line 180
  fprintf(stdout, "-s           : subsampling factor (-s 2,2) [-s X,Y] \n\375");
#line 181
  fprintf(stdout, "\t     Remark: subsampling bigger than 2 can produce error\n\001");
#line 182
  fprintf(stdout, "\n");
#line 183
  fprintf(stdout, "-POC         : Progression order change (-POC T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL) \n\261");
#line 184
  fprintf(stdout, "      Example: T1=0,0,1,5,3,CPRL \n");
#line 185
  fprintf(stdout, "\t\t\t : Ttilenumber=Resolution num start,Component num start,Layer num end,Resolution num end,Component num end,Progression order\n\220");
#line 186
  fprintf(stdout, "\n");
#line 187
  fprintf(stdout, "-SOP         : write SOP marker before each packet \n\222\001");
#line 188
  fprintf(stdout, "\n");
#line 189
  fprintf(stdout, "-EPH         : write EPH marker after each header packet \n");
#line 190
  fprintf(stdout, "\n");
#line 191
  fprintf(stdout, "-M           : mode switch (-M 3) [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
#line 192
  fprintf(stdout, "                 8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)] \n");
#line 193
  fprintf(stdout, "                 Indicate multiple modes by adding their values. \n");
#line 194
  fprintf(stdout, "                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
#line 195
  fprintf(stdout, "\n");
#line 196
  fprintf(stdout, "-TP          : devide packets of every tile into tile-parts (-TP R) [R, L, C]\n");
#line 197
  fprintf(stdout, "\n");
#line 198
  fprintf(stdout, "-x           : create an index file *.Idx (-x index_name.Idx) \n");
#line 199
  fprintf(stdout, "\n");
#line 200
  fprintf(stdout, "-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
#line 201
  fprintf(stdout, "               for component c=%%d [%%d = 0,1,2]\n");
#line 202
  fprintf(stdout, "               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
#line 203
  fprintf(stdout, "\n");
#line 204
  fprintf(stdout, "-d           : offset of the origin of the image (-d 150,300) \n");
#line 205
  fprintf(stdout, "\n");
#line 206
  fprintf(stdout, "-T           : offset of the origin of the tiles (-T 100,75) \n");
#line 207
  fprintf(stdout, "\n");
#line 208
  fprintf(stdout, "-I           : use the irreversible DWT 9-7 (-I) \n");
#line 209
  fprintf(stdout, "\n");
#line 210
  fprintf(stdout, "-F           : characteristics of the raw input image\n");
#line 211
  fprintf(stdout, "               -F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
#line 212
  fprintf(stdout, "               Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 213
  fprintf(stdout, "\n");
#line 214
  fprintf(stdout, "-jpip        : write jpip codestream index box in JP2 output file\n");
#line 215
  fprintf(stdout, "               NOTICE: currently supports only RPCL order\n");
#line 216
  fprintf(stdout, "\n");
#line 284
  fprintf(stdout, "IMPORTANT:\n");
#line 285
  fprintf(stdout, "-----------\n");
#line 286
  fprintf(stdout, "\n");
#line 287
  fprintf(stdout, "The index file has the structure below:\n\220");
#line 288
  fprintf(stdout, "---------------------------------------\n\220");
#line 289
  fprintf(stdout, "\n");
#line 290
  fprintf(stdout, "Image_height Image_width\n");
#line 291
  fprintf(stdout, "progression order\n");
#line 292
  fprintf(stdout, "Tiles_size_X Tiles_size_Y\n");
#line 293
  fprintf(stdout, "Tiles_nb_X Tiles_nb_Y\n");
#line 294
  fprintf(stdout, "Components_nb\n");
#line 295
  fprintf(stdout, "Layers_nb\n");
#line 296
  fprintf(stdout, "decomposition_levels\n");
#line 297
  fprintf(stdout, "[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
#line 298
  fprintf(stdout, "   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
#line 299
  fprintf(stdout, "Main_header_start_position\n");
#line 300
  fprintf(stdout, "Main_header_end_position\n");
#line 301
  fprintf(stdout, "Codestream_size\n\220");
#line 302
  fprintf(stdout, "\n");
#line 303
  fprintf(stdout, "INFO ON TILES\n");
#line 304
  fprintf(stdout, "tileno start_pos end_hd end_tile nbparts disto nbpix disto/nbpix\n");
#line 305
  fprintf(stdout, "Tile_0 start_pos end_Theader end_pos NumParts TotalDisto NumPix MaxMSE\n");
#line 306
  fprintf(stdout, "Tile_1   \'\'           \'\'        \'\'        \'\'       \'\'    \'\'      \'\'\n");
#line 307
  fprintf(stdout, "...\n");
#line 308
  fprintf(stdout, "Tile_Nt   \'\'           \'\'        \'\'        \'\'       \'\'    \'\'     \'\'\n");
#line 309
  fprintf(stdout, "...\n");
#line 310
  fprintf(stdout, "TILE 0 DETAILS\n");
#line 311
  fprintf(stdout, "part_nb tileno num_packs start_pos end_tph_pos end_pos\n");
#line 312
  fprintf(stdout, "...\n");
#line 313
  fprintf(stdout, "Progression_string\n");
#line 314
  fprintf(stdout, "pack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
#line 315
  fprintf(stdout, "Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
#line 316
  fprintf(stdout, "...\n");
#line 317
  fprintf(stdout, "Tpacket_Np \'\'   \'\'    \'\'   \'\'    \'\'       \'\'       \'\'     \'\'\n");
#line 319
  fprintf(stdout, "MaxDisto\n");
#line 321
  fprintf(stdout, "TotalDisto\n\n");
  }
  return;
}
}
#line 324 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
OPJ_PROG_ORDER give_progression(char progression[4] ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 325
  __cil_tmp2 = strncmp((char const   *)progression, "LRCP", (unsigned long )4);
  }
#line 325
  if (__cil_tmp2 == 0) {
#line 326
    return ((OPJ_PROG_ORDER )0);
  }
  {
#line 328
  __cil_tmp3 = strncmp((char const   *)progression, "RLCP", (unsigned long )4);
  }
#line 328
  if (__cil_tmp3 == 0) {
#line 329
    return ((OPJ_PROG_ORDER )1);
  }
  {
#line 331
  __cil_tmp4 = strncmp((char const   *)progression, "RPCL", (unsigned long )4);
  }
#line 331
  if (__cil_tmp4 == 0) {
#line 332
    return ((OPJ_PROG_ORDER )2);
  }
  {
#line 334
  __cil_tmp5 = strncmp((char const   *)progression, "PCRL", (unsigned long )4);
  }
#line 334
  if (__cil_tmp5 == 0) {
#line 335
    return ((OPJ_PROG_ORDER )3);
  }
  {
#line 337
  __cil_tmp6 = strncmp((char const   *)progression, "CPRL", (unsigned long )4);
  }
#line 337
  if (__cil_tmp6 == 0) {
#line 338
    return ((OPJ_PROG_ORDER )4);
  }
#line 341
  return ((OPJ_PROG_ORDER )-1);
}
}
#line 411 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
char *get_file_name(char *name ) 
{ 
  char *fname ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 413
  __cil_tmp3 = malloc(4096UL * sizeof(char ));
#line 413
  fname = (char *)__cil_tmp3;
#line 414
  fname = strtok(name, ".{W\016`U");
  }
#line 415
  return (fname);
}
}
#line 443 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
static int initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 444
  (POC + 0)->tile = 1;
#line 445
  (POC + 0)->resno0 = 0;
#line 446
  (POC + 0)->compno0 = 0;
#line 447
  (POC + 0)->layno1 = 1;
#line 448
  (POC + 0)->resno1 = numres - 1;
#line 449
  (POC + 0)->compno1 = 3;
#line 450
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 451
  (POC + 1)->tile = 1;
#line 452
  (POC + 1)->resno0 = numres - 1;
#line 453
  (POC + 1)->compno0 = 0;
#line 454
  (POC + 1)->layno1 = 1;
#line 455
  (POC + 1)->resno1 = numres;
#line 456
  (POC + 1)->compno1 = 3;
#line 457
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 458
  return (2);
}
}
#line 461 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
void cinema_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 462
  parameters->tile_size_on = 0;
#line 463
  parameters->cp_tdx = 1;
#line 464
  parameters->cp_tdy = 1;
#line 467
  parameters->tp_flag = (char )'C';
#line 468
  parameters->tp_on = (char )1;
#line 471
  parameters->cp_tx0 = 0;
#line 472
  parameters->cp_ty0 = 0;
#line 473
  parameters->image_offset_x0 = 0;
#line 474
  parameters->image_offset_y0 = 0;
#line 477
  parameters->cblockw_init = 32;
#line 478
  parameters->cblockh_init = 32;
#line 479
  parameters->csty |= 1;
#line 482
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 485
  parameters->roi_compno = - 1;
#line 487
  parameters->subsampling_dx = 1;
#line 487
  parameters->subsampling_dy = 1;
#line 490
  parameters->irreversible = 1;
  return;
}
}
#line 494 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
void cinema_setup_encoder(opj_cparameters_t *parameters , opj_image_t *image , img_fol_t___0 *img_fol ) 
{ 
  int i ;
  float temp_rate ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 500
  if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 500
    goto case_2;
  }
#line 500
  if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 500
    goto case_2;
  }
#line 512
  if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 512
    goto case_3;
  }
#line 526
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 501
  if (parameters->numresolution > 6) {
#line 502
    parameters->numresolution = 6;
  }
#line 504
  if (! (((image->comps + 0)->w == 2048) | ((image->comps + 0)->h == 1080))) {
    {
#line 505
    fprintf(stdout, "Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 (2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
            (image->comps + 0)->w, (image->comps + 0)->h);
#line 508
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
    }
  }
#line 510
  goto switch_break;
  case_3: /* CIL Label */ 
#line 513
  if (parameters->numresolution < 1) {
#line 514
    parameters->numresolution = 1;
  } else
#line 515
  if (parameters->numresolution > 7) {
#line 516
    parameters->numresolution = 7;
  }
#line 518
  if (! (((image->comps + 0)->w == 4096) | ((image->comps + 0)->h == 2160))) {
    {
#line 519
    fprintf(stdout, "Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
            (image->comps + 0)->w, (image->comps + 0)->h);
#line 522
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
    }
  }
  {
#line 524
  parameters->numpocs = initialise_4K_poc((opj_poc_t *)parameters->POC, parameters->numresolution);
  }
#line 525
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 527
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 532
  if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 532
    goto case_3___0;
  }
#line 532
  if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 532
    goto case_3___0;
  }
#line 552
  if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 552
    goto case_2___0;
  }
#line 571
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 533
  i = 0;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < parameters->tcp_numlayers)) {
#line 533
      goto while_break;
    }
#line 534
    temp_rate = (float )0;
#line 535
    if (*(img_fol->rates + i) == (float )0) {
#line 536
      parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((10416664 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
    } else {
#line 539
      temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((*(img_fol->rates + i) * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 541
      if (temp_rate > (float )1302083) {
#line 542
        parameters->tcp_rates[i] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((10416664 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
      } else {
#line 545
        parameters->tcp_rates[i] = *(img_fol->rates + i);
      }
    }
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  parameters->max_comp_size = 1041666;
#line 550
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 553
  i = 0;
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 553
    if (! (i < parameters->tcp_numlayers)) {
#line 553
      goto while_break___0;
    }
#line 554
    temp_rate = (float )0;
#line 555
    if (*(img_fol->rates + i) == (float )0) {
#line 556
      parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((5208328 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
    } else {
#line 559
      temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((*(img_fol->rates + i) * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 561
      if (temp_rate > (float )651041) {
#line 562
        parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((5208328 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
      } else {
#line 565
        parameters->tcp_rates[i] = *(img_fol->rates + i);
      }
    }
#line 553
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 569
  parameters->max_comp_size = 520833;
#line 570
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 572
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 574
  parameters->cp_disto_alloc = 1;
  return;
}
}
#line 579 "/doner/openjpeg/openjpeg-c02f145/applications/codec/image_to_j2k.c"
int parse_cmdline_encoder(int argc , char **argv , opj_cparameters_t *parameters ,
                          img_fol_t___0 *img_fol , raw_cparameters_t *raw_cp , char *indexfilename ) 
{ 
  int i ;
  int j ;
  int totlen ;
  int c ;
  opj_option_t long_option[10] ;
  char const   optlist[46] ;
  int __cil_tmp13 ;
  char *infile ;
  int __cil_tmp15 ;
  char *outfile ;
  int __cil_tmp17 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp20 ;
  char *s ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char signo ;
  char *s___0 ;
  int __cil_tmp28 ;
  char *s___1 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  int *row ;
  int *col ;
  int numlayers ;
  int numresolution ;
  int matrix_width ;
  char *s___2 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  int __cil_tmp47 ;
  char *__cil_tmp48 ;
  int __cil_tmp49 ;
  char sep ;
  int res_spec ;
  char *s___3 ;
  int __cil_tmp53 ;
  char *__cil_tmp54 ;
  int cblockw_init ;
  int cblockh_init ;
  char *index___60 ;
  char progression[4] ;
  OPJ_PROG_ORDER __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int numpocs ;
  opj_poc_t *POC ;
  char *s___4 ;
  int __cil_tmp65 ;
  OPJ_PROG_ORDER __cil_tmp66 ;
  int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  int value ;
  int __cil_tmp71 ;
  int cache ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  void *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  void *__cil_tmp79 ;
  int fps ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;

  {
#line 582
  long_option[0].name = "cinema2K\251";
#line 582
  long_option[0].has_arg = 1;
#line 582
  long_option[0].flag = (int *)((void *)0);
#line 582
  long_option[0].val = 'w';
#line 582
  long_option[1].name = "cinema4K\251";
#line 582
  long_option[1].has_arg = 0;
#line 582
  long_option[1].flag = (int *)((void *)0);
#line 582
  long_option[1].val = 'y';
#line 582
  long_option[2].name = "ImgDir";
#line 582
  long_option[2].has_arg = 1;
#line 582
  long_option[2].flag = (int *)((void *)0);
#line 582
  long_option[2].val = 'z';
#line 582
  long_option[3].name = "TP";
#line 582
  long_option[3].has_arg = 1;
#line 582
  long_option[3].flag = (int *)((void *)0);
#line 582
  long_option[3].val = 'u';
#line 582
  long_option[4].name = "SOP";
#line 582
  long_option[4].has_arg = 0;
#line 582
  long_option[4].flag = (int *)((void *)0);
#line 582
  long_option[4].val = 'S';
#line 582
  long_option[5].name = "EPH";
#line 582
  long_option[5].has_arg = 0;
#line 582
  long_option[5].flag = (int *)((void *)0);
#line 582
  long_option[5].val = 'E';
#line 582
  long_option[6].name = "OutFor";
#line 582
  long_option[6].has_arg = 1;
#line 582
  long_option[6].flag = (int *)((void *)0);
#line 582
  long_option[6].val = 'O';
#line 582
  long_option[7].name = "POC";
#line 582
  long_option[7].has_arg = 1;
#line 582
  long_option[7].flag = (int *)((void *)0);
#line 582
  long_option[7].val = 'P';
#line 582
  long_option[8].name = "ROI";
#line 582
  long_option[8].has_arg = 1;
#line 582
  long_option[8].flag = (int *)((void *)0);
#line 582
  long_option[8].val = 'R';
#line 582
  long_option[9].name = "jpip";
#line 582
  long_option[9].has_arg = 0;
#line 582
  long_option[9].flag = (int *)((void *)0);
#line 582
  long_option[9].val = 'J';
#line 596
  optlist = "i:o:r:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:F:u:Jh";
#line 602
  totlen = (int )sizeof(long_option);
#line 603
  img_fol->set_out_format = (char )0;
#line 604
  raw_cp->rawWidth = 0;
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 607
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 608
    if (c == -1) {
#line 609
      goto while_break;
    }
    {
#line 611
    if (c == 'i') {
#line 611
      goto case_105;
    }
#line 622
    if (c == 17) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 16) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 15) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 14) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 12) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 10) {
#line 622
      goto case_17;
    }
#line 622
    if (c == 11) {
#line 622
      goto case_17;
    }
#line 637
    if (c == 'o') {
#line 637
      goto case_111;
    }
#line 643
    if (c == 1) {
#line 643
      goto case_1;
    }
#line 643
    if (c == 0) {
#line 643
      goto case_1;
    }
#line 654
    if (c == 'O') {
#line 654
      goto case_79;
    }
#line 663
    if (c == 1) {
#line 663
      goto case_1___0;
    }
#line 663
    if (c == 0) {
#line 663
      goto case_1___0;
    }
#line 677
    if (c == 'r') {
#line 677
      goto case_114;
    }
#line 697
    if (c == 'F') {
#line 697
      goto case_70;
    }
#line 731
    if (c == 'q') {
#line 731
      goto case_113;
    }
#line 750
    if (c == 'f') {
#line 750
      goto case_102;
    }
#line 797
    if (c == 't') {
#line 797
      goto case_116;
    }
#line 806
    if (c == 'n') {
#line 806
      goto case_110;
    }
#line 813
    if (c == 'c') {
#line 813
      goto case_99;
    }
#line 834
    if (c == 'b') {
#line 834
      goto case_98;
    }
#line 852
    if (c == 'x') {
#line 852
      goto case_120;
    }
#line 861
    if (c == 'p') {
#line 861
      goto case_112;
    }
#line 877
    if (c == 's') {
#line 877
      goto case_115;
    }
#line 889
    if (c == 'd') {
#line 889
      goto case_100;
    }
#line 902
    if (c == 'h') {
#line 902
      goto case_104;
    }
#line 908
    if (c == 'P') {
#line 908
      goto case_80;
    }
#line 936
    if (c == 'S') {
#line 936
      goto case_83;
    }
#line 944
    if (c == 'E') {
#line 944
      goto case_69;
    }
#line 952
    if (c == 'M') {
#line 952
      goto case_77;
    }
#line 967
    if (c == 'R') {
#line 967
      goto case_82;
    }
#line 979
    if (c == 'T') {
#line 979
      goto case_84;
    }
#line 990
    if (c == 'C') {
#line 990
      goto case_67;
    }
#line 1002
    if (c == 'I') {
#line 1002
      goto case_73;
    }
#line 1010
    if (c == 'u') {
#line 1010
      goto case_117;
    }
#line 1019
    if (c == 'z') {
#line 1019
      goto case_122;
    }
#line 1029
    if (c == 'w') {
#line 1029
      goto case_119;
    }
#line 1049
    if (c == 'y') {
#line 1049
      goto case_121;
    }
#line 1380
    if (c == 'J') {
#line 1380
      goto case_74;
    }
#line 1388
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 613
    infile = opj_optarg;
#line 614
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 622
    if (parameters->decod_format == 17) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 16) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 15) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 14) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 12) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 10) {
#line 622
      goto case_17;
    }
#line 622
    if (parameters->decod_format == 11) {
#line 622
      goto case_17;
    }
#line 624
    goto switch_default;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 623
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 625
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.pnm, *.pgm, *.ppm, *.pgx, *png, *.bmp, *.tif, *.raw or *.tga] !!\n\n",
            infile);
    }
#line 629
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 631
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 633
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 639
    outfile = opj_optarg;
#line 640
    parameters->cod_format = get_file_format(outfile);
    }
    {
#line 643
    if (parameters->cod_format == 1) {
#line 643
      goto case_1;
    }
#line 643
    if (parameters->cod_format == 0) {
#line 643
      goto case_1;
    }
#line 645
    goto switch_default___0;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 644
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 646
    fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n",
            outfile);
    }
#line 647
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 649
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 651
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 657
    of = opj_optarg;
#line 658
    sprintf((char *)outformat, ".%s", of);
#line 659
    img_fol->set_out_format = (char )1;
#line 660
    parameters->cod_format = get_file_format((char *)outformat);
    }
    {
#line 663
    if (parameters->cod_format == 1) {
#line 663
      goto case_1___0;
    }
#line 663
    if (parameters->cod_format == 0) {
#line 663
      goto case_1___0;
    }
#line 666
    goto switch_default___1;
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 664
    img_fol->out_format = opj_optarg;
#line 665
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 667
    fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
    }
#line 668
    return (1);
    switch_break___2: /* CIL Label */ ;
    }
#line 671
    goto switch_break;
    case_114: /* CIL Label */ 
#line 679
    s = opj_optarg;
#line 680
    parameters->tcp_numlayers = 0;
    {
#line 681
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 681
      __cil_tmp22 = sscanf((char const   *)s, "%f", & parameters->tcp_rates[parameters->tcp_numlayers]);
      }
#line 681
      if (! (__cil_tmp22 == 1)) {
#line 681
        goto while_break___0;
      }
#line 682
      (parameters->tcp_numlayers) ++;
      {
#line 683
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 683
        if (! ((int )*s && (int )*s != 44)) {
#line 683
          goto while_break___1;
        }
#line 684
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 686
      if (! *s) {
#line 687
        goto while_break___0;
      }
#line 688
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 690
    parameters->cp_disto_alloc = 1;
#line 692
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 700
    s___0 = opj_optarg;
#line 701
    __cil_tmp28 = sscanf((char const   *)s___0, "%d,%d,%d,%d,%c", & raw_cp->rawWidth,
                         & raw_cp->rawHeight, & raw_cp->rawComp, & raw_cp->rawBitDepth,
                         & signo);
    }
#line 701
    if (__cil_tmp28 == 5) {
#line 702
      if ((int )signo == 115) {
        {
#line 703
        raw_cp->rawSigned = 1;
#line 704
        fprintf(stdout, "\nRaw file parameters: %d,%d,%d,%d Signed\n", raw_cp->rawWidth,
                raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
        }
      } else
#line 706
      if ((int )signo == 117) {
        {
#line 707
        raw_cp->rawSigned = 0;
#line 708
        fprintf(stdout, "\nRaw file parameters: %d,%d,%d,%d Unsigned\n", raw_cp->rawWidth,
                raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
        }
      } else {
        {
#line 711
        fprintf(stderr, "\nError: invalid raw image parameters: Unknown sign of raw file\n");
#line 712
        fprintf(stderr, "Please use the Format option -F:\n");
#line 713
        fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 714
        fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 715
        fprintf(stderr, "Aborting\n");
        }
      }
    } else {
      {
#line 719
      fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 720
      fprintf(stderr, "Please use the Format option -F:\n");
#line 721
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 722
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 723
      fprintf(stderr, "Aborting\n");
      }
#line 724
      return (1);
    }
#line 727
    goto switch_break;
    case_113: /* CIL Label */ 
#line 733
    s___1 = opj_optarg;
    {
#line 734
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 734
      __cil_tmp30 = sscanf((char const   *)s___1, "%f", & parameters->tcp_distoratio[parameters->tcp_numlayers]);
      }
#line 734
      if (! (__cil_tmp30 == 1)) {
#line 734
        goto while_break___2;
      }
#line 735
      (parameters->tcp_numlayers) ++;
      {
#line 736
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 736
        if (! ((int )*s___1 && (int )*s___1 != 44)) {
#line 736
          goto while_break___3;
        }
#line 737
        s___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 739
      if (! *s___1) {
#line 740
        goto while_break___2;
      }
#line 741
      s___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 743
    parameters->cp_fixed_quality = 1;
#line 745
    goto switch_break;
    case_102: /* CIL Label */ 
#line 752
    row = (int *)((void *)0);
#line 752
    col = (int *)((void *)0);
#line 753
    numlayers = 0;
#line 753
    numresolution = 0;
    {
#line 753
    matrix_width = 0;
#line 755
    s___2 = opj_optarg;
#line 756
    sscanf((char const   *)s___2, "%d", & numlayers);
#line 757
    s___2 ++;
    }
#line 758
    if (numlayers > 9) {
#line 759
      s___2 ++;
    }
    {
#line 761
    parameters->tcp_numlayers = numlayers;
#line 762
    numresolution = parameters->numresolution;
#line 763
    matrix_width = numresolution * 3;
#line 764
    __cil_tmp42 = malloc((unsigned long )(numlayers * matrix_width) * sizeof(int ));
#line 764
    parameters->cp_matrice = (int *)__cil_tmp42;
#line 765
    s___2 += 2;
#line 767
    i = 0;
    }
    {
#line 767
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 767
      if (! (i < numlayers)) {
#line 767
        goto while_break___4;
      }
      {
#line 768
      row = parameters->cp_matrice + i * matrix_width;
#line 769
      col = row;
#line 770
      parameters->tcp_rates[i] = (float )1;
#line 771
      sscanf((char const   *)s___2, "%d,", col + 0);
#line 772
      s___2 += 2;
      }
#line 773
      if (*(col + 0) > 9) {
#line 774
        s___2 ++;
      }
#line 775
      *(col + 1) = 0;
#line 776
      *(col + 2) = 0;
#line 777
      j = 1;
      {
#line 777
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 777
        if (! (j < numresolution)) {
#line 777
          goto while_break___5;
        }
        {
#line 778
        col += 3;
#line 779
        sscanf((char const   *)s___2, "%d,%d,%d\230\001", col + 0, col + 1, col + 2);
#line 780
        s___2 += 6;
        }
#line 781
        if (*(col + 0) > 9) {
#line 782
          s___2 ++;
        }
#line 783
        if (*(col + 1) > 9) {
#line 784
          s___2 ++;
        }
#line 785
        if (*(col + 2) > 9) {
#line 786
          s___2 ++;
        }
#line 777
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 788
      if (i < numlayers - 1) {
#line 789
        s___2 ++;
      }
#line 767
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 791
    parameters->cp_fixed_alloc = 1;
#line 793
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 799
    sscanf((char const   *)opj_optarg, "%d,%d", & parameters->cp_tdx, & parameters->cp_tdy);
#line 800
    parameters->tile_size_on = 1;
    }
#line 802
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 808
    sscanf((char const   *)opj_optarg, "%d", & parameters->numresolution);
    }
#line 810
    goto switch_break;
    case_99: /* CIL Label */ 
#line 816
    res_spec = 0;
#line 818
    s___3 = opj_optarg;
    {
#line 819
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 820
      sep = (char )0;
#line 821
      sscanf((char const   *)s___3, "[%d,%d]%c", & parameters->prcw_init[res_spec],
             & parameters->prch_init[res_spec], & sep);
#line 823
      parameters->csty |= 1;
#line 824
      res_spec ++;
#line 825
      __cil_tmp54 = strpbrk((char const   *)s___3, "]");
#line 825
      s___3 = __cil_tmp54 + 2;
      }
#line 819
      if (! ((int )sep == 44)) {
#line 819
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 828
    parameters->res_spec = res_spec;
#line 830
    goto switch_break;
    case_98: /* CIL Label */ 
#line 836
    cblockw_init = 0;
    {
#line 836
    cblockh_init = 0;
#line 837
    sscanf((char const   *)opj_optarg, "%d,%d", & cblockw_init, & cblockh_init);
    }
#line 838
    if (cblockw_init * cblockh_init > 4096) {
      {
      {
      {
      {
      {
#line 840
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 843
      return (1);
    } else
#line 838
    if (cblockw_init > 1024) {
      {
      {
      {
      {
      {
#line 840
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 843
      return (1);
    } else
#line 838
    if (cblockw_init < 4) {
      {
      {
      {
      {
      {
#line 840
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 843
      return (1);
    } else
#line 838
    if (cblockh_init > 1024) {
      {
      {
      {
      {
      {
#line 840
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 843
      return (1);
    } else
#line 838
    if (cblockh_init < 4) {
      {
      {
      {
      {
      {
#line 840
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 843
      return (1);
    }
#line 845
    parameters->cblockw_init = cblockw_init;
#line 846
    parameters->cblockh_init = cblockh_init;
#line 848
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 854
    index___60 = opj_optarg;
#line 855
    strncpy(indexfilename, (char const   *)index___60, (unsigned long )4096);
    }
#line 857
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 865
    strncpy((char *)progression, (char const   *)opj_optarg, (unsigned long )4);
#line 866
    parameters->prog_order = give_progression((char *)progression);
    }
#line 867
    if ((int )parameters->prog_order == -1) {
      {
#line 868
      fprintf(stderr, "Unrecognized progression order [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
      }
#line 870
      return (1);
    }
#line 873
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 879
    __cil_tmp60 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->subsampling_dx,
                         & parameters->subsampling_dy);
    }
#line 879
    if (__cil_tmp60 != 2) {
      {
#line 881
      fprintf(stderr, "\'-s\' sub-sampling argument error !  [-s dx,dy]\n");
      }
#line 882
      return (1);
    }
#line 885
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 891
    __cil_tmp61 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->image_offset_x0,
                         & parameters->image_offset_y0);
    }
#line 891
    if (__cil_tmp61 != 2) {
      {
#line 893
      fprintf(stderr, "-d \'coordonnate of the reference grid\' argument error !! [-d x0,y0]\n\220");
      }
#line 895
      return (1);
    }
#line 898
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 903
    encode_help_display();
    }
#line 904
    return (1);
    case_80: /* CIL Label */ 
#line 910
    numpocs = 0;
#line 911
    POC = (opj_poc_t *)((void *)0);
#line 913
    s___4 = opj_optarg;
#line 914
    POC = (opj_poc_t *)parameters->POC;
    {
#line 916
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 916
      __cil_tmp65 = sscanf((char const   *)s___4, "T%d=%d,%d,%d,%d,%d,%4s", & (POC + numpocs)->tile,
                           & (POC + numpocs)->resno0, & (POC + numpocs)->compno0,
                           & (POC + numpocs)->layno1, & (POC + numpocs)->resno1, & (POC + numpocs)->compno1,
                           (char *)(POC + numpocs)->progorder);
      }
#line 916
      if (! (__cil_tmp65 == 7)) {
#line 916
        goto while_break___7;
      }
      {
#line 920
      (POC + numpocs)->prg1 = give_progression((char *)(POC + numpocs)->progorder);
#line 921
      numpocs ++;
      }
      {
#line 922
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 922
        if (! ((int )*s___4 && (int )*s___4 != 47)) {
#line 922
          goto while_break___8;
        }
#line 923
        s___4 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 925
      if (! *s___4) {
#line 926
        goto while_break___7;
      }
#line 928
      s___4 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 930
    parameters->numpocs = numpocs;
#line 932
    goto switch_break;
    case_83: /* CIL Label */ 
#line 938
    parameters->csty |= 2;
#line 940
    goto switch_break;
    case_69: /* CIL Label */ 
#line 946
    parameters->csty |= 4;
#line 948
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 954
    value = 0;
#line 955
    __cil_tmp71 = sscanf((char const   *)opj_optarg, "%d", & value);
    }
#line 955
    if (__cil_tmp71 == 1) {
#line 956
      i = 0;
      {
#line 956
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 956
        if (! (i <= 5)) {
#line 956
          goto while_break___9;
        }
#line 957
        cache = value & (1 << i);
#line 958
        if (cache) {
#line 959
          parameters->mode |= 1 << i;
        }
#line 956
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 963
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 969
    __cil_tmp74 = sscanf((char const   *)opj_optarg, "c=%d,U=%d", & parameters->roi_compno,
                         & parameters->roi_shift);
    }
#line 969
    if (__cil_tmp74 != 2) {
      {
#line 971
      fprintf(stderr, "ROI error !! [-ROI c=\'compno\',U=\'shift\']\n");
      }
#line 972
      return (1);
    }
#line 975
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 981
    __cil_tmp75 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->cp_tx0,
                         & parameters->cp_ty0);
    }
#line 981
    if (__cil_tmp75 != 2) {
      {
#line 982
      fprintf(stderr, "-T \'tile offset\' argument error !! [-T X0,Y0]");
      }
#line 983
      return (1);
    }
#line 986
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 992
    __cil_tmp76 = strlen((char const   *)opj_optarg);
#line 992
    __cil_tmp77 = malloc(__cil_tmp76 + 1UL);
#line 992
    parameters->cp_comment = (char *)__cil_tmp77;
    }
#line 993
    if (parameters->cp_comment) {
      {
#line 994
      strcpy(parameters->cp_comment, (char const   *)opj_optarg);
      }
    }
#line 997
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1004
    parameters->irreversible = 1;
#line 1006
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1012
    parameters->tp_flag = *(opj_optarg + 0);
#line 1013
    parameters->tp_on = (char )1;
#line 1015
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 1021
    __cil_tmp78 = strlen((char const   *)opj_optarg);
#line 1021
    __cil_tmp79 = malloc(__cil_tmp78 + 1UL);
#line 1021
    img_fol->imgdirpath = (char *)__cil_tmp79;
#line 1022
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 1023
    img_fol->set_imgdir = (char )1;
    }
#line 1025
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 1031
    fps = 0;
#line 1032
    sscanf((char const   *)opj_optarg, "%d", & fps);
    }
#line 1033
    if (fps == 24) {
#line 1034
      parameters->cp_cinema = (OPJ_CINEMA_MODE )1;
    } else
#line 1035
    if (fps == 48) {
#line 1036
      parameters->cp_cinema = (OPJ_CINEMA_MODE )2;
    } else {
      {
#line 1038
      fprintf(stderr, "Incorrect value!! must be 24 or 48\n");
      }
#line 1039
      return (1);
    }
    {
#line 1041
    fprintf(stdout, "CINEMA 2K compliant codestream\n");
#line 1042
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )3;
    }
#line 1045
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 1051
    parameters->cp_cinema = (OPJ_CINEMA_MODE )3;
#line 1052
    fprintf(stdout, "CINEMA 4K compliant codestream\n");
#line 1053
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )4;
    }
#line 1055
    goto switch_break;
    case_74: /* CIL Label */ 
#line 1382
    parameters->jpip_on = 1;
#line 1384
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 1389
    fprintf(stderr, "ERROR -> Command line not valid\n\220");
    }
#line 1390
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 606
    if (! (c != -1)) {
#line 606
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1395
  if (parameters->cp_cinema) {
#line 1396
    if (parameters->tcp_numlayers > 1) {
      {
#line 1397
      parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 1398
      fprintf(stdout, "Warning: DC profiles do not allow more than one quality layer. The codestream created will not be compliant with the DC profile\n\220");
      }
    }
  }
#line 1401
  if ((int )img_fol->set_imgdir == 1) {
#line 1402
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 1403
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 1404
      return (1);
    }
#line 1406
    if ((int )img_fol->set_out_format == 0) {
      {
#line 1407
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 1408
      fprintf(stderr, "Only one format allowed! Valid formats are j2k and jp2!!\n");
      }
#line 1409
      return (1);
    }
#line 1411
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 1412
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
#line 1413
      fprintf(stderr, "Specify OutputFormat using -OutFor<FORMAT> !!\n");
      }
#line 1414
      return (1);
    }
  } else
#line 1417
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 1418
    fprintf(stderr, "Example: %s -i image.ppm  -o image.j2k\n", *(argv + 0));
    }
    {
#line 1419
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 1420
    return (1);
  } else
#line 1417
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 1418
    fprintf(stderr, "Example: %s -i image.ppm  -o image.j2k\n", *(argv + 0));
    }
    {
#line 1419
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 1420
    return (1);
  }
#line 1424
  if (parameters->decod_format == 15) {
#line 1424
    if (raw_cp->rawWidth == 0) {
      {
#line 1425
      fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 1426
      fprintf(stderr, "Please use the Format option -F:\n");
#line 1427
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 1428
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 1429
      fprintf(stderr, "Aborting\n");
      }
#line 1430
      return (1);
    }
  }
#line 1433
  if (parameters->cp_disto_alloc) {
    _L: /* CIL Label */ 
    _L___61: /* CIL Label */ 
#line 1433
    if (! ((parameters->cp_disto_alloc ^ parameters->cp_fixed_alloc) ^ parameters->cp_fixed_quality)) {
      {
#line 1435
      fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
      }
#line 1436
      return (1);
    }
  } else
#line 1433
  if (parameters->cp_fixed_alloc) {
#line 1433
    goto _L;
  } else
#line 1433
  if (parameters->cp_fixed_quality) {
#line 1433
    goto _L;
  }
#line 1440
  if (parameters->tcp_numlayers == 0) {
#line 1441
    parameters->tcp_rates[0] = (float )0;
#line 1442
    (parameters->tcp_numlayers) ++;
#line 1443
    parameters->cp_disto_alloc = 1;
  }
#line 1446
  if (parameters->cp_tx0 > parameters->image_offset_x0) {
    {
    {
#line 1447
    fprintf(stderr, "Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters->cp_tx0, parameters->image_offset_x0, parameters->cp_ty0, parameters->image_offset_y0);
    }
    }
#line 1450
    return (1);
  } else
#line 1446
  if (parameters->cp_ty0 > parameters->image_offset_y0) {
    {
    {
#line 1447
    fprintf(stderr, "Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters->cp_tx0, parameters->image_offset_x0, parameters->cp_ty0, parameters->image_offset_y0);
    }
    }
#line 1450
    return (1);
  }
#line 1453
  i = 0;
  {
#line 1453
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1453
    if (! (i < parameters->numpocs)) {
#line 1453
      goto while_break___10;
    }
#line 1454
    if ((int )parameters->POC[i].prg == -1) {
      {
#line 1455
      fprintf(stderr, "Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",
              i + 1);
      }
    }
#line 1453
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1461
  return (0);
}
}
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int int_floorlog2___0(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short get_ushort___0(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_readheader___0(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                              unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 124
    return (0);
  }
  {
#line 126
  id_len = (unsigned char )*(tga + 0);
#line 127
  cmap_type = (unsigned char )*(tga + 1);
#line 128
  image_type = (unsigned char )*(tga + 2);
#line 129
  cmap_index = get_ushort___0(*((unsigned short *)(tga + 3)));
#line 130
  cmap_len = get_ushort___0(*((unsigned short *)(tga + 5)));
#line 131
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 134
  x_origin = get_ushort___0(*((unsigned short *)(tga + 8)));
#line 135
  y_origin = get_ushort___0(*((unsigned short *)(tga + 10)));
#line 136
  image_w = get_ushort___0(*((unsigned short *)(tga + 12)));
#line 137
  image_h = get_ushort___0(*((unsigned short *)(tga + 14)));
#line 138
  pixel_depth = (unsigned char )*(tga + 16);
#line 139
  image_desc = (unsigned char )*(tga + 17);
#line 141
  free(tga);
#line 143
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 144
  *width = (unsigned int )image_w;
#line 145
  *height = (unsigned int )image_h;
  }
#line 148
  if (id_len) {
    {
#line 150
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 150
    id = (unsigned char *)__cil_tmp29;
#line 151
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 151
    if (! __cil_tmp30) {
      {
#line 153
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 154
      free(id);
      }
#line 155
      return (0);
    }
    {
#line 157
    free(id);
    }
  }
#line 163
  if ((int )image_type > 8) {
    {
#line 165
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 166
    return (0);
  }
#line 169
  *flip_image = ! ((int )image_desc & 32);
#line 172
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 174
  if (palette_size > 0) {
    {
#line 176
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 177
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 179
  return (1);
}
}
#line 192 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_writeheader___0(FILE *fp , int bits_per_pixel , int width , int height ,
                               opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 199
  if (! bits_per_pixel) {
#line 200
    return (0);
  } else
#line 199
  if (! width) {
#line 200
    return (0);
  } else
#line 199
  if (! height) {
#line 200
    return (0);
  }
#line 202
  pixel_depth = (unsigned char )0;
#line 204
  if (bits_per_pixel < 256) {
#line 205
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 207
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerU");
    }
#line 208
    return (0);
  }
  {
#line 210
  uc0 = (unsigned char )0;
#line 212
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 212
  if (__cil_tmp13 != 1UL) {
#line 212
    goto fails;
  }
  {
#line 213
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 213
  if (__cil_tmp14 != 1UL) {
#line 213
    goto fails;
  }
  {
#line 215
  image_type = (unsigned char )2;
#line 216
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 216
  if (__cil_tmp15 != 1UL) {
#line 216
    goto fails;
  }
  {
#line 218
  us0 = (unsigned short )0;
#line 219
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 219
  if (__cil_tmp16 != 1UL) {
#line 219
    goto fails;
  }
  {
#line 220
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 220
  if (__cil_tmp17 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp18 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 223
  if (__cil_tmp19 != 1UL) {
#line 223
    goto fails;
  }
  {
#line 224
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp20 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  image_w = (unsigned short )width;
#line 227
  image_h = (unsigned short )height;
#line 230
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 230
  if (__cil_tmp21 != 1UL) {
#line 230
    goto fails;
  }
  {
#line 231
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 231
  if (__cil_tmp22 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 239
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 239
  if (__cil_tmp23 != 1UL) {
#line 239
    goto fails;
  }
#line 241
  image_desc = (unsigned char )8;
#line 243
  if (flip_image) {
#line 244
    image_desc |= 32;
  }
  {
#line 245
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 245
  if (__cil_tmp24 != 1UL) {
#line 245
    goto fails;
  }
#line 247
  return (1);
  fails: 
  {
#line 250
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 251
  return (0);
}
}
#line 1205 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned char readuchar___0(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1208
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1208
  if (! __cil_tmp3) {
    {
#line 1210
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1211
    return ((unsigned char )0);
  }
#line 1213
  return (c1);
}
}
#line 1216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short readushort___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1219
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1219
  if (! __cil_tmp5) {
    {
#line 1221
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1222
    return ((unsigned short )0);
  }
  {
#line 1224
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1224
  if (! __cil_tmp6) {
    {
#line 1226
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1227
    return ((unsigned short )0);
  }
#line 1229
  if (bigendian) {
#line 1230
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1232
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1235 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned int readuint___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1238
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1238
  if (! __cil_tmp7) {
    {
#line 1240
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1241
    return ((unsigned int )0);
  }
  {
#line 1243
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1243
  if (! __cil_tmp8) {
    {
#line 1245
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1246
    return ((unsigned int )0);
  }
  {
#line 1248
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1248
  if (! __cil_tmp9) {
    {
#line 1250
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1251
    return ((unsigned int )0);
  }
  {
#line 1253
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp10) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
#line 1258
  if (bigendian) {
#line 1259
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1261
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1479 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_white___0(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1481
    if (! *s) {
#line 1481
      goto while_break;
    }
#line 1483
    if ((int )*s == 10) {
#line 1483
      return ((char *)((void *)0));
    } else
#line 1483
    if ((int )*s == 13) {
#line 1483
      return ((char *)((void *)0));
    }
    {
#line 1484
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1484
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1484
      s ++;
#line 1484
      goto while_continue;
    }
#line 1485
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  return ((char *)((void *)0));
}
}
#line 1490 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_int___0(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1495
  *out_n = 0;
#line 1495
  s = start;
#line 1497
  s = skip_white___0(start);
  }
#line 1498
  if (s == (void *)0) {
#line 1498
    return ((char *)((void *)0));
  }
#line 1499
  start = s;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! *s) {
#line 1501
      goto while_break;
    }
    {
#line 1503
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1503
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1503
      goto while_break;
    }
#line 1504
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  c = *s;
#line 1506
  *s = (char )0;
#line 1506
  *out_n = atoi((char const   *)start);
#line 1506
  *s = c;
  }
#line 1507
  return (s);
}
}
#line 1510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_idf___0(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1515
  s = skip_white___0(start);
  }
#line 1516
  if (s == (void *)0) {
#line 1516
    return ((char *)((void *)0));
  }
#line 1517
  start = s;
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (! *s) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1521
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    } else
#line 1521
    if ((int )*s == 95) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    }
#line 1522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1524
  c = *s;
#line 1524
  *s = (char )0;
#line 1524
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1524
  *s = c;
  }
#line 1525
  return (s);
}
}
#line 1528 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static void read_pnm_header___0(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1535
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1535
  if (__cil_tmp11 == (void *)0) {
    {
#line 1537
    fprintf(stderr, "\nWARNING: fgets return a NULL value\016`U");
    }
#line 1538
    return;
  }
#line 1541
  if ((int )line[0] != 80) {
    {
#line 1543
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1543
    return;
  }
  {
#line 1545
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1546
  if (format < 1) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  } else
#line 1546
  if (format > 7) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  }
#line 1551
  ph->format = format;
#line 1552
  have_wh = 0;
#line 1552
  end = have_wh;
#line 1552
  ttype = end;
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1554
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1554
    if (! __cil_tmp13) {
#line 1554
      goto while_break;
    }
#line 1556
    if ((int )*((char *)line) == 35) {
#line 1556
      goto while_continue;
    }
#line 1558
    s = (char *)line;
#line 1560
    if (format == 7) {
      {
#line 1562
      s = skip_idf___0(s, (char *)idf);
      }
#line 1564
      if (s == (void *)0) {
#line 1564
        return;
      } else
#line 1564
      if ((int )*s == 0) {
#line 1564
        return;
      }
      {
#line 1566
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1566
      if (__cil_tmp15 == 0) {
#line 1568
        end = 1;
#line 1568
        goto while_break;
      }
      {
#line 1570
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHU");
      }
#line 1570
      if (__cil_tmp16 == 0) {
        {
#line 1572
        s = skip_int___0(s, & ph->width);
        }
#line 1573
        if (s == (void *)0) {
#line 1573
          return;
        } else
#line 1573
        if ((int )*s == 0) {
#line 1573
          return;
        }
#line 1575
        goto while_continue;
      }
      {
#line 1577
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1577
      if (__cil_tmp18 == 0) {
        {
#line 1579
        s = skip_int___0(s, & ph->height);
        }
#line 1580
        if (s == (void *)0) {
#line 1580
          return;
        } else
#line 1580
        if ((int )*s == 0) {
#line 1580
          return;
        }
#line 1582
        goto while_continue;
      }
      {
#line 1584
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTHU");
      }
#line 1584
      if (__cil_tmp20 == 0) {
        {
#line 1586
        s = skip_int___0(s, & ph->depth);
        }
#line 1587
        if (s == (void *)0) {
#line 1587
          return;
        } else
#line 1587
        if ((int )*s == 0) {
#line 1587
          return;
        }
#line 1589
        goto while_continue;
      }
      {
#line 1591
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1591
      if (__cil_tmp22 == 0) {
        {
#line 1593
        s = skip_int___0(s, & ph->maxval);
        }
#line 1594
        if (s == (void *)0) {
#line 1594
          return;
        } else
#line 1594
        if ((int )*s == 0) {
#line 1594
          return;
        }
#line 1596
        goto while_continue;
      }
      {
#line 1598
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1598
      if (__cil_tmp24 == 0) {
        {
#line 1600
        s = skip_idf___0(s, (char *)type);
        }
#line 1601
        if (s == (void *)0) {
#line 1601
          return;
        } else
#line 1601
        if ((int )*s == 0) {
#line 1601
          return;
        }
        {
#line 1603
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1603
        if (__cil_tmp26 == 0) {
#line 1605
          ph->bw = (char )1;
#line 1605
          ttype = 1;
#line 1605
          goto while_continue;
        }
        {
#line 1607
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE\223");
        }
#line 1607
        if (__cil_tmp27 == 0) {
#line 1609
          ph->gray = (char )1;
#line 1609
          ttype = 1;
#line 1609
          goto while_continue;
        }
        {
#line 1611
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1611
        if (__cil_tmp28 == 0) {
#line 1613
          ph->graya = (char )1;
#line 1613
          ttype = 1;
#line 1613
          goto while_continue;
        }
        {
#line 1615
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1615
        if (__cil_tmp29 == 0) {
#line 1617
          ph->rgb = (char )1;
#line 1617
          ttype = 1;
#line 1617
          goto while_continue;
        }
        {
#line 1619
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\001");
        }
#line 1619
        if (__cil_tmp30 == 0) {
#line 1621
          ph->rgba = (char )1;
#line 1621
          ttype = 1;
#line 1621
          goto while_continue;
        }
        {
#line 1623
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1624
        return;
      }
      {
#line 1626
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n\001", (char *)idf);
      }
#line 1627
      return;
    }
#line 1630
    if (! have_wh) {
      {
#line 1632
      s = skip_int___0(s, & ph->width);
#line 1634
      s = skip_int___0(s, & ph->height);
#line 1636
      have_wh = 1;
      }
#line 1638
      if (format == 1) {
#line 1638
        goto while_break;
      } else
#line 1638
      if (format == 4) {
#line 1638
        goto while_break;
      }
#line 1640
      goto while_continue;
    }
#line 1642
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___75: /* CIL Label */ 
      _L___76: /* CIL Label */ 
      {
#line 1645
      s = skip_int___0(s, & ph->maxval);
      }
#line 1647
      if (ph->maxval > 65535) {
#line 1647
        return;
      }
    } else
#line 1642
    if (format == 3) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 5) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 6) {
#line 1642
      goto _L;
    }
#line 1649
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1651
  if (format == 2) {
    _L___77: /* CIL Label */ 
    _L___78: /* CIL Label */ 
#line 1653
    if (ph->maxval < 1) {
#line 1653
      return;
    } else
#line 1653
    if (ph->maxval > 65535) {
#line 1653
      return;
    }
  } else
#line 1651
  if (format == 3) {
#line 1651
    goto _L___77;
  } else
#line 1651
  if (format > 4) {
#line 1651
    goto _L___77;
  }
#line 1655
  if (ph->width < 1) {
#line 1655
    return;
  } else
#line 1655
  if (ph->height < 1) {
#line 1655
    return;
  }
#line 1657
  if (format == 7) {
#line 1659
    if (! end) {
      {
#line 1661
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1661
      return;
    }
#line 1663
    if (ph->depth < 1) {
#line 1663
      return;
    } else
#line 1663
    if (ph->depth > 4) {
#line 1663
      return;
    }
#line 1665
    if (ph->width) {
#line 1665
      if (ph->height) {
#line 1665
        if (ph->depth & ph->maxval) {
#line 1665
          if (ttype) {
#line 1666
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1670
  if (format != 1) {
#line 1670
    if (format != 4) {
#line 1672
      if (ph->width) {
#line 1672
        if (ph->height) {
#line 1672
          if (ph->maxval) {
#line 1672
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1670
      goto _L___79;
    }
  } else {
    _L___79: /* CIL Label */ 
#line 1676
    if (ph->width) {
#line 1676
      if (ph->height) {
#line 1676
        ph->ok = (char )1;
      }
    }
#line 1677
    ph->maxval = 255;
  }
  return;
}
}
#line 1682 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int has_prec___0(int val ) 
{ 


  {
#line 1684
  if (val < 2) {
#line 1684
    return (1);
  }
#line 1685
  if (val < 4) {
#line 1685
    return (2);
  }
#line 1686
  if (val < 8) {
#line 1686
    return (3);
  }
#line 1687
  if (val < 16) {
#line 1687
    return (4);
  }
#line 1688
  if (val < 32) {
#line 1688
    return (5);
  }
#line 1689
  if (val < 64) {
#line 1689
    return (6);
  }
#line 1690
  if (val < 128) {
#line 1690
    return (7);
  }
#line 1691
  if (val < 256) {
#line 1691
    return (8);
  }
#line 1692
  if (val < 512) {
#line 1692
    return (9);
  }
#line 1693
  if (val < 1024) {
#line 1693
    return (10);
  }
#line 1694
  if (val < 2048) {
#line 1694
    return (11);
  }
#line 1695
  if (val < 4096) {
#line 1695
    return (12);
  }
#line 1696
  if (val < 8192) {
#line 1696
    return (13);
  }
#line 1697
  if (val < 16384) {
#line 1697
    return (14);
  }
#line 1698
  if (val < 32768) {
#line 1698
    return (15);
  }
#line 1699
  return (16);
}
}
