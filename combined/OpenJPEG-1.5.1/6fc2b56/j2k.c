/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__0 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__0 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_1 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_1 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_2 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_2 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 lldiv_t;
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_4 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_4 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__5 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 54 "/usr/include/time.h"
typedef __pid_t pid_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_7 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_6 {
   int __count ;
   union __anonunion_7 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_6 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__8 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 63 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 172 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 183 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 190 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 47 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 100 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 76 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 48 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
union __anonunion_9 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_9 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_15 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_15 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_16 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_16 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_18 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_17 {
   unsigned long long __wseq ;
   struct __anonstruct_18 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_20 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_19 {
   unsigned long long __g1_start ;
   struct __anonstruct_20 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_17  ;
   unsigned long long __wseq ;
   struct __anonstruct_18 __wseq32 ;
   union __anonunion_19  ;
   unsigned long long __g1_start ;
   struct __anonstruct_20 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_21 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_21 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_22 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_22 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_23 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_23 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_24 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_24 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_25 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_25 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_26 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_26 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_27 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_27 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_28 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_28 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__29 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__32 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_37 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_38 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_39 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_40 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_41 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_42 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_43 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_44 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_45 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_46 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_47 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_48 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_49 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_50 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_37  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_38  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_39  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_40  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_41  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_42  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_43  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_44  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_45  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_46  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_47  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_48  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_49  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_50  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__67 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__70 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__29___0 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__32___0 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 255 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 258 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1676 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1683 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 853 "/usr/include/math.h"
enum __anonenum__29___1 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__32___1 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 66
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 68
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 68
  if (__cil_tmp2) {
    {
#line 68
    __cil_tmp3 = __uflow(__fp);
#line 68
    tmp = __cil_tmp3;
    }
  } else {
#line 68
    (__fp->_IO_read_ptr) ++;
#line 68
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 68
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 101
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 103
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 103
  if (__cil_tmp3) {
    {
#line 103
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 103
    tmp = __cil_tmp4;
    }
  } else {
#line 103
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 103
    (__stream->_IO_write_ptr) ++;
#line 103
    *__cil_tmp5 = (char )__c;
#line 103
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 103
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 732 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/event.h"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) ;
#line 67 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 59 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 65
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 73
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) ;
#line 80
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 86
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 85 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 90
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 96
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 102
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 110
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 116
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 128
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 133
void mqc_flush(opj_mqc_t *mqc ) ;
#line 140
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 148
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 155
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 160
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 166
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 171
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 176
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 181
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 188
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 194
int mqc_decode(opj_mqc_t * const  mqc ) ;
#line 70 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 74 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 125
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 134
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 143
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 150
opj_bool pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 273
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) ;
#line 278
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 279
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 74 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 84
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 93
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 98
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (l);
}
}
#line 56 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 53 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cidx_manager.h"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) ;
#line 68 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/indexbox_manager.h"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) ;
#line 79
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 92
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 105
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 115
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) ;
#line 36 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 39
  fprintf(fd, "image {\n\220");
#line 40
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 43
  tileno = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (tileno < img->th * img->tw)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tile = (tcd->tcd_image)->tiles + tileno;
#line 45
    fprintf(fd, "  tile {\n");
#line 46
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 48
    compno = 0;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (! (compno < tile->numcomps)) {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tilec = tile->comps + compno;
#line 50
      fprintf(fd, "    tilec {\n");
#line 51
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 54
      resno = 0;
      }
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (resno < tilec->numresolutions)) {
#line 54
          goto while_break___1;
        }
        {
#line 55
        res = tilec->resolutions + resno;
#line 56
        fprintf(fd, "\n   res {\n");
#line 57
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 60
        bandno = 0;
        }
        {
#line 60
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 60
          if (! (bandno < res->numbands)) {
#line 60
            goto while_break___2;
          }
          {
#line 61
          band = & res->bands[bandno];
#line 62
          fprintf(fd, "        band {\n");
#line 63
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 66
          precno = 0;
          }
          {
#line 66
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 66
            if (! (precno < res->pw * res->ph)) {
#line 66
              goto while_break___3;
            }
            {
#line 67
            prec = band->precincts + precno;
#line 68
            fprintf(fd, "          prec {\n");
#line 69
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 82
            fprintf(fd, "          }\n");
            }
#line 66
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 84
          fprintf(fd, "        }\n");
          }
#line 60
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 86
        fprintf(fd, "      }\n\220");
        }
#line 54
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 88
      fprintf(fd, "    }\n");
      }
#line 48
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    fprintf(fd, "  }\n");
    }
#line 43
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 100 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 102
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 102
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 103
  if (! tcd) {
#line 103
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 104
  tcd->cinfo = cinfo;
#line 105
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 105
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 106
  if (! tcd->tcd_image) {
    {
#line 107
    free(tcd);
    }
#line 108
    return ((opj_tcd_t *)((void *)0));
  }
#line 111
  return (tcd);
}
}
#line 117 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 118
  if (tcd) {
    {
#line 119
    free(tcd->tcd_image);
#line 120
    free(tcd);
    }
  }
  return;
}
}
#line 126 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int __cil_tmp88 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;

  {
  {
#line 129
  tcd->image = image;
#line 130
  tcd->cp = cp;
#line 131
  (tcd->tcd_image)->tw = cp->tw;
#line 132
  (tcd->tcd_image)->th = cp->th;
#line 133
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 133
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 135
  tileno = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (tileno < 1)) {
#line 135
      goto while_break;
    }
    {
#line 136
    tcp = cp->tcps + curtileno;
#line 140
    p = curtileno % cp->tw;
#line 141
    q = curtileno / cp->tw;
#line 144
    tile = (tcd->tcd_image)->tiles;
#line 147
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 148
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 149
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 150
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 151
    tile->numcomps = image->numcomps;
#line 155
    j = 0;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! (j < tcp->numlayers)) {
#line 155
        goto while_break___0;
      }
#line 156
      if (tcp->rates[j]) {
#line 156
        if ((int )cp->tp_on) {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 156
        tmp___0 = tmp;
      } else {
#line 156
        tmp___0 = (float )0;
      }
#line 156
      tcp->rates[j] = tmp___0;
#line 171
      if (tcp->rates[j]) {
#line 172
        if (j) {
#line 172
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 173
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 172
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 175
        if (! j) {
#line 175
          if (tcp->rates[j] < (float )30) {
#line 176
            tcp->rates[j] = (float )30;
          }
        }
#line 179
        if (j == tcp->numlayers - 1) {
#line 180
          tcp->rates[j] -= (float )2;
        }
      }
#line 155
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 186
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 187
    compno = 0;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if (! (compno < tile->numcomps)) {
#line 187
        goto while_break___1;
      }
      {
#line 188
      tccp = tcp->tccps + compno;
#line 190
      tilec = tile->comps + compno;
#line 193
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 194
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 195
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 196
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 198
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 198
      tilec->data = (int *)__cil_tmp31;
#line 199
      tilec->numresolutions = tccp->numresolutions;
#line 201
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 201
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 203
      resno = 0;
      }
      {
#line 203
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 203
        if (! (resno < tilec->numresolutions)) {
#line 203
          goto while_break___2;
        }
        {
#line 205
        levelno = (tilec->numresolutions - 1) - resno;
#line 211
        res = tilec->resolutions + resno;
#line 214
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 215
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 216
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 217
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 219
        if (resno == 0) {
#line 219
          tmp___1 = 1;
        } else {
#line 219
          tmp___1 = 3;
        }
#line 219
        res->numbands = tmp___1;
#line 221
        if (tccp->csty & 1) {
#line 222
          pdx = tccp->prcw[resno];
#line 223
          pdy = tccp->prch[resno];
        } else {
#line 225
          pdx = 15;
#line 226
          pdy = 15;
        }
        {
#line 229
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 229
        tlprcxstart = __cil_tmp54 << pdx;
#line 230
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 230
        tlprcystart = __cil_tmp55 << pdy;
#line 232
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 232
        brprcxend = __cil_tmp56 << pdx;
#line 233
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 233
        brprcyend = __cil_tmp57 << pdy;
#line 235
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 236
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 238
        if (resno == 0) {
#line 239
          tlcbgxstart = tlprcxstart;
#line 240
          tlcbgystart = tlprcystart;
#line 241
          brcbgxend = brprcxend;
#line 242
          brcbgyend = brprcyend;
#line 243
          cbgwidthexpn = pdx;
#line 244
          cbgheightexpn = pdy;
        } else {
          {
#line 246
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 247
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 248
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 249
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 250
          cbgwidthexpn = pdx - 1;
#line 251
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 256
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 257
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 259
        bandno = 0;
        }
        {
#line 259
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 259
          if (! (bandno < res->numbands)) {
#line 259
            goto while_break___3;
          }
#line 262
          ss = (opj_stepsize_t *)((void *)0);
#line 264
          band = & res->bands[bandno];
#line 266
          if (resno == 0) {
#line 266
            tmp___2 = 0;
          } else {
#line 266
            tmp___2 = bandno + 1;
          }
#line 266
          band->bandno = tmp___2;
#line 267
          if (band->bandno == 1 || band->bandno == 3) {
#line 267
            tmp___3 = 1;
          } else {
#line 267
            tmp___3 = 0;
          }
#line 267
          x0b = tmp___3;
#line 268
          if (band->bandno == 2 || band->bandno == 3) {
#line 268
            tmp___4 = 1;
          } else {
#line 268
            tmp___4 = 0;
          }
#line 268
          y0b = tmp___4;
#line 270
          if (band->bandno == 0) {
            {
#line 272
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 273
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 274
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 275
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 278
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 279
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 280
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 281
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 284
          if (resno == 0) {
#line 284
            tmp___5 = 0;
          } else {
#line 284
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 284
          ss = & tccp->stepsizes[tmp___5];
#line 285
          if (tccp->qmfbid == 0) {
            {
#line 285
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 285
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 285
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 285
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 285
          gain = tmp___6;
#line 286
          numbps = (image->comps + compno)->prec + gain;
#line 288
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 288
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 289
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 291
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 291
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 293
          i = 0;
          }
          {
#line 293
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 293
            if (! (i < (res->pw * res->ph) * 3)) {
#line 293
              goto while_break___4;
            }
#line 294
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 295
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 296
            (band->precincts + i)->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 293
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 299
          precno = 0;
          {
#line 299
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 299
            if (! (precno < res->pw * res->ph)) {
#line 299
              goto while_break___5;
            }
            {
#line 302
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 303
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 304
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 305
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 307
            prc = band->precincts + precno;
#line 310
            prc->x0 = int_max(cbgxstart, band->x0);
#line 311
            prc->y0 = int_max(cbgystart, band->y0);
#line 312
            prc->x1 = int_min(cbgxend, band->x1);
#line 313
            prc->y1 = int_min(cbgyend, band->y1);
#line 315
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 315
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 316
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 316
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 317
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 317
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 318
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 318
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 319
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 320
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 322
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 322
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 323
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 324
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 326
            cblkno = 0;
            }
            {
#line 326
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 326
              if (! (cblkno < prc->cw * prc->ch)) {
#line 326
                goto while_break___6;
              }
              {
#line 327
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 328
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 329
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 330
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 332
              cblk = prc->cblks.enc + cblkno;
#line 335
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 336
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 337
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 338
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 339
              __cil_tmp118 = calloc((unsigned long )9730, sizeof(unsigned char ));
#line 339
              cblk->data = (unsigned char *)__cil_tmp118;
#line 341
              *(cblk->data + 0) = (unsigned char )0;
#line 342
              *(cblk->data + 1) = (unsigned char )0;
#line 343
              cblk->data += 2;
#line 344
              __cil_tmp119 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 344
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 345
              __cil_tmp120 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 345
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
              }
#line 326
              cblkno ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 299
            precno ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 259
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 203
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 187
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 356 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 359
  tileno = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (tileno < 1)) {
#line 359
      goto while_break;
    }
#line 360
    tile = (tcd->tcd_image)->tiles;
#line 362
    compno = 0;
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! (compno < tile->numcomps)) {
#line 362
        goto while_break___0;
      }
#line 363
      tilec = tile->comps + compno;
#line 365
      resno = 0;
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 365
        if (! (resno < tilec->numresolutions)) {
#line 365
          goto while_break___1;
        }
#line 366
        res = tilec->resolutions + resno;
#line 368
        bandno = 0;
        {
#line 368
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 368
          if (! (bandno < res->numbands)) {
#line 368
            goto while_break___2;
          }
#line 369
          band = & res->bands[bandno];
#line 371
          precno = 0;
          {
#line 371
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 371
            if (! (precno < res->pw * res->ph)) {
#line 371
              goto while_break___3;
            }
#line 372
            prc = band->precincts + precno;
#line 374
            if (prc->incltree != (void *)0) {
              {
#line 375
              tgt_destroy(prc->incltree);
#line 376
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 378
            if (prc->imsbtree != (void *)0) {
              {
#line 379
              tgt_destroy(prc->imsbtree);
#line 380
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 382
            cblkno = 0;
            {
#line 382
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 382
              if (! (cblkno < prc->cw * prc->ch)) {
#line 382
                goto while_break___4;
              }
              {
#line 383
              free((prc->cblks.enc + cblkno)->data - 2);
#line 384
              free((prc->cblks.enc + cblkno)->layers);
#line 385
              free((prc->cblks.enc + cblkno)->passes);
              }
#line 382
              cblkno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 387
            free(prc->cblks.enc);
            }
#line 371
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 389
          free(band->precincts);
#line 390
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
          }
#line 368
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 365
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 393
      free(tilec->resolutions);
#line 394
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
      }
#line 362
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 396
    free(tile->comps);
#line 397
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
#line 359
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 399
  free((tcd->tcd_image)->tiles);
#line 400
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
  return;
}
}
#line 403 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp22 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  opj_tgt_tree_t *__cil_tmp101 ;
  opj_tgt_tree_t *__cil_tmp102 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;

  {
#line 406
  tileno = 0;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (tileno < 1)) {
#line 406
      goto while_break;
    }
    {
#line 407
    tcp = cp->tcps + curtileno;
#line 410
    p = curtileno % cp->tw;
#line 411
    q = curtileno / cp->tw;
#line 413
    tile = (tcd->tcd_image)->tiles;
#line 416
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 417
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 418
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 419
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 421
    tile->numcomps = image->numcomps;
#line 425
    j = 0;
    }
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! (j < tcp->numlayers)) {
#line 425
        goto while_break___0;
      }
#line 426
      if (tcp->rates[j]) {
#line 426
        if ((int )cp->tp_on) {
#line 426
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 426
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 426
        tmp___0 = tmp;
      } else {
#line 426
        tmp___0 = (float )0;
      }
#line 426
      tcp->rates[j] = tmp___0;
#line 441
      if (tcp->rates[j]) {
#line 442
        if (j) {
#line 442
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 443
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 442
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 445
        if (! j) {
#line 445
          if (tcp->rates[j] < (float )30) {
#line 446
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 425
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    compno = 0;
    {
#line 453
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 453
      if (! (compno < tile->numcomps)) {
#line 453
        goto while_break___1;
      }
      {
#line 454
      tccp = tcp->tccps + compno;
#line 456
      tilec = tile->comps + compno;
#line 459
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 460
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 461
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 462
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 464
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 464
      tilec->data = (int *)__cil_tmp29;
#line 465
      tilec->numresolutions = tccp->numresolutions;
#line 467
      resno = 0;
      }
      {
#line 467
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 467
        if (! (resno < tilec->numresolutions)) {
#line 467
          goto while_break___2;
        }
        {
#line 470
        levelno = (tilec->numresolutions - 1) - resno;
#line 476
        res = tilec->resolutions + resno;
#line 479
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 480
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 481
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 482
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 483
        if (resno == 0) {
#line 483
          tmp___1 = 1;
        } else {
#line 483
          tmp___1 = 3;
        }
#line 483
        res->numbands = tmp___1;
#line 486
        if (tccp->csty & 1) {
#line 487
          pdx = tccp->prcw[resno];
#line 488
          pdy = tccp->prch[resno];
        } else {
#line 490
          pdx = 15;
#line 491
          pdy = 15;
        }
        {
#line 494
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 494
        tlprcxstart = __cil_tmp51 << pdx;
#line 495
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 495
        tlprcystart = __cil_tmp52 << pdy;
#line 496
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 496
        brprcxend = __cil_tmp53 << pdx;
#line 497
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 497
        brprcyend = __cil_tmp54 << pdy;
#line 499
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 500
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 502
        if (resno == 0) {
#line 503
          tlcbgxstart = tlprcxstart;
#line 504
          tlcbgystart = tlprcystart;
#line 505
          brcbgxend = brprcxend;
#line 506
          brcbgyend = brprcyend;
#line 507
          cbgwidthexpn = pdx;
#line 508
          cbgheightexpn = pdy;
        } else {
          {
#line 510
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 511
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 512
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 513
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 514
          cbgwidthexpn = pdx - 1;
#line 515
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 520
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 521
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 523
        bandno = 0;
        }
        {
#line 523
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 523
          if (! (bandno < res->numbands)) {
#line 523
            goto while_break___3;
          }
#line 526
          ss = (opj_stepsize_t *)((void *)0);
#line 528
          band = & res->bands[bandno];
#line 530
          if (resno == 0) {
#line 530
            tmp___2 = 0;
          } else {
#line 530
            tmp___2 = bandno + 1;
          }
#line 530
          band->bandno = tmp___2;
#line 531
          if (band->bandno == 1 || band->bandno == 3) {
#line 531
            tmp___3 = 1;
          } else {
#line 531
            tmp___3 = 0;
          }
#line 531
          x0b = tmp___3;
#line 532
          if (band->bandno == 2 || band->bandno == 3) {
#line 532
            tmp___4 = 1;
          } else {
#line 532
            tmp___4 = 0;
          }
#line 532
          y0b = tmp___4;
#line 534
          if (band->bandno == 0) {
            {
#line 536
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 537
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 538
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 539
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 541
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 542
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 543
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 544
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 547
          if (resno == 0) {
#line 547
            tmp___5 = 0;
          } else {
#line 547
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 547
          ss = & tccp->stepsizes[tmp___5];
#line 548
          if (tccp->qmfbid == 0) {
            {
#line 548
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 548
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 548
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 548
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 548
          gain = tmp___6;
#line 549
          numbps = (image->comps + compno)->prec + gain;
#line 550
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 550
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 551
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 553
          precno = 0;
          }
          {
#line 553
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 553
            if (! (precno < res->pw * res->ph)) {
#line 553
              goto while_break___4;
            }
            {
#line 556
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 557
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 558
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 559
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 561
            prc = band->precincts + precno;
#line 564
            prc->x0 = int_max(cbgxstart, band->x0);
#line 565
            prc->y0 = int_max(cbgystart, band->y0);
#line 566
            prc->x1 = int_min(cbgxend, band->x1);
#line 567
            prc->y1 = int_min(cbgyend, band->y1);
#line 569
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 569
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 570
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 570
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 571
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 571
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 572
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 572
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 573
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 574
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 576
            free(prc->cblks.enc);
#line 577
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 577
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 579
            if (prc->incltree != (void *)0) {
              {
#line 580
              tgt_destroy(prc->incltree);
              }
            }
#line 582
            if (prc->imsbtree != (void *)0) {
              {
#line 583
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 586
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 587
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 589
            cblkno = 0;
            }
            {
#line 589
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 589
              if (! (cblkno < prc->cw * prc->ch)) {
#line 589
                goto while_break___5;
              }
              {
#line 590
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 591
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 592
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 593
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 595
              cblk = prc->cblks.enc + cblkno;
#line 598
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 599
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 600
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 601
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 602
              __cil_tmp112 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 602
              cblk->data = (unsigned char *)__cil_tmp112;
#line 604
              *(cblk->data + 0) = (unsigned char )0;
#line 605
              *(cblk->data + 1) = (unsigned char )0;
#line 606
              cblk->data += 2;
#line 607
              __cil_tmp113 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 607
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 608
              __cil_tmp114 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 608
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
              }
#line 589
              cblkno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 553
            precno ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 523
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 467
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 453
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 406
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 619 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
#line 621
  x0 = (unsigned int )0;
#line 621
  y0___0 = (unsigned int )0;
#line 621
  x1 = (unsigned int )0;
  {
#line 621
  y1___0 = (unsigned int )0;
#line 623
  tcd->image = image;
#line 624
  (tcd->tcd_image)->tw = cp->tw;
#line 625
  (tcd->tcd_image)->th = cp->th;
#line 626
  __cil_tmp15 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcd_tile_t ));
#line 626
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 633
  j = 0;
  }
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! (j < cp->tileno_size)) {
#line 633
      goto while_break;
    }
    {
#line 636
    tileno = *(cp->tileno + j);
#line 637
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 638
    tile->numcomps = image->numcomps;
#line 639
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 639
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
    }
#line 633
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 642
    if (! (i < image->numcomps)) {
#line 642
      goto while_break___0;
    }
#line 643
    j = 0;
    {
#line 643
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 643
      if (! (j < cp->tileno_size)) {
#line 643
        goto while_break___1;
      }
      {
#line 649
      tileno = *(cp->tileno + j);
#line 651
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 652
      tilec = tile___0->comps + i;
#line 654
      p = tileno % cp->tw;
#line 655
      q = tileno / cp->tw;
#line 658
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 659
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 660
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 661
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 663
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 664
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 665
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 666
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 668
      if (j == 0) {
#line 668
        tmp = tilec->x0;
      } else {
        {
#line 668
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 668
        tmp = __cil_tmp29;
        }
      }
#line 668
      x0 = (unsigned int )tmp;
#line 669
      if (j == 0) {
#line 669
        tmp___0 = tilec->y0;
      } else {
        {
#line 669
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->y0));
#line 669
        tmp___0 = __cil_tmp31;
        }
      }
#line 669
      y0___0 = (unsigned int )tmp___0;
#line 670
      if (j == 0) {
#line 670
        tmp___1 = tilec->x1;
      } else {
        {
#line 670
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 670
        tmp___1 = __cil_tmp33;
        }
      }
#line 670
      x1 = (unsigned int )tmp___1;
#line 671
      if (j == 0) {
#line 671
        tmp___2 = tilec->y1;
      } else {
        {
#line 671
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 671
        tmp___2 = __cil_tmp35;
        }
      }
#line 671
      y1___0 = (unsigned int )tmp___2;
#line 643
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 674
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 674
    w = (unsigned int )__cil_tmp38;
#line 675
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 675
    h = (unsigned int )__cil_tmp39;
#line 677
    (image->comps + i)->w = (int )w;
#line 678
    (image->comps + i)->h = (int )h;
#line 679
    (image->comps + i)->x0 = (int )x0;
#line 680
    (image->comps + i)->y0 = (int )y0___0;
    }
#line 642
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 684 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tgt_tree_t *__cil_tmp94 ;
  opj_tgt_tree_t *__cil_tmp95 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 691
  tcd->cp = cp;
#line 693
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 694
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 696
  tileno = *(cp->tileno + tileno);
#line 698
  compno = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! (compno < tile->numcomps)) {
#line 698
      goto while_break;
    }
#line 699
    tccp = tcp->tccps + compno;
#line 700
    tilec = tile->comps + compno;
#line 702
    if (tccp->numresolutions <= 0) {
#line 704
      *(cp->tileno + tileno) = - 1;
#line 705
      return;
    }
    {
#line 709
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 710
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 711
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 712
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 714
    tilec->numresolutions = tccp->numresolutions;
#line 715
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 715
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 717
    resno = 0;
    }
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 717
      if (! (resno < tilec->numresolutions)) {
#line 717
        goto while_break___0;
      }
      {
#line 719
      levelno = (tilec->numresolutions - 1) - resno;
#line 725
      res = tilec->resolutions + resno;
#line 728
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 729
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 730
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 731
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 732
      if (resno == 0) {
#line 732
        tmp = 1;
      } else {
#line 732
        tmp = 3;
      }
#line 732
      res->numbands = tmp;
#line 735
      if (tccp->csty & 1) {
#line 736
        pdx = tccp->prcw[resno];
#line 737
        pdy = tccp->prch[resno];
      } else {
#line 739
        pdx = 15;
#line 740
        pdy = 15;
      }
      {
#line 744
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 744
      tlprcxstart = __cil_tmp41 << pdx;
#line 745
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 745
      tlprcystart = __cil_tmp42 << pdy;
#line 746
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 746
      brprcxend = __cil_tmp43 << pdx;
#line 747
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 747
      brprcyend = __cil_tmp44 << pdy;
      }
#line 749
      if (res->x0 == res->x1) {
#line 749
        tmp___0 = 0;
      } else {
#line 749
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 749
      res->pw = tmp___0;
#line 750
      if (res->y0 == res->y1) {
#line 750
        tmp___1 = 0;
      } else {
#line 750
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 750
      res->ph = tmp___1;
#line 752
      if (resno == 0) {
#line 753
        tlcbgxstart = tlprcxstart;
#line 754
        tlcbgystart = tlprcystart;
#line 755
        brcbgxend = brprcxend;
#line 756
        brcbgyend = brprcyend;
#line 757
        cbgwidthexpn = pdx;
#line 758
        cbgheightexpn = pdy;
      } else {
        {
#line 760
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 761
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 762
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 763
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 764
        cbgwidthexpn = pdx - 1;
#line 765
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 770
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 771
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 773
      bandno = 0;
      }
      {
#line 773
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 773
        if (! (bandno < res->numbands)) {
#line 773
          goto while_break___1;
        }
#line 776
        ss = (opj_stepsize_t *)((void *)0);
#line 778
        band = & res->bands[bandno];
#line 779
        if (resno == 0) {
#line 779
          tmp___2 = 0;
        } else {
#line 779
          tmp___2 = bandno + 1;
        }
#line 779
        band->bandno = tmp___2;
#line 780
        if (band->bandno == 1 || band->bandno == 3) {
#line 780
          tmp___3 = 1;
        } else {
#line 780
          tmp___3 = 0;
        }
#line 780
        x0b = tmp___3;
#line 781
        if (band->bandno == 2 || band->bandno == 3) {
#line 781
          tmp___4 = 1;
        } else {
#line 781
          tmp___4 = 0;
        }
#line 781
        y0b = tmp___4;
#line 783
        if (band->bandno == 0) {
          {
#line 785
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 786
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 787
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 788
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 791
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 792
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 793
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 794
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 797
        if (resno == 0) {
#line 797
          tmp___5 = 0;
        } else {
#line 797
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 797
        ss = & tccp->stepsizes[tmp___5];
#line 798
        if (tccp->qmfbid == 0) {
          {
#line 798
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 798
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 798
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 798
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 798
        gain = tmp___6;
#line 799
        numbps = (image->comps + compno)->prec + gain;
#line 800
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 800
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 801
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 803
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 803
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 805
        precno = 0;
        }
        {
#line 805
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 805
          if (! (precno < res->pw * res->ph)) {
#line 805
            goto while_break___2;
          }
          {
#line 807
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 808
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 809
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 810
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 812
          prc = band->precincts + precno;
#line 814
          prc->x0 = int_max(cbgxstart, band->x0);
#line 815
          prc->y0 = int_max(cbgystart, band->y0);
#line 816
          prc->x1 = int_min(cbgxend, band->x1);
#line 817
          prc->y1 = int_min(cbgyend, band->y1);
#line 819
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 819
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 820
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 820
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 821
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 821
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 822
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 822
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 823
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 824
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 826
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 826
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 828
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 829
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 831
          cblkno = 0;
          }
          {
#line 831
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 831
            if (! (cblkno < prc->cw * prc->ch)) {
#line 831
              goto while_break___3;
            }
            {
#line 832
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 833
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 834
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 835
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 837
            cblk = prc->cblks.dec + cblkno;
#line 838
            cblk->data = (unsigned char *)((void *)0);
#line 839
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 841
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 842
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 843
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 844
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 845
            cblk->numsegs = 0;
            }
#line 831
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 805
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 773
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 717
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 698
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 854 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 860
  cp = tcd->cp;
#line 861
  tcd_tile = tcd->tcd_tile;
#line 862
  tcd_tcp = tcd->tcp;
#line 866
  compno = 0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (compno < tcd_tile->numcomps)) {
#line 866
      goto while_break;
    }
#line 867
    tilec = tcd_tile->comps + compno;
#line 868
    i = 0;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 868
      if (! (i < tcd_tcp->numlayers)) {
#line 868
        goto while_break___0;
      }
#line 869
      j = 0;
      {
#line 869
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 869
        if (! (j < tilec->numresolutions)) {
#line 869
          goto while_break___1;
        }
#line 870
        k = 0;
        {
#line 870
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 870
          if (! (k < 3)) {
#line 870
            goto while_break___2;
          }
#line 871
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 870
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 869
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 868
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 878
    resno = 0;
    {
#line 878
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 878
      if (! (resno < tilec->numresolutions)) {
#line 878
        goto while_break___3;
      }
#line 879
      res = tilec->resolutions + resno;
#line 880
      bandno = 0;
      {
#line 880
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 880
        if (! (bandno < res->numbands)) {
#line 880
          goto while_break___4;
        }
#line 881
        band = & res->bands[bandno];
#line 882
        precno = 0;
        {
#line 882
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 882
          if (! (precno < res->pw * res->ph)) {
#line 882
            goto while_break___5;
          }
#line 883
          prc = band->precincts + precno;
#line 884
          cblkno = 0;
          {
#line 884
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 884
            if (! (cblkno < prc->cw * prc->ch)) {
#line 884
              goto while_break___6;
            }
#line 885
            cblk = prc->cblks.enc + cblkno;
#line 886
            layer = cblk->layers + layno;
#line 888
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 890
            if (layno == 0) {
#line 891
              value = matrice[layno][resno][bandno];
#line 892
              if (imsb >= value) {
#line 893
                value = 0;
              } else {
#line 895
                value -= imsb;
              }
            } else {
#line 898
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 899
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 900
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 901
                if (value < 0) {
#line 902
                  value = 0;
                }
              }
            }
#line 907
            if (layno == 0) {
#line 908
              cblk->numpassesinlayers = 0;
            }
#line 911
            n = cblk->numpassesinlayers;
#line 912
            if (cblk->numpassesinlayers == 0) {
#line 913
              if (value != 0) {
#line 914
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 916
                n = cblk->numpassesinlayers;
              }
            } else {
#line 919
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 922
            layer->numpasses = n - cblk->numpassesinlayers;
#line 924
            if (! layer->numpasses) {
#line 925
              goto while_continue___6;
            }
#line 927
            if (cblk->numpassesinlayers == 0) {
#line 928
              layer->len = (cblk->passes + (n - 1))->rate;
#line 929
              layer->data = cblk->data;
            } else {
#line 931
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 932
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 934
            if (final) {
#line 935
              cblk->numpassesinlayers = n;
            }
#line 884
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 882
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 880
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 878
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 866
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 943 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;
  int __cil_tmp3 ;

  {
#line 945
  layno = 0;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 945
      goto while_break;
    }
    {
#line 946
    tcd_makelayer_fixed(tcd, layno, 1);
    }
#line 945
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 950 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
#line 953
  tcd_tile = tcd->tcd_tile;
#line 955
  tcd_tile->distolayer[layno] = (double )0;
#line 957
  compno = 0;
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (compno < tcd_tile->numcomps)) {
#line 957
      goto while_break;
    }
#line 958
    tilec = tcd_tile->comps + compno;
#line 959
    resno = 0;
    {
#line 959
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 959
      if (! (resno < tilec->numresolutions)) {
#line 959
        goto while_break___0;
      }
#line 960
      res = tilec->resolutions + resno;
#line 961
      bandno = 0;
      {
#line 961
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 961
        if (! (bandno < res->numbands)) {
#line 961
          goto while_break___1;
        }
#line 962
        band = & res->bands[bandno];
#line 963
        precno = 0;
        {
#line 963
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 963
          if (! (precno < res->pw * res->ph)) {
#line 963
            goto while_break___2;
          }
#line 964
          prc = band->precincts + precno;
#line 965
          cblkno = 0;
          {
#line 965
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 965
            if (! (cblkno < prc->cw * prc->ch)) {
#line 965
              goto while_break___3;
            }
#line 966
            cblk = prc->cblks.enc + cblkno;
#line 967
            layer = cblk->layers + layno;
#line 970
            if (layno == 0) {
#line 971
              cblk->numpassesinlayers = 0;
            }
#line 973
            n = cblk->numpassesinlayers;
#line 974
            passno = cblk->numpassesinlayers;
            {
#line 974
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 974
              if (! (passno < cblk->totalpasses)) {
#line 974
                goto while_break___4;
              }
#line 977
              pass = cblk->passes + passno;
#line 978
              if (n == 0) {
#line 979
                dr = pass->rate;
#line 980
                dd = pass->distortiondec;
              } else {
#line 982
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 983
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 985
              if (! dr) {
#line 986
                if (dd != (double )0) {
#line 987
                  n = passno + 1;
                }
#line 988
                goto while_continue___4;
              }
#line 990
              if (dd / (double )dr >= thresh) {
#line 991
                n = passno + 1;
              }
#line 974
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 993
            layer->numpasses = n - cblk->numpassesinlayers;
#line 995
            if (! layer->numpasses) {
#line 996
              layer->disto = (double )0;
#line 997
              goto while_continue___3;
            }
#line 999
            if (cblk->numpassesinlayers == 0) {
#line 1000
              layer->len = (cblk->passes + (n - 1))->rate;
#line 1001
              layer->data = cblk->data;
#line 1002
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 1004
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1005
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1006
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 1009
            tcd_tile->distolayer[layno] += layer->disto;
#line 1011
            if (final) {
#line 1012
              cblk->numpassesinlayers = n;
            }
#line 965
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 963
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 961
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 959
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 957
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1020 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  int __cil_tmp54 ;
  double tmp___0 ;
  double tmp___1 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double tmp___2 ;
  double tmp___3 ;
  int __cil_tmp61 ;

  {
#line 1024
  K = (double )1;
#line 1025
  maxSE = (double )0;
#line 1027
  cp = tcd->cp;
#line 1028
  tcd_tile = tcd->tcd_tile;
#line 1029
  tcd_tcp = tcd->tcp;
#line 1031
  min = (double )1.79769313487e+308L;
#line 1032
  max = (double )0;
#line 1034
  tcd_tile->numpix = 0;
#line 1036
  compno = 0;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (compno < tcd_tile->numcomps)) {
#line 1036
      goto while_break;
    }
#line 1037
    tilec = tcd_tile->comps + compno;
#line 1038
    tilec->numpix = 0;
#line 1040
    resno = 0;
    {
#line 1040
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1040
      if (! (resno < tilec->numresolutions)) {
#line 1040
        goto while_break___0;
      }
#line 1041
      res = tilec->resolutions + resno;
#line 1043
      bandno = 0;
      {
#line 1043
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1043
        if (! (bandno < res->numbands)) {
#line 1043
          goto while_break___1;
        }
#line 1044
        band = & res->bands[bandno];
#line 1046
        precno = 0;
        {
#line 1046
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1046
          if (! (precno < res->pw * res->ph)) {
#line 1046
            goto while_break___2;
          }
#line 1047
          prc = band->precincts + precno;
#line 1049
          cblkno = 0;
          {
#line 1049
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1049
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1049
              goto while_break___3;
            }
#line 1050
            cblk = prc->cblks.enc + cblkno;
#line 1052
            passno = 0;
            {
#line 1052
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1052
              if (! (passno < cblk->totalpasses)) {
#line 1052
                goto while_break___4;
              }
#line 1053
              pass = cblk->passes + passno;
#line 1056
              if (passno == 0) {
#line 1057
                dr = pass->rate;
#line 1058
                dd = pass->distortiondec;
              } else {
#line 1060
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1061
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1063
              if (dr == 0) {
#line 1064
                goto while_continue___4;
              }
#line 1066
              rdslope = dd / (double )dr;
#line 1067
              if (rdslope < min) {
#line 1068
                min = rdslope;
              }
#line 1070
              if (rdslope > max) {
#line 1071
                max = rdslope;
              }
#line 1052
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1076
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1077
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1049
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1046
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1043
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1040
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1083
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1036
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1089
  if (cstr_info) {
    {
#line 1090
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1091
    tile_info->numpix = tcd_tile->numpix;
#line 1092
    tile_info->distotile = tcd_tile->distotile;
#line 1093
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1093
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1096
  layno = 0;
  {
#line 1096
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1096
    if (! (layno < tcd_tcp->numlayers)) {
#line 1096
      goto while_break___5;
    }
#line 1097
    lo = min;
#line 1098
    hi = max;
#line 1099
    success = 0;
#line 1100
    if (tcd_tcp->rates[layno]) {
      {
#line 1100
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1100
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1100
      tmp = __cil_tmp42;
      }
    } else {
#line 1100
      tmp = len;
    }
    {
#line 1100
    maxlen = tmp;
#line 1101
    goodthresh = (double )0;
#line 1102
    stable_thresh = (double )0;
#line 1107
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1107
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp48;
    }
#line 1113
    if (cp->disto_alloc == 1) {
#line 1113
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: /* CIL Label */ 
        {
#line 1114
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1114
        t2 = __cil_tmp50;
#line 1115
        thresh = (double )0;
#line 1117
        i = 0;
        }
        {
#line 1117
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1117
          if (! (i < 128)) {
#line 1117
            goto while_break___6;
          }
          {
#line 1118
          l = 0;
#line 1119
          distoachieved = (double )0;
#line 1120
          thresh = (lo + hi) / (double )2;
#line 1122
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1124
          if (cp->fixed_quality) {
#line 1125
            if (cp->cinema) {
              {
#line 1126
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1127
              if (l == -999) {
#line 1128
                lo = thresh;
#line 1129
                goto while_continue___6;
              } else {
#line 1131
                if (layno == 0) {
#line 1131
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1131
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1131
                distoachieved = tmp___0;
#line 1133
                if (distoachieved < distotarget) {
#line 1134
                  hi = thresh;
#line 1135
                  stable_thresh = thresh;
#line 1136
                  goto while_continue___6;
                } else {
#line 1138
                  lo = thresh;
                }
              }
            } else {
#line 1142
              if (layno == 0) {
#line 1142
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1142
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1142
              distoachieved = tmp___1;
#line 1144
              if (distoachieved < distotarget) {
#line 1145
                hi = thresh;
#line 1146
                stable_thresh = thresh;
#line 1147
                goto while_continue___6;
              }
#line 1149
              lo = thresh;
            }
          } else {
            {
#line 1152
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1155
            if (l == -999) {
#line 1156
              lo = thresh;
#line 1157
              goto while_continue___6;
            }
#line 1159
            hi = thresh;
#line 1160
            stable_thresh = thresh;
          }
#line 1117
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1163
        success = 1;
#line 1164
        if (stable_thresh == (double )0) {
#line 1164
          tmp___2 = thresh;
        } else {
#line 1164
          tmp___2 = stable_thresh;
        }
        {
#line 1164
        goodthresh = tmp___2;
#line 1165
        t2_destroy(t2);
        }
      } else {
#line 1113
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1113
    if (cp->fixed_quality == 1) {
#line 1113
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1113
        goto _L;
      } else {
#line 1167
        success = 1;
#line 1168
        goodthresh = min;
      }
    } else {
#line 1167
      success = 1;
#line 1168
      goodthresh = min;
    }
#line 1171
    if (! success) {
#line 1172
      return (0);
    }
#line 1175
    if (cstr_info) {
#line 1176
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1178
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1181
    if (layno == 0) {
#line 1181
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1181
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1181
    cumdisto[layno] = tmp___3;
#line 1096
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1184
  return (1);
}
}
#line 1187 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int __cil_tmp50 ;
  opj_t1_t *__cil_tmp51 ;
  opj_t2_t *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  int __cil_tmp56 ;

  {
#line 1189
  numpacks = 0;
#line 1190
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1191
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1192
  cp = (opj_cp_t *)((void *)0);
#line 1194
  tcp = (tcd->cp)->tcps + 0;
#line 1195
  tccp = tcp->tccps + 0;
#line 1196
  image = tcd->image;
#line 1198
  t1 = (opj_t1_t *)((void *)0);
#line 1199
  t2 = (opj_t2_t *)((void *)0);
#line 1201
  tcd->tcd_tileno = tileno;
#line 1202
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1203
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1205
  tile = tcd->tcd_tile;
#line 1206
  tcd_tcp = tcd->tcp;
#line 1207
  cp = tcd->cp;
#line 1209
  if (tcd->cur_tp_num == 0) {
    {
#line 1210
    tcd->encoding_time = opj_clock();
    }
#line 1212
    if (cstr_info) {
#line 1213
      tilec_idx = tile->comps + 0;
#line 1214
      i = 0;
      {
#line 1214
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1214
        if (! (i < tilec_idx->numresolutions)) {
#line 1214
          goto while_break;
        }
#line 1215
        res_idx = tilec_idx->resolutions + i;
#line 1217
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1218
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1220
        numpacks += res_idx->pw * res_idx->ph;
#line 1222
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1223
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1214
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1225
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1225
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1231
    compno = 0;
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1231
      if (! (compno < tile->numcomps)) {
#line 1231
        goto while_break___0;
      }
#line 1234
      if ((image->comps + compno)->sgnd) {
#line 1234
        tmp = 0;
      } else {
#line 1234
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1234
      adjust = tmp;
#line 1235
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1235
      offset_x = __cil_tmp28;
#line 1236
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1236
      offset_y = __cil_tmp30;
#line 1238
      tilec = tile->comps + compno;
#line 1239
      tw = tilec->x1 - tilec->x0;
#line 1240
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1240
      w = __cil_tmp34;
      }
#line 1244
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1245
        y = tilec->y0;
        {
#line 1245
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1245
          if (! (y < tilec->y1)) {
#line 1245
            goto while_break___1;
          }
#line 1247
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1249
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1250
          x = tilec->x0;
          {
#line 1250
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1250
            if (! (x < tilec->x1)) {
#line 1250
              goto while_break___2;
            }
#line 1251
            __cil_tmp38 = data;
#line 1251
            data ++;
#line 1251
            __cil_tmp37 = tile_data;
#line 1251
            tile_data ++;
#line 1251
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1250
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1245
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1254
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1255
        y = tilec->y0;
        {
#line 1255
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1255
          if (! (y < tilec->y1)) {
#line 1255
            goto while_break___3;
          }
#line 1257
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1259
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1260
          x = tilec->x0;
          {
#line 1260
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1260
            if (! (x < tilec->x1)) {
#line 1260
              goto while_break___4;
            }
#line 1261
            __cil_tmp44 = data___0;
#line 1261
            data___0 ++;
#line 1261
            __cil_tmp43 = tile_data___0;
#line 1261
            tile_data___0 ++;
#line 1261
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1260
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1255
          y ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1231
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1269
    if (tcd_tcp->mct) {
#line 1270
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1271
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1272
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1274
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1280
    compno = 0;
    {
#line 1280
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1280
      if (! (compno < tile->numcomps)) {
#line 1280
        goto while_break___5;
      }
#line 1281
      tilec___0 = tile->comps + compno;
#line 1282
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1283
        dwt_encode(tilec___0);
        }
      } else
#line 1284
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1285
        dwt_encode_real(tilec___0);
        }
      }
#line 1280
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1290
    t1 = t1_create(tcd->cinfo);
#line 1291
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1292
    t1_destroy(t1);
    }
#line 1297
    if (cstr_info) {
#line 1298
      cstr_info->index_write = 0;
    }
#line 1300
    if (cp->disto_alloc) {
      {
      {
#line 1302
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else
#line 1300
    if (cp->fixed_quality) {
      {
      {
#line 1302
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else {
      {
#line 1305
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1311
  if (cstr_info) {
#line 1312
    cstr_info->index_write = 1;
  }
  {
#line 1315
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1316
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1317
  t2_destroy(t2);
  }
#line 1322
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1323
    __cil_tmp54 = opj_clock();
#line 1323
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1324
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1327
    compno = 0;
    }
    {
#line 1327
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1327
      if (! (compno < tile->numcomps)) {
#line 1327
        goto while_break___6;
      }
      {
#line 1328
      tilec___1 = tile->comps + compno;
#line 1329
      free(tilec___1->data);
      }
#line 1327
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1333
  return (l);
}
}
#line 1336 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp15 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  opj_t2_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  opj_t1_t *__cil_tmp29 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int offset_x ;
  int __cil_tmp51 ;
  int offset_y ;
  int __cil_tmp53 ;
  int i ;
  int j ;
  void *__cil_tmp56 ;
  int v ;
  int __cil_tmp58 ;
  float tmp___2 ;
  int v___0 ;
  long __cil_tmp61 ;
  int __cil_tmp62 ;
  double __cil_tmp63 ;

  {
  {
#line 1339
  eof = 0;
#line 1341
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1343
  t1 = (opj_t1_t *)((void *)0);
#line 1344
  t2 = (opj_t2_t *)((void *)0);
#line 1346
  tcd->tcd_tileno = tileno;
#line 1347
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1348
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1349
  tile = tcd->tcd_tile;
#line 1351
  tile_time = opj_clock();
#line 1352
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1355
  if (cstr_info) {
#line 1356
    numprec = 0;
#line 1357
    compno___1 = 0;
    {
#line 1357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1357
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1357
        goto while_break;
      }
#line 1358
      tcp = (tcd->cp)->tcps + 0;
#line 1359
      tccp = tcp->tccps + compno___1;
#line 1360
      tilec_idx = tile->comps + compno___1;
#line 1361
      resno = 0;
      {
#line 1361
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1361
        if (! (resno < tilec_idx->numresolutions)) {
#line 1361
          goto while_break___0;
        }
#line 1362
        res_idx = tilec_idx->resolutions + resno;
#line 1363
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1364
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1365
        numprec += res_idx->pw * res_idx->ph;
#line 1366
        if (tccp->csty & 1) {
#line 1367
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1368
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1371
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1372
          (cstr_info->tile + tileno)->pdy[resno] = 15;
        }
#line 1361
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1357
      compno___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1376
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1376
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1377
    cstr_info->packno = 0;
    }
  }
  {
#line 1383
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1384
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1385
  t2_destroy(t2);
  }
#line 1387
  if (l == -999) {
    {
#line 1388
    eof = 1;
#line 1389
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
  }
  {
#line 1394
  t1_time = opj_clock();
#line 1395
  t1 = t1_create(tcd->cinfo);
  }
#line 1396
  if (t1 == (void *)0) {
    {
#line 1398
    opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1399
    t1_destroy(t1);
    }
#line 1400
    return (0);
  }
#line 1403
  compno = 0;
  {
#line 1403
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1403
    if (! (compno < tile->numcomps)) {
#line 1403
      goto while_break___1;
    }
    {
#line 1404
    tilec = tile->comps + compno;
#line 1406
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1406
    tilec->data = (int *)__cil_tmp31;
    }
#line 1407
    if (tilec->data == (void *)0) {
      {
#line 1409
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1410
      t1_destroy(t1);
      }
#line 1411
      return (0);
    }
    {
#line 1414
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
    }
#line 1403
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1416
  t1_destroy(t1);
#line 1417
  __cil_tmp32 = opj_clock();
#line 1417
  t1_time = __cil_tmp32 - t1_time;
#line 1418
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n", t1_time);
#line 1422
  dwt_time = opj_clock();
#line 1423
  compno = 0;
  }
  {
#line 1423
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1423
    if (! (compno < tile->numcomps)) {
#line 1423
      goto while_break___2;
    }
#line 1424
    tilec___0 = tile->comps + compno;
#line 1427
    if ((tcd->cp)->reduce != 0) {
#line 1428
      if ((tile->comps + compno)->numresolutions < (tcd->cp)->reduce - 1) {
        {
#line 1429
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1431
        return (0);
      } else {
#line 1434
        ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
      }
    }
#line 1439
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1440
    if (numres2decode > 0) {
#line 1441
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1442
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1444
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1423
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1448
  __cil_tmp37 = opj_clock();
#line 1448
  dwt_time = __cil_tmp37 - dwt_time;
#line 1449
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1453
  if ((tcd->tcp)->mct) {
#line 1454
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1456
    if (tile->numcomps >= 3) {
#line 1457
      if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
        {
#line 1458
        mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   n);
        }
      } else {
        {
#line 1464
        mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                        (float *)(tile->comps + 2)->data, n);
        }
      }
    } else {
      {
#line 1471
      opj_event_msg(tcd->cinfo, 2, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\nh5\212TV",
                    tile->numcomps);
      }
    }
  }
#line 1477
  compno = 0;
  {
#line 1477
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1477
    if (! (compno < tile->numcomps)) {
#line 1477
      goto while_break___3;
    }
#line 1478
    tilec___1 = tile->comps + compno;
#line 1479
    imagec = (tcd->image)->comps + compno;
#line 1480
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1481
    if (imagec->sgnd) {
#line 1481
      tmp = 0;
    } else {
#line 1481
      tmp = 1 << (imagec->prec - 1);
    }
#line 1481
    adjust = tmp;
#line 1482
    if (imagec->sgnd) {
#line 1482
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1482
      tmp___0 = 0;
    }
#line 1482
    min = tmp___0;
#line 1483
    if (imagec->sgnd) {
#line 1483
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1483
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1483
    max = tmp___1;
#line 1485
    tw = tilec___1->x1 - tilec___1->x0;
#line 1486
    w = imagec->w;
#line 1488
    __cil_tmp51 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1488
    offset_x = __cil_tmp51;
#line 1489
    __cil_tmp53 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1489
    offset_y = __cil_tmp53;
    }
#line 1492
    if (! imagec->data) {
      {
#line 1493
      __cil_tmp56 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1493
      imagec->data = (int *)__cil_tmp56;
      }
    }
#line 1495
    if (! imagec->data) {
      {
#line 1497
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1498
      return (0);
    }
#line 1500
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1501
      j = res->y0;
      {
#line 1501
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1501
        if (! (j < res->y1)) {
#line 1501
          goto while_break___4;
        }
#line 1502
        i = res->x0;
        {
#line 1502
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1502
          if (! (i < res->x1)) {
#line 1502
            goto while_break___5;
          }
          {
#line 1503
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1504
          v += adjust;
#line 1505
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
          }
#line 1502
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1501
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1509
      j = res->y0;
      {
#line 1509
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1509
        if (! (j < res->y1)) {
#line 1509
          goto while_break___6;
        }
#line 1510
        i = res->x0;
        {
#line 1510
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1510
          if (! (i < res->x1)) {
#line 1510
            goto while_break___7;
          }
          {
#line 1511
          tmp___2 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1512
          __cil_tmp61 = lrintf(tmp___2);
#line 1512
          v___0 = (int )__cil_tmp61;
#line 1513
          v___0 += adjust;
#line 1514
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
          }
#line 1510
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1509
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1518
    free(tilec___1->data);
    }
#line 1477
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1521
  __cil_tmp63 = opj_clock();
#line 1521
  tile_time = __cil_tmp63 - tile_time;
#line 1522
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1524
  if (eof) {
#line 1525
    return (0);
  }
#line 1528
  return (1);
}
}
#line 1531 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;
  int i ;
  int __cil_tmp4 ;

  {
#line 1532
  tcd_image = tcd->tcd_image;
#line 1533
  i = 0;
#line 1534
  i = 0;
  {
#line 1534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1534
    if (! (i < tcd_image->tw * tcd_image->th)) {
#line 1534
      goto while_break;
    }
    {
#line 1536
    tcd_free_decode_tile(tcd, i);
    }
#line 1534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1539
  free(tcd_image->tiles);
  }
  return;
}
}
#line 1542 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1545
  tcd_image = tcd->tcd_image;
#line 1547
  tile = tcd_image->tiles + tileno;
#line 1548
  if (tile->comps != (void *)0) {
#line 1549
    compno = 0;
    {
#line 1549
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1549
      if (! (compno < tile->numcomps)) {
#line 1549
        goto while_break;
      }
#line 1550
      tilec = tile->comps + compno;
#line 1551
      resno = 0;
      {
#line 1551
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1551
        if (! (resno < tilec->numresolutions)) {
#line 1551
          goto while_break___0;
        }
#line 1552
        res = tilec->resolutions + resno;
#line 1553
        bandno = 0;
        {
#line 1553
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1553
          if (! (bandno < res->numbands)) {
#line 1553
            goto while_break___1;
          }
#line 1554
          band = & res->bands[bandno];
#line 1555
          precno = 0;
          {
#line 1555
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1555
            if (! (precno < res->ph * res->pw)) {
#line 1555
              goto while_break___2;
            }
#line 1556
            prec = band->precincts + precno;
#line 1557
            if (prec->cblks.dec != (void *)0) {
#line 1558
              cblkno = 0;
              {
#line 1558
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1558
                if (! (cblkno < prec->cw * prec->ch)) {
#line 1558
                  goto while_break___3;
                }
                {
#line 1559
                cblk = prec->cblks.dec + cblkno;
#line 1560
                free(cblk->data);
#line 1561
                free(cblk->segs);
                }
#line 1558
                cblkno ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 1563
              free(prec->cblks.dec);
              }
            }
#line 1565
            if (prec->imsbtree != (void *)0) {
              {
#line 1565
              tgt_destroy(prec->imsbtree);
              }
            }
#line 1566
            if (prec->incltree != (void *)0) {
              {
#line 1566
              tgt_destroy(prec->incltree);
              }
            }
#line 1555
            precno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1570
          free(band->precincts);
          }
#line 1553
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1551
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1573
      free(tilec->resolutions);
      }
#line 1549
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1575
    free(tile->comps);
#line 1576
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
  }
  return;
}
}
#line 54 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 174 "/usr/include/time.h"
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 192 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 791 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 329 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 142 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 47 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 55
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 56
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 65
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 72
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 74
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) ;
#line 75
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 82
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 90
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 97
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) ;
#line 106
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 116
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 126
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 137
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) ;
#line 144
static void write_iptr(int offset , int length , opj_cio_t *cio ) ;
#line 153
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) ;
#line 160 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 161
  box->init_pos = cio_tell(cio);
#line 162
  __cil_tmp5 = cio_read(cio, 4);
#line 162
  box->length = (int )__cil_tmp5;
#line 163
  __cil_tmp6 = cio_read(cio, 4);
#line 163
  box->type = (int )__cil_tmp6;
  }
#line 164
  if (box->length == 1) {
    {
#line 165
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 165
    if (__cil_tmp7 != 0U) {
      {
#line 166
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 167
      return (0);
    }
    {
#line 169
    __cil_tmp8 = cio_read(cio, 4);
#line 169
    box->length = (int )__cil_tmp8;
    }
#line 170
    if (box->length == 0) {
      {
#line 171
      __cil_tmp9 = cio_numbytesleft(cio);
#line 171
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 173
  if (box->length == 0) {
    {
#line 174
    __cil_tmp10 = cio_numbytesleft(cio);
#line 174
    box->length = __cil_tmp10 + 8;
    }
  }
#line 176
  if (box->length < 0) {
    {
#line 177
    opj_event_msg(cinfo, 1, "Integer overflow in box->length\n\220");
    }
#line 178
    return (0);
  }
#line 181
  return (1);
}
}
#line 208 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 211
  cinfo = jp2->cinfo;
#line 213
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 213
  if (__cil_tmp5 == 0) {
    {
#line 214
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 215
    return (0);
  }
#line 217
  if (1768449138 != box.type) {
    {
#line 218
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 219
    return (0);
  }
  {
#line 222
  jp2->h = cio_read(cio, 4);
#line 223
  jp2->w = cio_read(cio, 4);
#line 224
  jp2->numcomps = cio_read(cio, 2);
#line 225
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 225
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
#line 227
  jp2->bpc = cio_read(cio, 1);
#line 229
  jp2->C = cio_read(cio, 1);
#line 230
  jp2->UnkC = cio_read(cio, 1);
#line 231
  jp2->IPR = cio_read(cio, 1);
#line 233
  __cil_tmp14 = cio_tell(cio);
  }
#line 233
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 234
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n");
    }
#line 235
    return (0);
  }
#line 238
  return (1);
}
}
#line 241 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 244
  box.init_pos = cio_tell(cio);
#line 245
  cio_skip(cio, 4);
#line 246
  cio_write(cio, (unsigned long long )1768449138, 4);
#line 248
  cio_write(cio, (unsigned long long )jp2->h, 4);
#line 249
  cio_write(cio, (unsigned long long )jp2->w, 4);
#line 250
  cio_write(cio, (unsigned long long )jp2->numcomps, 2);
#line 252
  cio_write(cio, (unsigned long long )jp2->bpc, 1);
#line 254
  cio_write(cio, (unsigned long long )jp2->C, 1);
#line 255
  cio_write(cio, (unsigned long long )jp2->UnkC, 1);
#line 256
  cio_write(cio, (unsigned long long )jp2->IPR, 1);
#line 258
  __cil_tmp5 = cio_tell(cio);
#line 258
  box.length = __cil_tmp5 - box.init_pos;
#line 259
  cio_seek(cio, box.init_pos);
#line 260
  cio_write(cio, (unsigned long long )box.length, 4);
#line 261
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 264 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 268
  box.init_pos = cio_tell(cio);
#line 269
  cio_skip(cio, 4);
#line 270
  cio_write(cio, (unsigned long long )1651532643, 4);
#line 272
  i = (unsigned int )0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < jp2->numcomps)) {
#line 272
      goto while_break;
    }
    {
#line 273
    cio_write(cio, (unsigned long long )(jp2->comps + i)->bpcc, 1);
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  __cil_tmp7 = cio_tell(cio);
#line 276
  box.length = __cil_tmp7 - box.init_pos;
#line 277
  cio_seek(cio, box.init_pos);
#line 278
  cio_write(cio, (unsigned long long )box.length, 4);
#line 279
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 283 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 287
  cinfo = jp2->cinfo;
#line 289
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 289
  if (__cil_tmp6 == 0) {
    {
#line 290
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 291
    return (0);
  }
#line 293
  if (1651532643 != box.type) {
    {
#line 294
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\nV");
    }
#line 295
    return (0);
  }
#line 298
  i = (unsigned int )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < jp2->numcomps)) {
#line 298
      goto while_break;
    }
    {
#line 299
    __cil_tmp7 = cio_read(cio, 1);
#line 299
    (jp2->comps + i)->bpcc = (int )__cil_tmp7;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  __cil_tmp9 = cio_tell(cio);
  }
#line 302
  if (__cil_tmp9 - box.init_pos != box.length) {
    {
#line 303
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 304
    return (0);
  }
#line 307
  return (1);
}
}
#line 310 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 313
  box.init_pos = cio_tell(cio);
#line 314
  cio_skip(cio, 4);
#line 315
  cio_write(cio, (unsigned long long )1668246642, 4);
#line 317
  cio_write(cio, (unsigned long long )jp2->meth, 1);
#line 318
  cio_write(cio, (unsigned long long )jp2->precedence, 1);
#line 319
  cio_write(cio, (unsigned long long )jp2->approx, 1);
  }
#line 321
  if (jp2->meth == 2U) {
#line 322
    jp2->enumcs = (unsigned int )0;
  }
  {
#line 324
  cio_write(cio, (unsigned long long )jp2->enumcs, 4);
#line 326
  __cil_tmp5 = cio_tell(cio);
#line 326
  box.length = __cil_tmp5 - box.init_pos;
#line 327
  cio_seek(cio, box.init_pos);
#line 328
  cio_write(cio, (unsigned long long )box.length, 4);
#line 329
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 332 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 334
  free((color->jp2_pclr)->channel_sign);
#line 335
  free((color->jp2_pclr)->channel_size);
#line 336
  free((color->jp2_pclr)->entries);
  }
#line 338
  if ((color->jp2_pclr)->cmap) {
    {
#line 338
    free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 340
  free(color->jp2_pclr);
#line 340
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 343 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void free_color_data(opj_jp2_color_t *color ) 
{ 


  {
#line 345
  if (color->jp2_pclr) {
    {
#line 347
    jp2_free_pclr(color);
    }
  }
#line 349
  if (color->jp2_cdef) {
#line 351
    if ((color->jp2_cdef)->info) {
      {
#line 351
      free((color->jp2_cdef)->info);
      }
    }
    {
#line 352
    free(color->jp2_cdef);
    }
  }
#line 354
  if (color->icc_profile_buf) {
    {
#line 354
    free(color->icc_profile_buf);
    }
  }
  return;
}
}
#line 357 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  int *src ;
  int *dst ;
  unsigned int j ;
  unsigned int max ;
  unsigned short i ;
  unsigned short nr_channels ;
  unsigned short cmp ;
  unsigned short pcol ;
  int k ;
  int top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 368
  channel_size = (color->jp2_pclr)->channel_size;
#line 369
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 370
  entries = (color->jp2_pclr)->entries;
#line 371
  cmap = (color->jp2_pclr)->cmap;
#line 372
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 374
  old_comps = image->comps;
#line 375
  __cil_tmp20 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 375
  new_comps = (opj_image_comp_t *)__cil_tmp20;
#line 378
  i = (unsigned short )0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((int )i < (int )nr_channels)) {
#line 378
      goto while_break;
    }
#line 380
    pcol = (unsigned short )(cmap + i)->pcol;
#line 380
    cmp = (cmap + i)->cmp;
#line 382
    if ((int )pcol < (int )nr_channels) {
#line 383
      *(new_comps + pcol) = *(old_comps + cmp);
    } else {
      {
#line 386
      opj_event_msg(cinfo, 1, "Error with pcol value %d (max: %d). skipping\n", (int )pcol,
                    (int )nr_channels);
      }
#line 387
      goto while_continue;
    }
#line 390
    if ((int )(cmap + i)->mtyp == 0) {
#line 392
      (old_comps + cmp)->data = (int *)((void *)0);
#line 392
      goto while_continue;
    }
    {
#line 395
    __cil_tmp21 = malloc((unsigned long )((old_comps + cmp)->w * (old_comps + cmp)->h) * sizeof(int ));
#line 395
    (new_comps + pcol)->data = (int *)__cil_tmp21;
#line 397
    (new_comps + pcol)->prec = (int )*(channel_size + i);
#line 398
    (new_comps + pcol)->sgnd = (int )*(channel_sign + i);
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 402
  i = (unsigned short )0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 402
    if (! ((int )i < (int )nr_channels)) {
#line 402
      goto while_break___0;
    }
#line 405
    if ((int )(cmap + i)->mtyp == 0) {
#line 405
      goto while_continue___0;
    }
#line 408
    cmp = (cmap + i)->cmp;
#line 408
    pcol = (unsigned short )(cmap + i)->pcol;
#line 409
    src = (old_comps + cmp)->data;
#line 410
    dst = (new_comps + pcol)->data;
#line 411
    max = (unsigned int )((new_comps + pcol)->w * (new_comps + pcol)->h);
#line 413
    j = (unsigned int )0;
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 413
      if (! (j < max)) {
#line 413
        goto while_break___1;
      }
#line 416
      k = *(src + j);
#line 416
      if (k < 0) {
#line 416
        k = 0;
      } else
#line 416
      if (k > top_k) {
#line 416
        k = top_k;
      }
#line 418
      *(dst + j) = (int )*(entries + (k * (int )nr_channels + (int )pcol));
#line 413
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 402
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 421
  max = (unsigned int )image->numcomps;
#line 422
  i = (unsigned short )0;
  {
#line 422
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 422
    if (! ((unsigned int )i < max)) {
#line 422
      goto while_break___2;
    }
#line 424
    if ((old_comps + i)->data) {
      {
#line 424
      free((old_comps + i)->data);
      }
    }
#line 422
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 426
  free(old_comps);
#line 427
  image->comps = new_comps;
#line 428
  image->numcomps = (int )nr_channels;
#line 430
  jp2_free_pclr(color);
  }
  return;
}
}
#line 434 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  unsigned short nr_entries ;
  unsigned short nr_channels ;
  unsigned short i ;
  unsigned short j ;
  unsigned char uc ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;
  unsigned int *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 450
  if (color->jp2_pclr) {
#line 450
    return (0);
  }
  {
#line 452
  __cil_tmp14 = cio_read(cio, 2);
#line 452
  nr_entries = (unsigned short )__cil_tmp14;
#line 453
  __cil_tmp15 = cio_read(cio, 1);
#line 453
  nr_channels = (unsigned short )__cil_tmp15;
#line 455
  __cil_tmp16 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(unsigned int ));
#line 455
  entries = (unsigned int *)__cil_tmp16;
#line 457
  __cil_tmp17 = malloc((unsigned long )nr_channels);
#line 457
  channel_size = (unsigned char *)__cil_tmp17;
#line 458
  __cil_tmp18 = malloc((unsigned long )nr_channels);
#line 458
  channel_sign = (unsigned char *)__cil_tmp18;
#line 460
  __cil_tmp19 = malloc(sizeof(opj_jp2_pclr_t ));
#line 460
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp19;
#line 461
  jp2_pclr->channel_sign = channel_sign;
#line 462
  jp2_pclr->channel_size = channel_size;
#line 463
  jp2_pclr->entries = entries;
#line 464
  jp2_pclr->nr_entries = nr_entries;
#line 465
  jp2_pclr->nr_channels = nr_channels;
#line 466
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 468
  color->jp2_pclr = jp2_pclr;
#line 470
  i = (unsigned short )0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! ((int )i < (int )nr_channels)) {
#line 470
      goto while_break;
    }
    {
#line 472
    __cil_tmp20 = cio_read(cio, 1);
#line 472
    uc = (unsigned char )__cil_tmp20;
#line 473
    *(channel_size + i) = (unsigned char )(((int )uc & 127) + 1);
    }
#line 474
    if ((int )uc & 128) {
#line 474
      tmp = 1;
    } else {
#line 474
      tmp = 0;
    }
#line 474
    *(channel_sign + i) = (unsigned char )tmp;
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  j = (unsigned short )0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! ((int )j < (int )nr_entries)) {
#line 477
      goto while_break___0;
    }
#line 479
    i = (unsigned short )0;
    {
#line 479
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 479
      if (! ((int )i < (int )nr_channels)) {
#line 479
        goto while_break___1;
      }
      {
#line 482
      __cil_tmp22 = entries;
#line 482
      entries ++;
#line 482
      *__cil_tmp22 = cio_read(cio, ((int )*(channel_size + i) + 7) >> 3);
      }
#line 479
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 477
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  return (1);
}
}
#line 489 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  unsigned short i ;
  unsigned short nr_channels ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 499
  if (color->jp2_pclr == (void *)0) {
#line 499
    return (0);
  }
#line 504
  if ((color->jp2_pclr)->cmap) {
#line 504
    return (0);
  }
  {
#line 506
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 507
  __cil_tmp8 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 507
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp8;
#line 510
  i = (unsigned short )0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int )i < (int )nr_channels)) {
#line 510
      goto while_break;
    }
    {
#line 512
    __cil_tmp9 = cio_read(cio, 2);
#line 512
    (cmap + i)->cmp = (unsigned short )__cil_tmp9;
#line 513
    __cil_tmp10 = cio_read(cio, 1);
#line 513
    (cmap + i)->mtyp = (unsigned char )__cil_tmp10;
#line 514
    __cil_tmp11 = cio_read(cio, 1);
#line 514
    (cmap + i)->pcol = (unsigned char )__cil_tmp11;
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  (color->jp2_pclr)->cmap = cmap;
#line 519
  return (1);
}
}
#line 522 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned short cn ;
  unsigned short typ ;
  unsigned short asoc ;
  unsigned short acn ;
  opj_image_comp_t saved ;

  {
#line 527
  info = (color->jp2_cdef)->info;
#line 528
  n = (color->jp2_cdef)->n;
#line 530
  i = (unsigned short )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((int )i < (int )n)) {
#line 530
      goto while_break;
    }
#line 533
    asoc = (info + i)->asoc;
#line 533
    if ((int )asoc == 0) {
#line 533
      goto while_continue;
    }
#line 535
    cn = (info + i)->cn;
#line 535
    typ = (info + i)->typ;
#line 535
    acn = (unsigned short )((int )asoc - 1);
#line 538
    if ((int )cn != (int )acn) {
      {
#line 542
      memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 543
      memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 544
      memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 546
      (info + i)->asoc = (unsigned short )((int )cn + 1);
#line 547
      (info + acn)->asoc = (unsigned short )((int )(info + acn)->cn + 1);
      }
    }
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  if ((color->jp2_cdef)->info) {
    {
#line 550
    free((color->jp2_cdef)->info);
    }
  }
  {
#line 552
  free(color->jp2_cdef);
#line 552
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 556 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_cdef(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 568
  if (color->jp2_cdef) {
#line 568
    return (0);
  }
  {
#line 570
  __cil_tmp8 = cio_read(cio, 2);
#line 570
  n = (unsigned short )__cil_tmp8;
  }
#line 570
  if ((int )n == 0) {
#line 570
    return (0);
  }
  {
#line 572
  __cil_tmp9 = malloc((unsigned long )n * sizeof(opj_jp2_cdef_info_t ));
#line 572
  info = (opj_jp2_cdef_info_t *)__cil_tmp9;
#line 575
  __cil_tmp10 = malloc(sizeof(opj_jp2_cdef_t ));
#line 575
  color->jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp10;
#line 576
  (color->jp2_cdef)->info = info;
#line 577
  (color->jp2_cdef)->n = n;
#line 579
  i = (unsigned short )0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! ((int )i < (int )n)) {
#line 579
      goto while_break;
    }
    {
#line 581
    __cil_tmp11 = cio_read(cio, 2);
#line 581
    (info + i)->cn = (unsigned short )__cil_tmp11;
#line 582
    __cil_tmp12 = cio_read(cio, 2);
#line 582
    (info + i)->typ = (unsigned short )__cil_tmp12;
#line 583
    __cil_tmp13 = cio_read(cio, 2);
#line 583
    (info + i)->asoc = (unsigned short )__cil_tmp13;
    }
#line 579
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return (1);
}
}
#line 589 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  int skip_len ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *start ;
  unsigned char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 598
  if (color->jp2_has_colr) {
#line 598
    return (0);
  }
  {
#line 600
  cinfo = jp2->cinfo;
#line 602
  jp2->meth = cio_read(cio, 1);
#line 603
  jp2->precedence = cio_read(cio, 1);
#line 604
  jp2->approx = cio_read(cio, 1);
  }
#line 606
  if (jp2->meth == 1U) {
    {
#line 608
    jp2->enumcs = cio_read(cio, 4);
    }
  } else
#line 611
  if (jp2->meth == 2U) {
    {
#line 614
    __cil_tmp11 = cio_tell(cio);
#line 614
    skip_len = (box->init_pos + box->length) - __cil_tmp11;
    }
#line 615
    if (skip_len < 0) {
      {
#line 617
      opj_event_msg(cinfo, 1, "Error with COLR box size\n#U\212TV");
      }
#line 618
      return (0);
    }
#line 620
    if (skip_len > 0) {
      {
#line 624
      start = cio_getbp(cio);
#line 625
      __cil_tmp14 = malloc((unsigned long )skip_len);
#line 625
      color->icc_profile_buf = (unsigned char *)__cil_tmp14;
#line 626
      color->icc_profile_len = skip_len;
#line 628
      __cil_tmp15 = cio_tell(cio);
#line 628
      cio_skip(cio, (box->init_pos + box->length) - __cil_tmp15);
#line 630
      memcpy(color->icc_profile_buf, start, (unsigned long )skip_len);
      }
    }
  }
  {
#line 634
  __cil_tmp16 = cio_tell(cio);
  }
#line 634
  if (__cil_tmp16 - box->init_pos != box->length) {
    {
#line 636
    opj_event_msg(cinfo, 1, "Error with COLR Box\n");
    }
#line 637
    return (0);
  }
#line 639
  color->jp2_has_colr = (unsigned char )1;
#line 641
  return (1);
}
}
#line 644 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_jp2_box_t box ;
  int jp2h_end ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  opj_bool __cil_tmp9 ;
  opj_bool __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_bool __cil_tmp13 ;
  opj_bool __cil_tmp14 ;
  opj_bool __cil_tmp15 ;
  opj_bool __cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_bool __cil_tmp18 ;
  opj_bool __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  opj_bool __cil_tmp21 ;

  {
  {
#line 649
  cinfo = jp2->cinfo;
#line 651
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 651
  if (__cil_tmp7 == 0) {
#line 651
    return (0);
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (1785737832 != box.type) {
#line 655
      if (box.type == 1785737827) {
        {
#line 657
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\nV");
        }
#line 658
        return (0);
      }
#line 660
      if (box.length <= 8) {
#line 660
        return (0);
      }
      {
#line 661
      cio_skip(cio, box.length - 8);
      }
#line 663
      if (cio->bp >= cio->end) {
#line 663
        return (0);
      }
      {
#line 665
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 665
      if (__cil_tmp8 == 0) {
#line 665
        return (0);
      }
    }
#line 652
    if (! (1785737832 != box.type)) {
#line 652
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  __cil_tmp9 = jp2_read_ihdr(jp2, cio);
  }
#line 669
  if (! __cil_tmp9) {
#line 670
    return (0);
  }
#line 671
  jp2h_end = box.init_pos + box.length;
#line 673
  if (jp2->bpc == 255U) {
    {
#line 675
    __cil_tmp10 = jp2_read_bpcc(jp2, cio);
    }
#line 675
    if (! __cil_tmp10) {
#line 676
      return (0);
    }
  }
  {
#line 678
  __cil_tmp11 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 678
  if (__cil_tmp11 == 0) {
#line 678
    return (0);
  }
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 680
    __cil_tmp12 = cio_tell(cio);
    }
#line 680
    if (! (__cil_tmp12 < jp2h_end)) {
#line 680
      goto while_break___0;
    }
#line 682
    if (box.type == 1668246642) {
      {
#line 684
      __cil_tmp13 = jp2_read_colr(jp2, cio, & box, color);
      }
#line 684
      if (! __cil_tmp13) {
#line 686
        if (box.length <= 8) {
#line 686
          return (0);
        }
        {
#line 687
        cio_seek(cio, box.init_pos + 8);
#line 688
        cio_skip(cio, box.length - 8);
        }
      }
      {
#line 690
      __cil_tmp14 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 690
      if (__cil_tmp14 == 0) {
#line 690
        return (0);
      }
#line 691
      goto while_continue___0;
    }
#line 693
    if (box.type == 1667523942) {
#line 693
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 695
        __cil_tmp15 = jp2_read_cdef(jp2, cio, & box, color);
        }
#line 695
        if (! __cil_tmp15) {
#line 697
          if (box.length <= 8) {
#line 697
            return (0);
          }
          {
#line 698
          cio_seek(cio, box.init_pos + 8);
#line 699
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 701
        __cil_tmp16 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 701
        if (__cil_tmp16 == 0) {
#line 701
          return (0);
        }
#line 702
        goto while_continue___0;
      }
    }
#line 704
    if (box.type == 1885564018) {
#line 704
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 706
        __cil_tmp17 = jp2_read_pclr(jp2, cio, & box, color);
        }
#line 706
        if (! __cil_tmp17) {
#line 708
          if (box.length <= 8) {
#line 708
            return (0);
          }
          {
#line 709
          cio_seek(cio, box.init_pos + 8);
#line 710
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 712
        __cil_tmp18 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 712
        if (__cil_tmp18 == 0) {
#line 712
          return (0);
        }
#line 713
        goto while_continue___0;
      }
    }
#line 715
    if (box.type == 1668112752) {
#line 715
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 717
        __cil_tmp19 = jp2_read_cmap(jp2, cio, & box, color);
        }
#line 717
        if (! __cil_tmp19) {
#line 719
          if (box.length <= 8) {
#line 719
            return (0);
          }
          {
#line 720
          cio_seek(cio, box.init_pos + 8);
#line 721
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 723
        __cil_tmp20 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 723
        if (__cil_tmp20 == 0) {
#line 723
          return (0);
        }
#line 724
        goto while_continue___0;
      }
    }
#line 726
    if (box.length <= 8) {
#line 726
      return (0);
    }
    {
#line 727
    cio_seek(cio, box.init_pos + 8);
#line 728
    cio_skip(cio, box.length - 8);
#line 729
    __cil_tmp21 = jp2_read_boxhdr(cinfo, cio, & box);
    }
#line 729
    if (__cil_tmp21 == 0) {
#line 729
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 733
  cio_seek(cio, jp2h_end);
  }
#line 736
  return ((int )color->jp2_has_colr == 1);
}
}
#line 740 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  opj_jp2_color_t color ;
  opj_bool __cil_tmp7 ;
  opj_image_t *__cil_tmp8 ;

  {
#line 744
  image = (opj_image_t *)((void *)0);
#line 747
  if (! jp2) {
#line 749
    return ((opj_image_t *)((void *)0));
  } else
#line 747
  if (! cio) {
#line 749
    return ((opj_image_t *)((void *)0));
  }
  {
#line 751
  memset(& color, 0, sizeof(opj_jp2_color_t ));
#line 752
  cinfo = jp2->cinfo;
#line 755
  __cil_tmp7 = jp2_read_struct(jp2, cio, & color);
  }
#line 755
  if (! __cil_tmp7) {
    {
#line 757
    free_color_data(& color);
#line 758
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 759
    return ((opj_image_t *)((void *)0));
  }
  {
#line 763
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 765
  if (! image) {
    {
#line 767
    free_color_data(& color);
#line 768
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 769
    return ((opj_image_t *)((void *)0));
  }
#line 772
  if (! jp2->ignore_pclr_cmap_cdef) {
#line 775
    if (jp2->enumcs == 16U) {
#line 776
      image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 777
    if (jp2->enumcs == 17U) {
#line 778
      image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 779
    if (jp2->enumcs == 18U) {
#line 780
      image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 782
      image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 784
    if (color.jp2_cdef) {
      {
#line 786
      jp2_apply_cdef(image, & color);
      }
    }
#line 788
    if (color.jp2_pclr) {
#line 791
      if (! (color.jp2_pclr)->cmap) {
        {
#line 792
        jp2_free_pclr(& color);
        }
      } else {
        {
#line 794
        jp2_apply_pclr(& color, image, cinfo);
        }
      }
    }
#line 796
    if (color.icc_profile_buf) {
#line 798
      image->icc_profile_buf = color.icc_profile_buf;
#line 799
      color.icc_profile_buf = (unsigned char *)((void *)0);
#line 800
      image->icc_profile_len = color.icc_profile_len;
    }
  }
#line 804
  return (image);
}
}
#line 809 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 812
  box.init_pos = cio_tell(cio);
#line 813
  cio_skip(cio, 4);
#line 814
  cio_write(cio, (unsigned long long )1785737832, 4);
#line 816
  jp2_write_ihdr(jp2, cio);
  }
#line 818
  if (jp2->bpc == 255U) {
    {
#line 819
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 821
  jp2_write_colr(jp2, cio);
#line 823
  __cil_tmp5 = cio_tell(cio);
#line 823
  box.length = __cil_tmp5 - box.init_pos;
#line 824
  cio_seek(cio, box.init_pos);
#line 825
  cio_write(cio, (unsigned long long )box.length, 4);
#line 826
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 829 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 833
  box.init_pos = cio_tell(cio);
#line 834
  cio_skip(cio, 4);
#line 835
  cio_write(cio, (unsigned long long )1718909296, 4);
#line 837
  cio_write(cio, (unsigned long long )jp2->brand, 4);
#line 838
  cio_write(cio, (unsigned long long )jp2->minversion, 4);
#line 840
  i = (unsigned int )0;
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 840
    if (! (i < jp2->numcl)) {
#line 840
      goto while_break;
    }
    {
#line 841
    cio_write(cio, (unsigned long long )*(jp2->cl + i), 4);
    }
#line 840
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 844
  __cil_tmp7 = cio_tell(cio);
#line 844
  box.length = __cil_tmp7 - box.init_pos;
#line 845
  cio_seek(cio, box.init_pos);
#line 846
  cio_write(cio, (unsigned long long )box.length, 4);
#line 847
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 850 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 854
  cinfo = jp2->cinfo;
#line 856
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 856
  if (__cil_tmp6 == 0) {
    {
#line 857
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 858
    return (0);
  }
#line 860
  if (1718909296 != box.type) {
    {
#line 861
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\nV");
    }
#line 862
    return (0);
  }
  {
#line 865
  jp2->brand = cio_read(cio, 4);
#line 866
  jp2->minversion = cio_read(cio, 4);
#line 867
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 868
  __cil_tmp9 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 868
  jp2->cl = (unsigned int *)__cil_tmp9;
#line 870
  i = 0;
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if (! (i < (int )jp2->numcl)) {
#line 870
      goto while_break;
    }
    {
#line 871
    *(jp2->cl + i) = cio_read(cio, 4);
    }
#line 870
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 874
  __cil_tmp12 = cio_tell(cio);
  }
#line 874
  if (__cil_tmp12 - box.init_pos != box.length) {
    {
#line 875
    opj_event_msg(cinfo, 1, "Error with FTYP Box\nTV");
    }
#line 876
    return (0);
  }
#line 879
  return (1);
}
}
#line 882 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 886
  j2k = jp2->j2k;
#line 888
  box.init_pos = cio_tell(cio);
#line 889
  cio_skip(cio, 4);
#line 890
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 893
  __cil_tmp10 = cio_tell(cio);
#line 893
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 894
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 894
  if (! __cil_tmp11) {
    {
#line 895
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 896
    return (0);
  }
  {
#line 898
  __cil_tmp12 = cio_tell(cio);
#line 898
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 900
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 901
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 903
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 904
  cio_seek(cio, box.init_pos);
#line 905
  cio_write(cio, (unsigned long long )box.length, 4);
#line 906
  cio_seek(cio, box.init_pos + box.length);
  }
#line 908
  return (box.length);
}
}
#line 911 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 914
  cinfo = jp2->cinfo;
#line 916
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 916
  if (__cil_tmp7 == 0) {
    {
#line 917
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 918
    return (0);
  }
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 921
    if (1785737827 != box.type) {
#line 922
      if (box.length <= 8) {
#line 922
        return (0);
      }
      {
#line 923
      cio_skip(cio, box.length - 8);
#line 924
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 924
      if (__cil_tmp8 == 0) {
#line 924
        return (0);
      }
    }
#line 920
    if (! (1785737827 != box.type)) {
#line 920
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 928
  __cil_tmp9 = cio_tell(cio);
#line 928
  *j2k_codestream_offset = (unsigned int )__cil_tmp9;
  }
#line 929
  if (box.length <= 8) {
#line 929
    return (0);
  }
#line 930
  *j2k_codestream_length = (unsigned int )(box.length - 8);
#line 932
  return (1);
}
}
#line 935 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 938
  box.init_pos = cio_tell(cio);
#line 939
  cio_skip(cio, 4);
#line 940
  cio_write(cio, (unsigned long long )1783636000, 4);
#line 941
  cio_write(cio, (unsigned long long )218793738, 4);
#line 943
  __cil_tmp4 = cio_tell(cio);
#line 943
  box.length = __cil_tmp4 - box.init_pos;
#line 944
  cio_seek(cio, box.init_pos);
#line 945
  cio_write(cio, (unsigned long long )box.length, 4);
#line 946
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 949 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 952
  cinfo = jp2->cinfo;
#line 954
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 954
  if (__cil_tmp5 == 0) {
    {
#line 955
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 956
    return (0);
  }
#line 958
  if (1783636000 != box.type) {
    {
#line 959
    opj_event_msg(cinfo, 1, "Expected JP Marker\n");
    }
#line 960
    return (0);
  }
  {
#line 962
  __cil_tmp6 = cio_read(cio, 4);
  }
#line 962
  if (218793738U != __cil_tmp6) {
    {
#line 963
    opj_event_msg(cinfo, 1, "Error with JP Marker\n");
    }
#line 964
    return (0);
  }
  {
#line 966
  __cil_tmp7 = cio_tell(cio);
  }
#line 966
  if (__cil_tmp7 - box.init_pos != box.length) {
    {
#line 967
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 968
    return (0);
  }
#line 971
  return (1);
}
}
#line 975 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;
  opj_bool __cil_tmp7 ;

  {
  {
#line 977
  __cil_tmp4 = jp2_read_jp(jp2, cio);
  }
#line 977
  if (! __cil_tmp4) {
#line 978
    return (0);
  }
  {
#line 979
  __cil_tmp5 = jp2_read_ftyp(jp2, cio);
  }
#line 979
  if (! __cil_tmp5) {
#line 980
    return (0);
  }
  {
#line 981
  __cil_tmp6 = jp2_read_jp2h(jp2, cio, color);
  }
#line 981
  if (! __cil_tmp6) {
#line 982
    return (0);
  }
  {
#line 983
  __cil_tmp7 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 983
  if (! __cil_tmp7) {
#line 984
    return (0);
  }
#line 986
  return (1);
}
}
#line 990 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 994
  lenp = cio_tell(cio);
#line 995
  cio_skip(cio, 4);
#line 996
  cio_write(cio, (unsigned long long )1718183032, 4);
#line 998
  write_prxy(offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
#line 1000
  __cil_tmp9 = cio_tell(cio);
#line 1000
  len = __cil_tmp9 - lenp;
#line 1001
  cio_seek(cio, lenp);
#line 1002
  cio_write(cio, (unsigned long long )len, 4);
#line 1003
  cio_seek(cio, lenp + len);
  }
#line 1005
  return (len);
}
}
#line 1008 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1012
  lenp = cio_tell(cio);
#line 1013
  cio_skip(cio, 4);
#line 1014
  cio_write(cio, (unsigned long long )1886550137, 4);
#line 1016
  cio_write(cio, (unsigned long long )offset_jp2c, 8);
#line 1017
  cio_write(cio, (unsigned long long )length_jp2c, 4);
#line 1018
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 1020
  cio_write(cio, (unsigned long long )1, 1);
#line 1022
  cio_write(cio, (unsigned long long )offset_idx, 8);
#line 1023
  cio_write(cio, (unsigned long long )length_idx, 4);
#line 1024
  cio_write(cio, (unsigned long long )1667851384, 4);
#line 1026
  __cil_tmp9 = cio_tell(cio);
#line 1026
  len = __cil_tmp9 - lenp;
#line 1027
  cio_seek(cio, lenp);
#line 1028
  cio_write(cio, (unsigned long long )len, 4);
#line 1029
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1032 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
static void write_iptr(int offset , int length , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1036
  lenp = cio_tell(cio);
#line 1037
  cio_skip(cio, 4);
#line 1038
  cio_write(cio, (unsigned long long )1768977522, 4);
#line 1040
  cio_write(cio, (unsigned long long )offset, 8);
#line 1041
  cio_write(cio, (unsigned long long )length, 8);
#line 1043
  __cil_tmp7 = cio_tell(cio);
#line 1043
  len = __cil_tmp7 - lenp;
#line 1044
  cio_seek(cio, lenp);
#line 1045
  cio_write(cio, (unsigned long long )len, 4);
#line 1046
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1054 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1055
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 1055
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1056
  if (jp2) {
    {
#line 1057
    jp2->cinfo = cinfo;
#line 1059
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 1060
    if (jp2->j2k == (void *)0) {
      {
#line 1061
      jp2_destroy_decompress(jp2);
      }
#line 1062
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1065
  return (jp2);
}
}
#line 1068 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1069
  if (jp2) {
    {
#line 1071
    j2k_destroy_decompress(jp2->j2k);
    }
#line 1073
    if (jp2->comps) {
      {
#line 1074
      free(jp2->comps);
      }
    }
#line 1076
    if (jp2->cl) {
      {
#line 1077
      free(jp2->cl);
      }
    }
    {
#line 1079
    free(jp2);
    }
  }
  return;
}
}
#line 1083 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1085
  j2k_setup_decoder(jp2->j2k, parameters);
#line 1087
  jp2->ignore_pclr_cmap_cdef = (opj_bool )(parameters->flags & 1U);
  }
  return;
}
}
#line 1094 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1095
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 1095
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1096
  if (jp2) {
    {
#line 1097
    memset(jp2, 0, sizeof(opj_jp2_t ));
#line 1098
    jp2->cinfo = cinfo;
#line 1100
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 1101
    if (jp2->j2k == (void *)0) {
      {
#line 1102
      jp2_destroy_compress(jp2);
      }
#line 1103
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1106
  return (jp2);
}
}
#line 1109 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1110
  if (jp2) {
    {
#line 1112
    j2k_destroy_compress(jp2->j2k);
    }
#line 1114
    if (jp2->comps) {
      {
#line 1115
      free(jp2->comps);
      }
    }
#line 1117
    if (jp2->cl) {
      {
#line 1118
      free(jp2->cl);
      }
    }
    {
#line 1120
    free(jp2);
    }
  }
  return;
}
}
#line 1124 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1128
  if (! jp2) {
#line 1129
    return;
  } else
#line 1128
  if (! parameters) {
#line 1129
    return;
  } else
#line 1128
  if (! image) {
#line 1129
    return;
  }
#line 1135
  if (image->numcomps < 1) {
    {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1137
    return;
  } else
#line 1135
  if (image->numcomps > 16384) {
    {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1137
    return;
  }
  {
#line 1140
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 1147
  jp2->brand = (unsigned int )1785737760;
#line 1148
  jp2->minversion = (unsigned int )0;
#line 1149
  jp2->numcl = (unsigned int )1;
#line 1150
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 1150
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 1151
  *(jp2->cl + 0) = (unsigned int )1785737760;
#line 1155
  jp2->numcomps = (unsigned int )image->numcomps;
#line 1156
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1156
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 1157
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 1158
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 1160
  depth_0 = (image->comps + 0)->prec - 1;
#line 1161
  sign = (image->comps + 0)->sgnd;
#line 1162
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 1163
  i = 1;
  }
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (! (i < image->numcomps)) {
#line 1163
      goto while_break;
    }
#line 1164
    depth = (image->comps + i)->prec - 1;
#line 1165
    sign = (image->comps + i)->sgnd;
#line 1166
    if (depth_0 != depth) {
#line 1167
      jp2->bpc = (unsigned int )255;
    }
#line 1163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  jp2->C = (unsigned int )7;
#line 1170
  jp2->UnkC = (unsigned int )0;
#line 1171
  jp2->IPR = (unsigned int )0;
#line 1175
  i = 0;
  {
#line 1175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1175
    if (! (i < image->numcomps)) {
#line 1175
      goto while_break___0;
    }
#line 1176
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 1175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1178
  jp2->meth = (unsigned int )1;
#line 1179
  if ((int )image->color_space == 1) {
#line 1180
    jp2->enumcs = (unsigned int )16;
  } else
#line 1181
  if ((int )image->color_space == 2) {
#line 1182
    jp2->enumcs = (unsigned int )17;
  } else
#line 1183
  if ((int )image->color_space == 3) {
#line 1184
    jp2->enumcs = (unsigned int )18;
  }
#line 1185
  jp2->precedence = (unsigned int )0;
#line 1186
  jp2->approx = (unsigned int )0;
#line 1188
  jp2->jpip_on = parameters->jpip_on;
  return;
}
}
#line 1191 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/jp2.c"
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int pos_iptr ;
  int pos_cidx ;
  int pos_jp2c ;
  int len_jp2c ;
  int len_cidx ;
  int end_pos ;
  int pos_fidx ;
  int len_fidx ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1194
  pos_iptr = - 1;
#line 1194
  pos_jp2c = pos_iptr;
#line 1199
  jp2_write_jp(cio);
#line 1201
  jp2_write_ftyp(jp2, cio);
#line 1203
  jp2_write_jp2h(jp2, cio);
  }
#line 1205
  if (jp2->jpip_on) {
    {
#line 1206
    pos_iptr = cio_tell(cio);
#line 1207
    cio_skip(cio, 24);
#line 1209
    pos_jp2c = cio_tell(cio);
    }
  }
  {
#line 1213
  len_jp2c = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 1213
  if (! len_jp2c) {
    {
#line 1214
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 1215
    return (0);
  }
#line 1218
  if (jp2->jpip_on) {
    {
#line 1219
    pos_cidx = cio_tell(cio);
#line 1221
    len_cidx = write_cidx(pos_jp2c + 8, cio, image, *cstr_info, len_jp2c - 8);
#line 1223
    pos_fidx = cio_tell(cio);
#line 1224
    len_fidx = write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
#line 1226
    end_pos = cio_tell(cio);
#line 1228
    cio_seek(cio, pos_iptr);
#line 1229
    write_iptr(pos_fidx, len_fidx, cio);
#line 1231
    cio_seek(cio, end_pos);
    }
  }
#line 1234
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 36 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 46 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 51
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 56
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 61
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 66
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 71
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 77
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 83
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 88
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 93
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 99
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 104
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 110
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 117
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 122
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 127
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 133
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 138
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 143
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 148
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 153
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 158
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 163
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 168
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 173
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 178
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 183
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 188
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 193
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 199
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 204
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 211
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 216
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 221
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 226
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 231
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 239
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 248
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 260 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 269 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 271
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((int )po->enum_prog != -1)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )po->enum_prog == (int )prg_order) {
#line 273
      goto while_break;
    }
#line 271
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return ((char *)po->str_prog);
}
}
#line 280 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 283
  tpnum = 1;
  {
#line 283
  tpend = 0;
#line 284
  tcp = cp->tcps + tileno;
#line 285
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 287
  if ((int )cp->tp_on == 1) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < 4)) {
#line 288
        goto while_break;
      }
#line 289
      if (tpend != 1) {
#line 290
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 291
          tpend = 1;
#line 291
          cp->tp_pos = i;
        }
        {
#line 294
        if ((int )*(prog + i) == 'C') {
#line 294
          goto case_67;
        }
#line 297
        if ((int )*(prog + i) == 'R') {
#line 297
          goto case_82;
        }
#line 300
        if ((int )*(prog + i) == 'P') {
#line 300
          goto case_80;
        }
#line 303
        if ((int )*(prog + i) == 'L') {
#line 303
          goto case_76;
        }
#line 293
        goto switch_break;
        case_67: /* CIL Label */ 
#line 295
        tpnum *= tcp->pocs[pino].compE;
#line 296
        goto switch_break;
        case_82: /* CIL Label */ 
#line 298
        tpnum *= tcp->pocs[pino].resE;
#line 299
        goto switch_break;
        case_80: /* CIL Label */ 
#line 301
        tpnum *= tcp->pocs[pino].prcE;
#line 302
        goto switch_break;
        case_76: /* CIL Label */ 
#line 304
        tpnum *= tcp->pocs[pino].layE;
#line 305
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 288
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 310
    tpnum = 1;
  }
#line 312
  return (tpnum);
}
}
#line 316 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 317
  totnum_tp = 0;
#line 321
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 321
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 322
  tileno = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (tileno < cp->tw * cp->th)) {
#line 322
      goto while_break;
    }
#line 323
    cur_totnum_tp = 0;
#line 324
    tcp = cp->tcps + tileno;
#line 325
    pino = 0;
    {
#line 325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 325
      if (! (pino <= tcp->numpocs)) {
#line 325
        goto while_break___0;
      }
      {
#line 326
      tp_num = 0;
#line 327
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 327
      pi = __cil_tmp13;
      }
#line 328
      if (! pi) {
#line 328
        return (- 1);
      }
      {
#line 329
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 330
      totnum_tp += tp_num;
#line 331
      cur_totnum_tp += tp_num;
#line 332
      pi_destroy(pi, cp, tileno);
      }
#line 325
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 336
    if (j2k->cstr_info) {
      {
#line 337
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 338
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 338
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 322
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (totnum_tp);
}
}
#line 345 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;
  int __cil_tmp3 ;

  {
  {
#line 346
  cio = j2k->cio;
#line 347
  cio_write(cio, (unsigned long long )65359, 2);
  }
#line 349
  if (j2k->cstr_info) {
    {
#line 350
    __cil_tmp3 = cio_tell(cio);
#line 350
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65359, __cil_tmp3, 0);
    }
  }
  return;
}
}
#line 361 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 362
  j2k->state = 2;
#line 364
  if (j2k->cstr_info) {
    {
#line 365
    __cil_tmp2 = cio_tell(j2k->cio);
#line 365
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 366
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 366
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
  return;
}
}
#line 370 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 374
  cio = j2k->cio;
#line 375
  image = j2k->image;
#line 376
  cp = j2k->cp;
#line 378
  cio_write(cio, (unsigned long long )65361, 2);
#line 379
  lenp = cio_tell(cio);
#line 380
  cio_skip(cio, 2);
#line 381
  cio_write(cio, (unsigned long long )cp->rsiz, 2);
#line 382
  cio_write(cio, (unsigned long long )image->x1, 4);
#line 383
  cio_write(cio, (unsigned long long )image->y1, 4);
#line 384
  cio_write(cio, (unsigned long long )image->x0, 4);
#line 385
  cio_write(cio, (unsigned long long )image->y0, 4);
#line 386
  cio_write(cio, (unsigned long long )cp->tdx, 4);
#line 387
  cio_write(cio, (unsigned long long )cp->tdy, 4);
#line 388
  cio_write(cio, (unsigned long long )cp->tx0, 4);
#line 389
  cio_write(cio, (unsigned long long )cp->ty0, 4);
#line 390
  cio_write(cio, (unsigned long long )image->numcomps, 2);
#line 391
  i = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (i < image->numcomps)) {
#line 391
      goto while_break;
    }
    {
#line 392
    cio_write(cio, (unsigned long long )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 393
    cio_write(cio, (unsigned long long )(image->comps + i)->dx, 1);
#line 394
    cio_write(cio, (unsigned long long )(image->comps + i)->dy, 1);
    }
#line 391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  __cil_tmp10 = cio_tell(cio);
#line 396
  len = __cil_tmp10 - lenp;
#line 397
  cio_seek(cio, lenp);
#line 398
  cio_write(cio, (unsigned long long )len, 2);
#line 399
  cio_seek(cio, lenp + len);
  }
#line 401
  if (j2k->cstr_info) {
    {
#line 402
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65361, lenp, len);
    }
  }
  return;
}
}
#line 405 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  int tmp ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp34 ;

  {
  {
#line 408
  cio = j2k->cio;
#line 409
  image = j2k->image;
#line 410
  cp = j2k->cp;
#line 412
  __cil_tmp7 = cio_read(cio, 2);
#line 412
  len = (int )__cil_tmp7;
#line 413
  cio_read(cio, 2);
#line 414
  __cil_tmp8 = cio_read(cio, 4);
#line 414
  image->x1 = (int )__cil_tmp8;
#line 415
  __cil_tmp9 = cio_read(cio, 4);
#line 415
  image->y1 = (int )__cil_tmp9;
#line 416
  __cil_tmp10 = cio_read(cio, 4);
#line 416
  image->x0 = (int )__cil_tmp10;
#line 417
  __cil_tmp11 = cio_read(cio, 4);
#line 417
  image->y0 = (int )__cil_tmp11;
#line 418
  __cil_tmp12 = cio_read(cio, 4);
#line 418
  cp->tdx = (int )__cil_tmp12;
#line 419
  __cil_tmp13 = cio_read(cio, 4);
#line 419
  cp->tdy = (int )__cil_tmp13;
#line 420
  __cil_tmp14 = cio_read(cio, 4);
#line 420
  cp->tx0 = (int )__cil_tmp14;
#line 421
  __cil_tmp15 = cio_read(cio, 4);
#line 421
  cp->ty0 = (int )__cil_tmp15;
  }
#line 423
  if (image->x0 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->x1 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->y0 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->y1 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  }
  {
#line 430
  __cil_tmp16 = cio_read(cio, 2);
#line 430
  image->numcomps = (int )__cil_tmp16;
  }
#line 474
  if (! (cp->tdx * cp->tdy)) {
    {
#line 475
    opj_event_msg(j2k->cinfo, 1, "JPWL: invalid tile size (tdx: %d, tdy: %d)\n", cp->tdx,
                  cp->tdy);
    }
#line 476
    return;
  }
  {
#line 479
  __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 479
  image->comps = (opj_image_comp_t *)__cil_tmp17;
#line 480
  i = 0;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < image->numcomps)) {
#line 480
      goto while_break;
    }
    {
#line 482
    __cil_tmp19 = cio_read(cio, 1);
#line 482
    tmp = (int )__cil_tmp19;
#line 483
    (image->comps + i)->prec = (tmp & 127) + 1;
#line 484
    (image->comps + i)->sgnd = tmp >> 7;
#line 485
    __cil_tmp20 = cio_read(cio, 1);
#line 485
    (image->comps + i)->dx = (int )__cil_tmp20;
#line 486
    __cil_tmp21 = cio_read(cio, 1);
#line 486
    (image->comps + i)->dy = (int )__cil_tmp21;
    }
#line 518
    if (! ((image->comps + i)->dx * (image->comps + i)->dy)) {
      {
#line 519
      opj_event_msg(j2k->cinfo, 1, "JPWL: invalid component size (dx: %d, dy: %d)\n",
                    (image->comps + i)->dx, (image->comps + i)->dy);
      }
#line 520
      return;
    }
#line 523
    (image->comps + i)->resno_decoded = 0;
#line 524
    (image->comps + i)->factor = cp->reduce;
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 527
  cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 528
  cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
#line 570
  __cil_tmp25 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 570
  cp->tcps = (opj_tcp_t *)__cil_tmp25;
  }
#line 571
  if (cp->tcps == (void *)0) {
    {
#line 573
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 574
    return;
  }
  {
#line 576
  __cil_tmp26 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 576
  cp->tileno = (int *)__cil_tmp26;
  }
#line 577
  if (cp->tileno == (void *)0) {
    {
#line 579
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 580
    return;
  }
#line 582
  cp->tileno_size = 0;
#line 597
  i = 0;
  {
#line 597
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 597
    if (! (i < cp->tw * cp->th)) {
#line 597
      goto while_break___0;
    }
#line 598
    (cp->tcps + i)->POC = 0;
#line 599
    (cp->tcps + i)->numpocs = 0;
#line 600
    (cp->tcps + i)->first = 1;
#line 597
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 604
  cp->ppm = 0;
#line 605
  cp->ppm_data = (unsigned char *)((void *)0);
#line 606
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 607
  cp->ppm_previous = 0;
#line 608
  cp->ppm_store = 0;
#line 610
  __cil_tmp28 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 610
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp28;
#line 611
  i = 0;
  }
  {
#line 611
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 611
    if (! (i < cp->tw * cp->th)) {
#line 611
      goto while_break___1;
    }
    {
#line 612
    __cil_tmp29 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 612
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp29;
    }
#line 611
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 614
  __cil_tmp31 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 614
  j2k->tile_data = (unsigned char **)__cil_tmp31;
#line 615
  __cil_tmp32 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 615
  j2k->tile_len = (int *)__cil_tmp32;
#line 616
  j2k->state = 4;
  }
#line 619
  if (j2k->cstr_info) {
    {
#line 620
    cstr_info = j2k->cstr_info;
#line 621
    cstr_info->image_w = image->x1 - image->x0;
#line 622
    cstr_info->image_h = image->y1 - image->y0;
#line 623
    cstr_info->numcomps = image->numcomps;
#line 624
    cstr_info->tw = cp->tw;
#line 625
    cstr_info->th = cp->th;
#line 626
    cstr_info->tile_x = cp->tdx;
#line 627
    cstr_info->tile_y = cp->tdy;
#line 628
    cstr_info->tile_Ox = cp->tx0;
#line 629
    cstr_info->tile_Oy = cp->ty0;
#line 630
    __cil_tmp34 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 630
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp34;
    }
  }
  return;
}
}
#line 634 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 638
  if ((j2k->cp)->comment) {
    {
#line 639
    cio = j2k->cio;
#line 640
    comment = (j2k->cp)->comment;
#line 642
    cio_write(cio, (unsigned long long )65380, 2);
#line 643
    lenp = cio_tell(cio);
#line 644
    cio_skip(cio, 2);
#line 645
    cio_write(cio, (unsigned long long )1, 2);
#line 646
    i = (unsigned int )0;
    }
    {
#line 646
    while (1) {
      while_continue: /* CIL Label */ ;
#line 646
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 646
        goto while_break;
      }
      {
#line 647
      cio_write(cio, (unsigned long long )*(comment + i), 1);
      }
#line 646
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 649
    __cil_tmp10 = cio_tell(cio);
#line 649
    len = __cil_tmp10 - lenp;
#line 650
    cio_seek(cio, lenp);
#line 651
    cio_write(cio, (unsigned long long )len, 2);
#line 652
    cio_seek(cio, lenp + len);
    }
#line 655
    if (j2k->cstr_info) {
      {
#line 656
      j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65380, lenp, len);
      }
    }
  }
  return;
}
}
#line 661 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 664
  cio = j2k->cio;
#line 666
  __cil_tmp4 = cio_read(cio, 2);
#line 666
  len = (int )__cil_tmp4;
#line 667
  cio_skip(cio, len - 2);
  }
  return;
}
}
#line 670 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 673
  cp = j2k->cp;
#line 674
  tcp = cp->tcps + j2k->curtileno;
#line 675
  tccp = tcp->tccps + compno;
#line 676
  cio = j2k->cio;
#line 678
  cio_write(cio, (unsigned long long )(tccp->numresolutions - 1), 1);
#line 679
  cio_write(cio, (unsigned long long )(tccp->cblkw - 2), 1);
#line 680
  cio_write(cio, (unsigned long long )(tccp->cblkh - 2), 1);
#line 681
  cio_write(cio, (unsigned long long )tccp->cblksty, 1);
#line 682
  cio_write(cio, (unsigned long long )tccp->qmfbid, 1);
  }
#line 684
  if (tccp->csty & 1) {
#line 685
    i = 0;
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
#line 685
      if (! (i < tccp->numresolutions)) {
#line 685
        goto while_break;
      }
      {
#line 686
      cio_write(cio, (unsigned long long )(tccp->prcw[i] + (tccp->prch[i] << 4)),
                1);
      }
#line 685
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 691 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 694
  cp = j2k->cp;
#line 695
  if (j2k->state == 16) {
#line 695
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 695
    tmp = j2k->default_tcp;
  }
  {
#line 695
  tcp = tmp;
#line 696
  tccp = tcp->tccps + compno;
#line 697
  cio = j2k->cio;
#line 699
  __cil_tmp9 = cio_read(cio, 1);
#line 699
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 702
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 703
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 705
    j2k->state |= 128;
    }
  }
#line 707
  if (tccp->numresolutions > 33) {
    {
#line 708
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
                  compno, tccp->numresolutions, 33);
#line 710
    j2k->state |= 128;
#line 711
    tccp->numresolutions = 33;
    }
  }
  {
#line 714
  __cil_tmp10 = cio_read(cio, 1);
#line 714
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 715
  __cil_tmp11 = cio_read(cio, 1);
#line 715
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 716
  __cil_tmp12 = cio_read(cio, 1);
#line 716
  tccp->cblksty = (int )__cil_tmp12;
#line 717
  __cil_tmp13 = cio_read(cio, 1);
#line 717
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 718
  if (tccp->csty & 1) {
#line 719
    i = 0;
    {
#line 719
    while (1) {
      while_continue: /* CIL Label */ ;
#line 719
      if (! (i < tccp->numresolutions)) {
#line 719
        goto while_break;
      }
      {
#line 720
      __cil_tmp15 = cio_read(cio, 1);
#line 720
      tmp___0 = (int )__cil_tmp15;
#line 721
      tccp->prcw[i] = tmp___0 & 15;
#line 722
      tccp->prch[i] = tmp___0 >> 4;
      }
#line 719
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 727
  if (j2k->cstr_info) {
#line 727
    if (compno == 0) {
#line 728
      i = 0;
      {
#line 728
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 728
        if (! (i < tccp->numresolutions)) {
#line 728
          goto while_break___0;
        }
#line 729
        if (tccp->csty & 1) {
#line 730
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 731
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 734
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 735
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 728
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 742 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 743
  cp = (opj_cp_t *)((void *)0);
#line 744
  tcp = (opj_tcp_t *)((void *)0);
#line 747
  cio = j2k->cio;
#line 749
  cio_write(cio, (unsigned long long )65362, 2);
#line 751
  lenp = cio_tell(cio);
#line 752
  cio_skip(cio, 2);
#line 754
  cp = j2k->cp;
#line 755
  tcp = cp->tcps + j2k->curtileno;
#line 757
  cio_write(cio, (unsigned long long )tcp->csty, 1);
#line 758
  cio_write(cio, (unsigned long long )tcp->prg, 1);
#line 759
  cio_write(cio, (unsigned long long )tcp->numlayers, 2);
#line 760
  cio_write(cio, (unsigned long long )tcp->mct, 1);
#line 762
  j2k_write_cox(j2k, 0);
#line 763
  __cil_tmp8 = cio_tell(cio);
#line 763
  len = __cil_tmp8 - lenp;
#line 764
  cio_seek(cio, lenp);
#line 765
  cio_write(cio, (unsigned long long )len, 2);
#line 766
  cio_seek(cio, lenp + len);
  }
#line 768
  if (j2k->cstr_info) {
    {
#line 769
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65362, lenp, len);
    }
  }
  return;
}
}
#line 773 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 776
  cio = j2k->cio;
#line 777
  cp = j2k->cp;
#line 778
  if (j2k->state == 16) {
#line 778
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 778
    tmp = j2k->default_tcp;
  }
  {
#line 778
  tcp = tmp;
#line 779
  image = j2k->image;
#line 781
  __cil_tmp10 = cio_read(cio, 2);
#line 781
  len = (int )__cil_tmp10;
#line 783
  __cil_tmp11 = cio_read(cio, 1);
#line 783
  tcp->csty = (int )__cil_tmp11;
#line 784
  __cil_tmp12 = cio_read(cio, 1);
#line 784
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 785
  __cil_tmp13 = cio_read(cio, 2);
#line 785
  tcp->numlayers = (int )__cil_tmp13;
#line 786
  __cil_tmp14 = cio_read(cio, 1);
#line 786
  tcp->mct = (int )__cil_tmp14;
#line 788
  pos = cio_tell(cio);
#line 789
  i = 0;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! (i < image->numcomps)) {
#line 789
      goto while_break;
    }
    {
#line 790
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 791
    cio_seek(cio, pos);
#line 792
    j2k_read_cox(j2k, i);
    }
#line 789
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  if (j2k->cstr_info) {
    {
#line 797
    cstr_info = j2k->cstr_info;
#line 798
    cstr_info->prog = tcp->prg;
#line 799
    cstr_info->numlayers = tcp->numlayers;
#line 800
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 800
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 801
    i = 0;
    }
    {
#line 801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 801
      if (! (i < image->numcomps)) {
#line 801
        goto while_break___0;
      }
#line 802
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 801
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 807 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 810
  cp = j2k->cp;
#line 811
  tcp = cp->tcps + j2k->curtileno;
#line 812
  image = j2k->image;
#line 813
  cio = j2k->cio;
#line 815
  cio_write(cio, (unsigned long long )65363, 2);
#line 816
  lenp = cio_tell(cio);
#line 817
  cio_skip(cio, 2);
  }
#line 818
  if (image->numcomps <= 256) {
#line 818
    tmp = 1;
  } else {
#line 818
    tmp = 2;
  }
  {
#line 818
  cio_write(cio, (unsigned long long )compno, tmp);
#line 819
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->csty, 1);
#line 820
  j2k_write_cox(j2k, compno);
#line 821
  __cil_tmp11 = cio_tell(cio);
#line 821
  len = __cil_tmp11 - lenp;
#line 822
  cio_seek(cio, lenp);
#line 823
  cio_write(cio, (unsigned long long )len, 2);
#line 824
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 827 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 830
  cp = j2k->cp;
#line 831
  if (j2k->state == 16) {
#line 831
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 831
    tmp = j2k->default_tcp;
  }
  {
#line 831
  tcp = tmp;
#line 832
  image = j2k->image;
#line 833
  cio = j2k->cio;
#line 835
  __cil_tmp9 = cio_read(cio, 2);
#line 835
  len = (int )__cil_tmp9;
  }
#line 837
  if (image->numcomps <= 256) {
#line 837
    tmp___0 = 1;
  } else {
#line 837
    tmp___0 = 2;
  }
  {
#line 837
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 837
  compno = (int )__cil_tmp11;
  }
#line 838
  if (compno >= image->numcomps) {
    {
#line 839
    opj_event_msg(j2k->cinfo, 1, "bad component number in COC (%d out of a maximum of %d)\n\230\001",
                  compno, image->numcomps);
    }
#line 842
    return;
  }
  {
#line 844
  __cil_tmp12 = cio_read(cio, 1);
#line 844
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 845
  j2k_read_cox(j2k, compno);
  }
  return;
}
}
#line 848 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 852
  cp = j2k->cp;
#line 853
  tcp = cp->tcps + j2k->curtileno;
#line 854
  tccp = tcp->tccps + compno;
#line 855
  cio = j2k->cio;
#line 857
  cio_write(cio, (unsigned long long )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 858
  if (tccp->qntsty == 1) {
#line 858
    tmp = 1;
  } else {
#line 858
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 858
  numbands = tmp;
#line 860
  bandno = 0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! (bandno < numbands)) {
#line 860
      goto while_break;
    }
#line 861
    expn = tccp->stepsizes[bandno].expn;
#line 862
    mant = tccp->stepsizes[bandno].mant;
#line 864
    if (tccp->qntsty == 0) {
      {
#line 865
      cio_write(cio, (unsigned long long )(expn << 3), 1);
      }
    } else {
      {
#line 867
      cio_write(cio, (unsigned long long )((expn << 11) + mant), 2);
      }
    }
#line 860
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 872 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___2 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___3 ;
  int tmp___4 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___5 ;
  int __cil_tmp21 ;

  {
#line 876
  cp = j2k->cp;
#line 877
  if (j2k->state == 16) {
#line 877
    tmp___2 = cp->tcps + j2k->curtileno;
  } else {
#line 877
    tmp___2 = j2k->default_tcp;
  }
  {
#line 877
  tcp = tmp___2;
#line 878
  tccp = tcp->tccps + compno;
#line 879
  cio = j2k->cio;
#line 881
  __cil_tmp12 = cio_read(cio, 1);
#line 881
  tmp = (int )__cil_tmp12;
#line 882
  tccp->qntsty = tmp & 31;
#line 883
  tccp->numgbits = tmp >> 5;
  }
#line 884
  if (tccp->qntsty == 1) {
#line 884
    tmp___4 = 1;
  } else {
#line 884
    if (tccp->qntsty == 0) {
#line 884
      tmp___3 = len - 1;
    } else {
#line 884
      tmp___3 = (len - 1) / 2;
    }
#line 884
    tmp___4 = tmp___3;
  }
#line 884
  numbands = tmp___4;
#line 910
  if (numbands < 0) {
    {
    {
#line 911
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
    }
  } else
#line 910
  if (numbands >= 97) {
    {
    {
#line 911
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
    }
  }
#line 918
  bandno = 0;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! (bandno < numbands)) {
#line 918
      goto while_break;
    }
#line 920
    if (tccp->qntsty == 0) {
      {
#line 921
      __cil_tmp17 = cio_read(cio, 1);
#line 921
      expn = (int )(__cil_tmp17 >> 3);
#line 922
      mant = 0;
      }
    } else {
      {
#line 924
      __cil_tmp18 = cio_read(cio, 2);
#line 924
      tmp = (int )__cil_tmp18;
#line 925
      expn = tmp >> 11;
#line 926
      mant = tmp & 2047;
      }
    }
#line 928
    if (bandno < 97) {
#line 929
      tccp->stepsizes[bandno].expn = expn;
#line 930
      tccp->stepsizes[bandno].mant = mant;
    }
#line 918
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  if (tccp->qntsty == 1) {
#line 936
    bandno = 1;
    {
#line 936
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 936
      if (! (bandno < 97)) {
#line 936
        goto while_break___0;
      }
#line 937
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 937
        tmp___5 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 937
        tmp___5 = 0;
      }
#line 937
      tccp->stepsizes[bandno].expn = tmp___5;
#line 940
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 936
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 946 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 949
  cio = j2k->cio;
#line 951
  cio_write(cio, (unsigned long long )65372, 2);
#line 952
  lenp = cio_tell(cio);
#line 953
  cio_skip(cio, 2);
#line 954
  j2k_write_qcx(j2k, 0);
#line 955
  __cil_tmp6 = cio_tell(cio);
#line 955
  len = __cil_tmp6 - lenp;
#line 956
  cio_seek(cio, lenp);
#line 957
  cio_write(cio, (unsigned long long )len, 2);
#line 958
  cio_seek(cio, lenp + len);
  }
#line 960
  if (j2k->cstr_info) {
    {
#line 961
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65372, lenp, len);
    }
  }
  return;
}
}
#line 964 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 967
  cio = j2k->cio;
#line 968
  image = j2k->image;
#line 970
  __cil_tmp7 = cio_read(cio, 2);
#line 970
  len = (int )__cil_tmp7;
#line 971
  pos = cio_tell(cio);
#line 972
  i = 0;
  }
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! (i < image->numcomps)) {
#line 972
      goto while_break;
    }
    {
#line 973
    cio_seek(cio, pos);
#line 974
    j2k_read_qcx(j2k, i, len - 2);
    }
#line 972
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 978 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 981
  cio = j2k->cio;
#line 983
  cio_write(cio, (unsigned long long )65373, 2);
#line 984
  lenp = cio_tell(cio);
#line 985
  cio_skip(cio, 2);
  }
#line 986
  if ((j2k->image)->numcomps <= 256) {
#line 986
    tmp = 1;
  } else {
#line 986
    tmp = 2;
  }
  {
#line 986
  cio_write(cio, (unsigned long long )compno, tmp);
#line 987
  j2k_write_qcx(j2k, compno);
#line 988
  __cil_tmp8 = cio_tell(cio);
#line 988
  len = __cil_tmp8 - lenp;
#line 989
  cio_seek(cio, lenp);
#line 990
  cio_write(cio, (unsigned long long )len, 2);
#line 991
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 994 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 996
  numcomp = (j2k->image)->numcomps;
#line 997
  cio = j2k->cio;
#line 999
  __cil_tmp6 = cio_read(cio, 2);
#line 999
  len = (int )__cil_tmp6;
  }
#line 1000
  if (numcomp <= 256) {
#line 1000
    tmp = 1;
  } else {
#line 1000
    tmp = 2;
  }
  {
#line 1000
  __cil_tmp8 = cio_read(cio, tmp);
#line 1000
  compno = (int )__cil_tmp8;
  }
#line 1028
  if (compno < 0) {
    {
    {
#line 1029
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1032
    return;
  } else
#line 1028
  if (compno >= numcomp) {
    {
    {
#line 1029
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1032
    return;
  }
#line 1035
  if (numcomp <= 256) {
#line 1035
    tmp___0 = 1;
  } else {
#line 1035
    tmp___0 = 2;
  }
  {
#line 1035
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
  return;
}
}
#line 1038 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1041
  numcomps = (j2k->image)->numcomps;
#line 1043
  cp = j2k->cp;
#line 1044
  tcp = cp->tcps + j2k->curtileno;
#line 1045
  tccp = tcp->tccps + 0;
#line 1046
  cio = j2k->cio;
#line 1048
  numpchgs = 1 + tcp->numpocs;
#line 1049
  cio_write(cio, (unsigned long long )65375, 2);
  }
#line 1050
  if (numcomps <= 256) {
#line 1050
    tmp = 1;
  } else {
#line 1050
    tmp = 2;
  }
  {
#line 1050
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1051
  cio_write(cio, (unsigned long long )len, 2);
#line 1052
  i = 0;
  }
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    if (! (i < numpchgs)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    poc = & tcp->pocs[i];
#line 1054
    cio_write(cio, (unsigned long long )poc->resno0, 1);
    }
#line 1055
    if (numcomps <= 256) {
#line 1055
      tmp___0 = 1;
    } else {
#line 1055
      tmp___0 = 2;
    }
    {
#line 1055
    cio_write(cio, (unsigned long long )poc->compno0, tmp___0);
#line 1056
    cio_write(cio, (unsigned long long )poc->layno1, 2);
#line 1057
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1058
    cio_write(cio, (unsigned long long )poc->resno1, 1);
#line 1059
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1060
    if (numcomps <= 256) {
#line 1060
      tmp___1 = 1;
    } else {
#line 1060
      tmp___1 = 2;
    }
    {
#line 1060
    cio_write(cio, (unsigned long long )poc->compno1, tmp___1);
#line 1061
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1062
    cio_write(cio, (unsigned long long )poc->prg, 1);
    }
#line 1052
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1066 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1069
  numcomps = (j2k->image)->numcomps;
#line 1071
  cp = j2k->cp;
#line 1072
  if (j2k->state == 16) {
#line 1072
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1072
    tmp = j2k->default_tcp;
  }
#line 1072
  tcp = tmp;
#line 1073
  cio = j2k->cio;
#line 1075
  if (tcp->POC) {
#line 1075
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1075
    tmp___0 = 0;
  }
  {
#line 1075
  old_poc = tmp___0;
#line 1076
  tcp->POC = 1;
#line 1077
  __cil_tmp12 = cio_read(cio, 2);
#line 1077
  len = (int )__cil_tmp12;
  }
#line 1078
  if (numcomps <= 256) {
#line 1078
    tmp___1 = 1;
  } else {
#line 1078
    tmp___1 = 2;
  }
#line 1078
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1080
  i = old_poc;
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1080
    if (! (i < numpchgs + old_poc)) {
#line 1080
      goto while_break;
    }
    {
#line 1082
    poc = & tcp->pocs[i];
#line 1083
    __cil_tmp15 = cio_read(cio, 1);
#line 1083
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1084
    if (numcomps <= 256) {
#line 1084
      tmp___2 = 1;
    } else {
#line 1084
      tmp___2 = 2;
    }
    {
#line 1084
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1084
    poc->compno0 = (int )__cil_tmp17;
#line 1085
    __cil_tmp18 = cio_read(cio, 2);
#line 1085
    poc->layno1 = (int )__cil_tmp18;
#line 1086
    __cil_tmp19 = cio_read(cio, 1);
#line 1086
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1087
    if (numcomps <= 256) {
#line 1087
      tmp___3 = 1;
    } else {
#line 1087
      tmp___3 = 2;
    }
    {
#line 1087
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1087
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1087
    poc->compno1 = __cil_tmp22;
#line 1089
    __cil_tmp23 = cio_read(cio, 1);
#line 1089
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
    }
#line 1080
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1092
  tcp->numpocs = (numpchgs + old_poc) - 1;
  return;
}
}
#line 1095 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1098
  cio = j2k->cio;
#line 1099
  numcomps = (j2k->image)->numcomps;
#line 1101
  __cil_tmp8 = cio_read(cio, 2);
#line 1101
  len = (int )__cil_tmp8;
#line 1103
  i = 0;
  }
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (! (i < numcomps)) {
#line 1103
      goto while_break;
    }
    {
#line 1104
    __cil_tmp9 = cio_read(cio, 2);
#line 1104
    Xcrg_i = (int )__cil_tmp9;
#line 1106
    __cil_tmp10 = cio_read(cio, 2);
#line 1106
    Ycrg_i = (int )__cil_tmp10;
    }
#line 1103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1111 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1115
  cio = j2k->cio;
#line 1117
  __cil_tmp12 = cio_read(cio, 2);
#line 1117
  len = (int )__cil_tmp12;
#line 1118
  __cil_tmp13 = cio_read(cio, 1);
#line 1118
  Ztlm = (int )__cil_tmp13;
#line 1120
  __cil_tmp14 = cio_read(cio, 1);
#line 1120
  Stlm = (int )__cil_tmp14;
#line 1121
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1122
  SP = (Stlm >> 6) & 1;
#line 1123
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1124
  i = 0;
  }
  {
#line 1124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1124
    if (! (i < tile_tlm)) {
#line 1124
      goto while_break;
    }
    {
#line 1125
    __cil_tmp15 = cio_read(cio, ST);
#line 1125
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1127
    if (SP) {
#line 1127
      tmp = 4;
    } else {
#line 1127
      tmp = 2;
    }
    {
#line 1127
    __cil_tmp17 = cio_read(cio, tmp);
#line 1127
    Ptlm_i = (long )__cil_tmp17;
    }
#line 1124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1132 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1133
  packet_len = 0;
#line 1135
  cio = j2k->cio;
#line 1137
  __cil_tmp9 = cio_read(cio, 2);
#line 1137
  len = (int )__cil_tmp9;
#line 1138
  __cil_tmp10 = cio_read(cio, 1);
#line 1138
  Zplm = (int )__cil_tmp10;
#line 1140
  len -= 3;
  }
  {
#line 1141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1141
    if (! (len > 0)) {
#line 1141
      goto while_break;
    }
    {
#line 1142
    __cil_tmp11 = cio_read(cio, 4);
#line 1142
    Nplm = (int )__cil_tmp11;
#line 1143
    len -= 4;
#line 1144
    i = Nplm;
    }
    {
#line 1144
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1144
      if (! (i > 0)) {
#line 1144
        goto while_break___0;
      }
      {
#line 1145
      __cil_tmp12 = cio_read(cio, 1);
#line 1145
      add = (int )__cil_tmp12;
#line 1146
      __cil_tmp13 = len;
#line 1146
      len --;
#line 1147
      packet_len = (packet_len << 7) + add;
      }
#line 1148
      if ((add & 128) == 0) {
#line 1150
        packet_len = 0;
      }
#line 1152
      if (len <= 0) {
#line 1153
        goto while_break___0;
      }
#line 1144
      __cil_tmp14 = i;
#line 1144
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1158 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1159
  packet_len = 0;
#line 1161
  cio = j2k->cio;
#line 1163
  __cil_tmp8 = cio_read(cio, 2);
#line 1163
  len = (int )__cil_tmp8;
#line 1164
  __cil_tmp9 = cio_read(cio, 1);
#line 1164
  Zplt = (int )__cil_tmp9;
#line 1166
  i = len - 3;
  }
  {
#line 1166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1166
    if (! (i > 0)) {
#line 1166
      goto while_break;
    }
    {
#line 1167
    __cil_tmp10 = cio_read(cio, 1);
#line 1167
    add = (int )__cil_tmp10;
#line 1168
    packet_len = (packet_len << 7) + add;
    }
#line 1169
    if ((add & 128) == 0) {
#line 1171
      packet_len = 0;
    }
#line 1166
    __cil_tmp11 = i;
#line 1166
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1176 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1180
  cp = j2k->cp;
#line 1181
  cio = j2k->cio;
#line 1183
  __cil_tmp9 = cio_read(cio, 2);
#line 1183
  len = (int )__cil_tmp9;
#line 1184
  cp->ppm = 1;
#line 1186
  __cil_tmp10 = cio_read(cio, 1);
#line 1186
  Z_ppm = (int )__cil_tmp10;
#line 1187
  len -= 3;
  }
  {
#line 1188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1188
    if (! (len > 0)) {
#line 1188
      goto while_break;
    }
#line 1189
    if (cp->ppm_previous == 0) {
      {
#line 1190
      __cil_tmp11 = cio_read(cio, 4);
#line 1190
      N_ppm = (int )__cil_tmp11;
#line 1191
      len -= 4;
      }
    } else {
#line 1193
      N_ppm = cp->ppm_previous;
    }
#line 1195
    j = cp->ppm_store;
#line 1196
    if (Z_ppm == 0) {
      {
#line 1197
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1197
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1198
      cp->ppm_data_first = cp->ppm_data;
#line 1199
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1201
      __cil_tmp13 = realloc(cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1201
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1219
      cp->ppm_data_first = cp->ppm_data;
#line 1220
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1222
    i = N_ppm;
    {
#line 1222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1222
      if (! (i > 0)) {
#line 1222
        goto while_break___0;
      }
      {
#line 1223
      __cil_tmp14 = cio_read(cio, 1);
#line 1223
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1224
      j ++;
#line 1225
      __cil_tmp16 = len;
#line 1225
      len --;
      }
#line 1226
      if (len == 0) {
#line 1227
        goto while_break___0;
      }
#line 1222
      __cil_tmp17 = i;
#line 1222
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1229
    cp->ppm_previous = i - 1;
#line 1230
    cp->ppm_store = j;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1234 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 1235
  j = 0;
#line 1237
  cp = j2k->cp;
#line 1238
  tcp = cp->tcps + j2k->curtileno;
#line 1239
  cio = j2k->cio;
#line 1241
  __cil_tmp9 = cio_read(cio, 2);
#line 1241
  len = (int )__cil_tmp9;
#line 1242
  __cil_tmp10 = cio_read(cio, 1);
#line 1242
  Z_ppt = (int )__cil_tmp10;
#line 1243
  tcp->ppt = 1;
  }
#line 1244
  if (Z_ppt == 0) {
    {
#line 1245
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1245
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1246
    tcp->ppt_data_first = tcp->ppt_data;
#line 1247
    tcp->ppt_store = 0;
#line 1248
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1250
    __cil_tmp12 = realloc(tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1250
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1251
    tcp->ppt_data_first = tcp->ppt_data;
#line 1252
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1254
  j = tcp->ppt_store;
#line 1255
  i = len - 3;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! (i > 0)) {
#line 1255
      goto while_break;
    }
    {
#line 1256
    __cil_tmp13 = cio_read(cio, 1);
#line 1256
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1257
    j ++;
    }
#line 1255
    __cil_tmp15 = i;
#line 1255
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  tcp->ppt_store = j;
  return;
}
}
#line 1262 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;
  int __cil_tmp4 ;

  {
  {
#line 1264
  cio = j2k->cio;
#line 1265
  j2k->tlm_start = cio_tell(cio);
#line 1266
  cio_write(cio, (unsigned long long )65365, 2);
#line 1267
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1268
  cio_write(cio, (unsigned long long )lenp, 2);
#line 1269
  cio_write(cio, (unsigned long long )0, 1);
#line 1270
  cio_write(cio, (unsigned long long )80, 1);
#line 1271
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
  return;
}
}
#line 1274 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1277
  cio = j2k->cio;
#line 1279
  j2k->sot_start = cio_tell(cio);
#line 1280
  cio_write(cio, (unsigned long long )65424, 2);
#line 1281
  lenp = cio_tell(cio);
#line 1282
  cio_skip(cio, 2);
#line 1283
  cio_write(cio, (unsigned long long )j2k->curtileno, 2);
#line 1284
  cio_skip(cio, 4);
#line 1285
  cio_write(cio, (unsigned long long )j2k->cur_tp_num, 1);
#line 1286
  cio_write(cio, (unsigned long long )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1287
  __cil_tmp7 = cio_tell(cio);
#line 1287
  len = __cil_tmp7 - lenp;
#line 1288
  cio_seek(cio, lenp);
#line 1289
  cio_write(cio, (unsigned long long )len, 2);
#line 1290
  cio_seek(cio, lenp + len);
  }
#line 1299
  if (j2k->cstr_info) {
#line 1299
    if (j2k->cur_tp_num == 0) {
      {
#line 1300
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65424, lenp,
                       len);
      }
    }
  }
  return;
}
}
#line 1304 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  opj_tccp_t *tmp___0 ;
  int __cil_tmp31 ;

  {
  {
#line 1306
  tcp = (opj_tcp_t *)((void *)0);
#line 1307
  status = (char )0;
#line 1309
  cp = j2k->cp;
#line 1310
  cio = j2k->cio;
#line 1312
  __cil_tmp12 = cio_read(cio, 2);
#line 1312
  len = (int )__cil_tmp12;
#line 1314
  __cil_tmp13 = cio_read(cio, 2);
#line 1314
  tileno = (int )__cil_tmp13;
  }
#line 1344
  if (tileno < 0) {
    {
    {
#line 1345
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1348
    return;
  } else
#line 1344
  if (tileno >= cp->tw * cp->th) {
    {
    {
#line 1345
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1348
    return;
  }
#line 1352
  if (cp->tileno_size == 0) {
#line 1353
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1354
    (cp->tileno_size) ++;
  } else {
#line 1356
    i = 0;
    {
#line 1357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1357
      if (! (i < cp->tileno_size && (int )status == 0)) {
#line 1357
        goto while_break;
      }
#line 1358
      if (*(cp->tileno + i) == tileno) {
#line 1358
        tmp = 1;
      } else {
#line 1358
        tmp = 0;
      }
#line 1358
      status = (char )tmp;
#line 1359
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1361
    if ((int )status == 0) {
#line 1362
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1363
      (cp->tileno_size) ++;
    }
  }
  {
#line 1367
  __cil_tmp18 = cio_read(cio, 4);
#line 1367
  totlen = (int )__cil_tmp18;
#line 1393
  __cil_tmp19 = cio_numbytesleft(cio);
  }
#line 1393
  if (totlen < 0) {
    {
    {
#line 1394
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1394
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1397
    return;
  } else
#line 1393
  if (totlen > __cil_tmp19 + 8) {
    {
    {
#line 1394
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1394
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1397
    return;
  }
#line 1401
  if (! totlen) {
    {
#line 1402
    __cil_tmp21 = cio_numbytesleft(cio);
#line 1402
    totlen = __cil_tmp21 + 8;
    }
  }
  {
#line 1404
  __cil_tmp22 = cio_read(cio, 1);
#line 1404
  partno = (int )__cil_tmp22;
#line 1405
  __cil_tmp23 = cio_read(cio, 1);
#line 1405
  numparts = (int )__cil_tmp23;
  }
#line 1407
  if (partno >= numparts) {
    {
#line 1408
    opj_event_msg(j2k->cinfo, 2, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n",
                  tileno, partno, numparts);
#line 1409
    numparts = partno + 1;
    }
  }
  {
#line 1412
  j2k->curtileno = tileno;
#line 1413
  j2k->cur_tp_num = partno;
#line 1414
  __cil_tmp24 = cio_getbp(cio);
#line 1414
  j2k->eot = (__cil_tmp24 - 12) + totlen;
#line 1415
  j2k->state = 16;
#line 1416
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1419
  if (j2k->cstr_info) {
#line 1420
    if (tcp->first) {
#line 1421
      if (tileno == 0) {
        {
#line 1422
        __cil_tmp25 = cio_tell(cio);
#line 1422
        (j2k->cstr_info)->main_head_end = __cil_tmp25 - 13;
        }
      }
      {
#line 1423
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1424
      __cil_tmp26 = cio_tell(cio);
#line 1424
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp26 - 12;
#line 1425
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
      }
    } else {
#line 1427
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
#line 1429
    ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
#line 1430
    if (numparts) {
      {
#line 1431
      __cil_tmp27 = realloc(((j2k->cstr_info)->tile + tileno)->tp, (unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1431
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp27;
      }
    } else {
      {
#line 1433
      __cil_tmp28 = realloc(((j2k->cstr_info)->tile + tileno)->tp, 10UL * sizeof(opj_tp_info_t ));
#line 1433
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp28;
      }
    }
    {
#line 1434
    __cil_tmp29 = cio_tell(cio);
#line 1434
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp29 - 12;
#line 1435
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1439
  if (tcp->first == 1) {
    {
#line 1441
    tmp___0 = tcp->tccps;
#line 1442
    memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1443
    tcp->ppt = 0;
#line 1444
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1445
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1446
    tcp->tccps = tmp___0;
#line 1448
    i = 0;
    }
    {
#line 1448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1448
      if (! (i < (j2k->image)->numcomps)) {
#line 1448
        goto while_break___0;
      }
#line 1449
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1448
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1451
    (cp->tcps + j2k->curtileno)->first = 0;
  }
  return;
}
}
#line 1455 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1458
  tcp = (opj_tcp_t *)((void *)0);
#line 1459
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1461
  tcd = (opj_tcd_t *)tile_coder;
#line 1462
  cp = j2k->cp;
#line 1463
  cio = j2k->cio;
#line 1465
  tcd->tp_num = j2k->tp_num;
#line 1466
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1468
  cio_write(cio, (unsigned long long )65427, 2);
  }
#line 1470
  if (j2k->cstr_info) {
#line 1470
    if (j2k->cur_tp_num == 0) {
      {
#line 1471
      __cil_tmp11 = cio_tell(cio);
#line 1471
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65427, __cil_tmp11,
                       0);
      }
    }
  }
#line 1474
  if (j2k->curtileno == 0) {
    {
#line 1475
    __cil_tmp12 = cio_tell(cio);
#line 1475
    j2k->sod_start = __cil_tmp12 + j2k->pos_correction;
    }
  }
#line 1479
  cstr_info = j2k->cstr_info;
#line 1480
  if (cstr_info) {
#line 1481
    if (! j2k->cur_tp_num) {
      {
#line 1482
      __cil_tmp13 = cio_tell(cio);
#line 1482
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp13 + j2k->pos_correction) - 1;
#line 1483
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1486
      __cil_tmp14 = cio_tell(cio);
      }
#line 1486
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp14) {
        {
#line 1487
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1498
  tcp = cp->tcps + j2k->curtileno;
#line 1499
  layno = 0;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (layno < tcp->numlayers)) {
#line 1499
      goto while_break;
    }
#line 1500
    if (tcp->rates[layno] > (float )(j2k->sod_start / (cp->th * cp->tw))) {
#line 1501
      tcp->rates[layno] -= (float )(j2k->sod_start / (cp->th * cp->tw));
    } else
#line 1502
    if (tcp->rates[layno]) {
#line 1503
      tcp->rates[layno] = (float )1;
    }
#line 1499
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1506
  if (j2k->cur_tp_num == 0) {
#line 1507
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1508
    if (cstr_info) {
#line 1509
      cstr_info->packno = 0;
    }
  }
  {
#line 1512
  __cil_tmp17 = cio_getbp(cio);
  }
  {
#line 1512
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1512
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1512
  l = __cil_tmp19;
#line 1515
  __cil_tmp20 = cio_tell(cio);
#line 1515
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1516
  cio_seek(cio, j2k->sot_start + 6);
#line 1517
  cio_write(cio, (unsigned long long )totlen, 4);
#line 1518
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1520
  if (cp->cinema) {
    {
#line 1521
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1522
    cio_write(cio, (unsigned long long )j2k->curtileno, 1);
#line 1523
    cio_write(cio, (unsigned long long )totlen, 4);
    }
  }
  {
#line 1525
  cio_seek(cio, j2k->sot_start + totlen);
  }
  return;
}
}
#line 1528 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1529
  truncate = 0;
#line 1530
  data = (unsigned char *)((void *)0);
#line 1530
  data_ptr = (unsigned char *)((void *)0);
#line 1532
  cio = j2k->cio;
#line 1533
  curtileno = j2k->curtileno;
#line 1536
  if (j2k->cstr_info) {
    {
#line 1537
    __cil_tmp9 = cio_tell(cio);
#line 1537
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1539
    if (j2k->cur_tp_num == 0) {
      {
#line 1540
      __cil_tmp10 = cio_tell(cio);
#line 1540
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1541
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1544
  __cil_tmp11 = cio_getbp(cio);
  }
  {
#line 1544
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1544
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1544
  len = __cil_tmp13;
#line 1546
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1546
  if (len == __cil_tmp14 + 1) {
#line 1547
    truncate = 1;
  }
  {
#line 1550
  data = *(j2k->tile_data + curtileno);
#line 1551
  __cil_tmp15 = realloc(data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1551
  data = (unsigned char *)__cil_tmp15;
#line 1553
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1554
  i = 0;
  }
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1554
    if (! (i < len)) {
#line 1554
      goto while_break;
    }
    {
#line 1555
    __cil_tmp16 = cio_read(cio, 1);
#line 1555
    *(data_ptr + i) = (unsigned char )__cil_tmp16;
    }
#line 1554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1558
  *(j2k->tile_len + curtileno) += len;
#line 1559
  *(j2k->tile_data + curtileno) = data;
#line 1561
  if (! truncate) {
#line 1562
    j2k->state = 8;
  } else {
#line 1564
    j2k->state = 64;
  }
#line 1566
  (j2k->cur_tp_num) ++;
  return;
}
}
#line 1569 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1570
  cp = j2k->cp;
#line 1571
  tcp = cp->tcps + tileno;
#line 1572
  cio = j2k->cio;
#line 1573
  numcomps = (j2k->image)->numcomps;
#line 1575
  cio_write(cio, (unsigned long long )65374, 2);
  }
#line 1576
  if (numcomps <= 256) {
#line 1576
    tmp = 5;
  } else {
#line 1576
    tmp = 6;
  }
  {
#line 1576
  cio_write(cio, (unsigned long long )tmp, 2);
  }
#line 1577
  if (numcomps <= 256) {
#line 1577
    tmp___0 = 1;
  } else {
#line 1577
    tmp___0 = 2;
  }
  {
#line 1577
  cio_write(cio, (unsigned long long )compno, tmp___0);
#line 1578
  cio_write(cio, (unsigned long long )0, 1);
#line 1579
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->roishift, 1);
  }
  return;
}
}
#line 1582 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1585
  cp = j2k->cp;
#line 1586
  if (j2k->state == 16) {
#line 1586
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1586
    tmp = j2k->default_tcp;
  }
  {
#line 1586
  tcp = tmp;
#line 1587
  cio = j2k->cio;
#line 1588
  numcomps = (j2k->image)->numcomps;
#line 1590
  __cil_tmp10 = cio_read(cio, 2);
#line 1590
  len = (int )__cil_tmp10;
  }
#line 1592
  if (numcomps <= 256) {
#line 1592
    tmp___0 = 1;
  } else {
#line 1592
    tmp___0 = 2;
  }
  {
#line 1592
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1592
  compno = (int )__cil_tmp12;
#line 1593
  __cil_tmp13 = cio_read(cio, 1);
#line 1593
  roisty = (int )__cil_tmp13;
  }
#line 1611
  if (compno >= numcomps) {
    {
#line 1612
    opj_event_msg(j2k->cinfo, 1, "bad component number in RGN (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
#line 1615
    return;
  }
  {
#line 1618
  __cil_tmp14 = cio_read(cio, 1);
#line 1618
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
  return;
}
}
#line 1621 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1622
  cio = j2k->cio;
#line 1624
  cio_write(cio, (unsigned long long )65497, 2);
  }
  return;
}
}
#line 1634 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_bool success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;
  opj_bool __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1636
  success = 0;
#line 1639
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1640
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1640
    tcd = __cil_tmp6;
#line 1641
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1642
    i = 0;
    }
    {
#line 1642
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1642
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1642
        goto while_break;
      }
      {
#line 1643
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
      }
#line 1644
      if (*((j2k->cp)->tileno + i) != -1) {
        {
#line 1646
        tileno = *((j2k->cp)->tileno + i);
#line 1647
        success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                  tileno, j2k->cstr_info);
#line 1648
        free(*(j2k->tile_data + tileno));
#line 1649
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1650
        tcd_free_decode_tile(tcd, i);
        }
      } else {
#line 1653
        success = 0;
      }
#line 1654
      if (success == 0) {
#line 1655
        j2k->state |= 128;
#line 1656
        goto while_break;
      }
#line 1642
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1659
    tcd_free_decode(tcd);
#line 1660
    tcd_destroy(tcd);
    }
  } else {
#line 1664
    i = 0;
    {
#line 1664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1664
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1664
        goto while_break___0;
      }
      {
#line 1665
      tileno = *((j2k->cp)->tileno + i);
#line 1666
      free(*(j2k->tile_data + tileno));
#line 1667
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
      }
#line 1664
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1670
  if (j2k->state & 128) {
#line 1671
    j2k->state = 160;
  } else {
#line 1673
    j2k->state = 32;
  }
  return;
}
}
#line 1685 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1685
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1720 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1721
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
  return;
}
}
#line 1786 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;
  opj_dec_mstabent_t *__cil_tmp3 ;

  {
#line 1788
  e = (opj_dec_mstabent_t *)j2k_dec_mstab;
  {
#line 1788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1788
    if (! (e->id != 0)) {
#line 1788
      goto while_break;
    }
#line 1789
    if (e->id == id) {
#line 1790
      goto while_break;
    }
#line 1788
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1793
  return (e);
}
}
#line 1800 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1801
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1801
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1802
  if (! j2k) {
#line 1803
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1805
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 1805
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1806
  if (! j2k->default_tcp) {
    {
#line 1807
    free(j2k);
    }
#line 1808
    return ((opj_j2k_t *)((void *)0));
  }
#line 1811
  j2k->cinfo = cinfo;
#line 1812
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1814
  return (j2k);
}
}
#line 1817 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  int __cil_tmp4 ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;
  int __cil_tmp7 ;

  {
#line 1818
  i = 0;
#line 1820
  if (j2k->tile_len != (void *)0) {
    {
#line 1821
    free(j2k->tile_len);
    }
  }
#line 1823
  if (j2k->tile_data != (void *)0) {
#line 1824
    if (j2k->cp != (void *)0) {
#line 1825
      i = 0;
      {
#line 1825
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1825
        if (! (i < (j2k->cp)->tileno_size)) {
#line 1825
          goto while_break;
        }
        {
#line 1826
        tileno = *((j2k->cp)->tileno + i);
#line 1827
        free(*(j2k->tile_data + tileno));
#line 1828
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
        }
#line 1825
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1832
    free(j2k->tile_data);
    }
  }
#line 1834
  if (j2k->default_tcp != (void *)0) {
#line 1835
    default_tcp = j2k->default_tcp;
#line 1836
    if (default_tcp->ppt_data_first != (void *)0) {
      {
#line 1837
      free(default_tcp->ppt_data_first);
      }
    }
#line 1839
    if ((j2k->default_tcp)->tccps != (void *)0) {
      {
#line 1840
      free((j2k->default_tcp)->tccps);
      }
    }
    {
#line 1842
    free(j2k->default_tcp);
    }
  }
#line 1844
  if (j2k->cp != (void *)0) {
#line 1845
    cp = j2k->cp;
#line 1846
    if (cp->tcps != (void *)0) {
#line 1847
      i = 0;
      {
#line 1847
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1847
        if (! (i < cp->tw * cp->th)) {
#line 1847
          goto while_break___0;
        }
#line 1848
        if ((cp->tcps + i)->ppt_data_first != (void *)0) {
          {
#line 1849
          free((cp->tcps + i)->ppt_data_first);
          }
        }
#line 1851
        if ((cp->tcps + i)->tccps != (void *)0) {
          {
#line 1852
          free((cp->tcps + i)->tccps);
          }
        }
#line 1847
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1855
      free(cp->tcps);
      }
    }
#line 1857
    if (cp->ppm_data_first != (void *)0) {
      {
#line 1858
      free(cp->ppm_data_first);
      }
    }
#line 1860
    if (cp->tileno != (void *)0) {
      {
#line 1861
      free(cp->tileno);
      }
    }
#line 1863
    if (cp->comment != (void *)0) {
      {
#line 1864
      free(cp->comment);
      }
    }
    {
#line 1867
    free(cp);
    }
  }
  {
#line 1869
  free(j2k);
  }
  return;
}
}
#line 1872 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1873
  if (j2k) {
#line 1873
    if (parameters) {
      {
#line 1875
      __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 1875
      cp = (opj_cp_t *)__cil_tmp4;
#line 1876
      cp->reduce = parameters->cp_reduce;
#line 1877
      cp->layer = parameters->cp_layer;
#line 1878
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1888
      j2k->cp = cp;
      }
    }
  }
  return;
}
}
#line 1892 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp6 ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_dec_mstabent_t *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1893
  image = (opj_image_t *)((void *)0);
#line 1895
  cinfo = j2k->cinfo;
#line 1897
  j2k->cio = cio;
#line 1898
  j2k->cstr_info = cstr_info;
#line 1899
  if (cstr_info) {
    {
#line 1900
    memset(cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1903
  image = opj_image_create0();
#line 1904
  j2k->image = image;
#line 1906
  j2k->state = 1;
  }
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1908
    if (! 1) {
#line 1908
      goto while_break;
    }
    {
#line 1910
    __cil_tmp9 = cio_read(cio, 2);
#line 1910
    id = (int )__cil_tmp9;
    }
#line 1950
    if (id >> 8 != 255) {
      {
#line 1951
      __cil_tmp10 = cio_numbytesleft(cio);
      }
#line 1951
      if (__cil_tmp10 != 0) {
        {
#line 1953
        __cil_tmp11 = cio_tell(cio);
#line 1953
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp11 - 2,
                      id);
#line 1954
        opj_image_destroy(image);
        }
#line 1955
        return ((opj_image_t *)0);
      }
      {
#line 1957
      __cil_tmp12 = cio_tell(cio);
#line 1957
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp12 - 2,
                    id);
#line 1958
      j2k->state = 64;
      }
#line 1959
      goto while_break;
    }
    {
#line 1961
    e = j2k_dec_mstab_lookup(id);
    }
#line 1963
    if (! (j2k->state & e->states)) {
      {
#line 1964
      opj_image_destroy(image);
#line 1965
      __cil_tmp14 = cio_tell(cio);
#line 1965
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp14 - 2, id);
      }
#line 1966
      return ((opj_image_t *)0);
    }
#line 1969
    if (e->id == 65424) {
#line 1969
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 1970
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 1971
        return (image);
      }
    }
#line 1974
    if (e->handler) {
      {
#line 1975
      (*(e->handler))(j2k);
      }
    }
#line 1977
    if (j2k->state & 128) {
      {
#line 1979
      opj_image_destroy(image);
      }
#line 1980
      return ((opj_image_t *)((void *)0));
    }
#line 1983
    if (j2k->state == 32) {
#line 1984
      goto while_break;
    }
#line 1986
    if (j2k->state == 64) {
#line 1987
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1990
  if (j2k->state == 64) {
    {
#line 1991
    j2k_read_eoc(j2k);
    }
  }
#line 1994
  if (j2k->state != 32) {
    {
#line 1995
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 1997
  return (image);
}
}
#line 2004 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  opj_dec_mstabent_t *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 2005
  image = (opj_image_t *)((void *)0);
#line 2008
  cinfo = j2k->cinfo;
#line 2012
  j2k->cio = cio;
#line 2015
  image = opj_image_create0();
#line 2016
  j2k->image = image;
#line 2018
  j2k->state = 1;
#line 2021
  jpt_init_msg_header(& header);
#line 2023
  jpt_read_msg_header(cinfo, cio, & header);
#line 2025
  position = cio_tell(cio);
  }
#line 2026
  if (header.Class_Id != 6U) {
    {
#line 2027
    opj_image_destroy(image);
#line 2028
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 2029
    return ((opj_image_t *)0);
  }
  {
#line 2032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2032
    if (! 1) {
#line 2032
      goto while_break;
    }
    {
#line 2033
    e = (opj_dec_mstabent_t *)((void *)0);
#line 2036
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 2036
    if (! __cil_tmp12) {
      {
#line 2037
      j2k_read_eoc(j2k);
      }
#line 2038
      return (image);
    }
    {
#line 2041
    __cil_tmp13 = cio_tell(cio);
    }
#line 2041
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 2042
      jpt_read_msg_header(cinfo, cio, & header);
#line 2043
      position = cio_tell(cio);
      }
#line 2044
      if (header.Class_Id != 4U) {
        {
#line 2045
        opj_image_destroy(image);
#line 2046
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\n");
        }
#line 2047
        return ((opj_image_t *)0);
      }
    }
    {
#line 2051
    __cil_tmp15 = cio_read(cio, 2);
#line 2051
    id = (int )__cil_tmp15;
    }
#line 2052
    if (id >> 8 != 255) {
      {
#line 2053
      __cil_tmp16 = cio_numbytesleft(cio);
      }
#line 2053
      if (__cil_tmp16 != 0) {
        {
#line 2055
        __cil_tmp17 = cio_tell(cio);
#line 2055
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp17 - 2,
                      id);
#line 2056
        opj_image_destroy(image);
        }
#line 2057
        return ((opj_image_t *)0);
      }
      {
#line 2059
      __cil_tmp18 = cio_tell(cio);
#line 2059
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp18 - 2,
                    id);
#line 2060
      j2k->state = 64;
      }
#line 2061
      goto while_break;
    }
    {
#line 2063
    e = j2k_dec_mstab_lookup(id);
    }
#line 2064
    if (! (j2k->state & e->states)) {
      {
#line 2065
      opj_image_destroy(image);
#line 2066
      __cil_tmp20 = cio_tell(cio);
#line 2066
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp20 - 2, id);
      }
#line 2067
      return ((opj_image_t *)0);
    }
#line 2069
    if (e->handler) {
      {
#line 2070
      (*(e->handler))(j2k);
      }
    }
#line 2072
    if (j2k->state == 32) {
#line 2073
      goto while_break;
    }
#line 2075
    if (j2k->state == 64) {
#line 2076
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2079
  if (j2k->state == 64) {
    {
#line 2080
    j2k_read_eoc(j2k);
    }
  }
#line 2083
  if (j2k->state != 32) {
    {
#line 2084
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2087
  return (image);
}
}
#line 2094 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 2095
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 2095
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 2096
  if (j2k) {
#line 2097
    j2k->cinfo = cinfo;
  }
#line 2099
  return (j2k);
}
}
#line 2102 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;
  int __cil_tmp4 ;

  {
#line 2105
  if (! j2k) {
#line 2105
    return;
  }
#line 2106
  if (j2k->cp != (void *)0) {
#line 2107
    cp = j2k->cp;
#line 2109
    if (cp->comment) {
      {
#line 2110
      free(cp->comment);
      }
    }
#line 2112
    if (cp->matrice) {
      {
#line 2113
      free(cp->matrice);
      }
    }
#line 2115
    tileno = 0;
    {
#line 2115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2115
      if (! (tileno < cp->tw * cp->th)) {
#line 2115
        goto while_break;
      }
      {
#line 2116
      free((cp->tcps + tileno)->tccps);
      }
#line 2115
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2118
    free(cp->tcps);
#line 2119
    free(cp);
    }
  }
  {
#line 2122
  free(j2k);
  }
  return;
}
}
#line 2125 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  opj_poc_t *tcp_poc ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int p ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 2127
  cp = (opj_cp_t *)((void *)0);
#line 2129
  if (! j2k) {
#line 2130
    return;
  } else
#line 2129
  if (! parameters) {
#line 2130
    return;
  } else
#line 2129
  if (! image) {
#line 2130
    return;
  }
  {
#line 2134
  __cil_tmp9 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 2134
  cp = (opj_cp_t *)__cil_tmp9;
#line 2137
  j2k->cp = cp;
#line 2140
  cp->tw = 1;
#line 2141
  cp->th = 1;
#line 2146
  cp->cinema = parameters->cp_cinema;
#line 2147
  cp->max_comp_size = parameters->max_comp_size;
#line 2148
  cp->rsiz = parameters->cp_rsiz;
#line 2149
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2150
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2151
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2154
  if (parameters->cp_matrice) {
    {
#line 2155
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2156
    __cil_tmp11 = malloc(array_size);
#line 2156
    cp->matrice = (int *)__cil_tmp11;
#line 2157
    memcpy(cp->matrice, parameters->cp_matrice, array_size);
    }
  }
#line 2161
  cp->tdx = parameters->cp_tdx;
#line 2162
  cp->tdy = parameters->cp_tdy;
#line 2165
  cp->tx0 = parameters->cp_tx0;
#line 2166
  cp->ty0 = parameters->cp_ty0;
#line 2169
  if (parameters->cp_comment) {
    {
#line 2170
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2170
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2170
    cp->comment = (char *)__cil_tmp13;
    }
#line 2171
    if (cp->comment) {
      {
#line 2172
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2180
  if (parameters->tile_size_on) {
    {
#line 2181
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2182
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2184
    cp->tdx = image->x1 - cp->tx0;
#line 2185
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2188
  if (parameters->tp_on) {
#line 2189
    cp->tp_flag = parameters->tp_flag;
#line 2190
    cp->tp_on = (char )1;
  }
#line 2193
  cp->img_size = 0;
#line 2194
  i = 0;
  {
#line 2194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2194
    if (! (i < image->numcomps)) {
#line 2194
      goto while_break;
    }
#line 2195
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2258
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2258
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2260
  tileno = 0;
  }
  {
#line 2260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2260
    if (! (tileno < cp->tw * cp->th)) {
#line 2260
      goto while_break___0;
    }
#line 2261
    tcp = cp->tcps + tileno;
#line 2262
    tcp->numlayers = parameters->tcp_numlayers;
#line 2263
    j = 0;
    {
#line 2263
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2263
      if (! (j < tcp->numlayers)) {
#line 2263
        goto while_break___1;
      }
#line 2264
      if (cp->cinema) {
#line 2265
        if (cp->fixed_quality) {
#line 2266
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2268
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2270
      if (cp->fixed_quality) {
#line 2271
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2273
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2263
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2277
    tcp->csty = parameters->csty;
#line 2278
    tcp->prg = parameters->prog_order;
#line 2279
    tcp->mct = (int )parameters->tcp_mct;
#line 2281
    numpocs_tile = 0;
#line 2282
    tcp->POC = 0;
#line 2283
    if (parameters->numpocs) {
#line 2285
      tcp->POC = 1;
#line 2286
      i = 0;
      {
#line 2286
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2286
        if (! (i < parameters->numpocs)) {
#line 2286
          goto while_break___2;
        }
#line 2287
        if (tileno == parameters->POC[i].tile - 1) {
          _L: /* CIL Label */ 
#line 2288
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2289
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2290
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2291
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2292
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2293
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2294
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2295
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2296
          numpocs_tile ++;
        } else
#line 2287
        if (parameters->POC[i].tile == -1) {
#line 2287
          goto _L;
        }
#line 2286
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2299
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2301
      tcp->numpocs = 0;
    }
    {
#line 2304
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2304
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2306
    i = 0;
    }
    {
#line 2306
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2306
      if (! (i < image->numcomps)) {
#line 2306
        goto while_break___3;
      }
      {
#line 2307
      tccp = tcp->tccps + i;
#line 2308
      tccp->csty = parameters->csty & 1;
#line 2309
      tccp->numresolutions = parameters->numresolution;
#line 2310
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2311
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2312
      tccp->cblksty = parameters->mode;
      }
#line 2313
      if (parameters->irreversible) {
#line 2313
        tmp = 0;
      } else {
#line 2313
        tmp = 1;
      }
#line 2313
      tccp->qmfbid = tmp;
#line 2314
      if (parameters->irreversible) {
#line 2314
        tmp___0 = 2;
      } else {
#line 2314
        tmp___0 = 0;
      }
#line 2314
      tccp->qntsty = tmp___0;
#line 2315
      tccp->numgbits = 2;
#line 2316
      if (i == parameters->roi_compno) {
#line 2317
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2319
        tccp->roishift = 0;
      }
#line 2322
      if (parameters->cp_cinema) {
#line 2325
        tccp->prcw[0] = 7;
#line 2326
        tccp->prch[0] = 7;
#line 2328
        j = 1;
        {
#line 2328
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2328
          if (! (j < tccp->numresolutions)) {
#line 2328
            goto while_break___4;
          }
#line 2329
          tccp->prcw[j] = 8;
#line 2330
          tccp->prch[j] = 8;
#line 2328
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2333
      if (parameters->csty & 1) {
#line 2334
        p = 0;
#line 2335
        j = tccp->numresolutions - 1;
        {
#line 2335
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2335
          if (! (j >= 0)) {
#line 2335
            goto while_break___5;
          }
#line 2336
          if (p < parameters->res_spec) {
#line 2338
            if (parameters->prcw_init[p] < 1) {
#line 2339
              tccp->prcw[j] = 1;
            } else {
              {
#line 2341
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2344
            if (parameters->prch_init[p] < 1) {
#line 2345
              tccp->prch[j] = 1;
            } else {
              {
#line 2347
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2351
            res_spec = parameters->res_spec;
#line 2352
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2353
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2355
            if (size_prcw < 1) {
#line 2356
              tccp->prcw[j] = 1;
            } else {
              {
#line 2358
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2361
            if (size_prch < 1) {
#line 2362
              tccp->prch[j] = 1;
            } else {
              {
#line 2364
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2367
          p ++;
#line 2335
          __cil_tmp39 = j;
#line 2335
          j --;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2371
        j = 0;
        {
#line 2371
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2371
          if (! (j < tccp->numresolutions)) {
#line 2371
            goto while_break___6;
          }
#line 2372
          tccp->prcw[j] = 15;
#line 2373
          tccp->prch[j] = 15;
#line 2371
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2378
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
      }
#line 2306
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2260
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 2383 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___6 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  opj_tcp_t *tcp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_tcd_t *__cil_tmp20 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int tot_num_tp ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
#line 2385
  cp = (opj_cp_t *)((void *)0);
#line 2387
  tcd = (opj_tcd_t *)((void *)0);
#line 2389
  j2k->cio = cio;
#line 2390
  j2k->image = image;
#line 2392
  cp = j2k->cp;
#line 2395
  j2k->cstr_info = cstr_info;
#line 2396
  if (cstr_info) {
    {
#line 2398
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2398
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2399
    cstr_info->image_w = image->x1 - image->x0;
#line 2400
    cstr_info->image_h = image->y1 - image->y0;
#line 2401
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2402
    cstr_info->tw = cp->tw;
#line 2403
    cstr_info->th = cp->th;
#line 2404
    cstr_info->tile_x = cp->tdx;
#line 2405
    cstr_info->tile_y = cp->tdy;
#line 2406
    cstr_info->tile_Ox = cp->tx0;
#line 2407
    cstr_info->tile_Oy = cp->ty0;
#line 2408
    cstr_info->numcomps = image->numcomps;
#line 2409
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2410
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2410
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2411
    compno___6 = 0;
    }
    {
#line 2411
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2411
      if (! (compno___6 < image->numcomps)) {
#line 2411
        goto while_break;
      }
#line 2412
      *(cstr_info->numdecompos + compno___6) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2411
      compno___6 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2414
    cstr_info->D_max = 0.;
#line 2415
    cstr_info->main_head_start = cio_tell(cio);
#line 2416
    cstr_info->maxmarknum = 100;
#line 2417
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2417
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2418
    cstr_info->marknum = 0;
    }
  }
  {
#line 2422
  j2k_write_soc(j2k);
#line 2423
  j2k_write_siz(j2k);
#line 2424
  j2k_write_cod(j2k);
#line 2425
  j2k_write_qcd(j2k);
  }
#line 2427
  if (cp->cinema) {
#line 2428
    compno = 1;
    {
#line 2428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2428
      if (! (compno < image->numcomps)) {
#line 2428
        goto while_break___0;
      }
      {
#line 2429
      j2k_write_coc(j2k, compno);
#line 2430
      j2k_write_qcc(j2k, compno);
      }
#line 2428
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2434
  compno = 0;
  {
#line 2434
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2434
    if (! (compno < image->numcomps)) {
#line 2434
      goto while_break___1;
    }
#line 2435
    tcp = cp->tcps + 0;
#line 2436
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2437
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2434
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2439
  if (cp->comment != (void *)0) {
    {
#line 2440
    j2k_write_com(j2k);
    }
  }
  {
#line 2443
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2445
  if (cp->cinema) {
    {
#line 2446
    j2k_write_tlm(j2k);
    }
#line 2447
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2448
      j2k_write_poc(j2k);
      }
    }
  }
#line 2456
  if (cstr_info) {
    {
#line 2457
    __cil_tmp19 = cio_tell(cio);
#line 2457
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2463
  tcd = tcd_create(j2k->cinfo);
#line 2466
  tileno = 0;
  }
  {
#line 2466
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2466
    if (! (tileno < cp->tw * cp->th)) {
#line 2466
      goto while_break___2;
    }
    {
#line 2468
    tilepartno = 0;
#line 2470
    acc_pack_num = 0;
#line 2474
    tcp___0 = cp->tcps + tileno;
#line 2475
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2477
    j2k->curtileno = tileno;
#line 2478
    j2k->cur_tp_num = 0;
#line 2479
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2481
    if (tileno == 0) {
      {
#line 2482
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2484
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2488
    if (cstr_info) {
      {
#line 2489
      __cil_tmp25 = cio_tell(cio);
#line 2489
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
#line 2490
      (cstr_info->tile + j2k->curtileno)->maxmarknum = 10;
#line 2491
      __cil_tmp26 = malloc((unsigned long )(cstr_info->tile + j2k->curtileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 2491
      (cstr_info->tile + j2k->curtileno)->marker = (opj_marker_info_t *)__cil_tmp26;
#line 2492
      (cstr_info->tile + j2k->curtileno)->marknum = 0;
      }
    }
#line 2496
    pino = 0;
    {
#line 2496
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2496
      if (! (pino <= tcp___0->numpocs)) {
#line 2496
        goto while_break___3;
      }
      {
#line 2498
      tcd->cur_pino = pino;
#line 2501
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2502
      tcd->tp_pos = cp->tp_pos;
#line 2504
      tilepartno = 0;
      }
      {
#line 2504
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2504
        if (! (tilepartno < tot_num_tp)) {
#line 2504
          goto while_break___4;
        }
#line 2505
        j2k->tp_num = tilepartno;
#line 2507
        if (cstr_info) {
          {
#line 2508
          __cil_tmp29 = cio_tell(cio);
#line 2508
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp29 + j2k->pos_correction;
          }
        }
        {
#line 2511
        j2k_write_sot(j2k);
        }
#line 2513
        if (j2k->cur_tp_num == 0) {
#line 2513
          if ((unsigned int )cp->cinema == 0U) {
#line 2514
            compno = 1;
            {
#line 2514
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2514
              if (! (compno < image->numcomps)) {
#line 2514
                goto while_break___5;
              }
              {
#line 2515
              j2k_write_coc(j2k, compno);
#line 2516
              j2k_write_qcc(j2k, compno);
              }
#line 2514
              compno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2518
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2519
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2524
        if (cstr_info) {
          {
#line 2525
          __cil_tmp31 = cio_tell(cio);
#line 2525
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp31 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2529
        j2k_write_sod(j2k, tcd);
        }
#line 2532
        if (cstr_info) {
          {
#line 2533
          __cil_tmp32 = cio_tell(cio);
#line 2533
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp32 + j2k->pos_correction) - 1;
#line 2535
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2537
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2539
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2543
        (j2k->cur_tp_num) ++;
#line 2504
        tilepartno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2496
      pino ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2546
    if (cstr_info) {
      {
#line 2547
      __cil_tmp36 = cio_tell(cio);
#line 2547
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp36 + j2k->pos_correction) - 1;
      }
    }
#line 2466
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2570
  tcd_free_encode(tcd);
#line 2571
  tcd_destroy(tcd);
#line 2573
  free(j2k->cur_totnum_tp);
#line 2575
  j2k_write_eoc(j2k);
  }
#line 2577
  if (cstr_info) {
    {
#line 2578
    __cil_tmp38 = cio_tell(cio);
#line 2578
    cstr_info->codestream_size = __cil_tmp38 + j2k->pos_correction;
#line 2583
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2599
  return (1);
}
}
#line 2602 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2604
  if (! cstr_info) {
#line 2605
    return;
  }
#line 2608
  if (cstr_info->marknum + 1 > cstr_info->maxmarknum) {
    {
#line 2609
    cstr_info->maxmarknum = 100 + (int )((float )cstr_info->maxmarknum * 1.f);
#line 2610
    __cil_tmp5 = realloc(cstr_info->marker, (unsigned long )cstr_info->maxmarknum);
#line 2610
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp5;
    }
  }
#line 2614
  (cstr_info->marker + cstr_info->marknum)->type = type;
#line 2615
  (cstr_info->marker + cstr_info->marknum)->pos = pos;
#line 2616
  (cstr_info->marker + cstr_info->marknum)->len = len;
#line 2617
  (cstr_info->marknum) ++;
  return;
}
}
#line 2621 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/j2k.c"
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  opj_marker_info_t *marker ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2625
  if (! cstr_info) {
#line 2626
    return;
  }
#line 2629
  if ((cstr_info->tile + tileno)->marknum + 1 > (cstr_info->tile + tileno)->maxmarknum) {
    {
#line 2630
    (cstr_info->tile + tileno)->maxmarknum = 100 + (int )((float )(cstr_info->tile + tileno)->maxmarknum * 1.f);
#line 2631
    __cil_tmp7 = realloc((cstr_info->tile + tileno)->marker, (unsigned long )cstr_info->maxmarknum);
#line 2631
    (cstr_info->tile + tileno)->marker = (opj_marker_info_t *)__cil_tmp7;
    }
  }
#line 2634
  marker = (cstr_info->tile + tileno)->marker + (cstr_info->tile + tileno)->marknum;
#line 2637
  marker->type = type;
#line 2638
  marker->pos = pos;
#line 2639
  marker->len = len;
#line 2640
  ((cstr_info->tile + tileno)->marknum) ++;
  return;
}
}
#line 36 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 37
  cp = (opj_cp_t *)((void *)0);
#line 38
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 38
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 39
  if (! cio) {
#line 39
    return ((opj_cio_t *)((void *)0));
  }
#line 40
  cio->cinfo = cinfo;
#line 41
  if (buffer) {
#line 41
    if (length) {
#line 43
      cio->openmode = 1;
#line 44
      cio->buffer = buffer;
#line 45
      cio->length = length;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 47
  if (! buffer) {
#line 47
    if (! length) {
#line 47
      if (cinfo) {
#line 49
        cio->openmode = 2;
        {
#line 51
        if ((int )cinfo->codec_format == 0) {
#line 51
          goto case_0;
        }
#line 54
        if ((int )cinfo->codec_format == 2) {
#line 54
          goto case_2;
        }
#line 57
        goto switch_default;
        case_0: /* CIL Label */ 
#line 52
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 53
        goto switch_break;
        case_2: /* CIL Label */ 
#line 55
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 56
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 58
        free(cio);
        }
#line 59
        return ((opj_cio_t *)((void *)0));
        switch_break: /* CIL Label */ ;
        }
        {
#line 61
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 62
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 62
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 63
        if (! cio->buffer) {
          {
#line 64
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n");
#line 65
          free(cio);
          }
#line 66
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
        {
        {
#line 70
        free(cio);
        }
        }
        }
#line 71
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
      {
      {
#line 70
      free(cio);
      }
      }
      }
#line 71
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
    {
    {
#line 70
    free(cio);
    }
    }
    }
#line 71
    return ((opj_cio_t *)((void *)0));
  }
#line 75
  cio->start = cio->buffer;
#line 76
  cio->end = cio->buffer + cio->length;
#line 77
  cio->bp = cio->buffer;
#line 79
  return (cio);
}
}
#line 82 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 83
  if (cio) {
#line 84
    if (cio->openmode == 2) {
      {
#line 86
      free(cio->buffer);
      }
    }
    {
#line 89
    free(cio);
    }
  }
  return;
}
}
#line 99 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 100
  return ((int )(cio->bp - cio->start));
}
}
#line 108 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 


  {
#line 109
  cio->bp = cio->start + pos;
  return;
}
}
#line 115 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 


  {
#line 116
  return ((int )(cio->end - cio->bp));
}
}
#line 122 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 123
  return (cio->bp);
}
}
#line 129 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
opj_bool cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 130
  if (cio->bp >= cio->end) {
    {
#line 131
    opj_event_msg(cio->cinfo, 1, "write error\nTV");
    }
#line 132
    return (0);
  }
#line 134
  __cil_tmp3 = cio->bp;
#line 134
  (cio->bp) ++;
#line 134
  *__cil_tmp3 = v;
#line 135
  return (1);
}
}
#line 141 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 142
  if (cio->bp >= cio->end) {
    {
#line 143
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 144
    return ((unsigned char )0);
  }
#line 146
  __cil_tmp2 = cio->bp;
#line 146
  (cio->bp) ++;
#line 146
  return (*__cil_tmp2);
}
}
#line 155 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) 
{ 
  int i ;
  opj_bool __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  i = n - 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i >= 0)) {
#line 157
      goto while_break;
    }
    {
#line 158
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255ULL));
    }
#line 158
    if (! __cil_tmp5) {
#line 159
      return ((unsigned int )0);
    }
#line 157
    __cil_tmp6 = i;
#line 157
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return ((unsigned int )n);
}
}
#line 171 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 174
  v = (unsigned int )0;
#line 175
  i = n - 1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i >= 0)) {
#line 175
      goto while_break;
    }
    {
#line 176
    __cil_tmp5 = cio_bytein(cio);
    }
#line 176
    v += (unsigned int )((int )__cil_tmp5 << (i << 3));
#line 175
    __cil_tmp6 = i;
#line 175
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (v);
}
}
#line 186 "/doner/openjpeg/openjpeg-6fc2b56/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 


  {
#line 187
  cio->bp += n;
  return;
}
}
