/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__2 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__2 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_6 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_6 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_7 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_7 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_8 {
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_11 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_10 {
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_8  ;
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
   union __anonunion_10  ;
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_21 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_20 {
   int __count ;
   union __anonunion_21 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_20 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 63 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 172 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 183 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 190 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 47 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 100 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 76 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 48 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
union __anonunion_23 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_23 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 853 "/usr/include/math.h"
enum __anonenum__45 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__46 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__68 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__69 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__70 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___0 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___1 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___0 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___2 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__100 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__103 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___1 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___3 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___2 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___4 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___3 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___5 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___4 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___6 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___5 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___7 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___6 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___8 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___7 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___9 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___8 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___10 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_107 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_108 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_109 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_110 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_111 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_112 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_113 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_114 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_115 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_116 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_117 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_118 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_119 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_120 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_107  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_108  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_109  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_110  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_111  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_112  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_113  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_114  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_115  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_116  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_117  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_118  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_119  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_120  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__137 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__140 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___9 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___11 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 256 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 259 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1716 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1723 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 853 "/usr/include/math.h"
enum __anonenum__92___10 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___12 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___11 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___13 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___12 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___14 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___13 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___15 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__45___0 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__160 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "../../applications/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "../../applications/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 36 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   opj_bool rawSigned ;
};
#line 48 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 68 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 73 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
typedef struct dircnt dircnt_t;
#line 76 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 86 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__161 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__162 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
#line 537 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
typedef unsigned short WORD;
#line 540 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
typedef unsigned int DWORD;
#line 542 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
struct __anonstruct_163 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 548 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
typedef struct __anonstruct_163 BITMAPFILEHEADER_t;
#line 550 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
struct __anonstruct_164 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 562 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
typedef struct __anonstruct_164 BITMAPINFOHEADER_t;
#line 564 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
struct bmp_cmap {
   unsigned char blue ;
   unsigned char green ;
   unsigned char red ;
   unsigned char alpha ;
};
#line 1494 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__45___1 {
    FP_NAN___22 = 0,
    FP_INFINITE___22 = 1,
    FP_ZERO___22 = 2,
    FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22 = 4
} ;
#line 853
enum __anonenum__161___0 {
    FP_NAN___23 = 0,
    FP_INFINITE___23 = 1,
    FP_ZERO___23 = 2,
    FP_SUBNORMAL___23 = 3,
    FP_NORMAL___23 = 4
} ;
#line 853
enum __anonenum__45___2 {
    FP_NAN___24 = 0,
    FP_INFINITE___24 = 1,
    FP_ZERO___24 = 2,
    FP_SUBNORMAL___24 = 3,
    FP_NORMAL___24 = 4
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__160___0 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 72 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
struct img_folder___0 {
   char *imgdirpath ;
   char *out_format ;
   char set_imgdir ;
   char set_out_format ;
   float *rates ;
};
#line 83 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
typedef struct img_folder___0 img_fol_t___0;
#line 46 "/usr/include/ctype.h"
enum __anonenum__162___0 {
    _ISupper___21 = 256,
    _ISlower___21 = 512,
    _ISalpha___21 = 1024,
    _ISdigit___21 = 2048,
    _ISxdigit___21 = 4096,
    _ISspace___21 = 8192,
    _ISprint___21 = 16384,
    _ISgraph___21 = 32768,
    _ISblank___21 = 1,
    _IScntrl___21 = 2,
    _ISpunct___21 = 4,
    _ISalnum___21 = 8
} ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 732 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/event.h"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) ;
#line 67 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 59 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 65
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 73
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) ;
#line 80
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 86
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 85 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 90
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 96
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 102
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 110
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 116
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 128
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 133
void mqc_flush(opj_mqc_t *mqc ) ;
#line 140
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 148
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 155
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 160
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 166
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 171
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 176
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 181
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 188
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 194
int mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 74 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 125
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 134
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 143
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 150
opj_bool pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 273
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) ;
#line 278
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 279
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 74 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 84
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 93
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 98
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (l);
}
}
#line 56 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 53 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.h"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) ;
#line 68 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/indexbox_manager.h"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) ;
#line 79
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 92
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 105
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 115
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) ;
#line 52 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) ;
#line 55 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tpix_manager.c"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 58
  lenp = cio_tell(cio);
#line 59
  cio_skip(cio, 4);
#line 60
  cio_write(cio, (unsigned long long )1953524088, 4);
#line 62
  write_tpixfaix(coff, 0, cstr_info, j2klen, cio);
#line 64
  __cil_tmp8 = cio_tell(cio);
#line 64
  len = __cil_tmp8 - lenp;
#line 65
  cio_seek(cio, lenp);
#line 66
  cio_write(cio, (unsigned long long )len, 4);
#line 67
  cio_seek(cio, lenp + len);
  }
#line 69
  return (len);
}
}
#line 79
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) ;
#line 81 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int j ;
  int Aux ;
  int num_max_tile_parts ;
  int size_of_coding ;
  opj_tp_info_t tp ;
  int version ;
  int __cil_tmp15 ;
  double __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 91
  num_max_tile_parts = get_num_max_tile_parts(cstr_info);
#line 93
  __cil_tmp16 = pow((double )2, (double )32);
  }
#line 93
  if ((double )j2klen > __cil_tmp16) {
#line 94
    size_of_coding = 8;
#line 95
    if (num_max_tile_parts == 1) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 3;
    }
#line 95
    version = tmp;
  } else {
#line 98
    size_of_coding = 4;
#line 99
    if (num_max_tile_parts == 1) {
#line 99
      tmp___0 = 0;
    } else {
#line 99
      tmp___0 = 2;
    }
#line 99
    version = tmp___0;
  }
  {
#line 102
  lenp = cio_tell(cio);
#line 103
  cio_skip(cio, 4);
#line 104
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 105
  cio_write(cio, (unsigned long long )version, 1);
#line 107
  cio_write(cio, (unsigned long long )num_max_tile_parts, size_of_coding);
#line 108
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 109
  i = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 109
      goto while_break;
    }
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (j < (cstr_info.tile + i)->num_tps)) {
#line 110
        goto while_break___0;
      }
      {
#line 111
      tp = *((cstr_info.tile + i)->tp + j);
#line 112
      cio_write(cio, (unsigned long long )(tp.tp_start_pos - coff), size_of_coding);
#line 113
      cio_write(cio, (unsigned long long )((tp.tp_end_pos - tp.tp_start_pos) + 1),
                size_of_coding);
      }
#line 114
      if (version & 2) {
#line 115
        if ((cstr_info.tile + i)->num_tps == 1) {
#line 115
          if (*(cstr_info.numdecompos + compno) > 1) {
#line 116
            Aux = *(cstr_info.numdecompos + compno) + 1;
          } else {
#line 118
            Aux = j + 1;
          }
        } else {
#line 118
          Aux = j + 1;
        }
        {
#line 120
        cio_write(cio, (unsigned long long )Aux, 4);
        }
      }
#line 110
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 127
      if (! (j < num_max_tile_parts)) {
#line 127
        goto while_break___1;
      }
      {
#line 128
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 129
      cio_write(cio, (unsigned long long )0, size_of_coding);
      }
#line 130
      if (version & 2) {
        {
#line 131
        cio_write(cio, (unsigned long long )0, 4);
        }
      }
#line 132
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  __cil_tmp23 = cio_tell(cio);
#line 136
  len = __cil_tmp23 - lenp;
#line 137
  cio_seek(cio, lenp);
#line 138
  cio_write(cio, (unsigned long long )len, 4);
#line 139
  cio_seek(cio, lenp + len);
  }
#line 141
  return (len);
}
}
#line 145 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tpix_manager.c"
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) 
{ 
  int num_max_tp ;
  int i ;
  int tmp ;
  int __cil_tmp5 ;

  {
#line 147
  num_max_tp = 0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 149
      goto while_break;
    }
#line 150
    if ((cstr_info.tile + i)->num_tps > num_max_tp) {
#line 150
      tmp = (cstr_info.tile + i)->num_tps;
    } else {
#line 150
      tmp = num_max_tp;
    }
#line 150
    num_max_tp = tmp;
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (num_max_tp);
}
}
#line 50 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) ;
#line 52 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/thix_manager.c"
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int tileno ;
  opj_jp2_box_t *box ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 58
  lenp = 0;
#line 59
  __cil_tmp9 = calloc((unsigned long )(cstr_info.tw * cstr_info.th), sizeof(opj_jp2_box_t ));
#line 59
  box = (opj_jp2_box_t *)__cil_tmp9;
#line 61
  i = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 2)) {
#line 61
      goto while_break;
    }
#line 62
    if (i) {
      {
#line 63
      cio_seek(cio, lenp);
      }
    }
    {
#line 65
    lenp = cio_tell(cio);
#line 66
    cio_skip(cio, 4);
#line 67
    cio_write(cio, (unsigned long long )1952999800, 4);
#line 68
    write_manf(i, cstr_info.tw * cstr_info.th, box, cio);
#line 70
    tileno = 0;
    }
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      (box + tileno)->length = write_tilemhix(coff, cstr_info, tileno, cio);
#line 72
      (box + tileno)->type = 1835559288;
      }
#line 70
      tileno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    __cil_tmp13 = cio_tell(cio);
#line 75
    len = __cil_tmp13 - lenp;
#line 76
    cio_seek(cio, lenp);
#line 77
    cio_write(cio, (unsigned long long )len, 4);
#line 78
    cio_seek(cio, lenp + len);
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  free(box);
  }
#line 83
  return (len);
}
}
#line 86 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) 
{ 
  int i ;
  opj_tile_info_t tile ;
  opj_tp_info_t tp ;
  int len ;
  int lenp ;
  opj_marker_info_t *marker ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 94
  lenp = cio_tell(cio);
#line 95
  cio_skip(cio, 4);
#line 96
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 98
  tile = *(cstr_info.tile + tileno);
#line 99
  tp = *(tile.tp + 0);
#line 101
  cio_write(cio, (unsigned long long )((tp.tp_end_header - tp.tp_start_pos) + 1),
            8);
#line 103
  marker = (cstr_info.tile + tileno)->marker;
#line 105
  i = 0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < (cstr_info.tile + tileno)->marknum)) {
#line 105
      goto while_break;
    }
    {
#line 106
    cio_write(cio, (unsigned long long )(marker + i)->type, 2);
#line 107
    cio_write(cio, (unsigned long long )0, 2);
#line 108
    cio_write(cio, (unsigned long long )((marker + i)->pos - coff), 8);
#line 109
    cio_write(cio, (unsigned long long )(marker + i)->len, 2);
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  __cil_tmp13 = cio_tell(cio);
#line 114
  len = __cil_tmp13 - lenp;
#line 115
  cio_seek(cio, lenp);
#line 116
  cio_write(cio, (unsigned long long )len, 4);
#line 117
  cio_seek(cio, lenp + len);
  }
#line 119
  return (len);
}
}
#line 52 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 54 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/ppix_manager.c"
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 61
  lenp = - 1;
#line 62
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 62
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 2)) {
#line 64
      goto while_break;
    }
#line 65
    if (i) {
      {
#line 65
      cio_seek(cio, lenp);
      }
    }
    {
#line 67
    lenp = cio_tell(cio);
#line 68
    cio_skip(cio, 4);
#line 69
    cio_write(cio, (unsigned long long )1886415224, 4);
#line 71
    write_manf(i, cstr_info.numcomps, box, cio);
#line 73
    compno = 0;
    }
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (compno < cstr_info.numcomps)) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      (box + compno)->length = write_ppixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 75
      (box + compno)->type = 1717660024;
      }
#line 73
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 78
    __cil_tmp15 = cio_tell(cio);
#line 78
    len = __cil_tmp15 - lenp;
#line 79
    cio_seek(cio, lenp);
#line 80
    cio_write(cio, (unsigned long long )len, 4);
#line 81
    cio_seek(cio, lenp + len);
    }
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  free(box);
  }
#line 86
  return (len);
}
}
#line 89 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 96
  packet.start_pos = - 1;
#line 96
  packet.end_ph_pos = packet.start_pos;
#line 96
  packet.end_pos = packet.end_ph_pos;
#line 99
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 99
  if ((double )j2klen > __cil_tmp23) {
#line 100
    size_of_coding = 8;
#line 101
    version = 1;
  } else {
#line 104
    size_of_coding = 4;
#line 105
    version = 0;
  }
  {
#line 108
  lenp = cio_tell(cio);
#line 109
  cio_skip(cio, 4);
#line 110
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 111
  cio_write(cio, (unsigned long long )version, 1);
#line 113
  nmax = 0;
#line 114
  i = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 114
      goto while_break;
    }
#line 115
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 118
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 120
  tileno = 0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 120
      goto while_break___0;
    }
#line 121
    tile_Idx = cstr_info.tile + tileno;
#line 123
    num_packet = 0;
#line 124
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 126
    resno = 0;
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 126
      if (! (resno < numOfres)) {
#line 126
        goto while_break___1;
      }
#line 127
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 128
      precno = 0;
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 128
        if (! (precno < numOfprec)) {
#line 128
          goto while_break___2;
        }
#line 129
        numOflayers = cstr_info.numlayers;
#line 130
        layno = 0;
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 130
          if (! (layno < numOflayers)) {
#line 130
            goto while_break___3;
          }
          {
#line 133
          if ((int )cstr_info.prog == 0) {
#line 133
            goto case_0;
          }
#line 136
          if ((int )cstr_info.prog == 1) {
#line 136
            goto case_1;
          }
#line 139
          if ((int )cstr_info.prog == 2) {
#line 139
            goto case_2;
          }
#line 142
          if ((int )cstr_info.prog == 3) {
#line 142
            goto case_3;
          }
#line 145
          if ((int )cstr_info.prog == 4) {
#line 145
            goto case_4;
          }
#line 148
          goto switch_default;
          case_0: /* CIL Label */ 
#line 134
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 135
          goto switch_break;
          case_1: /* CIL Label */ 
#line 137
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 138
          goto switch_break;
          case_2: /* CIL Label */ 
#line 140
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 141
          goto switch_break;
          case_3: /* CIL Label */ 
#line 143
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 144
          goto switch_break;
          case_4: /* CIL Label */ 
#line 146
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 147
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 149
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 152
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 153
          cio_write(cio, (unsigned long long )((packet.end_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 155
          num_packet ++;
          }
#line 130
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 128
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 160
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 160
      if (! (num_packet < nmax)) {
#line 160
        goto while_break___4;
      }
      {
#line 161
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 162
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 163
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 120
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 167
  __cil_tmp32 = cio_tell(cio);
#line 167
  len = __cil_tmp32 - lenp;
#line 168
  cio_seek(cio, lenp);
#line 169
  cio_write(cio, (unsigned long long )len, 4);
#line 170
  cio_seek(cio, lenp + len);
  }
#line 172
  return (len);
}
}
#line 51 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 53 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/phix_manager.c"
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 55
  lenp = 0;
#line 58
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 58
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < 2)) {
#line 60
      goto while_break;
    }
#line 61
    if (i) {
      {
#line 61
      cio_seek(cio, lenp);
      }
    }
    {
#line 63
    lenp = cio_tell(cio);
#line 64
    cio_skip(cio, 4);
#line 65
    cio_write(cio, (unsigned long long )1885890936, 4);
#line 67
    write_manf(i, cstr_info.numcomps, box, cio);
#line 69
    compno = 0;
    }
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (compno < cstr_info.numcomps)) {
#line 69
        goto while_break___0;
      }
      {
#line 70
      (box + compno)->length = write_phixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 71
      (box + compno)->type = 1717660024;
      }
#line 69
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 74
    __cil_tmp15 = cio_tell(cio);
#line 74
    len = __cil_tmp15 - lenp;
#line 75
    cio_seek(cio, lenp);
#line 76
    cio_write(cio, (unsigned long long )len, 4);
#line 77
    cio_seek(cio, lenp + len);
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  free(box);
  }
#line 82
  return (len);
}
}
#line 85 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 92
  packet.start_pos = - 1;
#line 92
  packet.end_ph_pos = packet.start_pos;
#line 95
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 95
  if ((double )j2klen > __cil_tmp23) {
#line 96
    size_of_coding = 8;
#line 97
    version = 1;
  } else {
#line 100
    size_of_coding = 4;
#line 101
    version = 0;
  }
  {
#line 104
  lenp = cio_tell(cio);
#line 105
  cio_skip(cio, 4);
#line 106
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 107
  cio_write(cio, (unsigned long long )version, 1);
#line 109
  nmax = 0;
#line 110
  i = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 110
      goto while_break;
    }
#line 111
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 114
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 116
  tileno = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 116
      goto while_break___0;
    }
#line 117
    tile_Idx = cstr_info.tile + tileno;
#line 119
    num_packet = 0;
#line 120
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 122
    resno = 0;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! (resno < numOfres)) {
#line 122
        goto while_break___1;
      }
#line 123
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 124
      precno = 0;
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 124
        if (! (precno < numOfprec)) {
#line 124
          goto while_break___2;
        }
#line 125
        numOflayers = cstr_info.numlayers;
#line 126
        layno = 0;
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 126
          if (! (layno < numOflayers)) {
#line 126
            goto while_break___3;
          }
          {
#line 129
          if ((int )cstr_info.prog == 0) {
#line 129
            goto case_0;
          }
#line 132
          if ((int )cstr_info.prog == 1) {
#line 132
            goto case_1;
          }
#line 135
          if ((int )cstr_info.prog == 2) {
#line 135
            goto case_2;
          }
#line 138
          if ((int )cstr_info.prog == 3) {
#line 138
            goto case_3;
          }
#line 141
          if ((int )cstr_info.prog == 4) {
#line 141
            goto case_4;
          }
#line 144
          goto switch_default;
          case_0: /* CIL Label */ 
#line 130
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 131
          goto switch_break;
          case_1: /* CIL Label */ 
#line 133
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 134
          goto switch_break;
          case_2: /* CIL Label */ 
#line 136
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 137
          goto switch_break;
          case_3: /* CIL Label */ 
#line 139
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 140
          goto switch_break;
          case_4: /* CIL Label */ 
#line 142
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 143
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 145
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 148
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 149
          cio_write(cio, (unsigned long long )((packet.end_ph_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 151
          num_packet ++;
          }
#line 126
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 124
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 122
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 157
      if (! (num_packet < nmax)) {
#line 157
        goto while_break___4;
      }
      {
#line 158
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 159
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 160
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 116
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  __cil_tmp32 = cio_tell(cio);
#line 164
  len = __cil_tmp32 - lenp;
#line 165
  cio_seek(cio, lenp);
#line 166
  cio_write(cio, (unsigned long long )len, 4);
#line 167
  cio_seek(cio, lenp + len);
  }
#line 169
  return (len);
}
}
#line 42 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) ;
#line 53
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 65
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) ;
#line 68 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) 
{ 
  int len ;
  int i ;
  int lenp ;
  opj_jp2_box_t *box ;
  int num_box ;
  opj_bool EPHused ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
  {
#line 72
  num_box = 0;
#line 76
  lenp = - 1;
#line 77
  __cil_tmp12 = calloc((unsigned long )32, sizeof(opj_jp2_box_t ));
#line 77
  box = (opj_jp2_box_t *)__cil_tmp12;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 2)) {
#line 79
      goto while_break;
    }
#line 81
    if (i) {
      {
#line 82
      cio_seek(cio, lenp);
      }
    }
    {
#line 84
    lenp = cio_tell(cio);
#line 86
    cio_skip(cio, 4);
#line 87
    cio_write(cio, (unsigned long long )1667851384, 4);
#line 88
    write_cptr(offset, cstr_info.codestream_size, cio);
#line 90
    write_manf(i, num_box, box, cio);
#line 92
    num_box = 0;
#line 93
    (box + num_box)->length = write_mainmhix(offset, cstr_info, cio);
#line 94
    (box + num_box)->type = 1835559288;
#line 95
    num_box ++;
#line 97
    (box + num_box)->length = write_tpix(offset, cstr_info, j2klen, cio);
#line 98
    (box + num_box)->type = 1953524088;
#line 99
    num_box ++;
#line 101
    (box + num_box)->length = write_thix(offset, cstr_info, cio);
#line 102
    (box + num_box)->type = 1952999800;
#line 103
    num_box ++;
#line 105
    EPHused = check_EPHuse(offset, cstr_info.marker, cstr_info.marknum, cio);
#line 107
    (box + num_box)->length = write_ppix(offset, cstr_info, EPHused, j2klen, cio);
#line 108
    (box + num_box)->type = 1886415224;
#line 109
    num_box ++;
#line 111
    (box + num_box)->length = write_phix(offset, cstr_info, EPHused, j2klen, cio);
#line 112
    (box + num_box)->type = 1885890936;
#line 113
    num_box ++;
#line 115
    __cil_tmp25 = cio_tell(cio);
#line 115
    len = __cil_tmp25 - lenp;
#line 116
    cio_seek(cio, lenp);
#line 117
    cio_write(cio, (unsigned long long )len, 4);
#line 118
    cio_seek(cio, lenp + len);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  free(box);
  }
#line 123
  return (len);
}
}
#line 126 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 130
  lenp = cio_tell(cio);
#line 131
  cio_skip(cio, 4);
#line 132
  cio_write(cio, (unsigned long long )1668314226, 4);
#line 133
  cio_write(cio, (unsigned long long )0, 2);
#line 134
  cio_write(cio, (unsigned long long )0, 2);
#line 135
  cio_write(cio, (unsigned long long )coff, 8);
#line 136
  cio_write(cio, (unsigned long long )clen, 8);
#line 137
  __cil_tmp7 = cio_tell(cio);
#line 137
  len = __cil_tmp7 - lenp;
#line 138
  cio_seek(cio, lenp);
#line 139
  cio_write(cio, (unsigned long long )len, 4);
#line 140
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 143 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 147
  lenp = cio_tell(cio);
#line 148
  cio_skip(cio, 4);
#line 149
  cio_write(cio, (unsigned long long )1835101798, 4);
  }
#line 151
  if (second) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      if (! (i < v)) {
#line 152
        goto while_break;
      }
      {
#line 153
      cio_write(cio, (unsigned long long )(box + i)->length, 4);
#line 154
      cio_write(cio, (unsigned long long )(box + i)->type, 4);
      }
#line 152
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 158
  __cil_tmp10 = cio_tell(cio);
#line 158
  len = __cil_tmp10 - lenp;
#line 159
  cio_seek(cio, lenp);
#line 160
  cio_write(cio, (unsigned long long )len, 4);
#line 161
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 164 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int i ;
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 169
  lenp = cio_tell(cio);
#line 170
  cio_skip(cio, 4);
#line 171
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 173
  cio_write(cio, (unsigned long long )((cstr_info.main_head_end - cstr_info.main_head_start) + 1),
            8);
#line 175
  i = 1;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < cstr_info.marknum)) {
#line 175
      goto while_break;
    }
    {
#line 176
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->type, 2);
#line 177
    cio_write(cio, (unsigned long long )0, 2);
#line 178
    cio_write(cio, (unsigned long long )((cstr_info.marker + i)->pos - coff), 8);
#line 179
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->len, 2);
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  __cil_tmp9 = cio_tell(cio);
#line 182
  len = __cil_tmp9 - lenp;
#line 183
  cio_seek(cio, lenp);
#line 184
  cio_write(cio, (unsigned long long )len, 4);
#line 185
  cio_seek(cio, lenp + len);
  }
#line 187
  return (len);
}
}
#line 190 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cidx_manager.c"
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) 
{ 
  opj_bool EPHused ;
  int i ;
  int org_pos ;
  unsigned int Scod ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 192
  EPHused = 0;
#line 193
  i = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < marknum)) {
#line 197
      goto while_break;
    }
#line 198
    if ((int )(markers + i)->type == 65362) {
      {
#line 199
      org_pos = cio_tell(cio);
#line 200
      cio_seek(cio, (coff + (markers + i)->pos) + 2);
#line 202
      Scod = cio_read(cio, 1);
      }
#line 203
      if ((Scod >> 2) & 1U) {
#line 204
        EPHused = 1;
      }
      {
#line 205
      cio_seek(cio, org_pos);
      }
#line 207
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (EPHused);
}
}
#line 40 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) 
{ 
  int nplh[32] ;
  int nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *parentnode ;
  opj_tgt_node_t *parentnode0 ;
  opj_tgt_tree_t *tree ;
  int i ;
  int j ;
  int k ;
  int numlvls ;
  int n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 43
  node = (opj_tgt_node_t *)((void *)0);
#line 44
  parentnode = (opj_tgt_node_t *)((void *)0);
#line 45
  parentnode0 = (opj_tgt_node_t *)((void *)0);
#line 46
  tree = (opj_tgt_tree_t *)((void *)0);
#line 51
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 51
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 52
  if (! tree) {
#line 52
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 53
  tree->numleafsh = numleafsh;
#line 54
  tree->numleafsv = numleafsv;
#line 56
  numlvls = 0;
#line 57
  nplh[0] = numleafsh;
#line 58
  nplv[0] = numleafsv;
#line 59
  tree->numnodes = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    n = nplh[numlvls] * nplv[numlvls];
#line 62
    nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
#line 63
    nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
#line 64
    tree->numnodes += n;
#line 65
    numlvls ++;
#line 60
    if (! (n > 1)) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (tree->numnodes == 0) {
    {
#line 70
    free(tree);
    }
#line 71
    return ((opj_tgt_tree_t *)((void *)0));
  }
  {
#line 74
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 74
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 75
  if (! tree->nodes) {
    {
#line 76
    free(tree);
    }
#line 77
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 80
  node = tree->nodes;
#line 81
  parentnode = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 82
  parentnode0 = parentnode;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < numlvls - 1)) {
#line 84
      goto while_break___0;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! (j < nplv[i])) {
#line 85
        goto while_break___1;
      }
#line 86
      k = nplh[i];
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        k --;
#line 87
        if (! (k >= 0)) {
#line 87
          goto while_break___2;
        }
#line 88
        node->parent = parentnode;
#line 89
        node ++;
#line 90
        k --;
#line 90
        if (k >= 0) {
#line 91
          node->parent = parentnode;
#line 92
          node ++;
        }
#line 94
        parentnode ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 96
      if (j & 1) {
#line 97
        parentnode0 = parentnode;
      } else
#line 96
      if (j == nplv[i] - 1) {
#line 97
        parentnode0 = parentnode;
      } else {
#line 99
        parentnode = parentnode0;
#line 100
        parentnode0 += nplh[i];
      }
#line 85
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 84
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  node->parent = (struct opj_tgt_node *)0;
#line 106
  tgt_reset(tree);
  }
#line 108
  return (tree);
}
}
#line 111 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
void tgt_destroy(opj_tgt_tree_t *tree ) 
{ 


  {
  {
#line 112
  free(tree->nodes);
#line 113
  free(tree);
  }
  return;
}
}
#line 116 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
void tgt_reset(opj_tgt_tree_t *tree ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 119
  if ((void *)0 == tree) {
#line 120
    return;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < tree->numnodes)) {
#line 122
      goto while_break;
    }
#line 123
    (tree->nodes + i)->value = 999;
#line 124
    (tree->nodes + i)->low = 0;
#line 125
    (tree->nodes + i)->known = 0;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 129 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 131
  node = tree->nodes + leafno;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (node && node->value > value)) {
#line 132
      goto while_break;
    }
#line 133
    node->value = value;
#line 134
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 138 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 144
  stkptr = (opj_tgt_node_t **)stk;
#line 145
  node = tree->nodes + leafno;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! node->parent) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp9 = stkptr;
#line 147
    stkptr ++;
#line 147
    *__cil_tmp9 = node;
#line 148
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  low = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! 1) {
#line 152
      goto while_break___0;
    }
#line 153
    if (low > node->low) {
#line 154
      node->low = low;
    } else {
#line 156
      low = node->low;
    }
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (low < threshold)) {
#line 159
        goto while_break___1;
      }
#line 160
      if (low >= node->value) {
#line 161
        if (! node->known) {
          {
#line 162
          bio_write(bio, 1, 1);
#line 163
          node->known = 1;
          }
        }
#line 165
        goto while_break___1;
      }
      {
#line 167
      bio_write(bio, 0, 1);
#line 168
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    node->low = low;
#line 172
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 173
      goto while_break___0;
    }
#line 174
    stkptr --;
#line 174
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 178 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tgt.c"
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 184
  stkptr = (opj_tgt_node_t **)stk;
#line 185
  node = tree->nodes + leafno;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! node->parent) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp9 = stkptr;
#line 187
    stkptr ++;
#line 187
    *__cil_tmp9 = node;
#line 188
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  low = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! 1) {
#line 192
      goto while_break___0;
    }
#line 193
    if (low > node->low) {
#line 194
      node->low = low;
    } else {
#line 196
      low = node->low;
    }
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (low < threshold && low < node->value)) {
#line 198
        goto while_break___1;
      }
      {
#line 199
      __cil_tmp10 = bio_read(bio, 1);
      }
#line 199
      if (__cil_tmp10) {
#line 200
        node->value = low;
      } else {
#line 202
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    node->low = low;
#line 206
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 207
      goto while_break___0;
    }
#line 209
    stkptr --;
#line 209
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  if (node->value < threshold) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 37 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 40
  fprintf(fd, "image {\n\220");
#line 41
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 44
  tileno = 0;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (tileno < img->th * img->tw)) {
#line 44
      goto while_break;
    }
    {
#line 45
    tile = (tcd->tcd_image)->tiles + tileno;
#line 46
    fprintf(fd, "  tile {\n");
#line 47
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 49
    compno = 0;
    }
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! (compno < tile->numcomps)) {
#line 49
        goto while_break___0;
      }
      {
#line 50
      tilec = tile->comps + compno;
#line 51
      fprintf(fd, "    tilec {\n");
#line 52
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 55
      resno = 0;
      }
      {
#line 55
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 55
        if (! (resno < tilec->numresolutions)) {
#line 55
          goto while_break___1;
        }
        {
#line 56
        res = tilec->resolutions + resno;
#line 57
        fprintf(fd, "\n   res {\n");
#line 58
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 61
        bandno = 0;
        }
        {
#line 61
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 61
          if (! (bandno < res->numbands)) {
#line 61
            goto while_break___2;
          }
          {
#line 62
          band = & res->bands[bandno];
#line 63
          fprintf(fd, "        band {\n");
#line 64
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 67
          precno = 0;
          }
          {
#line 67
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 67
            if (! (precno < res->pw * res->ph)) {
#line 67
              goto while_break___3;
            }
            {
#line 68
            prec = band->precincts + precno;
#line 69
            fprintf(fd, "          prec {\n");
#line 70
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 83
            fprintf(fd, "          }\n");
            }
#line 67
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 85
          fprintf(fd, "        }\n");
          }
#line 61
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 87
        fprintf(fd, "      }\n\220");
        }
#line 55
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 89
      fprintf(fd, "    }\n");
      }
#line 49
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 91
    fprintf(fd, "  }\n");
    }
#line 44
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 101 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 103
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 103
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 104
  if (! tcd) {
#line 104
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 105
  tcd->cinfo = cinfo;
#line 106
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 106
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 107
  if (! tcd->tcd_image) {
    {
#line 108
    free(tcd);
    }
#line 109
    return ((opj_tcd_t *)((void *)0));
  }
#line 112
  return (tcd);
}
}
#line 118 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 119
  if (tcd) {
    {
#line 120
    free(tcd->tcd_image);
#line 121
    free(tcd);
    }
  }
  return;
}
}
#line 127 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int __cil_tmp88 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;

  {
  {
#line 130
  tcd->image = image;
#line 131
  tcd->cp = cp;
#line 132
  (tcd->tcd_image)->tw = cp->tw;
#line 133
  (tcd->tcd_image)->th = cp->th;
#line 134
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 134
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 136
  tileno = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (tileno < 1)) {
#line 136
      goto while_break;
    }
    {
#line 137
    tcp = cp->tcps + curtileno;
#line 141
    p = curtileno % cp->tw;
#line 142
    q = curtileno / cp->tw;
#line 145
    tile = (tcd->tcd_image)->tiles;
#line 148
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 149
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 150
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 151
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 152
    tile->numcomps = image->numcomps;
#line 156
    j = 0;
    }
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (! (j < tcp->numlayers)) {
#line 156
        goto while_break___0;
      }
#line 157
      if (tcp->rates[j]) {
#line 157
        if ((int )cp->tp_on) {
#line 157
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 157
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 157
        tmp___0 = tmp;
      } else {
#line 157
        tmp___0 = (float )0;
      }
#line 157
      tcp->rates[j] = tmp___0;
#line 172
      if (tcp->rates[j]) {
#line 173
        if (j) {
#line 173
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 174
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 173
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 176
        if (! j) {
#line 176
          if (tcp->rates[j] < (float )30) {
#line 177
            tcp->rates[j] = (float )30;
          }
        }
#line 180
        if (j == tcp->numlayers - 1) {
#line 181
          tcp->rates[j] -= (float )2;
        }
      }
#line 156
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 187
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 187
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 188
    compno = 0;
    }
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (! (compno < tile->numcomps)) {
#line 188
        goto while_break___1;
      }
      {
#line 189
      tccp = tcp->tccps + compno;
#line 191
      tilec = tile->comps + compno;
#line 194
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 195
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 196
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 197
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 199
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 199
      tilec->data = (int *)__cil_tmp31;
#line 200
      tilec->numresolutions = tccp->numresolutions;
#line 202
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 202
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 204
      resno = 0;
      }
      {
#line 204
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 204
        if (! (resno < tilec->numresolutions)) {
#line 204
          goto while_break___2;
        }
        {
#line 206
        levelno = (tilec->numresolutions - 1) - resno;
#line 212
        res = tilec->resolutions + resno;
#line 215
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 216
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 217
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 218
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 220
        if (resno == 0) {
#line 220
          tmp___1 = 1;
        } else {
#line 220
          tmp___1 = 3;
        }
#line 220
        res->numbands = tmp___1;
#line 222
        if (tccp->csty & 1) {
#line 223
          pdx = tccp->prcw[resno];
#line 224
          pdy = tccp->prch[resno];
        } else {
#line 226
          pdx = 15;
#line 227
          pdy = 15;
        }
        {
#line 230
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 230
        tlprcxstart = __cil_tmp54 << pdx;
#line 231
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 231
        tlprcystart = __cil_tmp55 << pdy;
#line 233
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 233
        brprcxend = __cil_tmp56 << pdx;
#line 234
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 234
        brprcyend = __cil_tmp57 << pdy;
#line 236
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 237
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 239
        if (resno == 0) {
#line 240
          tlcbgxstart = tlprcxstart;
#line 241
          tlcbgystart = tlprcystart;
#line 242
          brcbgxend = brprcxend;
#line 243
          brcbgyend = brprcyend;
#line 244
          cbgwidthexpn = pdx;
#line 245
          cbgheightexpn = pdy;
        } else {
          {
#line 247
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 248
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 249
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 250
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 251
          cbgwidthexpn = pdx - 1;
#line 252
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 257
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 258
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 260
        bandno = 0;
        }
        {
#line 260
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 260
          if (! (bandno < res->numbands)) {
#line 260
            goto while_break___3;
          }
#line 263
          ss = (opj_stepsize_t *)((void *)0);
#line 265
          band = & res->bands[bandno];
#line 267
          if (resno == 0) {
#line 267
            tmp___2 = 0;
          } else {
#line 267
            tmp___2 = bandno + 1;
          }
#line 267
          band->bandno = tmp___2;
#line 268
          if (band->bandno == 1 || band->bandno == 3) {
#line 268
            tmp___3 = 1;
          } else {
#line 268
            tmp___3 = 0;
          }
#line 268
          x0b = tmp___3;
#line 269
          if (band->bandno == 2 || band->bandno == 3) {
#line 269
            tmp___4 = 1;
          } else {
#line 269
            tmp___4 = 0;
          }
#line 269
          y0b = tmp___4;
#line 271
          if (band->bandno == 0) {
            {
#line 273
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 274
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 275
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 276
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 279
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 280
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 281
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 282
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 285
          if (resno == 0) {
#line 285
            tmp___5 = 0;
          } else {
#line 285
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 285
          ss = & tccp->stepsizes[tmp___5];
#line 286
          if (tccp->qmfbid == 0) {
            {
#line 286
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 286
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 286
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 286
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 286
          gain = tmp___6;
#line 287
          numbps = (image->comps + compno)->prec + gain;
#line 289
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 289
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 290
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 292
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 292
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 294
          i = 0;
          }
          {
#line 294
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 294
            if (! (i < (res->pw * res->ph) * 3)) {
#line 294
              goto while_break___4;
            }
#line 295
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 296
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 297
            (band->precincts + i)->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 294
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 300
          precno = 0;
          {
#line 300
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 300
            if (! (precno < res->pw * res->ph)) {
#line 300
              goto while_break___5;
            }
            {
#line 303
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 304
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 305
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 306
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 308
            prc = band->precincts + precno;
#line 311
            prc->x0 = int_max(cbgxstart, band->x0);
#line 312
            prc->y0 = int_max(cbgystart, band->y0);
#line 313
            prc->x1 = int_min(cbgxend, band->x1);
#line 314
            prc->y1 = int_min(cbgyend, band->y1);
#line 316
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 316
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 317
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 317
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 318
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 318
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 319
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 319
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 320
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 321
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 323
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 323
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 324
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 325
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 327
            cblkno = 0;
            }
            {
#line 327
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 327
              if (! (cblkno < prc->cw * prc->ch)) {
#line 327
                goto while_break___6;
              }
              {
#line 328
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 329
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 330
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 331
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 333
              cblk = prc->cblks.enc + cblkno;
#line 336
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 337
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 338
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 339
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 340
              __cil_tmp118 = calloc((unsigned long )9730, sizeof(unsigned char ));
#line 340
              cblk->data = (unsigned char *)__cil_tmp118;
#line 342
              *(cblk->data + 0) = (unsigned char )0;
#line 343
              *(cblk->data + 1) = (unsigned char )0;
#line 344
              cblk->data += 2;
#line 345
              __cil_tmp119 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 345
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 346
              __cil_tmp120 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 346
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
              }
#line 327
              cblkno ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 300
            precno ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 260
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 204
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 188
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 136
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 357 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 360
  tileno = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (tileno < 1)) {
#line 360
      goto while_break;
    }
#line 361
    tile = (tcd->tcd_image)->tiles;
#line 363
    compno = 0;
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      if (! (compno < tile->numcomps)) {
#line 363
        goto while_break___0;
      }
#line 364
      tilec = tile->comps + compno;
#line 366
      resno = 0;
      {
#line 366
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 366
        if (! (resno < tilec->numresolutions)) {
#line 366
          goto while_break___1;
        }
#line 367
        res = tilec->resolutions + resno;
#line 369
        bandno = 0;
        {
#line 369
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 369
          if (! (bandno < res->numbands)) {
#line 369
            goto while_break___2;
          }
#line 370
          band = & res->bands[bandno];
#line 372
          precno = 0;
          {
#line 372
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 372
            if (! (precno < res->pw * res->ph)) {
#line 372
              goto while_break___3;
            }
#line 373
            prc = band->precincts + precno;
#line 375
            if (prc->incltree != (void *)0) {
              {
#line 376
              tgt_destroy(prc->incltree);
#line 377
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 379
            if (prc->imsbtree != (void *)0) {
              {
#line 380
              tgt_destroy(prc->imsbtree);
#line 381
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 383
            cblkno = 0;
            {
#line 383
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 383
              if (! (cblkno < prc->cw * prc->ch)) {
#line 383
                goto while_break___4;
              }
              {
#line 384
              free((prc->cblks.enc + cblkno)->data - 2);
#line 385
              free((prc->cblks.enc + cblkno)->layers);
#line 386
              free((prc->cblks.enc + cblkno)->passes);
              }
#line 383
              cblkno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 388
            free(prc->cblks.enc);
            }
#line 372
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 390
          free(band->precincts);
#line 391
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
          }
#line 369
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 366
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 394
      free(tilec->resolutions);
#line 395
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
      }
#line 363
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 397
    free(tile->comps);
#line 398
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
#line 360
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  free((tcd->tcd_image)->tiles);
#line 401
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
  return;
}
}
#line 404 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp22 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  opj_tgt_tree_t *__cil_tmp101 ;
  opj_tgt_tree_t *__cil_tmp102 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;

  {
#line 407
  tileno = 0;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (tileno < 1)) {
#line 407
      goto while_break;
    }
    {
#line 408
    tcp = cp->tcps + curtileno;
#line 411
    p = curtileno % cp->tw;
#line 412
    q = curtileno / cp->tw;
#line 414
    tile = (tcd->tcd_image)->tiles;
#line 417
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 418
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 419
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 420
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 422
    tile->numcomps = image->numcomps;
#line 426
    j = 0;
    }
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! (j < tcp->numlayers)) {
#line 426
        goto while_break___0;
      }
#line 427
      if (tcp->rates[j]) {
#line 427
        if ((int )cp->tp_on) {
#line 427
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 427
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 427
        tmp___0 = tmp;
      } else {
#line 427
        tmp___0 = (float )0;
      }
#line 427
      tcp->rates[j] = tmp___0;
#line 442
      if (tcp->rates[j]) {
#line 443
        if (j) {
#line 443
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 444
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 443
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 446
        if (! j) {
#line 446
          if (tcp->rates[j] < (float )30) {
#line 447
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 426
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 454
    compno = 0;
    {
#line 454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 454
      if (! (compno < tile->numcomps)) {
#line 454
        goto while_break___1;
      }
      {
#line 455
      tccp = tcp->tccps + compno;
#line 457
      tilec = tile->comps + compno;
#line 460
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 461
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 462
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 463
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 465
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 465
      tilec->data = (int *)__cil_tmp29;
#line 466
      tilec->numresolutions = tccp->numresolutions;
#line 468
      resno = 0;
      }
      {
#line 468
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 468
        if (! (resno < tilec->numresolutions)) {
#line 468
          goto while_break___2;
        }
        {
#line 471
        levelno = (tilec->numresolutions - 1) - resno;
#line 477
        res = tilec->resolutions + resno;
#line 480
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 481
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 482
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 483
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 484
        if (resno == 0) {
#line 484
          tmp___1 = 1;
        } else {
#line 484
          tmp___1 = 3;
        }
#line 484
        res->numbands = tmp___1;
#line 487
        if (tccp->csty & 1) {
#line 488
          pdx = tccp->prcw[resno];
#line 489
          pdy = tccp->prch[resno];
        } else {
#line 491
          pdx = 15;
#line 492
          pdy = 15;
        }
        {
#line 495
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 495
        tlprcxstart = __cil_tmp51 << pdx;
#line 496
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 496
        tlprcystart = __cil_tmp52 << pdy;
#line 497
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 497
        brprcxend = __cil_tmp53 << pdx;
#line 498
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 498
        brprcyend = __cil_tmp54 << pdy;
#line 500
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 501
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 503
        if (resno == 0) {
#line 504
          tlcbgxstart = tlprcxstart;
#line 505
          tlcbgystart = tlprcystart;
#line 506
          brcbgxend = brprcxend;
#line 507
          brcbgyend = brprcyend;
#line 508
          cbgwidthexpn = pdx;
#line 509
          cbgheightexpn = pdy;
        } else {
          {
#line 511
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 512
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 513
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 514
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 515
          cbgwidthexpn = pdx - 1;
#line 516
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 521
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 522
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 524
        bandno = 0;
        }
        {
#line 524
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 524
          if (! (bandno < res->numbands)) {
#line 524
            goto while_break___3;
          }
#line 527
          ss = (opj_stepsize_t *)((void *)0);
#line 529
          band = & res->bands[bandno];
#line 531
          if (resno == 0) {
#line 531
            tmp___2 = 0;
          } else {
#line 531
            tmp___2 = bandno + 1;
          }
#line 531
          band->bandno = tmp___2;
#line 532
          if (band->bandno == 1 || band->bandno == 3) {
#line 532
            tmp___3 = 1;
          } else {
#line 532
            tmp___3 = 0;
          }
#line 532
          x0b = tmp___3;
#line 533
          if (band->bandno == 2 || band->bandno == 3) {
#line 533
            tmp___4 = 1;
          } else {
#line 533
            tmp___4 = 0;
          }
#line 533
          y0b = tmp___4;
#line 535
          if (band->bandno == 0) {
            {
#line 537
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 538
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 539
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 540
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 542
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 543
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 544
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 545
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 548
          if (resno == 0) {
#line 548
            tmp___5 = 0;
          } else {
#line 548
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 548
          ss = & tccp->stepsizes[tmp___5];
#line 549
          if (tccp->qmfbid == 0) {
            {
#line 549
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 549
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 549
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 549
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 549
          gain = tmp___6;
#line 550
          numbps = (image->comps + compno)->prec + gain;
#line 551
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 551
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 552
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 554
          precno = 0;
          }
          {
#line 554
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 554
            if (! (precno < res->pw * res->ph)) {
#line 554
              goto while_break___4;
            }
            {
#line 557
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 558
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 559
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 560
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 562
            prc = band->precincts + precno;
#line 565
            prc->x0 = int_max(cbgxstart, band->x0);
#line 566
            prc->y0 = int_max(cbgystart, band->y0);
#line 567
            prc->x1 = int_min(cbgxend, band->x1);
#line 568
            prc->y1 = int_min(cbgyend, band->y1);
#line 570
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 570
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 571
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 571
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 572
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 572
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 573
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 573
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 574
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 575
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 577
            free(prc->cblks.enc);
#line 578
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 578
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 580
            if (prc->incltree != (void *)0) {
              {
#line 581
              tgt_destroy(prc->incltree);
              }
            }
#line 583
            if (prc->imsbtree != (void *)0) {
              {
#line 584
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 587
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 588
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 590
            cblkno = 0;
            }
            {
#line 590
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 590
              if (! (cblkno < prc->cw * prc->ch)) {
#line 590
                goto while_break___5;
              }
              {
#line 591
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 592
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 593
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 594
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 596
              cblk = prc->cblks.enc + cblkno;
#line 599
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 600
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 601
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 602
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 603
              __cil_tmp112 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 603
              cblk->data = (unsigned char *)__cil_tmp112;
#line 605
              *(cblk->data + 0) = (unsigned char )0;
#line 606
              *(cblk->data + 1) = (unsigned char )0;
#line 607
              cblk->data += 2;
#line 608
              __cil_tmp113 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 608
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 609
              __cil_tmp114 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 609
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
              }
#line 590
              cblkno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 554
            precno ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 524
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 468
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 454
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 407
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 620 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
#line 622
  x0 = (unsigned int )0;
#line 622
  y0___0 = (unsigned int )0;
#line 622
  x1 = (unsigned int )0;
  {
#line 622
  y1___0 = (unsigned int )0;
#line 624
  tcd->image = image;
#line 625
  (tcd->tcd_image)->tw = cp->tw;
#line 626
  (tcd->tcd_image)->th = cp->th;
#line 627
  __cil_tmp15 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcd_tile_t ));
#line 627
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 634
  j = 0;
  }
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (! (j < cp->tileno_size)) {
#line 634
      goto while_break;
    }
    {
#line 637
    tileno = *(cp->tileno + j);
#line 638
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 639
    tile->numcomps = image->numcomps;
#line 640
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 640
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
    }
#line 634
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  i = 0;
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! (i < image->numcomps)) {
#line 643
      goto while_break___0;
    }
#line 644
    j = 0;
    {
#line 644
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 644
      if (! (j < cp->tileno_size)) {
#line 644
        goto while_break___1;
      }
      {
#line 650
      tileno = *(cp->tileno + j);
#line 652
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 653
      tilec = tile___0->comps + i;
#line 655
      p = tileno % cp->tw;
#line 656
      q = tileno / cp->tw;
#line 659
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 660
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 661
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 662
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 664
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 665
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 666
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 667
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 669
      if (j == 0) {
#line 669
        tmp = tilec->x0;
      } else {
        {
#line 669
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 669
        tmp = __cil_tmp29;
        }
      }
#line 669
      x0 = (unsigned int )tmp;
#line 670
      if (j == 0) {
#line 670
        tmp___0 = tilec->y0;
      } else {
        {
#line 670
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->y0));
#line 670
        tmp___0 = __cil_tmp31;
        }
      }
#line 670
      y0___0 = (unsigned int )tmp___0;
#line 671
      if (j == 0) {
#line 671
        tmp___1 = tilec->x1;
      } else {
        {
#line 671
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 671
        tmp___1 = __cil_tmp33;
        }
      }
#line 671
      x1 = (unsigned int )tmp___1;
#line 672
      if (j == 0) {
#line 672
        tmp___2 = tilec->y1;
      } else {
        {
#line 672
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 672
        tmp___2 = __cil_tmp35;
        }
      }
#line 672
      y1___0 = (unsigned int )tmp___2;
#line 644
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 675
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 675
    w = (unsigned int )__cil_tmp38;
#line 676
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 676
    h = (unsigned int )__cil_tmp39;
#line 678
    (image->comps + i)->w = (int )w;
#line 679
    (image->comps + i)->h = (int )h;
#line 680
    (image->comps + i)->x0 = (int )x0;
#line 681
    (image->comps + i)->y0 = (int )y0___0;
    }
#line 643
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 685 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tgt_tree_t *__cil_tmp94 ;
  opj_tgt_tree_t *__cil_tmp95 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 692
  tcd->cp = cp;
#line 694
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 695
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 697
  tileno = *(cp->tileno + tileno);
#line 699
  compno = 0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! (compno < tile->numcomps)) {
#line 699
      goto while_break;
    }
#line 700
    tccp = tcp->tccps + compno;
#line 701
    tilec = tile->comps + compno;
#line 703
    if (tccp->numresolutions <= 0) {
#line 705
      *(cp->tileno + tileno) = - 1;
#line 706
      return;
    }
    {
#line 710
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 711
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 712
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 713
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 715
    tilec->numresolutions = tccp->numresolutions;
#line 716
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 716
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 718
    resno = 0;
    }
    {
#line 718
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 718
      if (! (resno < tilec->numresolutions)) {
#line 718
        goto while_break___0;
      }
      {
#line 720
      levelno = (tilec->numresolutions - 1) - resno;
#line 726
      res = tilec->resolutions + resno;
#line 729
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 730
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 731
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 732
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 733
      if (resno == 0) {
#line 733
        tmp = 1;
      } else {
#line 733
        tmp = 3;
      }
#line 733
      res->numbands = tmp;
#line 736
      if (tccp->csty & 1) {
#line 737
        pdx = tccp->prcw[resno];
#line 738
        pdy = tccp->prch[resno];
      } else {
#line 740
        pdx = 15;
#line 741
        pdy = 15;
      }
      {
#line 745
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 745
      tlprcxstart = __cil_tmp41 << pdx;
#line 746
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 746
      tlprcystart = __cil_tmp42 << pdy;
#line 747
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 747
      brprcxend = __cil_tmp43 << pdx;
#line 748
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 748
      brprcyend = __cil_tmp44 << pdy;
      }
#line 750
      if (res->x0 == res->x1) {
#line 750
        tmp___0 = 0;
      } else {
#line 750
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 750
      res->pw = tmp___0;
#line 751
      if (res->y0 == res->y1) {
#line 751
        tmp___1 = 0;
      } else {
#line 751
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 751
      res->ph = tmp___1;
#line 753
      if (resno == 0) {
#line 754
        tlcbgxstart = tlprcxstart;
#line 755
        tlcbgystart = tlprcystart;
#line 756
        brcbgxend = brprcxend;
#line 757
        brcbgyend = brprcyend;
#line 758
        cbgwidthexpn = pdx;
#line 759
        cbgheightexpn = pdy;
      } else {
        {
#line 761
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 762
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 763
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 764
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 765
        cbgwidthexpn = pdx - 1;
#line 766
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 771
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 772
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 774
      bandno = 0;
      }
      {
#line 774
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 774
        if (! (bandno < res->numbands)) {
#line 774
          goto while_break___1;
        }
#line 777
        ss = (opj_stepsize_t *)((void *)0);
#line 779
        band = & res->bands[bandno];
#line 780
        if (resno == 0) {
#line 780
          tmp___2 = 0;
        } else {
#line 780
          tmp___2 = bandno + 1;
        }
#line 780
        band->bandno = tmp___2;
#line 781
        if (band->bandno == 1 || band->bandno == 3) {
#line 781
          tmp___3 = 1;
        } else {
#line 781
          tmp___3 = 0;
        }
#line 781
        x0b = tmp___3;
#line 782
        if (band->bandno == 2 || band->bandno == 3) {
#line 782
          tmp___4 = 1;
        } else {
#line 782
          tmp___4 = 0;
        }
#line 782
        y0b = tmp___4;
#line 784
        if (band->bandno == 0) {
          {
#line 786
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 787
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 788
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 789
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 792
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 793
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 794
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 795
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 798
        if (resno == 0) {
#line 798
          tmp___5 = 0;
        } else {
#line 798
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 798
        ss = & tccp->stepsizes[tmp___5];
#line 799
        if (tccp->qmfbid == 0) {
          {
#line 799
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 799
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 799
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 799
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 799
        gain = tmp___6;
#line 800
        numbps = (image->comps + compno)->prec + gain;
#line 801
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 801
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 802
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 804
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 804
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 806
        precno = 0;
        }
        {
#line 806
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 806
          if (! (precno < res->pw * res->ph)) {
#line 806
            goto while_break___2;
          }
          {
#line 808
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 809
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 810
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 811
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 813
          prc = band->precincts + precno;
#line 815
          prc->x0 = int_max(cbgxstart, band->x0);
#line 816
          prc->y0 = int_max(cbgystart, band->y0);
#line 817
          prc->x1 = int_min(cbgxend, band->x1);
#line 818
          prc->y1 = int_min(cbgyend, band->y1);
#line 820
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 820
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 821
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 821
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 822
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 822
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 823
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 823
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 824
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 825
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 827
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 827
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 829
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 830
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 832
          cblkno = 0;
          }
          {
#line 832
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 832
            if (! (cblkno < prc->cw * prc->ch)) {
#line 832
              goto while_break___3;
            }
            {
#line 833
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 834
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 835
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 836
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 838
            cblk = prc->cblks.dec + cblkno;
#line 839
            cblk->data = (unsigned char *)((void *)0);
#line 840
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 842
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 843
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 844
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 845
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 846
            cblk->numsegs = 0;
            }
#line 832
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 806
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 774
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 718
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 699
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 855 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 861
  cp = tcd->cp;
#line 862
  tcd_tile = tcd->tcd_tile;
#line 863
  tcd_tcp = tcd->tcp;
#line 867
  compno = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (compno < tcd_tile->numcomps)) {
#line 867
      goto while_break;
    }
#line 868
    tilec = tcd_tile->comps + compno;
#line 869
    i = 0;
    {
#line 869
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 869
      if (! (i < tcd_tcp->numlayers)) {
#line 869
        goto while_break___0;
      }
#line 870
      j = 0;
      {
#line 870
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 870
        if (! (j < tilec->numresolutions)) {
#line 870
          goto while_break___1;
        }
#line 871
        k = 0;
        {
#line 871
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 871
          if (! (k < 3)) {
#line 871
            goto while_break___2;
          }
#line 872
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 871
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 870
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 869
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 879
    resno = 0;
    {
#line 879
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 879
      if (! (resno < tilec->numresolutions)) {
#line 879
        goto while_break___3;
      }
#line 880
      res = tilec->resolutions + resno;
#line 881
      bandno = 0;
      {
#line 881
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 881
        if (! (bandno < res->numbands)) {
#line 881
          goto while_break___4;
        }
#line 882
        band = & res->bands[bandno];
#line 883
        precno = 0;
        {
#line 883
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 883
          if (! (precno < res->pw * res->ph)) {
#line 883
            goto while_break___5;
          }
#line 884
          prc = band->precincts + precno;
#line 885
          cblkno = 0;
          {
#line 885
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 885
            if (! (cblkno < prc->cw * prc->ch)) {
#line 885
              goto while_break___6;
            }
#line 886
            cblk = prc->cblks.enc + cblkno;
#line 887
            layer = cblk->layers + layno;
#line 889
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 891
            if (layno == 0) {
#line 892
              value = matrice[layno][resno][bandno];
#line 893
              if (imsb >= value) {
#line 894
                value = 0;
              } else {
#line 896
                value -= imsb;
              }
            } else {
#line 899
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 900
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 901
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 902
                if (value < 0) {
#line 903
                  value = 0;
                }
              }
            }
#line 908
            if (layno == 0) {
#line 909
              cblk->numpassesinlayers = 0;
            }
#line 912
            n = cblk->numpassesinlayers;
#line 913
            if (cblk->numpassesinlayers == 0) {
#line 914
              if (value != 0) {
#line 915
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 917
                n = cblk->numpassesinlayers;
              }
            } else {
#line 920
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 923
            layer->numpasses = n - cblk->numpassesinlayers;
#line 925
            if (! layer->numpasses) {
#line 926
              goto while_continue___6;
            }
#line 928
            if (cblk->numpassesinlayers == 0) {
#line 929
              layer->len = (cblk->passes + (n - 1))->rate;
#line 930
              layer->data = cblk->data;
            } else {
#line 932
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 933
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 935
            if (final) {
#line 936
              cblk->numpassesinlayers = n;
            }
#line 885
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 883
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 881
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 879
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 867
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 944 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;
  int __cil_tmp3 ;

  {
#line 946
  layno = 0;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 946
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 946
      goto while_break;
    }
    {
#line 947
    tcd_makelayer_fixed(tcd, layno, 1);
    }
#line 946
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 951 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
#line 954
  tcd_tile = tcd->tcd_tile;
#line 956
  tcd_tile->distolayer[layno] = (double )0;
#line 958
  compno = 0;
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! (compno < tcd_tile->numcomps)) {
#line 958
      goto while_break;
    }
#line 959
    tilec = tcd_tile->comps + compno;
#line 960
    resno = 0;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 960
      if (! (resno < tilec->numresolutions)) {
#line 960
        goto while_break___0;
      }
#line 961
      res = tilec->resolutions + resno;
#line 962
      bandno = 0;
      {
#line 962
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 962
        if (! (bandno < res->numbands)) {
#line 962
          goto while_break___1;
        }
#line 963
        band = & res->bands[bandno];
#line 964
        precno = 0;
        {
#line 964
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 964
          if (! (precno < res->pw * res->ph)) {
#line 964
            goto while_break___2;
          }
#line 965
          prc = band->precincts + precno;
#line 966
          cblkno = 0;
          {
#line 966
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 966
            if (! (cblkno < prc->cw * prc->ch)) {
#line 966
              goto while_break___3;
            }
#line 967
            cblk = prc->cblks.enc + cblkno;
#line 968
            layer = cblk->layers + layno;
#line 971
            if (layno == 0) {
#line 972
              cblk->numpassesinlayers = 0;
            }
#line 974
            n = cblk->numpassesinlayers;
#line 975
            passno = cblk->numpassesinlayers;
            {
#line 975
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 975
              if (! (passno < cblk->totalpasses)) {
#line 975
                goto while_break___4;
              }
#line 978
              pass = cblk->passes + passno;
#line 979
              if (n == 0) {
#line 980
                dr = pass->rate;
#line 981
                dd = pass->distortiondec;
              } else {
#line 983
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 984
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 986
              if (! dr) {
#line 987
                if (dd != (double )0) {
#line 988
                  n = passno + 1;
                }
#line 989
                goto while_continue___4;
              }
#line 991
              if (dd / (double )dr >= thresh) {
#line 992
                n = passno + 1;
              }
#line 975
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 994
            layer->numpasses = n - cblk->numpassesinlayers;
#line 996
            if (! layer->numpasses) {
#line 997
              layer->disto = (double )0;
#line 998
              goto while_continue___3;
            }
#line 1000
            if (cblk->numpassesinlayers == 0) {
#line 1001
              layer->len = (cblk->passes + (n - 1))->rate;
#line 1002
              layer->data = cblk->data;
#line 1003
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 1005
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1006
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1007
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 1010
            tcd_tile->distolayer[layno] += layer->disto;
#line 1012
            if (final) {
#line 1013
              cblk->numpassesinlayers = n;
            }
#line 966
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 964
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 962
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 960
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 958
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1021 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  int __cil_tmp54 ;
  double tmp___0 ;
  double tmp___1 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double tmp___2 ;
  double tmp___3 ;
  int __cil_tmp61 ;

  {
#line 1025
  K = (double )1;
#line 1026
  maxSE = (double )0;
#line 1028
  cp = tcd->cp;
#line 1029
  tcd_tile = tcd->tcd_tile;
#line 1030
  tcd_tcp = tcd->tcp;
#line 1032
  min = (double )1.79769313487e+308L;
#line 1033
  max = (double )0;
#line 1035
  tcd_tile->numpix = 0;
#line 1037
  compno = 0;
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! (compno < tcd_tile->numcomps)) {
#line 1037
      goto while_break;
    }
#line 1038
    tilec = tcd_tile->comps + compno;
#line 1039
    tilec->numpix = 0;
#line 1041
    resno = 0;
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1041
      if (! (resno < tilec->numresolutions)) {
#line 1041
        goto while_break___0;
      }
#line 1042
      res = tilec->resolutions + resno;
#line 1044
      bandno = 0;
      {
#line 1044
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1044
        if (! (bandno < res->numbands)) {
#line 1044
          goto while_break___1;
        }
#line 1045
        band = & res->bands[bandno];
#line 1047
        precno = 0;
        {
#line 1047
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1047
          if (! (precno < res->pw * res->ph)) {
#line 1047
            goto while_break___2;
          }
#line 1048
          prc = band->precincts + precno;
#line 1050
          cblkno = 0;
          {
#line 1050
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1050
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1050
              goto while_break___3;
            }
#line 1051
            cblk = prc->cblks.enc + cblkno;
#line 1053
            passno = 0;
            {
#line 1053
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1053
              if (! (passno < cblk->totalpasses)) {
#line 1053
                goto while_break___4;
              }
#line 1054
              pass = cblk->passes + passno;
#line 1057
              if (passno == 0) {
#line 1058
                dr = pass->rate;
#line 1059
                dd = pass->distortiondec;
              } else {
#line 1061
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1062
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1064
              if (dr == 0) {
#line 1065
                goto while_continue___4;
              }
#line 1067
              rdslope = dd / (double )dr;
#line 1068
              if (rdslope < min) {
#line 1069
                min = rdslope;
              }
#line 1071
              if (rdslope > max) {
#line 1072
                max = rdslope;
              }
#line 1053
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1077
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1078
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1050
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1047
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1044
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1041
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1084
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1037
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1090
  if (cstr_info) {
    {
#line 1091
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1092
    tile_info->numpix = tcd_tile->numpix;
#line 1093
    tile_info->distotile = tcd_tile->distotile;
#line 1094
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1094
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1097
  layno = 0;
  {
#line 1097
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1097
    if (! (layno < tcd_tcp->numlayers)) {
#line 1097
      goto while_break___5;
    }
#line 1098
    lo = min;
#line 1099
    hi = max;
#line 1100
    success = 0;
#line 1101
    if (tcd_tcp->rates[layno]) {
      {
#line 1101
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1101
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1101
      tmp = __cil_tmp42;
      }
    } else {
#line 1101
      tmp = len;
    }
    {
#line 1101
    maxlen = tmp;
#line 1102
    goodthresh = (double )0;
#line 1103
    stable_thresh = (double )0;
#line 1108
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1108
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp48;
    }
#line 1114
    if (cp->disto_alloc == 1) {
#line 1114
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: /* CIL Label */ 
        {
#line 1115
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1115
        t2 = __cil_tmp50;
#line 1116
        thresh = (double )0;
#line 1118
        i = 0;
        }
        {
#line 1118
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1118
          if (! (i < 128)) {
#line 1118
            goto while_break___6;
          }
          {
#line 1119
          l = 0;
#line 1120
          distoachieved = (double )0;
#line 1121
          thresh = (lo + hi) / (double )2;
#line 1123
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1125
          if (cp->fixed_quality) {
#line 1126
            if (cp->cinema) {
              {
#line 1127
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1128
              if (l == -999) {
#line 1129
                lo = thresh;
#line 1130
                goto while_continue___6;
              } else {
#line 1132
                if (layno == 0) {
#line 1132
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1132
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1132
                distoachieved = tmp___0;
#line 1134
                if (distoachieved < distotarget) {
#line 1135
                  hi = thresh;
#line 1136
                  stable_thresh = thresh;
#line 1137
                  goto while_continue___6;
                } else {
#line 1139
                  lo = thresh;
                }
              }
            } else {
#line 1143
              if (layno == 0) {
#line 1143
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1143
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1143
              distoachieved = tmp___1;
#line 1145
              if (distoachieved < distotarget) {
#line 1146
                hi = thresh;
#line 1147
                stable_thresh = thresh;
#line 1148
                goto while_continue___6;
              }
#line 1150
              lo = thresh;
            }
          } else {
            {
#line 1153
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1156
            if (l == -999) {
#line 1157
              lo = thresh;
#line 1158
              goto while_continue___6;
            }
#line 1160
            hi = thresh;
#line 1161
            stable_thresh = thresh;
          }
#line 1118
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1164
        success = 1;
#line 1165
        if (stable_thresh == (double )0) {
#line 1165
          tmp___2 = thresh;
        } else {
#line 1165
          tmp___2 = stable_thresh;
        }
        {
#line 1165
        goodthresh = tmp___2;
#line 1166
        t2_destroy(t2);
        }
      } else {
#line 1114
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1114
    if (cp->fixed_quality == 1) {
#line 1114
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1114
        goto _L;
      } else {
#line 1168
        success = 1;
#line 1169
        goodthresh = min;
      }
    } else {
#line 1168
      success = 1;
#line 1169
      goodthresh = min;
    }
#line 1172
    if (! success) {
#line 1173
      return (0);
    }
#line 1176
    if (cstr_info) {
#line 1177
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1179
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1182
    if (layno == 0) {
#line 1182
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1182
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1182
    cumdisto[layno] = tmp___3;
#line 1097
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1185
  return (1);
}
}
#line 1188 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int __cil_tmp50 ;
  opj_t1_t *__cil_tmp51 ;
  opj_t2_t *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  int __cil_tmp56 ;

  {
#line 1190
  numpacks = 0;
#line 1191
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1192
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1193
  cp = (opj_cp_t *)((void *)0);
#line 1195
  tcp = (tcd->cp)->tcps + 0;
#line 1196
  tccp = tcp->tccps + 0;
#line 1197
  image = tcd->image;
#line 1199
  t1 = (opj_t1_t *)((void *)0);
#line 1200
  t2 = (opj_t2_t *)((void *)0);
#line 1202
  tcd->tcd_tileno = tileno;
#line 1203
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1204
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1206
  tile = tcd->tcd_tile;
#line 1207
  tcd_tcp = tcd->tcp;
#line 1208
  cp = tcd->cp;
#line 1210
  if (tcd->cur_tp_num == 0) {
    {
#line 1211
    tcd->encoding_time = opj_clock();
    }
#line 1213
    if (cstr_info) {
#line 1214
      tilec_idx = tile->comps + 0;
#line 1215
      i = 0;
      {
#line 1215
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1215
        if (! (i < tilec_idx->numresolutions)) {
#line 1215
          goto while_break;
        }
#line 1216
        res_idx = tilec_idx->resolutions + i;
#line 1218
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1219
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1221
        numpacks += res_idx->pw * res_idx->ph;
#line 1223
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1224
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1215
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1226
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1226
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1232
    compno = 0;
    {
#line 1232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1232
      if (! (compno < tile->numcomps)) {
#line 1232
        goto while_break___0;
      }
#line 1235
      if ((image->comps + compno)->sgnd) {
#line 1235
        tmp = 0;
      } else {
#line 1235
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1235
      adjust = tmp;
#line 1236
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1236
      offset_x = __cil_tmp28;
#line 1237
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1237
      offset_y = __cil_tmp30;
#line 1239
      tilec = tile->comps + compno;
#line 1240
      tw = tilec->x1 - tilec->x0;
#line 1241
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1241
      w = __cil_tmp34;
      }
#line 1245
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1246
        y = tilec->y0;
        {
#line 1246
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1246
          if (! (y < tilec->y1)) {
#line 1246
            goto while_break___1;
          }
#line 1248
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1250
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1251
          x = tilec->x0;
          {
#line 1251
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1251
            if (! (x < tilec->x1)) {
#line 1251
              goto while_break___2;
            }
#line 1252
            __cil_tmp38 = data;
#line 1252
            data ++;
#line 1252
            __cil_tmp37 = tile_data;
#line 1252
            tile_data ++;
#line 1252
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1251
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1246
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1255
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1256
        y = tilec->y0;
        {
#line 1256
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1256
          if (! (y < tilec->y1)) {
#line 1256
            goto while_break___3;
          }
#line 1258
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1260
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1261
          x = tilec->x0;
          {
#line 1261
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1261
            if (! (x < tilec->x1)) {
#line 1261
              goto while_break___4;
            }
#line 1262
            __cil_tmp44 = data___0;
#line 1262
            data___0 ++;
#line 1262
            __cil_tmp43 = tile_data___0;
#line 1262
            tile_data___0 ++;
#line 1262
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1261
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1256
          y ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1232
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1270
    if (tcd_tcp->mct) {
#line 1271
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1272
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1273
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1275
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1281
    compno = 0;
    {
#line 1281
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1281
      if (! (compno < tile->numcomps)) {
#line 1281
        goto while_break___5;
      }
#line 1282
      tilec___0 = tile->comps + compno;
#line 1283
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1284
        dwt_encode(tilec___0);
        }
      } else
#line 1285
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1286
        dwt_encode_real(tilec___0);
        }
      }
#line 1281
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1291
    t1 = t1_create(tcd->cinfo);
#line 1292
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1293
    t1_destroy(t1);
    }
#line 1298
    if (cstr_info) {
#line 1299
      cstr_info->index_write = 0;
    }
#line 1301
    if (cp->disto_alloc) {
      {
      {
#line 1303
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else
#line 1301
    if (cp->fixed_quality) {
      {
      {
#line 1303
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else {
      {
#line 1306
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1312
  if (cstr_info) {
#line 1313
    cstr_info->index_write = 1;
  }
  {
#line 1316
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1317
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1318
  t2_destroy(t2);
  }
#line 1323
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1324
    __cil_tmp54 = opj_clock();
#line 1324
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1325
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1328
    compno = 0;
    }
    {
#line 1328
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1328
      if (! (compno < tile->numcomps)) {
#line 1328
        goto while_break___6;
      }
      {
#line 1329
      tilec___1 = tile->comps + compno;
#line 1330
      free(tilec___1->data);
      }
#line 1328
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1334
  return (l);
}
}
#line 1337 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp15 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  opj_t2_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  opj_t1_t *__cil_tmp29 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int i ;
  int j ;
  int offset_x ;
  int __cil_tmp53 ;
  int offset_y ;
  int __cil_tmp55 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp58 ;
  int v ;
  int __cil_tmp60 ;
  float tmp___4 ;
  int v___0 ;
  long __cil_tmp63 ;
  int __cil_tmp64 ;
  double __cil_tmp65 ;

  {
  {
#line 1340
  eof = 0;
#line 1342
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1344
  t1 = (opj_t1_t *)((void *)0);
#line 1345
  t2 = (opj_t2_t *)((void *)0);
#line 1347
  tcd->tcd_tileno = tileno;
#line 1348
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1349
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1350
  tile = tcd->tcd_tile;
#line 1352
  tile_time = opj_clock();
#line 1353
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1356
  if (cstr_info) {
#line 1357
    numprec = 0;
#line 1358
    compno___1 = 0;
    {
#line 1358
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1358
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1358
        goto while_break;
      }
#line 1359
      tcp = (tcd->cp)->tcps + 0;
#line 1360
      tccp = tcp->tccps + compno___1;
#line 1361
      tilec_idx = tile->comps + compno___1;
#line 1362
      resno = 0;
      {
#line 1362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1362
        if (! (resno < tilec_idx->numresolutions)) {
#line 1362
          goto while_break___0;
        }
#line 1363
        res_idx = tilec_idx->resolutions + resno;
#line 1364
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1365
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1366
        numprec += res_idx->pw * res_idx->ph;
#line 1367
        if (tccp->csty & 1) {
#line 1368
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1369
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1372
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1373
          (cstr_info->tile + tileno)->pdy[resno] = 15;
        }
#line 1362
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1358
      compno___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1377
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1377
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1378
    cstr_info->packno = 0;
    }
  }
  {
#line 1384
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1385
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1386
  t2_destroy(t2);
  }
#line 1388
  if (l == -999) {
    {
#line 1389
    eof = 1;
#line 1390
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
#line 1391
    return (0);
  }
  {
#line 1396
  t1_time = opj_clock();
#line 1397
  t1 = t1_create(tcd->cinfo);
  }
#line 1398
  if (t1 == (void *)0) {
    {
#line 1400
    opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1401
    t1_destroy(t1);
    }
#line 1402
    return (0);
  }
#line 1405
  compno = 0;
  {
#line 1405
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1405
    if (! (compno < tile->numcomps)) {
#line 1405
      goto while_break___1;
    }
    {
#line 1406
    tilec = tile->comps + compno;
#line 1408
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1408
    tilec->data = (int *)__cil_tmp31;
    }
#line 1409
    if (tilec->data == (void *)0) {
      {
#line 1411
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1412
      t1_destroy(t1);
      }
#line 1413
      return (0);
    }
    {
#line 1416
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
    }
#line 1405
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1418
  t1_destroy(t1);
#line 1419
  __cil_tmp32 = opj_clock();
#line 1419
  t1_time = __cil_tmp32 - t1_time;
#line 1420
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n\006V", t1_time);
#line 1424
  dwt_time = opj_clock();
#line 1425
  compno = 0;
  }
  {
#line 1425
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1425
    if (! (compno < tile->numcomps)) {
#line 1425
      goto while_break___2;
    }
#line 1426
    tilec___0 = tile->comps + compno;
#line 1429
    if ((tcd->cp)->reduce != 0) {
#line 1430
      if ((tile->comps + compno)->numresolutions < (tcd->cp)->reduce - 1) {
        {
#line 1431
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1433
        return (0);
      } else {
#line 1436
        ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
      }
    }
#line 1441
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1442
    if (numres2decode > 0) {
#line 1443
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1444
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1446
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1425
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1450
  __cil_tmp37 = opj_clock();
#line 1450
  dwt_time = __cil_tmp37 - dwt_time;
#line 1451
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1455
  if ((tcd->tcp)->mct) {
#line 1456
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1458
    if (tile->numcomps >= 3) {
#line 1460
      if (((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0) < n) {
        {
        {
        {
#line 1463
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
#line 1464
        return (0);
      } else
#line 1460
      if (((tile->comps + 1)->x1 - (tile->comps + 1)->x0) * ((tile->comps + 1)->y1 - (tile->comps + 1)->y0) < n) {
        {
        {
        {
#line 1463
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
#line 1464
        return (0);
      } else
#line 1460
      if (((tile->comps + 2)->x1 - (tile->comps + 2)->x0) * ((tile->comps + 2)->y1 - (tile->comps + 2)->y0) < n) {
        {
        {
        {
#line 1463
        opj_event_msg(tcd->cinfo, 1, "Tiles don\'t all have the same dimension. Skip the MCT step.\n");
        }
        }
        }
#line 1464
        return (0);
      }
#line 1466
      if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
        {
#line 1467
        mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   n);
        }
      } else {
        {
#line 1473
        mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                        (float *)(tile->comps + 2)->data, n);
        }
      }
    } else {
      {
#line 1480
      opj_event_msg(tcd->cinfo, 2, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",
                    tile->numcomps);
      }
    }
  }
#line 1486
  compno = 0;
  {
#line 1486
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1486
    if (! (compno < tile->numcomps)) {
#line 1486
      goto while_break___3;
    }
#line 1487
    tilec___1 = tile->comps + compno;
#line 1488
    imagec = (tcd->image)->comps + compno;
#line 1489
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1490
    if (imagec->sgnd) {
#line 1490
      tmp = 0;
    } else {
#line 1490
      tmp = 1 << (imagec->prec - 1);
    }
#line 1490
    adjust = tmp;
#line 1491
    if (imagec->sgnd) {
#line 1491
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1491
      tmp___0 = 0;
    }
#line 1491
    min = tmp___0;
#line 1492
    if (imagec->sgnd) {
#line 1492
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1492
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1492
    max = tmp___1;
#line 1494
    tw = tilec___1->x1 - tilec___1->x0;
#line 1495
    w = imagec->w;
#line 1498
    __cil_tmp53 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1498
    offset_x = __cil_tmp53;
#line 1499
    __cil_tmp55 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1499
    offset_y = __cil_tmp55;
    }
#line 1500
    if (res->x0 > offset_x) {
      {
      {
      {
      {
#line 1503
      opj_event_msg(tcd->cinfo, 1, "Impossible offsets\n");
      }
      }
      }
      }
#line 1504
      return (0);
    } else
#line 1500
    if (offset_x > res->x1) {
      {
      {
      {
      {
#line 1503
      opj_event_msg(tcd->cinfo, 1, "Impossible offsets\n");
      }
      }
      }
      }
#line 1504
      return (0);
    } else
#line 1500
    if (res->y0 > offset_y) {
      {
      {
      {
      {
#line 1503
      opj_event_msg(tcd->cinfo, 1, "Impossible offsets\n");
      }
      }
      }
      }
#line 1504
      return (0);
    } else
#line 1500
    if (offset_y > res->y1) {
      {
      {
      {
      {
#line 1503
      opj_event_msg(tcd->cinfo, 1, "Impossible offsets\n");
      }
      }
      }
      }
#line 1504
      return (0);
    }
#line 1509
    if (! imagec->data) {
      {
#line 1510
      __cil_tmp58 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1510
      imagec->data = (int *)__cil_tmp58;
      }
    }
#line 1512
    if (! imagec->data) {
      {
#line 1514
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1515
      return (0);
    }
#line 1517
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1518
      j = res->y0;
      {
#line 1518
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1518
        if (! (j < res->y1)) {
#line 1518
          goto while_break___4;
        }
#line 1519
        i = res->x0;
        {
#line 1519
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1519
          if (! (i < res->x1)) {
#line 1519
            goto while_break___5;
          }
          {
#line 1520
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1521
          v += adjust;
#line 1523
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
          }
#line 1519
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1518
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1527
      j = res->y0;
      {
#line 1527
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1527
        if (! (j < res->y1)) {
#line 1527
          goto while_break___6;
        }
#line 1528
        i = res->x0;
        {
#line 1528
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1528
          if (! (i < res->x1)) {
#line 1528
            goto while_break___7;
          }
          {
#line 1529
          tmp___4 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1530
          __cil_tmp63 = lrintf(tmp___4);
#line 1530
          v___0 = (int )__cil_tmp63;
#line 1531
          v___0 += adjust;
#line 1533
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
          }
#line 1528
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1527
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1537
    free(tilec___1->data);
    }
#line 1486
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1540
  __cil_tmp65 = opj_clock();
#line 1540
  tile_time = __cil_tmp65 - tile_time;
#line 1541
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1543
  if (eof) {
#line 1544
    return (0);
  }
#line 1547
  return (1);
}
}
#line 1550 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;
  int i ;
  int __cil_tmp4 ;

  {
#line 1551
  tcd_image = tcd->tcd_image;
#line 1552
  i = 0;
#line 1553
  i = 0;
  {
#line 1553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1553
    if (! (i < tcd_image->tw * tcd_image->th)) {
#line 1553
      goto while_break;
    }
    {
#line 1555
    tcd_free_decode_tile(tcd, i);
    }
#line 1553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1558
  free(tcd_image->tiles);
  }
  return;
}
}
#line 1561 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1564
  tcd_image = tcd->tcd_image;
#line 1566
  tile = tcd_image->tiles + tileno;
#line 1567
  if (tile->comps != (void *)0) {
#line 1568
    compno = 0;
    {
#line 1568
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1568
      if (! (compno < tile->numcomps)) {
#line 1568
        goto while_break;
      }
#line 1569
      tilec = tile->comps + compno;
#line 1570
      resno = 0;
      {
#line 1570
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1570
        if (! (resno < tilec->numresolutions)) {
#line 1570
          goto while_break___0;
        }
#line 1571
        res = tilec->resolutions + resno;
#line 1572
        bandno = 0;
        {
#line 1572
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1572
          if (! (bandno < res->numbands)) {
#line 1572
            goto while_break___1;
          }
#line 1573
          band = & res->bands[bandno];
#line 1574
          precno = 0;
          {
#line 1574
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1574
            if (! (precno < res->ph * res->pw)) {
#line 1574
              goto while_break___2;
            }
#line 1575
            prec = band->precincts + precno;
#line 1576
            if (prec->cblks.dec != (void *)0) {
#line 1577
              cblkno = 0;
              {
#line 1577
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1577
                if (! (cblkno < prec->cw * prec->ch)) {
#line 1577
                  goto while_break___3;
                }
                {
#line 1578
                cblk = prec->cblks.dec + cblkno;
#line 1579
                free(cblk->data);
#line 1580
                free(cblk->segs);
                }
#line 1577
                cblkno ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 1582
              free(prec->cblks.dec);
              }
            }
#line 1584
            if (prec->imsbtree != (void *)0) {
              {
#line 1584
              tgt_destroy(prec->imsbtree);
              }
            }
#line 1585
            if (prec->incltree != (void *)0) {
              {
#line 1585
              tgt_destroy(prec->incltree);
              }
            }
#line 1574
            precno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1589
          free(band->precincts);
          }
#line 1572
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1570
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1592
      free(tilec->resolutions);
      }
#line 1568
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1594
    free(tile->comps);
#line 1595
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
  }
  return;
}
}
#line 41 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) ;
#line 42
static int t2_getcommacode(opj_bio_t *bio ) ;
#line 48
static void t2_putnumpasses(opj_bio_t *bio , int n ) ;
#line 49
static int t2_getnumpasses(opj_bio_t *bio ) ;
#line 61
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) ;
#line 68
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) ;
#line 80
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) ;
#line 91 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) 
{ 


  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    n --;
#line 92
    if (! (n >= 0)) {
#line 92
      goto while_break;
    }
    {
#line 93
    bio_write(bio, 1, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  bio_write(bio, 0, 1);
  }
  return;
}
}
#line 98 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static int t2_getcommacode(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 100
  n = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! __cil_tmp3) {
#line 100
      goto while_break;
    }

#line 100
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (n);
}
}
#line 106 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static void t2_putnumpasses(opj_bio_t *bio , int n ) 
{ 


  {
#line 107
  if (n == 1) {
    {
#line 108
    bio_write(bio, 0, 1);
    }
  } else
#line 109
  if (n == 2) {
    {
#line 110
    bio_write(bio, 2, 2);
    }
  } else
#line 111
  if (n <= 5) {
    {
#line 112
    bio_write(bio, 12 | (n - 3), 4);
    }
  } else
#line 113
  if (n <= 36) {
    {
#line 114
    bio_write(bio, 480 | (n - 6), 9);
    }
  } else
#line 115
  if (n <= 164) {
    {
#line 116
    bio_write(bio, 65408 | (n - 37), 16);
    }
  }
  return;
}
}
#line 120 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static int t2_getnumpasses(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 122
  __cil_tmp3 = bio_read(bio, 1);
  }
#line 122
  if (! __cil_tmp3) {
#line 123
    return (1);
  }
  {
#line 124
  __cil_tmp4 = bio_read(bio, 1);
  }
#line 124
  if (! __cil_tmp4) {
#line 125
    return (2);
  }
  {
#line 126
  n = bio_read(bio, 2);
  }
#line 126
  if (n != 3) {
#line 127
    return (3 + n);
  }
  {
#line 128
  n = bio_read(bio, 5);
  }
#line 128
  if (n != 31) {
#line 129
    return (6 + n);
  }
  {
#line 130
  __cil_tmp7 = bio_read(bio, 7);
  }
#line 130
  return (37 + __cil_tmp7);
}
}
#line 133 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  opj_bio_t *__cil_tmp23 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_cblk_enc_t *cblk___0 ;
  opj_tcd_layer_t *layer ;
  int __cil_tmp28 ;
  opj_tcd_cblk_enc_t *cblk___1 ;
  opj_tcd_layer_t *layer___0 ;
  int increment ;
  int nump ;
  int len ;
  int passno ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_enc_t *cblk___2 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;

  {
#line 135
  c = dest;
#line 137
  compno = pi->compno;
#line 138
  resno = pi->resno;
#line 139
  precno = pi->precno;
#line 140
  layno = pi->layno;
#line 142
  tilec = tile->comps + compno;
#line 143
  res = tilec->resolutions + resno;
#line 145
  bio = (opj_bio_t *)((void *)0);
#line 148
  if (tcp->csty & 2) {
#line 149
    *(c + 0) = (unsigned char )255;
#line 150
    *(c + 1) = (unsigned char )145;
#line 151
    *(c + 2) = (unsigned char )0;
#line 152
    *(c + 3) = (unsigned char )4;
#line 153
    *(c + 4) = (unsigned char )((tile->packno % 65536) / 256);
#line 154
    *(c + 5) = (unsigned char )((tile->packno % 65536) % 256);
#line 155
    c += 6;
  }
#line 159
  if (! layno) {
#line 160
    bandno = 0;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (bandno < res->numbands)) {
#line 160
        goto while_break;
      }
      {
#line 161
      band = & res->bands[bandno];
#line 162
      prc = band->precincts + precno;
#line 163
      tgt_reset(prc->incltree);
#line 164
      tgt_reset(prc->imsbtree);
#line 165
      cblkno = 0;
      }
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (! (cblkno < prc->cw * prc->ch)) {
#line 165
          goto while_break___0;
        }
        {
#line 166
        cblk = prc->cblks.enc + cblkno;
#line 167
        cblk->numpasses = 0;
#line 168
        tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
        }
#line 165
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 160
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 173
  bio = bio_create();
#line 174
  bio_init_enc(bio, c, length);
#line 175
  bio_write(bio, 1, 1);
#line 178
  bandno = 0;
  }
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! (bandno < res->numbands)) {
#line 178
      goto while_break___1;
    }
#line 179
    band___0 = & res->bands[bandno];
#line 180
    prc___0 = band___0->precincts + precno;
#line 181
    cblkno = 0;
    {
#line 181
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 181
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 181
        goto while_break___2;
      }
#line 182
      cblk___0 = prc___0->cblks.enc + cblkno;
#line 183
      layer = cblk___0->layers + layno;
#line 184
      if (! cblk___0->numpasses) {
#line 184
        if (layer->numpasses) {
          {
#line 185
          tgt_setvalue(prc___0->incltree, cblkno, layno);
          }
        }
      }
#line 181
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 188
    cblkno = 0;
    {
#line 188
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 188
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 188
        goto while_break___3;
      }
#line 189
      cblk___1 = prc___0->cblks.enc + cblkno;
#line 190
      layer___0 = cblk___1->layers + layno;
#line 191
      increment = 0;
#line 192
      nump = 0;
#line 193
      len = 0;
#line 195
      if (! cblk___1->numpasses) {
        {
#line 196
        tgt_encode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 198
        bio_write(bio, layer___0->numpasses != 0, 1);
        }
      }
#line 201
      if (! layer___0->numpasses) {
#line 202
        goto while_continue___3;
      }
#line 205
      if (! cblk___1->numpasses) {
        {
#line 206
        cblk___1->numlenbits = 3;
#line 207
        tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 210
      t2_putnumpasses(bio, layer___0->numpasses);
#line 213
      passno = cblk___1->numpasses;
      }
      {
#line 213
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 213
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 213
          goto while_break___4;
        }
#line 214
        pass = cblk___1->passes + passno;
#line 215
        nump ++;
#line 216
        len += pass->len;
#line 217
        if (pass->term) {
          _L: /* CIL Label */ 
          {
#line 218
          __cil_tmp38 = int_floorlog2(nump);
          }
          {
#line 218
          __cil_tmp37 = int_floorlog2(len);
#line 218
          __cil_tmp39 = int_max(increment, (__cil_tmp37 + 1) - (cblk___1->numlenbits + __cil_tmp38));
#line 218
          increment = __cil_tmp39;
#line 219
          len = 0;
#line 220
          nump = 0;
          }
        } else
#line 217
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
#line 217
          goto _L;
        }
#line 213
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 223
      t2_putcommacode(bio, increment);
#line 226
      cblk___1->numlenbits += increment;
#line 229
      passno = cblk___1->numpasses;
      }
      {
#line 229
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 229
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 229
          goto while_break___5;
        }
#line 230
        pass___0 = cblk___1->passes + passno;
#line 231
        nump ++;
#line 232
        len += pass___0->len;
#line 233
        if (pass___0->term) {
          {
          {
#line 234
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 234
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 235
          len = 0;
#line 236
          nump = 0;
          }
        } else
#line 233
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
          {
          {
#line 234
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 234
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 235
          len = 0;
#line 236
          nump = 0;
          }
        }
#line 229
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 188
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 178
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 242
  __cil_tmp47 = bio_flush(bio);
  }
#line 242
  if (__cil_tmp47) {
    {
#line 243
    bio_destroy(bio);
    }
#line 244
    return (- 999);
  }
  {
#line 247
  __cil_tmp48 = bio_numbytes(bio);
  }
  {
#line 247
  c += __cil_tmp48;
#line 248
  bio_destroy(bio);
  }
#line 251
  if (tcp->csty & 4) {
#line 252
    *(c + 0) = (unsigned char )255;
#line 253
    *(c + 1) = (unsigned char )146;
#line 254
    c += 2;
  }
#line 261
  if (cstr_info) {
#line 261
    if (cstr_info->index_write) {
#line 262
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 263
      info_PK->end_ph_pos = (int )(c - dest);
    }
  }
#line 269
  bandno = 0;
  {
#line 269
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 269
    if (! (bandno < res->numbands)) {
#line 269
      goto while_break___6;
    }
#line 270
    band___1 = & res->bands[bandno];
#line 271
    prc___1 = band___1->precincts + precno;
#line 272
    cblkno = 0;
    {
#line 272
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 272
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 272
        goto while_break___7;
      }
#line 273
      cblk___2 = prc___1->cblks.enc + cblkno;
#line 274
      layer___1 = cblk___2->layers + layno;
#line 275
      if (! layer___1->numpasses) {
#line 276
        goto while_continue___7;
      }
#line 278
      if (c + layer___1->len > dest + length) {
#line 279
        return (- 999);
      }
      {
#line 282
      memcpy(c, layer___1->data, (unsigned long )layer___1->len);
#line 283
      cblk___2->numpasses += layer___1->numpasses;
#line 284
      c += layer___1->len;
      }
#line 286
      if (cstr_info) {
#line 286
        if (cstr_info->index_write) {
#line 287
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 288
          info_PK___0->disto += layer___1->disto;
#line 289
          if (cstr_info->D_max < info_PK___0->disto) {
#line 290
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 272
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 269
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 297
  return ((int )(c - dest));
}
}
#line 300 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) 
{ 
  opj_tcd_seg_t *seg ;
  opj_tcd_seg_t *segs ;
  void *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 303
  __cil_tmp7 = realloc(cblk->segs, (unsigned long )(index___0 + 1) * sizeof(opj_tcd_seg_t ));
#line 303
  segs = (opj_tcd_seg_t *)__cil_tmp7;
  }
#line 305
  if (segs == (void *)0) {
#line 307
    return (0);
  }
#line 309
  cblk->segs = segs;
#line 311
  seg = cblk->segs + index___0;
#line 312
  seg->data = (unsigned char **)((void *)0);
#line 313
  seg->dataindex = 0;
#line 314
  seg->numpasses = 0;
#line 315
  seg->len = 0;
#line 316
  if (cblksty & 4) {
#line 317
    seg->maxpasses = 1;
  } else
#line 319
  if (cblksty & 1) {
#line 320
    if (first) {
#line 321
      seg->maxpasses = 10;
    } else {
#line 323
      if ((seg - 1)->maxpasses == 1 || (seg - 1)->maxpasses == 10) {
#line 323
        tmp = 2;
      } else {
#line 323
        tmp = 1;
      }
#line 323
      seg->maxpasses = tmp;
    }
  } else {
#line 326
    seg->maxpasses = 109;
  }
#line 329
  return (1);
}
}
#line 332 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  opj_cp_t *cp ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  unsigned char *hd ;
  int present ;
  opj_bio_t *bio ;
  opj_tcd_resolution_t *res ;
  int tmp ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  opj_bio_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  int included ;
  int increment ;
  int n ;
  int segno ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int i ;
  int numimsbs ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  opj_bool __cil_tmp44 ;
  opj_bool __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_bool __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_dec_t *cblk___1 ;
  opj_tcd_seg_t *seg ;
  int __cil_tmp58 ;
  opj_tcd_seg_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  void *__cil_tmp61 ;
  opj_tcd_seg_t *__cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;

  {
#line 335
  c = src;
#line 337
  cp = t2->cp;
#line 339
  compno = pi->compno;
#line 340
  resno = pi->resno;
#line 341
  precno = pi->precno;
#line 342
  layno = pi->layno;
#line 344
  hd = (unsigned char *)((void *)0);
#line 347
  bio = (opj_bio_t *)((void *)0);
#line 351
  res = (tile->comps + compno)->resolutions + resno;
#line 353
  if (layno == 0) {
#line 354
    bandno = 0;
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      if (! (bandno < res->numbands)) {
#line 354
        goto while_break;
      }
#line 355
      band = & res->bands[bandno];
#line 356
      prc = band->precincts + precno;
#line 358
      if (band->x1 - band->x0 == 0) {
#line 358
        goto while_continue;
      } else
#line 358
      if (band->y1 - band->y0 == 0) {
#line 358
        goto while_continue;
      }
      {
#line 360
      tgt_reset(prc->incltree);
#line 361
      tgt_reset(prc->imsbtree);
#line 362
      cblkno = 0;
      }
      {
#line 362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 362
        if (! (cblkno < prc->cw * prc->ch)) {
#line 362
          goto while_break___0;
        }
#line 363
        cblk = prc->cblks.dec + cblkno;
#line 364
        cblk->numsegs = 0;
#line 362
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 354
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 371
  if (tcp->csty & 2) {
#line 372
    if ((int )*c != 255) {
      {
      {
#line 373
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\006V");
      }
      }
    } else
#line 372
    if ((int )*(c + 1) != 145) {
      {
      {
#line 373
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n\006V");
      }
      }
    } else {
#line 375
      c += 6;
    }
  }
  {
#line 388
  bio = bio_create();
  }
#line 390
  if (cp->ppm == 1) {
    {
#line 391
    hd = cp->ppm_data;
#line 392
    bio_init_dec(bio, hd, cp->ppm_len);
    }
  } else
#line 393
  if (tcp->ppt == 1) {
    {
#line 394
    hd = tcp->ppt_data;
#line 395
    bio_init_dec(bio, hd, tcp->ppt_len);
    }
  } else {
    {
#line 397
    hd = c;
#line 398
    bio_init_dec(bio, hd, (int )((src + len) - hd));
    }
  }
  {
#line 401
  present = bio_read(bio, 1);
  }
#line 403
  if (! present) {
    {
#line 404
    bio_inalign(bio);
#line 405
    __cil_tmp28 = bio_numbytes(bio);
    }
    {
#line 405
    hd += __cil_tmp28;
#line 406
    bio_destroy(bio);
    }
#line 410
    if (tcp->csty & 4) {
#line 411
      if ((int )*hd != 255) {
        {
        {
#line 412
        printf("Error : expected EPH marker\n\006V");
        }
        }
      } else
#line 411
      if ((int )*(hd + 1) != 146) {
        {
        {
#line 412
        printf("Error : expected EPH marker\n\006V");
        }
        }
      } else {
#line 414
        hd += 2;
      }
    }
#line 421
    if (pack_info) {
#line 422
      pack_info->end_ph_pos = (int )(c - src);
    }
#line 426
    if (cp->ppm == 1) {
#line 427
      cp->ppm_len += cp->ppm_data - hd;
#line 428
      cp->ppm_data = hd;
#line 429
      return ((int )(c - src));
    }
#line 431
    if (tcp->ppt == 1) {
#line 432
      tcp->ppt_len += tcp->ppt_data - hd;
#line 433
      tcp->ppt_data = hd;
#line 434
      return ((int )(c - src));
    }
#line 437
    return ((int )(hd - src));
  }
#line 440
  bandno = 0;
  {
#line 440
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 440
    if (! (bandno < res->numbands)) {
#line 440
      goto while_break___1;
    }
#line 441
    band___0 = & res->bands[bandno];
#line 442
    prc___0 = band___0->precincts + precno;
#line 444
    if (band___0->x1 - band___0->x0 == 0) {
#line 444
      goto while_continue___1;
    } else
#line 444
    if (band___0->y1 - band___0->y0 == 0) {
#line 444
      goto while_continue___1;
    }
#line 446
    cblkno = 0;
    {
#line 446
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 446
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 446
        goto while_break___2;
      }
#line 448
      cblk___0 = prc___0->cblks.dec + cblkno;
#line 450
      if (! cblk___0->numsegs) {
        {
#line 451
        included = tgt_decode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 454
        included = bio_read(bio, 1);
        }
      }
#line 457
      if (! included) {
#line 458
        cblk___0->numnewpasses = 0;
#line 459
        goto while_continue___2;
      }
#line 462
      if (! cblk___0->numsegs) {
#line 464
        i = 0;
        {
#line 464
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 464
          if (! (! __cil_tmp40)) {
#line 464
            goto while_break___3;
          }

#line 464
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 467
        numimsbs = i - 1;
#line 468
        cblk___0->numbps = band___0->numbps - numimsbs;
#line 469
        cblk___0->numlenbits = 3;
      }
      {
#line 472
      cblk___0->numnewpasses = t2_getnumpasses(bio);
#line 473
      increment = t2_getcommacode(bio);
#line 475
      cblk___0->numlenbits += increment;
#line 476
      segno = 0;
      }
#line 477
      if (! cblk___0->numsegs) {
        {
#line 478
        __cil_tmp44 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                  1);
        }
#line 478
        if (! __cil_tmp44) {
          {
#line 480
          opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 481
          bio_destroy(bio);
          }
#line 482
          return (- 999);
        }
      } else {
#line 485
        segno = cblk___0->numsegs - 1;
#line 486
        if ((cblk___0->segs + segno)->numpasses == (cblk___0->segs + segno)->maxpasses) {
          {
#line 487
          segno ++;
#line 488
          __cil_tmp45 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 488
          if (! __cil_tmp45) {
            {
#line 490
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 491
            bio_destroy(bio);
            }
#line 492
            return (- 999);
          }
        }
      }
#line 496
      n = cblk___0->numnewpasses;
      {
#line 498
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 499
        (cblk___0->segs + segno)->numnewpasses = int_min((cblk___0->segs + segno)->maxpasses - (cblk___0->segs + segno)->numpasses,
                                                         n);
#line 500
        __cil_tmp47 = int_floorlog2((cblk___0->segs + segno)->numnewpasses);
#line 500
        __cil_tmp48 = bio_read(bio, cblk___0->numlenbits + __cil_tmp47);
#line 500
        (cblk___0->segs + segno)->newlen = __cil_tmp48;
#line 501
        n -= (cblk___0->segs + segno)->numnewpasses;
        }
#line 502
        if (n > 0) {
          {
#line 503
          segno ++;
#line 504
          __cil_tmp49 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 504
          if (! __cil_tmp49) {
            {
#line 506
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 507
            bio_destroy(bio);
            }
#line 508
            return (- 999);
          }
        }
#line 498
        if (! (n > 0)) {
#line 498
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 446
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 440
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 515
  __cil_tmp52 = bio_inalign(bio);
  }
#line 515
  if (__cil_tmp52) {
    {
#line 516
    bio_destroy(bio);
    }
#line 517
    return (- 999);
  }
  {
#line 520
  __cil_tmp53 = bio_numbytes(bio);
  }
  {
#line 520
  hd += __cil_tmp53;
#line 521
  bio_destroy(bio);
  }
#line 524
  if (tcp->csty & 4) {
#line 525
    if ((int )*hd != 255) {
      {
      {
#line 526
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 527
      return (- 999);
    } else
#line 525
    if ((int )*(hd + 1) != 146) {
      {
      {
#line 526
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 527
      return (- 999);
    } else {
#line 529
      hd += 2;
    }
  }
#line 536
  if (pack_info) {
#line 537
    pack_info->end_ph_pos = (int )(hd - src);
  }
#line 541
  if (cp->ppm == 1) {
#line 542
    cp->ppm_len += cp->ppm_data - hd;
#line 543
    cp->ppm_data = hd;
  } else
#line 544
  if (tcp->ppt == 1) {
#line 545
    tcp->ppt_len += tcp->ppt_data - hd;
#line 546
    tcp->ppt_data = hd;
  } else {
#line 548
    c = hd;
  }
#line 551
  bandno = 0;
  {
#line 551
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 551
    if (! (bandno < res->numbands)) {
#line 551
      goto while_break___5;
    }
#line 552
    band___1 = & res->bands[bandno];
#line 553
    prc___1 = band___1->precincts + precno;
#line 555
    if (band___1->x1 - band___1->x0 == 0) {
#line 555
      goto while_continue___5;
    } else
#line 555
    if (band___1->y1 - band___1->y0 == 0) {
#line 555
      goto while_continue___5;
    }
#line 557
    cblkno = 0;
    {
#line 557
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 557
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 557
        goto while_break___6;
      }
#line 558
      cblk___1 = prc___1->cblks.dec + cblkno;
#line 559
      seg = (opj_tcd_seg_t *)((void *)0);
#line 560
      if (! cblk___1->numnewpasses) {
#line 561
        goto while_continue___6;
      }
#line 562
      if (! cblk___1->numsegs) {
#line 563
        seg = cblk___1->segs + 0;
#line 564
        (cblk___1->numsegs) ++;
#line 565
        cblk___1->len = 0;
      } else {
#line 567
        seg = cblk___1->segs + (cblk___1->numsegs - 1);
#line 568
        if (seg->numpasses == seg->maxpasses) {
#line 569
          seg ++;
#line 570
          (cblk___1->numsegs) ++;
        }
      }
      {
#line 574
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 575
        if (c + seg->newlen > src + len) {
#line 576
          return (- 999);
        }
        {
#line 599
        __cil_tmp61 = realloc(cblk___1->data, (unsigned long )(cblk___1->len + seg->newlen) * sizeof(unsigned char ));
#line 599
        cblk___1->data = (unsigned char *)__cil_tmp61;
#line 600
        memcpy(cblk___1->data + cblk___1->len, c, (unsigned long )seg->newlen);
        }
#line 601
        if (seg->numpasses == 0) {
#line 602
          seg->data = & cblk___1->data;
#line 603
          seg->dataindex = cblk___1->len;
        }
#line 605
        c += seg->newlen;
#line 606
        cblk___1->len += seg->newlen;
#line 607
        seg->len += seg->newlen;
#line 608
        seg->numpasses += seg->numnewpasses;
#line 609
        cblk___1->numnewpasses -= seg->numnewpasses;
#line 610
        if (cblk___1->numnewpasses > 0) {
#line 611
          seg ++;
#line 612
          (cblk___1->numsegs) ++;
        }
#line 574
        if (! (cblk___1->numnewpasses > 0)) {
#line 574
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 557
      cblkno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 551
    bandno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 618
  return ((int )(c - src));
}
}
#line 623 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  unsigned char *c ;
  int e ;
  int compno ;
  opj_pi_iterator_t *pi ;
  int poc ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int pocno ;
  int tmp ;
  int maxcomp ;
  int tmp___0 ;
  opj_pi_iterator_t *__cil_tmp25 ;
  int comp_len ;
  int tpnum___2 ;
  opj_bool __cil_tmp28 ;
  opj_bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  opj_bool __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___1 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 624
  c = dest;
#line 625
  e = 0;
#line 627
  pi = (opj_pi_iterator_t *)((void *)0);
#line 629
  image = t2->image;
#line 630
  cp = t2->cp;
#line 631
  tcp = cp->tcps + tileno;
#line 632
  if ((unsigned int )cp->cinema == 3U) {
#line 632
    tmp = 2;
  } else {
#line 632
    tmp = 1;
  }
#line 632
  pocno = tmp;
#line 633
  if (cp->max_comp_size > 0) {
#line 633
    tmp___0 = image->numcomps;
  } else {
#line 633
    tmp___0 = 1;
  }
  {
#line 633
  maxcomp = tmp___0;
#line 635
  pi = pi_initialise_encode(image, cp, tileno, t2_mode);
  }
#line 636
  if (! pi) {
#line 638
    return (- 999);
  }
#line 641
  if ((unsigned int )t2_mode == 0U) {
#line 642
    compno = 0;
    {
#line 642
    while (1) {
      while_continue: /* CIL Label */ ;
#line 642
      if (! (compno < maxcomp)) {
#line 642
        goto while_break;
      }
#line 643
      poc = 0;
      {
#line 643
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 643
        if (! (poc < pocno)) {
#line 643
          goto while_break___0;
        }
        {
#line 644
        comp_len = 0;
#line 645
        tpnum___2 = compno;
#line 646
        __cil_tmp28 = pi_create_encode(pi, cp, tileno, poc, tpnum___2, tppos, t2_mode,
                                       cur_totnum_tp);
        }
#line 646
        if (__cil_tmp28) {
          {
#line 647
          opj_event_msg(t2->cinfo, 1, "Error initializing Packet Iterator\nS\006V");
#line 648
          pi_destroy(pi, cp, tileno);
          }
#line 649
          return (- 999);
        }
        {
#line 651
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 651
          __cil_tmp29 = pi_next(pi + poc);
          }
#line 651
          if (! __cil_tmp29) {
#line 651
            goto while_break___1;
          }
#line 652
          if ((pi + poc)->layno < maxlayers) {
            {
#line 653
            e = t2_encode_packet(tile, cp->tcps + tileno, pi + poc, c, (int )((dest + len) - c),
                                 cstr_info, tileno);
#line 654
            comp_len += e;
            }
#line 655
            if (e == -999) {
#line 656
              goto while_break___1;
            } else {
#line 658
              c += e;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 662
        if (e == -999) {
#line 662
          goto while_break___0;
        }
#line 663
        if (cp->max_comp_size) {
#line 664
          if (comp_len > cp->max_comp_size) {
#line 665
            e = - 999;
#line 666
            goto while_break___0;
          }
        }
#line 643
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 670
      if (e == -999) {
#line 670
        goto while_break;
      }
#line 642
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 673
    pi_create_encode(pi, cp, tileno, pino, tpnum, tppos, t2_mode, cur_totnum_tp);
    }
    {
#line 674
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 674
      __cil_tmp33 = pi_next(pi + pino);
      }
#line 674
      if (! __cil_tmp33) {
#line 674
        goto while_break___2;
      }
#line 675
      if ((pi + pino)->layno < maxlayers) {
        {
#line 676
        e = t2_encode_packet(tile, cp->tcps + tileno, pi + pino, c, (int )((dest + len) - c),
                             cstr_info, tileno);
        }
#line 677
        if (e == -999) {
#line 678
          goto while_break___2;
        } else {
#line 680
          c += e;
        }
#line 683
        if (cstr_info) {
#line 684
          if (cstr_info->index_write) {
#line 685
            info_TL = cstr_info->tile + tileno;
#line 686
            info_PK = info_TL->packet + cstr_info->packno;
#line 687
            if (! cstr_info->packno) {
#line 688
              info_PK->start_pos = info_TL->end_header + 1;
            } else {
#line 690
              if ((int )cp->tp_on | tcp->POC && info_PK->start_pos) {
#line 690
                tmp___1 = info_PK->start_pos;
              } else {
#line 690
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
              }
#line 690
              info_PK->start_pos = tmp___1;
            }
#line 692
            info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 693
            info_PK->end_ph_pos += info_PK->start_pos - 1;
          }
#line 697
          (cstr_info->packno) ++;
        }
#line 700
        (tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 705
  pi_destroy(pi, cp, tileno);
  }
#line 707
  if (e == -999) {
#line 708
    return (e);
  }
#line 711
  return ((int )(c - dest));
}
}
#line 714 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) 
{ 
  unsigned char *c ;
  opj_pi_iterator_t *pi ;
  int pino ;
  int e ;
  int n ;
  int curtp ;
  int tp_start_packno ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_pi_iterator_t *__cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_packet_info_t *pack_info ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int __cil_tmp22 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 715
  c = src;
#line 717
  e = 0;
#line 718
  n = 0;
  {
#line 718
  curtp = 0;
#line 721
  image = t2->image;
#line 722
  cp = t2->cp;
#line 725
  pi = pi_create_decode(image, cp, tileno);
  }
#line 726
  if (! pi) {
#line 728
    return (- 999);
  }
#line 731
  tp_start_packno = 0;
#line 733
  pino = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (pino <= (cp->tcps + tileno)->numpocs)) {
#line 733
      goto while_break;
    }
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 734
      __cil_tmp17 = pi_next(pi + pino);
      }
#line 734
      if (! __cil_tmp17) {
#line 734
        goto while_break___0;
      }
#line 735
      if (cp->layer == 0) {
        _L: /* CIL Label */ 
#line 737
        if (cstr_info) {
#line 738
          pack_info = (cstr_info->tile + tileno)->packet + cstr_info->packno;
        } else {
#line 740
          pack_info = (opj_packet_info_t *)((void *)0);
        }
        {
#line 741
        e = t2_decode_packet(t2, c, (int )((src + len) - c), tile, cp->tcps + tileno,
                             pi + pino, pack_info);
        }
      } else
#line 735
      if (cp->layer >= (pi + pino)->layno + 1) {
#line 735
        goto _L;
      } else {
#line 743
        e = 0;
      }
#line 745
      if (e == -999) {
        {
#line 747
        pi_destroy(pi, cp, tileno);
        }
#line 748
        return (- 999);
      }
#line 751
      if (e > 0) {
        {
#line 751
        __cil_tmp20 = int_max((pi + pino)->resno, (image->comps + (pi + pino)->compno)->resno_decoded);
#line 751
        tmp = __cil_tmp20;
        }
      } else {
#line 751
        tmp = (image->comps + (pi + pino)->compno)->resno_decoded;
      }
#line 751
      (image->comps + (pi + pino)->compno)->resno_decoded = tmp;
#line 755
      n ++;
#line 758
      if (cstr_info) {
#line 759
        info_TL = cstr_info->tile + tileno;
#line 760
        info_PK = info_TL->packet + cstr_info->packno;
#line 761
        if (! cstr_info->packno) {
#line 762
          info_PK->start_pos = info_TL->end_header + 1;
        } else
#line 763
        if ((info_TL->packet + (cstr_info->packno - 1))->end_pos >= (int )((cstr_info->tile + tileno)->tp + curtp)->tp_end_pos) {
#line 764
          (info_TL->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 765
          (info_TL->tp + curtp)->tp_start_pack = tp_start_packno;
#line 766
          tp_start_packno = cstr_info->packno;
#line 767
          curtp ++;
#line 768
          info_PK->start_pos = ((cstr_info->tile + tileno)->tp + curtp)->tp_end_header + 1;
        } else {
#line 770
          if ((int )cp->tp_on && info_PK->start_pos) {
#line 770
            tmp___0 = info_PK->start_pos;
          } else {
#line 770
            tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
          }
#line 770
          info_PK->start_pos = tmp___0;
        }
#line 772
        info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 773
        info_PK->end_ph_pos += info_PK->start_pos - 1;
#line 775
        (cstr_info->packno) ++;
      }
#line 779
      if (e == -999) {
#line 780
        goto while_break___0;
      } else {
#line 782
        c += e;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 733
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  if (cstr_info) {
#line 788
    ((cstr_info->tile + tileno)->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 789
    ((cstr_info->tile + tileno)->tp + curtp)->tp_start_pack = tp_start_packno;
  }
  {
#line 794
  pi_destroy(pi, cp, tileno);
  }
#line 796
  if (e == -999) {
#line 797
    return (e);
  }
#line 800
  return ((int )(c - src));
}
}
#line 805 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) 
{ 
  opj_t2_t *t2 ;
  void *__cil_tmp5 ;

  {
  {
#line 807
  __cil_tmp5 = malloc(sizeof(opj_t2_t ));
#line 807
  t2 = (opj_t2_t *)__cil_tmp5;
  }
#line 808
  if (! t2) {
#line 808
    return ((opj_t2_t *)((void *)0));
  }
#line 809
  t2->cinfo = cinfo;
#line 810
  t2->image = image;
#line 811
  t2->cp = cp;
#line 813
  return (t2);
}
}
#line 816 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t2.c"
void t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 817
  if (t2) {
    {
#line 818
    free(t2);
    }
  }
  return;
}
}
#line 3 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static char lut_ctxno_zc[1024]  = 
#line 3 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
  {      (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )3,      (char )3,      (char )6, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )6,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8};
#line 38 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static char lut_ctxno_sc[256]  = 
#line 38
  {      (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13};
#line 57 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static char lut_spb[256]  = 
#line 57
  {      (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1};
#line 68 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig[128]  = 
#line 68
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )384,      (short )768,      (short )1152, 
        (short )1536,      (short )1920,      (short )2304,      (short )2688, 
        (short )3072,      (short )3456,      (short )3840,      (short )4224, 
        (short )4608,      (short )4992,      (short )5376,      (short )5760, 
        (short )6144,      (short )6528,      (short )6912,      (short )7296, 
        (short )7680,      (short )8064,      (short )8448,      (short )8832, 
        (short )9216,      (short )9600,      (short )9984,      (short )10368, 
        (short )10752,      (short )11136,      (short )11520,      (short )11904, 
        (short )12288,      (short )12672,      (short )13056,      (short )13440, 
        (short )13824,      (short )14208,      (short )14592,      (short )14976, 
        (short )15360,      (short )15744,      (short )16128,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20736,      (short )21120, 
        (short )21504,      (short )21888,      (short )22272,      (short )22656, 
        (short )23040,      (short )23424,      (short )23808,      (short )24192, 
        (short )24576,      (short )24960,      (short )25344,      (short )25728, 
        (short )26112,      (short )26496,      (short )26880,      (short )27264, 
        (short )27648,      (short )28032,      (short )28416,      (short )28800, 
        (short )29184,      (short )29568,      (short )29952,      (short )30336};
#line 87 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig0[128]  = 
#line 87
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936, 
        (short )8192,      (short )8448,      (short )8704,      (short )8960, 
        (short )9216,      (short )9472,      (short )9856,      (short )10112, 
        (short )10368,      (short )10624,      (short )11008,      (short )11264, 
        (short )11520,      (short )11904,      (short )12160,      (short )12544, 
        (short )12800,      (short )13184,      (short )13440,      (short )13824, 
        (short )14080,      (short )14464,      (short )14848,      (short )15104, 
        (short )15488,      (short )15872,      (short )16256,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20864,      (short )21248, 
        (short )21632,      (short )22016,      (short )22528,      (short )22912, 
        (short )23296,      (short )23808,      (short )24192,      (short )24704, 
        (short )25088,      (short )25600,      (short )25984,      (short )26496, 
        (short )26880,      (short )27392,      (short )27904,      (short )28288, 
        (short )28800,      (short )29312,      (short )29824,      (short )30208, 
        (short )30720,      (short )31232,      (short )31744,      (short )32256};
#line 106 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref[128]  = 
#line 106
  {      (short )6144,      (short )6016,      (short )5888,      (short )5760, 
        (short )5632,      (short )5504,      (short )5376,      (short )5248, 
        (short )5120,      (short )4992,      (short )4864,      (short )4736, 
        (short )4608,      (short )4480,      (short )4352,      (short )4224, 
        (short )4096,      (short )3968,      (short )3840,      (short )3712, 
        (short )3584,      (short )3456,      (short )3328,      (short )3200, 
        (short )3072,      (short )2944,      (short )2816,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1280,      (short )1152, 
        (short )1024,      (short )896,      (short )768,      (short )640, 
        (short )512,      (short )384,      (short )256,      (short )128, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )128,      (short )256,      (short )384, 
        (short )512,      (short )640,      (short )768,      (short )896, 
        (short )1024,      (short )1152,      (short )1280,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2816,      (short )2944, 
        (short )3072,      (short )3200,      (short )3328,      (short )3456, 
        (short )3584,      (short )3712,      (short )3840,      (short )3968, 
        (short )4096,      (short )4224,      (short )4352,      (short )4480, 
        (short )4608,      (short )4736,      (short )4864,      (short )4992, 
        (short )5120,      (short )5248,      (short )5376,      (short )5504, 
        (short )5632,      (short )5760,      (short )5888,      (short )6016};
#line 125 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref0[128]  = 
#line 125
  {      (short )8192,      (short )7936,      (short )7680,      (short )7424, 
        (short )7168,      (short )6912,      (short )6784,      (short )6528, 
        (short )6272,      (short )6016,      (short )5888,      (short )5632, 
        (short )5376,      (short )5248,      (short )4992,      (short )4864, 
        (short )4608,      (short )4480,      (short )4224,      (short )4096, 
        (short )3840,      (short )3712,      (short )3584,      (short )3328, 
        (short )3200,      (short )3072,      (short )2944,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1408,      (short )1280, 
        (short )1152,      (short )1024,      (short )1024,      (short )896, 
        (short )768,      (short )768,      (short )640,      (short )640, 
        (short )512,      (short )512,      (short )384,      (short )384, 
        (short )256,      (short )256,      (short )256,      (short )128, 
        (short )128,      (short )128,      (short )128,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936};
#line 42 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) ;
#line 43
static char t1_getctxno_sc(int f ) ;
#line 44
static int t1_getctxno_mag(int f ) ;
#line 45
static char t1_getspb(int f ) ;
#line 46
static short t1_getnmsedec_sig(int x , int bitpos ) ;
#line 47
static short t1_getnmsedec_ref(int x , int bitpos ) ;
#line 48
static void t1_updateflags(flag_t *flagsp , int s , int stride ) ;
#line 52
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) ;
#line 65
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) ;
#line 72
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) ;
#line 78
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) ;
#line 88
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) ;
#line 98
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 103
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 107
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 114
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) ;
#line 126
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) ;
#line 133
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) ;
#line 139
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) ;
#line 150
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) ;
#line 159
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) ;
#line 163
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) ;
#line 166
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) ;
#line 172
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) ;
#line 185
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) ;
#line 191
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) ;
#line 197
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) ;
#line 208
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) ;
#line 217
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 222
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) ;
#line 246
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) ;
#line 266
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) ;
#line 279 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) 
{ 


  {
#line 280
  return (lut_ctxno_zc[(orient << 8) | (f & 255)]);
}
}
#line 283 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static char t1_getctxno_sc(int f ) 
{ 


  {
#line 284
  return (lut_ctxno_sc[(f & 4080) >> 4]);
}
}
#line 287 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static int t1_getctxno_mag(int f ) 
{ 
  int tmp1 ;
  int tmp ;
  int tmp2 ;
  int tmp___0 ;

  {
#line 288
  if (f & 255) {
#line 288
    tmp = 15;
  } else {
#line 288
    tmp = 14;
  }
#line 288
  tmp1 = tmp;
#line 289
  if (f & 8192) {
#line 289
    tmp___0 = 16;
  } else {
#line 289
    tmp___0 = tmp1;
  }
#line 289
  tmp2 = tmp___0;
#line 290
  return (tmp2);
}
}
#line 293 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static char t1_getspb(int f ) 
{ 


  {
#line 294
  return (lut_spb[(f & 4080) >> 4]);
}
}
#line 297 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static short t1_getnmsedec_sig(int x , int bitpos ) 
{ 


  {
#line 298
  if (bitpos > 6) {
#line 299
    return (lut_nmsedec_sig[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 302
  return (lut_nmsedec_sig0[x & ((1 << 7) - 1)]);
}
}
#line 305 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static short t1_getnmsedec_ref(int x , int bitpos ) 
{ 


  {
#line 306
  if (bitpos > 6) {
#line 307
    return (lut_nmsedec_ref[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 310
  return (lut_nmsedec_ref0[x & ((1 << 7) - 1)]);
}
}
#line 313 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_updateflags(flag_t *flagsp , int s , int stride ) 
{ 
  flag_t *np ;
  flag_t *sp ;
  static flag_t mod[8] ;

  {
#line 314
  np = flagsp - stride;
#line 315
  sp = flagsp + stride;
#line 317
  mod[0] = (flag_t )64;
#line 317
  mod[1] = (flag_t )1088;
#line 317
  mod[2] = (flag_t )32;
#line 317
  mod[3] = (flag_t )544;
#line 317
  mod[4] = (flag_t )128;
#line 317
  mod[5] = (flag_t )2176;
#line 317
  mod[6] = (flag_t )16;
#line 317
  mod[7] = (flag_t )272;
#line 324
  *(np + - 1) |= 2;
#line 325
  *(np + 0) |= (int )mod[s];
#line 326
  *(np + 1) |= 4;
#line 328
  *(flagsp + - 1) |= (int )mod[s + 2];
#line 329
  *(flagsp + 0) |= 4096;
#line 330
  *(flagsp + 1) |= (int )mod[s + 4];
#line 332
  *(sp + - 1) |= 1;
#line 333
  *(sp + 0) |= (int )mod[s + 6];
#line 334
  *(sp + 1) |= 8;
  return;
}
}
#line 337 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int tmp___1 ;
  int __cil_tmp18 ;
  short __cil_tmp19 ;
  char __cil_tmp20 ;
  char __cil_tmp21 ;

  {
#line 350
  mqc = t1->mqc;
#line 352
  if (vsc) {
#line 352
    tmp = (int )*flagsp & -1095;
  } else {
#line 352
    tmp = (int )*flagsp;
  }
#line 352
  flag = tmp;
#line 353
  if (flag & 255) {
#line 353
    if (! (flag & 20480)) {
      {
#line 354
      __cil_tmp14 = int_abs(*datap);
      }
#line 354
      if (__cil_tmp14 & one) {
#line 354
        tmp___0 = 1;
      } else {
#line 354
        tmp___0 = 0;
      }
      {
#line 354
      v = tmp___0;
#line 355
      __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 355
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
      }
#line 356
      if ((int )type == 1) {
        {
#line 357
        mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 359
        mqc_encode(mqc, v);
        }
      }
#line 361
      if (v) {
#line 362
        if (*datap < 0) {
#line 362
          tmp___1 = 1;
        } else {
#line 362
          tmp___1 = 0;
        }
        {
#line 362
        v = tmp___1;
#line 363
        __cil_tmp18 = int_abs(*datap);
#line 363
        __cil_tmp19 = t1_getnmsedec_sig(__cil_tmp18, bpno + 6);
        }
        {
#line 363
        *nmsedec += (int )__cil_tmp19;
#line 364
        __cil_tmp20 = t1_getctxno_sc(flag);
#line 364
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp20];
        }
#line 365
        if ((int )type == 1) {
          {
#line 366
          mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 368
          __cil_tmp21 = t1_getspb(flag);
#line 368
          mqc_encode(mqc, v ^ (int )__cil_tmp21);
          }
        }
        {
#line 370
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 372
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 376 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___0 ;

  {
#line 385
  raw = t1->raw;
#line 389
  if (vsc) {
#line 389
    tmp = (int )*flagsp & -1095;
  } else {
#line 389
    tmp = (int )*flagsp;
  }
#line 389
  flag = tmp;
#line 390
  if (flag & 255) {
#line 390
    if (! (flag & 20480)) {
      {
#line 391
      __cil_tmp11 = raw_decode(raw);
      }
#line 391
      if (__cil_tmp11) {
        {
#line 392
        v = raw_decode(raw);
        }
#line 393
        if (v) {
#line 393
          tmp___0 = - oneplushalf;
        } else {
#line 393
          tmp___0 = oneplushalf;
        }
        {
#line 393
        *datap = tmp___0;
#line 394
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 396
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 400 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 409
  mqc = t1->mqc;
#line 411
  flag = (int )*flagsp;
#line 412
  if (flag & 255) {
#line 412
    if (! (flag & 20480)) {
      {
#line 413
      __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 413
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 414
      __cil_tmp10 = mqc_decode(mqc);
      }
#line 414
      if (__cil_tmp10) {
        {
#line 415
        __cil_tmp11 = t1_getctxno_sc(flag);
#line 415
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 416
        __cil_tmp13 = t1_getspb(flag);
        }
        {
#line 416
        __cil_tmp12 = mqc_decode(mqc);
#line 416
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 417
        if (v) {
#line 417
          tmp = - oneplushalf;
        } else {
#line 417
          tmp = oneplushalf;
        }
        {
#line 417
        *datap = tmp;
#line 418
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 420
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 424 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  int tmp___0 ;

  {
#line 434
  mqc = t1->mqc;
#line 436
  if (vsc) {
#line 436
    tmp = (int )*flagsp & -1095;
  } else {
#line 436
    tmp = (int )*flagsp;
  }
#line 436
  flag = tmp;
#line 437
  if (flag & 255) {
#line 437
    if (! (flag & 20480)) {
      {
#line 438
      __cil_tmp11 = t1_getctxno_zc(flag, orient);
#line 438
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 439
      __cil_tmp12 = mqc_decode(mqc);
      }
#line 439
      if (__cil_tmp12) {
        {
#line 440
        __cil_tmp13 = t1_getctxno_sc(flag);
#line 440
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp13];
#line 441
        __cil_tmp15 = t1_getspb(flag);
        }
        {
#line 441
        __cil_tmp14 = mqc_decode(mqc);
#line 441
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 442
        if (v) {
#line 442
          tmp___0 = - oneplushalf;
        } else {
#line 442
          tmp___0 = oneplushalf;
        }
        {
#line 442
        *datap = tmp___0;
#line 443
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 445
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 449 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 458
  *nmsedec = 0;
#line 459
  one = 1 << (bpno + 6);
#line 460
  k = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k < t1->h)) {
#line 460
      goto while_break;
    }
#line 461
    i = 0;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (! (i < t1->w)) {
#line 461
        goto while_break___0;
      }
#line 462
      j = k;
      {
#line 462
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 462
        if (! (j < k + 4 && j < t1->h)) {
#line 462
          goto while_break___1;
        }
#line 463
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 463
          tmp = 1;
        } else {
#line 463
          tmp = 0;
        }
        {
#line 463
        vsc = tmp;
#line 464
        t1_enc_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            type, vsc);
        }
#line 462
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 461
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 479 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 486
  one = 1 << bpno;
#line 487
  half = one >> 1;
#line 488
  oneplushalf = one | half;
#line 489
  k = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (k < t1->h)) {
#line 489
      goto while_break;
    }
#line 490
    i = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! (i < t1->w)) {
#line 490
        goto while_break___0;
      }
#line 491
      j = k;
      {
#line 491
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 491
        if (! (j < k + 4 && j < t1->h)) {
#line 491
          goto while_break___1;
        }
#line 492
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 492
          tmp = 1;
        } else {
#line 492
          tmp = 0;
        }
        {
#line 492
        vsc = tmp;
#line 493
        t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), orient, oneplushalf, vsc);
        }
#line 491
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 490
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 489
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 505 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 511
  data1 = t1->data;
#line 512
  flags1 = t1->flags + 1;
#line 513
  one = 1 << bpno;
#line 514
  half = one >> 1;
#line 515
  oneplushalf = one | half;
#line 516
  k = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (k < (t1->h & -4))) {
#line 516
      goto while_break;
    }
#line 517
    i = 0;
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 517
      if (! (i < t1->w)) {
#line 517
        goto while_break___0;
      }
      {
#line 518
      data2 = data1 + i;
#line 519
      flags2 = flags1 + i;
#line 520
      flags2 += t1->flags_stride;
#line 521
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 522
      data2 += t1->w;
#line 523
      flags2 += t1->flags_stride;
#line 524
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 525
      data2 += t1->w;
#line 526
      flags2 += t1->flags_stride;
#line 527
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 528
      data2 += t1->w;
#line 529
      flags2 += t1->flags_stride;
#line 530
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 531
      data2 += t1->w;
      }
#line 517
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    data1 += t1->w << 2;
#line 534
    flags1 += t1->flags_stride << 2;
#line 516
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  i = 0;
  {
#line 536
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 536
    if (! (i < t1->w)) {
#line 536
      goto while_break___1;
    }
#line 537
    data2___0 = data1 + i;
#line 538
    flags2___0 = flags1 + i;
#line 539
    j = k;
    {
#line 539
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 539
      if (! (j < t1->h)) {
#line 539
        goto while_break___2;
      }
      {
#line 540
      flags2___0 += t1->flags_stride;
#line 541
      t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 542
      data2___0 += t1->w;
      }
#line 539
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 536
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 547 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 553
  one = 1 << bpno;
#line 554
  half = one >> 1;
#line 555
  oneplushalf = one | half;
#line 556
  k = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (k < t1->h)) {
#line 556
      goto while_break;
    }
#line 557
    i = 0;
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! (i < t1->w)) {
#line 557
        goto while_break___0;
      }
#line 558
      j = k;
      {
#line 558
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 558
        if (! (j < k + 4 && j < t1->h)) {
#line 558
          goto while_break___1;
        }
#line 559
        if (j == k + 3 || j == t1->h - 1) {
#line 559
          tmp = 1;
        } else {
#line 559
          tmp = 0;
        }
        {
#line 559
        vsc = tmp;
#line 560
        t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
        }
#line 558
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 557
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 556
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 572 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  short __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;

  {
#line 584
  mqc = t1->mqc;
#line 586
  if (vsc) {
#line 586
    tmp = (int )*flagsp & -1095;
  } else {
#line 586
    tmp = (int )*flagsp;
  }
#line 586
  flag = tmp;
#line 587
  if ((flag & 20480) == 4096) {
    {
#line 588
    __cil_tmp13 = int_abs(*datap);
#line 588
    __cil_tmp14 = t1_getnmsedec_ref(__cil_tmp13, bpno + 6);
    }
    {
#line 588
    *nmsedec += (int )__cil_tmp14;
#line 589
    __cil_tmp15 = int_abs(*datap);
    }
#line 589
    if (__cil_tmp15 & one) {
#line 589
      tmp___0 = 1;
    } else {
#line 589
      tmp___0 = 0;
    }
    {
#line 589
    v = tmp___0;
#line 590
    __cil_tmp17 = t1_getctxno_mag(flag);
#line 590
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp17];
    }
#line 591
    if ((int )type == 1) {
      {
#line 592
      mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 594
      mqc_encode(mqc, v);
      }
    }
#line 596
    *flagsp |= 8192;
  }
  return;
}
}
#line 600 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 610
  raw = t1->raw;
#line 612
  if (vsc) {
#line 612
    tmp = (int )*flagsp & -1095;
  } else {
#line 612
    tmp = (int )*flagsp;
  }
#line 612
  flag = tmp;
#line 613
  if ((flag & 20480) == 4096) {
    {
#line 614
    v = raw_decode(raw);
    }
#line 615
    if (v) {
#line 615
      tmp___0 = poshalf;
    } else {
#line 615
      tmp___0 = neghalf;
    }
#line 615
    t = tmp___0;
#line 616
    if (*datap < 0) {
#line 616
      tmp___1 = - t;
    } else {
#line 616
      tmp___1 = t;
    }
#line 616
    *datap += tmp___1;
#line 617
    *flagsp |= 8192;
  }
  return;
}
}
#line 621 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp ;
  int tmp___0 ;

  {
#line 630
  mqc = t1->mqc;
#line 632
  flag = (int )*flagsp;
#line 633
  if ((flag & 20480) == 4096) {
    {
#line 634
    __cil_tmp10 = t1_getctxno_mag(flag);
#line 634
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp10];
#line 635
    v = mqc_decode(mqc);
    }
#line 636
    if (v) {
#line 636
      tmp = poshalf;
    } else {
#line 636
      tmp = neghalf;
    }
#line 636
    t = tmp;
#line 637
    if (*datap < 0) {
#line 637
      tmp___0 = - t;
    } else {
#line 637
      tmp___0 = t;
    }
#line 637
    *datap += tmp___0;
#line 638
    *flagsp |= 8192;
  }
  return;
}
}
#line 642 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 652
  mqc = t1->mqc;
#line 654
  if (vsc) {
#line 654
    tmp = (int )*flagsp & -1095;
  } else {
#line 654
    tmp = (int )*flagsp;
  }
#line 654
  flag = tmp;
#line 655
  if ((flag & 20480) == 4096) {
    {
#line 656
    __cil_tmp12 = t1_getctxno_mag(flag);
#line 656
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 657
    v = mqc_decode(mqc);
    }
#line 658
    if (v) {
#line 658
      tmp___0 = poshalf;
    } else {
#line 658
      tmp___0 = neghalf;
    }
#line 658
    t = tmp___0;
#line 659
    if (*datap < 0) {
#line 659
      tmp___1 = - t;
    } else {
#line 659
      tmp___1 = t;
    }
#line 659
    *datap += tmp___1;
#line 660
    *flagsp |= 8192;
  }
  return;
}
}
#line 664 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 672
  *nmsedec = 0;
#line 673
  one = 1 << (bpno + 6);
#line 674
  k = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (k < t1->h)) {
#line 674
      goto while_break;
    }
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if (! (i < t1->w)) {
#line 675
        goto while_break___0;
      }
#line 676
      j = k;
      {
#line 676
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 676
        if (! (j < k + 4 && j < t1->h)) {
#line 676
          goto while_break___1;
        }
#line 677
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 677
          tmp = 1;
        } else {
#line 677
          tmp = 0;
        }
        {
#line 677
        vsc = tmp;
#line 678
        t1_enc_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                            vsc);
        }
#line 676
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 675
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 674
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 692 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 699
  one = 1 << bpno;
#line 700
  poshalf = one >> 1;
#line 701
  if (bpno > 0) {
#line 701
    tmp = - poshalf;
  } else {
#line 701
    tmp = - 1;
  }
#line 701
  neghalf = tmp;
#line 702
  k = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (k < t1->h)) {
#line 702
      goto while_break;
    }
#line 703
    i = 0;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (! (i < t1->w)) {
#line 703
        goto while_break___0;
      }
#line 704
      j = k;
      {
#line 704
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 704
        if (! (j < k + 4 && j < t1->h)) {
#line 704
          goto while_break___1;
        }
#line 705
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 705
          tmp___0 = 1;
        } else {
#line 705
          tmp___0 = 0;
        }
        {
#line 705
        vsc = tmp___0;
#line 706
        t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), poshalf, neghalf, vsc);
        }
#line 704
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 702
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 718 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int *data1 ;
  flag_t *flags1 ;
  int tmp ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 723
  data1 = t1->data;
#line 724
  flags1 = t1->flags + 1;
#line 725
  one = 1 << bpno;
#line 726
  poshalf = one >> 1;
#line 727
  if (bpno > 0) {
#line 727
    tmp = - poshalf;
  } else {
#line 727
    tmp = - 1;
  }
#line 727
  neghalf = tmp;
#line 728
  k = 0;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! (k < (t1->h & -4))) {
#line 728
      goto while_break;
    }
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 729
      if (! (i < t1->w)) {
#line 729
        goto while_break___0;
      }
      {
#line 730
      data2 = data1 + i;
#line 731
      flags2 = flags1 + i;
#line 732
      flags2 += t1->flags_stride;
#line 733
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 734
      data2 += t1->w;
#line 735
      flags2 += t1->flags_stride;
#line 736
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 737
      data2 += t1->w;
#line 738
      flags2 += t1->flags_stride;
#line 739
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 740
      data2 += t1->w;
#line 741
      flags2 += t1->flags_stride;
#line 742
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 743
      data2 += t1->w;
      }
#line 729
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 745
    data1 += t1->w << 2;
#line 746
    flags1 += t1->flags_stride << 2;
#line 728
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 748
    if (! (i < t1->w)) {
#line 748
      goto while_break___1;
    }
#line 749
    data2___0 = data1 + i;
#line 750
    flags2___0 = flags1 + i;
#line 751
    j = k;
    {
#line 751
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 751
      if (! (j < t1->h)) {
#line 751
        goto while_break___2;
      }
      {
#line 752
      flags2___0 += t1->flags_stride;
#line 753
      t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 754
      data2___0 += t1->w;
      }
#line 751
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 748
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 759 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 765
  one = 1 << bpno;
#line 766
  poshalf = one >> 1;
#line 767
  if (bpno > 0) {
#line 767
    tmp = - poshalf;
  } else {
#line 767
    tmp = - 1;
  }
#line 767
  neghalf = tmp;
#line 768
  k = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (k < t1->h)) {
#line 768
      goto while_break;
    }
#line 769
    i = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 769
      if (! (i < t1->w)) {
#line 769
        goto while_break___0;
      }
#line 770
      j = k;
      {
#line 770
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 770
        if (! (j < k + 4 && j < t1->h)) {
#line 770
          goto while_break___1;
        }
#line 771
        if (j == k + 3 || j == t1->h - 1) {
#line 771
          tmp___0 = 1;
        } else {
#line 771
          tmp___0 = 0;
        }
        {
#line 771
        vsc = tmp___0;
#line 772
        t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
        }
#line 770
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 769
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 768
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 784 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  short __cil_tmp18 ;
  char __cil_tmp19 ;
  int tmp___1 ;
  char __cil_tmp21 ;

  {
#line 797
  mqc = t1->mqc;
#line 799
  if (vsc) {
#line 799
    tmp = (int )*flagsp & -1095;
  } else {
#line 799
    tmp = (int )*flagsp;
  }
#line 799
  flag = tmp;
#line 800
  if (partial) {
#line 801
    goto LABEL_PARTIAL;
  }
#line 803
  if (! ((int )*flagsp & 20480)) {
    {
#line 804
    __cil_tmp14 = t1_getctxno_zc(flag, orient);
#line 804
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 805
    __cil_tmp15 = int_abs(*datap);
    }
#line 805
    if (__cil_tmp15 & one) {
#line 805
      tmp___0 = 1;
    } else {
#line 805
      tmp___0 = 0;
    }
    {
#line 805
    v = tmp___0;
#line 806
    mqc_encode(mqc, v);
    }
#line 807
    if (v) {
      LABEL_PARTIAL: 
      {
#line 809
      __cil_tmp17 = int_abs(*datap);
#line 809
      __cil_tmp18 = t1_getnmsedec_sig(__cil_tmp17, bpno + 6);
      }
      {
#line 809
      *nmsedec += (int )__cil_tmp18;
#line 810
      __cil_tmp19 = t1_getctxno_sc(flag);
#line 810
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp19];
      }
#line 811
      if (*datap < 0) {
#line 811
        tmp___1 = 1;
      } else {
#line 811
        tmp___1 = 0;
      }
      {
#line 811
      v = tmp___1;
#line 812
      __cil_tmp21 = t1_getspb(flag);
#line 812
      mqc_encode(mqc, v ^ (int )__cil_tmp21);
#line 813
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 816
  *flagsp &= ~ 16384;
  return;
}
}
#line 819 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int tmp ;

  {
  {
#line 827
  mqc = t1->mqc;
#line 831
  flag = (int )*flagsp;
#line 832
  __cil_tmp9 = t1_getctxno_sc(flag);
#line 832
  mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 833
  __cil_tmp11 = t1_getspb(flag);
  }
  {
#line 833
  __cil_tmp10 = mqc_decode(mqc);
#line 833
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 834
  if (v) {
#line 834
    tmp = - oneplushalf;
  } else {
#line 834
    tmp = oneplushalf;
  }
  {
#line 834
  *datap = tmp;
#line 835
  t1_updateflags(flagsp, v, t1->flags_stride);
#line 836
  *flagsp &= ~ 16384;
  }
  return;
}
}
#line 839 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 848
  mqc = t1->mqc;
#line 850
  flag = (int )*flagsp;
#line 851
  if (! (flag & 20480)) {
    {
#line 852
    __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 852
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 853
    __cil_tmp10 = mqc_decode(mqc);
    }
#line 853
    if (__cil_tmp10) {
      {
#line 854
      __cil_tmp11 = t1_getctxno_sc(flag);
#line 854
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 855
      __cil_tmp13 = t1_getspb(flag);
      }
      {
#line 855
      __cil_tmp12 = mqc_decode(mqc);
#line 855
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 856
      if (v) {
#line 856
        tmp = - oneplushalf;
      } else {
#line 856
        tmp = oneplushalf;
      }
      {
#line 856
      *datap = tmp;
#line 857
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 860
  *flagsp &= ~ 16384;
  return;
}
}
#line 863 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char __cil_tmp16 ;
  int tmp___0 ;

  {
#line 874
  mqc = t1->mqc;
#line 876
  if (vsc) {
#line 876
    tmp = (int )*flagsp & -1095;
  } else {
#line 876
    tmp = (int )*flagsp;
  }
#line 876
  flag = tmp;
#line 877
  if (partial) {
#line 878
    goto LABEL_PARTIAL;
  }
#line 880
  if (! (flag & 20480)) {
    {
#line 881
    __cil_tmp12 = t1_getctxno_zc(flag, orient);
#line 881
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 882
    __cil_tmp13 = mqc_decode(mqc);
    }
#line 882
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 884
      __cil_tmp14 = t1_getctxno_sc(flag);
#line 884
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
      }
      {
#line 885
      __cil_tmp16 = t1_getspb(flag);
      }
      {
#line 885
      __cil_tmp15 = mqc_decode(mqc);
#line 885
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 886
      if (v) {
#line 886
        tmp___0 = - oneplushalf;
      } else {
#line 886
        tmp___0 = oneplushalf;
      }
      {
#line 886
      *datap = tmp___0;
#line 887
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 890
  *flagsp &= ~ 16384;
  return;
}
}
#line 893 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int agg ;
  int runlen ;
  int vsc ;
  opj_mqc_t *mqc ;
  int __cil_tmp14 ;
  int tmp ;

  {
#line 902
  mqc = t1->mqc;
#line 904
  *nmsedec = 0;
#line 905
  one = 1 << (bpno + 6);
#line 906
  k = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (k < t1->h)) {
#line 906
      goto while_break;
    }
#line 907
    i = 0;
    {
#line 907
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 907
      if (! (i < t1->w)) {
#line 907
        goto while_break___0;
      }
#line 908
      if (k + 3 < t1->h) {
#line 909
        if (cblksty & 8) {
#line 910
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 916
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
        }
      } else {
#line 922
        agg = 0;
      }
#line 924
      if (agg) {
#line 925
        runlen = 0;
        {
#line 925
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 925
          if (! (runlen < 4)) {
#line 925
            goto while_break___1;
          }
          {
#line 926
          __cil_tmp14 = int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 926
          if (__cil_tmp14 & one) {
#line 927
            goto while_break___1;
          }
#line 925
          runlen ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 929
        mqc->curctx = & mqc->ctxs[(int )17];
#line 930
        mqc_encode(mqc, runlen != 4);
        }
#line 931
        if (runlen == 4) {
#line 932
          goto while_continue___0;
        }
        {
#line 934
        mqc->curctx = & mqc->ctxs[(int )18];
#line 935
        mqc_encode(mqc, runlen >> 1);
#line 936
        mqc_encode(mqc, runlen & 1);
        }
      } else {
#line 938
        runlen = 0;
      }
#line 940
      j = k + runlen;
      {
#line 940
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 940
        if (! (j < k + 4 && j < t1->h)) {
#line 940
          goto while_break___2;
        }
#line 941
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 941
          tmp = 1;
        } else {
#line 941
          tmp = 0;
        }
        {
#line 941
        vsc = tmp;
#line 942
        t1_enc_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            agg && j == k + runlen, vsc);
        }
#line 940
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 907
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 957 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int agg ;
  int runlen ;
  int vsc ;
  int segsym ;
  opj_mqc_t *mqc ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int *data2___0 ;
  flag_t *flags2___0 ;
  int v ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 964
  segsym = cblksty & 32;
#line 966
  mqc = t1->mqc;
#line 968
  one = 1 << bpno;
#line 969
  half = one >> 1;
#line 970
  oneplushalf = one | half;
#line 971
  if (cblksty & 8) {
#line 972
    k = 0;
    {
#line 972
    while (1) {
      while_continue: /* CIL Label */ ;
#line 972
      if (! (k < t1->h)) {
#line 972
        goto while_break;
      }
#line 973
      i = 0;
      {
#line 973
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 973
        if (! (i < t1->w)) {
#line 973
          goto while_break___0;
        }
#line 974
        if (k + 3 < t1->h) {
#line 975
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 981
          agg = 0;
        }
#line 983
        if (agg) {
          {
#line 984
          mqc->curctx = & mqc->ctxs[(int )17];
#line 985
          __cil_tmp16 = mqc_decode(mqc);
          }
#line 985
          if (! __cil_tmp16) {
#line 986
            goto while_continue___0;
          }
          {
#line 988
          mqc->curctx = & mqc->ctxs[(int )18];
#line 989
          runlen = mqc_decode(mqc);
#line 990
          __cil_tmp18 = mqc_decode(mqc);
#line 990
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 992
          runlen = 0;
        }
#line 994
        j = k + runlen;
        {
#line 994
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 994
          if (! (j < k + 4 && j < t1->h)) {
#line 994
            goto while_break___1;
          }
#line 995
          if (j == k + 3 || j == t1->h - 1) {
#line 995
            tmp = 1;
          } else {
#line 995
            tmp = 0;
          }
          {
#line 995
          vsc = tmp;
#line 996
          t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                  t1->data + (j * t1->w + i), orient, oneplushalf,
                                  agg && j == k + runlen, vsc);
          }
#line 994
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 973
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 972
      k += 4;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1008
    data1 = t1->data;
#line 1009
    flags1 = t1->flags + 1;
#line 1010
    k = 0;
    {
#line 1010
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1010
      if (! (k < (t1->h & -4))) {
#line 1010
        goto while_break___2;
      }
#line 1011
      i = 0;
      {
#line 1011
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1011
        if (! (i < t1->w)) {
#line 1011
          goto while_break___3;
        }
#line 1012
        data2 = data1 + i;
#line 1013
        flags2 = flags1 + i;
#line 1014
        agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
#line 1018
        if (agg) {
          {
#line 1019
          mqc->curctx = & mqc->ctxs[(int )17];
#line 1020
          __cil_tmp24 = mqc_decode(mqc);
          }
#line 1020
          if (! __cil_tmp24) {
#line 1021
            goto while_continue___3;
          }
          {
#line 1023
          mqc->curctx = & mqc->ctxs[(int )18];
#line 1024
          runlen = mqc_decode(mqc);
#line 1025
          __cil_tmp26 = mqc_decode(mqc);
#line 1025
          runlen = (runlen << 1) | __cil_tmp26;
#line 1026
          flags2 += runlen * t1->flags_stride;
#line 1027
          data2 += runlen * t1->w;
#line 1028
          j = k + runlen;
          }
          {
#line 1028
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1028
            if (! (j < k + 4 && j < t1->h)) {
#line 1028
              goto while_break___4;
            }
#line 1029
            flags2 += t1->flags_stride;
#line 1030
            if (agg) {
#line 1030
              if (j == k + runlen) {
                {
#line 1031
                t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
                {
#line 1033
                t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
                }
              }
            } else {
              {
              {
#line 1033
              t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
              }
            }
#line 1035
            data2 += t1->w;
#line 1028
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1038
          flags2 += t1->flags_stride;
#line 1039
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1040
          data2 += t1->w;
#line 1041
          flags2 += t1->flags_stride;
#line 1042
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1043
          data2 += t1->w;
#line 1044
          flags2 += t1->flags_stride;
#line 1045
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1046
          data2 += t1->w;
#line 1047
          flags2 += t1->flags_stride;
#line 1048
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1049
          data2 += t1->w;
          }
        }
#line 1011
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1052
      data1 += t1->w << 2;
#line 1053
      flags1 += t1->flags_stride << 2;
#line 1010
      k += 4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1055
    i = 0;
    {
#line 1055
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1055
      if (! (i < t1->w)) {
#line 1055
        goto while_break___5;
      }
#line 1056
      data2___0 = data1 + i;
#line 1057
      flags2___0 = flags1 + i;
#line 1058
      j = k;
      {
#line 1058
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1058
        if (! (j < t1->h)) {
#line 1058
          goto while_break___6;
        }
        {
#line 1059
        flags2___0 += t1->flags_stride;
#line 1060
        t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1061
        data2___0 += t1->w;
        }
#line 1058
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1055
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1066
  if (segsym) {
    {
#line 1067
    v = 0;
#line 1068
    mqc->curctx = & mqc->ctxs[(int )18];
#line 1069
    v = mqc_decode(mqc);
#line 1070
    __cil_tmp31 = mqc_decode(mqc);
#line 1070
    v = (v << 1) | __cil_tmp31;
#line 1071
    __cil_tmp32 = mqc_decode(mqc);
#line 1071
    v = (v << 1) | __cil_tmp32;
#line 1072
    __cil_tmp33 = mqc_decode(mqc);
#line 1072
    v = (v << 1) | __cil_tmp33;
    }
  }
  return;
}
}
#line 1083 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) 
{ 
  double w1 ;
  double w2 ;
  double wmsedec ;
  double __cil_tmp13 ;
  double tmp ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double tmp___0 ;
  double __cil_tmp18 ;

  {
#line 1095
  if (qmfbid == 1) {
#line 1096
    if (mct && numcomps == 3) {
      {
#line 1096
      __cil_tmp13 = mct_getnorm(compno);
#line 1096
      tmp = __cil_tmp13;
      }
    } else {
#line 1096
      tmp = 1.;
    }
    {
#line 1096
    w1 = tmp;
#line 1097
    w2 = dwt_getnorm(level, orient);
    }
  } else {
#line 1099
    if (mct && numcomps == 3) {
      {
#line 1099
      __cil_tmp16 = mct_getnorm_real(compno);
#line 1099
      tmp___0 = __cil_tmp16;
      }
    } else {
#line 1099
      tmp___0 = 1.;
    }
    {
#line 1099
    w1 = tmp___0;
#line 1100
    w2 = dwt_getnorm_real(level, orient);
    }
  }
#line 1102
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1103
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1105
  return (wmsedec);
}
}
#line 1108 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static opj_bool allocate_buffers(opj_t1_t *t1 , int w , int h ) 
{ 
  int datasize ;
  int flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1113
  datasize = w * h;
#line 1116
  if (datasize > t1->datasize) {
    {
#line 1117
    free(t1->data);
#line 1118
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(int ));
#line 1118
    t1->data = (int *)__cil_tmp6;
    }
#line 1119
    if (! t1->data) {
#line 1120
      return (0);
    }
#line 1122
    t1->datasize = datasize;
  }
  {
#line 1124
  memset(t1->data, 0, (unsigned long )datasize * sizeof(int ));
#line 1126
  t1->flags_stride = w + 2;
#line 1127
  flagssize = t1->flags_stride * (h + 2);
  }
#line 1129
  if (flagssize > t1->flagssize) {
    {
#line 1130
    free(t1->flags);
#line 1131
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(flag_t ));
#line 1131
    t1->flags = (flag_t *)__cil_tmp7;
    }
#line 1132
    if (! t1->flags) {
#line 1133
      return (0);
    }
#line 1135
    t1->flagssize = flagssize;
  }
  {
#line 1137
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(flag_t ));
#line 1139
  t1->w = w;
#line 1140
  t1->h = h;
  }
#line 1142
  return (1);
}
}
#line 1146 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) 
{ 
  double cumwmsedec ;
  opj_mqc_t *mqc ;
  int passno ;
  int bpno ;
  int passtype ;
  int nmsedec ;
  int i ;
  int max ;
  char type ;
  double tempwmsedec ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___0 ;
  opj_tcd_pass_t *pass ;
  int correction ;
  int tmp___1 ;
  double __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___2 ;
  int __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp___3 ;
  int __cil_tmp39 ;

  {
#line 1159
  cumwmsedec = 0.;
#line 1161
  mqc = t1->mqc;
#line 1164
  nmsedec = 0;
#line 1166
  type = (char )0;
#line 1169
  max = 0;
#line 1170
  i = 0;
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1170
    if (! (i < t1->w * t1->h)) {
#line 1170
      goto while_break;
    }
    {
#line 1171
    __cil_tmp23 = abs(*(t1->data + i));
#line 1171
    tmp = __cil_tmp23;
#line 1172
    max = int_max(max, tmp);
    }
#line 1170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  if (max) {
    {
#line 1175
    __cil_tmp25 = int_floorlog2(max);
#line 1175
    tmp___0 = (__cil_tmp25 + 1) - 6;
    }
  } else {
#line 1175
    tmp___0 = 0;
  }
  {
#line 1175
  cblk->numbps = tmp___0;
#line 1177
  bpno = cblk->numbps - 1;
#line 1178
  passtype = 2;
#line 1180
  mqc_resetstates(mqc);
#line 1181
  mqc_setstate(mqc, 18, 0, 46);
#line 1182
  mqc_setstate(mqc, 17, 0, 3);
#line 1183
  mqc_setstate(mqc, 0, 0, 4);
#line 1184
  mqc_init_enc(mqc, cblk->data);
#line 1186
  passno = 0;
  }
  {
#line 1186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1186
    if (! (bpno >= 0)) {
#line 1186
      goto while_break___0;
    }
#line 1187
    pass = cblk->passes + passno;
#line 1188
    correction = 3;
#line 1189
    if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1189
      tmp___1 = 1;
    } else {
#line 1189
      tmp___1 = 0;
    }
#line 1189
    type = (char )tmp___1;
    {
#line 1192
    if (passtype == 0) {
#line 1192
      goto case_0;
    }
#line 1195
    if (passtype == 1) {
#line 1195
      goto case_1;
    }
#line 1198
    if (passtype == 2) {
#line 1198
      goto case_2;
    }
#line 1191
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1193
    t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1194
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1196
    t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1197
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1199
    t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1201
    if (cblksty & 32) {
      {
#line 1202
      mqc_segmark_enc(mqc);
      }
    }
#line 1203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1207
    tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize,
                                numcomps, mct);
#line 1208
    cumwmsedec += tempwmsedec;
#line 1209
    tile->distotile += tempwmsedec;
    }
#line 1212
    if (cblksty & 4) {
#line 1212
      if (! (passtype == 2 && bpno - 1 < 0)) {
#line 1213
        if ((int )type == 1) {
          {
#line 1214
          mqc_flush(mqc);
#line 1215
          correction = 1;
          }
        } else {
          {
#line 1218
          mqc_flush(mqc);
#line 1219
          correction = 1;
          }
        }
#line 1221
        pass->term = 1;
      } else {
#line 1212
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1223
    if (bpno < cblk->numbps - 4) {
#line 1223
      if (passtype > 0) {
        _L: /* CIL Label */ 
#line 1223
        if (cblksty & 1) {
#line 1225
          if ((int )type == 1) {
            {
#line 1226
            mqc_flush(mqc);
#line 1227
            correction = 1;
            }
          } else {
            {
#line 1230
            mqc_flush(mqc);
#line 1231
            correction = 1;
            }
          }
#line 1233
          pass->term = 1;
        } else {
#line 1235
          pass->term = 0;
        }
      } else {
#line 1223
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1223
    if (bpno == cblk->numbps - 4) {
#line 1223
      if (passtype == 2) {
#line 1223
        goto _L;
      } else {
#line 1235
        pass->term = 0;
      }
    } else {
#line 1235
      pass->term = 0;
    }
#line 1239
    passtype ++;
#line 1239
    if (passtype == 3) {
#line 1240
      passtype = 0;
#line 1241
      __cil_tmp31 = bpno;
#line 1241
      bpno --;
    }
#line 1244
    if (pass->term) {
#line 1244
      if (bpno > 0) {
#line 1245
        if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1245
          tmp___2 = 1;
        } else {
#line 1245
          tmp___2 = 0;
        }
#line 1245
        type = (char )tmp___2;
#line 1246
        if ((int )type == 1) {
          {
#line 1247
          mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1249
          mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1252
    pass->distortiondec = cumwmsedec;
#line 1253
    __cil_tmp33 = mqc_numbytes(mqc);
#line 1253
    pass->rate = __cil_tmp33 + correction;
    }
#line 1256
    if (cblksty & 2) {
      {
#line 1257
      mqc_reset_enc(mqc);
      }
    }
#line 1186
    passno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1261
  if (cblksty & 16) {
    {
#line 1262
    mqc_erterm_enc(mqc);
    }
  } else
#line 1263
  if (! (cblksty & 1)) {
    {
#line 1264
    mqc_flush(mqc);
    }
  }
#line 1266
  cblk->totalpasses = passno;
#line 1268
  passno = 0;
  {
#line 1268
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1268
    if (! (passno < cblk->totalpasses)) {
#line 1268
      goto while_break___1;
    }
    {
#line 1269
    pass___0 = cblk->passes + passno;
#line 1270
    __cil_tmp35 = mqc_numbytes(mqc);
    }
#line 1270
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1271
      pass___0->rate = mqc_numbytes(mqc);
      }
    }
#line 1273
    if (pass___0->rate > 1) {
#line 1273
      if ((int )*(cblk->data + (pass___0->rate - 1)) == 255) {
#line 1274
        __cil_tmp37 = pass___0->rate;
#line 1274
        (pass___0->rate) --;
      }
    }
#line 1276
    if (passno == 0) {
#line 1276
      tmp___3 = 0;
    } else {
#line 1276
      tmp___3 = (cblk->passes + (passno - 1))->rate;
    }
#line 1276
    pass___0->len = pass___0->rate - tmp___3;
#line 1268
    passno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 1280 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int bpno ;
  int passtype ;
  int segno ;
  int passno ;
  char type ;
  opj_bool __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 1287
  raw = t1->raw;
#line 1288
  mqc = t1->mqc;
#line 1292
  type = (char )0;
#line 1294
  __cil_tmp13 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
  }
#line 1294
  if (! __cil_tmp13) {
#line 1299
    return;
  }
  {
#line 1302
  bpno = (roishift + cblk->numbps) - 1;
#line 1303
  passtype = 2;
#line 1305
  mqc_resetstates(mqc);
#line 1306
  mqc_setstate(mqc, 18, 0, 46);
#line 1307
  mqc_setstate(mqc, 17, 0, 3);
#line 1308
  mqc_setstate(mqc, 0, 0, 4);
#line 1310
  segno = 0;
  }
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! (segno < cblk->numsegs)) {
#line 1310
      goto while_break;
    }
#line 1311
    seg = cblk->segs + segno;
#line 1314
    if ((bpno <= (cblk->numbps - 1) - 4 && passtype < 2) && cblksty & 1) {
#line 1314
      tmp = 1;
    } else {
#line 1314
      tmp = 0;
    }
#line 1314
    type = (char )tmp;
#line 1316
    if (seg->data == (void *)0) {
#line 1317
      goto while_continue;
    }
#line 1319
    if ((int )type == 1) {
      {
#line 1320
      raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1322
      mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
    }
#line 1325
    passno = 0;
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1325
      if (! (passno < seg->numpasses)) {
#line 1325
        goto while_break___0;
      }
      {
#line 1327
      if (passtype == 0) {
#line 1327
        goto case_0;
      }
#line 1338
      if (passtype == 1) {
#line 1338
        goto case_1;
      }
#line 1349
      if (passtype == 2) {
#line 1349
        goto case_2;
      }
#line 1326
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1328
      if ((int )type == 1) {
        {
#line 1329
        t1_dec_sigpass_raw(t1, bpno + 1, orient, cblksty);
        }
      } else
#line 1331
      if (cblksty & 8) {
        {
#line 1332
        t1_dec_sigpass_mqc_vsc(t1, bpno + 1, orient);
        }
      } else {
        {
#line 1334
        t1_dec_sigpass_mqc(t1, bpno + 1, orient);
        }
      }
#line 1337
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1339
      if ((int )type == 1) {
        {
#line 1340
        t1_dec_refpass_raw(t1, bpno + 1, cblksty);
        }
      } else
#line 1342
      if (cblksty & 8) {
        {
#line 1343
        t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1345
        t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1348
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1350
      t1_dec_clnpass(t1, bpno + 1, orient, cblksty);
      }
#line 1351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1354
      if (cblksty & 2) {
#line 1354
        if ((int )type == 0) {
          {
#line 1355
          mqc_resetstates(mqc);
#line 1356
          mqc_setstate(mqc, 18, 0, 46);
#line 1357
          mqc_setstate(mqc, 17, 0, 3);
#line 1358
          mqc_setstate(mqc, 0, 0, 4);
          }
        }
      }
#line 1360
      passtype ++;
#line 1360
      if (passtype == 3) {
#line 1361
        passtype = 0;
#line 1362
        __cil_tmp16 = bpno;
#line 1362
        bpno --;
      }
#line 1325
      passno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1310
    segno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1370 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
opj_t1_t *t1_create(opj_common_ptr cinfo ) 
{ 
  opj_t1_t *t1 ;
  void *__cil_tmp3 ;
  opj_mqc_t *__cil_tmp4 ;
  opj_raw_t *__cil_tmp5 ;

  {
  {
#line 1371
  __cil_tmp3 = malloc(sizeof(opj_t1_t ));
#line 1371
  t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1372
  if (! t1) {
#line 1373
    return ((opj_t1_t *)((void *)0));
  }
  {
#line 1375
  t1->cinfo = cinfo;
#line 1377
  t1->mqc = mqc_create();
#line 1378
  t1->raw = raw_create();
#line 1380
  t1->data = (int *)((void *)0);
#line 1381
  t1->flags = (flag_t *)((void *)0);
#line 1382
  t1->datasize = 0;
#line 1383
  t1->flagssize = 0;
  }
#line 1385
  return (t1);
}
}
#line 1388 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
void t1_destroy(opj_t1_t *t1 ) 
{ 


  {
#line 1389
  if (t1) {
    {
#line 1391
    mqc_destroy(t1->mqc);
#line 1392
    raw_destroy(t1->raw);
#line 1393
    free(t1->data);
#line 1394
    free(t1->flags);
#line 1395
    free(t1);
    }
  }
  return;
}
}
#line 1399 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  int bandconst ;
  double __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int *datap ;
  int *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int i ;
  int j ;
  int x ;
  int y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  opj_bool __cil_tmp28 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp31 ;

  {
#line 1406
  tile->distotile = (double )0;
#line 1408
  compno = 0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! (compno < tile->numcomps)) {
#line 1408
      goto while_break;
    }
#line 1409
    tilec = tile->comps + compno;
#line 1410
    tccp = tcp->tccps + compno;
#line 1411
    tile_w = tilec->x1 - tilec->x0;
#line 1413
    resno = 0;
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1413
      if (! (resno < tilec->numresolutions)) {
#line 1413
        goto while_break___0;
      }
#line 1414
      res = tilec->resolutions + resno;
#line 1416
      bandno = 0;
      {
#line 1416
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1416
        if (! (bandno < res->numbands)) {
#line 1416
          goto while_break___1;
        }
        {
#line 1417
        band = & res->bands[bandno];
#line 1418
        __cil_tmp15 = floor((double )(band->stepsize * (float )8192));
#line 1418
        bandconst = 67108864 / (int )__cil_tmp15;
#line 1420
        precno = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1420
          if (! (precno < res->pw * res->ph)) {
#line 1420
            goto while_break___2;
          }
#line 1421
          prc = band->precincts + precno;
#line 1423
          cblkno = 0;
          {
#line 1423
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1423
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1423
              goto while_break___3;
            }
#line 1424
            cblk = prc->cblks.enc + cblkno;
#line 1431
            x = cblk->x0 - band->x0;
#line 1432
            y = cblk->y0 - band->y0;
#line 1433
            if (band->bandno & 1) {
#line 1434
              pres = tilec->resolutions + (resno - 1);
#line 1435
              x += pres->x1 - pres->x0;
            }
#line 1437
            if (band->bandno & 2) {
#line 1438
              pres___0 = tilec->resolutions + (resno - 1);
#line 1439
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1442
            __cil_tmp28 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
            }
#line 1442
            if (! __cil_tmp28) {
#line 1447
              return;
            }
#line 1450
            datap = t1->data;
#line 1451
            cblk_w = t1->w;
#line 1452
            cblk_h = t1->h;
#line 1454
            tiledp = tilec->data + (y * tile_w + x);
#line 1455
            if (tccp->qmfbid == 1) {
#line 1456
              j = 0;
              {
#line 1456
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1456
                if (! (j < cblk_h)) {
#line 1456
                  goto while_break___4;
                }
#line 1457
                i = 0;
                {
#line 1457
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1457
                  if (! (i < cblk_w)) {
#line 1457
                    goto while_break___5;
                  }
#line 1458
                  tmp = *(tiledp + (j * tile_w + i));
#line 1459
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1457
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1456
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1463
              j = 0;
              {
#line 1463
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1463
                if (! (j < cblk_h)) {
#line 1463
                  goto while_break___6;
                }
#line 1464
                i = 0;
                {
#line 1464
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1464
                  if (! (i < cblk_w)) {
#line 1464
                    goto while_break___7;
                  }
                  {
#line 1465
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1466
                  __cil_tmp31 = fix_mul(tmp___0, bandconst);
#line 1466
                  *(datap + (j * cblk_w + i)) = __cil_tmp31 >> 5;
                  }
#line 1464
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1463
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
            {
#line 1474
            t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1) - resno,
                           tccp->qmfbid, (double )band->stepsize, tccp->cblksty, tile->numcomps,
                           tcp->mct, tile);
            }
#line 1423
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1420
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1416
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1413
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1408
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1494 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/t1.c"
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  int *datap ;
  int cblk_w ;
  int cblk_h ;
  int x ;
  int y ;
  int i ;
  int j ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int thresh ;
  int val ;
  int mag ;
  int __cil_tmp25 ;
  int tmp ;
  int *tiledp ;
  int tmp___0 ;
  float *tiledp___0 ;
  float *tiledp2 ;
  float tmp___1 ;
  int *__cil_tmp32 ;
  float *__cil_tmp33 ;

  {
#line 1501
  tile_w = tilec->x1 - tilec->x0;
#line 1503
  resno = 0;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (resno < tilec->numresolutions)) {
#line 1503
      goto while_break;
    }
#line 1504
    res = tilec->resolutions + resno;
#line 1506
    bandno = 0;
    {
#line 1506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1506
      if (! (bandno < res->numbands)) {
#line 1506
        goto while_break___0;
      }
#line 1507
      band = & res->bands[bandno];
#line 1509
      precno = 0;
      {
#line 1509
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1509
        if (! (precno < res->pw * res->ph)) {
#line 1509
          goto while_break___1;
        }
#line 1510
        precinct = band->precincts + precno;
#line 1512
        cblkno = 0;
        {
#line 1512
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1512
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1512
            goto while_break___2;
          }
          {
#line 1513
          cblk = precinct->cblks.dec + cblkno;
#line 1519
          t1_decode_cblk(t1, cblk, band->bandno, tccp->roishift, tccp->cblksty);
#line 1526
          x = cblk->x0 - band->x0;
#line 1527
          y = cblk->y0 - band->y0;
          }
#line 1528
          if (band->bandno & 1) {
#line 1529
            pres = tilec->resolutions + (resno - 1);
#line 1530
            x += pres->x1 - pres->x0;
          }
#line 1532
          if (band->bandno & 2) {
#line 1533
            pres___0 = tilec->resolutions + (resno - 1);
#line 1534
            y += pres___0->y1 - pres___0->y0;
          }
#line 1537
          datap = t1->data;
#line 1538
          cblk_w = t1->w;
#line 1539
          cblk_h = t1->h;
#line 1541
          if (tccp->roishift) {
#line 1542
            thresh = 1 << tccp->roishift;
#line 1543
            j = 0;
            {
#line 1543
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1543
              if (! (j < cblk_h)) {
#line 1543
                goto while_break___3;
              }
#line 1544
              i = 0;
              {
#line 1544
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1544
                if (! (i < cblk_w)) {
#line 1544
                  goto while_break___4;
                }
                {
#line 1545
                val = *(datap + (j * cblk_w + i));
#line 1546
                __cil_tmp25 = abs(val);
#line 1546
                mag = __cil_tmp25;
                }
#line 1547
                if (mag >= thresh) {
#line 1548
                  mag >>= tccp->roishift;
#line 1549
                  if (val < 0) {
#line 1549
                    tmp = - mag;
                  } else {
#line 1549
                    tmp = mag;
                  }
#line 1549
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1544
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1543
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1555
          if (tccp->qmfbid == 1) {
#line 1556
            tiledp = tilec->data + (y * tile_w + x);
#line 1557
            j = 0;
            {
#line 1557
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1557
              if (! (j < cblk_h)) {
#line 1557
                goto while_break___5;
              }
#line 1558
              i = 0;
              {
#line 1558
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1558
                if (! (i < cblk_w)) {
#line 1558
                  goto while_break___6;
                }
#line 1559
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1560
                *((int *)tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1558
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1557
              j ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 1564
            tiledp___0 = (float *)(tilec->data + (y * tile_w + x));
#line 1565
            j = 0;
            {
#line 1565
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1565
              if (! (j < cblk_h)) {
#line 1565
                goto while_break___7;
              }
#line 1566
              tiledp2 = tiledp___0;
#line 1567
              i = 0;
              {
#line 1567
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1567
                if (! (i < cblk_w)) {
#line 1567
                  goto while_break___8;
                }
#line 1568
                tmp___1 = (float )*datap * band->stepsize;
#line 1569
                *tiledp2 = tmp___1;
#line 1570
                datap ++;
#line 1571
                tiledp2 ++;
#line 1567
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1573
              tiledp___0 += tile_w;
#line 1565
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 1576
          free(cblk->data);
#line 1577
          free(cblk->segs);
          }
#line 1512
          cblkno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1579
        free(precinct->cblks.dec);
#line 1580
        precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
        }
#line 1509
        precno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1506
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1503
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.c"
opj_raw_t *raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.c"
void raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free(raw);
    }
  }
  return;
}
}
#line 56 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.c"
int raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((int )(raw->bp - raw->start));
}
}
#line 60 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.c"
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = (unsigned int )len;
#line 63
  raw->len = (unsigned int )0;
#line 64
  raw->c = (unsigned char )0;
#line 65
  raw->ct = (unsigned int )0;
  return;
}
}
#line 68 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/raw.c"
int raw_decode(opj_raw_t *raw ) 
{ 
  int d ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = (unsigned int )8;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (unsigned char )255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = (unsigned int )7;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = ((int )raw->c >> raw->ct) & 1;
#line 85
  return (d);
}
}
#line 46 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 82 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___5 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 83
  comp = (opj_pi_comp_t *)((void *)0);
#line 84
  res = (opj_pi_resolution_t *)((void *)0);
#line 85
  index___5 = (long )0;
#line 87
  if (! pi->first) {
#line 88
    comp = pi->comps + pi->compno;
#line 89
    res = comp->resolutions + pi->resno;
#line 90
    goto LABEL_SKIP;
  } else {
#line 92
    pi->first = 0;
  }
#line 95
  pi->layno = pi->poc.layno0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (pi->layno < pi->poc.layno1)) {
#line 95
      goto while_break;
    }
#line 96
    pi->resno = pi->poc.resno0;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (pi->resno < pi->poc.resno1)) {
#line 96
        goto while_break___0;
      }
#line 98
      pi->compno = pi->poc.compno0;
      {
#line 98
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 98
        if (! (pi->compno < pi->poc.compno1)) {
#line 98
          goto while_break___1;
        }
#line 99
        comp = pi->comps + pi->compno;
#line 100
        if (pi->resno >= comp->numresolutions) {
#line 101
          goto while_continue___1;
        }
#line 103
        res = comp->resolutions + pi->resno;
#line 104
        if (! pi->tp_on) {
#line 105
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 107
        pi->precno = pi->poc.precno0;
        {
#line 107
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if (! (pi->precno < pi->poc.precno1)) {
#line 107
            goto while_break___2;
          }
#line 108
          index___5 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 109
          if (! *(pi->include + index___5)) {
#line 110
            *(pi->include + index___5) = (short )1;
#line 111
            return (1);
          }
          LABEL_SKIP: ;
#line 107
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 98
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 97
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 122 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___6 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 123
  comp = (opj_pi_comp_t *)((void *)0);
#line 124
  res = (opj_pi_resolution_t *)((void *)0);
#line 125
  index___6 = (long )0;
#line 127
  if (! pi->first) {
#line 128
    comp = pi->comps + pi->compno;
#line 129
    res = comp->resolutions + pi->resno;
#line 130
    goto LABEL_SKIP;
  } else {
#line 132
    pi->first = 0;
  }
#line 135
  pi->resno = pi->poc.resno0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (pi->resno < pi->poc.resno1)) {
#line 135
      goto while_break;
    }
#line 136
    pi->layno = pi->poc.layno0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (pi->layno < pi->poc.layno1)) {
#line 136
        goto while_break___0;
      }
#line 137
      pi->compno = pi->poc.compno0;
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (! (pi->compno < pi->poc.compno1)) {
#line 137
          goto while_break___1;
        }
#line 138
        comp = pi->comps + pi->compno;
#line 139
        if (pi->resno >= comp->numresolutions) {
#line 140
          goto while_continue___1;
        }
#line 142
        res = comp->resolutions + pi->resno;
#line 143
        if (! pi->tp_on) {
#line 144
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 146
        pi->precno = pi->poc.precno0;
        {
#line 146
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 146
          if (! (pi->precno < pi->poc.precno1)) {
#line 146
            goto while_break___2;
          }
#line 147
          index___6 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 148
          if (! *(pi->include + index___6)) {
#line 149
            *(pi->include + index___6) = (short )1;
#line 150
            return (1);
          }
          LABEL_SKIP: ;
#line 146
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 137
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 136
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___7 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 162
  comp = (opj_pi_comp_t *)((void *)0);
#line 163
  res = (opj_pi_resolution_t *)((void *)0);
#line 164
  index___7 = (long )0;
#line 166
  if (! pi->first) {
#line 167
    goto LABEL_SKIP;
  } else {
#line 170
    pi->first = 0;
#line 171
    pi->dx = 0;
#line 172
    pi->dy = 0;
#line 173
    compno = 0;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (compno < pi->numcomps)) {
#line 173
        goto while_break;
      }
#line 174
      comp = pi->comps + compno;
#line 175
      resno = 0;
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (resno < comp->numresolutions)) {
#line 175
          goto while_break___0;
        }
#line 177
        res = comp->resolutions + resno;
#line 178
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 179
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 180
        if (! pi->dx) {
#line 180
          tmp = dx;
        } else {
          {
#line 180
          __cil_tmp9 = int_min(pi->dx, dx);
#line 180
          tmp = __cil_tmp9;
          }
        }
#line 180
        pi->dx = tmp;
#line 181
        if (! pi->dy) {
#line 181
          tmp___0 = dy;
        } else {
          {
#line 181
          __cil_tmp11 = int_min(pi->dy, dy);
#line 181
          tmp___0 = __cil_tmp11;
          }
        }
#line 181
        pi->dy = tmp___0;
#line 175
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 173
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 185
  if (! pi->tp_on) {
#line 186
    pi->poc.ty0 = pi->ty0;
#line 187
    pi->poc.tx0 = pi->tx0;
#line 188
    pi->poc.ty1 = pi->ty1;
#line 189
    pi->poc.tx1 = pi->tx1;
  }
#line 191
  pi->resno = pi->poc.resno0;
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 191
    if (! (pi->resno < pi->poc.resno1)) {
#line 191
      goto while_break___1;
    }
#line 192
    pi->y = pi->poc.ty0;
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      if (! (pi->y < pi->poc.ty1)) {
#line 192
        goto while_break___2;
      }
#line 193
      pi->x = pi->poc.tx0;
      {
#line 193
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 193
        if (! (pi->x < pi->poc.tx1)) {
#line 193
          goto while_break___3;
        }
#line 194
        pi->compno = pi->poc.compno0;
        {
#line 194
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 194
          if (! (pi->compno < pi->poc.compno1)) {
#line 194
            goto while_break___4;
          }
#line 200
          comp = pi->comps + pi->compno;
#line 201
          if (pi->resno >= comp->numresolutions) {
#line 202
            goto while_continue___4;
          }
          {
#line 204
          res = comp->resolutions + pi->resno;
#line 205
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 206
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 207
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 208
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 209
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 210
          rpx = res->pdx + levelno;
#line 211
          rpy = res->pdy + levelno;
          }
#line 212
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 213
            goto while_continue___4;
          }
#line 215
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 216
            goto while_continue___4;
          }
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          } else
#line 219
          if (res->ph == 0) {
#line 219
            goto while_continue___4;
          }
#line 221
          if (trx0 == trx1) {
#line 221
            goto while_continue___4;
          } else
#line 221
          if (try0 == try1) {
#line 221
            goto while_continue___4;
          }
          {
#line 223
          __cil_tmp30 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 223
          __cil_tmp28 = int_ceildiv(pi->x, comp->dx << levelno);
#line 223
          __cil_tmp29 = int_floordivpow2(__cil_tmp28, res->pdx);
#line 223
          prci = __cil_tmp29 - __cil_tmp30;
#line 225
          __cil_tmp33 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 225
          __cil_tmp31 = int_ceildiv(pi->y, comp->dy << levelno);
#line 225
          __cil_tmp32 = int_floordivpow2(__cil_tmp31, res->pdy);
#line 225
          prcj = __cil_tmp32 - __cil_tmp33;
#line 227
          pi->precno = prci + prcj * res->pw;
#line 228
          pi->layno = pi->poc.layno0;
          }
          {
#line 228
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 228
            if (! (pi->layno < pi->poc.layno1)) {
#line 228
              goto while_break___5;
            }
#line 229
            index___7 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 230
            if (! *(pi->include + index___7)) {
#line 231
              *(pi->include + index___7) = (short )1;
#line 232
              return (1);
            }
            LABEL_SKIP: ;
#line 228
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 194
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 193
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 192
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 191
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  return (0);
}
}
#line 244 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___8 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 245
  comp = (opj_pi_comp_t *)((void *)0);
#line 246
  res = (opj_pi_resolution_t *)((void *)0);
#line 247
  index___8 = (long )0;
#line 249
  if (! pi->first) {
#line 250
    comp = pi->comps + pi->compno;
#line 251
    goto LABEL_SKIP;
  } else {
#line 254
    pi->first = 0;
#line 255
    pi->dx = 0;
#line 256
    pi->dy = 0;
#line 257
    compno = 0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! (compno < pi->numcomps)) {
#line 257
        goto while_break;
      }
#line 258
      comp = pi->comps + compno;
#line 259
      resno = 0;
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (! (resno < comp->numresolutions)) {
#line 259
          goto while_break___0;
        }
#line 261
        res = comp->resolutions + resno;
#line 262
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 263
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 264
        if (! pi->dx) {
#line 264
          tmp = dx;
        } else {
          {
#line 264
          __cil_tmp9 = int_min(pi->dx, dx);
#line 264
          tmp = __cil_tmp9;
          }
        }
#line 264
        pi->dx = tmp;
#line 265
        if (! pi->dy) {
#line 265
          tmp___0 = dy;
        } else {
          {
#line 265
          __cil_tmp11 = int_min(pi->dy, dy);
#line 265
          tmp___0 = __cil_tmp11;
          }
        }
#line 265
        pi->dy = tmp___0;
#line 259
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 257
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 269
  if (! pi->tp_on) {
#line 270
    pi->poc.ty0 = pi->ty0;
#line 271
    pi->poc.tx0 = pi->tx0;
#line 272
    pi->poc.ty1 = pi->ty1;
#line 273
    pi->poc.tx1 = pi->tx1;
  }
#line 275
  pi->y = pi->poc.ty0;
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 275
    if (! (pi->y < pi->poc.ty1)) {
#line 275
      goto while_break___1;
    }
#line 276
    pi->x = pi->poc.tx0;
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (pi->x < pi->poc.tx1)) {
#line 276
        goto while_break___2;
      }
#line 277
      pi->compno = pi->poc.compno0;
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (pi->compno < pi->poc.compno1)) {
#line 277
          goto while_break___3;
        }
#line 278
        comp = pi->comps + pi->compno;
#line 279
        pi->resno = pi->poc.resno0;
        {
#line 279
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 279
          if (! (pi->resno < __cil_tmp15)) {
#line 279
            goto while_break___4;
          }
          {
#line 285
          res = comp->resolutions + pi->resno;
#line 286
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 287
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 288
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 289
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 290
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 291
          rpx = res->pdx + levelno;
#line 292
          rpy = res->pdy + levelno;
          }
#line 293
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 294
            goto while_continue___4;
          }
#line 296
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 297
            goto while_continue___4;
          }
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          } else
#line 300
          if (res->ph == 0) {
#line 300
            goto while_continue___4;
          }
#line 302
          if (trx0 == trx1) {
#line 302
            goto while_continue___4;
          } else
#line 302
          if (try0 == try1) {
#line 302
            goto while_continue___4;
          }
          {
#line 304
          __cil_tmp31 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 304
          __cil_tmp29 = int_ceildiv(pi->x, comp->dx << levelno);
#line 304
          __cil_tmp30 = int_floordivpow2(__cil_tmp29, res->pdx);
#line 304
          prci = __cil_tmp30 - __cil_tmp31;
#line 306
          __cil_tmp34 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 306
          __cil_tmp32 = int_ceildiv(pi->y, comp->dy << levelno);
#line 306
          __cil_tmp33 = int_floordivpow2(__cil_tmp32, res->pdy);
#line 306
          prcj = __cil_tmp33 - __cil_tmp34;
#line 308
          pi->precno = prci + prcj * res->pw;
#line 309
          pi->layno = pi->poc.layno0;
          }
          {
#line 309
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 309
            if (! (pi->layno < pi->poc.layno1)) {
#line 309
              goto while_break___5;
            }
#line 310
            index___8 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 311
            if (! *(pi->include + index___8)) {
#line 312
              *(pi->include + index___8) = (short )1;
#line 313
              return (1);
            }
            LABEL_SKIP: ;
#line 309
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 279
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 277
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 276
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (0);
}
}
#line 325 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___9 ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 326
  comp = (opj_pi_comp_t *)((void *)0);
#line 327
  res = (opj_pi_resolution_t *)((void *)0);
#line 328
  index___9 = (long )0;
#line 330
  if (! pi->first) {
#line 331
    comp = pi->comps + pi->compno;
#line 332
    goto LABEL_SKIP;
  } else {
#line 334
    pi->first = 0;
  }
#line 337
  pi->compno = pi->poc.compno0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (pi->compno < pi->poc.compno1)) {
#line 337
      goto while_break;
    }
#line 339
    comp = pi->comps + pi->compno;
#line 340
    pi->dx = 0;
#line 341
    pi->dy = 0;
#line 342
    resno = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (resno < comp->numresolutions)) {
#line 342
        goto while_break___0;
      }
#line 344
      res = comp->resolutions + resno;
#line 345
      dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 346
      dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 347
      if (! pi->dx) {
#line 347
        tmp = dx;
      } else {
        {
#line 347
        __cil_tmp8 = int_min(pi->dx, dx);
#line 347
        tmp = __cil_tmp8;
        }
      }
#line 347
      pi->dx = tmp;
#line 348
      if (! pi->dy) {
#line 348
        tmp___0 = dy;
      } else {
        {
#line 348
        __cil_tmp10 = int_min(pi->dy, dy);
#line 348
        tmp___0 = __cil_tmp10;
        }
      }
#line 348
      pi->dy = tmp___0;
#line 342
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    if (! pi->tp_on) {
#line 351
      pi->poc.ty0 = pi->ty0;
#line 352
      pi->poc.tx0 = pi->tx0;
#line 353
      pi->poc.ty1 = pi->ty1;
#line 354
      pi->poc.tx1 = pi->tx1;
    }
#line 356
    pi->y = pi->poc.ty0;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! (pi->y < pi->poc.ty1)) {
#line 356
        goto while_break___1;
      }
#line 357
      pi->x = pi->poc.tx0;
      {
#line 357
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 357
        if (! (pi->x < pi->poc.tx1)) {
#line 357
          goto while_break___2;
        }
#line 358
        pi->resno = pi->poc.resno0;
        {
#line 358
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 358
          if (! (pi->resno < __cil_tmp13)) {
#line 358
            goto while_break___3;
          }
          {
#line 364
          res = comp->resolutions + pi->resno;
#line 365
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 366
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 367
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 368
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 369
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 370
          rpx = res->pdx + levelno;
#line 371
          rpy = res->pdy + levelno;
          }
#line 372
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 373
            goto while_continue___3;
          }
#line 375
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 376
            goto while_continue___3;
          }
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          } else
#line 379
          if (res->ph == 0) {
#line 379
            goto while_continue___3;
          }
#line 381
          if (trx0 == trx1) {
#line 381
            goto while_continue___3;
          } else
#line 381
          if (try0 == try1) {
#line 381
            goto while_continue___3;
          }
          {
#line 383
          __cil_tmp29 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 383
          __cil_tmp27 = int_ceildiv(pi->x, comp->dx << levelno);
#line 383
          __cil_tmp28 = int_floordivpow2(__cil_tmp27, res->pdx);
#line 383
          prci = __cil_tmp28 - __cil_tmp29;
#line 385
          __cil_tmp32 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 385
          __cil_tmp30 = int_ceildiv(pi->y, comp->dy << levelno);
#line 385
          __cil_tmp31 = int_floordivpow2(__cil_tmp30, res->pdy);
#line 385
          prcj = __cil_tmp31 - __cil_tmp32;
#line 387
          pi->precno = prci + prcj * res->pw;
#line 388
          pi->layno = pi->poc.layno0;
          }
          {
#line 388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 388
            if (! (pi->layno < pi->poc.layno1)) {
#line 388
              goto while_break___4;
            }
#line 389
            index___9 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 390
            if (! *(pi->include + index___9)) {
#line 391
              *(pi->include + index___9) = (short )1;
#line 392
              return (1);
            }
            LABEL_SKIP: ;
#line 388
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 358
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 357
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 356
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 410 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) 
{ 
  int p ;
  int q ;
  int compno ;
  int resno ;
  int pino ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp12 ;
  int maxres ;
  int maxprec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void *__cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 413
  pi = (opj_pi_iterator_t *)((void *)0);
#line 414
  tcp = (opj_tcp_t *)((void *)0);
#line 415
  tccp = (opj_tccp_t *)((void *)0);
#line 417
  tcp = cp->tcps + tileno;
#line 419
  __cil_tmp12 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 419
  pi = (opj_pi_iterator_t *)__cil_tmp12;
  }
#line 420
  if (! pi) {
#line 422
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 425
  pino = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (pino < tcp->numpocs + 1)) {
#line 425
      goto while_break;
    }
    {
#line 426
    maxres = 0;
#line 427
    maxprec = 0;
#line 428
    p = tileno % cp->tw;
#line 429
    q = tileno / cp->tw;
#line 431
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 432
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 433
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 434
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 435
    (pi + pino)->numcomps = image->numcomps;
#line 437
    __cil_tmp19 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 437
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp19;
    }
#line 438
    if (! (pi + pino)->comps) {
      {
#line 440
      pi_destroy(pi, cp, tileno);
      }
#line 441
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 444
    compno = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (compno < pi->numcomps)) {
#line 444
        goto while_break___0;
      }
      {
#line 446
      comp = (pi + pino)->comps + compno;
#line 447
      tccp = tcp->tccps + compno;
#line 448
      comp->dx = (image->comps + compno)->dx;
#line 449
      comp->dy = (image->comps + compno)->dy;
#line 450
      comp->numresolutions = tccp->numresolutions;
#line 452
      __cil_tmp25 = calloc((unsigned long )comp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 452
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp25;
      }
#line 453
      if (! comp->resolutions) {
        {
#line 455
        pi_destroy(pi, cp, tileno);
        }
#line 456
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 459
      tcx0 = int_ceildiv(pi->tx0, comp->dx);
#line 460
      tcy0 = int_ceildiv(pi->ty0, comp->dy);
#line 461
      tcx1 = int_ceildiv(pi->tx1, comp->dx);
#line 462
      tcy1 = int_ceildiv(pi->ty1, comp->dy);
      }
#line 463
      if (comp->numresolutions > maxres) {
#line 464
        maxres = comp->numresolutions;
      }
#line 467
      resno = 0;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (! (resno < comp->numresolutions)) {
#line 467
          goto while_break___1;
        }
#line 471
        res = comp->resolutions + resno;
#line 472
        if (tccp->csty & 1) {
#line 473
          res->pdx = tccp->prcw[resno];
#line 474
          res->pdy = tccp->prch[resno];
        } else {
#line 476
          res->pdx = 15;
#line 477
          res->pdy = 15;
        }
        {
#line 479
        levelno = (comp->numresolutions - 1) - resno;
#line 480
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 481
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 482
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 483
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 484
        __cil_tmp44 = int_floordivpow2(rx0, res->pdx);
#line 484
        px0 = __cil_tmp44 << res->pdx;
#line 485
        __cil_tmp45 = int_floordivpow2(ry0, res->pdy);
#line 485
        py0 = __cil_tmp45 << res->pdy;
#line 486
        __cil_tmp46 = int_ceildivpow2(rx1, res->pdx);
#line 486
        px1 = __cil_tmp46 << res->pdx;
#line 487
        __cil_tmp47 = int_ceildivpow2(ry1, res->pdy);
#line 487
        py1 = __cil_tmp47 << res->pdy;
        }
#line 488
        if (rx0 == rx1) {
#line 488
          tmp = 0;
        } else {
#line 488
          tmp = (px1 - px0) >> res->pdx;
        }
#line 488
        res->pw = tmp;
#line 489
        if (ry0 == ry1) {
#line 489
          tmp___0 = 0;
        } else {
#line 489
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 489
        res->ph = tmp___0;
#line 491
        if (res->pw * res->ph > maxprec) {
#line 492
          maxprec = res->pw * res->ph;
        }
#line 467
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 444
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    tccp = tcp->tccps + 0;
#line 499
    (pi + pino)->step_p = 1;
#line 500
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 501
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 502
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 504
    if (pino == 0) {
      {
#line 505
      __cil_tmp52 = calloc((unsigned long )(((image->numcomps * maxres) * tcp->numlayers) * maxprec),
                           sizeof(short ));
#line 505
      (pi + pino)->include = (short *)__cil_tmp52;
      }
#line 506
      if (! (pi + pino)->include) {
        {
#line 508
        pi_destroy(pi, cp, tileno);
        }
#line 509
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 513
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 516
    if (tcp->POC == 0) {
#line 517
      (pi + pino)->first = 1;
#line 518
      (pi + pino)->poc.resno0 = 0;
#line 519
      (pi + pino)->poc.compno0 = 0;
#line 520
      (pi + pino)->poc.layno1 = tcp->numlayers;
#line 521
      (pi + pino)->poc.resno1 = maxres;
#line 522
      (pi + pino)->poc.compno1 = image->numcomps;
#line 523
      (pi + pino)->poc.prg = tcp->prg;
    } else {
#line 525
      (pi + pino)->first = 1;
#line 526
      (pi + pino)->poc.resno0 = tcp->pocs[pino].resno0;
#line 527
      (pi + pino)->poc.compno0 = tcp->pocs[pino].compno0;
#line 528
      (pi + pino)->poc.layno1 = tcp->pocs[pino].layno1;
#line 529
      (pi + pino)->poc.resno1 = tcp->pocs[pino].resno1;
#line 530
      (pi + pino)->poc.compno1 = tcp->pocs[pino].compno1;
#line 531
      (pi + pino)->poc.prg = tcp->pocs[pino].prg;
    }
#line 533
    (pi + pino)->poc.layno0 = 0;
#line 534
    (pi + pino)->poc.precno0 = 0;
#line 535
    (pi + pino)->poc.precno1 = maxprec;
#line 425
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (pi);
}
}
#line 543 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) 
{ 
  int p ;
  int q ;
  int pino ;
  int compno ;
  int resno ;
  int maxres ;
  int maxprec ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_pi_comp_t *comp___0 ;
  int dx ;
  int dy ;
  opj_pi_resolution_t *res___0 ;
  int __cil_tmp57 ;
  int tmp___1 ;
  int __cil_tmp59 ;
  int tmp___2 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  void *__cil_tmp63 ;
  int tmp___3 ;
  int __cil_tmp65 ;

  {
  {
#line 546
  maxres = 0;
#line 547
  maxprec = 0;
#line 548
  pi = (opj_pi_iterator_t *)((void *)0);
#line 549
  tcp = (opj_tcp_t *)((void *)0);
#line 550
  tccp = (opj_tccp_t *)((void *)0);
#line 552
  tcp = cp->tcps + tileno;
#line 554
  __cil_tmp15 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 554
  pi = (opj_pi_iterator_t *)__cil_tmp15;
  }
#line 555
  if (! pi) {
#line 555
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 556
  pi->tp_on = cp->tp_on;
#line 558
  pino = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (pino < tcp->numpocs + 1)) {
#line 558
      goto while_break;
    }
    {
#line 559
    p = tileno % cp->tw;
#line 560
    q = tileno / cp->tw;
#line 562
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 563
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 564
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 565
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 566
    (pi + pino)->numcomps = image->numcomps;
#line 568
    __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 568
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp20;
    }
#line 569
    if (! (pi + pino)->comps) {
      {
#line 570
      pi_destroy(pi, cp, tileno);
      }
#line 571
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 574
    compno = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (compno < (pi + pino)->numcomps)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      comp = (pi + pino)->comps + compno;
#line 577
      tccp = tcp->tccps + compno;
#line 578
      comp->dx = (image->comps + compno)->dx;
#line 579
      comp->dy = (image->comps + compno)->dy;
#line 580
      comp->numresolutions = tccp->numresolutions;
#line 582
      __cil_tmp26 = malloc((unsigned long )comp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 582
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp26;
      }
#line 583
      if (! comp->resolutions) {
        {
#line 584
        pi_destroy(pi, cp, tileno);
        }
#line 585
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 588
      tcx0 = int_ceildiv((pi + pino)->tx0, comp->dx);
#line 589
      tcy0 = int_ceildiv((pi + pino)->ty0, comp->dy);
#line 590
      tcx1 = int_ceildiv((pi + pino)->tx1, comp->dx);
#line 591
      tcy1 = int_ceildiv((pi + pino)->ty1, comp->dy);
      }
#line 592
      if (comp->numresolutions > maxres) {
#line 593
        maxres = comp->numresolutions;
      }
#line 596
      resno = 0;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 596
        if (! (resno < comp->numresolutions)) {
#line 596
          goto while_break___1;
        }
#line 600
        res = comp->resolutions + resno;
#line 601
        if (tccp->csty & 1) {
#line 602
          res->pdx = tccp->prcw[resno];
#line 603
          res->pdy = tccp->prch[resno];
        } else {
#line 605
          res->pdx = 15;
#line 606
          res->pdy = 15;
        }
        {
#line 608
        levelno = (comp->numresolutions - 1) - resno;
#line 609
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 610
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 611
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 612
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 613
        __cil_tmp45 = int_floordivpow2(rx0, res->pdx);
#line 613
        px0 = __cil_tmp45 << res->pdx;
#line 614
        __cil_tmp46 = int_floordivpow2(ry0, res->pdy);
#line 614
        py0 = __cil_tmp46 << res->pdy;
#line 615
        __cil_tmp47 = int_ceildivpow2(rx1, res->pdx);
#line 615
        px1 = __cil_tmp47 << res->pdx;
#line 616
        __cil_tmp48 = int_ceildivpow2(ry1, res->pdy);
#line 616
        py1 = __cil_tmp48 << res->pdy;
        }
#line 617
        if (rx0 == rx1) {
#line 617
          tmp = 0;
        } else {
#line 617
          tmp = (px1 - px0) >> res->pdx;
        }
#line 617
        res->pw = tmp;
#line 618
        if (ry0 == ry1) {
#line 618
          tmp___0 = 0;
        } else {
#line 618
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 618
        res->ph = tmp___0;
#line 620
        if (res->pw * res->ph > maxprec) {
#line 621
          maxprec = res->pw * res->ph;
        }
#line 596
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 574
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    tccp = tcp->tccps + 0;
#line 627
    (pi + pino)->step_p = 1;
#line 628
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 629
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 630
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 632
    compno = 0;
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (compno < pi->numcomps)) {
#line 632
        goto while_break___2;
      }
#line 633
      comp___0 = pi->comps + compno;
#line 634
      resno = 0;
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 634
        if (! (resno < comp___0->numresolutions)) {
#line 634
          goto while_break___3;
        }
#line 636
        res___0 = comp___0->resolutions + resno;
#line 637
        dx = comp___0->dx * (1 << (((res___0->pdx + comp___0->numresolutions) - 1) - resno));
#line 638
        dy = comp___0->dy * (1 << (((res___0->pdy + comp___0->numresolutions) - 1) - resno));
#line 639
        if (! pi->dx) {
#line 639
          tmp___1 = dx;
        } else {
          {
#line 639
          __cil_tmp57 = int_min(pi->dx, dx);
#line 639
          tmp___1 = __cil_tmp57;
          }
        }
#line 639
        (pi + pino)->dx = tmp___1;
#line 640
        if (! pi->dy) {
#line 640
          tmp___2 = dy;
        } else {
          {
#line 640
          __cil_tmp59 = int_min(pi->dy, dy);
#line 640
          tmp___2 = __cil_tmp59;
          }
        }
#line 640
        (pi + pino)->dy = tmp___2;
#line 634
        resno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 632
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    if (pino == 0) {
      {
#line 645
      __cil_tmp63 = calloc((unsigned long )(tcp->numlayers * (pi + pino)->step_l),
                           sizeof(short ));
#line 645
      (pi + pino)->include = (short *)__cil_tmp63;
      }
#line 646
      if (! (pi + pino)->include) {
        {
#line 647
        pi_destroy(pi, cp, tileno);
        }
#line 648
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 652
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 656
    if (tcp->POC) {
#line 656
      if ((unsigned int )cp->cinema) {
        _L___10: /* CIL Label */ 
#line 657
        tcp->pocs[pino].compS = tcp->pocs[pino].compno0;
#line 658
        tcp->pocs[pino].compE = tcp->pocs[pino].compno1;
#line 659
        tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
#line 660
        tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
#line 661
        tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
#line 662
        tcp->pocs[pino].prg = tcp->pocs[pino].prg1;
#line 663
        if (pino > 0) {
#line 664
          if (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) {
#line 664
            tmp___3 = tcp->pocs[pino - 1].layE;
          } else {
#line 664
            tmp___3 = 0;
          }
#line 664
          tcp->pocs[pino].layS = tmp___3;
        }
      } else
#line 656
      if (! cp->cinema) {
#line 656
        if ((unsigned int )t2_mode == 1U) {
#line 656
          goto _L___10;
        } else {
#line 656
          goto _L;
        }
      } else {
#line 656
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 666
      tcp->pocs[pino].compS = 0;
#line 667
      tcp->pocs[pino].compE = image->numcomps;
#line 668
      tcp->pocs[pino].resS = 0;
#line 669
      tcp->pocs[pino].resE = maxres;
#line 670
      tcp->pocs[pino].layS = 0;
#line 671
      tcp->pocs[pino].layE = tcp->numlayers;
#line 672
      tcp->pocs[pino].prg = tcp->prg;
    }
#line 674
    tcp->pocs[pino].prcS = 0;
#line 675
    tcp->pocs[pino].prcE = maxprec;
#line 676
    tcp->pocs[pino].txS = (pi + pino)->tx0;
#line 677
    tcp->pocs[pino].txE = (pi + pino)->tx1;
#line 678
    tcp->pocs[pino].tyS = (pi + pino)->ty0;
#line 679
    tcp->pocs[pino].tyE = (pi + pino)->ty1;
#line 680
    tcp->pocs[pino].dx = (pi + pino)->dx;
#line 681
    tcp->pocs[pino].dy = (pi + pino)->dy;
#line 558
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (pi);
}
}
#line 688 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) 
{ 
  int compno ;
  int pino ;
  opj_tcp_t *tcp ;
  opj_pi_comp_t *comp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 690
  tcp = cp->tcps + tileno;
#line 691
  if (pi) {
#line 692
    pino = 0;
    {
#line 692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 692
      if (! (pino < tcp->numpocs + 1)) {
#line 692
        goto while_break;
      }
#line 693
      if ((pi + pino)->comps) {
#line 694
        compno = 0;
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 694
          if (! (compno < pi->numcomps)) {
#line 694
            goto while_break___0;
          }
#line 695
          comp = (pi + pino)->comps + compno;
#line 696
          if (comp->resolutions) {
            {
#line 697
            free(comp->resolutions);
            }
          }
#line 694
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 700
        free((pi + pino)->comps);
        }
      }
#line 692
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    if (pi->include) {
      {
#line 704
      free(pi->include);
      }
    }
    {
#line 706
    free(pi);
    }
  }
  return;
}
}
#line 710 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
opj_bool pi_next(opj_pi_iterator_t *pi ) 
{ 
  opj_bool __cil_tmp2 ;
  opj_bool __cil_tmp3 ;
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
  {
#line 712
  if ((int )pi->poc.prg == 0) {
#line 712
    goto case_0;
  }
#line 714
  if ((int )pi->poc.prg == 1) {
#line 714
    goto case_1;
  }
#line 716
  if ((int )pi->poc.prg == 2) {
#line 716
    goto case_2;
  }
#line 718
  if ((int )pi->poc.prg == 3) {
#line 718
    goto case_3;
  }
#line 720
  if ((int )pi->poc.prg == 4) {
#line 720
    goto case_4;
  }
#line 722
  if ((int )pi->poc.prg == -1) {
#line 722
    goto case_neg_1;
  }
#line 711
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 713
  __cil_tmp2 = pi_next_lrcp(pi);
  }
#line 713
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 715
  __cil_tmp3 = pi_next_rlcp(pi);
  }
#line 715
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 717
  __cil_tmp4 = pi_next_rpcl(pi);
  }
#line 717
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 719
  __cil_tmp5 = pi_next_pcrl(pi);
  }
#line 719
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 721
  __cil_tmp6 = pi_next_cprl(pi);
  }
#line 721
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 723
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 726
  return (0);
}
}
#line 729 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/pi.c"
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  char prog[4] ;
  int i ;
  int incr_top ;
  int resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  int __cil_tmp15 ;

  {
#line 732
  incr_top = 1;
#line 732
  resetX = 0;
#line 733
  tcps = cp->tcps + tileno;
#line 734
  tcp = & tcps->pocs[pino];
#line 736
  (pi + pino)->first = 1;
#line 737
  (pi + pino)->poc.prg = tcp->prg;
  {
#line 740
  if ((int )tcp->prg == 4) {
#line 740
    goto case_4;
  }
#line 742
  if ((int )tcp->prg == 0) {
#line 742
    goto case_0;
  }
#line 744
  if ((int )tcp->prg == 3) {
#line 744
    goto case_3;
  }
#line 746
  if ((int )tcp->prg == 1) {
#line 746
    goto case_1;
  }
#line 748
  if ((int )tcp->prg == 2) {
#line 748
    goto case_2;
  }
#line 750
  if ((int )tcp->prg == -1) {
#line 750
    goto case_neg_1;
  }
#line 739
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 740
  strncpy((char *)prog, "CPRL\006V", (unsigned long )4);
  }
#line 741
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 742
  strncpy((char *)prog, "LRCP\006V", (unsigned long )4);
  }
#line 743
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 744
  strncpy((char *)prog, "PCRL", (unsigned long )4);
  }
#line 745
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 746
  strncpy((char *)prog, "RLCP\006V", (unsigned long )4);
  }
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 748
  strncpy((char *)prog, "RPCL\006V", (unsigned long )4);
  }
#line 749
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 751
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (! ((int )cp->tp_on && ((! cp->cinema && (unsigned int )t2_mode == 1U) || (unsigned int )cp->cinema))) {
#line 755
    (pi + pino)->poc.resno0 = tcp->resS;
#line 756
    (pi + pino)->poc.resno1 = tcp->resE;
#line 757
    (pi + pino)->poc.compno0 = tcp->compS;
#line 758
    (pi + pino)->poc.compno1 = tcp->compE;
#line 759
    (pi + pino)->poc.layno0 = tcp->layS;
#line 760
    (pi + pino)->poc.layno1 = tcp->layE;
#line 761
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 762
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 763
    (pi + pino)->poc.tx0 = tcp->txS;
#line 764
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 765
    (pi + pino)->poc.tx1 = tcp->txE;
#line 766
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else
#line 768
  if (tpnum < cur_totnum_tp) {
#line 769
    i = 3;
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (i >= 0)) {
#line 769
        goto while_break;
      }
      {
#line 771
      if ((int )prog[i] == 'C') {
#line 771
        goto case_67;
      }
#line 803
      if ((int )prog[i] == 'R') {
#line 803
        goto case_82;
      }
#line 835
      if ((int )prog[i] == 'L') {
#line 835
        goto case_76;
      }
#line 867
      if ((int )prog[i] == 'P') {
#line 867
        goto case_80;
      }
#line 870
      if ((int )prog[i] == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )prog[i] == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_67: /* CIL Label */ 
#line 772
      if (i > tppos) {
#line 773
        (pi + pino)->poc.compno0 = tcp->compS;
#line 774
        (pi + pino)->poc.compno1 = tcp->compE;
      } else
#line 776
      if (tpnum == 0) {
#line 777
        tcp->comp_t = tcp->compS;
#line 778
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 779
        (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 780
        (tcp->comp_t) ++;
      } else
#line 782
      if (incr_top == 1) {
#line 783
        if (tcp->comp_t == tcp->compE) {
#line 784
          tcp->comp_t = tcp->compS;
#line 785
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 786
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 787
          (tcp->comp_t) ++;
#line 788
          incr_top = 1;
        } else {
#line 790
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 791
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 792
          (tcp->comp_t) ++;
#line 793
          incr_top = 0;
        }
      } else {
#line 796
        (pi + pino)->poc.compno0 = tcp->comp_t - 1;
#line 797
        (pi + pino)->poc.compno1 = tcp->comp_t;
      }
#line 801
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 804
      if (i > tppos) {
#line 805
        (pi + pino)->poc.resno0 = tcp->resS;
#line 806
        (pi + pino)->poc.resno1 = tcp->resE;
      } else
#line 808
      if (tpnum == 0) {
#line 809
        tcp->res_t = tcp->resS;
#line 810
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 811
        (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 812
        (tcp->res_t) ++;
      } else
#line 814
      if (incr_top == 1) {
#line 815
        if (tcp->res_t == tcp->resE) {
#line 816
          tcp->res_t = tcp->resS;
#line 817
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 818
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 819
          (tcp->res_t) ++;
#line 820
          incr_top = 1;
        } else {
#line 822
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 823
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 824
          (tcp->res_t) ++;
#line 825
          incr_top = 0;
        }
      } else {
#line 828
        (pi + pino)->poc.resno0 = tcp->res_t - 1;
#line 829
        (pi + pino)->poc.resno1 = tcp->res_t;
      }
#line 833
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 836
      if (i > tppos) {
#line 837
        (pi + pino)->poc.layno0 = tcp->layS;
#line 838
        (pi + pino)->poc.layno1 = tcp->layE;
      } else
#line 840
      if (tpnum == 0) {
#line 841
        tcp->lay_t = tcp->layS;
#line 842
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 843
        (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 844
        (tcp->lay_t) ++;
      } else
#line 846
      if (incr_top == 1) {
#line 847
        if (tcp->lay_t == tcp->layE) {
#line 848
          tcp->lay_t = tcp->layS;
#line 849
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 850
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 851
          (tcp->lay_t) ++;
#line 852
          incr_top = 1;
        } else {
#line 854
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 855
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 856
          (tcp->lay_t) ++;
#line 857
          incr_top = 0;
        }
      } else {
#line 860
        (pi + pino)->poc.layno0 = tcp->lay_t - 1;
#line 861
        (pi + pino)->poc.layno1 = tcp->lay_t;
      }
#line 865
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 870
      if ((int )tcp->prg == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )tcp->prg == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 871
      if (i > tppos) {
#line 872
        (pi + pino)->poc.precno0 = tcp->prcS;
#line 873
        (pi + pino)->poc.precno1 = tcp->prcE;
      } else
#line 875
      if (tpnum == 0) {
#line 876
        tcp->prc_t = tcp->prcS;
#line 877
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 878
        (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 879
        (tcp->prc_t) ++;
      } else
#line 881
      if (incr_top == 1) {
#line 882
        if (tcp->prc_t == tcp->prcE) {
#line 883
          tcp->prc_t = tcp->prcS;
#line 884
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 885
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 886
          (tcp->prc_t) ++;
#line 887
          incr_top = 1;
        } else {
#line 889
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 890
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 891
          (tcp->prc_t) ++;
#line 892
          incr_top = 0;
        }
      } else {
#line 895
        (pi + pino)->poc.precno0 = tcp->prc_t - 1;
#line 896
        (pi + pino)->poc.precno1 = tcp->prc_t;
      }
#line 900
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 902
      if (i > tppos) {
#line 903
        (pi + pino)->poc.tx0 = tcp->txS;
#line 904
        (pi + pino)->poc.ty0 = tcp->tyS;
#line 905
        (pi + pino)->poc.tx1 = tcp->txE;
#line 906
        (pi + pino)->poc.ty1 = tcp->tyE;
      } else
#line 908
      if (tpnum == 0) {
#line 909
        tcp->tx0_t = tcp->txS;
#line 910
        tcp->ty0_t = tcp->tyS;
#line 911
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 912
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 913
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 914
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 915
        tcp->tx0_t = (pi + pino)->poc.tx1;
#line 916
        tcp->ty0_t = (pi + pino)->poc.ty1;
      } else
#line 918
      if (incr_top == 1) {
#line 919
        if (tcp->tx0_t >= tcp->txE) {
#line 920
          if (tcp->ty0_t >= tcp->tyE) {
#line 921
            tcp->ty0_t = tcp->tyS;
#line 922
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 923
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 924
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 925
            incr_top = 1;
#line 925
            resetX = 1;
          } else {
#line 927
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 928
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 929
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 930
            incr_top = 0;
#line 930
            resetX = 1;
          }
#line 932
          if (resetX == 1) {
#line 933
            tcp->tx0_t = tcp->txS;
#line 934
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 935
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 936
            tcp->tx0_t = (pi + pino)->poc.tx1;
          }
        } else {
#line 939
          (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 940
          (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 941
          tcp->tx0_t = (pi + pino)->poc.tx1;
#line 942
          (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 943
          (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 944
          incr_top = 0;
        }
      } else {
#line 947
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 948
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 949
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 950
        (pi + pino)->poc.ty1 = tcp->ty0_t;
      }
#line 954
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 956
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 769
      __cil_tmp15 = i;
#line 769
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 961
  return (0);
}
}
#line 61 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 62
  return ("1.5.2");
}
}
#line 65 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_dinfo_t *dinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 66
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_dinfo_t ));
#line 66
  dinfo = (opj_dinfo_t *)__cil_tmp3;
  }
#line 67
  if (! dinfo) {
#line 67
    return ((opj_dinfo_t *)((void *)0));
  }
#line 68
  dinfo->is_decompressor = 1;
  {
#line 71
  if ((int )format == 1) {
#line 71
    goto case_1;
  }
#line 71
  if ((int )format == 0) {
#line 71
    goto case_1;
  }
#line 79
  if ((int )format == 2) {
#line 79
    goto case_2;
  }
#line 88
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 73
  __cil_tmp4 = j2k_create_decompress((opj_common_ptr )dinfo);
#line 73
  dinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 74
  if (! dinfo->j2k_handle) {
    {
#line 75
    free(dinfo);
    }
#line 76
    return ((opj_dinfo_t *)((void *)0));
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 81
  __cil_tmp5 = jp2_create_decompress((opj_common_ptr )dinfo);
#line 81
  dinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 82
  if (! dinfo->jp2_handle) {
    {
#line 83
    free(dinfo);
    }
#line 84
    return ((opj_dinfo_t *)((void *)0));
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 89
  free(dinfo);
  }
#line 90
  return ((opj_dinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 93
  dinfo->codec_format = format;
#line 95
  return (dinfo);
}
}
#line 98 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_destroy_decompress(opj_dinfo_t *dinfo ) 
{ 


  {
#line 99
  if (dinfo) {
    {
#line 103
    if ((int )dinfo->codec_format == 1) {
#line 103
      goto case_1;
    }
#line 103
    if ((int )dinfo->codec_format == 0) {
#line 103
      goto case_1;
    }
#line 106
    if ((int )dinfo->codec_format == 2) {
#line 106
      goto case_2;
    }
#line 110
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 104
    j2k_destroy_decompress((opj_j2k_t *)dinfo->j2k_handle);
    }
#line 105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 107
    jp2_destroy_decompress((opj_jp2_t *)dinfo->jp2_handle);
    }
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 114
    free(dinfo);
    }
  }
  return;
}
}
#line 118 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 119
  if (parameters) {
    {
#line 120
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 122
    parameters->cp_layer = 0;
#line 123
    parameters->cp_reduce = 0;
#line 124
    parameters->cp_limit_decoding = (OPJ_LIMIT_DECODING )0;
#line 126
    parameters->decod_format = - 1;
#line 127
    parameters->cod_format = - 1;
#line 128
    parameters->flags = (unsigned int )0;
    }
  }
  return;
}
}
#line 139 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) 
{ 


  {
#line 140
  if (dinfo) {
#line 140
    if (parameters) {
      {
#line 143
      if ((int )dinfo->codec_format == 1) {
#line 143
        goto case_1;
      }
#line 143
      if ((int )dinfo->codec_format == 0) {
#line 143
        goto case_1;
      }
#line 146
      if ((int )dinfo->codec_format == 2) {
#line 146
        goto case_2;
      }
#line 150
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 144
      j2k_setup_decoder((opj_j2k_t *)dinfo->j2k_handle, parameters);
      }
#line 145
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 147
      jp2_setup_decoder((opj_jp2_t *)dinfo->jp2_handle, parameters);
      }
#line 148
      goto switch_break;
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 151
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 156 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) 
{ 
  opj_image_t *__cil_tmp3 ;

  {
  {
#line 157
  __cil_tmp3 = opj_decode_with_info(dinfo, cio, (opj_codestream_info_t *)((void *)0));
  }
#line 157
  return (__cil_tmp3);
}
}
#line 160 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *__cil_tmp4 ;
  opj_image_t *__cil_tmp5 ;
  opj_image_t *__cil_tmp6 ;

  {
#line 161
  if (dinfo) {
#line 161
    if (cio) {
      {
#line 163
      if ((int )dinfo->codec_format == 0) {
#line 163
        goto case_0;
      }
#line 165
      if ((int )dinfo->codec_format == 1) {
#line 165
        goto case_1;
      }
#line 167
      if ((int )dinfo->codec_format == 2) {
#line 167
        goto case_2;
      }
#line 170
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 164
      __cil_tmp4 = j2k_decode((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 164
      return (__cil_tmp4);
      case_1: /* CIL Label */ 
      {
#line 166
      __cil_tmp5 = j2k_decode_jpt_stream((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 166
      return (__cil_tmp5);
      case_2: /* CIL Label */ 
      {
#line 168
      __cil_tmp6 = opj_jp2_decode((opj_jp2_t *)dinfo->jp2_handle, cio, cstr_info);
      }
#line 168
      return (__cil_tmp6);
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 174
  return ((opj_image_t *)((void *)0));
}
}
#line 177 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_cinfo_t *cinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 178
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_cinfo_t ));
#line 178
  cinfo = (opj_cinfo_t *)__cil_tmp3;
  }
#line 179
  if (! cinfo) {
#line 179
    return ((opj_cinfo_t *)((void *)0));
  }
#line 180
  cinfo->is_decompressor = 0;
  {
#line 182
  if ((int )format == 0) {
#line 182
    goto case_0;
  }
#line 190
  if ((int )format == 2) {
#line 190
    goto case_2;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 184
  __cil_tmp4 = j2k_create_compress((opj_common_ptr )cinfo);
#line 184
  cinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 185
  if (! cinfo->j2k_handle) {
    {
#line 186
    free(cinfo);
    }
#line 187
    return ((opj_cinfo_t *)((void *)0));
  }
#line 189
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  __cil_tmp5 = jp2_create_compress((opj_common_ptr )cinfo);
#line 192
  cinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 193
  if (! cinfo->jp2_handle) {
    {
#line 194
    free(cinfo);
    }
#line 195
    return ((opj_cinfo_t *)((void *)0));
  }
#line 197
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 201
  free(cinfo);
  }
#line 202
  return ((opj_cinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 205
  cinfo->codec_format = format;
#line 207
  return (cinfo);
}
}
#line 210 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_destroy_compress(opj_cinfo_t *cinfo ) 
{ 


  {
#line 211
  if (cinfo) {
    {
#line 214
    if ((int )cinfo->codec_format == 0) {
#line 214
      goto case_0;
    }
#line 217
    if ((int )cinfo->codec_format == 2) {
#line 217
      goto case_2;
    }
#line 222
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 215
    j2k_destroy_compress((opj_j2k_t *)cinfo->j2k_handle);
    }
#line 216
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 218
    jp2_destroy_compress((opj_jp2_t *)cinfo->jp2_handle);
    }
#line 219
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 223
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 226
    free(cinfo);
    }
  }
  return;
}
}
#line 230 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 231
  if (parameters) {
    {
#line 232
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 234
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 235
    parameters->max_comp_size = 0;
#line 236
    parameters->numresolution = 6;
#line 237
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 238
    parameters->cblockw_init = 64;
#line 239
    parameters->cblockh_init = 64;
#line 240
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 241
    parameters->roi_compno = - 1;
#line 242
    parameters->subsampling_dx = 1;
#line 243
    parameters->subsampling_dy = 1;
#line 244
    parameters->tp_on = (char )0;
#line 245
    parameters->decod_format = - 1;
#line 246
    parameters->cod_format = - 1;
#line 247
    parameters->tcp_rates[0] = (float )0;
#line 248
    parameters->tcp_numlayers = 0;
#line 249
    parameters->cp_disto_alloc = 0;
#line 250
    parameters->cp_fixed_alloc = 0;
#line 251
    parameters->cp_fixed_quality = 0;
#line 252
    parameters->jpip_on = 0;
    }
  }
  return;
}
}
#line 288 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 


  {
#line 289
  if (cinfo) {
#line 289
    if (parameters) {
#line 289
      if (image) {
        {
#line 291
        if ((int )cinfo->codec_format == 0) {
#line 291
          goto case_0;
        }
#line 294
        if ((int )cinfo->codec_format == 2) {
#line 294
          goto case_2;
        }
#line 299
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 292
        j2k_setup_encoder((opj_j2k_t *)cinfo->j2k_handle, parameters, image);
        }
#line 293
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 295
        jp2_setup_encoder((opj_jp2_t *)cinfo->jp2_handle, parameters, image);
        }
#line 296
        goto switch_break;
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 300
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  return;
}
}
#line 305 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) 
{ 
  opj_bool __cil_tmp5 ;

  {
#line 306
  if (index___0 != (void *)0) {
    {
#line 307
    opj_event_msg((opj_common_ptr )cinfo, 2, "Set index to NULL when calling the opj_encode function.\nTo extract the index, use the opj_encode_with_info() function.\nNo index will be generated during this encoding\n");
    }
  }
  {
#line 310
  __cil_tmp5 = opj_encode_with_info(cinfo, cio, image, (opj_codestream_info_t *)((void *)0));
  }
#line 310
  return (__cil_tmp5);
}
}
#line 313 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) 
{ 
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
#line 314
  if (cinfo) {
#line 314
    if (cio) {
#line 314
      if (image) {
        {
#line 316
        if ((int )cinfo->codec_format == 0) {
#line 316
          goto case_0;
        }
#line 318
        if ((int )cinfo->codec_format == 2) {
#line 318
          goto case_2;
        }
#line 322
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 317
        __cil_tmp5 = j2k_encode((opj_j2k_t *)cinfo->j2k_handle, cio, image, cstr_info);
        }
#line 317
        return (__cil_tmp5);
        case_2: /* CIL Label */ 
        {
#line 319
        __cil_tmp6 = opj_jp2_encode((opj_jp2_t *)cinfo->jp2_handle, cio, image, cstr_info);
        }
#line 319
        return (__cil_tmp6);
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 323
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 326
  return (0);
}
}
#line 329 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  opj_tile_info_t *tile_info ;
  int __cil_tmp4 ;

  {
#line 330
  if (cstr_info) {
#line 332
    tileno = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 332
        goto while_break;
      }
      {
#line 333
      tile_info = cstr_info->tile + tileno;
#line 334
      free(tile_info->thresh);
#line 335
      free(tile_info->packet);
#line 336
      free(tile_info->tp);
#line 337
      free(tile_info->marker);
      }
#line 332
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 339
    free(cstr_info->tile);
#line 340
    free(cstr_info->marker);
#line 341
    free(cstr_info->numdecompos);
    }
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) ;
#line 50
static void mqc_renorme(opj_mqc_t *mqc ) ;
#line 55
static void mqc_codemps(opj_mqc_t *mqc ) ;
#line 60
static void mqc_codelps(opj_mqc_t *mqc ) ;
#line 65
static void mqc_setbits(opj_mqc_t *mqc ) ;
#line 71
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 77
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 82
static void mqc_bytein(opj_mqc_t *mqc ) ;
#line 87
__inline static void mqc_renormd(opj_mqc_t *mqc ) ;
#line 95 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 95
  {      {(unsigned int )22017, 0, & mqc_states[2], & mqc_states[3]}, 
        {(unsigned int )22017, 1, & mqc_states[3], & mqc_states[2]}, 
        {(unsigned int )13313, 0, & mqc_states[4], & mqc_states[12]}, 
        {(unsigned int )13313, 1, & mqc_states[5], & mqc_states[13]}, 
        {(unsigned int )6145, 0, & mqc_states[6], & mqc_states[18]}, 
        {(unsigned int )6145, 1, & mqc_states[7], & mqc_states[19]}, 
        {(unsigned int )2753, 0, & mqc_states[8], & mqc_states[24]}, 
        {(unsigned int )2753, 1, & mqc_states[9], & mqc_states[25]}, 
        {(unsigned int )1313, 0, & mqc_states[10], & mqc_states[58]}, 
        {(unsigned int )1313, 1, & mqc_states[11], & mqc_states[59]}, 
        {(unsigned int )545, 0, & mqc_states[76], & mqc_states[66]}, 
        {(unsigned int )545, 1, & mqc_states[77], & mqc_states[67]}, 
        {(unsigned int )22017, 0, & mqc_states[14], & mqc_states[13]}, 
        {(unsigned int )22017, 1, & mqc_states[15], & mqc_states[12]}, 
        {(unsigned int )21505, 0, & mqc_states[16], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[17], & mqc_states[29]}, 
        {(unsigned int )18433, 0, & mqc_states[18], & mqc_states[28]}, 
        {(unsigned int )18433, 1, & mqc_states[19], & mqc_states[29]}, 
        {(unsigned int )14337, 0, & mqc_states[20], & mqc_states[28]}, 
        {(unsigned int )14337, 1, & mqc_states[21], & mqc_states[29]}, 
        {(unsigned int )12289, 0, & mqc_states[22], & mqc_states[34]}, 
        {(unsigned int )12289, 1, & mqc_states[23], & mqc_states[35]}, 
        {(unsigned int )9217, 0, & mqc_states[24], & mqc_states[36]}, 
        {(unsigned int )9217, 1, & mqc_states[25], & mqc_states[37]}, 
        {(unsigned int )7169, 0, & mqc_states[26], & mqc_states[40]}, 
        {(unsigned int )7169, 1, & mqc_states[27], & mqc_states[41]}, 
        {(unsigned int )5633, 0, & mqc_states[58], & mqc_states[42]}, 
        {(unsigned int )5633, 1, & mqc_states[59], & mqc_states[43]}, 
        {(unsigned int )22017, 0, & mqc_states[30], & mqc_states[29]}, 
        {(unsigned int )22017, 1, & mqc_states[31], & mqc_states[28]}, 
        {(unsigned int )21505, 0, & mqc_states[32], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[33], & mqc_states[29]}, 
        {(unsigned int )20737, 0, & mqc_states[34], & mqc_states[30]}, 
        {(unsigned int )20737, 1, & mqc_states[35], & mqc_states[31]}, 
        {(unsigned int )18433, 0, & mqc_states[36], & mqc_states[32]}, 
        {(unsigned int )18433, 1, & mqc_states[37], & mqc_states[33]}, 
        {(unsigned int )14337, 0, & mqc_states[38], & mqc_states[34]}, 
        {(unsigned int )14337, 1, & mqc_states[39], & mqc_states[35]}, 
        {(unsigned int )13313, 0, & mqc_states[40], & mqc_states[36]}, 
        {(unsigned int )13313, 1, & mqc_states[41], & mqc_states[37]}, 
        {(unsigned int )12289, 0, & mqc_states[42], & mqc_states[38]}, 
        {(unsigned int )12289, 1, & mqc_states[43], & mqc_states[39]}, 
        {(unsigned int )10241, 0, & mqc_states[44], & mqc_states[38]}, 
        {(unsigned int )10241, 1, & mqc_states[45], & mqc_states[39]}, 
        {(unsigned int )9217, 0, & mqc_states[46], & mqc_states[40]}, 
        {(unsigned int )9217, 1, & mqc_states[47], & mqc_states[41]}, 
        {(unsigned int )8705, 0, & mqc_states[48], & mqc_states[42]}, 
        {(unsigned int )8705, 1, & mqc_states[49], & mqc_states[43]}, 
        {(unsigned int )7169, 0, & mqc_states[50], & mqc_states[44]}, 
        {(unsigned int )7169, 1, & mqc_states[51], & mqc_states[45]}, 
        {(unsigned int )6145, 0, & mqc_states[52], & mqc_states[46]}, 
        {(unsigned int )6145, 1, & mqc_states[53], & mqc_states[47]}, 
        {(unsigned int )5633, 0, & mqc_states[54], & mqc_states[48]}, 
        {(unsigned int )5633, 1, & mqc_states[55], & mqc_states[49]}, 
        {(unsigned int )5121, 0, & mqc_states[56], & mqc_states[50]}, 
        {(unsigned int )5121, 1, & mqc_states[57], & mqc_states[51]}, 
        {(unsigned int )4609, 0, & mqc_states[58], & mqc_states[52]}, 
        {(unsigned int )4609, 1, & mqc_states[59], & mqc_states[53]}, 
        {(unsigned int )4353, 0, & mqc_states[60], & mqc_states[54]}, 
        {(unsigned int )4353, 1, & mqc_states[61], & mqc_states[55]}, 
        {(unsigned int )2753, 0, & mqc_states[62], & mqc_states[56]}, 
        {(unsigned int )2753, 1, & mqc_states[63], & mqc_states[57]}, 
        {(unsigned int )2497, 0, & mqc_states[64], & mqc_states[58]}, 
        {(unsigned int )2497, 1, & mqc_states[65], & mqc_states[59]}, 
        {(unsigned int )2209, 0, & mqc_states[66], & mqc_states[60]}, 
        {(unsigned int )2209, 1, & mqc_states[67], & mqc_states[61]}, 
        {(unsigned int )1313, 0, & mqc_states[68], & mqc_states[62]}, 
        {(unsigned int )1313, 1, & mqc_states[69], & mqc_states[63]}, 
        {(unsigned int )1089, 0, & mqc_states[70], & mqc_states[64]}, 
        {(unsigned int )1089, 1, & mqc_states[71], & mqc_states[65]}, 
        {(unsigned int )673, 0, & mqc_states[72], & mqc_states[66]}, 
        {(unsigned int )673, 1, & mqc_states[73], & mqc_states[67]}, 
        {(unsigned int )545, 0, & mqc_states[74], & mqc_states[68]}, 
        {(unsigned int )545, 1, & mqc_states[75], & mqc_states[69]}, 
        {(unsigned int )321, 0, & mqc_states[76], & mqc_states[70]}, 
        {(unsigned int )321, 1, & mqc_states[77], & mqc_states[71]}, 
        {(unsigned int )273, 0, & mqc_states[78], & mqc_states[72]}, 
        {(unsigned int )273, 1, & mqc_states[79], & mqc_states[73]}, 
        {(unsigned int )133, 0, & mqc_states[80], & mqc_states[74]}, 
        {(unsigned int )133, 1, & mqc_states[81], & mqc_states[75]}, 
        {(unsigned int )73, 0, & mqc_states[82], & mqc_states[76]}, 
        {(unsigned int )73, 1, & mqc_states[83], & mqc_states[77]}, 
        {(unsigned int )37, 0, & mqc_states[84], & mqc_states[78]}, 
        {(unsigned int )37, 1, & mqc_states[85], & mqc_states[79]}, 
        {(unsigned int )21, 0, & mqc_states[86], & mqc_states[80]}, 
        {(unsigned int )21, 1, & mqc_states[87], & mqc_states[81]}, 
        {(unsigned int )9, 0, & mqc_states[88], & mqc_states[82]}, 
        {(unsigned int )9, 1, & mqc_states[89], & mqc_states[83]}, 
        {(unsigned int )5, 0, & mqc_states[90], & mqc_states[84]}, 
        {(unsigned int )5, 1, & mqc_states[91], & mqc_states[85]}, 
        {(unsigned int )1, 0, & mqc_states[90], & mqc_states[86]}, 
        {(unsigned int )1, 1, & mqc_states[91], & mqc_states[87]}, 
        {(unsigned int )22017, 0, & mqc_states[92], & mqc_states[92]}, 
        {(unsigned int )22017, 1, & mqc_states[93], & mqc_states[93]}};
#line 198 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;
  unsigned char *__cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;

  {
#line 199
  if ((int )*(mqc->bp) == 255) {
#line 200
    (mqc->bp) ++;
#line 201
    *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 202
    mqc->c &= (unsigned int )1048575;
#line 203
    mqc->ct = (unsigned int )7;
  } else
#line 205
  if ((mqc->c & 134217728U) == 0U) {
#line 206
    (mqc->bp) ++;
#line 207
    *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 208
    mqc->c &= (unsigned int )524287;
#line 209
    mqc->ct = (unsigned int )8;
  } else {
#line 211
    (*(mqc->bp)) ++;
#line 212
    if ((int )*(mqc->bp) == 255) {
#line 213
      mqc->c &= (unsigned int )134217727;
#line 214
      (mqc->bp) ++;
#line 215
      *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 216
      mqc->c &= (unsigned int )1048575;
#line 217
      mqc->ct = (unsigned int )7;
    } else {
#line 219
      (mqc->bp) ++;
#line 220
      *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 221
      mqc->c &= (unsigned int )524287;
#line 222
      mqc->ct = (unsigned int )8;
    }
  }
  return;
}
}
#line 228 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_renorme(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    mqc->a <<= 1;
#line 231
    mqc->c <<= 1;
#line 232
    __cil_tmp2 = mqc->ct;
#line 232
    (mqc->ct) --;
#line 233
    if (mqc->ct == 0U) {
      {
#line 234
      mqc_byteout(mqc);
      }
    }
#line 229
    if (! ((mqc->a & 32768U) == 0U)) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 239 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 240
  mqc->a -= (*(mqc->curctx))->qeval;
#line 241
  if ((mqc->a & 32768U) == 0U) {
#line 242
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 243
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 245
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 247
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 248
    mqc_renorme(mqc);
    }
  } else {
#line 250
    mqc->c += (*(mqc->curctx))->qeval;
  }
  return;
}
}
#line 254 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 255
  mqc->a -= (*(mqc->curctx))->qeval;
#line 256
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 259
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 261
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 262
  mqc_renorme(mqc);
  }
  return;
}
}
#line 265 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_setbits(opj_mqc_t *mqc ) 
{ 
  unsigned int tempc ;

  {
#line 266
  tempc = mqc->c + mqc->a;
#line 267
  mqc->c |= (unsigned int )65535;
#line 268
  if (mqc->c >= tempc) {
#line 269
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 273 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 275
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 276
    d = 1 - (*(mqc->curctx))->mps;
#line 277
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 279
    d = (*(mqc->curctx))->mps;
#line 280
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 283
  return (d);
}
}
#line 286 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 288
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 289
    mqc->a = (*(mqc->curctx))->qeval;
#line 290
    d = (*(mqc->curctx))->mps;
#line 291
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 293
    mqc->a = (*(mqc->curctx))->qeval;
#line 294
    d = 1 - (*(mqc->curctx))->mps;
#line 295
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 298
  return (d);
}
}
#line 309 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
static void mqc_bytein(opj_mqc_t *mqc ) 
{ 
  unsigned int c ;
  unsigned char *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 310
  if (mqc->bp != mqc->end) {
#line 312
    if (mqc->bp + 1 != mqc->end) {
#line 313
      c = (unsigned int )*(mqc->bp + 1);
    } else {
#line 315
      c = (unsigned int )255;
    }
#line 317
    if ((int )*(mqc->bp) == 255) {
#line 318
      if (c > 143U) {
#line 319
        mqc->c += (unsigned int )65280;
#line 320
        mqc->ct = (unsigned int )8;
      } else {
#line 322
        (mqc->bp) ++;
#line 323
        mqc->c += c << 9;
#line 324
        mqc->ct = (unsigned int )7;
      }
    } else {
#line 327
      (mqc->bp) ++;
#line 328
      mqc->c += c << 8;
#line 329
      mqc->ct = (unsigned int )8;
    }
  } else {
#line 332
    mqc->c += (unsigned int )65280;
#line 333
    mqc->ct = (unsigned int )8;
  }
  return;
}
}
#line 338 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
__inline static void mqc_renormd(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (mqc->ct == 0U) {
      {
#line 341
      mqc_bytein(mqc);
      }
    }
#line 343
    mqc->a <<= 1;
#line 344
    mqc->c <<= 1;
#line 345
    __cil_tmp2 = mqc->ct;
#line 345
    (mqc->ct) --;
#line 339
    if (! (mqc->a < 32768U)) {
#line 339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 355 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
opj_mqc_t *mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 356
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 356
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 360
  return (mqc);
}
}
#line 363 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 364
  if (mqc) {
    {
#line 370
    free(mqc);
    }
  }
  return;
}
}
#line 374 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
int mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 375
  return ((int )(mqc->bp - mqc->start));
}
}
#line 378 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) 
{ 


  {
#line 379
  mqc->curctx = & mqc->ctxs[(int )0];
#line 380
  mqc->a = (unsigned int )32768;
#line 381
  mqc->c = (unsigned int )0;
#line 382
  mqc->bp = bp - 1;
#line 383
  mqc->ct = (unsigned int )12;
#line 384
  if ((int )*(mqc->bp) == 255) {
#line 385
    mqc->ct = (unsigned int )13;
  }
#line 387
  mqc->start = bp;
  return;
}
}
#line 390 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_encode(opj_mqc_t *mqc , int d ) 
{ 


  {
#line 391
  if ((*(mqc->curctx))->mps == d) {
    {
#line 392
    mqc_codemps(mqc);
    }
  } else {
    {
#line 394
    mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 398 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_flush(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
  {
#line 399
  mqc_setbits(mqc);
#line 400
  mqc->c <<= mqc->ct;
#line 401
  mqc_byteout(mqc);
#line 402
  mqc->c <<= mqc->ct;
#line 403
  mqc_byteout(mqc);
  }
#line 405
  if ((int )*(mqc->bp) != 255) {
#line 406
    (mqc->bp) ++;
  }
  return;
}
}
#line 410 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 411
  mqc->c = (unsigned int )0;
#line 412
  mqc->ct = (unsigned int )8;
  return;
}
}
#line 418 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) 
{ 
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 419
  __cil_tmp3 = mqc->ct;
#line 419
  (mqc->ct) --;
#line 420
  mqc->c += (unsigned int )(d << mqc->ct);
#line 421
  if (mqc->ct == 0U) {
#line 422
    (mqc->bp) ++;
#line 423
    *(mqc->bp) = (unsigned char )mqc->c;
#line 424
    mqc->ct = (unsigned int )8;
#line 425
    if ((int )*(mqc->bp) == 255) {
#line 426
      mqc->ct = (unsigned int )7;
    }
#line 428
    mqc->c = (unsigned int )0;
  }
  return;
}
}
#line 432 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char bit_padding ;
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 435
  bit_padding = (unsigned char )0;
#line 437
  if (mqc->ct != 0U) {
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;
#line 438
      if (! (mqc->ct > 0U)) {
#line 438
        goto while_break;
      }
#line 439
      __cil_tmp3 = mqc->ct;
#line 439
      (mqc->ct) --;
#line 440
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 441
      bit_padding = (unsigned char )(((int )bit_padding + 1) & 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 443
    (mqc->bp) ++;
#line 444
    *(mqc->bp) = (unsigned char )mqc->c;
#line 445
    mqc->ct = (unsigned int )8;
#line 446
    mqc->c = (unsigned int )0;
  }
#line 449
  return (1);
}
}
#line 452 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 453
  mqc_resetstates(mqc);
#line 454
  mqc_setstate(mqc, 18, 0, 46);
#line 455
  mqc_setstate(mqc, 17, 0, 3);
#line 456
  mqc_setstate(mqc, 0, 0, 4);
  }
  return;
}
}
#line 459 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
int mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  int correction ;
  int n ;

  {
#line 460
  correction = 1;
#line 463
  n = (int )(12U - mqc->ct);
#line 464
  mqc->c <<= mqc->ct;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (n > 0)) {
#line 465
      goto while_break;
    }
    {
#line 466
    mqc_byteout(mqc);
#line 467
    n -= mqc->ct;
#line 468
    mqc->c <<= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  mqc_byteout(mqc);
  }
#line 472
  return (correction);
}
}
#line 475 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 477
  mqc->curctx = & mqc->ctxs[(int )0];
#line 478
  mqc->a = (unsigned int )32768;
#line 479
  mqc->c = (unsigned int )0;
#line 480
  mqc->ct = (unsigned int )12;
#line 481
  __cil_tmp2 = mqc->bp;
#line 481
  (mqc->bp) --;
#line 482
  if ((int )*(mqc->bp) == 255) {
#line 483
    mqc->ct = (unsigned int )13;
  }
  return;
}
}
#line 487 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  int k ;

  {
#line 488
  k = (int )((11U - mqc->ct) + 1U);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (k > 0)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc->c <<= mqc->ct;
#line 492
    mqc->ct = (unsigned int )0;
#line 493
    mqc_byteout(mqc);
#line 494
    k -= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if ((int )*(mqc->bp) != 255) {
    {
#line 498
    mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 502 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 504
  mqc->curctx = & mqc->ctxs[(int )18];
#line 506
  i = 1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < 5)) {
#line 506
      goto while_break;
    }
    {
#line 507
    mqc_encode(mqc, i % 2);
    }
#line 506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 511 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) 
{ 


  {
#line 512
  mqc->curctx = & mqc->ctxs[(int )0];
#line 513
  mqc->start = bp;
#line 514
  mqc->end = bp + len;
#line 515
  mqc->bp = bp;
#line 516
  if (len == 0) {
#line 516
    mqc->c = (unsigned int )(255 << 16);
  } else {
#line 517
    mqc->c = (unsigned int )((int )*(mqc->bp) << 16);
  }
  {
#line 556
  mqc_bytein(mqc);
#line 557
  mqc->c <<= 7;
#line 558
  mqc->ct -= (unsigned int )7;
#line 559
  mqc->a = (unsigned int )32768;
  }
  return;
}
}
#line 562 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
int mqc_decode(opj_mqc_t *mqc ) 
{ 
  int d ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 564
  mqc->a -= (*(mqc->curctx))->qeval;
#line 565
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 566
    d = mqc_lpsexchange(mqc);
#line 567
    mqc_renormd(mqc);
    }
  } else {
#line 569
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 570
    if ((mqc->a & 32768U) == 0U) {
      {
#line 571
      d = mqc_mpsexchange(mqc);
#line 572
      mqc_renormd(mqc);
      }
    } else {
#line 574
      d = (*(mqc->curctx))->mps;
    }
  }
#line 578
  return (d);
}
}
#line 581 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (i < 19)) {
#line 583
      goto while_break;
    }
#line 584
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 583
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 588 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/mqc.c"
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) 
{ 


  {
#line 589
  mqc->ctxs[ctxno] = & mqc_states[msb + (prob << 1)];
  return;
}
}
#line 37 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.c"
unsigned int jpt_read_VBAS_info(opj_cio_t *cio , unsigned int value ) 
{ 
  unsigned char elmt ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = cio_read(cio, 1);
#line 40
  elmt = (unsigned char )__cil_tmp4;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int )elmt >> 7 == 1)) {
#line 41
      goto while_break;
    }
    {
#line 42
    value <<= 7;
#line 43
    value |= (unsigned int )((int )elmt & 127);
#line 44
    __cil_tmp5 = cio_read(cio, 1);
#line 44
    elmt = (unsigned char )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  value <<= 7;
#line 47
  value |= (unsigned int )((int )elmt & 127);
#line 49
  return (value);
}
}
#line 56 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.c"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 57
  header->Id = (unsigned int )0;
#line 58
  header->last_byte = (unsigned int )0;
#line 59
  header->Class_Id = (unsigned int )0;
#line 60
  header->CSn_Id = (unsigned int )0;
#line 61
  header->Msg_offset = (unsigned int )0;
#line 62
  header->Msg_length = (unsigned int )0;
#line 63
  header->Layer_nb = (unsigned int )0;
  return;
}
}
#line 72 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.c"
void jpt_reinit_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 73
  header->Id = (unsigned int )0;
#line 74
  header->last_byte = (unsigned int )0;
#line 75
  header->Msg_offset = (unsigned int )0;
#line 76
  header->Msg_length = (unsigned int )0;
  return;
}
}
#line 83 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jpt.c"
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) 
{ 
  unsigned char elmt ;
  unsigned char Class ;
  unsigned char CSn ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 84
  Class = (unsigned char )0;
  {
#line 84
  CSn = (unsigned char )0;
#line 85
  jpt_reinit_msg_header(header);
#line 90
  __cil_tmp7 = cio_read(cio, 1);
#line 90
  elmt = (unsigned char )__cil_tmp7;
  }
  {
#line 94
  if ((((int )elmt >> 5) & 3) == 0) {
#line 94
    goto case_0;
  }
#line 97
  if ((((int )elmt >> 5) & 3) == 1) {
#line 97
    goto case_1;
  }
#line 101
  if ((((int )elmt >> 5) & 3) == 2) {
#line 101
    goto case_2;
  }
#line 105
  if ((((int )elmt >> 5) & 3) == 3) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 95
  opj_event_msg(cinfo, 1, "Forbidden value encounter in message header !!\n");
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
#line 98
  Class = (unsigned char )0;
#line 99
  CSn = (unsigned char )0;
#line 100
  goto switch_break;
  case_2: /* CIL Label */ 
#line 102
  Class = (unsigned char )1;
#line 103
  CSn = (unsigned char )0;
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
#line 106
  Class = (unsigned char )1;
#line 107
  CSn = (unsigned char )1;
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  if ((((int )elmt >> 4) & 1) == 1) {
#line 115
    header->last_byte = (unsigned int )1;
  }
#line 118
  header->Id |= (unsigned int )((int )elmt & 15);
#line 119
  if ((int )elmt >> 7 == 1) {
    {
#line 120
    header->Id = jpt_read_VBAS_info(cio, header->Id);
    }
  }
#line 125
  if ((int )Class == 1) {
    {
#line 126
    header->Class_Id = (unsigned int )0;
#line 127
    header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
    }
  }
#line 133
  if ((int )CSn == 1) {
    {
#line 134
    header->CSn_Id = (unsigned int )0;
#line 135
    header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
    }
  }
  {
#line 141
  header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
#line 146
  header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
  }
#line 151
  if ((header->Class_Id & 1U) == 1U) {
    {
#line 152
    header->Layer_nb = (unsigned int )0;
#line 153
    header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
    }
  }
  return;
}
}
#line 48 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 56
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 60
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 66
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 74
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 75
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) ;
#line 76
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 83
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 91
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 98
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) ;
#line 107
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 117
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 127
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 138
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) ;
#line 145
static void write_iptr(int offset , int length , opj_cio_t *cio ) ;
#line 154
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) ;
#line 161 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 162
  box->init_pos = cio_tell(cio);
#line 163
  __cil_tmp5 = cio_read(cio, 4);
#line 163
  box->length = (int )__cil_tmp5;
#line 164
  __cil_tmp6 = cio_read(cio, 4);
#line 164
  box->type = (int )__cil_tmp6;
  }
#line 165
  if (box->length == 1) {
    {
#line 166
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 166
    if (__cil_tmp7 != 0U) {
      {
#line 167
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 168
      return (0);
    }
    {
#line 170
    __cil_tmp8 = cio_read(cio, 4);
#line 170
    box->length = (int )__cil_tmp8;
    }
#line 171
    if (box->length == 0) {
      {
#line 172
      __cil_tmp9 = cio_numbytesleft(cio);
#line 172
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 174
  if (box->length == 0) {
    {
#line 175
    __cil_tmp10 = cio_numbytesleft(cio);
#line 175
    box->length = __cil_tmp10 + 8;
    }
  } else
#line 176
  if (box->length < 0) {
    {
#line 177
    opj_event_msg(cinfo, 1, "Integer overflow in box->length\n\220");
    }
#line 178
    return (0);
  }
#line 181
  return (1);
}
}
#line 208 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 211
  cinfo = jp2->cinfo;
#line 213
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 213
  if (__cil_tmp5 == 0) {
    {
#line 214
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 215
    return (0);
  }
#line 217
  if (1768449138 != box.type) {
    {
#line 218
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 219
    return (0);
  }
  {
#line 222
  jp2->h = cio_read(cio, 4);
#line 223
  jp2->w = cio_read(cio, 4);
#line 224
  jp2->numcomps = cio_read(cio, 2);
#line 225
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 225
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
#line 227
  jp2->bpc = cio_read(cio, 1);
#line 229
  jp2->C = cio_read(cio, 1);
#line 230
  jp2->UnkC = cio_read(cio, 1);
#line 231
  jp2->IPR = cio_read(cio, 1);
#line 233
  __cil_tmp14 = cio_tell(cio);
  }
#line 233
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 234
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n");
    }
#line 235
    return (0);
  }
#line 238
  return (1);
}
}
#line 241 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 244
  box.init_pos = cio_tell(cio);
#line 245
  cio_skip(cio, 4);
#line 246
  cio_write(cio, (unsigned long long )1768449138, 4);
#line 248
  cio_write(cio, (unsigned long long )jp2->h, 4);
#line 249
  cio_write(cio, (unsigned long long )jp2->w, 4);
#line 250
  cio_write(cio, (unsigned long long )jp2->numcomps, 2);
#line 252
  cio_write(cio, (unsigned long long )jp2->bpc, 1);
#line 254
  cio_write(cio, (unsigned long long )jp2->C, 1);
#line 255
  cio_write(cio, (unsigned long long )jp2->UnkC, 1);
#line 256
  cio_write(cio, (unsigned long long )jp2->IPR, 1);
#line 258
  __cil_tmp5 = cio_tell(cio);
#line 258
  box.length = __cil_tmp5 - box.init_pos;
#line 259
  cio_seek(cio, box.init_pos);
#line 260
  cio_write(cio, (unsigned long long )box.length, 4);
#line 261
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 264 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 268
  box.init_pos = cio_tell(cio);
#line 269
  cio_skip(cio, 4);
#line 270
  cio_write(cio, (unsigned long long )1651532643, 4);
#line 272
  i = (unsigned int )0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < jp2->numcomps)) {
#line 272
      goto while_break;
    }
    {
#line 273
    cio_write(cio, (unsigned long long )(jp2->comps + i)->bpcc, 1);
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  __cil_tmp7 = cio_tell(cio);
#line 276
  box.length = __cil_tmp7 - box.init_pos;
#line 277
  cio_seek(cio, box.init_pos);
#line 278
  cio_write(cio, (unsigned long long )box.length, 4);
#line 279
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 283 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 287
  cinfo = jp2->cinfo;
#line 289
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 289
  if (__cil_tmp6 == 0) {
    {
#line 290
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 291
    return (0);
  }
#line 293
  if (1651532643 != box.type) {
    {
#line 294
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\n");
    }
#line 295
    return (0);
  }
#line 298
  i = (unsigned int )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < jp2->numcomps)) {
#line 298
      goto while_break;
    }
    {
#line 299
    __cil_tmp7 = cio_read(cio, 1);
#line 299
    (jp2->comps + i)->bpcc = (int )__cil_tmp7;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  __cil_tmp9 = cio_tell(cio);
  }
#line 302
  if (__cil_tmp9 - box.init_pos != box.length) {
    {
#line 303
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 304
    return (0);
  }
#line 307
  return (1);
}
}
#line 310 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 313
  box.init_pos = cio_tell(cio);
#line 314
  cio_skip(cio, 4);
#line 315
  cio_write(cio, (unsigned long long )1668246642, 4);
#line 317
  cio_write(cio, (unsigned long long )jp2->meth, 1);
#line 318
  cio_write(cio, (unsigned long long )jp2->precedence, 1);
#line 319
  cio_write(cio, (unsigned long long )jp2->approx, 1);
  }
#line 321
  if (jp2->meth == 2U) {
#line 322
    jp2->enumcs = (unsigned int )0;
  }
  {
#line 324
  cio_write(cio, (unsigned long long )jp2->enumcs, 4);
#line 326
  __cil_tmp5 = cio_tell(cio);
#line 326
  box.length = __cil_tmp5 - box.init_pos;
#line 327
  cio_seek(cio, box.init_pos);
#line 328
  cio_write(cio, (unsigned long long )box.length, 4);
#line 329
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 332 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 334
  free((color->jp2_pclr)->channel_sign);
#line 335
  free((color->jp2_pclr)->channel_size);
#line 336
  free((color->jp2_pclr)->entries);
  }
#line 338
  if ((color->jp2_pclr)->cmap) {
    {
#line 338
    free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 340
  free(color->jp2_pclr);
#line 340
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 343 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void free_color_data(opj_jp2_color_t *color ) 
{ 


  {
#line 345
  if (color->jp2_pclr) {
    {
#line 347
    jp2_free_pclr(color);
    }
  }
#line 349
  if (color->jp2_cdef) {
#line 351
    if ((color->jp2_cdef)->info) {
      {
#line 351
      free((color->jp2_cdef)->info);
      }
    }
    {
#line 352
    free(color->jp2_cdef);
    }
  }
#line 354
  if (color->icc_profile_buf) {
    {
#line 354
    free(color->icc_profile_buf);
    }
  }
  return;
}
}
#line 357 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  int *src ;
  int *dst ;
  unsigned int j ;
  unsigned int max ;
  unsigned short i ;
  unsigned short nr_channels ;
  unsigned short cmp ;
  unsigned short pcol ;
  int k ;
  int top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 368
  channel_size = (color->jp2_pclr)->channel_size;
#line 369
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 370
  entries = (color->jp2_pclr)->entries;
#line 371
  cmap = (color->jp2_pclr)->cmap;
#line 372
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 374
  old_comps = image->comps;
#line 375
  __cil_tmp20 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 375
  new_comps = (opj_image_comp_t *)__cil_tmp20;
#line 378
  i = (unsigned short )0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((int )i < (int )nr_channels)) {
#line 378
      goto while_break;
    }
#line 380
    pcol = (unsigned short )(cmap + i)->pcol;
#line 380
    cmp = (cmap + i)->cmp;
#line 382
    if ((int )pcol < (int )nr_channels) {
#line 383
      *(new_comps + pcol) = *(old_comps + cmp);
    } else {
      {
#line 386
      opj_event_msg(cinfo, 1, "Error with pcol value %d (max: %d). skipping\n", (int )pcol,
                    (int )nr_channels);
      }
#line 387
      goto while_continue;
    }
#line 390
    if ((int )(cmap + i)->mtyp == 0) {
#line 392
      (old_comps + cmp)->data = (int *)((void *)0);
#line 392
      goto while_continue;
    }
    {
#line 395
    __cil_tmp21 = malloc((unsigned long )((old_comps + cmp)->w * (old_comps + cmp)->h) * sizeof(int ));
#line 395
    (new_comps + pcol)->data = (int *)__cil_tmp21;
#line 397
    (new_comps + pcol)->prec = (int )*(channel_size + i);
#line 398
    (new_comps + pcol)->sgnd = (int )*(channel_sign + i);
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 402
  i = (unsigned short )0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 402
    if (! ((int )i < (int )nr_channels)) {
#line 402
      goto while_break___0;
    }
#line 405
    if ((int )(cmap + i)->mtyp == 0) {
#line 405
      goto while_continue___0;
    }
#line 408
    cmp = (cmap + i)->cmp;
#line 408
    pcol = (unsigned short )(cmap + i)->pcol;
#line 409
    src = (old_comps + cmp)->data;
#line 410
    dst = (new_comps + pcol)->data;
#line 411
    max = (unsigned int )((new_comps + pcol)->w * (new_comps + pcol)->h);
#line 413
    j = (unsigned int )0;
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 413
      if (! (j < max)) {
#line 413
        goto while_break___1;
      }
#line 416
      k = *(src + j);
#line 416
      if (k < 0) {
#line 416
        k = 0;
      } else
#line 416
      if (k > top_k) {
#line 416
        k = top_k;
      }
#line 418
      *(dst + j) = (int )*(entries + (k * (int )nr_channels + (int )pcol));
#line 413
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 402
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 421
  max = (unsigned int )image->numcomps;
#line 422
  i = (unsigned short )0;
  {
#line 422
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 422
    if (! ((unsigned int )i < max)) {
#line 422
      goto while_break___2;
    }
#line 424
    if ((old_comps + i)->data) {
      {
#line 424
      free((old_comps + i)->data);
      }
    }
#line 422
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 426
  free(old_comps);
#line 427
  image->comps = new_comps;
#line 428
  image->numcomps = (int )nr_channels;
#line 430
  jp2_free_pclr(color);
  }
  return;
}
}
#line 434 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  unsigned short nr_entries ;
  unsigned short nr_channels ;
  unsigned short i ;
  unsigned short j ;
  unsigned char uc ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;
  unsigned int *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 450
  if (color->jp2_pclr) {
#line 450
    return (0);
  }
  {
#line 452
  __cil_tmp14 = cio_read(cio, 2);
#line 452
  nr_entries = (unsigned short )__cil_tmp14;
#line 453
  __cil_tmp15 = cio_read(cio, 1);
#line 453
  nr_channels = (unsigned short )__cil_tmp15;
#line 455
  __cil_tmp16 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(unsigned int ));
#line 455
  entries = (unsigned int *)__cil_tmp16;
#line 457
  __cil_tmp17 = malloc((unsigned long )nr_channels);
#line 457
  channel_size = (unsigned char *)__cil_tmp17;
#line 458
  __cil_tmp18 = malloc((unsigned long )nr_channels);
#line 458
  channel_sign = (unsigned char *)__cil_tmp18;
#line 460
  __cil_tmp19 = malloc(sizeof(opj_jp2_pclr_t ));
#line 460
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp19;
#line 461
  jp2_pclr->channel_sign = channel_sign;
#line 462
  jp2_pclr->channel_size = channel_size;
#line 463
  jp2_pclr->entries = entries;
#line 464
  jp2_pclr->nr_entries = nr_entries;
#line 465
  jp2_pclr->nr_channels = nr_channels;
#line 466
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 468
  color->jp2_pclr = jp2_pclr;
#line 470
  i = (unsigned short )0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! ((int )i < (int )nr_channels)) {
#line 470
      goto while_break;
    }
    {
#line 472
    __cil_tmp20 = cio_read(cio, 1);
#line 472
    uc = (unsigned char )__cil_tmp20;
#line 473
    *(channel_size + i) = (unsigned char )(((int )uc & 127) + 1);
    }
#line 474
    if ((int )uc & 128) {
#line 474
      tmp = 1;
    } else {
#line 474
      tmp = 0;
    }
#line 474
    *(channel_sign + i) = (unsigned char )tmp;
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  j = (unsigned short )0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! ((int )j < (int )nr_entries)) {
#line 477
      goto while_break___0;
    }
#line 479
    i = (unsigned short )0;
    {
#line 479
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 479
      if (! ((int )i < (int )nr_channels)) {
#line 479
        goto while_break___1;
      }
      {
#line 482
      __cil_tmp22 = entries;
#line 482
      entries ++;
#line 482
      *__cil_tmp22 = cio_read(cio, ((int )*(channel_size + i) + 7) >> 3);
      }
#line 479
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 477
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  return (1);
}
}
#line 489 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  unsigned short i ;
  unsigned short nr_channels ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 499
  if (color->jp2_pclr == (void *)0) {
#line 499
    return (0);
  }
#line 504
  if ((color->jp2_pclr)->cmap) {
#line 504
    return (0);
  }
  {
#line 506
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 507
  __cil_tmp8 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 507
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp8;
#line 510
  i = (unsigned short )0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int )i < (int )nr_channels)) {
#line 510
      goto while_break;
    }
    {
#line 512
    __cil_tmp9 = cio_read(cio, 2);
#line 512
    (cmap + i)->cmp = (unsigned short )__cil_tmp9;
#line 513
    __cil_tmp10 = cio_read(cio, 1);
#line 513
    (cmap + i)->mtyp = (unsigned char )__cil_tmp10;
#line 514
    __cil_tmp11 = cio_read(cio, 1);
#line 514
    (cmap + i)->pcol = (unsigned char )__cil_tmp11;
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  (color->jp2_pclr)->cmap = cmap;
#line 519
  return (1);
}
}
#line 522 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned short cn ;
  unsigned short typ ;
  unsigned short asoc ;
  unsigned short acn ;
  opj_image_comp_t saved ;

  {
#line 527
  info = (color->jp2_cdef)->info;
#line 528
  n = (color->jp2_cdef)->n;
#line 530
  i = (unsigned short )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((int )i < (int )n)) {
#line 530
      goto while_break;
    }
#line 533
    asoc = (info + i)->asoc;
#line 533
    if ((int )asoc == 0) {
#line 533
      goto while_continue;
    }
#line 535
    cn = (info + i)->cn;
#line 535
    typ = (info + i)->typ;
#line 535
    acn = (unsigned short )((int )asoc - 1);
#line 538
    if ((int )cn != (int )acn) {
      {
#line 542
      memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 543
      memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 544
      memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 546
      (info + i)->asoc = (unsigned short )((int )cn + 1);
#line 547
      (info + acn)->asoc = (unsigned short )((int )(info + acn)->cn + 1);
      }
    }
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  if ((color->jp2_cdef)->info) {
    {
#line 550
    free((color->jp2_cdef)->info);
    }
  }
  {
#line 552
  free(color->jp2_cdef);
#line 552
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 556 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_cdef(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 568
  if (color->jp2_cdef) {
#line 568
    return (0);
  }
  {
#line 570
  __cil_tmp8 = cio_read(cio, 2);
#line 570
  n = (unsigned short )__cil_tmp8;
  }
#line 570
  if ((int )n == 0) {
#line 570
    return (0);
  }
  {
#line 572
  __cil_tmp9 = malloc((unsigned long )n * sizeof(opj_jp2_cdef_info_t ));
#line 572
  info = (opj_jp2_cdef_info_t *)__cil_tmp9;
#line 575
  __cil_tmp10 = malloc(sizeof(opj_jp2_cdef_t ));
#line 575
  color->jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp10;
#line 576
  (color->jp2_cdef)->info = info;
#line 577
  (color->jp2_cdef)->n = n;
#line 579
  i = (unsigned short )0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! ((int )i < (int )n)) {
#line 579
      goto while_break;
    }
    {
#line 581
    __cil_tmp11 = cio_read(cio, 2);
#line 581
    (info + i)->cn = (unsigned short )__cil_tmp11;
#line 582
    __cil_tmp12 = cio_read(cio, 2);
#line 582
    (info + i)->typ = (unsigned short )__cil_tmp12;
#line 583
    __cil_tmp13 = cio_read(cio, 2);
#line 583
    (info + i)->asoc = (unsigned short )__cil_tmp13;
    }
#line 579
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return (1);
}
}
#line 589 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  int skip_len ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *start ;
  unsigned char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 598
  if (color->jp2_has_colr) {
#line 598
    return (0);
  }
  {
#line 600
  cinfo = jp2->cinfo;
#line 602
  jp2->meth = cio_read(cio, 1);
#line 603
  jp2->precedence = cio_read(cio, 1);
#line 604
  jp2->approx = cio_read(cio, 1);
  }
#line 606
  if (jp2->meth == 1U) {
    {
#line 608
    jp2->enumcs = cio_read(cio, 4);
    }
  } else
#line 611
  if (jp2->meth == 2U) {
    {
#line 614
    __cil_tmp11 = cio_tell(cio);
#line 614
    skip_len = (box->init_pos + box->length) - __cil_tmp11;
    }
#line 615
    if (skip_len < 0) {
      {
#line 617
      opj_event_msg(cinfo, 1, "Error with COLR box size\n");
      }
#line 618
      return (0);
    }
#line 620
    if (skip_len > 0) {
      {
#line 624
      start = cio_getbp(cio);
#line 625
      __cil_tmp14 = malloc((unsigned long )skip_len);
#line 625
      color->icc_profile_buf = (unsigned char *)__cil_tmp14;
#line 626
      color->icc_profile_len = skip_len;
#line 628
      __cil_tmp15 = cio_tell(cio);
#line 628
      cio_skip(cio, (box->init_pos + box->length) - __cil_tmp15);
#line 630
      memcpy(color->icc_profile_buf, start, (unsigned long )skip_len);
      }
    }
  }
  {
#line 634
  __cil_tmp16 = cio_tell(cio);
  }
#line 634
  if (__cil_tmp16 - box->init_pos != box->length) {
    {
#line 636
    opj_event_msg(cinfo, 1, "Error with COLR Box\n");
    }
#line 637
    return (0);
  }
#line 639
  color->jp2_has_colr = (unsigned char )1;
#line 641
  return (1);
}
}
#line 644 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_jp2_box_t box ;
  int jp2h_end ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  opj_bool __cil_tmp9 ;
  opj_bool __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_bool __cil_tmp13 ;
  opj_bool __cil_tmp14 ;
  opj_bool __cil_tmp15 ;
  opj_bool __cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_bool __cil_tmp18 ;
  opj_bool __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  opj_bool __cil_tmp21 ;

  {
  {
#line 649
  cinfo = jp2->cinfo;
#line 651
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 651
  if (__cil_tmp7 == 0) {
#line 651
    return (0);
  }
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (1785737832 != box.type) {
#line 655
      if (box.type == 1785737827) {
        {
#line 657
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\n");
        }
#line 658
        return (0);
      }
#line 660
      if (box.length <= 8) {
#line 660
        return (0);
      }
      {
#line 661
      cio_skip(cio, box.length - 8);
      }
#line 663
      if (cio->bp >= cio->end) {
#line 663
        return (0);
      }
      {
#line 665
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 665
      if (__cil_tmp8 == 0) {
#line 665
        return (0);
      }
    }
#line 652
    if (! (1785737832 != box.type)) {
#line 652
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  __cil_tmp9 = jp2_read_ihdr(jp2, cio);
  }
#line 669
  if (! __cil_tmp9) {
#line 670
    return (0);
  }
#line 671
  jp2h_end = box.init_pos + box.length;
#line 673
  if (jp2->bpc == 255U) {
    {
#line 675
    __cil_tmp10 = jp2_read_bpcc(jp2, cio);
    }
#line 675
    if (! __cil_tmp10) {
#line 676
      return (0);
    }
  }
  {
#line 678
  __cil_tmp11 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 678
  if (__cil_tmp11 == 0) {
#line 678
    return (0);
  }
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 680
    __cil_tmp12 = cio_tell(cio);
    }
#line 680
    if (! (__cil_tmp12 < jp2h_end)) {
#line 680
      goto while_break___0;
    }
#line 682
    if (box.type == 1668246642) {
      {
#line 684
      __cil_tmp13 = jp2_read_colr(jp2, cio, & box, color);
      }
#line 684
      if (! __cil_tmp13) {
#line 686
        if (box.length <= 8) {
#line 686
          return (0);
        }
        {
#line 687
        cio_seek(cio, box.init_pos + 8);
#line 688
        cio_skip(cio, box.length - 8);
        }
      }
      {
#line 690
      __cil_tmp14 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 690
      if (__cil_tmp14 == 0) {
#line 690
        return (0);
      }
#line 691
      goto while_continue___0;
    }
#line 693
    if (box.type == 1667523942) {
#line 693
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 695
        __cil_tmp15 = jp2_read_cdef(jp2, cio, & box, color);
        }
#line 695
        if (! __cil_tmp15) {
#line 697
          if (box.length <= 8) {
#line 697
            return (0);
          }
          {
#line 698
          cio_seek(cio, box.init_pos + 8);
#line 699
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 701
        __cil_tmp16 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 701
        if (__cil_tmp16 == 0) {
#line 701
          return (0);
        }
#line 702
        goto while_continue___0;
      }
    }
#line 704
    if (box.type == 1885564018) {
#line 704
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 706
        __cil_tmp17 = jp2_read_pclr(jp2, cio, & box, color);
        }
#line 706
        if (! __cil_tmp17) {
#line 708
          if (box.length <= 8) {
#line 708
            return (0);
          }
          {
#line 709
          cio_seek(cio, box.init_pos + 8);
#line 710
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 712
        __cil_tmp18 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 712
        if (__cil_tmp18 == 0) {
#line 712
          return (0);
        }
#line 713
        goto while_continue___0;
      }
    }
#line 715
    if (box.type == 1668112752) {
#line 715
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 717
        __cil_tmp19 = jp2_read_cmap(jp2, cio, & box, color);
        }
#line 717
        if (! __cil_tmp19) {
#line 719
          if (box.length <= 8) {
#line 719
            return (0);
          }
          {
#line 720
          cio_seek(cio, box.init_pos + 8);
#line 721
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 723
        __cil_tmp20 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 723
        if (__cil_tmp20 == 0) {
#line 723
          return (0);
        }
#line 724
        goto while_continue___0;
      }
    }
#line 726
    if (box.length <= 8) {
#line 726
      return (0);
    }
    {
#line 727
    cio_seek(cio, box.init_pos + 8);
#line 728
    cio_skip(cio, box.length - 8);
#line 729
    __cil_tmp21 = jp2_read_boxhdr(cinfo, cio, & box);
    }
#line 729
    if (__cil_tmp21 == 0) {
#line 729
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 733
  cio_seek(cio, jp2h_end);
  }
#line 736
  return ((int )color->jp2_has_colr == 1);
}
}
#line 740 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool opj_jp2_check_color(opj_image_t *image , opj_jp2_color_t *color ,
                                    opj_common_ptr cinfo ) 
{ 
  int i ;
  opj_jp2_cdef_info_t *info ;
  int n ;
  int __cil_tmp7 ;
  int nr_channels ;
  opj_jp2_cmap_comp_t *cmap ;
  opj_bool *pcol_usage ;
  opj_bool is_sane ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  int pcol ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 745
  if (color->jp2_cdef) {
#line 746
    info = (color->jp2_cdef)->info;
#line 747
    n = (int )(color->jp2_cdef)->n;
#line 749
    i = 0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! (i < n)) {
#line 749
        goto while_break;
      }
#line 750
      if ((int )(info + i)->cn >= image->numcomps) {
        {
#line 751
        opj_event_msg(cinfo, 1, "Invalid component index %d (>= %d).\n", (int )(info + i)->cn,
                      image->numcomps);
        }
#line 752
        return (0);
      }
#line 754
      if ((int )(info + i)->asoc > 0) {
#line 754
        if ((int )(info + i)->asoc - 1 >= image->numcomps) {
          {
#line 755
          opj_event_msg(cinfo, 1, "Invalid component index %d (>= %d).\n", (int )(info + i)->asoc - 1,
                        image->numcomps);
          }
#line 756
          return (0);
        }
      }
#line 749
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 763
  if (color->jp2_pclr) {
#line 763
    if ((color->jp2_pclr)->cmap) {
#line 764
      nr_channels = (int )(color->jp2_pclr)->nr_channels;
#line 765
      cmap = (color->jp2_pclr)->cmap;
#line 766
      is_sane = 1;
#line 769
      i = 0;
      {
#line 769
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 769
        if (! (i < nr_channels)) {
#line 769
          goto while_break___0;
        }
#line 770
        if ((int )(cmap + i)->cmp >= image->numcomps) {
          {
#line 771
          opj_event_msg(cinfo, 1, "Invalid component index %d (>= %d).\n\006V", (int )(cmap + i)->cmp,
                        image->numcomps);
#line 772
          is_sane = 0;
          }
        }
#line 769
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 776
      pcol_usage = (opj_bool *)calloc((unsigned long )nr_channels, sizeof(opj_bool ));
      }
#line 777
      if (! pcol_usage) {
        {
#line 778
        opj_event_msg(cinfo, 1, "Unexpected OOM.\n\220");
        }
#line 779
        return (0);
      }
#line 782
      i = 0;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        if (! (i < nr_channels)) {
#line 782
          goto while_break___1;
        }
#line 783
        pcol = (int )(cmap + i)->pcol;
#line 785
        if (pcol >= nr_channels) {
          {
#line 786
          opj_event_msg(cinfo, 1, "Invalid component/palette index for direct mapping %d.\n",
                        pcol);
#line 787
          is_sane = 0;
          }
        } else
#line 789
        if (*(pcol_usage + pcol)) {
#line 789
          if ((int )(cmap + i)->mtyp == 1) {
            {
#line 790
            opj_event_msg(cinfo, 1, "Component %d is mapped twice.\n", pcol);
#line 791
            is_sane = 0;
            }
          } else {
#line 789
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 793
        if ((int )(cmap + i)->mtyp == 0) {
#line 793
          if ((int )(cmap + i)->pcol != 0) {
            {
#line 796
            opj_event_msg(cinfo, 1, "Direct use at #%d however pcol=%d.\n", i, pcol);
#line 797
            is_sane = 0;
            }
          } else {
#line 800
            *(pcol_usage + pcol) = 1;
          }
        } else {
#line 800
          *(pcol_usage + pcol) = 1;
        }
#line 782
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 803
      i = 0;
      {
#line 803
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 803
        if (! (i < nr_channels)) {
#line 803
          goto while_break___2;
        }
#line 804
        if (! *(pcol_usage + i)) {
#line 804
          if ((int )(cmap + i)->mtyp != 0) {
            {
#line 805
            opj_event_msg(cinfo, 1, "Component %d doesn\'t have a mapping.\n", i);
#line 806
            is_sane = 0;
            }
          }
        }
#line 803
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 809
      free(pcol_usage);
      }
#line 810
      if (! is_sane) {
#line 811
        return (0);
      }
    }
  }
#line 815
  return (1);
}
}
#line 818 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  opj_jp2_color_t color ;
  opj_bool __cil_tmp7 ;
  opj_image_t *__cil_tmp8 ;
  opj_bool __cil_tmp9 ;

  {
#line 822
  image = (opj_image_t *)((void *)0);
#line 825
  if (! jp2) {
#line 827
    return ((opj_image_t *)((void *)0));
  } else
#line 825
  if (! cio) {
#line 827
    return ((opj_image_t *)((void *)0));
  }
  {
#line 829
  memset(& color, 0, sizeof(opj_jp2_color_t ));
#line 830
  cinfo = jp2->cinfo;
#line 833
  __cil_tmp7 = jp2_read_struct(jp2, cio, & color);
  }
#line 833
  if (! __cil_tmp7) {
    {
#line 835
    free_color_data(& color);
#line 836
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 837
    return ((opj_image_t *)((void *)0));
  }
  {
#line 841
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 843
  if (! image) {
    {
#line 845
    free_color_data(& color);
#line 846
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 847
    return ((opj_image_t *)((void *)0));
  }
#line 850
  if (! jp2->ignore_pclr_cmap_cdef) {
    {
#line 851
    __cil_tmp9 = opj_jp2_check_color(image, & color, cinfo);
    }
#line 851
    if (! __cil_tmp9) {
      {
#line 852
      opj_event_msg(cinfo, 1, "Failed to decode PCRL box\n");
      }
#line 853
      return ((opj_image_t *)((void *)0));
    }
#line 857
    if (jp2->enumcs == 16U) {
#line 858
      image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 859
    if (jp2->enumcs == 17U) {
#line 860
      image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 861
    if (jp2->enumcs == 18U) {
#line 862
      image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 864
      image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 866
    if (color.jp2_cdef) {
      {
#line 868
      jp2_apply_cdef(image, & color);
      }
    }
#line 870
    if (color.jp2_pclr) {
#line 873
      if (! (color.jp2_pclr)->cmap) {
        {
#line 874
        jp2_free_pclr(& color);
        }
      } else {
        {
#line 876
        jp2_apply_pclr(& color, image, cinfo);
        }
      }
    }
#line 878
    if (color.icc_profile_buf) {
#line 880
      image->icc_profile_buf = color.icc_profile_buf;
#line 881
      color.icc_profile_buf = (unsigned char *)((void *)0);
#line 882
      image->icc_profile_len = color.icc_profile_len;
    }
  }
#line 886
  return (image);
}
}
#line 891 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 894
  box.init_pos = cio_tell(cio);
#line 895
  cio_skip(cio, 4);
#line 896
  cio_write(cio, (unsigned long long )1785737832, 4);
#line 898
  jp2_write_ihdr(jp2, cio);
  }
#line 900
  if (jp2->bpc == 255U) {
    {
#line 901
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 903
  jp2_write_colr(jp2, cio);
#line 905
  __cil_tmp5 = cio_tell(cio);
#line 905
  box.length = __cil_tmp5 - box.init_pos;
#line 906
  cio_seek(cio, box.init_pos);
#line 907
  cio_write(cio, (unsigned long long )box.length, 4);
#line 908
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 911 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 915
  box.init_pos = cio_tell(cio);
#line 916
  cio_skip(cio, 4);
#line 917
  cio_write(cio, (unsigned long long )1718909296, 4);
#line 919
  cio_write(cio, (unsigned long long )jp2->brand, 4);
#line 920
  cio_write(cio, (unsigned long long )jp2->minversion, 4);
#line 922
  i = (unsigned int )0;
  }
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! (i < jp2->numcl)) {
#line 922
      goto while_break;
    }
    {
#line 923
    cio_write(cio, (unsigned long long )*(jp2->cl + i), 4);
    }
#line 922
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 926
  __cil_tmp7 = cio_tell(cio);
#line 926
  box.length = __cil_tmp7 - box.init_pos;
#line 927
  cio_seek(cio, box.init_pos);
#line 928
  cio_write(cio, (unsigned long long )box.length, 4);
#line 929
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 932 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 936
  cinfo = jp2->cinfo;
#line 938
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 938
  if (__cil_tmp6 == 0) {
    {
#line 939
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 940
    return (0);
  }
#line 942
  if (1718909296 != box.type) {
    {
#line 943
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\nV");
    }
#line 944
    return (0);
  }
  {
#line 947
  jp2->brand = cio_read(cio, 4);
#line 948
  jp2->minversion = cio_read(cio, 4);
#line 949
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 952
  __cil_tmp9 = cio_numbytesleft(cio);
  }
#line 952
  if (__cil_tmp9 < (int )jp2->numcl * 4) {
    {
#line 953
    __cil_tmp10 = cio_numbytesleft(cio);
#line 953
    opj_event_msg(cinfo, 1, "Not enough bytes in FTYP Box (expected %d, but only %d left)\n",
                  (int )jp2->numcl * 4, __cil_tmp10);
    }
#line 956
    return (0);
  }
  {
#line 958
  __cil_tmp11 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 958
  jp2->cl = (unsigned int *)__cil_tmp11;
#line 960
  i = 0;
  }
  {
#line 960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 960
    if (! (i < (int )jp2->numcl)) {
#line 960
      goto while_break;
    }
    {
#line 961
    *(jp2->cl + i) = cio_read(cio, 4);
    }
#line 960
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 964
  __cil_tmp14 = cio_tell(cio);
  }
#line 964
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 965
    opj_event_msg(cinfo, 1, "Error with FTYP Box\n");
    }
#line 966
    return (0);
  }
#line 969
  return (1);
}
}
#line 972 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 976
  j2k = jp2->j2k;
#line 978
  box.init_pos = cio_tell(cio);
#line 979
  cio_skip(cio, 4);
#line 980
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 983
  __cil_tmp10 = cio_tell(cio);
#line 983
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 984
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 984
  if (! __cil_tmp11) {
    {
#line 985
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 986
    return (0);
  }
  {
#line 988
  __cil_tmp12 = cio_tell(cio);
#line 988
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 990
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 991
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 993
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 994
  cio_seek(cio, box.init_pos);
#line 995
  cio_write(cio, (unsigned long long )box.length, 4);
#line 996
  cio_seek(cio, box.init_pos + box.length);
  }
#line 998
  return (box.length);
}
}
#line 1001 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1004
  cinfo = jp2->cinfo;
#line 1006
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 1006
  if (__cil_tmp7 == 0) {
    {
#line 1007
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 1008
    return (0);
  }
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1011
    if (1785737827 != box.type) {
#line 1012
      if (box.length <= 8) {
#line 1012
        return (0);
      }
      {
#line 1013
      cio_skip(cio, box.length - 8);
#line 1014
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 1014
      if (__cil_tmp8 == 0) {
#line 1014
        return (0);
      }
    }
#line 1010
    if (! (1785737827 != box.type)) {
#line 1010
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1018
  __cil_tmp9 = cio_tell(cio);
#line 1018
  *j2k_codestream_offset = (unsigned int )__cil_tmp9;
  }
#line 1019
  if (box.length <= 8) {
#line 1019
    return (0);
  }
#line 1020
  *j2k_codestream_length = (unsigned int )(box.length - 8);
#line 1022
  return (1);
}
}
#line 1025 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 1028
  box.init_pos = cio_tell(cio);
#line 1029
  cio_skip(cio, 4);
#line 1030
  cio_write(cio, (unsigned long long )1783636000, 4);
#line 1031
  cio_write(cio, (unsigned long long )218793738, 4);
#line 1033
  __cil_tmp4 = cio_tell(cio);
#line 1033
  box.length = __cil_tmp4 - box.init_pos;
#line 1034
  cio_seek(cio, box.init_pos);
#line 1035
  cio_write(cio, (unsigned long long )box.length, 4);
#line 1036
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 1039 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1042
  cinfo = jp2->cinfo;
#line 1044
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 1044
  if (__cil_tmp5 == 0) {
    {
#line 1045
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 1046
    return (0);
  }
#line 1048
  if (1783636000 != box.type) {
    {
#line 1049
    opj_event_msg(cinfo, 1, "Expected JP Marker\n");
    }
#line 1050
    return (0);
  }
  {
#line 1052
  __cil_tmp6 = cio_read(cio, 4);
  }
#line 1052
  if (218793738U != __cil_tmp6) {
    {
#line 1053
    opj_event_msg(cinfo, 1, "Error with JP Marker\n");
    }
#line 1054
    return (0);
  }
  {
#line 1056
  __cil_tmp7 = cio_tell(cio);
  }
#line 1056
  if (__cil_tmp7 - box.init_pos != box.length) {
    {
#line 1057
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 1058
    return (0);
  }
#line 1061
  return (1);
}
}
#line 1065 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;
  opj_bool __cil_tmp7 ;

  {
  {
#line 1067
  __cil_tmp4 = jp2_read_jp(jp2, cio);
  }
#line 1067
  if (! __cil_tmp4) {
#line 1068
    return (0);
  }
  {
#line 1069
  __cil_tmp5 = jp2_read_ftyp(jp2, cio);
  }
#line 1069
  if (! __cil_tmp5) {
#line 1070
    return (0);
  }
  {
#line 1071
  __cil_tmp6 = jp2_read_jp2h(jp2, cio, color);
  }
#line 1071
  if (! __cil_tmp6) {
#line 1072
    return (0);
  }
  {
#line 1073
  __cil_tmp7 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 1073
  if (! __cil_tmp7) {
#line 1074
    return (0);
  }
#line 1076
  return (1);
}
}
#line 1080 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1084
  lenp = cio_tell(cio);
#line 1085
  cio_skip(cio, 4);
#line 1086
  cio_write(cio, (unsigned long long )1718183032, 4);
#line 1088
  write_prxy(offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
#line 1090
  __cil_tmp9 = cio_tell(cio);
#line 1090
  len = __cil_tmp9 - lenp;
#line 1091
  cio_seek(cio, lenp);
#line 1092
  cio_write(cio, (unsigned long long )len, 4);
#line 1093
  cio_seek(cio, lenp + len);
  }
#line 1095
  return (len);
}
}
#line 1098 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1102
  lenp = cio_tell(cio);
#line 1103
  cio_skip(cio, 4);
#line 1104
  cio_write(cio, (unsigned long long )1886550137, 4);
#line 1106
  cio_write(cio, (unsigned long long )offset_jp2c, 8);
#line 1107
  cio_write(cio, (unsigned long long )length_jp2c, 4);
#line 1108
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 1110
  cio_write(cio, (unsigned long long )1, 1);
#line 1112
  cio_write(cio, (unsigned long long )offset_idx, 8);
#line 1113
  cio_write(cio, (unsigned long long )length_idx, 4);
#line 1114
  cio_write(cio, (unsigned long long )1667851384, 4);
#line 1116
  __cil_tmp9 = cio_tell(cio);
#line 1116
  len = __cil_tmp9 - lenp;
#line 1117
  cio_seek(cio, lenp);
#line 1118
  cio_write(cio, (unsigned long long )len, 4);
#line 1119
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1122 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
static void write_iptr(int offset , int length , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1126
  lenp = cio_tell(cio);
#line 1127
  cio_skip(cio, 4);
#line 1128
  cio_write(cio, (unsigned long long )1768977522, 4);
#line 1130
  cio_write(cio, (unsigned long long )offset, 8);
#line 1131
  cio_write(cio, (unsigned long long )length, 8);
#line 1133
  __cil_tmp7 = cio_tell(cio);
#line 1133
  len = __cil_tmp7 - lenp;
#line 1134
  cio_seek(cio, lenp);
#line 1135
  cio_write(cio, (unsigned long long )len, 4);
#line 1136
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1144 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1145
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 1145
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1146
  if (jp2) {
    {
#line 1147
    jp2->cinfo = cinfo;
#line 1149
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 1150
    if (jp2->j2k == (void *)0) {
      {
#line 1151
      jp2_destroy_decompress(jp2);
      }
#line 1152
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1155
  return (jp2);
}
}
#line 1158 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1159
  if (jp2) {
    {
#line 1161
    j2k_destroy_decompress(jp2->j2k);
    }
#line 1163
    if (jp2->comps) {
      {
#line 1164
      free(jp2->comps);
      }
    }
#line 1166
    if (jp2->cl) {
      {
#line 1167
      free(jp2->cl);
      }
    }
    {
#line 1169
    free(jp2);
    }
  }
  return;
}
}
#line 1173 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1175
  j2k_setup_decoder(jp2->j2k, parameters);
#line 1177
  jp2->ignore_pclr_cmap_cdef = (opj_bool )(parameters->flags & 1U);
  }
  return;
}
}
#line 1184 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1185
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 1185
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1186
  if (jp2) {
    {
#line 1187
    memset(jp2, 0, sizeof(opj_jp2_t ));
#line 1188
    jp2->cinfo = cinfo;
#line 1190
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 1191
    if (jp2->j2k == (void *)0) {
      {
#line 1192
      jp2_destroy_compress(jp2);
      }
#line 1193
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1196
  return (jp2);
}
}
#line 1199 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1200
  if (jp2) {
    {
#line 1202
    j2k_destroy_compress(jp2->j2k);
    }
#line 1204
    if (jp2->comps) {
      {
#line 1205
      free(jp2->comps);
      }
    }
#line 1207
    if (jp2->cl) {
      {
#line 1208
      free(jp2->cl);
      }
    }
    {
#line 1210
    free(jp2);
    }
  }
  return;
}
}
#line 1214 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1218
  if (! jp2) {
#line 1219
    return;
  } else
#line 1218
  if (! parameters) {
#line 1219
    return;
  } else
#line 1218
  if (! image) {
#line 1219
    return;
  }
#line 1225
  if (image->numcomps < 1) {
    {
    {
#line 1226
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1227
    return;
  } else
#line 1225
  if (image->numcomps > 16384) {
    {
    {
#line 1226
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1227
    return;
  }
  {
#line 1230
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 1237
  jp2->brand = (unsigned int )1785737760;
#line 1238
  jp2->minversion = (unsigned int )0;
#line 1239
  jp2->numcl = (unsigned int )1;
#line 1240
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 1240
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 1241
  *(jp2->cl + 0) = (unsigned int )1785737760;
#line 1245
  jp2->numcomps = (unsigned int )image->numcomps;
#line 1246
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1246
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 1247
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 1248
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 1250
  depth_0 = (image->comps + 0)->prec - 1;
#line 1251
  sign = (image->comps + 0)->sgnd;
#line 1252
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 1253
  i = 1;
  }
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1253
    if (! (i < image->numcomps)) {
#line 1253
      goto while_break;
    }
#line 1254
    depth = (image->comps + i)->prec - 1;
#line 1255
    sign = (image->comps + i)->sgnd;
#line 1256
    if (depth_0 != depth) {
#line 1257
      jp2->bpc = (unsigned int )255;
    }
#line 1253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  jp2->C = (unsigned int )7;
#line 1260
  jp2->UnkC = (unsigned int )0;
#line 1261
  jp2->IPR = (unsigned int )0;
#line 1265
  i = 0;
  {
#line 1265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1265
    if (! (i < image->numcomps)) {
#line 1265
      goto while_break___0;
    }
#line 1266
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 1265
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1268
  jp2->meth = (unsigned int )1;
#line 1269
  if ((int )image->color_space == 1) {
#line 1270
    jp2->enumcs = (unsigned int )16;
  } else
#line 1271
  if ((int )image->color_space == 2) {
#line 1272
    jp2->enumcs = (unsigned int )17;
  } else
#line 1273
  if ((int )image->color_space == 3) {
#line 1274
    jp2->enumcs = (unsigned int )18;
  }
#line 1275
  jp2->precedence = (unsigned int )0;
#line 1276
  jp2->approx = (unsigned int )0;
#line 1278
  jp2->jpip_on = parameters->jpip_on;
  return;
}
}
#line 1281 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/jp2.c"
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int pos_iptr ;
  int pos_cidx ;
  int pos_jp2c ;
  int len_jp2c ;
  int len_cidx ;
  int end_pos ;
  int pos_fidx ;
  int len_fidx ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1284
  pos_iptr = - 1;
#line 1284
  pos_jp2c = pos_iptr;
#line 1289
  jp2_write_jp(cio);
#line 1291
  jp2_write_ftyp(jp2, cio);
#line 1293
  jp2_write_jp2h(jp2, cio);
  }
#line 1295
  if (jp2->jpip_on) {
    {
#line 1296
    pos_iptr = cio_tell(cio);
#line 1297
    cio_skip(cio, 24);
#line 1299
    pos_jp2c = cio_tell(cio);
    }
  }
  {
#line 1303
  len_jp2c = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 1303
  if (! len_jp2c) {
    {
#line 1304
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 1305
    return (0);
  }
#line 1308
  if (jp2->jpip_on) {
    {
#line 1309
    pos_cidx = cio_tell(cio);
#line 1311
    len_cidx = write_cidx(pos_jp2c + 8, cio, image, *cstr_info, len_jp2c - 8);
#line 1313
    pos_fidx = cio_tell(cio);
#line 1314
    len_fidx = write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
#line 1316
    end_pos = cio_tell(cio);
#line 1318
    cio_seek(cio, pos_iptr);
#line 1319
    write_iptr(pos_fidx, len_fidx, cio);
#line 1321
    cio_seek(cio, end_pos);
    }
  }
#line 1324
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 36 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 47 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 52
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 57
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 62
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 67
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 72
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 78
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 84
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 89
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 94
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 100
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 105
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 111
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 118
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 123
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 128
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 134
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 139
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 144
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 149
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 154
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 159
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 164
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 169
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 174
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 179
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 184
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 189
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 194
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 200
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 205
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 212
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 217
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 222
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 227
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 232
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 240
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 249
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 261 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 270 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 272
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! ((int )po->enum_prog != -1)) {
#line 272
      goto while_break;
    }
#line 273
    if ((int )po->enum_prog == (int )prg_order) {
#line 274
      goto while_break;
    }
#line 272
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return ((char *)po->str_prog);
}
}
#line 281 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 284
  tpnum = 1;
  {
#line 284
  tpend = 0;
#line 285
  tcp = cp->tcps + tileno;
#line 286
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 288
  if ((int )cp->tp_on == 1) {
#line 289
    i = 0;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if (! (i < 4)) {
#line 289
        goto while_break;
      }
#line 290
      if (tpend != 1) {
#line 291
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 292
          tpend = 1;
#line 292
          cp->tp_pos = i;
        }
        {
#line 295
        if ((int )*(prog + i) == 'C') {
#line 295
          goto case_67;
        }
#line 298
        if ((int )*(prog + i) == 'R') {
#line 298
          goto case_82;
        }
#line 301
        if ((int )*(prog + i) == 'P') {
#line 301
          goto case_80;
        }
#line 304
        if ((int )*(prog + i) == 'L') {
#line 304
          goto case_76;
        }
#line 294
        goto switch_break;
        case_67: /* CIL Label */ 
#line 296
        tpnum *= tcp->pocs[pino].compE;
#line 297
        goto switch_break;
        case_82: /* CIL Label */ 
#line 299
        tpnum *= tcp->pocs[pino].resE;
#line 300
        goto switch_break;
        case_80: /* CIL Label */ 
#line 302
        tpnum *= tcp->pocs[pino].prcE;
#line 303
        goto switch_break;
        case_76: /* CIL Label */ 
#line 305
        tpnum *= tcp->pocs[pino].layE;
#line 306
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 289
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 311
    tpnum = 1;
  }
#line 313
  return (tpnum);
}
}
#line 317 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 318
  totnum_tp = 0;
#line 322
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 322
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 323
  tileno = 0;
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (tileno < cp->tw * cp->th)) {
#line 323
      goto while_break;
    }
#line 324
    cur_totnum_tp = 0;
#line 325
    tcp = cp->tcps + tileno;
#line 326
    pino = 0;
    {
#line 326
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (pino <= tcp->numpocs)) {
#line 326
        goto while_break___0;
      }
      {
#line 327
      tp_num = 0;
#line 328
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 328
      pi = __cil_tmp13;
      }
#line 329
      if (! pi) {
#line 329
        return (- 1);
      }
      {
#line 330
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 331
      totnum_tp += tp_num;
#line 332
      cur_totnum_tp += tp_num;
#line 333
      pi_destroy(pi, cp, tileno);
      }
#line 326
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 335
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 337
    if (j2k->cstr_info) {
      {
#line 338
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 339
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 339
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 323
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (totnum_tp);
}
}
#line 346 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;
  int __cil_tmp3 ;

  {
  {
#line 347
  cio = j2k->cio;
#line 348
  cio_write(cio, (unsigned long long )65359, 2);
  }
#line 350
  if (j2k->cstr_info) {
    {
#line 351
    __cil_tmp3 = cio_tell(cio);
#line 351
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65359, __cil_tmp3, 0);
    }
  }
  return;
}
}
#line 362 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 363
  j2k->state = 2;
#line 365
  if (j2k->cstr_info) {
    {
#line 366
    __cil_tmp2 = cio_tell(j2k->cio);
#line 366
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 367
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 367
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
  return;
}
}
#line 371 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  cio = j2k->cio;
#line 376
  image = j2k->image;
#line 377
  cp = j2k->cp;
#line 379
  cio_write(cio, (unsigned long long )65361, 2);
#line 380
  lenp = cio_tell(cio);
#line 381
  cio_skip(cio, 2);
#line 382
  cio_write(cio, (unsigned long long )cp->rsiz, 2);
#line 383
  cio_write(cio, (unsigned long long )image->x1, 4);
#line 384
  cio_write(cio, (unsigned long long )image->y1, 4);
#line 385
  cio_write(cio, (unsigned long long )image->x0, 4);
#line 386
  cio_write(cio, (unsigned long long )image->y0, 4);
#line 387
  cio_write(cio, (unsigned long long )cp->tdx, 4);
#line 388
  cio_write(cio, (unsigned long long )cp->tdy, 4);
#line 389
  cio_write(cio, (unsigned long long )cp->tx0, 4);
#line 390
  cio_write(cio, (unsigned long long )cp->ty0, 4);
#line 391
  cio_write(cio, (unsigned long long )image->numcomps, 2);
#line 392
  i = 0;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (i < image->numcomps)) {
#line 392
      goto while_break;
    }
    {
#line 393
    cio_write(cio, (unsigned long long )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 394
    cio_write(cio, (unsigned long long )(image->comps + i)->dx, 1);
#line 395
    cio_write(cio, (unsigned long long )(image->comps + i)->dy, 1);
    }
#line 392
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  __cil_tmp10 = cio_tell(cio);
#line 397
  len = __cil_tmp10 - lenp;
#line 398
  cio_seek(cio, lenp);
#line 399
  cio_write(cio, (unsigned long long )len, 2);
#line 400
  cio_seek(cio, lenp + len);
  }
#line 402
  if (j2k->cstr_info) {
    {
#line 403
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65361, lenp, len);
    }
  }
  return;
}
}
#line 406 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int n_comps ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int tmp ;
  unsigned int __cil_tmp18 ;
  int tmp___0 ;
  void *__cil_tmp20 ;
  int tmp___1 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp37 ;

  {
  {
#line 410
  cio = j2k->cio;
#line 411
  image = j2k->image;
#line 412
  cp = j2k->cp;
#line 414
  __cil_tmp8 = cio_read(cio, 2);
#line 414
  len = (int )__cil_tmp8;
#line 415
  cio_read(cio, 2);
#line 416
  __cil_tmp9 = cio_read(cio, 4);
#line 416
  image->x1 = (int )__cil_tmp9;
#line 417
  __cil_tmp10 = cio_read(cio, 4);
#line 417
  image->y1 = (int )__cil_tmp10;
#line 418
  __cil_tmp11 = cio_read(cio, 4);
#line 418
  image->x0 = (int )__cil_tmp11;
#line 419
  __cil_tmp12 = cio_read(cio, 4);
#line 419
  image->y0 = (int )__cil_tmp12;
#line 420
  __cil_tmp13 = cio_read(cio, 4);
#line 420
  cp->tdx = (int )__cil_tmp13;
#line 421
  __cil_tmp14 = cio_read(cio, 4);
#line 421
  cp->tdy = (int )__cil_tmp14;
#line 422
  __cil_tmp15 = cio_read(cio, 4);
#line 422
  cp->tx0 = (int )__cil_tmp15;
#line 423
  __cil_tmp16 = cio_read(cio, 4);
#line 423
  cp->ty0 = (int )__cil_tmp16;
  }
#line 425
  if (image->x0 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->x1 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->y0 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  } else
#line 425
  if (image->y1 < 0) {
    {
    {
    {
    {
#line 426
    opj_event_msg(j2k->cinfo, 1, "invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n\230\001",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 429
    return;
  }
  {
#line 432
  n_comps = ((len - 36) - 2) / 3;
#line 434
  __cil_tmp18 = cio_read(cio, 2);
#line 434
  image->numcomps = (int )__cil_tmp18;
  }
#line 438
  if (image->x0 > image->x1) {
    {
    {
#line 439
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: negative image size (%d x %d)\n",
                  image->x1 - image->x0, image->y1 - image->y0);
    }
    }
#line 440
    return;
  } else
#line 438
  if (image->y0 > image->y1) {
    {
    {
#line 439
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: negative image size (%d x %d)\n",
                  image->x1 - image->x0, image->y1 - image->y0);
    }
    }
#line 440
    return;
  }
#line 443
  if (! (cp->tdx * cp->tdy)) {
    {
#line 444
    opj_event_msg(j2k->cinfo, 1, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n",
                  cp->tdx, cp->tdy);
    }
#line 445
    return;
  }
#line 449
  if ((long long )image->x1 * (long long )image->y1 != (long long )(image->x1 * image->y1)) {
    {
#line 450
    opj_event_msg(j2k->cinfo, 1, "Prevent buffer overflow (x1: %d, y1: %d)\n", image->x1,
                  image->y1);
    }
#line 451
    return;
  }
#line 496
  if (! (cp->tdx * cp->tdy)) {
    {
#line 497
    opj_event_msg(j2k->cinfo, 1, "invalid tile size (tdx: %d, tdy: %d)\n", cp->tdx,
                  cp->tdy);
    }
#line 498
    return;
  }
  {
#line 501
  __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 501
  image->comps = (opj_image_comp_t *)__cil_tmp20;
#line 502
  i = 0;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (i < image->numcomps)) {
#line 502
      goto while_break;
    }
    {
#line 504
    __cil_tmp22 = cio_read(cio, 1);
#line 504
    tmp___1 = (int )__cil_tmp22;
#line 505
    (image->comps + i)->prec = (tmp___1 & 127) + 1;
#line 506
    (image->comps + i)->sgnd = tmp___1 >> 7;
#line 507
    __cil_tmp23 = cio_read(cio, 1);
#line 507
    (image->comps + i)->dx = (int )__cil_tmp23;
#line 508
    __cil_tmp24 = cio_read(cio, 1);
#line 508
    (image->comps + i)->dy = (int )__cil_tmp24;
    }
#line 540
    if (! ((image->comps + i)->dx * (image->comps + i)->dy)) {
      {
#line 541
      opj_event_msg(j2k->cinfo, 1, "JPWL: invalid component size (dx: %d, dy: %d)\n",
                    (image->comps + i)->dx, (image->comps + i)->dy);
      }
#line 542
      return;
    }
#line 545
    (image->comps + i)->resno_decoded = 0;
#line 546
    (image->comps + i)->factor = cp->reduce;
#line 502
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 550
  cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
#line 592
  __cil_tmp28 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 592
  cp->tcps = (opj_tcp_t *)__cil_tmp28;
  }
#line 593
  if (cp->tcps == (void *)0) {
    {
#line 595
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 596
    return;
  }
  {
#line 598
  __cil_tmp29 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 598
  cp->tileno = (int *)__cil_tmp29;
  }
#line 599
  if (cp->tileno == (void *)0) {
    {
#line 601
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 602
    return;
  }
#line 604
  cp->tileno_size = 0;
#line 619
  i = 0;
  {
#line 619
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 619
    if (! (i < cp->tw * cp->th)) {
#line 619
      goto while_break___0;
    }
#line 620
    (cp->tcps + i)->POC = 0;
#line 621
    (cp->tcps + i)->numpocs = 0;
#line 622
    (cp->tcps + i)->first = 1;
#line 619
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 626
  cp->ppm = 0;
#line 627
  cp->ppm_data = (unsigned char *)((void *)0);
#line 628
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 629
  cp->ppm_previous = 0;
#line 630
  cp->ppm_store = 0;
#line 632
  __cil_tmp31 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 632
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp31;
#line 633
  i = 0;
  }
  {
#line 633
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 633
    if (! (i < cp->tw * cp->th)) {
#line 633
      goto while_break___1;
    }
    {
#line 634
    __cil_tmp32 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 634
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp32;
    }
#line 633
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 636
  __cil_tmp34 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 636
  j2k->tile_data = (unsigned char **)__cil_tmp34;
#line 637
  __cil_tmp35 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 637
  j2k->tile_len = (int *)__cil_tmp35;
#line 638
  j2k->state = 4;
  }
#line 641
  if (j2k->cstr_info) {
    {
#line 642
    cstr_info = j2k->cstr_info;
#line 643
    cstr_info->image_w = image->x1 - image->x0;
#line 644
    cstr_info->image_h = image->y1 - image->y0;
#line 645
    cstr_info->numcomps = image->numcomps;
#line 646
    cstr_info->tw = cp->tw;
#line 647
    cstr_info->th = cp->th;
#line 648
    cstr_info->tile_x = cp->tdx;
#line 649
    cstr_info->tile_y = cp->tdy;
#line 650
    cstr_info->tile_Ox = cp->tx0;
#line 651
    cstr_info->tile_Oy = cp->ty0;
#line 652
    __cil_tmp37 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 652
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp37;
    }
  }
  return;
}
}
#line 656 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 660
  if ((j2k->cp)->comment) {
    {
#line 661
    cio = j2k->cio;
#line 662
    comment = (j2k->cp)->comment;
#line 664
    cio_write(cio, (unsigned long long )65380, 2);
#line 665
    lenp = cio_tell(cio);
#line 666
    cio_skip(cio, 2);
#line 667
    cio_write(cio, (unsigned long long )1, 2);
#line 668
    i = (unsigned int )0;
    }
    {
#line 668
    while (1) {
      while_continue: /* CIL Label */ ;
#line 668
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 668
        goto while_break;
      }
      {
#line 669
      cio_write(cio, (unsigned long long )*(comment + i), 1);
      }
#line 668
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 671
    __cil_tmp10 = cio_tell(cio);
#line 671
    len = __cil_tmp10 - lenp;
#line 672
    cio_seek(cio, lenp);
#line 673
    cio_write(cio, (unsigned long long )len, 2);
#line 674
    cio_seek(cio, lenp + len);
    }
#line 677
    if (j2k->cstr_info) {
      {
#line 678
      j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65380, lenp, len);
      }
    }
  }
  return;
}
}
#line 683 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 686
  cio = j2k->cio;
#line 688
  __cil_tmp4 = cio_read(cio, 2);
#line 688
  len = (int )__cil_tmp4;
#line 689
  cio_skip(cio, len - 2);
  }
  return;
}
}
#line 692 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 695
  cp = j2k->cp;
#line 696
  tcp = cp->tcps + j2k->curtileno;
#line 697
  tccp = tcp->tccps + compno;
#line 698
  cio = j2k->cio;
#line 700
  cio_write(cio, (unsigned long long )(tccp->numresolutions - 1), 1);
#line 701
  cio_write(cio, (unsigned long long )(tccp->cblkw - 2), 1);
#line 702
  cio_write(cio, (unsigned long long )(tccp->cblkh - 2), 1);
#line 703
  cio_write(cio, (unsigned long long )tccp->cblksty, 1);
#line 704
  cio_write(cio, (unsigned long long )tccp->qmfbid, 1);
  }
#line 706
  if (tccp->csty & 1) {
#line 707
    i = 0;
    {
#line 707
    while (1) {
      while_continue: /* CIL Label */ ;
#line 707
      if (! (i < tccp->numresolutions)) {
#line 707
        goto while_break;
      }
      {
#line 708
      cio_write(cio, (unsigned long long )(tccp->prcw[i] + (tccp->prch[i] << 4)),
                1);
      }
#line 707
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 713 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 716
  cp = j2k->cp;
#line 717
  if (j2k->state == 16) {
#line 717
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 717
    tmp = j2k->default_tcp;
  }
  {
#line 717
  tcp = tmp;
#line 718
  tccp = tcp->tccps + compno;
#line 719
  cio = j2k->cio;
#line 721
  __cil_tmp9 = cio_read(cio, 1);
#line 721
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 724
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 725
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 727
    j2k->state |= 128;
    }
  }
#line 729
  if (tccp->numresolutions > 33) {
    {
#line 730
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
                  compno, tccp->numresolutions, 33);
#line 732
    j2k->state |= 128;
#line 733
    tccp->numresolutions = 33;
    }
  }
  {
#line 736
  __cil_tmp10 = cio_read(cio, 1);
#line 736
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 737
  __cil_tmp11 = cio_read(cio, 1);
#line 737
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 738
  __cil_tmp12 = cio_read(cio, 1);
#line 738
  tccp->cblksty = (int )__cil_tmp12;
#line 739
  __cil_tmp13 = cio_read(cio, 1);
#line 739
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 740
  if (tccp->csty & 1) {
#line 741
    i = 0;
    {
#line 741
    while (1) {
      while_continue: /* CIL Label */ ;
#line 741
      if (! (i < tccp->numresolutions)) {
#line 741
        goto while_break;
      }
      {
#line 742
      __cil_tmp15 = cio_read(cio, 1);
#line 742
      tmp___0 = (int )__cil_tmp15;
#line 743
      tccp->prcw[i] = tmp___0 & 15;
#line 744
      tccp->prch[i] = tmp___0 >> 4;
      }
#line 741
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 749
  if (j2k->cstr_info) {
#line 749
    if (compno == 0) {
#line 750
      i = 0;
      {
#line 750
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 750
        if (! (i < tccp->numresolutions)) {
#line 750
          goto while_break___0;
        }
#line 751
        if (tccp->csty & 1) {
#line 752
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 753
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 756
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 757
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 750
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 764 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 765
  cp = (opj_cp_t *)((void *)0);
#line 766
  tcp = (opj_tcp_t *)((void *)0);
#line 769
  cio = j2k->cio;
#line 771
  cio_write(cio, (unsigned long long )65362, 2);
#line 773
  lenp = cio_tell(cio);
#line 774
  cio_skip(cio, 2);
#line 776
  cp = j2k->cp;
#line 777
  tcp = cp->tcps + j2k->curtileno;
#line 779
  cio_write(cio, (unsigned long long )tcp->csty, 1);
#line 780
  cio_write(cio, (unsigned long long )tcp->prg, 1);
#line 781
  cio_write(cio, (unsigned long long )tcp->numlayers, 2);
#line 782
  cio_write(cio, (unsigned long long )tcp->mct, 1);
#line 784
  j2k_write_cox(j2k, 0);
#line 785
  __cil_tmp8 = cio_tell(cio);
#line 785
  len = __cil_tmp8 - lenp;
#line 786
  cio_seek(cio, lenp);
#line 787
  cio_write(cio, (unsigned long long )len, 2);
#line 788
  cio_seek(cio, lenp + len);
  }
#line 790
  if (j2k->cstr_info) {
    {
#line 791
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65362, lenp, len);
    }
  }
  return;
}
}
#line 795 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 798
  cio = j2k->cio;
#line 799
  cp = j2k->cp;
#line 800
  if (j2k->state == 16) {
#line 800
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 800
    tmp = j2k->default_tcp;
  }
  {
#line 800
  tcp = tmp;
#line 801
  image = j2k->image;
#line 803
  __cil_tmp10 = cio_read(cio, 2);
#line 803
  len = (int )__cil_tmp10;
#line 805
  __cil_tmp11 = cio_read(cio, 1);
#line 805
  tcp->csty = (int )__cil_tmp11;
#line 806
  __cil_tmp12 = cio_read(cio, 1);
#line 806
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 807
  __cil_tmp13 = cio_read(cio, 2);
#line 807
  tcp->numlayers = (int )__cil_tmp13;
#line 808
  __cil_tmp14 = cio_read(cio, 1);
#line 808
  tcp->mct = (int )__cil_tmp14;
#line 810
  pos = cio_tell(cio);
#line 811
  i = 0;
  }
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! (i < image->numcomps)) {
#line 811
      goto while_break;
    }
    {
#line 812
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 813
    cio_seek(cio, pos);
#line 814
    j2k_read_cox(j2k, i);
    }
#line 811
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  if (j2k->cstr_info) {
    {
#line 819
    cstr_info = j2k->cstr_info;
#line 820
    cstr_info->prog = tcp->prg;
#line 821
    cstr_info->numlayers = tcp->numlayers;
#line 822
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 822
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 823
    i = 0;
    }
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 823
      if (! (i < image->numcomps)) {
#line 823
        goto while_break___0;
      }
#line 824
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 823
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 829 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 832
  cp = j2k->cp;
#line 833
  tcp = cp->tcps + j2k->curtileno;
#line 834
  image = j2k->image;
#line 835
  cio = j2k->cio;
#line 837
  cio_write(cio, (unsigned long long )65363, 2);
#line 838
  lenp = cio_tell(cio);
#line 839
  cio_skip(cio, 2);
  }
#line 840
  if (image->numcomps <= 256) {
#line 840
    tmp = 1;
  } else {
#line 840
    tmp = 2;
  }
  {
#line 840
  cio_write(cio, (unsigned long long )compno, tmp);
#line 841
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->csty, 1);
#line 842
  j2k_write_cox(j2k, compno);
#line 843
  __cil_tmp11 = cio_tell(cio);
#line 843
  len = __cil_tmp11 - lenp;
#line 844
  cio_seek(cio, lenp);
#line 845
  cio_write(cio, (unsigned long long )len, 2);
#line 846
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 849 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 852
  cp = j2k->cp;
#line 853
  if (j2k->state == 16) {
#line 853
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 853
    tmp = j2k->default_tcp;
  }
  {
#line 853
  tcp = tmp;
#line 854
  image = j2k->image;
#line 855
  cio = j2k->cio;
#line 857
  __cil_tmp9 = cio_read(cio, 2);
#line 857
  len = (int )__cil_tmp9;
  }
#line 859
  if (image->numcomps <= 256) {
#line 859
    tmp___0 = 1;
  } else {
#line 859
    tmp___0 = 2;
  }
  {
#line 859
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 859
  compno = (int )__cil_tmp11;
  }
#line 860
  if (compno >= image->numcomps) {
    {
#line 861
    opj_event_msg(j2k->cinfo, 1, "bad component number in COC (%d out of a maximum of %d)\n\230\001",
                  compno, image->numcomps);
    }
#line 864
    return;
  }
  {
#line 866
  __cil_tmp12 = cio_read(cio, 1);
#line 866
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 867
  j2k_read_cox(j2k, compno);
  }
  return;
}
}
#line 870 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 874
  cp = j2k->cp;
#line 875
  tcp = cp->tcps + j2k->curtileno;
#line 876
  tccp = tcp->tccps + compno;
#line 877
  cio = j2k->cio;
#line 879
  cio_write(cio, (unsigned long long )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 880
  if (tccp->qntsty == 1) {
#line 880
    tmp = 1;
  } else {
#line 880
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 880
  numbands = tmp;
#line 882
  bandno = 0;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (bandno < numbands)) {
#line 882
      goto while_break;
    }
#line 883
    expn = tccp->stepsizes[bandno].expn;
#line 884
    mant = tccp->stepsizes[bandno].mant;
#line 886
    if (tccp->qntsty == 0) {
      {
#line 887
      cio_write(cio, (unsigned long long )(expn << 3), 1);
      }
    } else {
      {
#line 889
      cio_write(cio, (unsigned long long )((expn << 11) + mant), 2);
      }
    }
#line 882
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 894 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___11 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___12 ;
  int tmp___13 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___14 ;
  int __cil_tmp21 ;

  {
#line 898
  cp = j2k->cp;
#line 899
  if (j2k->state == 16) {
#line 899
    tmp___11 = cp->tcps + j2k->curtileno;
  } else {
#line 899
    tmp___11 = j2k->default_tcp;
  }
  {
#line 899
  tcp = tmp___11;
#line 900
  tccp = tcp->tccps + compno;
#line 901
  cio = j2k->cio;
#line 903
  __cil_tmp12 = cio_read(cio, 1);
#line 903
  tmp = (int )__cil_tmp12;
#line 904
  tccp->qntsty = tmp & 31;
#line 905
  tccp->numgbits = tmp >> 5;
  }
#line 906
  if (tccp->qntsty == 1) {
#line 906
    tmp___13 = 1;
  } else {
#line 906
    if (tccp->qntsty == 0) {
#line 906
      tmp___12 = len - 1;
    } else {
#line 906
      tmp___12 = (len - 1) / 2;
    }
#line 906
    tmp___13 = tmp___12;
  }
#line 906
  numbands = tmp___13;
#line 932
  if (numbands < 0) {
    {
    {
#line 933
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
#line 937
    numbands = 1;
    }
  } else
#line 932
  if (numbands >= 97) {
    {
    {
#line 933
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
#line 937
    numbands = 1;
    }
  }
#line 942
  bandno = 0;
  {
#line 942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 942
    if (! (bandno < numbands)) {
#line 942
      goto while_break;
    }
#line 944
    if (tccp->qntsty == 0) {
      {
#line 945
      __cil_tmp17 = cio_read(cio, 1);
#line 945
      expn = (int )(__cil_tmp17 >> 3);
#line 946
      mant = 0;
      }
    } else {
      {
#line 948
      __cil_tmp18 = cio_read(cio, 2);
#line 948
      tmp = (int )__cil_tmp18;
#line 949
      expn = tmp >> 11;
#line 950
      mant = tmp & 2047;
      }
    }
#line 952
    if (bandno < 97) {
#line 953
      tccp->stepsizes[bandno].expn = expn;
#line 954
      tccp->stepsizes[bandno].mant = mant;
    }
#line 942
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  if (tccp->qntsty == 1) {
#line 960
    bandno = 1;
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 960
      if (! (bandno < 97)) {
#line 960
        goto while_break___0;
      }
#line 961
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 961
        tmp___14 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 961
        tmp___14 = 0;
      }
#line 961
      tccp->stepsizes[bandno].expn = tmp___14;
#line 964
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 960
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 970 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 973
  cio = j2k->cio;
#line 975
  cio_write(cio, (unsigned long long )65372, 2);
#line 976
  lenp = cio_tell(cio);
#line 977
  cio_skip(cio, 2);
#line 978
  j2k_write_qcx(j2k, 0);
#line 979
  __cil_tmp6 = cio_tell(cio);
#line 979
  len = __cil_tmp6 - lenp;
#line 980
  cio_seek(cio, lenp);
#line 981
  cio_write(cio, (unsigned long long )len, 2);
#line 982
  cio_seek(cio, lenp + len);
  }
#line 984
  if (j2k->cstr_info) {
    {
#line 985
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65372, lenp, len);
    }
  }
  return;
}
}
#line 988 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 991
  cio = j2k->cio;
#line 992
  image = j2k->image;
#line 994
  __cil_tmp7 = cio_read(cio, 2);
#line 994
  len = (int )__cil_tmp7;
#line 995
  pos = cio_tell(cio);
#line 996
  i = 0;
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (! (i < image->numcomps)) {
#line 996
      goto while_break;
    }
    {
#line 997
    cio_seek(cio, pos);
#line 998
    j2k_read_qcx(j2k, i, len - 2);
    }
#line 996
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1002 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 1005
  cio = j2k->cio;
#line 1007
  cio_write(cio, (unsigned long long )65373, 2);
#line 1008
  lenp = cio_tell(cio);
#line 1009
  cio_skip(cio, 2);
  }
#line 1010
  if ((j2k->image)->numcomps <= 256) {
#line 1010
    tmp = 1;
  } else {
#line 1010
    tmp = 2;
  }
  {
#line 1010
  cio_write(cio, (unsigned long long )compno, tmp);
#line 1011
  j2k_write_qcx(j2k, compno);
#line 1012
  __cil_tmp8 = cio_tell(cio);
#line 1012
  len = __cil_tmp8 - lenp;
#line 1013
  cio_seek(cio, lenp);
#line 1014
  cio_write(cio, (unsigned long long )len, 2);
#line 1015
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1018 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 1020
  numcomp = (j2k->image)->numcomps;
#line 1021
  cio = j2k->cio;
#line 1023
  __cil_tmp6 = cio_read(cio, 2);
#line 1023
  len = (int )__cil_tmp6;
  }
#line 1024
  if (numcomp <= 256) {
#line 1024
    tmp = 1;
  } else {
#line 1024
    tmp = 2;
  }
  {
#line 1024
  __cil_tmp8 = cio_read(cio, tmp);
#line 1024
  compno = (int )__cil_tmp8;
  }
#line 1052
  if (compno < 0) {
    {
    {
#line 1053
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1056
    return;
  } else
#line 1052
  if (compno >= numcomp) {
    {
    {
#line 1053
    opj_event_msg(j2k->cinfo, 1, "bad component number in QCC (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
    }
#line 1056
    return;
  }
#line 1059
  if (numcomp <= 256) {
#line 1059
    tmp___0 = 1;
  } else {
#line 1059
    tmp___0 = 2;
  }
  {
#line 1059
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
  return;
}
}
#line 1062 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1065
  numcomps = (j2k->image)->numcomps;
#line 1067
  cp = j2k->cp;
#line 1068
  tcp = cp->tcps + j2k->curtileno;
#line 1069
  tccp = tcp->tccps + 0;
#line 1070
  cio = j2k->cio;
#line 1072
  numpchgs = 1 + tcp->numpocs;
#line 1073
  cio_write(cio, (unsigned long long )65375, 2);
  }
#line 1074
  if (numcomps <= 256) {
#line 1074
    tmp = 1;
  } else {
#line 1074
    tmp = 2;
  }
  {
#line 1074
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1075
  cio_write(cio, (unsigned long long )len, 2);
#line 1076
  i = 0;
  }
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if (! (i < numpchgs)) {
#line 1076
      goto while_break;
    }
    {
#line 1077
    poc = & tcp->pocs[i];
#line 1078
    cio_write(cio, (unsigned long long )poc->resno0, 1);
    }
#line 1079
    if (numcomps <= 256) {
#line 1079
      tmp___0 = 1;
    } else {
#line 1079
      tmp___0 = 2;
    }
    {
#line 1079
    cio_write(cio, (unsigned long long )poc->compno0, tmp___0);
#line 1080
    cio_write(cio, (unsigned long long )poc->layno1, 2);
#line 1081
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1082
    cio_write(cio, (unsigned long long )poc->resno1, 1);
#line 1083
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1084
    if (numcomps <= 256) {
#line 1084
      tmp___1 = 1;
    } else {
#line 1084
      tmp___1 = 2;
    }
    {
#line 1084
    cio_write(cio, (unsigned long long )poc->compno1, tmp___1);
#line 1085
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1086
    cio_write(cio, (unsigned long long )poc->prg, 1);
    }
#line 1076
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1090 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1093
  numcomps = (j2k->image)->numcomps;
#line 1095
  cp = j2k->cp;
#line 1096
  if (j2k->state == 16) {
#line 1096
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1096
    tmp = j2k->default_tcp;
  }
#line 1096
  tcp = tmp;
#line 1097
  cio = j2k->cio;
#line 1099
  if (tcp->POC) {
#line 1099
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1099
    tmp___0 = 0;
  }
  {
#line 1099
  old_poc = tmp___0;
#line 1100
  tcp->POC = 1;
#line 1101
  __cil_tmp12 = cio_read(cio, 2);
#line 1101
  len = (int )__cil_tmp12;
  }
#line 1102
  if (numcomps <= 256) {
#line 1102
    tmp___1 = 1;
  } else {
#line 1102
    tmp___1 = 2;
  }
#line 1102
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1104
  if (numpchgs >= 32) {
    {
#line 1107
    opj_event_msg(j2k->cinfo, 1, "bad number of POCS (%d out of a maximum of %d)\n",
                  numpchgs, 32);
#line 1110
    numpchgs = 0;
    }
  }
#line 1113
  i = old_poc;
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if (! (i < numpchgs + old_poc)) {
#line 1113
      goto while_break;
    }
    {
#line 1115
    poc = & tcp->pocs[i];
#line 1116
    __cil_tmp15 = cio_read(cio, 1);
#line 1116
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1117
    if (numcomps <= 256) {
#line 1117
      tmp___2 = 1;
    } else {
#line 1117
      tmp___2 = 2;
    }
    {
#line 1117
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1117
    poc->compno0 = (int )__cil_tmp17;
#line 1118
    __cil_tmp18 = cio_read(cio, 2);
#line 1118
    poc->layno1 = (int )__cil_tmp18;
#line 1119
    __cil_tmp19 = cio_read(cio, 1);
#line 1119
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1120
    if (numcomps <= 256) {
#line 1120
      tmp___3 = 1;
    } else {
#line 1120
      tmp___3 = 2;
    }
    {
#line 1120
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1120
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1120
    poc->compno1 = __cil_tmp22;
#line 1122
    __cil_tmp23 = cio_read(cio, 1);
#line 1122
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
    }
#line 1113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  tcp->numpocs = (numpchgs + old_poc) - 1;
  return;
}
}
#line 1128 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1131
  cio = j2k->cio;
#line 1132
  numcomps = (j2k->image)->numcomps;
#line 1134
  __cil_tmp8 = cio_read(cio, 2);
#line 1134
  len = (int )__cil_tmp8;
#line 1136
  i = 0;
  }
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i < numcomps)) {
#line 1136
      goto while_break;
    }
    {
#line 1137
    __cil_tmp9 = cio_read(cio, 2);
#line 1137
    Xcrg_i = (int )__cil_tmp9;
#line 1139
    __cil_tmp10 = cio_read(cio, 2);
#line 1139
    Ycrg_i = (int )__cil_tmp10;
    }
#line 1136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1144 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1148
  cio = j2k->cio;
#line 1150
  __cil_tmp12 = cio_read(cio, 2);
#line 1150
  len = (int )__cil_tmp12;
#line 1151
  __cil_tmp13 = cio_read(cio, 1);
#line 1151
  Ztlm = (int )__cil_tmp13;
#line 1153
  __cil_tmp14 = cio_read(cio, 1);
#line 1153
  Stlm = (int )__cil_tmp14;
#line 1154
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1155
  SP = (Stlm >> 6) & 1;
#line 1156
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1157
  i = 0;
  }
  {
#line 1157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1157
    if (! (i < tile_tlm)) {
#line 1157
      goto while_break;
    }
    {
#line 1158
    __cil_tmp15 = cio_read(cio, ST);
#line 1158
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1160
    if (SP) {
#line 1160
      tmp = 4;
    } else {
#line 1160
      tmp = 2;
    }
    {
#line 1160
    __cil_tmp17 = cio_read(cio, tmp);
#line 1160
    Ptlm_i = (long )__cil_tmp17;
    }
#line 1157
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1165 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1166
  packet_len = 0;
#line 1168
  cio = j2k->cio;
#line 1170
  __cil_tmp9 = cio_read(cio, 2);
#line 1170
  len = (int )__cil_tmp9;
#line 1171
  __cil_tmp10 = cio_read(cio, 1);
#line 1171
  Zplm = (int )__cil_tmp10;
#line 1173
  len -= 3;
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1174
    if (! (len > 0)) {
#line 1174
      goto while_break;
    }
    {
#line 1175
    __cil_tmp11 = cio_read(cio, 4);
#line 1175
    Nplm = (int )__cil_tmp11;
#line 1176
    len -= 4;
#line 1177
    i = Nplm;
    }
    {
#line 1177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1177
      if (! (i > 0)) {
#line 1177
        goto while_break___0;
      }
      {
#line 1178
      __cil_tmp12 = cio_read(cio, 1);
#line 1178
      add = (int )__cil_tmp12;
#line 1179
      __cil_tmp13 = len;
#line 1179
      len --;
#line 1180
      packet_len = (packet_len << 7) + add;
      }
#line 1181
      if ((add & 128) == 0) {
#line 1183
        packet_len = 0;
      }
#line 1185
      if (len <= 0) {
#line 1186
        goto while_break___0;
      }
#line 1177
      __cil_tmp14 = i;
#line 1177
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1191 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1192
  packet_len = 0;
#line 1194
  cio = j2k->cio;
#line 1196
  __cil_tmp8 = cio_read(cio, 2);
#line 1196
  len = (int )__cil_tmp8;
#line 1197
  __cil_tmp9 = cio_read(cio, 1);
#line 1197
  Zplt = (int )__cil_tmp9;
#line 1199
  i = len - 3;
  }
  {
#line 1199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1199
    if (! (i > 0)) {
#line 1199
      goto while_break;
    }
    {
#line 1200
    __cil_tmp10 = cio_read(cio, 1);
#line 1200
    add = (int )__cil_tmp10;
#line 1201
    packet_len = (packet_len << 7) + add;
    }
#line 1202
    if ((add & 128) == 0) {
#line 1204
      packet_len = 0;
    }
#line 1199
    __cil_tmp11 = i;
#line 1199
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1209 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1213
  cp = j2k->cp;
#line 1214
  cio = j2k->cio;
#line 1216
  __cil_tmp9 = cio_read(cio, 2);
#line 1216
  len = (int )__cil_tmp9;
#line 1217
  cp->ppm = 1;
#line 1219
  __cil_tmp10 = cio_read(cio, 1);
#line 1219
  Z_ppm = (int )__cil_tmp10;
#line 1220
  len -= 3;
  }
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1221
    if (! (len > 0)) {
#line 1221
      goto while_break;
    }
#line 1222
    if (cp->ppm_previous == 0) {
      {
#line 1223
      __cil_tmp11 = cio_read(cio, 4);
#line 1223
      N_ppm = (int )__cil_tmp11;
#line 1224
      len -= 4;
      }
    } else {
#line 1226
      N_ppm = cp->ppm_previous;
    }
#line 1228
    j = cp->ppm_store;
#line 1229
    if (Z_ppm == 0) {
      {
#line 1230
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1230
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1231
      cp->ppm_data_first = cp->ppm_data;
#line 1232
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1234
      __cil_tmp13 = realloc(cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1234
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1252
      cp->ppm_data_first = cp->ppm_data;
#line 1253
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1255
    i = N_ppm;
    {
#line 1255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1255
      if (! (i > 0)) {
#line 1255
        goto while_break___0;
      }
      {
#line 1256
      __cil_tmp14 = cio_read(cio, 1);
#line 1256
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1257
      j ++;
#line 1258
      __cil_tmp16 = len;
#line 1258
      len --;
      }
#line 1259
      if (len == 0) {
#line 1260
        goto while_break___0;
      }
#line 1255
      __cil_tmp17 = i;
#line 1255
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1262
    cp->ppm_previous = i - 1;
#line 1263
    cp->ppm_store = j;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1267 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 1268
  j = 0;
#line 1270
  cp = j2k->cp;
#line 1271
  tcp = cp->tcps + j2k->curtileno;
#line 1272
  cio = j2k->cio;
#line 1274
  __cil_tmp9 = cio_read(cio, 2);
#line 1274
  len = (int )__cil_tmp9;
#line 1275
  __cil_tmp10 = cio_read(cio, 1);
#line 1275
  Z_ppt = (int )__cil_tmp10;
#line 1276
  tcp->ppt = 1;
  }
#line 1277
  if (Z_ppt == 0) {
    {
#line 1278
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1278
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1279
    tcp->ppt_data_first = tcp->ppt_data;
#line 1280
    tcp->ppt_store = 0;
#line 1281
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1283
    __cil_tmp12 = realloc(tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1283
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1284
    tcp->ppt_data_first = tcp->ppt_data;
#line 1285
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1287
  j = tcp->ppt_store;
#line 1288
  i = len - 3;
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1288
    if (! (i > 0)) {
#line 1288
      goto while_break;
    }
    {
#line 1289
    __cil_tmp13 = cio_read(cio, 1);
#line 1289
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1290
    j ++;
    }
#line 1288
    __cil_tmp15 = i;
#line 1288
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1292
  tcp->ppt_store = j;
  return;
}
}
#line 1295 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;
  int __cil_tmp4 ;

  {
  {
#line 1297
  cio = j2k->cio;
#line 1298
  j2k->tlm_start = cio_tell(cio);
#line 1299
  cio_write(cio, (unsigned long long )65365, 2);
#line 1300
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1301
  cio_write(cio, (unsigned long long )lenp, 2);
#line 1302
  cio_write(cio, (unsigned long long )0, 1);
#line 1303
  cio_write(cio, (unsigned long long )80, 1);
#line 1304
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
  return;
}
}
#line 1307 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1310
  cio = j2k->cio;
#line 1312
  j2k->sot_start = cio_tell(cio);
#line 1313
  cio_write(cio, (unsigned long long )65424, 2);
#line 1314
  lenp = cio_tell(cio);
#line 1315
  cio_skip(cio, 2);
#line 1316
  cio_write(cio, (unsigned long long )j2k->curtileno, 2);
#line 1317
  cio_skip(cio, 4);
#line 1318
  cio_write(cio, (unsigned long long )j2k->cur_tp_num, 1);
#line 1319
  cio_write(cio, (unsigned long long )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1320
  __cil_tmp7 = cio_tell(cio);
#line 1320
  len = __cil_tmp7 - lenp;
#line 1321
  cio_seek(cio, lenp);
#line 1322
  cio_write(cio, (unsigned long long )len, 2);
#line 1323
  cio_seek(cio, lenp + len);
  }
#line 1332
  if (j2k->cstr_info) {
#line 1332
    if (j2k->cur_tp_num == 0) {
      {
#line 1333
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65424, lenp,
                       len);
      }
    }
  }
  return;
}
}
#line 1337 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  opj_tccp_t *tmp___0 ;
  int __cil_tmp31 ;

  {
  {
#line 1339
  tcp = (opj_tcp_t *)((void *)0);
#line 1340
  status = (char )0;
#line 1342
  cp = j2k->cp;
#line 1343
  cio = j2k->cio;
#line 1345
  __cil_tmp12 = cio_read(cio, 2);
#line 1345
  len = (int )__cil_tmp12;
#line 1347
  __cil_tmp13 = cio_read(cio, 2);
#line 1347
  tileno = (int )__cil_tmp13;
  }
#line 1377
  if (tileno < 0) {
    {
    {
#line 1378
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1381
    return;
  } else
#line 1377
  if (tileno >= cp->tw * cp->th) {
    {
    {
#line 1378
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1381
    return;
  }
#line 1385
  if (cp->tileno_size == 0) {
#line 1386
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1387
    (cp->tileno_size) ++;
  } else {
#line 1389
    i = 0;
    {
#line 1390
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1390
      if (! (i < cp->tileno_size && (int )status == 0)) {
#line 1390
        goto while_break;
      }
#line 1391
      if (*(cp->tileno + i) == tileno) {
#line 1391
        tmp = 1;
      } else {
#line 1391
        tmp = 0;
      }
#line 1391
      status = (char )tmp;
#line 1392
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1394
    if ((int )status == 0) {
#line 1395
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1396
      (cp->tileno_size) ++;
    }
  }
  {
#line 1400
  __cil_tmp18 = cio_read(cio, 4);
#line 1400
  totlen = (int )__cil_tmp18;
#line 1426
  __cil_tmp19 = cio_numbytesleft(cio);
  }
#line 1426
  if (totlen < 0) {
    {
    {
#line 1427
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1427
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1430
    return;
  } else
#line 1426
  if (totlen > __cil_tmp19 + 8) {
    {
    {
#line 1427
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1427
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1430
    return;
  }
#line 1434
  if (! totlen) {
    {
#line 1435
    __cil_tmp21 = cio_numbytesleft(cio);
#line 1435
    totlen = __cil_tmp21 + 8;
    }
  }
  {
#line 1437
  __cil_tmp22 = cio_read(cio, 1);
#line 1437
  partno = (int )__cil_tmp22;
#line 1438
  __cil_tmp23 = cio_read(cio, 1);
#line 1438
  numparts = (int )__cil_tmp23;
  }
#line 1440
  if (partno >= numparts) {
    {
#line 1441
    opj_event_msg(j2k->cinfo, 2, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n",
                  tileno, partno, numparts);
#line 1442
    numparts = partno + 1;
    }
  }
  {
#line 1445
  j2k->curtileno = tileno;
#line 1446
  j2k->cur_tp_num = partno;
#line 1447
  __cil_tmp24 = cio_getbp(cio);
#line 1447
  j2k->eot = (__cil_tmp24 - 12) + totlen;
#line 1448
  j2k->state = 16;
#line 1449
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1452
  if (j2k->cstr_info) {
#line 1453
    if (tcp->first) {
#line 1454
      if (tileno == 0) {
        {
#line 1455
        __cil_tmp25 = cio_tell(cio);
#line 1455
        (j2k->cstr_info)->main_head_end = __cil_tmp25 - 13;
        }
      }
      {
#line 1456
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1457
      __cil_tmp26 = cio_tell(cio);
#line 1457
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp26 - 12;
#line 1458
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
      }
    } else {
#line 1460
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
#line 1462
    ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
#line 1463
    if (numparts) {
      {
#line 1464
      __cil_tmp27 = realloc(((j2k->cstr_info)->tile + tileno)->tp, (unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1464
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp27;
      }
    } else {
      {
#line 1466
      __cil_tmp28 = realloc(((j2k->cstr_info)->tile + tileno)->tp, 10UL * sizeof(opj_tp_info_t ));
#line 1466
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp28;
      }
    }
    {
#line 1467
    __cil_tmp29 = cio_tell(cio);
#line 1467
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp29 - 12;
#line 1468
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1472
  if (tcp->first == 1) {
    {
#line 1474
    tmp___0 = tcp->tccps;
#line 1475
    memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1476
    tcp->ppt = 0;
#line 1477
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1478
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1479
    tcp->tccps = tmp___0;
#line 1481
    i = 0;
    }
    {
#line 1481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1481
      if (! (i < (j2k->image)->numcomps)) {
#line 1481
        goto while_break___0;
      }
#line 1482
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1481
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1484
    (cp->tcps + j2k->curtileno)->first = 0;
  }
  return;
}
}
#line 1488 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1491
  tcp = (opj_tcp_t *)((void *)0);
#line 1492
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1494
  tcd = (opj_tcd_t *)tile_coder;
#line 1495
  cp = j2k->cp;
#line 1496
  cio = j2k->cio;
#line 1498
  tcd->tp_num = j2k->tp_num;
#line 1499
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1501
  cio_write(cio, (unsigned long long )65427, 2);
  }
#line 1503
  if (j2k->cstr_info) {
#line 1503
    if (j2k->cur_tp_num == 0) {
      {
#line 1504
      __cil_tmp11 = cio_tell(cio);
#line 1504
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65427, __cil_tmp11,
                       0);
      }
    }
  }
#line 1507
  if (j2k->curtileno == 0) {
    {
#line 1508
    __cil_tmp12 = cio_tell(cio);
#line 1508
    j2k->sod_start = __cil_tmp12 + j2k->pos_correction;
    }
  }
#line 1512
  cstr_info = j2k->cstr_info;
#line 1513
  if (cstr_info) {
#line 1514
    if (! j2k->cur_tp_num) {
      {
#line 1515
      __cil_tmp13 = cio_tell(cio);
#line 1515
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp13 + j2k->pos_correction) - 1;
#line 1516
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1519
      __cil_tmp14 = cio_tell(cio);
      }
#line 1519
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp14) {
        {
#line 1520
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1531
  tcp = cp->tcps + j2k->curtileno;
#line 1532
  layno = 0;
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (! (layno < tcp->numlayers)) {
#line 1532
      goto while_break;
    }
#line 1533
    if (tcp->rates[layno] > (float )(j2k->sod_start / (cp->th * cp->tw))) {
#line 1534
      tcp->rates[layno] -= (float )(j2k->sod_start / (cp->th * cp->tw));
    } else
#line 1535
    if (tcp->rates[layno]) {
#line 1536
      tcp->rates[layno] = (float )1;
    }
#line 1532
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1539
  if (j2k->cur_tp_num == 0) {
#line 1540
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1541
    if (cstr_info) {
#line 1542
      cstr_info->packno = 0;
    }
  }
  {
#line 1545
  __cil_tmp17 = cio_getbp(cio);
  }
  {
#line 1545
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1545
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1545
  l = __cil_tmp19;
#line 1548
  __cil_tmp20 = cio_tell(cio);
#line 1548
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1549
  cio_seek(cio, j2k->sot_start + 6);
#line 1550
  cio_write(cio, (unsigned long long )totlen, 4);
#line 1551
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1553
  if (cp->cinema) {
    {
#line 1554
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1555
    cio_write(cio, (unsigned long long )j2k->curtileno, 1);
#line 1556
    cio_write(cio, (unsigned long long )totlen, 4);
    }
  }
  {
#line 1558
  cio_seek(cio, j2k->sot_start + totlen);
  }
  return;
}
}
#line 1561 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1562
  truncate = 0;
#line 1563
  data = (unsigned char *)((void *)0);
#line 1563
  data_ptr = (unsigned char *)((void *)0);
#line 1565
  cio = j2k->cio;
#line 1566
  curtileno = j2k->curtileno;
#line 1569
  if (j2k->cstr_info) {
    {
#line 1570
    __cil_tmp9 = cio_tell(cio);
#line 1570
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1572
    if (j2k->cur_tp_num == 0) {
      {
#line 1573
      __cil_tmp10 = cio_tell(cio);
#line 1573
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1574
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1577
  __cil_tmp11 = cio_getbp(cio);
  }
  {
#line 1577
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1577
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1577
  len = __cil_tmp13;
#line 1579
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1579
  if (len == __cil_tmp14 + 1) {
#line 1580
    truncate = 1;
  }
  {
#line 1583
  data = *(j2k->tile_data + curtileno);
#line 1584
  data_ptr = data;
#line 1585
  __cil_tmp15 = realloc(data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1585
  data = (unsigned char *)__cil_tmp15;
  }
#line 1586
  if (data == (void *)0) {
    {
#line 1587
    opj_event_msg(j2k->cinfo, 1, "Could not reallocated\n");
#line 1588
    free(data_ptr);
    }
#line 1589
    return;
  }
#line 1592
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1593
  i = 0;
  {
#line 1593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1593
    if (! (i < len)) {
#line 1593
      goto while_break;
    }
    {
#line 1594
    __cil_tmp16 = cio_read(cio, 1);
#line 1594
    *(data_ptr + i) = (unsigned char )__cil_tmp16;
    }
#line 1593
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1597
  *(j2k->tile_len + curtileno) += len;
#line 1598
  *(j2k->tile_data + curtileno) = data;
#line 1600
  if (! truncate) {
#line 1601
    j2k->state = 8;
  } else {
#line 1603
    j2k->state = 64;
  }
#line 1605
  (j2k->cur_tp_num) ++;
  return;
}
}
#line 1608 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1609
  cp = j2k->cp;
#line 1610
  tcp = cp->tcps + tileno;
#line 1611
  cio = j2k->cio;
#line 1612
  numcomps = (j2k->image)->numcomps;
#line 1614
  cio_write(cio, (unsigned long long )65374, 2);
  }
#line 1615
  if (numcomps <= 256) {
#line 1615
    tmp = 5;
  } else {
#line 1615
    tmp = 6;
  }
  {
#line 1615
  cio_write(cio, (unsigned long long )tmp, 2);
  }
#line 1616
  if (numcomps <= 256) {
#line 1616
    tmp___0 = 1;
  } else {
#line 1616
    tmp___0 = 2;
  }
  {
#line 1616
  cio_write(cio, (unsigned long long )compno, tmp___0);
#line 1617
  cio_write(cio, (unsigned long long )0, 1);
#line 1618
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->roishift, 1);
  }
  return;
}
}
#line 1621 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1624
  cp = j2k->cp;
#line 1625
  if (j2k->state == 16) {
#line 1625
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1625
    tmp = j2k->default_tcp;
  }
  {
#line 1625
  tcp = tmp;
#line 1626
  cio = j2k->cio;
#line 1627
  numcomps = (j2k->image)->numcomps;
#line 1629
  __cil_tmp10 = cio_read(cio, 2);
#line 1629
  len = (int )__cil_tmp10;
  }
#line 1631
  if (numcomps <= 256) {
#line 1631
    tmp___0 = 1;
  } else {
#line 1631
    tmp___0 = 2;
  }
  {
#line 1631
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1631
  compno = (int )__cil_tmp12;
#line 1632
  __cil_tmp13 = cio_read(cio, 1);
#line 1632
  roisty = (int )__cil_tmp13;
  }
#line 1650
  if (compno >= numcomps) {
    {
#line 1651
    opj_event_msg(j2k->cinfo, 1, "bad component number in RGN (%d out of a maximum of %d)\n\230\001",
                  compno, (j2k->image)->numcomps);
    }
#line 1654
    return;
  }
  {
#line 1657
  __cil_tmp14 = cio_read(cio, 1);
#line 1657
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
  return;
}
}
#line 1660 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1661
  cio = j2k->cio;
#line 1663
  cio_write(cio, (unsigned long long )65497, 2);
  }
  return;
}
}
#line 1673 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_bool success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;
  opj_bool __cil_tmp7 ;
  int tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1675
  success = 0;
#line 1678
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1679
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1679
    tcd = __cil_tmp6;
#line 1680
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1681
    i = 0;
    }
    {
#line 1681
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1681
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1681
        goto while_break;
      }
      {
#line 1682
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
      }
#line 1683
      if (*((j2k->cp)->tileno + i) != -1) {
        {
#line 1685
        tileno = *((j2k->cp)->tileno + i);
#line 1686
        success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                  tileno, j2k->cstr_info);
#line 1688
        free(*(j2k->tile_data + tileno));
#line 1689
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1690
        tcd_free_decode_tile(tcd, i);
        }
      } else {
#line 1693
        success = 0;
      }
#line 1694
      if (success == 0) {
#line 1695
        j2k->state |= 128;
#line 1696
        goto while_break;
      }
#line 1681
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1699
    tcd_free_decode(tcd);
#line 1700
    tcd_destroy(tcd);
    }
  } else {
#line 1704
    i = 0;
    {
#line 1704
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1704
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1704
        goto while_break___0;
      }
      {
#line 1705
      tileno = *((j2k->cp)->tileno + i);
#line 1706
      free(*(j2k->tile_data + tileno));
#line 1707
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
      }
#line 1704
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1710
  if (j2k->state & 128) {
#line 1711
    j2k->state = 160;
  } else {
#line 1713
    j2k->state = 32;
  }
  return;
}
}
#line 1725 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1725
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1760 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1761
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
  return;
}
}
#line 1826 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;
  opj_dec_mstabent_t *__cil_tmp3 ;

  {
#line 1828
  e = (opj_dec_mstabent_t *)j2k_dec_mstab;
  {
#line 1828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1828
    if (! (e->id != 0)) {
#line 1828
      goto while_break;
    }
#line 1829
    if (e->id == id) {
#line 1830
      goto while_break;
    }
#line 1828
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return (e);
}
}
#line 1840 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1841
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1841
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1842
  if (! j2k) {
#line 1843
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1845
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 1845
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1846
  if (! j2k->default_tcp) {
    {
#line 1847
    free(j2k);
    }
#line 1848
    return ((opj_j2k_t *)((void *)0));
  }
#line 1851
  j2k->cinfo = cinfo;
#line 1852
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1854
  return (j2k);
}
}
#line 1857 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  int __cil_tmp4 ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;
  int __cil_tmp7 ;

  {
#line 1858
  i = 0;
#line 1860
  if (j2k->tile_len != (void *)0) {
    {
#line 1861
    free(j2k->tile_len);
    }
  }
#line 1863
  if (j2k->tile_data != (void *)0) {
#line 1864
    if (j2k->cp != (void *)0) {
#line 1865
      i = 0;
      {
#line 1865
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1865
        if (! (i < (j2k->cp)->tileno_size)) {
#line 1865
          goto while_break;
        }
#line 1866
        tileno = *((j2k->cp)->tileno + i);
#line 1867
        if (tileno != -1) {
          {
#line 1869
          free(*(j2k->tile_data + tileno));
#line 1870
          *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
          }
        }
#line 1865
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1875
    free(j2k->tile_data);
    }
  }
#line 1877
  if (j2k->default_tcp != (void *)0) {
#line 1878
    default_tcp = j2k->default_tcp;
#line 1879
    if (default_tcp->ppt_data_first != (void *)0) {
      {
#line 1880
      free(default_tcp->ppt_data_first);
      }
    }
#line 1882
    if ((j2k->default_tcp)->tccps != (void *)0) {
      {
#line 1883
      free((j2k->default_tcp)->tccps);
      }
    }
    {
#line 1885
    free(j2k->default_tcp);
    }
  }
#line 1887
  if (j2k->cp != (void *)0) {
#line 1888
    cp = j2k->cp;
#line 1889
    if (cp->tcps != (void *)0) {
#line 1890
      i = 0;
      {
#line 1890
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1890
        if (! (i < cp->tw * cp->th)) {
#line 1890
          goto while_break___0;
        }
#line 1891
        if ((cp->tcps + i)->ppt_data_first != (void *)0) {
          {
#line 1892
          free((cp->tcps + i)->ppt_data_first);
          }
        }
#line 1894
        if ((cp->tcps + i)->tccps != (void *)0) {
          {
#line 1895
          free((cp->tcps + i)->tccps);
          }
        }
#line 1890
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1898
      free(cp->tcps);
      }
    }
#line 1900
    if (cp->ppm_data_first != (void *)0) {
      {
#line 1901
      free(cp->ppm_data_first);
      }
    }
#line 1903
    if (cp->tileno != (void *)0) {
      {
#line 1904
      free(cp->tileno);
      }
    }
#line 1906
    if (cp->comment != (void *)0) {
      {
#line 1907
      free(cp->comment);
      }
    }
    {
#line 1910
    free(cp);
    }
  }
  {
#line 1912
  free(j2k);
  }
  return;
}
}
#line 1915 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1916
  if (j2k) {
#line 1916
    if (parameters) {
      {
#line 1918
      __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 1918
      cp = (opj_cp_t *)__cil_tmp4;
#line 1919
      cp->reduce = parameters->cp_reduce;
#line 1920
      cp->layer = parameters->cp_layer;
#line 1921
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1931
      j2k->cp = cp;
      }
    }
  }
  return;
}
}
#line 1935 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp6 ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_dec_mstabent_t *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1936
  image = (opj_image_t *)((void *)0);
#line 1938
  cinfo = j2k->cinfo;
#line 1940
  j2k->cio = cio;
#line 1941
  j2k->cstr_info = cstr_info;
#line 1942
  if (cstr_info) {
    {
#line 1943
    memset(cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1946
  image = opj_image_create0();
#line 1947
  j2k->image = image;
#line 1949
  j2k->state = 1;
  }
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! 1) {
#line 1951
      goto while_break;
    }
    {
#line 1953
    __cil_tmp9 = cio_read(cio, 2);
#line 1953
    id = (int )__cil_tmp9;
    }
#line 1993
    if (id >> 8 != 255) {
      {
#line 1994
      __cil_tmp10 = cio_numbytesleft(cio);
      }
#line 1994
      if (__cil_tmp10 != 0) {
        {
#line 1996
        __cil_tmp11 = cio_tell(cio);
#line 1996
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp11 - 2,
                      id);
#line 1997
        opj_image_destroy(image);
        }
#line 1998
        return ((opj_image_t *)0);
      }
      {
#line 2000
      __cil_tmp12 = cio_tell(cio);
#line 2000
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp12 - 2,
                    id);
#line 2001
      j2k->state = 64;
      }
#line 2002
      goto while_break;
    }
    {
#line 2004
    e = j2k_dec_mstab_lookup(id);
    }
#line 2006
    if (! (j2k->state & e->states)) {
      {
#line 2007
      opj_image_destroy(image);
#line 2008
      __cil_tmp14 = cio_tell(cio);
#line 2008
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp14 - 2, id);
      }
#line 2009
      return ((opj_image_t *)0);
    }
#line 2012
    if (e->id == 65424) {
#line 2012
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 2013
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 2014
        return (image);
      }
    }
#line 2017
    if (e->handler) {
      {
#line 2018
      (*(e->handler))(j2k);
      }
    }
#line 2020
    if (j2k->state & 128) {
      {
#line 2022
      opj_image_destroy(image);
      }
#line 2023
      return ((opj_image_t *)((void *)0));
    }
#line 2026
    if (j2k->state == 32) {
#line 2027
      goto while_break;
    }
#line 2029
    if (j2k->state == 64) {
#line 2030
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2033
  if (j2k->state == 64) {
    {
#line 2034
    j2k_read_eoc(j2k);
    }
#line 2036
    if (j2k->state & 128) {
      {
#line 2037
      opj_image_destroy(image);
      }
#line 2038
      return ((opj_image_t *)((void *)0));
    }
  }
#line 2042
  if (j2k->state != 32) {
    {
#line 2043
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2045
  return (image);
}
}
#line 2052 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  opj_dec_mstabent_t *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 2053
  image = (opj_image_t *)((void *)0);
#line 2056
  cinfo = j2k->cinfo;
#line 2060
  j2k->cio = cio;
#line 2063
  image = opj_image_create0();
#line 2064
  j2k->image = image;
#line 2066
  j2k->state = 1;
#line 2069
  jpt_init_msg_header(& header);
#line 2071
  jpt_read_msg_header(cinfo, cio, & header);
#line 2073
  position = cio_tell(cio);
  }
#line 2074
  if (header.Class_Id != 6U) {
    {
#line 2075
    opj_image_destroy(image);
#line 2076
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 2077
    return ((opj_image_t *)0);
  }
  {
#line 2080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2080
    if (! 1) {
#line 2080
      goto while_break;
    }
    {
#line 2081
    e = (opj_dec_mstabent_t *)((void *)0);
#line 2084
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 2084
    if (! __cil_tmp12) {
      {
#line 2085
      j2k_read_eoc(j2k);
      }
#line 2086
      return (image);
    }
    {
#line 2089
    __cil_tmp13 = cio_tell(cio);
    }
#line 2089
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 2090
      jpt_read_msg_header(cinfo, cio, & header);
#line 2091
      position = cio_tell(cio);
      }
#line 2092
      if (header.Class_Id != 4U) {
        {
#line 2093
        opj_image_destroy(image);
#line 2094
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\nV");
        }
#line 2095
        return ((opj_image_t *)0);
      }
    }
    {
#line 2099
    __cil_tmp15 = cio_read(cio, 2);
#line 2099
    id = (int )__cil_tmp15;
    }
#line 2100
    if (id >> 8 != 255) {
      {
#line 2101
      __cil_tmp16 = cio_numbytesleft(cio);
      }
#line 2101
      if (__cil_tmp16 != 0) {
        {
#line 2103
        __cil_tmp17 = cio_tell(cio);
#line 2103
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp17 - 2,
                      id);
#line 2104
        opj_image_destroy(image);
        }
#line 2105
        return ((opj_image_t *)0);
      }
      {
#line 2107
      __cil_tmp18 = cio_tell(cio);
#line 2107
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp18 - 2,
                    id);
#line 2108
      j2k->state = 64;
      }
#line 2109
      goto while_break;
    }
    {
#line 2111
    e = j2k_dec_mstab_lookup(id);
    }
#line 2112
    if (! (j2k->state & e->states)) {
      {
#line 2113
      opj_image_destroy(image);
#line 2114
      __cil_tmp20 = cio_tell(cio);
#line 2114
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\nU\006V", __cil_tmp20 - 2,
                    id);
      }
#line 2115
      return ((opj_image_t *)0);
    }
#line 2117
    if (e->handler) {
      {
#line 2118
      (*(e->handler))(j2k);
      }
    }
#line 2120
    if (j2k->state == 32) {
#line 2121
      goto while_break;
    }
#line 2123
    if (j2k->state == 64) {
#line 2124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2127
  if (j2k->state == 64) {
    {
#line 2128
    j2k_read_eoc(j2k);
    }
  }
#line 2131
  if (j2k->state != 32) {
    {
#line 2132
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2135
  return (image);
}
}
#line 2142 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 2143
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 2143
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 2144
  if (j2k) {
#line 2145
    j2k->cinfo = cinfo;
  }
#line 2147
  return (j2k);
}
}
#line 2150 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;
  int __cil_tmp4 ;

  {
#line 2153
  if (! j2k) {
#line 2153
    return;
  }
#line 2154
  if (j2k->cp != (void *)0) {
#line 2155
    cp = j2k->cp;
#line 2157
    if (cp->comment) {
      {
#line 2158
      free(cp->comment);
      }
    }
#line 2160
    if (cp->matrice) {
      {
#line 2161
      free(cp->matrice);
      }
    }
#line 2163
    tileno = 0;
    {
#line 2163
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2163
      if (! (tileno < cp->tw * cp->th)) {
#line 2163
        goto while_break;
      }
      {
#line 2164
      free((cp->tcps + tileno)->tccps);
      }
#line 2163
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2166
    free(cp->tcps);
#line 2167
    free(cp);
    }
  }
  {
#line 2170
  free(j2k);
  }
  return;
}
}
#line 2173 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  opj_poc_t *tcp_poc ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int p ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 2175
  cp = (opj_cp_t *)((void *)0);
#line 2177
  if (! j2k) {
#line 2178
    return;
  } else
#line 2177
  if (! parameters) {
#line 2178
    return;
  } else
#line 2177
  if (! image) {
#line 2178
    return;
  }
  {
#line 2182
  __cil_tmp9 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 2182
  cp = (opj_cp_t *)__cil_tmp9;
#line 2185
  j2k->cp = cp;
#line 2188
  cp->tw = 1;
#line 2189
  cp->th = 1;
#line 2194
  cp->cinema = parameters->cp_cinema;
#line 2195
  cp->max_comp_size = parameters->max_comp_size;
#line 2196
  cp->rsiz = parameters->cp_rsiz;
#line 2197
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2198
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2199
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2202
  if (parameters->cp_matrice) {
    {
#line 2203
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2204
    __cil_tmp11 = malloc(array_size);
#line 2204
    cp->matrice = (int *)__cil_tmp11;
#line 2205
    memcpy(cp->matrice, parameters->cp_matrice, array_size);
    }
  }
#line 2209
  cp->tdx = parameters->cp_tdx;
#line 2210
  cp->tdy = parameters->cp_tdy;
#line 2213
  cp->tx0 = parameters->cp_tx0;
#line 2214
  cp->ty0 = parameters->cp_ty0;
#line 2217
  if (parameters->cp_comment) {
    {
#line 2218
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2218
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2218
    cp->comment = (char *)__cil_tmp13;
    }
#line 2219
    if (cp->comment) {
      {
#line 2220
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2228
  if (parameters->tile_size_on) {
    {
#line 2229
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2230
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2232
    cp->tdx = image->x1 - cp->tx0;
#line 2233
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2236
  if (parameters->tp_on) {
#line 2237
    cp->tp_flag = parameters->tp_flag;
#line 2238
    cp->tp_on = (char )1;
  }
#line 2241
  cp->img_size = 0;
#line 2242
  i = 0;
  {
#line 2242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2242
    if (! (i < image->numcomps)) {
#line 2242
      goto while_break;
    }
#line 2243
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2306
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2306
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2308
  tileno = 0;
  }
  {
#line 2308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2308
    if (! (tileno < cp->tw * cp->th)) {
#line 2308
      goto while_break___0;
    }
#line 2309
    tcp = cp->tcps + tileno;
#line 2310
    tcp->numlayers = parameters->tcp_numlayers;
#line 2311
    j = 0;
    {
#line 2311
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2311
      if (! (j < tcp->numlayers)) {
#line 2311
        goto while_break___1;
      }
#line 2312
      if (cp->cinema) {
#line 2313
        if (cp->fixed_quality) {
#line 2314
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2316
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2318
      if (cp->fixed_quality) {
#line 2319
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2321
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2311
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2325
    tcp->csty = parameters->csty;
#line 2326
    tcp->prg = parameters->prog_order;
#line 2327
    tcp->mct = (int )parameters->tcp_mct;
#line 2329
    numpocs_tile = 0;
#line 2330
    tcp->POC = 0;
#line 2331
    if (parameters->numpocs) {
#line 2333
      tcp->POC = 1;
#line 2334
      i = 0;
      {
#line 2334
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2334
        if (! (i < parameters->numpocs)) {
#line 2334
          goto while_break___2;
        }
#line 2335
        if (tileno == parameters->POC[i].tile - 1) {
          _L: /* CIL Label */ 
#line 2336
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2337
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2338
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2339
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2340
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2341
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2342
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2343
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2344
          numpocs_tile ++;
        } else
#line 2335
        if (parameters->POC[i].tile == -1) {
#line 2335
          goto _L;
        }
#line 2334
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2347
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2349
      tcp->numpocs = 0;
    }
    {
#line 2352
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2352
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2354
    i = 0;
    }
    {
#line 2354
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2354
      if (! (i < image->numcomps)) {
#line 2354
        goto while_break___3;
      }
      {
#line 2355
      tccp = tcp->tccps + i;
#line 2356
      tccp->csty = parameters->csty & 1;
#line 2357
      tccp->numresolutions = parameters->numresolution;
#line 2358
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2359
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2360
      tccp->cblksty = parameters->mode;
      }
#line 2361
      if (parameters->irreversible) {
#line 2361
        tmp = 0;
      } else {
#line 2361
        tmp = 1;
      }
#line 2361
      tccp->qmfbid = tmp;
#line 2362
      if (parameters->irreversible) {
#line 2362
        tmp___0 = 2;
      } else {
#line 2362
        tmp___0 = 0;
      }
#line 2362
      tccp->qntsty = tmp___0;
#line 2363
      tccp->numgbits = 2;
#line 2364
      if (i == parameters->roi_compno) {
#line 2365
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2367
        tccp->roishift = 0;
      }
#line 2370
      if (parameters->cp_cinema) {
#line 2373
        tccp->prcw[0] = 7;
#line 2374
        tccp->prch[0] = 7;
#line 2376
        j = 1;
        {
#line 2376
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2376
          if (! (j < tccp->numresolutions)) {
#line 2376
            goto while_break___4;
          }
#line 2377
          tccp->prcw[j] = 8;
#line 2378
          tccp->prch[j] = 8;
#line 2376
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2381
      if (parameters->csty & 1) {
#line 2382
        p = 0;
#line 2383
        j = tccp->numresolutions - 1;
        {
#line 2383
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2383
          if (! (j >= 0)) {
#line 2383
            goto while_break___5;
          }
#line 2384
          if (p < parameters->res_spec) {
#line 2386
            if (parameters->prcw_init[p] < 1) {
#line 2387
              tccp->prcw[j] = 1;
            } else {
              {
#line 2389
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2392
            if (parameters->prch_init[p] < 1) {
#line 2393
              tccp->prch[j] = 1;
            } else {
              {
#line 2395
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2399
            res_spec = parameters->res_spec;
#line 2400
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2401
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2403
            if (size_prcw < 1) {
#line 2404
              tccp->prcw[j] = 1;
            } else {
              {
#line 2406
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2409
            if (size_prch < 1) {
#line 2410
              tccp->prch[j] = 1;
            } else {
              {
#line 2412
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2415
          p ++;
#line 2383
          __cil_tmp39 = j;
#line 2383
          j --;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2419
        j = 0;
        {
#line 2419
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2419
          if (! (j < tccp->numresolutions)) {
#line 2419
            goto while_break___6;
          }
#line 2420
          tccp->prcw[j] = 15;
#line 2421
          tccp->prch[j] = 15;
#line 2419
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2426
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
      }
#line 2354
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2308
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 2431 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___15 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  opj_tcp_t *tcp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_tcd_t *__cil_tmp20 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int tot_num_tp ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
#line 2433
  cp = (opj_cp_t *)((void *)0);
#line 2435
  tcd = (opj_tcd_t *)((void *)0);
#line 2437
  j2k->cio = cio;
#line 2438
  j2k->image = image;
#line 2440
  cp = j2k->cp;
#line 2443
  j2k->cstr_info = cstr_info;
#line 2444
  if (cstr_info) {
    {
#line 2446
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2446
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2447
    cstr_info->image_w = image->x1 - image->x0;
#line 2448
    cstr_info->image_h = image->y1 - image->y0;
#line 2449
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2450
    cstr_info->tw = cp->tw;
#line 2451
    cstr_info->th = cp->th;
#line 2452
    cstr_info->tile_x = cp->tdx;
#line 2453
    cstr_info->tile_y = cp->tdy;
#line 2454
    cstr_info->tile_Ox = cp->tx0;
#line 2455
    cstr_info->tile_Oy = cp->ty0;
#line 2456
    cstr_info->numcomps = image->numcomps;
#line 2457
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2458
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2458
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2459
    compno___15 = 0;
    }
    {
#line 2459
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2459
      if (! (compno___15 < image->numcomps)) {
#line 2459
        goto while_break;
      }
#line 2460
      *(cstr_info->numdecompos + compno___15) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2459
      compno___15 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2462
    cstr_info->D_max = 0.;
#line 2463
    cstr_info->main_head_start = cio_tell(cio);
#line 2464
    cstr_info->maxmarknum = 100;
#line 2465
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2465
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2466
    cstr_info->marknum = 0;
    }
  }
  {
#line 2470
  j2k_write_soc(j2k);
#line 2471
  j2k_write_siz(j2k);
#line 2472
  j2k_write_cod(j2k);
#line 2473
  j2k_write_qcd(j2k);
  }
#line 2475
  if (cp->cinema) {
#line 2476
    compno = 1;
    {
#line 2476
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2476
      if (! (compno < image->numcomps)) {
#line 2476
        goto while_break___0;
      }
      {
#line 2477
      j2k_write_coc(j2k, compno);
#line 2478
      j2k_write_qcc(j2k, compno);
      }
#line 2476
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2482
  compno = 0;
  {
#line 2482
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2482
    if (! (compno < image->numcomps)) {
#line 2482
      goto while_break___1;
    }
#line 2483
    tcp = cp->tcps + 0;
#line 2484
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2485
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2482
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2487
  if (cp->comment != (void *)0) {
    {
#line 2488
    j2k_write_com(j2k);
    }
  }
  {
#line 2491
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2493
  if (cp->cinema) {
    {
#line 2494
    j2k_write_tlm(j2k);
    }
#line 2495
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2496
      j2k_write_poc(j2k);
      }
    }
  }
#line 2504
  if (cstr_info) {
    {
#line 2505
    __cil_tmp19 = cio_tell(cio);
#line 2505
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2511
  tcd = tcd_create(j2k->cinfo);
#line 2514
  tileno = 0;
  }
  {
#line 2514
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2514
    if (! (tileno < cp->tw * cp->th)) {
#line 2514
      goto while_break___2;
    }
    {
#line 2516
    tilepartno = 0;
#line 2518
    acc_pack_num = 0;
#line 2522
    tcp___0 = cp->tcps + tileno;
#line 2523
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2525
    j2k->curtileno = tileno;
#line 2526
    j2k->cur_tp_num = 0;
#line 2527
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2529
    if (tileno == 0) {
      {
#line 2530
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2532
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2536
    if (cstr_info) {
      {
#line 2537
      __cil_tmp25 = cio_tell(cio);
#line 2537
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
#line 2538
      (cstr_info->tile + j2k->curtileno)->maxmarknum = 10;
#line 2539
      __cil_tmp26 = malloc((unsigned long )(cstr_info->tile + j2k->curtileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 2539
      (cstr_info->tile + j2k->curtileno)->marker = (opj_marker_info_t *)__cil_tmp26;
#line 2540
      (cstr_info->tile + j2k->curtileno)->marknum = 0;
      }
    }
#line 2544
    pino = 0;
    {
#line 2544
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2544
      if (! (pino <= tcp___0->numpocs)) {
#line 2544
        goto while_break___3;
      }
      {
#line 2546
      tcd->cur_pino = pino;
#line 2549
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2550
      tcd->tp_pos = cp->tp_pos;
#line 2552
      tilepartno = 0;
      }
      {
#line 2552
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2552
        if (! (tilepartno < tot_num_tp)) {
#line 2552
          goto while_break___4;
        }
#line 2553
        j2k->tp_num = tilepartno;
#line 2555
        if (cstr_info) {
          {
#line 2556
          __cil_tmp29 = cio_tell(cio);
#line 2556
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp29 + j2k->pos_correction;
          }
        }
        {
#line 2559
        j2k_write_sot(j2k);
        }
#line 2561
        if (j2k->cur_tp_num == 0) {
#line 2561
          if ((unsigned int )cp->cinema == 0U) {
#line 2562
            compno = 1;
            {
#line 2562
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2562
              if (! (compno < image->numcomps)) {
#line 2562
                goto while_break___5;
              }
              {
#line 2563
              j2k_write_coc(j2k, compno);
#line 2564
              j2k_write_qcc(j2k, compno);
              }
#line 2562
              compno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2566
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2567
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2572
        if (cstr_info) {
          {
#line 2573
          __cil_tmp31 = cio_tell(cio);
#line 2573
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp31 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2577
        j2k_write_sod(j2k, tcd);
        }
#line 2580
        if (cstr_info) {
          {
#line 2581
          __cil_tmp32 = cio_tell(cio);
#line 2581
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp32 + j2k->pos_correction) - 1;
#line 2583
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2585
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2587
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2591
        (j2k->cur_tp_num) ++;
#line 2552
        tilepartno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2544
      pino ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2594
    if (cstr_info) {
      {
#line 2595
      __cil_tmp36 = cio_tell(cio);
#line 2595
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp36 + j2k->pos_correction) - 1;
      }
    }
#line 2514
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2618
  tcd_free_encode(tcd);
#line 2619
  tcd_destroy(tcd);
#line 2621
  free(j2k->cur_totnum_tp);
#line 2623
  j2k_write_eoc(j2k);
  }
#line 2625
  if (cstr_info) {
    {
#line 2626
    __cil_tmp38 = cio_tell(cio);
#line 2626
    cstr_info->codestream_size = __cil_tmp38 + j2k->pos_correction;
#line 2631
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2647
  return (1);
}
}
#line 2650 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2652
  if (! cstr_info) {
#line 2653
    return;
  }
#line 2656
  if (cstr_info->marknum + 1 > cstr_info->maxmarknum) {
    {
#line 2657
    cstr_info->maxmarknum = 100 + (int )((float )cstr_info->maxmarknum * 1.f);
#line 2658
    __cil_tmp5 = realloc(cstr_info->marker, (unsigned long )cstr_info->maxmarknum);
#line 2658
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp5;
    }
  }
#line 2662
  (cstr_info->marker + cstr_info->marknum)->type = type;
#line 2663
  (cstr_info->marker + cstr_info->marknum)->pos = pos;
#line 2664
  (cstr_info->marker + cstr_info->marknum)->len = len;
#line 2665
  (cstr_info->marknum) ++;
  return;
}
}
#line 2669 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/j2k.c"
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  opj_marker_info_t *marker ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2673
  if (! cstr_info) {
#line 2674
    return;
  }
#line 2677
  if ((cstr_info->tile + tileno)->marknum + 1 > (cstr_info->tile + tileno)->maxmarknum) {
    {
#line 2678
    (cstr_info->tile + tileno)->maxmarknum = 100 + (int )((float )(cstr_info->tile + tileno)->maxmarknum * 1.f);
#line 2679
    __cil_tmp7 = realloc((cstr_info->tile + tileno)->marker, (unsigned long )cstr_info->maxmarknum);
#line 2679
    (cstr_info->tile + tileno)->marker = (opj_marker_info_t *)__cil_tmp7;
    }
  }
#line 2682
  marker = (cstr_info->tile + tileno)->marker + (cstr_info->tile + tileno)->marknum;
#line 2685
  marker->type = type;
#line 2686
  marker->pos = pos;
#line 2687
  marker->len = len;
#line 2688
  ((cstr_info->tile + tileno)->marknum) ++;
  return;
}
}
#line 29 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/image.c"
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) 
{ 
  int compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = calloc((unsigned long )1, (unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(int ));
#line 61
      comp->data = (int *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 70
  return (image);
}
}
#line 73 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  int i ;
  opj_image_comp_t *image_comp ;
  int __cil_tmp4 ;

  {
#line 75
  if (image) {
#line 76
    if (image->comps) {
#line 78
      i = 0;
      {
#line 78
      while (1) {
        while_continue: /* CIL Label */ ;
#line 78
        if (! (i < image->numcomps)) {
#line 78
          goto while_break;
        }
#line 79
        image_comp = image->comps + i;
#line 80
        if (image_comp->data) {
          {
#line 81
          free(image_comp->data);
          }
        }
#line 78
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 84
      free(image->comps);
      }
    }
    {
#line 86
    free(image);
    }
  }
  return;
}
}
#line 65 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/event.c"
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) 
{ 
  opj_event_mgr_t *previous ;

  {
#line 66
  if (cinfo) {
#line 67
    previous = cinfo->event_mgr;
#line 68
    cinfo->event_mgr = event_mgr;
#line 69
    cinfo->client_data = context;
#line 70
    return (previous);
  }
#line 73
  return ((opj_event_mgr_t *)((void *)0));
}
}
#line 76 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/event.c"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) 
{ 
  opj_msg_callback msg_handler ;
  opj_event_mgr_t *event_mgr ;
  va_list arg ;
  int str_length ;
  char message[512] ;
  int __cil_tmp9 ;

  {
#line 78
  msg_handler = (opj_msg_callback )((void *)0);
#line 80
  event_mgr = cinfo->event_mgr;
#line 81
  if (event_mgr != (void *)0) {
    {
#line 83
    if (event_type == 1) {
#line 83
      goto case_1;
    }
#line 86
    if (event_type == 2) {
#line 86
      goto case_2;
    }
#line 89
    if (event_type == 4) {
#line 89
      goto case_4;
    }
#line 92
    goto switch_default;
    case_1: /* CIL Label */ 
#line 84
    msg_handler = event_mgr->error_handler;
#line 85
    goto switch_break;
    case_2: /* CIL Label */ 
#line 87
    msg_handler = event_mgr->warning_handler;
#line 88
    goto switch_break;
    case_4: /* CIL Label */ 
#line 90
    msg_handler = event_mgr->info_handler;
#line 91
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 93
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 95
    if (msg_handler == (void *)0) {
#line 96
      return (0);
    }
  } else {
#line 99
    return (0);
  }
#line 102
  if (fmt != (void *)0) {
#line 102
    if (event_mgr != (void *)0) {
      {
#line 107
      __builtin_va_start((void *)arg, fmt);
#line 109
      str_length = vsnprintf((char *)message, (unsigned long )512, fmt, (void *)arg);
#line 111
      __builtin_va_end((void *)arg);
      }
#line 114
      if (str_length > -1) {
#line 114
        if (str_length < 512) {
          {
#line 115
          (*msg_handler)((char const   *)((char *)message), cinfo->client_data);
          }
        } else {
#line 116
          return (0);
        }
      } else {
#line 116
        return (0);
      }
    }
  }
#line 119
  return (1);
}
}
#line 37 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 38
  cp = (opj_cp_t *)((void *)0);
#line 39
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 39
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 40
  if (! cio) {
#line 40
    return ((opj_cio_t *)((void *)0));
  }
#line 41
  cio->cinfo = cinfo;
#line 42
  if (buffer) {
#line 42
    if (length) {
#line 44
      cio->openmode = 1;
#line 45
      cio->buffer = buffer;
#line 46
      cio->length = length;
    } else {
#line 42
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 48
  if (! buffer) {
#line 48
    if (! length) {
#line 48
      if (cinfo) {
#line 50
        cio->openmode = 2;
        {
#line 52
        if ((int )cinfo->codec_format == 0) {
#line 52
          goto case_0;
        }
#line 55
        if ((int )cinfo->codec_format == 2) {
#line 55
          goto case_2;
        }
#line 58
        goto switch_default;
        case_0: /* CIL Label */ 
#line 53
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 54
        goto switch_break;
        case_2: /* CIL Label */ 
#line 56
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 57
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 59
        free(cio);
        }
#line 60
        return ((opj_cio_t *)((void *)0));
        switch_break: /* CIL Label */ ;
        }
        {
#line 62
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 63
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 63
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 64
        if (! cio->buffer) {
          {
#line 65
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n\330");
#line 66
          free(cio);
          }
#line 67
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
        {
        {
#line 71
        free(cio);
        }
        }
        }
#line 72
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
      {
      {
#line 71
      free(cio);
      }
      }
      }
#line 72
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
    {
    {
#line 71
    free(cio);
    }
    }
    }
#line 72
    return ((opj_cio_t *)((void *)0));
  }
#line 76
  cio->start = cio->buffer;
#line 77
  cio->end = cio->buffer + cio->length;
#line 78
  cio->bp = cio->buffer;
#line 80
  return (cio);
}
}
#line 83 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 84
  if (cio) {
#line 85
    if (cio->openmode == 2) {
      {
#line 87
      free(cio->buffer);
      }
    }
    {
#line 90
    free(cio);
    }
  }
  return;
}
}
#line 100 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 101
  return ((int )(cio->bp - cio->start));
}
}
#line 109 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 
  int tmp ;

  {
#line 111
  cio->bp = cio->start + pos;
  return;
}
}
#line 117 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 
  int tmp ;

  {
#line 119
  return ((int )(cio->end - cio->bp));
}
}
#line 125 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 126
  return (cio->bp);
}
}
#line 132 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
opj_bool cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 133
  if (cio->bp >= cio->end) {
    {
#line 134
    opj_event_msg(cio->cinfo, 1, "write error\n\006V");
    }
#line 135
    return (0);
  }
#line 137
  __cil_tmp3 = cio->bp;
#line 137
  (cio->bp) ++;
#line 137
  *__cil_tmp3 = v;
#line 138
  return (1);
}
}
#line 144 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 146
  if (cio->bp >= cio->end) {
    {
#line 147
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 148
    return ((unsigned char )0);
  }
#line 150
  __cil_tmp3 = cio->bp;
#line 150
  (cio->bp) ++;
#line 150
  return (*__cil_tmp3);
}
}
#line 159 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) 
{ 
  int i ;
  opj_bool __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 161
  i = n - 1;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i >= 0)) {
#line 161
      goto while_break;
    }
    {
#line 162
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255ULL));
    }
#line 162
    if (! __cil_tmp5) {
#line 163
      return ((unsigned int )0);
    }
#line 161
    __cil_tmp6 = i;
#line 161
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return ((unsigned int )n);
}
}
#line 175 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 178
  v = (unsigned int )0;
#line 179
  i = n - 1;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i >= 0)) {
#line 179
      goto while_break;
    }
    {
#line 180
    __cil_tmp5 = cio_bytein(cio);
    }
#line 180
    v += (unsigned int )__cil_tmp5 << (i << 3);
#line 179
    __cil_tmp6 = i;
#line 179
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (v);
}
}
#line 190 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 192
  if (! (cio->bp + n < cio->start)) {
#line 192
    if (cio->bp + n > cio->end) {

    }
  }
#line 195
  cio->bp += n;
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , unsigned int b ) ;
#line 51
static int bio_getbit(opj_bio_t *bio ) ;
#line 57
static int bio_byteout(opj_bio_t *bio ) ;
#line 63
static int bio_bytein(opj_bio_t *bio ) ;
#line 75 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
static int bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = tmp;
#line 78
  if (bio->bp >= bio->end) {
#line 79
    return (1);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (unsigned char )(bio->buf >> 8);
#line 82
  return (0);
}
}
#line 85 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
static int bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = tmp;
#line 88
  if (bio->bp >= bio->end) {
#line 89
    return (1);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (0);
}
}
#line 95 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , unsigned int b ) 
{ 
  int __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0) {
    {
#line 97
    bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= b << bio->ct;
  return;
}
}
#line 103 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
static int bio_getbit(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0) {
    {
#line 105
    bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((int )((bio->buf >> bio->ct) & 1U));
}
}
#line 117 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
opj_bio_t *bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
void bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free(bio);
    }
  }
  return;
}
}
#line 128 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
int bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return ((int )(bio->bp - bio->start));
}
}
#line 132 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (unsigned int )0;
#line 137
  bio->ct = 8;
  return;
}
}
#line 140 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = (unsigned int )0;
#line 145
  bio->ct = 0;
  return;
}
}
#line 148 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
void bio_write(opj_bio_t *bio , int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 150
  i = n - 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i >= 0)) {
#line 150
      goto while_break;
    }
    {
#line 151
    bio_putbit(bio, (unsigned int )((v >> i) & 1));
    }
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 155 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
int bio_read(opj_bio_t *bio , int n ) 
{ 
  int i ;
  int v ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  v = 0;
#line 158
  i = n - 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    __cil_tmp5 = bio_getbit(bio);
    }
#line 159
    v += __cil_tmp5 << i;
#line 158
    __cil_tmp6 = i;
#line 158
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (v);
}
}
#line 164 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
int bio_flush(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 165
  bio->ct = 0;
#line 166
  __cil_tmp2 = bio_byteout(bio);
  }
#line 166
  if (__cil_tmp2) {
#line 167
    return (1);
  }
#line 169
  if (bio->ct == 7) {
    {
#line 170
    bio->ct = 0;
#line 171
    __cil_tmp3 = bio_byteout(bio);
    }
#line 171
    if (__cil_tmp3) {
#line 172
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/doner/openjpeg/openjpeg-910af7ed/libopenjpeg/bio.c"
int bio_inalign(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 179
  bio->ct = 0;
#line 180
  if ((bio->buf & 255U) == 255U) {
    {
#line 181
    __cil_tmp2 = bio_bytein(bio);
    }
#line 181
    if (__cil_tmp2) {
#line 182
      return (1);
    }
#line 184
    bio->ct = 0;
  }
#line 186
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 18 "../../applications/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20
int opj_optopt ;
#line 21
int opj_optreset ;
#line 22
char *opj_optarg ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 51 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 78
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 79
extern opj_image_t *pngtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 42 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 35 "../../applications/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 36
extern void color_apply_icc_profile(opj_image_t *image ) ;
#line 88 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static void decode_help_display(void) 
{ 


  {
  {
#line 89
  fprintf(stdout, "HELP for j2k_to_image\n----\n\n\006V");
#line 90
  fprintf(stdout, "- the -h option displays this help information on screen\n\n\223U\006V");
#line 93
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n\001");
#line 99
  fprintf(stdout, "\n\235\001");
#line 100
  fprintf(stdout, "\n\244\001");
#line 101
  fprintf(stdout, "  -ImgDir \nU\006V");
#line 102
  fprintf(stdout, "\tImage file Directory path \n");
#line 103
  fprintf(stdout, "  -OutFor \nU\006V");
#line 104
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 105
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 106
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA formats\nV");
#line 107
  fprintf(stdout, "  -i <compressed file>\n");
#line 108
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n\006V");
#line 109
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 110
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 111
  fprintf(stdout, "  -o <decompressed file>\n");
#line 112
  fprintf(stdout, "    REQUIRED\n");
#line 113
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA files\n");
#line 114
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 115
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 116
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 117
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 118
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 119
  fprintf(stdout, "    will be written to the file.\n");
#line 120
  fprintf(stdout, "  -r <reduce factor>\n");
#line 121
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 122
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 123
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 124
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 125
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 126
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 127
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 128
  fprintf(stdout, "    are decoded.\n");
#line 129
  fprintf(stdout, "  -x  \n");
#line 130
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 131
  fprintf(stdout, "\n");
#line 142
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 147 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 150
  num_images = 0;
#line 154
  dir = opendir((char const   *)imgdirpath);
  }
#line 155
  if (! dir) {
    {
#line 156
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 157
    return (0);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    content = readdir(dir);
    }
#line 160
    if (! (content != (void *)0)) {
#line 160
      goto while_break;
    }
    {
#line 161
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 161
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 161
    if (__cil_tmp7 == 0) {
#line 162
      goto while_continue;
    } else
#line 161
    if (__cil_tmp8 == 0) {
#line 162
      goto while_continue;
    }
#line 163
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  closedir(dir);
  }
#line 166
  return (num_images);
}
}
#line 169 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 172
  i = 0;
#line 176
  dir = opendir((char const   *)imgdirpath);
  }
#line 177
  if (! dir) {
    {
#line 178
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 179
    return (1);
  } else {
    {
#line 181
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    content = readdir(dir);
    }
#line 184
    if (! (content != (void *)0)) {
#line 184
      goto while_break;
    }
    {
#line 185
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 185
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 185
    if (__cil_tmp8 == 0) {
#line 186
      goto while_continue;
    } else
#line 185
    if (__cil_tmp9 == 0) {
#line 186
      goto while_continue;
    }
    {
#line 188
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 189
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  closedir(dir);
  }
#line 192
  return (0);
}
}
#line 195 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[14] ;
  static int const   format[14] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 197
  extension[0] = "pgxU\006V";
#line 197
  extension[1] = "pnmU\006V";
#line 197
  extension[2] = "pgmU\006V";
#line 197
  extension[3] = "ppmU\006V";
#line 197
  extension[4] = "bmpU\006V";
#line 197
  extension[5] = "tifU\006V";
#line 197
  extension[6] = "rawU\006V";
#line 197
  extension[7] = "tgaU\006V";
#line 197
  extension[8] = "pngU\006V";
#line 197
  extension[9] = "j2kU\006V";
#line 197
  extension[10] = "jp2U\006V";
#line 197
  extension[11] = "jpt";
#line 197
  extension[12] = "j2c";
#line 197
  extension[13] = "jpc";
#line 198
  format[0] = 11;
#line 198
  format[1] = 10;
#line 198
  format[2] = 10;
#line 198
  format[3] = 10;
#line 198
  format[4] = 12;
#line 198
  format[5] = 14;
#line 198
  format[6] = 15;
#line 198
  format[7] = 16;
#line 198
  format[8] = 17;
#line 198
  format[9] = 0;
#line 198
  format[10] = 1;
#line 198
  format[11] = 2;
#line 198
  format[12] = 0;
#line 198
  format[13] = 0;
#line 199
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 199
  ext = __cil_tmp6;
  }
#line 200
  if (ext == (void *)0) {
#line 201
    return (- 1);
  }
#line 202
  ext ++;
#line 203
  if (ext) {
#line 204
    i = (unsigned int )0;
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 204
        goto while_break;
      }
      {
#line 205
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
      }
#line 205
      if (__cil_tmp8 == 0) {
#line 206
        return (format[i]);
      }
#line 204
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 211
  return (- 1);
}
}
#line 214 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 216
  temp1 = "\002";
#line 218
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 219
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 220
  parameters->decod_format = get_file_format((char *)image_filename);
  }
#line 221
  if (parameters->decod_format == -1) {
#line 222
    return ((char )1);
  }
  {
#line 223
  sprintf((char *)infilename, "%s/%sV", img_fol->imgdirpath, (char *)image_filename);
#line 224
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 227
  __cil_tmp12 = strtok((char *)image_filename, ".\311");
#line 227
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 228
    temp_p = strtok((char *)((void *)0), ".\027\231U\006V");
    }
#line 228
    if (! (temp_p != (void *)0)) {
#line 228
      goto while_break;
    }
    {
#line 229
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 230
    sprintf((char *)temp1, ".%sU\006V", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  if ((int )img_fol->set_out_format == 1) {
    {
#line 233
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 234
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 236
  return ((char )0);
}
}
#line 240 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                                 img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char const   optlist[12] ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp14 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *index___16 ;

  {
#line 243
  long_option[0].name = "ImgDir";
#line 243
  long_option[0].has_arg = 1;
#line 243
  long_option[0].flag = (int *)((void *)0);
#line 243
  long_option[0].val = 'y';
#line 243
  long_option[1].name = "OutFor";
#line 243
  long_option[1].has_arg = 1;
#line 243
  long_option[1].flag = (int *)((void *)0);
#line 243
  long_option[1].val = 'O';
#line 248
  optlist = "i:o:r:l:x:h";
#line 256
  totlen = (int )sizeof(long_option);
#line 257
  img_fol->set_out_format = (char )0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 260
    if (c == -1) {
#line 261
      goto while_break;
    }
    {
#line 263
    if (c == 'i') {
#line 263
      goto case_105;
    }
#line 270
    if (c == 2) {
#line 270
      goto case_2;
    }
#line 270
    if (c == 1) {
#line 270
      goto case_2;
    }
#line 270
    if (c == 0) {
#line 270
      goto case_2;
    }
#line 284
    if (c == 'o') {
#line 284
      goto case_111;
    }
#line 295
    if (c == 17) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 16) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 15) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 14) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 12) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 10) {
#line 295
      goto case_17;
    }
#line 295
    if (c == 11) {
#line 295
      goto case_17;
    }
#line 307
    if (c == 'O') {
#line 307
      goto case_79;
    }
#line 315
    if (c == 11) {
#line 315
      goto case_11___0;
    }
#line 318
    if (c == 10) {
#line 318
      goto case_10___0;
    }
#line 321
    if (c == 12) {
#line 321
      goto case_12___0;
    }
#line 324
    if (c == 14) {
#line 324
      goto case_14___0;
    }
#line 327
    if (c == 15) {
#line 327
      goto case_15___0;
    }
#line 330
    if (c == 16) {
#line 330
      goto case_16___0;
    }
#line 333
    if (c == 17) {
#line 333
      goto case_17___0;
    }
#line 347
    if (c == 'r') {
#line 347
      goto case_114;
    }
#line 356
    if (c == 'l') {
#line 356
      goto case_108;
    }
#line 364
    if (c == 'h') {
#line 364
      goto case_104;
    }
#line 370
    if (c == 'y') {
#line 370
      goto case_121;
    }
#line 378
    if (c == 'x') {
#line 378
      goto case_120;
    }
#line 458
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 265
    infile = opj_optarg;
#line 266
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 270
    if (parameters->decod_format == 2) {
#line 270
      goto case_2;
    }
#line 270
    if (parameters->decod_format == 1) {
#line 270
      goto case_2;
    }
#line 270
    if (parameters->decod_format == 0) {
#line 270
      goto case_2;
    }
#line 272
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 271
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 273
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 276
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 278
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 280
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 286
    outfile = opj_optarg;
#line 287
    parameters->cod_format = get_file_format(outfile);
    }
    {
#line 295
    if (parameters->cod_format == 17) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 16) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 15) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 14) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 12) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 10) {
#line 295
      goto case_17;
    }
#line 295
    if (parameters->cod_format == 11) {
#line 295
      goto case_17;
    }
#line 297
    goto switch_default___0;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 296
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 298
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outfile);
    }
#line 299
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 301
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 303
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 310
    of = opj_optarg;
#line 311
    sprintf((char *)outformat, ".%s", of);
#line 312
    img_fol->set_out_format = (char )1;
#line 313
    parameters->cod_format = get_file_format((char *)outformat);
    }
    {
#line 315
    if (parameters->cod_format == 11) {
#line 315
      goto case_11___0;
    }
#line 318
    if (parameters->cod_format == 10) {
#line 318
      goto case_10___0;
    }
#line 321
    if (parameters->cod_format == 12) {
#line 321
      goto case_12___0;
    }
#line 324
    if (parameters->cod_format == 14) {
#line 324
      goto case_14___0;
    }
#line 327
    if (parameters->cod_format == 15) {
#line 327
      goto case_15___0;
    }
#line 330
    if (parameters->cod_format == 16) {
#line 330
      goto case_16___0;
    }
#line 333
    if (parameters->cod_format == 17) {
#line 333
      goto case_17___0;
    }
#line 336
    goto switch_default___1;
    case_11___0: /* CIL Label */ 
#line 316
    img_fol->out_format = "pgx";
#line 317
    goto switch_break___2;
    case_10___0: /* CIL Label */ 
#line 319
    img_fol->out_format = "ppm";
#line 320
    goto switch_break___2;
    case_12___0: /* CIL Label */ 
#line 322
    img_fol->out_format = "bmp";
#line 323
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 325
    img_fol->out_format = "tif";
#line 326
    goto switch_break___2;
    case_15___0: /* CIL Label */ 
#line 328
    img_fol->out_format = "raw";
#line 329
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
#line 331
    img_fol->out_format = "raw";
#line 332
    goto switch_break___2;
    case_17___0: /* CIL Label */ 
#line 334
    img_fol->out_format = "png";
#line 335
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 337
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            (char *)outformat);
    }
#line 338
    return (1);
#line 339
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 342
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 349
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_reduce);
    }
#line 351
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 358
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_layer);
    }
#line 360
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 365
    decode_help_display();
    }
#line 366
    return (1);
    case_121: /* CIL Label */ 
    {
#line 372
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 372
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 372
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 373
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 374
    img_fol->set_imgdir = (char )1;
    }
#line 376
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 380
    index___16 = opj_optarg;
#line 381
    strncpy(indexfilename, (char const   *)index___16, (unsigned long )4096);
    }
#line 383
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 459
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, opj_optarg);
    }
#line 460
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 258
    if (! (c != -1)) {
#line 258
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  if ((int )img_fol->set_imgdir == 1) {
#line 466
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 467
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 468
      return (1);
    }
#line 470
    if ((int )img_fol->set_out_format == 0) {
      {
#line 471
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 472
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 473
      return (1);
    }
#line 475
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 476
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 477
      return (1);
    }
  } else
#line 480
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 481
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 482
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 483
    return (1);
  } else
#line 480
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 481
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 482
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 483
    return (1);
  }
#line 487
  return (0);
}
}
#line 495 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 496
  stream = (FILE *)client_data;
#line 497
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 502 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 503
  stream = (FILE *)client_data;
#line 504
  fprintf(stream, "[WARNING] %s\006V", msg);
  }
  return;
}
}
#line 509 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
static void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 511
  fprintf(stdout, "[INFO] %s8\232U\006V", msg);
  }
  return;
}
}
#line 516 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/j2k_to_image.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char __cil_tmp25 ;
  FILE *__cil_tmp26 ;
  long __cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  opj_dinfo_t *__cil_tmp30 ;
  opj_cio_t *__cil_tmp31 ;
  opj_image_t *__cil_tmp32 ;
  opj_image_t *__cil_tmp33 ;
  opj_bool bSuccess ;
  int __cil_tmp35 ;
  opj_dinfo_t *__cil_tmp36 ;
  opj_cio_t *__cil_tmp37 ;
  opj_image_t *__cil_tmp38 ;
  opj_image_t *__cil_tmp39 ;
  opj_bool bSuccess___0 ;
  int __cil_tmp41 ;
  opj_dinfo_t *__cil_tmp42 ;
  opj_cio_t *__cil_tmp43 ;
  opj_image_t *__cil_tmp44 ;
  opj_image_t *__cil_tmp45 ;
  opj_bool bSuccess___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 520
  image = (opj_image_t *)((void *)0);
#line 521
  fsrc = (FILE *)((void *)0);
#line 522
  src = (unsigned char *)((void *)0);
#line 526
  dirptr = (dircnt_t *)((void *)0);
#line 527
  dinfo = (opj_dinfo_t *)((void *)0);
#line 528
  cio = (opj_cio_t *)((void *)0);
#line 533
  memset(& event_mgr, 0, sizeof(opj_event_mgr_t ));
#line 534
  event_mgr.error_handler = & error_callback;
#line 535
  event_mgr.warning_handler = & warning_callback;
#line 536
  event_mgr.info_handler = & info_callback;
#line 539
  opj_set_default_decoder_parameters(& parameters);
#line 542
  *((char *)indexfilename) = (char )0;
#line 543
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 546
  __cil_tmp18 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 546
  if (__cil_tmp18 == 1) {
#line 547
    return (1);
  }
#line 551
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 552
    num_images = get_num_images(img_fol.imgdirpath);
#line 554
    __cil_tmp20 = malloc(sizeof(dircnt_t ));
#line 554
    dirptr = (dircnt_t *)__cil_tmp20;
    }
#line 555
    if (dirptr) {
      {
#line 556
      __cil_tmp21 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 556
      dirptr->filename_buf = (char *)__cil_tmp21;
#line 557
      __cil_tmp22 = malloc((unsigned long )num_images * sizeof(char *));
#line 557
      dirptr->filename = (char **)__cil_tmp22;
      }
#line 559
      if (! dirptr->filename_buf) {
#line 560
        return (1);
      }
#line 562
      i = 0;
      {
#line 562
      while (1) {
        while_continue: /* CIL Label */ ;
#line 562
        if (! (i < num_images)) {
#line 562
          goto while_break;
        }
#line 563
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 562
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 566
    __cil_tmp24 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 566
    if (__cil_tmp24 == 1) {
#line 567
      return (1);
    }
#line 569
    if (num_images == 0) {
      {
#line 570
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 571
      return (1);
    }
  } else {
#line 574
    num_images = 1;
  }
#line 578
  imageno = 0;
  {
#line 578
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 578
    if (! (imageno < num_images)) {
#line 578
      goto while_break___0;
    }
    {
#line 579
    image = (opj_image_t *)((void *)0);
#line 580
    fprintf(stderr, "\n\225\231U\006V");
    }
#line 582
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 583
      __cil_tmp25 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 583
      if (__cil_tmp25) {
        {
#line 584
        fprintf(stderr, "skipping file...\nk\232U\006V");
        }
#line 585
        goto while_continue___0;
      }
    }
    {
#line 591
    fsrc = fopen((char const   *)((char *)parameters.infile), "rb\231U\006V");
    }
#line 592
    if (! fsrc) {
      {
#line 593
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.infile);
      }
#line 594
      return (1);
    }
    {
#line 596
    fseek(fsrc, (long )0, 2);
#line 597
    __cil_tmp27 = ftell(fsrc);
#line 597
    file_length = (int )__cil_tmp27;
#line 598
    fseek(fsrc, (long )0, 0);
#line 599
    __cil_tmp28 = malloc((unsigned long )file_length);
#line 599
    src = (unsigned char *)__cil_tmp28;
#line 600
    __cil_tmp29 = fread(src, (unsigned long )1, (unsigned long )file_length, fsrc);
    }
#line 600
    if (__cil_tmp29 != (size_t )file_length) {
      {
#line 602
      free(src);
#line 603
      fclose(fsrc);
#line 604
      fprintf(stderr, "\nERROR: fread return a number of element different from the expected.\n");
      }
#line 605
      return (1);
    }
    {
#line 607
    fclose(fsrc);
    }
    {
#line 613
    if (parameters.decod_format == 0) {
#line 613
      goto case_0;
    }
#line 656
    if (parameters.decod_format == 1) {
#line 656
      goto case_1;
    }
#line 699
    if (parameters.decod_format == 2) {
#line 699
      goto case_2;
    }
#line 742
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 618
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 621
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 624
    opj_setup_decoder(dinfo, & parameters);
#line 627
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 630
    if (*((char *)indexfilename)) {
      {
#line 631
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 633
      image = opj_decode(dinfo, cio);
      }
    }
#line 634
    if (! image) {
      {
#line 635
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 636
      opj_destroy_decompress(dinfo);
#line 637
      opj_cio_close(cio);
#line 638
      free(src);
      }
#line 639
      return (1);
    }
    {
#line 643
    opj_cio_close(cio);
    }
#line 646
    if (*((char *)indexfilename)) {
      {
#line 648
      bSuccess = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 649
      if (bSuccess) {
        {
#line 650
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 654
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 661
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 664
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 667
    opj_setup_decoder(dinfo, & parameters);
#line 670
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 673
    if (*((char *)indexfilename)) {
      {
#line 674
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 676
      image = opj_decode(dinfo, cio);
      }
    }
#line 677
    if (! image) {
      {
#line 678
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 679
      opj_destroy_decompress(dinfo);
#line 680
      opj_cio_close(cio);
#line 681
      free(src);
      }
#line 682
      return (1);
    }
    {
#line 686
    opj_cio_close(cio);
    }
#line 689
    if (*((char *)indexfilename)) {
      {
#line 691
      bSuccess___0 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 692
      if (bSuccess___0) {
        {
#line 693
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 697
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 704
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 707
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 710
    opj_setup_decoder(dinfo, & parameters);
#line 713
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 716
    if (*((char *)indexfilename)) {
      {
#line 717
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 719
      image = opj_decode(dinfo, cio);
      }
    }
#line 720
    if (! image) {
      {
#line 721
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 722
      opj_destroy_decompress(dinfo);
#line 723
      opj_cio_close(cio);
#line 724
      free(src);
      }
#line 725
      return (1);
    }
    {
#line 729
    opj_cio_close(cio);
    }
#line 732
    if (*((char *)indexfilename)) {
      {
#line 734
      bSuccess___1 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 735
      if (bSuccess___1) {
        {
#line 736
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 740
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 743
    fprintf(stderr, "skipping file..\n\220");
    }
#line 744
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 748
    free(src);
#line 749
    src = (unsigned char *)((void *)0);
    }
#line 751
    if ((int )image->color_space == 3) {
      {
#line 753
      color_sycc_to_rgb(image);
      }
    }
#line 756
    if (image->icc_profile_buf) {
      {
#line 762
      free(image->icc_profile_buf);
#line 763
      image->icc_profile_buf = (unsigned char *)((void *)0);
#line 763
      image->icc_profile_len = 0;
      }
    }
    {
#line 769
    if (parameters.cod_format == 10) {
#line 769
      goto case_10;
    }
#line 778
    if (parameters.cod_format == 11) {
#line 778
      goto case_11;
    }
#line 787
    if (parameters.cod_format == 12) {
#line 787
      goto case_12;
    }
#line 805
    if (parameters.cod_format == 15) {
#line 805
      goto case_15;
    }
#line 814
    if (parameters.cod_format == 16) {
#line 814
      goto case_16;
    }
#line 835
    goto switch_default___0;
    case_10: /* CIL Label */ 
    {
#line 770
    __cil_tmp48 = imagetopnm(image, (char const   *)((char *)parameters.outfile));
    }
#line 770
    if (__cil_tmp48) {
      {
#line 771
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 774
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 776
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 779
    __cil_tmp49 = imagetopgx(image, (char const   *)((char *)parameters.outfile));
    }
#line 779
    if (__cil_tmp49) {
      {
#line 780
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 783
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 785
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 788
    __cil_tmp50 = imagetobmp(image, (char const   *)((char *)parameters.outfile));
    }
#line 788
    if (__cil_tmp50) {
      {
#line 789
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 792
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 794
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 806
    __cil_tmp51 = imagetoraw(image, (char const   *)((char *)parameters.outfile));
    }
#line 806
    if (__cil_tmp51) {
      {
#line 807
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 810
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 812
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 815
    __cil_tmp52 = imagetotga(image, (char const   *)((char *)parameters.outfile));
    }
#line 815
    if (__cil_tmp52) {
      {
#line 816
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 819
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 821
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 836
    fprintf(stderr, "Outfile %s not generated\n", (char *)parameters.outfile);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 840
    if (dinfo) {
      {
#line 841
      opj_destroy_decompress(dinfo);
      }
    }
#line 844
    if (*((char *)indexfilename)) {
      {
#line 845
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 847
    opj_image_destroy(image);
    }
#line 578
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 850
  return (0);
}
}
#line 43 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int start_pos ;
  int end_ph_pos ;
  int end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___17 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___18 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___19 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___20 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___21 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___22 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 45
  stream = (FILE *)((void *)0);
#line 46
  total_disto = (double )0;
#line 57
  if (! cstr_info) {
#line 58
    return (1);
  }
  {
#line 60
  stream = fopen((char const   *)index___0, "w");
  }
#line 61
  if (! stream) {
    {
#line 62
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 63
    return (1);
  }
#line 66
  if ((cstr_info->tile + 0)->distotile) {
#line 67
    disto_on = (char )1;
  } else {
#line 69
    disto_on = (char )0;
  }
#line 71
  if ((cstr_info->tile + 0)->numpix) {
#line 72
    numpix_on = (char )1;
  } else {
#line 74
    numpix_on = (char )0;
  }
  {
#line 76
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 77
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 78
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 80
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 81
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 82
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 84
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (resno >= 0)) {
#line 84
      goto while_break;
    }
    {
#line 85
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 84
    __cil_tmp17 = resno;
#line 84
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  fprintf(stream, "\n");
#line 91
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 93
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 94
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 96
  fprintf(stream, "\nINFO ON TILES\n");
#line 97
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 98
  if (disto_on) {
    {
#line 99
    fprintf(stream, "         disto");
    }
  }
#line 100
  if (numpix_on) {
    {
#line 101
    fprintf(stream, "     nbpix");
    }
  }
#line 102
  if ((int )disto_on) {
#line 102
    if ((int )numpix_on) {
      {
#line 103
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 104
  fprintf(stream, "\n");
#line 106
  tileno = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 113
    if (disto_on) {
      {
#line 114
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 115
    if (numpix_on) {
      {
#line 116
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 117
    if ((int )disto_on) {
#line 117
      if ((int )numpix_on) {
        {
#line 118
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 119
    fprintf(stream, "\n");
    }
#line 106
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  tileno = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 122
      goto while_break___1;
    }
#line 124
    disto = (double )0;
#line 125
    max_numdecompos = 0;
#line 126
    pack_nb = 0;
#line 128
    compno = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (compno < cstr_info->numcomps)) {
#line 128
        goto while_break___2;
      }
#line 129
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 130
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 128
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 134
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 135
    tilepartno = 0;
    }
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 135
        goto while_break___3;
      }
      {
#line 136
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 135
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 145
    if ((int )cstr_info->prog == 0) {
      {
#line 146
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 147
      if (disto_on) {
        {
#line 148
        fprintf(stream, " disto");
        }
      }
      {
#line 149
      fprintf(stream, "\n");
#line 151
      layno = 0;
      }
      {
#line 151
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 151
        if (! (layno < cstr_info->numlayers)) {
#line 151
          goto while_break___4;
        }
#line 152
        resno = 0;
        {
#line 152
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 152
          if (! (resno < max_numdecompos + 1)) {
#line 152
            goto while_break___5;
          }
#line 153
          compno = 0;
          {
#line 153
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 153
            if (! (compno < cstr_info->numcomps)) {
#line 153
              goto while_break___6;
            }
#line 155
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 156
              goto while_break___6;
            }
#line 157
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 158
            precno = 0;
            {
#line 158
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 158
              if (! (precno < prec_max)) {
#line 158
                goto while_break___7;
              }
              {
#line 159
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 160
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 161
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 162
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 163
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 165
              if (disto_on) {
                {
#line 166
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 167
              fprintf(stream, "\n");
#line 168
              total_disto += disto;
#line 169
              pack_nb ++;
              }
#line 158
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 153
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 152
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 151
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 176
    if ((int )cstr_info->prog == 1) {
      {
#line 177
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 178
      if (disto_on) {
        {
#line 179
        fprintf(stream, " disto");
        }
      }
      {
#line 180
      fprintf(stream, "\n");
#line 182
      resno = 0;
      }
      {
#line 182
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 182
        if (! (resno < max_numdecompos + 1)) {
#line 182
          goto while_break___8;
        }
#line 183
        layno = 0;
        {
#line 183
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 183
          if (! (layno < cstr_info->numlayers)) {
#line 183
            goto while_break___9;
          }
#line 184
          compno = 0;
          {
#line 184
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 184
            if (! (compno < cstr_info->numcomps)) {
#line 184
              goto while_break___10;
            }
#line 186
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 187
              goto while_break___10;
            }
#line 188
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 189
            precno = 0;
            {
#line 189
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 189
              if (! (precno < prec_max___0)) {
#line 189
                goto while_break___11;
              }
              {
#line 190
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 191
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 192
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 193
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 194
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d", pack_nb, tileno,
                      resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
              }
#line 196
              if (disto_on) {
                {
#line 197
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 198
              fprintf(stream, "\n");
#line 199
              total_disto += disto;
#line 200
              pack_nb ++;
              }
#line 189
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 184
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 183
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 182
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 207
    if ((int )cstr_info->prog == 2) {
      {
#line 209
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 210
      if (disto_on) {
        {
#line 211
        fprintf(stream, " disto");
        }
      }
      {
#line 212
      fprintf(stream, "\n");
#line 214
      resno = 0;
      }
      {
#line 214
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 214
        if (! (resno < max_numdecompos + 1)) {
#line 214
          goto while_break___12;
        }
#line 215
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 216
        precno = 0;
        {
#line 216
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 216
          if (! (precno < numprec)) {
#line 216
            goto while_break___13;
          }
          {
#line 218
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 218
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 219
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          y0___17 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 220
          x1 = x0 + cstr_info->tile_x;
#line 221
          y1___18 = y0___17 + cstr_info->tile_y;
#line 222
          compno = 0;
          }
          {
#line 222
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 222
            if (! (compno < cstr_info->numcomps)) {
#line 222
              goto while_break___14;
            }
            {
#line 223
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 224
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 224
            pcx = (int )__cil_tmp47;
#line 225
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcy = (int )__cil_tmp49;
#line 226
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 226
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 227
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_y = (int )__cil_tmp53;
            }
#line 228
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 229
              goto while_break___14;
            }
#line 230
            y = y0___17;
            {
#line 230
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 230
              if (! (y < y1___18)) {
#line 230
                goto while_break___15;
              }
#line 231
              if (precno_y * pcy == y) {
#line 232
                x = x0;
                {
#line 232
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 232
                  if (! (x < x1)) {
#line 232
                    goto while_break___16;
                  }
#line 233
                  if (precno_x * pcx == x) {
#line 234
                    layno = 0;
                    {
#line 234
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 234
                      if (! (layno < cstr_info->numlayers)) {
#line 234
                        goto while_break___17;
                      }
                      {
#line 235
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 236
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 237
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 238
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 239
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d", pack_nb,
                              tileno, resno, precno, compno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 241
                      if (disto_on) {
                        {
#line 242
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 243
                      fprintf(stream, "\n");
#line 244
                      total_disto += disto;
#line 245
                      pack_nb ++;
                      }
#line 234
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 232
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 230
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 222
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 216
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 214
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 256
    if ((int )cstr_info->prog == 3) {
      {
#line 258
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 258
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 259
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      y0___19 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 260
      x1___0 = x0___0 + cstr_info->tile_x;
#line 261
      y1___20 = y0___19 + cstr_info->tile_y;
#line 264
      max_numprec = 0;
#line 265
      resno = 0;
      }
      {
#line 265
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 265
        if (! (resno < max_numdecompos + 1)) {
#line 265
          goto while_break___18;
        }
#line 266
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 267
        if (numprec___0 > max_numprec) {
#line 268
          max_numprec = numprec___0;
        }
#line 265
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 271
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 272
      if (disto_on) {
        {
#line 273
        fprintf(stream, " disto");
        }
      }
      {
#line 274
      fprintf(stream, "\n");
#line 276
      precno = 0;
      }
      {
#line 276
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 276
        if (! (precno < max_numprec)) {
#line 276
          goto while_break___19;
        }
#line 277
        compno = 0;
        {
#line 277
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 277
          if (! (compno < cstr_info->numcomps)) {
#line 277
            goto while_break___20;
          }
#line 278
          resno = 0;
          {
#line 278
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 278
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 278
              goto while_break___21;
            }
            {
#line 279
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 280
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 281
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 281
            pcx___0 = (int )__cil_tmp73;
#line 282
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcy___0 = (int )__cil_tmp75;
#line 283
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 283
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 284
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_y___0 = (int )__cil_tmp79;
            }
#line 285
            if (precno >= numprec___1) {
#line 286
              goto while_continue___21;
            }
#line 287
            y = y0___19;
            {
#line 287
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 287
              if (! (y < y1___20)) {
#line 287
                goto while_break___22;
              }
#line 288
              if (precno_y___0 * pcy___0 == y) {
#line 289
                x = x0___0;
                {
#line 289
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 289
                  if (! (x < x1___0)) {
#line 289
                    goto while_break___23;
                  }
#line 290
                  if (precno_x___0 * pcx___0 == x) {
#line 291
                    layno = 0;
                    {
#line 291
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 291
                      if (! (layno < cstr_info->numlayers)) {
#line 291
                        goto while_break___24;
                      }
                      {
#line 292
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 293
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 294
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 295
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 296
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, precno, compno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 298
                      if (disto_on) {
                        {
#line 299
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 300
                      fprintf(stream, "\n");
#line 301
                      total_disto += disto;
#line 302
                      pack_nb ++;
                      }
#line 291
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 289
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 287
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 278
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 277
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 276
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 315
      max_numprec___0 = 0;
#line 316
      resno = 0;
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! (resno < max_numdecompos + 1)) {
#line 316
          goto while_break___25;
        }
#line 317
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 318
        if (numprec___2 > max_numprec___0) {
#line 319
          max_numprec___0 = numprec___2;
        }
#line 316
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 322
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 323
      if (disto_on) {
        {
#line 324
        fprintf(stream, " disto");
        }
      }
      {
#line 325
      fprintf(stream, "\n");
#line 327
      compno = 0;
      }
      {
#line 327
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 327
        if (! (compno < cstr_info->numcomps)) {
#line 327
          goto while_break___26;
        }
        {
#line 329
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 329
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 330
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        y0___21 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 331
        x1___1 = x0___1 + cstr_info->tile_x;
#line 332
        y1___22 = y0___21 + cstr_info->tile_y;
#line 334
        precno = 0;
        }
        {
#line 334
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 334
          if (! (precno < max_numprec___0)) {
#line 334
            goto while_break___27;
          }
#line 335
          resno = 0;
          {
#line 335
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 335
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 335
              goto while_break___28;
            }
            {
#line 336
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 337
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 338
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 338
            pcx___1 = (int )__cil_tmp99;
#line 339
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcy___1 = (int )__cil_tmp101;
#line 340
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 340
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 341
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_y___1 = (int )__cil_tmp105;
            }
#line 342
            if (precno >= numprec___3) {
#line 343
              goto while_continue___28;
            }
#line 345
            y = y0___21;
            {
#line 345
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 345
              if (! (y < y1___22)) {
#line 345
                goto while_break___29;
              }
#line 346
              if (precno_y___1 * pcy___1 == y) {
#line 347
                x = x0___1;
                {
#line 347
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 347
                  if (! (x < x1___1)) {
#line 347
                    goto while_break___30;
                  }
#line 348
                  if (precno_x___1 * pcx___1 == x) {
#line 349
                    layno = 0;
                    {
#line 349
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 349
                      if (! (layno < cstr_info->numlayers)) {
#line 349
                        goto while_break___31;
                      }
                      {
#line 350
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 351
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 352
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 353
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 354
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, compno, precno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 356
                      if (disto_on) {
                        {
#line 357
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 358
                      fprintf(stream, "\n");
#line 359
                      total_disto += disto;
#line 360
                      pack_nb ++;
                      }
#line 349
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 347
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 345
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 335
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 334
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 327
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 122
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  if (disto_on) {
    {
#line 373
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 374
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 378
  if (cstr_info->marknum) {
    {
#line 379
    fprintf(stream, "\nMARKER LIST\n");
#line 380
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 381
    fprintf(stream, "type\tstart_pos    length\n");
#line 382
    x = 0;
    }
    {
#line 382
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 382
      if (! (x < cstr_info->marknum)) {
#line 382
        goto while_break___32;
      }
      {
#line 383
      fprintf(stream, "%X\t%9d %9d\n", (int )(cstr_info->marker + x)->type, (cstr_info->marker + x)->pos,
              (cstr_info->marker + x)->len);
      }
#line 382
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 386
  fclose(stream);
#line 388
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 390
  return (0);
}
}
#line 56 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int int_floorlog2___20(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 124
    free(tga);
    }
#line 125
    return (0);
  }
  {
#line 127
  id_len = (unsigned char )*(tga + 0);
#line 128
  cmap_type = (unsigned char )*(tga + 1);
#line 130
  image_type = (unsigned char )*(tga + 2);
#line 131
  cmap_index = get_ushort(*((unsigned short *)(tga + 3)));
#line 133
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 134
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 137
  x_origin = get_ushort(*((unsigned short *)(tga + 8)));
#line 139
  y_origin = get_ushort(*((unsigned short *)(tga + 10)));
#line 141
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 142
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 143
  pixel_depth = (unsigned char )*(tga + 16);
#line 144
  image_desc = (unsigned char )*(tga + 17);
#line 146
  free(tga);
#line 148
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 149
  *width = (unsigned int )image_w;
#line 150
  *height = (unsigned int )image_h;
  }
#line 153
  if (id_len) {
    {
#line 155
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 155
    id = (unsigned char *)__cil_tmp29;
#line 156
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 156
    if (! __cil_tmp30) {
      {
#line 158
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 159
      free(id);
      }
#line 160
      return (0);
    }
    {
#line 162
    free(id);
    }
  }
#line 168
  if ((int )image_type > 8) {
    {
#line 170
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 171
    return (0);
  }
#line 174
  *flip_image = ! ((int )image_desc & 32);
#line 177
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 179
  if (palette_size > 0) {
    {
#line 181
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 182
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 184
  return (1);
}
}
#line 197 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 204
  if (! bits_per_pixel) {
#line 205
    return (0);
  } else
#line 204
  if (! width) {
#line 205
    return (0);
  } else
#line 204
  if (! height) {
#line 205
    return (0);
  }
#line 207
  pixel_depth = (unsigned char )0;
#line 209
  if (bits_per_pixel < 256) {
#line 210
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 212
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerV");
    }
#line 213
    return (0);
  }
  {
#line 215
  uc0 = (unsigned char )0;
#line 217
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 217
  if (__cil_tmp13 != 1UL) {
#line 217
    goto fails;
  }
  {
#line 218
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 218
  if (__cil_tmp14 != 1UL) {
#line 218
    goto fails;
  }
  {
#line 220
  image_type = (unsigned char )2;
#line 221
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp15 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  us0 = (unsigned short )0;
#line 224
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp16 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 225
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 225
  if (__cil_tmp17 != 1UL) {
#line 225
    goto fails;
  }
  {
#line 226
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 226
  if (__cil_tmp18 != 1UL) {
#line 226
    goto fails;
  }
  {
#line 228
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 228
  if (__cil_tmp19 != 1UL) {
#line 228
    goto fails;
  }
  {
#line 229
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 229
  if (__cil_tmp20 != 1UL) {
#line 229
    goto fails;
  }
  {
#line 231
  image_w = (unsigned short )width;
#line 232
  image_h = (unsigned short )height;
#line 235
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 235
  if (__cil_tmp21 != 1UL) {
#line 235
    goto fails;
  }
  {
#line 236
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 236
  if (__cil_tmp22 != 1UL) {
#line 236
    goto fails;
  }
  {
#line 244
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 244
  if (__cil_tmp23 != 1UL) {
#line 244
    goto fails;
  }
#line 246
  image_desc = (unsigned char )8;
#line 248
  if (flip_image) {
#line 249
    image_desc |= 32;
  }
  {
#line 250
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 250
  if (__cil_tmp24 != 1UL) {
#line 250
    goto fails;
  }
#line 252
  return (1);
  fails: 
  {
#line 255
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 256
  return (0);
}
}
#line 259 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  opj_bool mono ;
  opj_bool save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;
  opj_image_t *__cil_tmp24 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int index___23 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
  {
#line 264
  flip_image = 0;
#line 273
  f = fopen(filename, "rb\304U\006V");
  }
#line 274
  if (! f) {
    {
#line 275
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
    }
#line 276
    return ((opj_image_t *)0);
  }
  {
#line 279
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 279
  if (! __cil_tmp20) {
    {
#line 280
    fclose(f);
    }
#line 281
    return ((opj_image_t *)((void *)0));
  }
#line 285
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
    {
#line 286
    fclose(f);
    }
#line 287
    return ((opj_image_t *)((void *)0));
  }
  {
#line 291
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 293
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 294
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 296
  if (mono) {
#line 297
    color_space = (OPJ_COLOR_SPACE )2;
#line 298
    if (save_alpha) {
#line 298
      tmp = 2;
    } else {
#line 298
      tmp = 1;
    }
#line 298
    numcomps = tmp;
  } else {
#line 301
    if (save_alpha) {
#line 301
      tmp___0 = 4;
    } else {
#line 301
      tmp___0 = 3;
    }
#line 301
    numcomps = tmp___0;
#line 302
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 305
  subsampling_dx = parameters->subsampling_dx;
#line 306
  subsampling_dy = parameters->subsampling_dy;
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < numcomps)) {
#line 308
      goto while_break;
    }
#line 309
    cmptparm[i].prec = 8;
#line 310
    cmptparm[i].bpp = 8;
#line 311
    cmptparm[i].sgnd = 0;
#line 312
    cmptparm[i].dx = subsampling_dx;
#line 313
    cmptparm[i].dy = subsampling_dy;
#line 314
    cmptparm[i].w = (int )image_width;
#line 315
    cmptparm[i].h = (int )image_height;
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 321
  if (! image) {
    {
#line 322
    fclose(f);
    }
#line 323
    return ((opj_image_t *)((void *)0));
  }
#line 327
  image->x0 = parameters->image_offset_x0;
#line 328
  image->y0 = parameters->image_offset_y0;
#line 329
  if (! image->x0) {
#line 329
    tmp___1 = (image_width - 1U) * (unsigned int )subsampling_dx + 1U;
  } else {
#line 329
    tmp___1 = ((unsigned int )image->x0 + (image_width - 1U) * (unsigned int )subsampling_dx) + 1U;
  }
#line 329
  image->x1 = (int )tmp___1;
#line 330
  if (! image->y0) {
#line 330
    tmp___2 = (image_height - 1U) * (unsigned int )subsampling_dy + 1U;
  } else {
#line 330
    tmp___2 = ((unsigned int )image->y0 + (image_height - 1U) * (unsigned int )subsampling_dy) + 1U;
  }
#line 330
  image->y1 = (int )tmp___2;
#line 333
  y = (unsigned int )0;
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 333
    if (! (y < image_height)) {
#line 333
      goto while_break___0;
    }
#line 337
    if (flip_image) {
#line 338
      index___23 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 340
      index___23 = (int )(y * image_width);
    }
#line 342
    if (numcomps == 3) {
#line 344
      x = (unsigned int )0;
      {
#line 344
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 344
        if (! (x < image_width)) {
#line 344
          goto while_break___1;
        }
        {
#line 348
        __cil_tmp31 = fread(& b, (unsigned long )1, (unsigned long )1, f);
        }
#line 348
        if (! __cil_tmp31) {
          {
#line 350
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 351
          opj_image_destroy(image);
#line 352
          fclose(f);
          }
#line 353
          return ((opj_image_t *)((void *)0));
        }
        {
#line 355
        __cil_tmp32 = fread(& g, (unsigned long )1, (unsigned long )1, f);
        }
#line 355
        if (! __cil_tmp32) {
          {
#line 357
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 358
          opj_image_destroy(image);
#line 359
          fclose(f);
          }
#line 360
          return ((opj_image_t *)((void *)0));
        }
        {
#line 362
        __cil_tmp33 = fread(& r, (unsigned long )1, (unsigned long )1, f);
        }
#line 362
        if (! __cil_tmp33) {
          {
#line 364
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 365
          opj_image_destroy(image);
#line 366
          fclose(f);
          }
#line 367
          return ((opj_image_t *)((void *)0));
        }
#line 370
        *((image->comps + 0)->data + index___23) = (int )r;
#line 371
        *((image->comps + 1)->data + index___23) = (int )g;
#line 372
        *((image->comps + 2)->data + index___23) = (int )b;
#line 373
        index___23 ++;
#line 344
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 376
    if (numcomps == 4) {
#line 378
      x = (unsigned int )0;
      {
#line 378
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 378
        if (! (x < image_width)) {
#line 378
          goto while_break___2;
        }
        {
#line 381
        __cil_tmp40 = fread(& b___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 381
        if (! __cil_tmp40) {
          {
#line 383
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 384
          opj_image_destroy(image);
#line 385
          fclose(f);
          }
#line 386
          return ((opj_image_t *)((void *)0));
        }
        {
#line 388
        __cil_tmp41 = fread(& g___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 388
        if (! __cil_tmp41) {
          {
#line 390
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 391
          opj_image_destroy(image);
#line 392
          fclose(f);
          }
#line 393
          return ((opj_image_t *)((void *)0));
        }
        {
#line 395
        __cil_tmp42 = fread(& r___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 395
        if (! __cil_tmp42) {
          {
#line 397
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 398
          opj_image_destroy(image);
#line 399
          fclose(f);
          }
#line 400
          return ((opj_image_t *)((void *)0));
        }
        {
#line 402
        __cil_tmp43 = fread(& a, (unsigned long )1, (unsigned long )1, f);
        }
#line 402
        if (! __cil_tmp43) {
          {
#line 404
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 405
          opj_image_destroy(image);
#line 406
          fclose(f);
          }
#line 407
          return ((opj_image_t *)((void *)0));
        }
#line 410
        *((image->comps + 0)->data + index___23) = (int )r___0;
#line 411
        *((image->comps + 1)->data + index___23) = (int )g___0;
#line 412
        *((image->comps + 2)->data + index___23) = (int )b___0;
#line 413
        *((image->comps + 3)->data + index___23) = (int )a;
#line 414
        index___23 ++;
#line 378
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 418
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 333
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 421
  fclose(f);
  }
#line 422
  return (image);
}
}
#line 425 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  opj_bool write_alpha ;
  int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  FILE *__cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___24 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
  {
#line 436
  fdest = fopen(outfile, "wb");
  }
#line 437
  if (! fdest) {
    {
#line 438
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 439
    return (1);
  }
#line 442
  i = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (i < image->numcomps - 1)) {
#line 442
      goto while_break;
    }
#line 443
    if ((image->comps + 0)->dx != (image->comps + (i + 1))->dx) {
      {
      {
      {
#line 446
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      {
      {
#line 447
      fclose(fdest);
      }
      }
      }
#line 448
      return (1);
    } else
#line 443
    if ((image->comps + 0)->dy != (image->comps + (i + 1))->dy) {
      {
      {
      {
#line 446
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      {
      {
#line 447
      fclose(fdest);
      }
      }
      }
#line 448
      return (1);
    } else
#line 443
    if ((image->comps + 0)->prec != (image->comps + (i + 1))->prec) {
      {
      {
      {
#line 446
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      {
      {
#line 447
      fclose(fdest);
      }
      }
      }
#line 448
      return (1);
    }
#line 442
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  width = (image->comps + 0)->w;
#line 453
  height = (image->comps + 0)->h;
#line 456
  write_alpha = image->numcomps == 2 || image->numcomps == 4;
#line 459
  if (write_alpha) {
#line 459
    tmp = 32;
  } else {
#line 459
    tmp = 24;
  }
  {
#line 459
  bpp = tmp;
#line 460
  __cil_tmp25 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 460
  if (! __cil_tmp25) {
    {
#line 461
    fclose(fdest);
    }
#line 462
    return (1);
  }
#line 465
  alpha_channel = (unsigned int )(image->numcomps - 1);
#line 467
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 469
  if ((image->comps + 0)->sgnd) {
#line 469
    tmp___0 = 1 << ((image->comps + 0)->prec - 1);
  } else {
#line 469
    tmp___0 = 0;
  }
#line 469
  adjustR = tmp___0;
#line 470
  if ((image->comps + 1)->sgnd) {
#line 470
    tmp___1 = 1 << ((image->comps + 1)->prec - 1);
  } else {
#line 470
    tmp___1 = 0;
  }
#line 470
  adjustG = tmp___1;
#line 471
  if ((image->comps + 2)->sgnd) {
#line 471
    tmp___2 = 1 << ((image->comps + 2)->prec - 1);
  } else {
#line 471
    tmp___2 = 0;
  }
#line 471
  adjustB = tmp___2;
#line 473
  y = 0;
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! (y < height)) {
#line 473
      goto while_break___0;
    }
#line 474
    index___24 = (unsigned int )(y * width);
#line 476
    x = 0;
    {
#line 476
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 476
      if (! (x < width)) {
#line 476
        goto while_break___1;
      }
#line 477
      r = (float )(*((image->comps + 0)->data + index___24) + adjustR);
#line 479
      if (image->numcomps > 2) {
#line 480
        g = (float )(*((image->comps + 1)->data + index___24) + adjustG);
#line 481
        b = (float )(*((image->comps + 2)->data + index___24) + adjustB);
      } else {
#line 484
        g = r;
#line 485
        b = r;
      }
      {
#line 489
      value = (unsigned char )(b * scale);
#line 490
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 491
      if (res < 1UL) {
        {
#line 492
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 493
        fclose(fdest);
        }
#line 494
        return (1);
      }
      {
#line 497
      value = (unsigned char )(g * scale);
#line 498
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 499
      if (res < 1UL) {
        {
#line 500
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 501
        fclose(fdest);
        }
#line 502
        return (1);
      }
      {
#line 505
      value = (unsigned char )(r * scale);
#line 506
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 507
      if (res < 1UL) {
        {
#line 508
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 509
        fclose(fdest);
        }
#line 510
        return (1);
      }
#line 513
      if (write_alpha) {
        {
#line 514
        a = (float )*((image->comps + alpha_channel)->data + index___24);
#line 515
        value = (unsigned char )(a * scale);
#line 516
        res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 517
        if (res < 1UL) {
          {
#line 518
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 519
          fclose(fdest);
          }
#line 520
          return (1);
        }
      }
#line 476
      __cil_tmp35 = index___24;
#line 476
      index___24 ++;
#line 476
      __cil_tmp34 = x;
#line 476
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 473
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 526
  fclose(fdest);
  }
#line 527
  return (0);
}
}
#line 572 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static void BMP_read_RGB8(int *red , int *green , int *blue , unsigned int line ,
                          BITMAPINFOHEADER_t *hdr , struct bmp_cmap bmap[256] , FILE *reader ,
                          unsigned int offset ) 
{ 
  unsigned int w ;
  unsigned int start_pos ;
  unsigned int y ;
  unsigned int x ;
  unsigned int pixel ;
  unsigned int i ;
  int __cil_tmp15 ;

  {
  {
#line 577
  i = (unsigned int )0;
#line 579
  w = hdr->biWidth;
#line 581
  start_pos = ((w * (unsigned int )hdr->biBitCount + 31U) & 4294967264U) >> 3;
#line 582
  y = (hdr->biHeight - line) - 1U;
#line 583
  fseek(reader, (long )(offset + y * start_pos), 0);
#line 585
  x = (unsigned int )0;
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (x < w)) {
#line 585
      goto while_break;
    }
    {
#line 587
    __cil_tmp15 = fgetc(reader);
#line 587
    pixel = (unsigned int )__cil_tmp15;
#line 588
    *(red + i) = (int )((unsigned char )bmap[pixel].red);
#line 589
    *(green + i) = (int )((unsigned char )bmap[pixel].green);
#line 590
    *(blue + i) = (int )((unsigned char )bmap[pixel].blue);
#line 591
    i ++;
    }
#line 585
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 595 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  int x ;
  int y ;
  int index___25 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  FILE *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  opj_image_t *__cil_tmp84 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  struct bmp_cmap cmap[256] ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  unsigned int __cil_tmp99 ;
  int __cil_tmp100 ;
  opj_image_t *__cil_tmp101 ;
  int tmp___2 ;
  int tmp___3 ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int offset ;
  int line ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red___0 ;
  int *green___0 ;
  int *blue___0 ;
  unsigned int x___26 ;
  unsigned int y___27 ;
  unsigned int max ;
  int i___28 ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  unsigned int __cil_tmp128 ;
  int tmp___4 ;
  int tmp___5 ;
  int __cil_tmp131 ;
  opj_image_t *__cil_tmp132 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp135 ;
  int __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  unsigned int __cil_tmp139 ;
  unsigned char *__cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  unsigned char *__cil_tmp147 ;
  unsigned int __cil_tmp148 ;
  unsigned char *__cil_tmp149 ;
  int *__cil_tmp150 ;
  unsigned int __cil_tmp151 ;
  unsigned char *__cil_tmp152 ;
  int *__cil_tmp153 ;
  int *__cil_tmp154 ;
  int *__cil_tmp155 ;

  {
  {
#line 597
  subsampling_dx = parameters->subsampling_dx;
#line 598
  subsampling_dy = parameters->subsampling_dy;
#line 603
  image = (opj_image_t *)((void *)0);
#line 610
  PAD = (unsigned int )0;
#line 613
  gray_scale = 1;
#line 617
  IN = fopen(filename, "rb");
  }
#line 618
  if (! IN) {
    {
#line 620
    fprintf(stderr, "Failed to open %s for reading !!\n\374\304U\006V", filename);
    }
#line 621
    return ((opj_image_t *)((void *)0));
  }
  {
#line 624
  __cil_tmp29 = getc(IN);
#line 624
  File_h.bfType = (WORD )__cil_tmp29;
#line 625
  __cil_tmp30 = getc(IN);
#line 625
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 627
  if ((int )File_h.bfType != 19778) {
    {
#line 629
    fprintf(stderr, "Error, not a BMP file!\n");
#line 630
    fclose(IN);
    }
#line 631
    return ((opj_image_t *)((void *)0));
  }
  {
#line 635
  __cil_tmp31 = getc(IN);
#line 635
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 636
  __cil_tmp32 = getc(IN);
#line 636
  File_h.bfSize = (unsigned int )(__cil_tmp32 << 8) + File_h.bfSize;
#line 637
  __cil_tmp33 = getc(IN);
#line 637
  File_h.bfSize = (unsigned int )(__cil_tmp33 << 16) + File_h.bfSize;
#line 638
  __cil_tmp34 = getc(IN);
#line 638
  File_h.bfSize = (unsigned int )(__cil_tmp34 << 24) + File_h.bfSize;
#line 640
  __cil_tmp35 = getc(IN);
#line 640
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 641
  __cil_tmp36 = getc(IN);
#line 641
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 643
  __cil_tmp37 = getc(IN);
#line 643
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 644
  __cil_tmp38 = getc(IN);
#line 644
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 646
  __cil_tmp39 = getc(IN);
#line 646
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 647
  __cil_tmp40 = getc(IN);
#line 647
  File_h.bfOffBits = (unsigned int )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 648
  __cil_tmp41 = getc(IN);
#line 648
  File_h.bfOffBits = (unsigned int )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 649
  __cil_tmp42 = getc(IN);
#line 649
  File_h.bfOffBits = (unsigned int )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 654
  __cil_tmp43 = getc(IN);
#line 654
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 655
  __cil_tmp44 = getc(IN);
#line 655
  Info_h.biSize = (unsigned int )(__cil_tmp44 << 8) + Info_h.biSize;
#line 656
  __cil_tmp45 = getc(IN);
#line 656
  Info_h.biSize = (unsigned int )(__cil_tmp45 << 16) + Info_h.biSize;
#line 657
  __cil_tmp46 = getc(IN);
#line 657
  Info_h.biSize = (unsigned int )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 659
  if (Info_h.biSize != 40U) {
    {
#line 661
    fprintf(stderr, "Error, unknown BMP header size %d\n", Info_h.biSize);
#line 662
    fclose(IN);
    }
#line 663
    return ((opj_image_t *)((void *)0));
  }
  {
#line 665
  __cil_tmp47 = getc(IN);
#line 665
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 666
  __cil_tmp48 = getc(IN);
#line 666
  Info_h.biWidth = (unsigned int )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 667
  __cil_tmp49 = getc(IN);
#line 667
  Info_h.biWidth = (unsigned int )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 668
  __cil_tmp50 = getc(IN);
#line 668
  Info_h.biWidth = (unsigned int )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 669
  w = (int )Info_h.biWidth;
#line 671
  __cil_tmp51 = getc(IN);
#line 671
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 672
  __cil_tmp52 = getc(IN);
#line 672
  Info_h.biHeight = (unsigned int )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 673
  __cil_tmp53 = getc(IN);
#line 673
  Info_h.biHeight = (unsigned int )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 674
  __cil_tmp54 = getc(IN);
#line 674
  Info_h.biHeight = (unsigned int )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 675
  h = (int )Info_h.biHeight;
#line 677
  __cil_tmp55 = getc(IN);
#line 677
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 678
  __cil_tmp56 = getc(IN);
#line 678
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 680
  __cil_tmp57 = getc(IN);
#line 680
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 681
  __cil_tmp58 = getc(IN);
#line 681
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 683
  __cil_tmp59 = getc(IN);
#line 683
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 684
  __cil_tmp60 = getc(IN);
#line 684
  Info_h.biCompression = (unsigned int )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 685
  __cil_tmp61 = getc(IN);
#line 685
  Info_h.biCompression = (unsigned int )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 686
  __cil_tmp62 = getc(IN);
#line 686
  Info_h.biCompression = (unsigned int )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 688
  __cil_tmp63 = getc(IN);
#line 688
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 689
  __cil_tmp64 = getc(IN);
#line 689
  Info_h.biSizeImage = (unsigned int )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 690
  __cil_tmp65 = getc(IN);
#line 690
  Info_h.biSizeImage = (unsigned int )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 691
  __cil_tmp66 = getc(IN);
#line 691
  Info_h.biSizeImage = (unsigned int )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 693
  __cil_tmp67 = getc(IN);
#line 693
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 694
  __cil_tmp68 = getc(IN);
#line 694
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 695
  __cil_tmp69 = getc(IN);
#line 695
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 696
  __cil_tmp70 = getc(IN);
#line 696
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 698
  __cil_tmp71 = getc(IN);
#line 698
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 699
  __cil_tmp72 = getc(IN);
#line 699
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 700
  __cil_tmp73 = getc(IN);
#line 700
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 701
  __cil_tmp74 = getc(IN);
#line 701
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 703
  __cil_tmp75 = getc(IN);
#line 703
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 704
  __cil_tmp76 = getc(IN);
#line 704
  Info_h.biClrUsed = (unsigned int )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 705
  __cil_tmp77 = getc(IN);
#line 705
  Info_h.biClrUsed = (unsigned int )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 706
  __cil_tmp78 = getc(IN);
#line 706
  Info_h.biClrUsed = (unsigned int )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 708
  __cil_tmp79 = getc(IN);
#line 708
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 709
  __cil_tmp80 = getc(IN);
#line 709
  Info_h.biClrImportant = (unsigned int )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 710
  __cil_tmp81 = getc(IN);
#line 710
  Info_h.biClrImportant = (unsigned int )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 711
  __cil_tmp82 = getc(IN);
#line 711
  Info_h.biClrImportant = (unsigned int )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 715
  if ((int )Info_h.biBitCount == 24) {
    {
#line 717
    numcomps = 3;
#line 718
    color_space = (OPJ_COLOR_SPACE )1;
#line 720
    memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 721
    i = 0;
    }
    {
#line 721
    while (1) {
      while_continue: /* CIL Label */ ;
#line 721
      if (! (i < numcomps)) {
#line 721
        goto while_break;
      }
#line 723
      cmptparm[i].prec = 8;
#line 724
      cmptparm[i].bpp = 8;
#line 725
      cmptparm[i].sgnd = 0;
#line 726
      cmptparm[i].dx = subsampling_dx;
#line 727
      cmptparm[i].dy = subsampling_dy;
#line 728
      cmptparm[i].w = w;
#line 729
      cmptparm[i].h = h;
#line 721
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 732
    image = opj_image_create(numcomps, & cmptparm[0], color_space);
    }
#line 733
    if (! image) {
      {
#line 735
      fclose(IN);
      }
#line 736
      return ((opj_image_t *)((void *)0));
    }
#line 740
    image->x0 = parameters->image_offset_x0;
#line 741
    image->y0 = parameters->image_offset_y0;
#line 742
    if (! image->x0) {
#line 742
      tmp = (w - 1) * subsampling_dx + 1;
    } else {
#line 742
      tmp = (image->x0 + (w - 1) * subsampling_dx) + 1;
    }
#line 742
    image->x1 = tmp;
#line 743
    if (! image->y0) {
#line 743
      tmp___0 = (h - 1) * subsampling_dy + 1;
    } else {
#line 743
      tmp___0 = (image->y0 + (h - 1) * subsampling_dy) + 1;
    }
    {
#line 743
    image->y1 = tmp___0;
#line 748
    fseek(IN, (long )0, 0);
#line 749
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 751
    W = Info_h.biWidth;
#line 752
    H = Info_h.biHeight;
    }
#line 756
    if ((3U * W) % 4U) {
#line 756
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 756
      tmp___1 = (unsigned int )0;
    }
    {
#line 756
    PAD = tmp___1;
#line 758
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 758
    RGB = (unsigned char *)__cil_tmp88;
#line 761
    __cil_tmp89 = fread(RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 761
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 763
      free(RGB);
#line 764
      opj_image_destroy(image);
#line 765
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 766
      return ((opj_image_t *)((void *)0));
    }
#line 769
    index___25 = 0;
#line 771
    y = 0;
    {
#line 771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 771
      if (! (y < (int )H)) {
#line 771
        goto while_break___0;
      }
#line 773
      scanline = RGB + (3U * W + PAD) * ((H - 1U) - (unsigned int )y);
#line 774
      x = 0;
      {
#line 774
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 774
        if (! (x < (int )W)) {
#line 774
          goto while_break___1;
        }
#line 776
        pixel = scanline + 3 * x;
#line 777
        *((image->comps + 0)->data + index___25) = (int )*(pixel + 2);
#line 778
        *((image->comps + 1)->data + index___25) = (int )*(pixel + 1);
#line 779
        *((image->comps + 2)->data + index___25) = (int )*(pixel + 0);
#line 780
        index___25 ++;
#line 774
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 771
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 783
    free(RGB);
    }
  } else
#line 786
  if ((int )Info_h.biBitCount == 8) {
#line 786
    if (Info_h.biCompression == 0U) {
#line 790
      if (Info_h.biClrUsed == 0U) {
#line 790
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 792
      if (Info_h.biClrUsed > 256U) {
#line 792
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 794
      fseek(IN, (long )(14U + Info_h.biSize), 0);
#line 795
      memset(& cmap, 0, sizeof(struct bmp_cmap ) * 256UL);
#line 797
      j = (unsigned int )0;
      }
      {
#line 797
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 797
        if (! (j < Info_h.biClrUsed)) {
#line 797
          goto while_break___2;
        }
        {
#line 799
        __cil_tmp96 = getc(IN);
#line 799
        cmap[j].blue = (unsigned char )__cil_tmp96;
#line 800
        __cil_tmp97 = getc(IN);
#line 800
        cmap[j].green = (unsigned char )__cil_tmp97;
#line 801
        __cil_tmp98 = getc(IN);
#line 801
        cmap[j].red = (unsigned char )__cil_tmp98;
#line 802
        getc(IN);
        }
#line 797
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 804
      numcomps = 3;
#line 805
      color_space = (OPJ_COLOR_SPACE )1;
#line 807
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 808
      i = 0;
      }
      {
#line 808
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 808
        if (! (i < numcomps)) {
#line 808
          goto while_break___3;
        }
#line 810
        cmptparm[i].prec = 8;
#line 811
        cmptparm[i].bpp = 8;
#line 812
        cmptparm[i].sgnd = 0;
#line 813
        cmptparm[i].dx = subsampling_dx;
#line 814
        cmptparm[i].dy = subsampling_dy;
#line 815
        cmptparm[i].w = w;
#line 816
        cmptparm[i].h = h;
#line 808
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 819
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 820
      if (! image) {
        {
#line 822
        fclose(IN);
        }
#line 823
        return ((opj_image_t *)((void *)0));
      }
#line 827
      image->x0 = parameters->image_offset_x0;
#line 828
      image->y0 = parameters->image_offset_y0;
#line 829
      if (! image->x0) {
#line 829
        tmp___2 = (w - 1) * subsampling_dx + 1;
      } else {
#line 829
        tmp___2 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 829
      image->x1 = tmp___2;
#line 830
      if (! image->y0) {
#line 830
        tmp___3 = (h - 1) * subsampling_dy + 1;
      } else {
#line 830
        tmp___3 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
#line 830
      image->y1 = tmp___3;
#line 833
      red = (image->comps + 0)->data;
#line 834
      green = (image->comps + 1)->data;
#line 835
      blue = (image->comps + 2)->data;
#line 836
      offset = File_h.bfOffBits;
#line 840
      line = 0;
      {
#line 840
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 840
        if (! (line < h)) {
#line 840
          goto while_break___4;
        }
        {
#line 842
        BMP_read_RGB8(red, green, blue, (unsigned int )line, & Info_h, (struct bmp_cmap *)cmap,
                      IN, offset);
#line 844
        red += w;
#line 844
        green += w;
#line 844
        blue += w;
        }
#line 840
        line ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 786
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 849
  if ((int )Info_h.biBitCount == 8) {
#line 849
    if (Info_h.biCompression == 1U) {
#line 857
      if (Info_h.biClrUsed == 0U) {
#line 858
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 859
      if (Info_h.biClrUsed > 256U) {
#line 860
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 862
      __cil_tmp122 = malloc(256UL * sizeof(unsigned char ));
#line 862
      table_R = (unsigned char *)__cil_tmp122;
#line 863
      __cil_tmp123 = malloc(256UL * sizeof(unsigned char ));
#line 863
      table_G = (unsigned char *)__cil_tmp123;
#line 864
      __cil_tmp124 = malloc(256UL * sizeof(unsigned char ));
#line 864
      table_B = (unsigned char *)__cil_tmp124;
#line 866
      has_color = 0;
#line 867
      j = (unsigned int )0;
      }
      {
#line 867
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 867
        if (! (j < Info_h.biClrUsed)) {
#line 867
          goto while_break___5;
        }
        {
#line 869
        __cil_tmp125 = getc(IN);
#line 869
        *(table_B + j) = (unsigned char )__cil_tmp125;
#line 870
        __cil_tmp126 = getc(IN);
#line 870
        *(table_G + j) = (unsigned char )__cil_tmp126;
#line 871
        __cil_tmp127 = getc(IN);
#line 871
        *(table_R + j) = (unsigned char )__cil_tmp127;
#line 872
        getc(IN);
#line 873
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 867
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 876
      if (has_color) {
#line 877
        gray_scale = 0;
      }
#line 879
      if (gray_scale) {
#line 879
        tmp___4 = 1;
      } else {
#line 879
        tmp___4 = 3;
      }
#line 879
      numcomps = tmp___4;
#line 880
      if (gray_scale) {
#line 880
        tmp___5 = 2;
      } else {
#line 880
        tmp___5 = 1;
      }
      {
#line 880
      color_space = (OPJ_COLOR_SPACE )tmp___5;
#line 882
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 883
      i___28 = 0;
      }
      {
#line 883
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 883
        if (! (i___28 < numcomps)) {
#line 883
          goto while_break___6;
        }
#line 885
        cmptparm[i___28].prec = 8;
#line 886
        cmptparm[i___28].bpp = 8;
#line 887
        cmptparm[i___28].sgnd = 0;
#line 888
        cmptparm[i___28].dx = subsampling_dx;
#line 889
        cmptparm[i___28].dy = subsampling_dy;
#line 890
        cmptparm[i___28].w = w;
#line 891
        cmptparm[i___28].h = h;
#line 883
        i___28 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 894
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 895
      if (! image) {
        {
#line 897
        fclose(IN);
#line 898
        free(table_R);
#line 899
        free(table_G);
#line 900
        free(table_B);
        }
#line 901
        return ((opj_image_t *)((void *)0));
      }
#line 905
      image->x0 = parameters->image_offset_x0;
#line 906
      image->y0 = parameters->image_offset_y0;
#line 907
      if (! image->x0) {
#line 907
        tmp___6 = (w - 1) * subsampling_dx + 1;
      } else {
#line 907
        tmp___6 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 907
      image->x1 = tmp___6;
#line 909
      if (! image->y0) {
#line 909
        tmp___7 = (h - 1) * subsampling_dy + 1;
      } else {
#line 909
        tmp___7 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 909
      image->y1 = tmp___7;
#line 915
      fseek(IN, (long )0, 0);
#line 916
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 918
      W = Info_h.biWidth;
#line 919
      H = Info_h.biHeight;
#line 920
      __cil_tmp135 = calloc((unsigned long )1, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 920
      RGB = (unsigned char *)__cil_tmp135;
#line 921
      beyond = RGB + W * H;
#line 922
      pix = beyond - W;
#line 923
      y___27 = (unsigned int )0;
#line 923
      x___26 = y___27;
      }
      {
#line 925
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 925
        if (! (y___27 < H)) {
#line 925
          goto while_break___7;
        }
        {
#line 927
        c = getc(IN);
        }
#line 929
        if (c) {
          {
#line 931
          c1 = getc(IN);
#line 933
          i___28 = 0;
          }
          {
#line 933
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 933
            if (! (pix < beyond && (i___28 < c && x___26 < W))) {
#line 933
              goto while_break___8;
            }
#line 934
            *pix = (unsigned char )c1;
#line 933
            __cil_tmp140 = pix;
#line 933
            pix ++;
#line 933
            __cil_tmp139 = x___26;
#line 933
            x___26 ++;
#line 933
            __cil_tmp138 = i___28;
#line 933
            i___28 ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
#line 938
          c = getc(IN);
          }
#line 940
          if (c == 0) {
#line 942
            x___26 = (unsigned int )0;
#line 943
            y___27 ++;
#line 944
            pix = (RGB + x___26) + ((H - y___27) - 1U) * W;
          } else
#line 946
          if (c == 1) {
#line 947
            goto while_break___7;
          } else
#line 948
          if (c == 2) {
            {
#line 950
            c = getc(IN);
#line 951
            x___26 += (unsigned int )c;
#line 952
            c = getc(IN);
#line 953
            y___27 += (unsigned int )c;
#line 954
            pix = (RGB + ((H - y___27) - 1U) * W) + x___26;
            }
          } else {
#line 958
            i___28 = 0;
            {
#line 959
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 959
              if (! (pix < beyond && (i___28 < c && x___26 < W))) {
#line 959
                goto while_break___9;
              }
              {
#line 961
              c1 = getc(IN);
#line 962
              *pix = (unsigned char )c1;
              }
#line 959
              __cil_tmp147 = pix;
#line 959
              pix ++;
#line 959
              __cil_tmp146 = x___26;
#line 959
              x___26 ++;
#line 959
              __cil_tmp145 = i___28;
#line 959
              i___28 ++;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 964
            if (c & 1) {
              {
#line 965
              getc(IN);
              }
            }
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 970
      if (gray_scale) {
#line 972
        gray = (image->comps + 0)->data;
#line 973
        pix = RGB;
#line 974
        max = W * H;
        {
#line 976
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 976
          __cil_tmp148 = max;
#line 976
          max --;
#line 976
          if (! __cil_tmp148) {
#line 976
            goto while_break___10;
          }
#line 978
          __cil_tmp149 = pix;
#line 978
          pix ++;
#line 978
          uc = *__cil_tmp149;
#line 980
          __cil_tmp150 = gray;
#line 980
          gray ++;
#line 980
          *__cil_tmp150 = (int )*(table_R + uc);
        }
        while_break___10: /* CIL Label */ ;
        }
      } else {
#line 987
        red___0 = (image->comps + 0)->data;
#line 988
        green___0 = (image->comps + 1)->data;
#line 989
        blue___0 = (image->comps + 2)->data;
#line 990
        pix = RGB;
#line 991
        max = W * H;
        {
#line 993
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 993
          __cil_tmp151 = max;
#line 993
          max --;
#line 993
          if (! __cil_tmp151) {
#line 993
            goto while_break___11;
          }
#line 995
          __cil_tmp152 = pix;
#line 995
          pix ++;
#line 995
          uc = *__cil_tmp152;
#line 997
          __cil_tmp153 = red___0;
#line 997
          red___0 ++;
#line 997
          *__cil_tmp153 = (int )*(table_R + uc);
#line 998
          __cil_tmp154 = green___0;
#line 998
          green___0 ++;
#line 998
          *__cil_tmp154 = (int )*(table_G + uc);
#line 999
          __cil_tmp155 = blue___0;
#line 999
          blue___0 ++;
#line 999
          *__cil_tmp155 = (int )*(table_B + uc);
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      {
#line 1002
      free(RGB);
#line 1003
      free(table_R);
#line 1004
      free(table_G);
#line 1005
      free(table_B);
      }
    } else {
      {
      {
#line 1009
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
  } else {
    {
    {
#line 1009
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
    }
  }
  {
#line 1013
  fclose(IN);
  }
#line 1014
  return (image);
}
}
#line 1017 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 1020
  fdest = (FILE *)((void *)0);
#line 1023
  if ((image->comps + 0)->prec < 8) {
    {
#line 1024
    fprintf(stderr, "Unsupported precision: %d\n", (image->comps + 0)->prec);
    }
#line 1025
    return (1);
  }
#line 1027
  if (image->numcomps >= 3) {
#line 1027
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1027
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1027
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1027
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1027
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1027
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1038
                fdest = fopen(outfile, "wb");
                }
#line 1039
                if (! fdest) {
                  {
#line 1040
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1041
                  return (1);
                }
                {
#line 1044
                w = (image->comps + 0)->w;
#line 1045
                h = (image->comps + 0)->h;
#line 1047
                fprintf(fdest, "BM\307U\006V");
#line 1051
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1056
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1057
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1061
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1062
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1066
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1070
                fprintf(fdest, "%c%c\006V", 1, (1 >> 8) & 255);
#line 1071
                fprintf(fdest, "%c%c\006V", 24, (24 >> 8) & 255);
#line 1072
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1073
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1077
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1078
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1079
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1080
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1082
                if ((image->comps + 0)->prec > 8) {
                  {
#line 1083
                  adjustR = (image->comps + 0)->prec - 8;
#line 1084
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1087
                  adjustR = 0;
                }
#line 1088
                if ((image->comps + 1)->prec > 8) {
                  {
#line 1089
                  adjustG = (image->comps + 1)->prec - 8;
#line 1090
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1093
                  adjustG = 0;
                }
#line 1094
                if ((image->comps + 2)->prec > 8) {
                  {
#line 1095
                  adjustB = (image->comps + 2)->prec - 8;
#line 1096
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1099
                  adjustB = 0;
                }
#line 1101
                i = 0;
                {
#line 1101
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1101
                  if (! (i < w * h)) {
#line 1101
                    goto while_break;
                  }
#line 1105
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1106
                  if ((image->comps + 0)->sgnd) {
#line 1106
                    tmp = 1 << ((image->comps + 0)->prec - 1);
                  } else {
#line 1106
                    tmp = 0;
                  }
#line 1106
                  r += tmp;
#line 1107
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1108
                  if (r > 255) {
#line 1108
                    r = 255;
                  } else
#line 1108
                  if (r < 0) {
#line 1108
                    r = 0;
                  }
#line 1109
                  rc = (unsigned char )r;
#line 1111
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1112
                  if ((image->comps + 1)->sgnd) {
#line 1112
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1);
                  } else {
#line 1112
                    tmp___0 = 0;
                  }
#line 1112
                  g += tmp___0;
#line 1113
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1114
                  if (g > 255) {
#line 1114
                    g = 255;
                  } else
#line 1114
                  if (g < 0) {
#line 1114
                    g = 0;
                  }
#line 1115
                  gc = (unsigned char )g;
#line 1117
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1118
                  if ((image->comps + 2)->sgnd) {
#line 1118
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1);
                  } else {
#line 1118
                    tmp___1 = 0;
                  }
#line 1118
                  b += tmp___1;
#line 1119
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1120
                  if (b > 255) {
#line 1120
                    b = 255;
                  } else
#line 1120
                  if (b < 0) {
#line 1120
                    b = 0;
                  }
                  {
#line 1121
                  bc = (unsigned char )b;
#line 1123
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1125
                  if ((i + 1) % w == 0) {
#line 1126
                    if ((3 * w) % 4) {
#line 1126
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1126
                      tmp___2 = 0;
                    }
#line 1126
                    pad = tmp___2;
                    {
#line 1126
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1126
                      if (! (pad > 0)) {
#line 1126
                        goto while_break___0;
                      }
                      {
#line 1127
                      fprintf(fdest, "%c", 0);
                      }
#line 1126
                      __cil_tmp22 = pad;
#line 1126
                      pad --;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
#line 1101
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 1130
                fclose(fdest);
                }
              } else {
#line 1027
                goto _L;
              }
            } else {
#line 1027
              goto _L;
            }
          } else {
#line 1027
            goto _L;
          }
        } else {
#line 1027
          goto _L;
        }
      } else {
#line 1027
        goto _L;
      }
    } else {
#line 1027
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___29: /* CIL Label */ 
    _L___30: /* CIL Label */ 
    _L___31: /* CIL Label */ 
    _L___32: /* CIL Label */ 
    _L___33: /* CIL Label */ 
    {
#line 1137
    fdest = fopen(outfile, "wb");
    }
#line 1138
    if (! fdest) {
      {
#line 1139
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1140
      return (1);
    }
    {
#line 1143
    w = (image->comps + 0)->w;
#line 1144
    h = (image->comps + 0)->h;
#line 1146
    fprintf(fdest, "BM");
#line 1150
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1154
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1155
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1161
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1162
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1166
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1170
    fprintf(fdest, "%c%c", 1, (1 >> 8) & 255);
#line 1171
    fprintf(fdest, "%c%c", 8, (8 >> 8) & 255);
#line 1172
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1173
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1177
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1178
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1179
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1180
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1182
    if ((image->comps + 0)->prec > 8) {
      {
#line 1183
      adjustR = (image->comps + 0)->prec - 8;
#line 1184
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1186
      adjustR = 0;
    }
#line 1188
    i = 0;
    {
#line 1188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1188
      if (! (i < 256)) {
#line 1188
        goto while_break___1;
      }
      {
#line 1189
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 1188
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1192
    i = 0;
    {
#line 1192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1192
      if (! (i < w * h)) {
#line 1192
        goto while_break___2;
      }
#line 1195
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1196
      if ((image->comps + 0)->sgnd) {
#line 1196
        tmp___3 = 1 << ((image->comps + 0)->prec - 1);
      } else {
#line 1196
        tmp___3 = 0;
      }
#line 1196
      r___0 += tmp___3;
#line 1197
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1198
      if (r___0 > 255) {
#line 1198
        r___0 = 255;
      } else
#line 1198
      if (r___0 < 0) {
#line 1198
        r___0 = 0;
      }
      {
#line 1200
      fprintf(fdest, "%coU\006V", (int )((unsigned char )r___0));
      }
#line 1202
      if ((i + 1) % w == 0) {
#line 1203
        if (w % 4) {
#line 1203
          tmp___4 = 4 - w % 4;
        } else {
#line 1203
          tmp___4 = 0;
        }
#line 1203
        pad = tmp___4;
        {
#line 1203
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1203
          if (! (pad > 0)) {
#line 1203
            goto while_break___3;
          }
          {
#line 1204
          fprintf(fdest, "%c\310U\006V", 0);
          }
#line 1203
          __cil_tmp29 = pad;
#line 1203
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1192
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1207
    fclose(fdest);
    }
  }
#line 1210
  return (0);
}
}
#line 1220 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1223
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1223
  if (! __cil_tmp3) {
    {
#line 1225
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1226
    return ((unsigned char )0);
  }
#line 1228
  return (c1);
}
}
#line 1231 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1234
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1234
  if (! __cil_tmp5) {
    {
#line 1236
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1237
    return ((unsigned short )0);
  }
  {
#line 1239
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1239
  if (! __cil_tmp6) {
    {
#line 1241
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1242
    return ((unsigned short )0);
  }
#line 1244
  if (bigendian) {
#line 1245
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1247
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1250 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1253
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp7) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
  {
#line 1258
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1258
  if (! __cil_tmp8) {
    {
#line 1260
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1261
    return ((unsigned int )0);
  }
  {
#line 1263
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1263
  if (! __cil_tmp9) {
    {
#line 1265
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1266
    return ((unsigned int )0);
  }
  {
#line 1268
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1268
  if (! __cil_tmp10) {
    {
#line 1270
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1271
    return ((unsigned int )0);
  }
#line 1273
  if (bigendian) {
#line 1274
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1276
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1279 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  opj_image_t *__cil_tmp29 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 1280
  f = (FILE *)((void *)0);
#line 1285
  image = (opj_image_t *)((void *)0);
#line 1293
  comp = (opj_image_comp_t *)((void *)0);
#line 1295
  numcomps = 1;
#line 1296
  color_space = (OPJ_COLOR_SPACE )2;
#line 1298
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1300
  max = 0;
#line 1302
  f = fopen(filename, "rb");
  }
#line 1303
  if (! f) {
    {
#line 1304
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1305
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1308
  fseek(f, (long )0, 0);
#line 1309
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d\310U\006V", (char *)temp,
                       & endian1, & endian2, (char *)signtmp, & prec, (char *)temp,
                       & w, (char *)temp, & h);
  }
#line 1309
  if (__cil_tmp25 != 9) {
    {
#line 1310
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
#line 1311
    fclose(f);
    }
#line 1312
    return ((opj_image_t *)((void *)0));
  }
#line 1315
  i = 0;
#line 1316
  sign = (char )'+';
  {
#line 1317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1317
    if (! ((int )signtmp[i] != 0)) {
#line 1317
      goto while_break;
    }
#line 1318
    if ((int )signtmp[i] == 45) {
#line 1318
      sign = (char )'-';
    }
#line 1319
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1322
  fgetc(f);
  }
#line 1323
  if ((int )endian1 == 77) {
#line 1323
    if ((int )endian2 == 76) {
#line 1324
      bigendian = 1;
    } else {
#line 1323
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1325
  if ((int )endian2 == 77) {
#line 1325
    if ((int )endian1 == 76) {
#line 1326
      bigendian = 0;
    } else {
      {
      {
#line 1328
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      {
#line 1329
      fclose(f);
      }
      }
#line 1330
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1328
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    {
#line 1329
    fclose(f);
    }
    }
#line 1330
    return ((opj_image_t *)((void *)0));
  }
#line 1335
  cmptparm.x0 = parameters->image_offset_x0;
#line 1336
  cmptparm.y0 = parameters->image_offset_y0;
#line 1337
  if (! cmptparm.x0) {
#line 1337
    tmp = (w - 1) * parameters->subsampling_dx + 1;
  } else {
#line 1337
    tmp = (cmptparm.x0 + (w - 1) * parameters->subsampling_dx) + 1;
  }
#line 1337
  cmptparm.w = tmp;
#line 1338
  if (! cmptparm.y0) {
#line 1338
    tmp___0 = (h - 1) * parameters->subsampling_dy + 1;
  } else {
#line 1338
    tmp___0 = (cmptparm.y0 + (h - 1) * parameters->subsampling_dy) + 1;
  }
#line 1338
  cmptparm.h = tmp___0;
#line 1340
  if ((int )sign == 45) {
#line 1341
    cmptparm.sgnd = 1;
  } else {
#line 1343
    cmptparm.sgnd = 0;
  }
#line 1345
  if (prec < 8) {
#line 1347
    force8 = 1;
#line 1348
    ushift = 8 - prec;
#line 1348
    dshift = prec - ushift;
#line 1349
    if (cmptparm.sgnd) {
#line 1349
      adjustS = 1 << (prec - 1);
    } else {
#line 1349
      adjustS = 0;
    }
#line 1350
    cmptparm.sgnd = 0;
#line 1351
    prec = 8;
  } else {
#line 1353
    adjustS = 0;
#line 1353
    force8 = adjustS;
#line 1353
    dshift = force8;
#line 1353
    ushift = dshift;
  }
  {
#line 1355
  cmptparm.prec = prec;
#line 1356
  cmptparm.bpp = prec;
#line 1357
  cmptparm.dx = parameters->subsampling_dx;
#line 1358
  cmptparm.dy = parameters->subsampling_dy;
#line 1361
  image = opj_image_create(numcomps, & cmptparm, color_space);
  }
#line 1362
  if (! image) {
    {
#line 1363
    fclose(f);
    }
#line 1364
    return ((opj_image_t *)((void *)0));
  }
#line 1367
  image->x0 = cmptparm.x0;
#line 1368
  image->y0 = cmptparm.x0;
#line 1369
  image->x1 = cmptparm.w;
#line 1370
  image->y1 = cmptparm.h;
#line 1374
  comp = image->comps + 0;
#line 1376
  i = 0;
  {
#line 1376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1376
    if (! (i < w * h)) {
#line 1376
      goto while_break___0;
    }
#line 1378
    if (force8) {
      {
#line 1380
      __cil_tmp31 = readuchar(f);
#line 1380
      v = (int )__cil_tmp31 + adjustS;
#line 1381
      v = (v << ushift) + (v >> dshift);
#line 1382
      *(comp->data + i) = (int )((unsigned char )v);
      }
#line 1384
      if (v > max) {
#line 1384
        max = v;
      }
#line 1386
      goto while_continue___0;
    }
#line 1388
    if (comp->prec == 8) {
#line 1389
      if (! comp->sgnd) {
        {
#line 1390
        __cil_tmp32 = readuchar(f);
#line 1390
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1392
        __cil_tmp33 = readuchar(f);
#line 1392
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1394
    if (comp->prec <= 16) {
#line 1395
      if (! comp->sgnd) {
        {
#line 1396
        __cil_tmp34 = readushort(f, bigendian);
#line 1396
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1398
        __cil_tmp35 = readushort(f, bigendian);
#line 1398
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1401
    if (! comp->sgnd) {
      {
#line 1402
      __cil_tmp36 = readuint(f, bigendian);
#line 1402
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1404
      __cil_tmp37 = readuint(f, bigendian);
#line 1404
      v = (int )__cil_tmp37;
      }
    }
#line 1407
    if (v > max) {
#line 1408
      max = v;
    }
#line 1409
    *(comp->data + i) = v;
#line 1376
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1411
  fclose(f);
#line 1412
  __cil_tmp39 = int_floorlog2___20(max);
#line 1412
  comp->bpp = __cil_tmp39 + 1;
  }
#line 1414
  return (image);
}
}
#line 1417 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp15 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp18 ;
  FILE *__cil_tmp19 ;
  int tmp ;
  int v ;
  char byte ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 1420
  fdest = (FILE *)((void *)0);
#line 1422
  compno = 0;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    if (! (compno < image->numcomps)) {
#line 1422
      goto while_break;
    }
    {
#line 1423
    comp = image->comps + compno;
#line 1425
    name = (char *)bname;
#line 1426
    nbytes = 0;
#line 1428
    __cil_tmp15 = strlen(outfile);
#line 1428
    olen = __cil_tmp15;
#line 1429
    dotpos = olen - 4UL;
#line 1430
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1431
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1433
      fprintf(stderr, "ERROR -> Impossible happen.U\006V");
      }
#line 1434
      return (1);
    }
#line 1436
    if (total > 256UL) {
      {
#line 1437
      __cil_tmp18 = malloc(total + 1UL);
#line 1437
      name = (char *)__cil_tmp18;
      }
    }
    {
#line 1439
    strncpy(name, outfile, dotpos);
#line 1441
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1445
    fdest = fopen((char const   *)name, "wb");
    }
#line 1446
    if (! fdest) {
      {
#line 1447
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1448
      return (1);
    }
#line 1451
    w = (image->comps + compno)->w;
#line 1452
    h = (image->comps + compno)->h;
#line 1454
    if (comp->sgnd) {
#line 1454
      tmp = '-';
    } else {
#line 1454
      tmp = '+';
    }
    {
#line 1454
    fprintf(fdest, "PG ML %c %d %d %d\n\310U\006V", tmp, comp->prec, w, h);
    }
#line 1455
    if (comp->prec <= 8) {
#line 1456
      nbytes = 1;
    } else
#line 1457
    if (comp->prec <= 16) {
#line 1458
      nbytes = 2;
    } else {
#line 1460
      nbytes = 4;
    }
#line 1462
    i = 0;
    {
#line 1462
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1462
      if (! (i < w * h)) {
#line 1462
        goto while_break___0;
      }
#line 1463
      v = *((image->comps + compno)->data + i);
#line 1464
      j = nbytes - 1;
      {
#line 1464
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1464
        if (! (j >= 0)) {
#line 1464
          goto while_break___1;
        }
        {
#line 1465
        byte = (char )(v >> j * 8);
#line 1466
        res = fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1467
        if (res < 1UL) {
          {
#line 1468
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1469
          if (total > 256UL) {
            {
#line 1470
            free(name);
            }
          }
          {
#line 1472
          fclose(fdest);
          }
#line 1473
          return (1);
        }
#line 1464
        __cil_tmp24 = j;
#line 1464
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1462
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1478
    if (total > 256UL) {
      {
#line 1479
      free(name);
      }
    }
    {
#line 1482
    fclose(fdest);
    }
#line 1422
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1485
  return (0);
}
}
#line 1501 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! *s) {
#line 1503
      goto while_break;
    }
#line 1505
    if ((int )*s == 10) {
#line 1505
      return ((char *)((void *)0));
    } else
#line 1505
    if ((int )*s == 13) {
#line 1505
      return ((char *)((void *)0));
    }
    {
#line 1506
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1506
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1506
      s ++;
#line 1506
      goto while_continue;
    }
#line 1507
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  return ((char *)((void *)0));
}
}
#line 1512 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1517
  *out_n = 0;
#line 1517
  s = start;
#line 1519
  s = skip_white(start);
  }
#line 1520
  if (s == (void *)0) {
#line 1520
    return ((char *)((void *)0));
  }
#line 1521
  start = s;
  {
#line 1523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1523
    if (! *s) {
#line 1523
      goto while_break;
    }
    {
#line 1525
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1525
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1525
      goto while_break;
    }
#line 1526
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1528
  c = *s;
#line 1528
  *s = (char )0;
#line 1528
  *out_n = atoi((char const   *)start);
#line 1528
  *s = c;
  }
#line 1529
  return (s);
}
}
#line 1532 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_idf(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1537
  s = skip_white(start);
  }
#line 1538
  if (s == (void *)0) {
#line 1538
    return ((char *)((void *)0));
  }
#line 1539
  start = s;
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (! *s) {
#line 1541
      goto while_break;
    }
    {
#line 1543
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1543
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1543
      s ++;
#line 1543
      goto while_continue;
    } else
#line 1543
    if ((int )*s == 95) {
#line 1543
      s ++;
#line 1543
      goto while_continue;
    }
#line 1544
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1546
  c = *s;
#line 1546
  *s = (char )0;
#line 1546
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1546
  *s = c;
  }
#line 1547
  return (s);
}
}
#line 1550 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1557
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1557
  if (__cil_tmp11 == (void *)0) {
    {
#line 1559
    fprintf(stderr, "\nWARNING: fgets return a NULL value");
    }
#line 1560
    return;
  }
#line 1563
  if ((int )line[0] != 80) {
    {
#line 1565
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1565
    return;
  }
  {
#line 1567
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1568
  if (format < 1) {
    {
    {
#line 1570
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1571
    return;
  } else
#line 1568
  if (format > 7) {
    {
    {
#line 1570
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1571
    return;
  }
#line 1573
  ph->format = format;
#line 1574
  have_wh = 0;
#line 1574
  end = have_wh;
#line 1574
  ttype = end;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1576
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1576
    if (! __cil_tmp13) {
#line 1576
      goto while_break;
    }
#line 1578
    if ((int )*((char *)line) == 35) {
#line 1578
      goto while_continue;
    }
#line 1580
    s = (char *)line;
#line 1582
    if (format == 7) {
      {
#line 1584
      s = skip_idf(s, (char *)idf);
      }
#line 1586
      if (s == (void *)0) {
#line 1586
        return;
      } else
#line 1586
      if ((int )*s == 0) {
#line 1586
        return;
      }
      {
#line 1588
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1588
      if (__cil_tmp15 == 0) {
#line 1590
        end = 1;
#line 1590
        goto while_break;
      }
      {
#line 1592
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHV");
      }
#line 1592
      if (__cil_tmp16 == 0) {
        {
#line 1594
        s = skip_int(s, & ph->width);
        }
#line 1595
        if (s == (void *)0) {
#line 1595
          return;
        } else
#line 1595
        if ((int )*s == 0) {
#line 1595
          return;
        }
#line 1597
        goto while_continue;
      }
      {
#line 1599
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1599
      if (__cil_tmp18 == 0) {
        {
#line 1601
        s = skip_int(s, & ph->height);
        }
#line 1602
        if (s == (void *)0) {
#line 1602
          return;
        } else
#line 1602
        if ((int )*s == 0) {
#line 1602
          return;
        }
#line 1604
        goto while_continue;
      }
      {
#line 1606
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTH");
      }
#line 1606
      if (__cil_tmp20 == 0) {
        {
#line 1608
        s = skip_int(s, & ph->depth);
        }
#line 1609
        if (s == (void *)0) {
#line 1609
          return;
        } else
#line 1609
        if ((int )*s == 0) {
#line 1609
          return;
        }
#line 1611
        goto while_continue;
      }
      {
#line 1613
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1613
      if (__cil_tmp22 == 0) {
        {
#line 1615
        s = skip_int(s, & ph->maxval);
        }
#line 1616
        if (s == (void *)0) {
#line 1616
          return;
        } else
#line 1616
        if ((int )*s == 0) {
#line 1616
          return;
        }
#line 1618
        goto while_continue;
      }
      {
#line 1620
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1620
      if (__cil_tmp24 == 0) {
        {
#line 1622
        s = skip_idf(s, (char *)type);
        }
#line 1623
        if (s == (void *)0) {
#line 1623
          return;
        } else
#line 1623
        if ((int )*s == 0) {
#line 1623
          return;
        }
        {
#line 1625
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1625
        if (__cil_tmp26 == 0) {
#line 1627
          ph->bw = (char )1;
#line 1627
          ttype = 1;
#line 1627
          goto while_continue;
        }
        {
#line 1629
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE");
        }
#line 1629
        if (__cil_tmp27 == 0) {
#line 1631
          ph->gray = (char )1;
#line 1631
          ttype = 1;
#line 1631
          goto while_continue;
        }
        {
#line 1633
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1633
        if (__cil_tmp28 == 0) {
#line 1635
          ph->graya = (char )1;
#line 1635
          ttype = 1;
#line 1635
          goto while_continue;
        }
        {
#line 1637
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1637
        if (__cil_tmp29 == 0) {
#line 1639
          ph->rgb = (char )1;
#line 1639
          ttype = 1;
#line 1639
          goto while_continue;
        }
        {
#line 1641
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\222\001");
        }
#line 1641
        if (__cil_tmp30 == 0) {
#line 1643
          ph->rgba = (char )1;
#line 1643
          ttype = 1;
#line 1643
          goto while_continue;
        }
        {
#line 1645
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1646
        return;
      }
      {
#line 1648
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", (char *)idf);
      }
#line 1649
      return;
    }
#line 1652
    if (! have_wh) {
      {
#line 1654
      s = skip_int(s, & ph->width);
#line 1656
      s = skip_int(s, & ph->height);
#line 1658
      have_wh = 1;
      }
#line 1660
      if (format == 1) {
#line 1660
        goto while_break;
      } else
#line 1660
      if (format == 4) {
#line 1660
        goto while_break;
      }
#line 1662
      goto while_continue;
    }
#line 1664
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___34: /* CIL Label */ 
      _L___35: /* CIL Label */ 
      {
#line 1667
      s = skip_int(s, & ph->maxval);
      }
#line 1669
      if (ph->maxval > 65535) {
#line 1669
        return;
      }
    } else
#line 1664
    if (format == 3) {
#line 1664
      goto _L;
    } else
#line 1664
    if (format == 5) {
#line 1664
      goto _L;
    } else
#line 1664
    if (format == 6) {
#line 1664
      goto _L;
    }
#line 1671
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1673
  if (format == 2) {
    _L___36: /* CIL Label */ 
    _L___37: /* CIL Label */ 
#line 1675
    if (ph->maxval < 1) {
#line 1675
      return;
    } else
#line 1675
    if (ph->maxval > 65535) {
#line 1675
      return;
    }
  } else
#line 1673
  if (format == 3) {
#line 1673
    goto _L___36;
  } else
#line 1673
  if (format > 4) {
#line 1673
    goto _L___36;
  }
#line 1677
  if (ph->width < 1) {
#line 1677
    return;
  } else
#line 1677
  if (ph->height < 1) {
#line 1677
    return;
  }
#line 1679
  if (format == 7) {
#line 1681
    if (! end) {
      {
#line 1683
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1683
      return;
    }
#line 1685
    if (ph->depth < 1) {
#line 1685
      return;
    } else
#line 1685
    if (ph->depth > 4) {
#line 1685
      return;
    }
#line 1687
    if (ph->width) {
#line 1687
      if (ph->height) {
#line 1687
        if (ph->depth & ph->maxval) {
#line 1687
          if (ttype) {
#line 1688
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1692
  if (format != 1) {
#line 1692
    if (format != 4) {
#line 1694
      if (ph->width) {
#line 1694
        if (ph->height) {
#line 1694
          if (ph->maxval) {
#line 1694
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1692
      goto _L___38;
    }
  } else {
    _L___38: /* CIL Label */ 
#line 1698
    if (ph->width) {
#line 1698
      if (ph->height) {
#line 1698
        ph->ok = (char )1;
      }
    }
#line 1699
    ph->maxval = 255;
  }
  return;
}
}
#line 1704 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1706
  if (val < 2) {
#line 1706
    return (1);
  }
#line 1707
  if (val < 4) {
#line 1707
    return (2);
  }
#line 1708
  if (val < 8) {
#line 1708
    return (3);
  }
#line 1709
  if (val < 16) {
#line 1709
    return (4);
  }
#line 1710
  if (val < 32) {
#line 1710
    return (5);
  }
#line 1711
  if (val < 64) {
#line 1711
    return (6);
  }
#line 1712
  if (val < 128) {
#line 1712
    return (7);
  }
#line 1713
  if (val < 256) {
#line 1713
    return (8);
  }
#line 1714
  if (val < 512) {
#line 1714
    return (9);
  }
#line 1715
  if (val < 1024) {
#line 1715
    return (10);
  }
#line 1716
  if (val < 2048) {
#line 1716
    return (11);
  }
#line 1717
  if (val < 4096) {
#line 1717
    return (12);
  }
#line 1718
  if (val < 8192) {
#line 1718
    return (13);
  }
#line 1719
  if (val < 16384) {
#line 1719
    return (14);
  }
#line 1720
  if (val < 32768) {
#line 1720
    return (15);
  }
#line 1721
  return (16);
}
}
#line 1724 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  FILE *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned int index___39 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int index___40 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1725
  subsampling_dx = parameters->subsampling_dx;
#line 1726
  subsampling_dy = parameters->subsampling_dy;
#line 1728
  fp = (FILE *)((void *)0);
#line 1732
  image = (opj_image_t *)((void *)0);
#line 1735
  fp = fopen(filename, "rb");
  }
#line 1735
  if (fp == (void *)0) {
    {
#line 1737
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1738
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1740
  memset(& header_info, 0, sizeof(struct pnm_header ));
#line 1742
  read_pnm_header(fp, & header_info);
  }
#line 1744
  if (! header_info.ok) {
    {
#line 1744
    fclose(fp);
    }
#line 1744
    return ((opj_image_t *)((void *)0));
  }
#line 1746
  format = header_info.format;
  {
#line 1751
  if (format == 4) {
#line 1751
    goto case_4;
  }
#line 1751
  if (format == 1) {
#line 1751
    goto case_4;
  }
#line 1756
  if (format == 5) {
#line 1756
    goto case_5;
  }
#line 1756
  if (format == 2) {
#line 1756
    goto case_5;
  }
#line 1761
  if (format == 6) {
#line 1761
    goto case_6;
  }
#line 1761
  if (format == 3) {
#line 1761
    goto case_6;
  }
#line 1765
  if (format == 7) {
#line 1765
    goto case_7;
  }
#line 1769
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1752
  numcomps = 1;
#line 1753
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1757
  numcomps = 1;
#line 1758
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1762
  numcomps = 3;
#line 1763
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1766
  numcomps = header_info.depth;
#line 1767
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1769
  fclose(fp);
  }
#line 1769
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1771
  if (numcomps < 3) {
#line 1772
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1774
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1776
  prec = has_prec(header_info.maxval);
  }
#line 1778
  if (prec < 8) {
#line 1778
    prec = 8;
  }
  {
#line 1780
  w = header_info.width;
#line 1781
  h = header_info.height;
#line 1782
  subsampling_dx = parameters->subsampling_dx;
#line 1783
  subsampling_dy = parameters->subsampling_dy;
#line 1785
  memset(& cmptparm[0], 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1787
  i = 0;
  }
  {
#line 1787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1787
    if (! (i < numcomps)) {
#line 1787
      goto while_break;
    }
#line 1789
    cmptparm[i].prec = prec;
#line 1790
    cmptparm[i].bpp = prec;
#line 1791
    cmptparm[i].sgnd = 0;
#line 1792
    cmptparm[i].dx = subsampling_dx;
#line 1793
    cmptparm[i].dy = subsampling_dy;
#line 1794
    cmptparm[i].w = w;
#line 1795
    cmptparm[i].h = h;
#line 1787
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1797
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 1799
  if (! image) {
    {
#line 1799
    fclose(fp);
    }
#line 1799
    return ((opj_image_t *)((void *)0));
  }
#line 1802
  image->x0 = parameters->image_offset_x0;
#line 1803
  image->y0 = parameters->image_offset_y0;
#line 1804
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 1805
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 1807
  if (format == 2) {
    _L___43: /* CIL Label */ 
#line 1811
    i = 0;
    {
#line 1811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1811
      if (! (i < w * h)) {
#line 1811
        goto while_break___0;
      }
#line 1813
      compno = 0;
      {
#line 1813
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1813
        if (! (compno < numcomps)) {
#line 1813
          goto while_break___1;
        }
        {
#line 1815
        index___39 = (unsigned int )0;
#line 1816
        __cil_tmp22 = fscanf(fp, "%u", & index___39);
        }
#line 1816
        if (__cil_tmp22 != 1) {
          {
#line 1817
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1819
        *((image->comps + compno)->data + i) = (int )((index___39 * 255U) / (unsigned int )header_info.maxval);
#line 1813
        compno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1811
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1807
  if (format == 3) {
#line 1807
    goto _L___43;
  } else
#line 1824
  if (format == 5) {
    _L: /* CIL Label */ 
    _L___42: /* CIL Label */ 
#line 1832
    one = (unsigned char )(prec < 9);
#line 1834
    i = 0;
    {
#line 1834
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1834
      if (! (i < w * h)) {
#line 1834
        goto while_break___2;
      }
#line 1836
      compno = 0;
      {
#line 1836
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1836
        if (! (compno < numcomps)) {
#line 1836
          goto while_break___3;
        }
        {
#line 1838
        __cil_tmp28 = fread(& c0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1838
        if (! __cil_tmp28) {
          {
#line 1839
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1840
        if (one) {
#line 1842
          *((image->comps + compno)->data + i) = (int )c0;
        } else {
          {
#line 1846
          __cil_tmp29 = fread(& c1, (unsigned long )1, (unsigned long )1, fp);
          }
#line 1846
          if (! __cil_tmp29) {
            {
#line 1847
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1849
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1836
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1834
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1824
  if (format == 6) {
#line 1824
    goto _L;
  } else
#line 1824
  if (format == 7) {
#line 1824
    if ((int )header_info.gray) {
#line 1824
      goto _L;
    } else
#line 1824
    if ((int )header_info.graya) {
#line 1824
      goto _L;
    } else
#line 1824
    if ((int )header_info.rgb) {
#line 1824
      goto _L;
    } else
#line 1824
    if ((int )header_info.rgba) {
#line 1824
      goto _L;
    } else {
#line 1824
      goto _L___41;
    }
  } else
  _L___41: /* CIL Label */ 
#line 1855
  if (format == 1) {
#line 1857
    i = 0;
    {
#line 1857
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1857
      if (! (i < w * h)) {
#line 1857
        goto while_break___4;
      }
      {
#line 1861
      __cil_tmp33 = fscanf(fp, "%u", & index___40);
      }
#line 1861
      if (__cil_tmp33 != 1) {
        {
#line 1862
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1864
      if (index___40) {
#line 1864
        tmp = 0;
      } else {
#line 1864
        tmp = 255;
      }
#line 1864
      *((image->comps + 0)->data + i) = tmp;
#line 1857
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1868
  if (format == 4) {
#line 1873
    i = 0;
#line 1874
    y = 0;
    {
#line 1874
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1874
      if (! (y < h)) {
#line 1874
        goto while_break___5;
      }
#line 1876
      bit = - 1;
#line 1876
      uc = (unsigned char )0;
#line 1878
      x = 0;
      {
#line 1878
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1878
        if (! (x < w)) {
#line 1878
          goto while_break___6;
        }
#line 1880
        if (bit == -1) {
          {
#line 1882
          bit = 7;
#line 1883
          __cil_tmp40 = getc(fp);
#line 1883
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1885
        if (((int )uc >> bit) & 1) {
#line 1885
          tmp___0 = 0;
        } else {
#line 1885
          tmp___0 = 255;
        }
#line 1885
        *((image->comps + 0)->data + i) = tmp___0;
#line 1886
        bit --;
#line 1886
        i ++;
#line 1878
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1874
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1891
  if (format == 7) {
#line 1891
    if ((int )header_info.bw) {
#line 1895
      i = 0;
      {
#line 1895
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1895
        if (! (i < w * h)) {
#line 1895
          goto while_break___7;
        }
        {
#line 1897
        __cil_tmp43 = fread(& uc___0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1897
        if (! __cil_tmp43) {
          {
#line 1898
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1899
        if ((int )uc___0 & 1) {
#line 1899
          tmp___1 = 0;
        } else {
#line 1899
          tmp___1 = 255;
        }
#line 1899
        *((image->comps + 0)->data + i) = tmp___1;
#line 1895
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 1902
  fclose(fp);
  }
#line 1904
  return (image);
}
}
#line 1907 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  int compno ;
  int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  FILE *__cil_tmp27 ;
  char const   *tt ;
  char const   *tmp___44 ;
  char const   *__cil_tmp30 ;
  int tmp___45 ;
  char const   *__cil_tmp32 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  FILE *__cil_tmp42 ;
  char const   *__cil_tmp43 ;
  int tmp___49 ;
  int *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;

  {
#line 1915
  fdest = (FILE *)((void *)0);
#line 1916
  tmp = outfile;
#line 1918
  alpha = (int *)((void *)0);
#line 1919
  prec = (image->comps + 0)->prec;
#line 1919
  if (prec > 16) {
    {
#line 1921
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n",
            "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c", 1922,
            prec);
    }
#line 1923
    return (1);
  }
#line 1925
  has_alpha = 0;
#line 1925
  two = has_alpha;
#line 1925
  fails = 1;
#line 1926
  ncomp = image->numcomps;
  {
#line 1928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1928
    if (! *tmp) {
#line 1928
      goto while_break;
    }
#line 1928
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1928
  tmp -= 2;
#line 1929
  want_gray = (int )*tmp == 103 || (int )*tmp == 71;
#line 1930
  ncomp = image->numcomps;
#line 1932
  if (want_gray) {
#line 1932
    ncomp = 1;
  }
#line 1934
  if (ncomp == 2) {
    _L: /* CIL Label */ 
    {
#line 1944
    fdest = fopen(outfile, "wb");
    }
#line 1946
    if (! fdest) {
      {
#line 1948
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1949
      return (fails);
    }
#line 1951
    two = prec > 8;
#line 1952
    triple = ncomp > 2;
#line 1953
    wr = (image->comps + 0)->w;
#line 1953
    hr = (image->comps + 0)->h;
#line 1954
    max = (1 << prec) - 1;
#line 1954
    has_alpha = ncomp == 4 || ncomp == 2;
#line 1956
    red = (image->comps + 0)->data;
#line 1958
    if (triple) {
#line 1960
      green = (image->comps + 1)->data;
#line 1961
      blue = (image->comps + 2)->data;
    } else {
#line 1963
      blue = (int *)((void *)0);
#line 1963
      green = blue;
    }
#line 1965
    if (has_alpha) {
#line 1967
      if (triple) {
#line 1967
        tmp___44 = "RGB_ALPHAi\312U\006V";
      } else {
#line 1967
        tmp___44 = "GRAYSCALE_ALPHA";
      }
      {
#line 1967
      tt = tmp___44;
#line 1969
      __cil_tmp30 = opj_version();
#line 1969
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 1972
      alpha = (image->comps + (ncomp - 1))->data;
      }
#line 1973
      if ((image->comps + (ncomp - 1))->sgnd) {
#line 1973
        tmp___45 = 1 << ((image->comps + (ncomp - 1))->prec - 1);
      } else {
#line 1973
        tmp___45 = 0;
      }
#line 1973
      adjustA = tmp___45;
    } else {
      {
#line 1978
      __cil_tmp32 = opj_version();
#line 1978
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n\312U\006V", __cil_tmp32, wr,
              hr, max);
#line 1980
      adjustA = 0;
      }
    }
#line 1982
    if ((image->comps + 0)->sgnd) {
#line 1982
      tmp___46 = 1 << ((image->comps + 0)->prec - 1);
    } else {
#line 1982
      tmp___46 = 0;
    }
#line 1982
    adjustR = tmp___46;
#line 1984
    if (triple) {
#line 1986
      if ((image->comps + 1)->sgnd) {
#line 1986
        tmp___47 = 1 << ((image->comps + 1)->prec - 1);
      } else {
#line 1986
        tmp___47 = 0;
      }
#line 1986
      adjustG = tmp___47;
#line 1987
      if ((image->comps + 2)->sgnd) {
#line 1987
        tmp___48 = 1 << ((image->comps + 2)->prec - 1);
      } else {
#line 1987
        tmp___48 = 0;
      }
#line 1987
      adjustB = tmp___48;
    } else {
#line 1989
      adjustB = 0;
#line 1989
      adjustG = adjustB;
    }
#line 1991
    i = 0;
    {
#line 1991
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1991
      if (! (i < wr * hr)) {
#line 1991
        goto while_break___0;
      }
#line 1993
      if (two) {
        {
#line 1995
        v = *red + adjustR;
#line 1995
        red ++;
#line 1997
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 1999
        if (triple) {
          {
#line 2001
          v = *green + adjustG;
#line 2001
          green ++;
#line 2003
          fprintf(fdest, "%c%c\006V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 2005
          v = *blue + adjustB;
#line 2005
          blue ++;
#line 2007
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2011
        if (has_alpha) {
          {
#line 2013
          v = *alpha + adjustA;
#line 2013
          alpha ++;
#line 2015
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2017
        goto while_continue___0;
      }
      {
#line 2023
      __cil_tmp36 = red;
#line 2023
      red ++;
#line 2023
      fprintf(fdest, "%c", (int )((unsigned char )*__cil_tmp36));
      }
#line 2024
      if (triple) {
#line 2025
        __cil_tmp37 = green;
#line 2025
        green ++;
        {
#line 2025
        __cil_tmp38 = blue;
#line 2025
        blue ++;
#line 2025
        fprintf(fdest, "%c%c", (int )((unsigned char )*__cil_tmp37), (int )((unsigned char )*__cil_tmp38));
        }
      }
#line 2027
      if (has_alpha) {
        {
#line 2028
        __cil_tmp39 = alpha;
#line 2028
        alpha ++;
#line 2028
        fprintf(fdest, "%c\312U\006V", (int )((unsigned char )*__cil_tmp39));
        }
      }
#line 1991
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2032
    fclose(fdest);
    }
#line 2032
    return (0);
  } else
#line 1934
  if (ncomp > 2) {
#line 1934
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1934
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1934
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1934
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1934
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1934
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1934
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2037
  if (image->numcomps > ncomp) {
    {
#line 2039
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2040
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2042
  __cil_tmp40 = strlen(outfile);
#line 2042
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2042
  destname = (char *)__cil_tmp41;
#line 2044
  compno = 0;
  }
  {
#line 2044
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2044
    if (! (compno < ncomp)) {
#line 2044
      goto while_break___1;
    }
#line 2046
    if (ncomp > 1) {
      {
#line 2047
      sprintf(destname, "%d.%sV", compno, outfile);
      }
    } else {
      {
#line 2049
      sprintf(destname, "%s\312U\006V", outfile);
      }
    }
    {
#line 2051
    fdest = fopen((char const   *)destname, "wb\312U\006V");
    }
#line 2052
    if (! fdest) {
      {
#line 2054
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2055
      free(destname);
      }
#line 2056
      return (1);
    }
    {
#line 2058
    wr = (image->comps + compno)->w;
#line 2058
    hr = (image->comps + compno)->h;
#line 2059
    prec = (image->comps + compno)->prec;
#line 2060
    max = (1 << prec) - 1;
#line 2062
    __cil_tmp43 = opj_version();
#line 2062
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp43, wr, hr, max);
#line 2065
    red = (image->comps + compno)->data;
    }
#line 2066
    if ((image->comps + compno)->sgnd) {
#line 2066
      tmp___49 = 1 << ((image->comps + compno)->prec - 1);
    } else {
#line 2066
      tmp___49 = 0;
    }
#line 2066
    adjustR = tmp___49;
#line 2069
    if (prec > 8) {
#line 2071
      i = 0;
      {
#line 2071
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2071
        if (! (i < wr * hr)) {
#line 2071
          goto while_break___2;
        }
        {
#line 2073
        v = *red + adjustR;
#line 2073
        red ++;
#line 2075
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2077
        if (has_alpha) {
          {
#line 2079
          __cil_tmp45 = alpha;
#line 2079
          alpha ++;
#line 2079
          v = *__cil_tmp45;
#line 2081
          fprintf(fdest, "%c%c\006V", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2071
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2087
      i = 0;
      {
#line 2087
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2087
        if (! (i < wr * hr)) {
#line 2087
          goto while_break___3;
        }
        {
#line 2089
        fprintf(fdest, "%c\312U\006V", (int )((unsigned char )(*red + adjustR)));
#line 2089
        red ++;
        }
#line 2087
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2092
    fclose(fdest);
    }
#line 2044
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2094
  free(destname);
  }
#line 2096
  return (0);
}
}
#line 2814 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_image_t *__cil_tmp19 ;
  unsigned char value ;
  unsigned long __cil_tmp21 ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned short value___0 ;
  unsigned char temp ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int tmp___0 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;

  {
#line 2815
  subsampling_dx = parameters->subsampling_dx;
#line 2816
  subsampling_dy = parameters->subsampling_dy;
#line 2818
  f = (FILE *)((void *)0);
#line 2822
  image = (opj_image_t *)((void *)0);
#line 2825
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2827
    fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 2828
    fprintf(stderr, "Please use the Format option -F:\n\216\305U\006V");
#line 2829
    fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 2830
    fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n\305U\006V");
#line 2831
    fprintf(stderr, "Aborting\n>\313U\006V");
    }
#line 2832
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2835
  f = fopen(filename, "rb");
  }
#line 2836
  if (! f) {
    {
#line 2837
    fprintf(stderr, "Failed to open %s for reading !!\n", filename);
#line 2838
    fprintf(stderr, "Aborting\n\216\305U\006V");
    }
#line 2839
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2841
  numcomps = raw_cp->rawComp;
#line 2842
  color_space = (OPJ_COLOR_SPACE )1;
#line 2843
  w = raw_cp->rawWidth;
#line 2844
  h = raw_cp->rawHeight;
#line 2845
  __cil_tmp17 = malloc((unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2845
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp17;
#line 2848
  memset(cmptparm + 0, 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2849
  i = 0;
  }
  {
#line 2849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2849
    if (! (i < numcomps)) {
#line 2849
      goto while_break;
    }
#line 2850
    (cmptparm + i)->prec = raw_cp->rawBitDepth;
#line 2851
    (cmptparm + i)->bpp = raw_cp->rawBitDepth;
#line 2852
    (cmptparm + i)->sgnd = raw_cp->rawSigned;
#line 2853
    (cmptparm + i)->dx = subsampling_dx;
#line 2854
    (cmptparm + i)->dy = subsampling_dy;
#line 2855
    (cmptparm + i)->w = w;
#line 2856
    (cmptparm + i)->h = h;
#line 2849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2859
  image = opj_image_create(numcomps, cmptparm + 0, color_space);
  }
#line 2860
  if (! image) {
    {
#line 2861
    fclose(f);
#line 2862
    free(cmptparm);
    }
#line 2863
    return ((opj_image_t *)((void *)0));
  }
#line 2866
  image->x0 = parameters->image_offset_x0;
#line 2867
  image->y0 = parameters->image_offset_y0;
#line 2868
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 2869
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 2871
  if (raw_cp->rawBitDepth <= 8) {
#line 2873
    value = (unsigned char )0;
#line 2874
    compno = 0;
    {
#line 2874
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2874
      if (! (compno < numcomps)) {
#line 2874
        goto while_break___0;
      }
#line 2875
      i = 0;
      {
#line 2875
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2875
        if (! (i < w * h)) {
#line 2875
          goto while_break___1;
        }
        {
#line 2876
        __cil_tmp21 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 2876
        if (! __cil_tmp21) {
          {
#line 2877
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2878
          fclose(f);
#line 2879
          free(cmptparm);
#line 2880
          opj_image_destroy(image);
          }
#line 2881
          return ((opj_image_t *)((void *)0));
        }
#line 2883
        if (raw_cp->rawSigned) {
#line 2883
          tmp = (int )((char )value);
        } else {
#line 2883
          tmp = (int )value;
        }
#line 2883
        *((image->comps + compno)->data + i) = tmp;
#line 2875
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2874
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 2887
  if (raw_cp->rawBitDepth <= 16) {
#line 2890
    compno = 0;
    {
#line 2890
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2890
      if (! (compno < numcomps)) {
#line 2890
        goto while_break___2;
      }
#line 2891
      i = 0;
      {
#line 2891
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2891
        if (! (i < w * h)) {
#line 2891
          goto while_break___3;
        }
        {
#line 2893
        __cil_tmp27 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2893
        if (! __cil_tmp27) {
          {
#line 2894
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2895
          fclose(f);
#line 2896
          free(cmptparm);
#line 2897
          opj_image_destroy(image);
          }
#line 2898
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2900
        value___0 = (unsigned short )((int )temp << 8);
#line 2901
        __cil_tmp28 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2901
        if (! __cil_tmp28) {
          {
#line 2902
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
#line 2903
          fclose(f);
#line 2904
          free(cmptparm);
#line 2905
          opj_image_destroy(image);
          }
#line 2906
          return ((opj_image_t *)((void *)0));
        }
#line 2908
        value___0 += (int )temp;
#line 2909
        if (raw_cp->rawSigned) {
#line 2909
          tmp___0 = (int )((short )value___0);
        } else {
#line 2909
          tmp___0 = (int )value___0;
        }
#line 2909
        *((image->comps + compno)->data + i) = tmp___0;
#line 2891
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2890
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 2914
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n");
#line 2915
    fclose(f);
#line 2916
    free(cmptparm);
#line 2917
    opj_image_destroy(image);
    }
#line 2918
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2921
  __cil_tmp32 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 2921
  if (__cil_tmp32) {
    {
#line 2922
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
  }
  {
#line 2924
  fclose(f);
#line 2925
  free(cmptparm);
  }
#line 2927
  return (image);
}
}
#line 2930 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  FILE *rawFile ;
  size_t res ;
  int compno ;
  int w ;
  int h ;
  int line ;
  int row ;
  int *ptr ;
  FILE *__cil_tmp11 ;
  char const   *tmp ;
  signed char curr ;
  int mask ;
  unsigned long __cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char curr___0 ;
  int mask___0 ;
  unsigned long __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  short curr___1 ;
  int mask___1 ;
  unsigned char temp ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned short curr___2 ;
  int mask___2 ;
  unsigned char temp___0 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 2932
  rawFile = (FILE *)((void *)0);
#line 2939
  if ((image->numcomps * image->x1) * image->y1 == 0) {
    {
#line 2941
    fprintf(stderr, "\nError: invalid raw image parameters\n");
    }
#line 2942
    return (1);
  }
  {
#line 2945
  rawFile = fopen(outfile, "wb\313U\006V");
  }
#line 2946
  if (! rawFile) {
    {
#line 2947
    fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
    }
#line 2948
    return (1);
  }
  {
#line 2951
  fprintf(stdout, "Raw image characteristics: %d components\n\213\313U\006V", image->numcomps);
#line 2953
  compno = 0;
  }
  {
#line 2953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2953
    if (! (compno < image->numcomps)) {
#line 2953
      goto while_break;
    }
#line 2955
    if ((image->comps + compno)->sgnd == 1) {
#line 2955
      tmp = "signed";
    } else {
#line 2955
      tmp = "unsigned\220";
    }
    {
#line 2955
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n\313U\006V", compno,
            (image->comps + compno)->w, (image->comps + compno)->h, (image->comps + compno)->prec,
            tmp);
#line 2958
    w = (image->comps + compno)->w;
#line 2959
    h = (image->comps + compno)->h;
    }
#line 2961
    if ((image->comps + compno)->prec <= 8) {
#line 2963
      if ((image->comps + compno)->sgnd == 1) {
#line 2966
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2967
        ptr = (image->comps + compno)->data;
#line 2968
        line = 0;
        {
#line 2968
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2968
          if (! (line < h)) {
#line 2968
            goto while_break___0;
          }
#line 2969
          row = 0;
          {
#line 2969
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2969
            if (! (row < w)) {
#line 2969
              goto while_break___1;
            }
            {
#line 2970
            curr = (signed char )(*ptr & mask);
#line 2971
            res = fwrite(& curr, sizeof(signed char ), (unsigned long )1, rawFile);
            }
#line 2972
            if (res < 1UL) {
              {
#line 2973
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 2974
              fclose(rawFile);
              }
#line 2975
              return (1);
            }
#line 2977
            ptr ++;
#line 2969
            row ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2968
          line ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 2981
      if ((image->comps + compno)->sgnd == 0) {
#line 2984
        mask___0 = (1 << (image->comps + compno)->prec) - 1;
#line 2985
        ptr = (image->comps + compno)->data;
#line 2986
        line = 0;
        {
#line 2986
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2986
          if (! (line < h)) {
#line 2986
            goto while_break___2;
          }
#line 2987
          row = 0;
          {
#line 2987
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2987
            if (! (row < w)) {
#line 2987
              goto while_break___3;
            }
            {
#line 2988
            curr___0 = (unsigned char )(*ptr & mask___0);
#line 2989
            res = fwrite(& curr___0, sizeof(unsigned char ), (unsigned long )1, rawFile);
            }
#line 2990
            if (res < 1UL) {
              {
#line 2991
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 2992
              fclose(rawFile);
              }
#line 2993
              return (1);
            }
#line 2995
            ptr ++;
#line 2987
            row ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2986
          line ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 3000
    if ((image->comps + compno)->prec <= 16) {
#line 3002
      if ((image->comps + compno)->sgnd == 1) {
#line 3005
        mask___1 = (1 << (image->comps + compno)->prec) - 1;
#line 3006
        ptr = (image->comps + compno)->data;
#line 3007
        line = 0;
        {
#line 3007
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3007
          if (! (line < h)) {
#line 3007
            goto while_break___4;
          }
#line 3008
          row = 0;
          {
#line 3008
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3008
            if (! (row < w)) {
#line 3008
              goto while_break___5;
            }
            {
#line 3010
            curr___1 = (short )(*ptr & mask___1);
#line 3011
            temp = (unsigned char )((int )curr___1 >> 8);
#line 3012
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3013
            if (res < 1UL) {
              {
#line 3014
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 3015
              fclose(rawFile);
              }
#line 3016
              return (1);
            }
            {
#line 3018
            temp = (unsigned char )curr___1;
#line 3019
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3020
            if (res < 1UL) {
              {
#line 3021
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 3022
              fclose(rawFile);
              }
#line 3023
              return (1);
            }
#line 3025
            ptr ++;
#line 3008
            row ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 3007
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 3029
      if ((image->comps + compno)->sgnd == 0) {
#line 3032
        mask___2 = (1 << (image->comps + compno)->prec) - 1;
#line 3033
        ptr = (image->comps + compno)->data;
#line 3034
        line = 0;
        {
#line 3034
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3034
          if (! (line < h)) {
#line 3034
            goto while_break___6;
          }
#line 3035
          row = 0;
          {
#line 3035
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3035
            if (! (row < w)) {
#line 3035
              goto while_break___7;
            }
            {
#line 3037
            curr___2 = (unsigned short )(*ptr & mask___2);
#line 3038
            temp___0 = (unsigned char )((int )curr___2 >> 8);
#line 3039
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3040
            if (res < 1UL) {
              {
#line 3041
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 3042
              fclose(rawFile);
              }
#line 3043
              return (1);
            }
            {
#line 3045
            temp___0 = (unsigned char )curr___2;
#line 3046
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3047
            if (res < 1UL) {
              {
#line 3048
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
#line 3049
              fclose(rawFile);
              }
#line 3050
              return (1);
            }
#line 3052
            ptr ++;
#line 3035
            row ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3034
          line ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    } else
#line 3057
    if ((image->comps + compno)->prec <= 32) {
      {
#line 3059
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
#line 3060
      fclose(rawFile);
      }
#line 3061
      return (1);
    } else {
      {
#line 3065
      fprintf(stderr, "Error: invalid precision: %d\n", (image->comps + compno)->prec);
#line 3066
      fclose(rawFile);
      }
#line 3067
      return (1);
    }
#line 2953
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3070
  fclose(rawFile);
  }
#line 3071
  return (0);
}
}
#line 41 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
int opj_opterr  =    1;
#line 42 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
int opj_optind  =    1;
#line 49 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 52 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 53
  opj_opterr = 1;
#line 54
  opj_optind = 1;
  return;
}
}
#line 61 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 63
  place = (char *)EMSG;
#line 64
  oli = (char *)((void *)0);
#line 66
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 67
    opj_optreset = 0;
#line 68
    place = *(nargv + opj_optind);
#line 68
    if (opj_optind >= nargc) {
#line 69
      place = (char *)EMSG;
#line 70
      return (- 1);
    } else
#line 68
    if ((int )*place != 45) {
#line 69
      place = (char *)EMSG;
#line 70
      return (- 1);
    }
#line 72
    place ++;
#line 72
    if ((int )*(place + 1)) {
#line 72
      if ((int )*place == 45) {
#line 73
        opj_optind ++;
#line 74
        place = (char *)EMSG;
#line 75
        return (- 1);
      }
    }
  } else
#line 66
  if (! *place) {
#line 66
    goto _L;
  }
  {
#line 78
  oli = strchr(ostr, opj_optopt);
  }
#line 78
  __cil_tmp6 = place;
#line 78
  place ++;
#line 78
  opj_optopt = (int )*__cil_tmp6;
#line 78
  if (! oli) {
    _L___50: /* CIL Label */ 
#line 84
    if (opj_optopt == 45) {
#line 85
      return (- 1);
    }
#line 86
    if (! *place) {
#line 87
      opj_optind ++;
    }
#line 88
    if (opj_opterr) {
#line 88
      if ((int )*ostr != 58) {
        {
#line 89
        fprintf(stderr, "%s: illegal option -- %c\nY\330U\006V", *(nargv + 0), opj_optopt);
        }
#line 91
        return ((int )'?');
      }
    }
  } else
#line 78
  if (opj_optopt == 58) {
#line 78
    goto _L___50;
  }
#line 94
  oli ++;
#line 94
  if ((int )*oli != 58) {
#line 95
    opj_optarg = (char *)((void *)0);
#line 96
    if (! *place) {
#line 97
      opj_optind ++;
    }
  } else {
#line 99
    if (*place) {
#line 100
      opj_optarg = place;
    } else {
#line 101
      opj_optind ++;
#line 101
      if (nargc <= opj_optind) {
#line 102
        place = (char *)EMSG;
#line 103
        if ((int )*ostr == 58) {
#line 104
          return ((int )':');
        }
#line 105
        if (opj_opterr) {
          {
#line 106
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 109
          return ((int )'?');
        }
      } else {
#line 112
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 113
    place = (char *)EMSG;
#line 114
    opj_optind ++;
  }
#line 116
  return (opj_optopt);
}
}
#line 120 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 125
  param = (char )1;
  again: 
#line 128
  if (! argv[opj_optind]) {
#line 129
    return (- 1);
  } else
#line 128
  if (opj_optind >= argc) {
#line 129
    return (- 1);
  } else
#line 128
  if ((int )*(argv[opj_optind]) != 45) {
#line 129
    return (- 1);
  }
#line 131
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 131
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 132
      if (opj_optind >= argc - 1) {
#line 133
        param = (char )0;
      } else
#line 136
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 137
        param = (char )0;
      } else {
#line 140
        param = (char )2;
      }
    }
  }
#line 145
  if ((int )param == 0) {
#line 146
    opj_optind ++;
#line 147
    return ((int )'?');
  }
#line 150
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 151
    arg = argv[opj_optind] + 1;
#line 153
    o = longopts;
#line 154
    len = (int )sizeof(*(longopts + 0));
#line 156
    if ((int )param > 1) {
#line 157
      arg = argv[opj_optind + 1];
#line 158
      opj_optind ++;
    } else {
#line 161
      arg = argv[opj_optind] + 1;
    }
    {
#line 163
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 163
    if (__cil_tmp15 > 1UL) {
#line 164
      i = 0;
      {
#line 164
      while (1) {
        while_continue: /* CIL Label */ ;
#line 164
        if (! (i < totlen)) {
#line 164
          goto while_break;
        }
        {
#line 165
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 165
        if (! __cil_tmp16) {
#line 166
          if (o->has_arg == 0) {
#line 167
            if (argv[opj_optind + 1]) {
#line 167
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 168
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 169
                opj_optind ++;
                }
              }
            }
          } else {
#line 172
            opj_optarg = argv[opj_optind + 1];
#line 173
            if (opj_optarg) {
#line 174
              if ((int )*(opj_optarg + 0) == 45) {
#line 175
                if (opj_opterr) {
                  {
#line 176
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 177
                  return ((int )'?');
                }
              }
            }
#line 181
            if (! opj_optarg) {
#line 181
              if (o->has_arg == 1) {
#line 182
                if (opj_opterr) {
                  {
#line 183
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 184
                  return ((int )'?');
                }
              }
            }
#line 187
            opj_optind ++;
          }
#line 189
          opj_optind ++;
#line 190
          if (o->flag) {
#line 191
            *(o->flag) = o->val;
          } else {
#line 193
            return (o->val);
          }
#line 194
          return (0);
        }
#line 164
        __cil_tmp17 = o;
#line 164
        o ++;
#line 164
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 197
      fprintf(stderr, "Invalid option %s\n", arg);
#line 198
      opj_optind ++;
      }
#line 199
      return ((int )'?');
    } else {
#line 201
      if ((int )*optstring == 58) {
#line 201
        return (':');
      }
#line 202
      if (lastidx != opj_optind) {
#line 203
        lastidx = opj_optind;
#line 203
        lastofs = 0;
      }
      {
#line 205
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 206
      tmp = strchr(optstring, opj_optopt);
      }
#line 206
      if (tmp) {
#line 207
        if ((int )*tmp == 0) {
#line 208
          opj_optind ++;
#line 209
          goto again;
        }
#line 211
        if ((int )*(tmp + 1) == 58) {
#line 212
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 213
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 213
            if (! *opj_optarg) {
#line 213
              opj_optarg = (char *)0;
            }
#line 214
            goto found;
          } else
#line 212
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 212
            goto _L;
          }
#line 216
          opj_optarg = argv[opj_optind + 1];
#line 217
          if (opj_optarg) {
#line 218
            if ((int )*(opj_optarg + 0) == 45) {
#line 219
              if (opj_opterr) {
                {
#line 220
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 221
                return ((int )'?');
              }
            }
          }
#line 225
          if (! opj_optarg) {
#line 226
            if (opj_opterr) {
              {
#line 227
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 228
              return ((int )'?');
            }
          }
#line 231
          opj_optind ++;
        } else {
#line 233
          lastofs ++;
#line 234
          return (opj_optopt);
        }
        found: 
#line 237
        opj_optind ++;
#line 238
        return (opj_optopt);
      } else {
        {
#line 240
        fprintf(stderr, "Invalid option %s\n", arg);
#line 241
        opj_optind ++;
        }
#line 242
        return ((int )'?');
      }
    }
  }
  {
#line 247
  fprintf(stderr, "Invalid option\n");
#line 248
  opj_optind ++;
  }
#line 249
  return ((int )'?');

}
}
#line 62 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 67
  cb -= offset;
#line 67
  cr -= offset;
#line 68
  r = y + (int )(1.402 * (double )((float )cr));
#line 69
  if (r < 0) {
#line 69
    r = 0;
  } else
#line 69
  if (r > upb) {
#line 69
    r = upb;
  }
#line 69
  *out_r = r;
#line 71
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 72
  if (g < 0) {
#line 72
    g = 0;
  } else
#line 72
  if (g > upb) {
#line 72
    g = upb;
  }
#line 72
  *out_g = g;
#line 74
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 75
  if (b < 0) {
#line 75
    b = 0;
  } else
#line 75
  if (b > upb) {
#line 75
    b = upb;
  }
#line 75
  *out_b = b;
  return;
}
}
#line 78 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 84
  i = (img->comps + 0)->prec;
#line 85
  offset = 1 << (i - 1);
#line 85
  upb = (1 << i) - 1;
#line 87
  maxw = (img->comps + 0)->w;
#line 87
  maxh = (img->comps + 0)->h;
#line 88
  max = maxw * maxh;
#line 90
  y = (int const   *)(img->comps + 0)->data;
#line 91
  cb = (int const   *)(img->comps + 1)->data;
#line 92
  cr = (int const   *)(img->comps + 2)->data;
#line 94
  __cil_tmp17 = malloc(sizeof(int ) * (unsigned long )max);
#line 94
  r = (int *)__cil_tmp17;
#line 94
  d0 = r;
#line 95
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 95
  g = (int *)__cil_tmp18;
#line 95
  d1 = g;
#line 96
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 96
  b = (int *)__cil_tmp19;
#line 96
  d2 = b;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < max)) {
#line 98
      goto while_break;
    }
    {
#line 100
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 102
    y ++;
#line 102
    cb ++;
#line 102
    cr ++;
#line 102
    r ++;
#line 102
    g ++;
#line 102
    b ++;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  free((img->comps + 0)->data);
#line 104
  (img->comps + 0)->data = d0;
#line 105
  free((img->comps + 1)->data);
#line 105
  (img->comps + 1)->data = d1;
#line 106
  free((img->comps + 2)->data);
#line 106
  (img->comps + 2)->data = d2;
  }
  return;
}
}
#line 110 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 117
  i = (img->comps + 0)->prec;
#line 118
  offset = 1 << (i - 1);
#line 118
  upb = (1 << i) - 1;
#line 120
  maxw = (img->comps + 0)->w;
#line 120
  maxh = (img->comps + 0)->h;
#line 121
  max = maxw * maxh;
#line 123
  y = (int const   *)(img->comps + 0)->data;
#line 124
  cb = (int const   *)(img->comps + 1)->data;
#line 125
  cr = (int const   *)(img->comps + 2)->data;
#line 127
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 127
  r = (int *)__cil_tmp18;
#line 127
  d0 = r;
#line 128
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 128
  g = (int *)__cil_tmp19;
#line 128
  d1 = g;
#line 129
  __cil_tmp20 = malloc(sizeof(int ) * (unsigned long )max);
#line 129
  b = (int *)__cil_tmp20;
#line 129
  d2 = b;
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < maxh)) {
#line 131
      goto while_break;
    }
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! (j < maxw)) {
#line 133
        goto while_break___0;
      }
      {
#line 135
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 137
      y ++;
#line 137
      r ++;
#line 137
      g ++;
#line 137
      b ++;
#line 139
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 141
      y ++;
#line 141
      r ++;
#line 141
      g ++;
#line 141
      b ++;
#line 141
      cb ++;
#line 141
      cr ++;
      }
#line 133
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((img->comps + 0)->data);
#line 144
  (img->comps + 0)->data = d0;
#line 145
  free((img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  free((img->comps + 2)->data);
#line 146
  (img->comps + 2)->data = d2;
#line 148
  (img->comps + 1)->w = maxw;
#line 148
  (img->comps + 1)->h = maxh;
#line 149
  (img->comps + 2)->w = maxw;
#line 149
  (img->comps + 2)->h = maxh;
#line 150
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 151
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 152
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 153
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 164
  i = (img->comps + 0)->prec;
#line 165
  offset = 1 << (i - 1);
#line 165
  upb = (1 << i) - 1;
#line 167
  maxw = (img->comps + 0)->w;
#line 167
  maxh = (img->comps + 0)->h;
#line 168
  max = maxw * maxh;
#line 170
  y = (int const   *)(img->comps + 0)->data;
#line 171
  cb = (int const   *)(img->comps + 1)->data;
#line 172
  cr = (int const   *)(img->comps + 2)->data;
#line 174
  __cil_tmp22 = malloc(sizeof(int ) * (unsigned long )max);
#line 174
  r = (int *)__cil_tmp22;
#line 174
  d0 = r;
#line 175
  __cil_tmp23 = malloc(sizeof(int ) * (unsigned long )max);
#line 175
  g = (int *)__cil_tmp23;
#line 175
  d1 = g;
#line 176
  __cil_tmp24 = malloc(sizeof(int ) * (unsigned long )max);
#line 176
  b = (int *)__cil_tmp24;
#line 176
  d2 = b;
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < maxh)) {
#line 178
      goto while_break;
    }
#line 180
    ny = y + maxw;
#line 181
    nr = r + maxw;
#line 181
    ng = g + maxw;
#line 181
    nb = b + maxw;
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < maxw)) {
#line 183
        goto while_break___0;
      }
      {
#line 185
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 187
      y ++;
#line 187
      r ++;
#line 187
      g ++;
#line 187
      b ++;
#line 189
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 191
      y ++;
#line 191
      r ++;
#line 191
      g ++;
#line 191
      b ++;
#line 193
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 195
      ny ++;
#line 195
      nr ++;
#line 195
      ng ++;
#line 195
      nb ++;
#line 197
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 199
      ny ++;
#line 199
      nr ++;
#line 199
      ng ++;
#line 199
      nb ++;
#line 199
      cb ++;
#line 199
      cr ++;
      }
#line 183
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 201
    y += maxw;
#line 201
    r += maxw;
#line 201
    g += maxw;
#line 201
    b += maxw;
#line 178
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  free((img->comps + 0)->data);
#line 203
  (img->comps + 0)->data = d0;
#line 204
  free((img->comps + 1)->data);
#line 204
  (img->comps + 1)->data = d1;
#line 205
  free((img->comps + 2)->data);
#line 205
  (img->comps + 2)->data = d2;
#line 207
  (img->comps + 1)->w = maxw;
#line 207
  (img->comps + 1)->h = maxh;
#line 208
  (img->comps + 2)->w = maxw;
#line 208
  (img->comps + 2)->h = maxh;
#line 209
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 210
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 211
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 212
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 216 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 218
  if (img->numcomps < 3) {
#line 220
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 221
    return;
  }
#line 224
  if ((img->comps + 0)->dx == 1) {
#line 224
    if ((img->comps + 1)->dx == 2) {
#line 224
      if ((img->comps + 2)->dx == 2) {
#line 224
        if ((img->comps + 0)->dy == 1) {
#line 224
          if ((img->comps + 1)->dy == 2) {
#line 224
            if ((img->comps + 2)->dy == 2) {
              {
#line 231
              sycc420_to_rgb(img);
              }
            } else {
#line 224
              goto _L___55;
            }
          } else {
#line 224
            goto _L___55;
          }
        } else {
#line 224
          goto _L___55;
        }
      } else {
#line 224
        goto _L___55;
      }
    } else {
#line 224
      goto _L___55;
    }
  } else
  _L___55: /* CIL Label */ 
  _L___56: /* CIL Label */ 
  _L___57: /* CIL Label */ 
  _L___58: /* CIL Label */ 
  _L___59: /* CIL Label */ 
#line 234
  if ((img->comps + 0)->dx == 1) {
#line 234
    if ((img->comps + 1)->dx == 2) {
#line 234
      if ((img->comps + 2)->dx == 2) {
#line 234
        if ((img->comps + 0)->dy == 1) {
#line 234
          if ((img->comps + 1)->dy == 1) {
#line 234
            if ((img->comps + 2)->dy == 1) {
              {
#line 241
              sycc422_to_rgb(img);
              }
            } else {
#line 234
              goto _L;
            }
          } else {
#line 234
            goto _L;
          }
        } else {
#line 234
          goto _L;
        }
      } else {
#line 234
        goto _L;
      }
    } else {
#line 234
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___51: /* CIL Label */ 
  _L___52: /* CIL Label */ 
  _L___53: /* CIL Label */ 
  _L___54: /* CIL Label */ 
#line 244
  if ((img->comps + 0)->dx == 1) {
#line 244
    if ((img->comps + 1)->dx == 1) {
#line 244
      if ((img->comps + 2)->dx == 1) {
#line 244
        if ((img->comps + 0)->dy == 1) {
#line 244
          if ((img->comps + 1)->dy == 1) {
#line 244
            if ((img->comps + 2)->dy == 1) {
              {
#line 251
              sycc444_to_rgb(img);
              }
            } else {
              {
              {
              {
              {
              {
              {
#line 255
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
                      256);
              }
              }
              }
              }
              }
              }
#line 257
              return;
            }
          } else {
            {
            {
            {
            {
            {
            {
#line 255
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
                    256);
            }
            }
            }
            }
            }
            }
#line 257
            return;
          }
        } else {
          {
          {
          {
          {
          {
          {
#line 255
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
                  256);
          }
          }
          }
          }
          }
          }
#line 257
          return;
        }
      } else {
        {
        {
        {
        {
        {
        {
#line 255
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
                256);
        }
        }
        }
        }
        }
        }
#line 257
        return;
      }
    } else {
      {
      {
      {
      {
      {
      {
#line 255
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
              256);
      }
      }
      }
      }
      }
      }
#line 257
      return;
    }
  } else {
    {
    {
    {
    {
    {
    {
#line 255
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/color.c",
            256);
    }
    }
    }
    }
    }
    }
#line 257
    return;
  }
#line 259
  img->color_space = (OPJ_COLOR_SPACE )1;
  return;
}
}
#line 49 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/../common/opj_getopt.c"
static char EMSG___0[1]  = {      "\250"};
#line 85 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void encode_help_display(void) 
{ 


  {
  {
#line 86
  fprintf(stdout, "HELP for image_to_j2k\n----\n\n\006V");
#line 87
  fprintf(stdout, "- the -h option displays this help information on screen\n\n1V\006V");
#line 90
  fprintf(stdout, "List of parameters for the JPEG 2000 encoder:\n\001");
#line 96
  fprintf(stdout, "\n\222\001");
#line 97
  fprintf(stdout, "REMARKS:\n\3551V\006V");
#line 98
  fprintf(stdout, "---------\n2V\006V");
#line 99
  fprintf(stdout, "\n-/V\006V");
#line 100
  fprintf(stdout, "The markers written to the main_header are : SOC SIZ COD QCD COM.\n\001");
#line 101
  fprintf(stdout, "COD and QCD never appear in the tile_header.\nV");
#line 102
  fprintf(stdout, "\n\2633V\006V");
#line 103
  fprintf(stdout, "By default:\n\006V");
#line 104
  fprintf(stdout, "------------\nV");
#line 105
  fprintf(stdout, "\nb4V\006V");
#line 106
  fprintf(stdout, " * Lossless\n");
#line 107
  fprintf(stdout, " * 1 tile\n4V\006V");
#line 108
  fprintf(stdout, " * Size of precinct : 2^15 x 2^15 (means 1 precinct)\nV");
#line 109
  fprintf(stdout, " * Size of code-block : 64 x 64\n\220");
#line 110
  fprintf(stdout, " * Number of resolutions: 6\n");
#line 111
  fprintf(stdout, " * No SOP marker in the codestream\n");
#line 112
  fprintf(stdout, " * No EPH marker in the codestream\n");
#line 113
  fprintf(stdout, " * No sub-sampling in x or y direction\n");
#line 114
  fprintf(stdout, " * No mode switch activated\n");
#line 115
  fprintf(stdout, " * Progression order: LRCP\n");
#line 116
  fprintf(stdout, " * No index file\n");
#line 117
  fprintf(stdout, " * No ROI upshifted\n");
#line 118
  fprintf(stdout, " * No offset of the origin of the image\n\220");
#line 119
  fprintf(stdout, " * No offset of the origin of the tiles\n\220");
#line 120
  fprintf(stdout, " * Reversible DWT 5-3\n");
#line 126
  fprintf(stdout, "\n");
#line 127
  fprintf(stdout, "Parameters:\n");
#line 128
  fprintf(stdout, "------------\n");
#line 129
  fprintf(stdout, "\n");
#line 130
  fprintf(stdout, "Required Parameters (except with -h):\n");
#line 131
  fprintf(stdout, "One of the two options -ImgDir or -i must be used\n");
#line 132
  fprintf(stdout, "\n");
#line 133
  fprintf(stdout, "-ImgDir      : Image file Directory path (example ../Images) \n");
#line 134
  fprintf(stdout, "    When using this option -OutFor must be used\n\220");
#line 135
  fprintf(stdout, "\n");
#line 136
  fprintf(stdout, "-OutFor \n");
#line 137
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 138
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 139
  fprintf(stdout, "    Currently accepts PBM, PGM, PPM, PNM, PAM, PGX, PNG, BMP, TIF, RAW and TGA formats\n");
#line 140
  fprintf(stdout, "\n");
#line 141
  fprintf(stdout, "-i           : source file  (-i source.pnm also *pbm, *.pgm, *.ppm, *.pam, *.pgx, *png, *.bmp, *.tif, *.raw, *.tga) \n");
#line 142
  fprintf(stdout, "    When using this option -o must be used\n");
#line 143
  fprintf(stdout, "\n");
#line 144
  fprintf(stdout, "-o           : destination file (-o dest.j2k or .jp2) \n");
#line 145
  fprintf(stdout, "\n");
#line 146
  fprintf(stdout, "Optional Parameters:\n");
#line 147
  fprintf(stdout, "\n");
#line 148
  fprintf(stdout, "-h           : display the help information \n ");
#line 149
  fprintf(stdout, "\n");
#line 150
  fprintf(stdout, "-cinema2K    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
#line 151
  fprintf(stdout, "\t  Need to specify the frames per second for a 2K resolution. Only 24 or 48 fps is allowed\n");
#line 152
  fprintf(stdout, "\n");
#line 153
  fprintf(stdout, "-cinema4K    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
#line 154
  fprintf(stdout, "\t  Frames per second not required. Default value is 24fps\n");
#line 155
  fprintf(stdout, "\n");
#line 156
  fprintf(stdout, "-r           : different compression ratios for successive layers (-r 20,10,5)\n \220");
#line 157
  fprintf(stdout, "\t         - The rate specified for each quality level is the desired \n");
#line 158
  fprintf(stdout, "\t           compression factor.\n\220");
#line 159
  fprintf(stdout, "\t\t   Example: -r 20,10,1 means quality 1: compress 20x, \n");
#line 160
  fprintf(stdout, "\t\t     quality 2: compress 10x and quality 3: compress lossless\n\220");
#line 161
  fprintf(stdout, "\n");
#line 162
  fprintf(stdout, "               (options -r and -q cannot be used together)\n \001");
#line 163
  fprintf(stdout, "\n");
#line 165
  fprintf(stdout, "-q           : different psnr for successive layers (-q 30,40,50) \n \251\f");
#line 167
  fprintf(stdout, "               (options -r and -q cannot be used together)\n ,");
#line 169
  fprintf(stdout, "\n");
#line 170
  fprintf(stdout, "-n           : number of resolutions (-n 3) \nE");
#line 171
  fprintf(stdout, "\n");
#line 172
  fprintf(stdout, "-b           : size of code block (-b 32,32) \n");
#line 173
  fprintf(stdout, "\n\235");
#line 174
  fprintf(stdout, "-c           : size of precinct (-c 128,128) \n");
#line 175
  fprintf(stdout, "\n\255");
#line 176
  fprintf(stdout, "-t           : size of tile (-t 512,512) \n");
#line 177
  fprintf(stdout, "\n\314");
#line 178
  fprintf(stdout, "-p           : progression order (-p LRCP) [LRCP, RLCP, RPCL, PCRL, CPRL] \n");
#line 179
  fprintf(stdout, "\n\333");
#line 180
  fprintf(stdout, "-s           : subsampling factor (-s 2,2) [-s X,Y] \n\375");
#line 181
  fprintf(stdout, "\t     Remark: subsampling bigger than 2 can produce error\n\001");
#line 182
  fprintf(stdout, "\n");
#line 183
  fprintf(stdout, "-POC         : Progression order change (-POC T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL) \n\261");
#line 184
  fprintf(stdout, "      Example: T1=0,0,1,5,3,CPRL \n");
#line 185
  fprintf(stdout, "\t\t\t : Ttilenumber=Resolution num start,Component num start,Layer num end,Resolution num end,Component num end,Progression order\n\220");
#line 186
  fprintf(stdout, "\n");
#line 187
  fprintf(stdout, "-SOP         : write SOP marker before each packet \n\222\001");
#line 188
  fprintf(stdout, "\n");
#line 189
  fprintf(stdout, "-EPH         : write EPH marker after each header packet \n");
#line 190
  fprintf(stdout, "\n");
#line 191
  fprintf(stdout, "-M           : mode switch (-M 3) [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
#line 192
  fprintf(stdout, "                 8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)] \n");
#line 193
  fprintf(stdout, "                 Indicate multiple modes by adding their values. \n");
#line 194
  fprintf(stdout, "                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
#line 195
  fprintf(stdout, "\n");
#line 196
  fprintf(stdout, "-TP          : devide packets of every tile into tile-parts (-TP R) [R, L, C]\n");
#line 197
  fprintf(stdout, "\n");
#line 198
  fprintf(stdout, "-x           : create an index file *.Idx (-x index_name.Idx) \n");
#line 199
  fprintf(stdout, "\n");
#line 200
  fprintf(stdout, "-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
#line 201
  fprintf(stdout, "               for component c=%%d [%%d = 0,1,2]\n");
#line 202
  fprintf(stdout, "               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
#line 203
  fprintf(stdout, "\n");
#line 204
  fprintf(stdout, "-d           : offset of the origin of the image (-d 150,300) \n");
#line 205
  fprintf(stdout, "\n");
#line 206
  fprintf(stdout, "-T           : offset of the origin of the tiles (-T 100,75) \n");
#line 207
  fprintf(stdout, "\n");
#line 208
  fprintf(stdout, "-I           : use the irreversible DWT 9-7 (-I) \n");
#line 209
  fprintf(stdout, "\n");
#line 210
  fprintf(stdout, "-F           : characteristics of the raw input image\n");
#line 211
  fprintf(stdout, "               -F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
#line 212
  fprintf(stdout, "               Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 213
  fprintf(stdout, "\n");
#line 214
  fprintf(stdout, "-jpip        : write jpip codestream index box in JP2 output file\n");
#line 215
  fprintf(stdout, "               NOTICE: currently supports only RPCL order\n");
#line 216
  fprintf(stdout, "\n");
#line 284
  fprintf(stdout, "IMPORTANT:\n");
#line 285
  fprintf(stdout, "-----------\n");
#line 286
  fprintf(stdout, "\n");
#line 287
  fprintf(stdout, "The index file has the structure below:\n\220");
#line 288
  fprintf(stdout, "---------------------------------------\n\220");
#line 289
  fprintf(stdout, "\n");
#line 290
  fprintf(stdout, "Image_height Image_width\n");
#line 291
  fprintf(stdout, "progression order\n");
#line 292
  fprintf(stdout, "Tiles_size_X Tiles_size_Y\n");
#line 293
  fprintf(stdout, "Tiles_nb_X Tiles_nb_Y\n");
#line 294
  fprintf(stdout, "Components_nb\n");
#line 295
  fprintf(stdout, "Layers_nb\n");
#line 296
  fprintf(stdout, "decomposition_levels\n");
#line 297
  fprintf(stdout, "[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
#line 298
  fprintf(stdout, "   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
#line 299
  fprintf(stdout, "Main_header_start_position\n");
#line 300
  fprintf(stdout, "Main_header_end_position\n");
#line 301
  fprintf(stdout, "Codestream_size\n\220");
#line 302
  fprintf(stdout, "\n");
#line 303
  fprintf(stdout, "INFO ON TILES\n");
#line 304
  fprintf(stdout, "tileno start_pos end_hd end_tile nbparts disto nbpix disto/nbpix\n");
#line 305
  fprintf(stdout, "Tile_0 start_pos end_Theader end_pos NumParts TotalDisto NumPix MaxMSE\n");
#line 306
  fprintf(stdout, "Tile_1   \'\'           \'\'        \'\'        \'\'       \'\'    \'\'      \'\'\n");
#line 307
  fprintf(stdout, "...\n");
#line 308
  fprintf(stdout, "Tile_Nt   \'\'           \'\'        \'\'        \'\'       \'\'    \'\'     \'\'\n");
#line 309
  fprintf(stdout, "...\n");
#line 310
  fprintf(stdout, "TILE 0 DETAILS\n");
#line 311
  fprintf(stdout, "part_nb tileno num_packs start_pos end_tph_pos end_pos\n");
#line 312
  fprintf(stdout, "...\n");
#line 313
  fprintf(stdout, "Progression_string\n");
#line 314
  fprintf(stdout, "pack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
#line 315
  fprintf(stdout, "Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
#line 316
  fprintf(stdout, "...\n");
#line 317
  fprintf(stdout, "Tpacket_Np \'\'   \'\'    \'\'   \'\'    \'\'       \'\'       \'\'     \'\'\n");
#line 319
  fprintf(stdout, "MaxDisto\n");
#line 321
  fprintf(stdout, "TotalDisto\n\n");
  }
  return;
}
}
#line 324 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static OPJ_PROG_ORDER give_progression(char progression[4] ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 325
  __cil_tmp2 = strncmp((char const   *)progression, "LRCP", (unsigned long )4);
  }
#line 325
  if (__cil_tmp2 == 0) {
#line 326
    return ((OPJ_PROG_ORDER )0);
  }
  {
#line 328
  __cil_tmp3 = strncmp((char const   *)progression, "RLCP", (unsigned long )4);
  }
#line 328
  if (__cil_tmp3 == 0) {
#line 329
    return ((OPJ_PROG_ORDER )1);
  }
  {
#line 331
  __cil_tmp4 = strncmp((char const   *)progression, "RPCL", (unsigned long )4);
  }
#line 331
  if (__cil_tmp4 == 0) {
#line 332
    return ((OPJ_PROG_ORDER )2);
  }
  {
#line 334
  __cil_tmp5 = strncmp((char const   *)progression, "PCRL", (unsigned long )4);
  }
#line 334
  if (__cil_tmp5 == 0) {
#line 335
    return ((OPJ_PROG_ORDER )3);
  }
  {
#line 337
  __cil_tmp6 = strncmp((char const   *)progression, "CPRL", (unsigned long )4);
  }
#line 337
  if (__cil_tmp6 == 0) {
#line 338
    return ((OPJ_PROG_ORDER )4);
  }
#line 341
  return ((OPJ_PROG_ORDER )-1);
}
}
#line 344 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static int get_num_images___0(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 347
  num_images = 0;
#line 351
  dir = opendir((char const   *)imgdirpath);
  }
#line 352
  if (! dir) {
    {
#line 353
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 354
    return (0);
  }
#line 357
  num_images = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    content = readdir(dir);
    }
#line 358
    if (! (content != (void *)0)) {
#line 358
      goto while_break;
    }
    {
#line 359
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 359
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 359
    if (__cil_tmp7 == 0) {
#line 360
      goto while_continue;
    } else
#line 359
    if (__cil_tmp8 == 0) {
#line 360
      goto while_continue;
    }
#line 361
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  closedir(dir);
  }
#line 364
  return (num_images);
}
}
#line 367 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static int load_images___0(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 370
  i = 0;
#line 374
  dir = opendir((char const   *)imgdirpath);
  }
#line 375
  if (! dir) {
    {
#line 376
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 377
    return (1);
  } else {
    {
#line 379
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 382
    content = readdir(dir);
    }
#line 382
    if (! (content != (void *)0)) {
#line 382
      goto while_break;
    }
    {
#line 383
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 383
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 383
    if (__cil_tmp8 == 0) {
#line 384
      goto while_continue;
    } else
#line 383
    if (__cil_tmp9 == 0) {
#line 384
      goto while_continue;
    }
    {
#line 386
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 387
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 389
  closedir(dir);
  }
#line 390
  return (0);
}
}
#line 393 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static int get_file_format___0(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[15] ;
  static int const   format[15] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 395
  extension[0] = "pgx";
#line 395
  extension[1] = "pnm";
#line 395
  extension[2] = "pgm";
#line 395
  extension[3] = "ppm";
#line 395
  extension[4] = "pbm";
#line 395
  extension[5] = "pam";
#line 395
  extension[6] = "bmp";
#line 395
  extension[7] = "tif";
#line 395
  extension[8] = "raw";
#line 395
  extension[9] = "tga";
#line 395
  extension[10] = "png";
#line 395
  extension[11] = "j2k";
#line 395
  extension[12] = "jp2";
#line 395
  extension[13] = "j2c";
#line 395
  extension[14] = "jpc";
#line 398
  format[0] = 11;
#line 398
  format[1] = 10;
#line 398
  format[2] = 10;
#line 398
  format[3] = 10;
#line 398
  format[4] = 10;
#line 398
  format[5] = 10;
#line 398
  format[6] = 12;
#line 398
  format[7] = 14;
#line 398
  format[8] = 15;
#line 398
  format[9] = 16;
#line 398
  format[10] = 17;
#line 398
  format[11] = 0;
#line 398
  format[12] = 1;
#line 398
  format[13] = 0;
#line 398
  format[14] = 0;
#line 401
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 401
  ext = __cil_tmp6;
  }
#line 402
  if (ext == (void *)0) {
#line 403
    return (- 1);
  }
#line 404
  ext ++;
#line 405
  i = (unsigned int )0;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 405
      goto while_break;
    }
    {
#line 406
    __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
    }
#line 406
    if (__cil_tmp8 == 0) {
#line 407
      return (format[i]);
    }
#line 405
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (- 1);
}
}
#line 413 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static char *get_file_name(char *name ) 
{ 
  char *fname ;
  char *__cil_tmp3 ;

  {
  {
#line 415
  fname = strtok(name, ".38V\006V");
  }
#line 416
  return (fname);
}
}
#line 419 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static char get_next_file___0(int imageno , dircnt_t *dirptr , img_fol_t___0 *img_fol ,
                              opj_cparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 421
  temp1 = "\002";
#line 423
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 424
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 425
  parameters->decod_format = get_file_format___0((char *)image_filename);
  }
#line 426
  if (parameters->decod_format == -1) {
#line 427
    return ((char )1);
  }
  {
#line 428
  sprintf((char *)infilename, "%s/%s", img_fol->imgdirpath, (char *)image_filename);
#line 429
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 432
  __cil_tmp12 = get_file_name((char *)image_filename);
#line 432
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 433
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 433
    if (! (temp_p != (void *)0)) {
#line 433
      goto while_break;
    }
    {
#line 434
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 435
    sprintf((char *)temp1, ".%s", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  if ((int )img_fol->set_out_format == 1) {
    {
#line 438
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 439
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 441
  return ((char )0);
}
}
#line 444 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static int initialise_4K_poc(opj_poc_t *POC , int numres ) 
{ 


  {
#line 445
  (POC + 0)->tile = 1;
#line 446
  (POC + 0)->resno0 = 0;
#line 447
  (POC + 0)->compno0 = 0;
#line 448
  (POC + 0)->layno1 = 1;
#line 449
  (POC + 0)->resno1 = numres - 1;
#line 450
  (POC + 0)->compno1 = 3;
#line 451
  (POC + 0)->prg1 = (OPJ_PROG_ORDER )4;
#line 452
  (POC + 1)->tile = 1;
#line 453
  (POC + 1)->resno0 = numres - 1;
#line 454
  (POC + 1)->compno0 = 0;
#line 455
  (POC + 1)->layno1 = 1;
#line 456
  (POC + 1)->resno1 = numres;
#line 457
  (POC + 1)->compno1 = 3;
#line 458
  (POC + 1)->prg1 = (OPJ_PROG_ORDER )4;
#line 459
  return (2);
}
}
#line 462 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void cinema_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 463
  parameters->tile_size_on = 0;
#line 464
  parameters->cp_tdx = 1;
#line 465
  parameters->cp_tdy = 1;
#line 468
  parameters->tp_flag = (char )'C';
#line 469
  parameters->tp_on = (char )1;
#line 472
  parameters->cp_tx0 = 0;
#line 473
  parameters->cp_ty0 = 0;
#line 474
  parameters->image_offset_x0 = 0;
#line 475
  parameters->image_offset_y0 = 0;
#line 478
  parameters->cblockw_init = 32;
#line 479
  parameters->cblockh_init = 32;
#line 480
  parameters->csty |= 1;
#line 483
  parameters->prog_order = (OPJ_PROG_ORDER )4;
#line 486
  parameters->roi_compno = - 1;
#line 488
  parameters->subsampling_dx = 1;
#line 488
  parameters->subsampling_dy = 1;
#line 491
  parameters->irreversible = 1;
  return;
}
}
#line 495 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void cinema_setup_encoder(opj_cparameters_t *parameters , opj_image_t *image ,
                                 img_fol_t___0 *img_fol ) 
{ 
  int i ;
  float temp_rate ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 501
  if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 501
    goto case_2;
  }
#line 501
  if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 501
    goto case_2;
  }
#line 513
  if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 513
    goto case_3;
  }
#line 527
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 502
  if (parameters->numresolution > 6) {
#line 503
    parameters->numresolution = 6;
  }
#line 505
  if (! (((image->comps + 0)->w == 2048) | ((image->comps + 0)->h == 1080))) {
    {
#line 506
    fprintf(stdout, "Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 (2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
            (image->comps + 0)->w, (image->comps + 0)->h);
#line 509
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
    }
  }
#line 511
  goto switch_break;
  case_3: /* CIL Label */ 
#line 514
  if (parameters->numresolution < 1) {
#line 515
    parameters->numresolution = 1;
  } else
#line 516
  if (parameters->numresolution > 7) {
#line 517
    parameters->numresolution = 7;
  }
#line 519
  if (! (((image->comps + 0)->w == 4096) | ((image->comps + 0)->h == 2160))) {
    {
#line 520
    fprintf(stdout, "Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
            (image->comps + 0)->w, (image->comps + 0)->h);
#line 523
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
    }
  }
  {
#line 525
  parameters->numpocs = initialise_4K_poc((opj_poc_t *)parameters->POC, parameters->numresolution);
  }
#line 526
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 528
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 533
  if ((unsigned int )parameters->cp_cinema == (unsigned int )3) {
#line 533
    goto case_3___0;
  }
#line 533
  if ((unsigned int )parameters->cp_cinema == (unsigned int )1) {
#line 533
    goto case_3___0;
  }
#line 553
  if ((unsigned int )parameters->cp_cinema == (unsigned int )2) {
#line 553
    goto case_2___0;
  }
#line 572
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 534
  i = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < parameters->tcp_numlayers)) {
#line 534
      goto while_break;
    }
#line 535
    temp_rate = (float )0;
#line 536
    if (*(img_fol->rates + i) == (float )0) {
#line 537
      parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((10416664 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
    } else {
#line 540
      temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((*(img_fol->rates + i) * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 542
      if (temp_rate > (float )1302083) {
#line 543
        parameters->tcp_rates[i] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((10416664 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
      } else {
#line 546
        parameters->tcp_rates[i] = *(img_fol->rates + i);
      }
    }
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  parameters->max_comp_size = 1041666;
#line 551
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 554
  i = 0;
  {
#line 554
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 554
    if (! (i < parameters->tcp_numlayers)) {
#line 554
      goto while_break___0;
    }
#line 555
    temp_rate = (float )0;
#line 556
    if (*(img_fol->rates + i) == (float )0) {
#line 557
      parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((5208328 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
    } else {
#line 560
      temp_rate = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (((*(img_fol->rates + i) * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
#line 562
      if (temp_rate > (float )651041) {
#line 563
        parameters->tcp_rates[0] = (float )(((image->numcomps * (image->comps + 0)->w) * (image->comps + 0)->h) * (image->comps + 0)->prec) / (float )((5208328 * (image->comps + 0)->dx) * (image->comps + 0)->dy);
      } else {
#line 566
        parameters->tcp_rates[i] = *(img_fol->rates + i);
      }
    }
#line 554
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 570
  parameters->max_comp_size = 520833;
#line 571
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 573
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 575
  parameters->cp_disto_alloc = 1;
  return;
}
}
#line 580 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static int parse_cmdline_encoder(int argc , char **argv , opj_cparameters_t *parameters ,
                                 img_fol_t___0 *img_fol , raw_cparameters_t *raw_cp ,
                                 char *indexfilename ) 
{ 
  int i ;
  int j ;
  int totlen ;
  int c ;
  opj_option_t long_option[10] ;
  char const   optlist[46] ;
  int __cil_tmp13 ;
  char *infile ;
  int __cil_tmp15 ;
  char *outfile ;
  int __cil_tmp17 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp20 ;
  char *s ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char signo ;
  char *s___0 ;
  int __cil_tmp28 ;
  char *s___1 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  int *row ;
  int *col ;
  int numlayers ;
  int numresolution ;
  int matrix_width ;
  char *s___2 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  int __cil_tmp47 ;
  char *__cil_tmp48 ;
  int __cil_tmp49 ;
  char sep ;
  int res_spec ;
  char *s___3 ;
  int __cil_tmp53 ;
  char *__cil_tmp54 ;
  int cblockw_init ;
  int cblockh_init ;
  char *index___67 ;
  char progression[4] ;
  OPJ_PROG_ORDER __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int numpocs ;
  opj_poc_t *POC ;
  char *s___4 ;
  int __cil_tmp65 ;
  OPJ_PROG_ORDER __cil_tmp66 ;
  int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  int value ;
  int __cil_tmp71 ;
  int cache ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  unsigned long __cil_tmp76 ;
  void *__cil_tmp77 ;
  unsigned long __cil_tmp78 ;
  void *__cil_tmp79 ;
  int fps ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;

  {
#line 583
  long_option[0].name = "cinema2K\251";
#line 583
  long_option[0].has_arg = 1;
#line 583
  long_option[0].flag = (int *)((void *)0);
#line 583
  long_option[0].val = 'w';
#line 583
  long_option[1].name = "cinema4K\251";
#line 583
  long_option[1].has_arg = 0;
#line 583
  long_option[1].flag = (int *)((void *)0);
#line 583
  long_option[1].val = 'y';
#line 583
  long_option[2].name = "ImgDir";
#line 583
  long_option[2].has_arg = 1;
#line 583
  long_option[2].flag = (int *)((void *)0);
#line 583
  long_option[2].val = 'z';
#line 583
  long_option[3].name = "TP";
#line 583
  long_option[3].has_arg = 1;
#line 583
  long_option[3].flag = (int *)((void *)0);
#line 583
  long_option[3].val = 'u';
#line 583
  long_option[4].name = "SOP";
#line 583
  long_option[4].has_arg = 0;
#line 583
  long_option[4].flag = (int *)((void *)0);
#line 583
  long_option[4].val = 'S';
#line 583
  long_option[5].name = "EPH";
#line 583
  long_option[5].has_arg = 0;
#line 583
  long_option[5].flag = (int *)((void *)0);
#line 583
  long_option[5].val = 'E';
#line 583
  long_option[6].name = "OutFor";
#line 583
  long_option[6].has_arg = 1;
#line 583
  long_option[6].flag = (int *)((void *)0);
#line 583
  long_option[6].val = 'O';
#line 583
  long_option[7].name = "POC";
#line 583
  long_option[7].has_arg = 1;
#line 583
  long_option[7].flag = (int *)((void *)0);
#line 583
  long_option[7].val = 'P';
#line 583
  long_option[8].name = "ROI";
#line 583
  long_option[8].has_arg = 1;
#line 583
  long_option[8].flag = (int *)((void *)0);
#line 583
  long_option[8].val = 'R';
#line 583
  long_option[9].name = "jpip";
#line 583
  long_option[9].has_arg = 0;
#line 583
  long_option[9].flag = (int *)((void *)0);
#line 583
  long_option[9].val = 'J';
#line 597
  optlist = "i:o:r:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:F:u:Jh";
#line 603
  totlen = (int )sizeof(long_option);
#line 604
  img_fol->set_out_format = (char )0;
#line 605
  raw_cp->rawWidth = 0;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 608
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 609
    if (c == -1) {
#line 610
      goto while_break;
    }
    {
#line 612
    if (c == 'i') {
#line 612
      goto case_105;
    }
#line 623
    if (c == 17) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 16) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 15) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 14) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 12) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 10) {
#line 623
      goto case_17;
    }
#line 623
    if (c == 11) {
#line 623
      goto case_17;
    }
#line 638
    if (c == 'o') {
#line 638
      goto case_111;
    }
#line 644
    if (c == 1) {
#line 644
      goto case_1;
    }
#line 644
    if (c == 0) {
#line 644
      goto case_1;
    }
#line 655
    if (c == 'O') {
#line 655
      goto case_79;
    }
#line 664
    if (c == 1) {
#line 664
      goto case_1___0;
    }
#line 664
    if (c == 0) {
#line 664
      goto case_1___0;
    }
#line 678
    if (c == 'r') {
#line 678
      goto case_114;
    }
#line 698
    if (c == 'F') {
#line 698
      goto case_70;
    }
#line 732
    if (c == 'q') {
#line 732
      goto case_113;
    }
#line 751
    if (c == 'f') {
#line 751
      goto case_102;
    }
#line 798
    if (c == 't') {
#line 798
      goto case_116;
    }
#line 807
    if (c == 'n') {
#line 807
      goto case_110;
    }
#line 814
    if (c == 'c') {
#line 814
      goto case_99;
    }
#line 835
    if (c == 'b') {
#line 835
      goto case_98;
    }
#line 853
    if (c == 'x') {
#line 853
      goto case_120;
    }
#line 862
    if (c == 'p') {
#line 862
      goto case_112;
    }
#line 878
    if (c == 's') {
#line 878
      goto case_115;
    }
#line 890
    if (c == 'd') {
#line 890
      goto case_100;
    }
#line 903
    if (c == 'h') {
#line 903
      goto case_104;
    }
#line 909
    if (c == 'P') {
#line 909
      goto case_80;
    }
#line 937
    if (c == 'S') {
#line 937
      goto case_83;
    }
#line 945
    if (c == 'E') {
#line 945
      goto case_69;
    }
#line 953
    if (c == 'M') {
#line 953
      goto case_77;
    }
#line 968
    if (c == 'R') {
#line 968
      goto case_82;
    }
#line 980
    if (c == 'T') {
#line 980
      goto case_84;
    }
#line 991
    if (c == 'C') {
#line 991
      goto case_67;
    }
#line 1003
    if (c == 'I') {
#line 1003
      goto case_73;
    }
#line 1011
    if (c == 'u') {
#line 1011
      goto case_117;
    }
#line 1020
    if (c == 'z') {
#line 1020
      goto case_122;
    }
#line 1030
    if (c == 'w') {
#line 1030
      goto case_119;
    }
#line 1050
    if (c == 'y') {
#line 1050
      goto case_121;
    }
#line 1381
    if (c == 'J') {
#line 1381
      goto case_74;
    }
#line 1389
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 614
    infile = opj_optarg;
#line 615
    parameters->decod_format = get_file_format___0(infile);
    }
    {
#line 623
    if (parameters->decod_format == 17) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 16) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 15) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 14) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 12) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 10) {
#line 623
      goto case_17;
    }
#line 623
    if (parameters->decod_format == 11) {
#line 623
      goto case_17;
    }
#line 625
    goto switch_default;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 624
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 626
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.pnm, *.pgm, *.ppm, *.pgx, *png, *.bmp, *.tif, *.raw or *.tga] !!\n\n",
            infile);
    }
#line 630
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 632
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 634
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 640
    outfile = opj_optarg;
#line 641
    parameters->cod_format = get_file_format___0(outfile);
    }
    {
#line 644
    if (parameters->cod_format == 1) {
#line 644
      goto case_1;
    }
#line 644
    if (parameters->cod_format == 0) {
#line 644
      goto case_1;
    }
#line 646
    goto switch_default___0;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 645
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 647
    fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n",
            outfile);
    }
#line 648
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 650
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 652
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 658
    of = opj_optarg;
#line 659
    sprintf((char *)outformat, ".%s", of);
#line 660
    img_fol->set_out_format = (char )1;
#line 661
    parameters->cod_format = get_file_format___0((char *)outformat);
    }
    {
#line 664
    if (parameters->cod_format == 1) {
#line 664
      goto case_1___0;
    }
#line 664
    if (parameters->cod_format == 0) {
#line 664
      goto case_1___0;
    }
#line 667
    goto switch_default___1;
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 665
    img_fol->out_format = opj_optarg;
#line 666
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 668
    fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
    }
#line 669
    return (1);
    switch_break___2: /* CIL Label */ ;
    }
#line 672
    goto switch_break;
    case_114: /* CIL Label */ 
#line 680
    s = opj_optarg;
#line 681
    parameters->tcp_numlayers = 0;
    {
#line 682
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 682
      __cil_tmp22 = sscanf((char const   *)s, "%f", & parameters->tcp_rates[parameters->tcp_numlayers]);
      }
#line 682
      if (! (__cil_tmp22 == 1)) {
#line 682
        goto while_break___0;
      }
#line 683
      (parameters->tcp_numlayers) ++;
      {
#line 684
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 684
        if (! ((int )*s && (int )*s != 44)) {
#line 684
          goto while_break___1;
        }
#line 685
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 687
      if (! *s) {
#line 688
        goto while_break___0;
      }
#line 689
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 691
    parameters->cp_disto_alloc = 1;
#line 693
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 701
    s___0 = opj_optarg;
#line 702
    __cil_tmp28 = sscanf((char const   *)s___0, "%d,%d,%d,%d,%c", & raw_cp->rawWidth,
                         & raw_cp->rawHeight, & raw_cp->rawComp, & raw_cp->rawBitDepth,
                         & signo);
    }
#line 702
    if (__cil_tmp28 == 5) {
#line 703
      if ((int )signo == 115) {
        {
#line 704
        raw_cp->rawSigned = 1;
#line 705
        fprintf(stdout, "\nRaw file parameters: %d,%d,%d,%d Signed\n", raw_cp->rawWidth,
                raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
        }
      } else
#line 707
      if ((int )signo == 117) {
        {
#line 708
        raw_cp->rawSigned = 0;
#line 709
        fprintf(stdout, "\nRaw file parameters: %d,%d,%d,%d Unsigned\n", raw_cp->rawWidth,
                raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
        }
      } else {
        {
#line 712
        fprintf(stderr, "\nError: invalid raw image parameters: Unknown sign of raw file\n");
#line 713
        fprintf(stderr, "Please use the Format option -F:\n");
#line 714
        fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 715
        fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 716
        fprintf(stderr, "Aborting\n");
        }
      }
    } else {
      {
#line 720
      fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 721
      fprintf(stderr, "Please use the Format option -F:\n");
#line 722
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 723
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 724
      fprintf(stderr, "Aborting\n");
      }
#line 725
      return (1);
    }
#line 728
    goto switch_break;
    case_113: /* CIL Label */ 
#line 734
    s___1 = opj_optarg;
    {
#line 735
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 735
      __cil_tmp30 = sscanf((char const   *)s___1, "%f", & parameters->tcp_distoratio[parameters->tcp_numlayers]);
      }
#line 735
      if (! (__cil_tmp30 == 1)) {
#line 735
        goto while_break___2;
      }
#line 736
      (parameters->tcp_numlayers) ++;
      {
#line 737
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 737
        if (! ((int )*s___1 && (int )*s___1 != 44)) {
#line 737
          goto while_break___3;
        }
#line 738
        s___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 740
      if (! *s___1) {
#line 741
        goto while_break___2;
      }
#line 742
      s___1 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 744
    parameters->cp_fixed_quality = 1;
#line 746
    goto switch_break;
    case_102: /* CIL Label */ 
#line 753
    row = (int *)((void *)0);
#line 753
    col = (int *)((void *)0);
#line 754
    numlayers = 0;
#line 754
    numresolution = 0;
    {
#line 754
    matrix_width = 0;
#line 756
    s___2 = opj_optarg;
#line 757
    sscanf((char const   *)s___2, "%d", & numlayers);
#line 758
    s___2 ++;
    }
#line 759
    if (numlayers > 9) {
#line 760
      s___2 ++;
    }
    {
#line 762
    parameters->tcp_numlayers = numlayers;
#line 763
    numresolution = parameters->numresolution;
#line 764
    matrix_width = numresolution * 3;
#line 765
    __cil_tmp42 = malloc((unsigned long )(numlayers * matrix_width) * sizeof(int ));
#line 765
    parameters->cp_matrice = (int *)__cil_tmp42;
#line 766
    s___2 += 2;
#line 768
    i = 0;
    }
    {
#line 768
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 768
      if (! (i < numlayers)) {
#line 768
        goto while_break___4;
      }
      {
#line 769
      row = parameters->cp_matrice + i * matrix_width;
#line 770
      col = row;
#line 771
      parameters->tcp_rates[i] = (float )1;
#line 772
      sscanf((char const   *)s___2, "%d,", col + 0);
#line 773
      s___2 += 2;
      }
#line 774
      if (*(col + 0) > 9) {
#line 775
        s___2 ++;
      }
#line 776
      *(col + 1) = 0;
#line 777
      *(col + 2) = 0;
#line 778
      j = 1;
      {
#line 778
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 778
        if (! (j < numresolution)) {
#line 778
          goto while_break___5;
        }
        {
#line 779
        col += 3;
#line 780
        sscanf((char const   *)s___2, "%d,%d,%d\230\001", col + 0, col + 1, col + 2);
#line 781
        s___2 += 6;
        }
#line 782
        if (*(col + 0) > 9) {
#line 783
          s___2 ++;
        }
#line 784
        if (*(col + 1) > 9) {
#line 785
          s___2 ++;
        }
#line 786
        if (*(col + 2) > 9) {
#line 787
          s___2 ++;
        }
#line 778
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 789
      if (i < numlayers - 1) {
#line 790
        s___2 ++;
      }
#line 768
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 792
    parameters->cp_fixed_alloc = 1;
#line 794
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 800
    sscanf((char const   *)opj_optarg, "%d,%d", & parameters->cp_tdx, & parameters->cp_tdy);
#line 801
    parameters->tile_size_on = 1;
    }
#line 803
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 809
    sscanf((char const   *)opj_optarg, "%d", & parameters->numresolution);
    }
#line 811
    goto switch_break;
    case_99: /* CIL Label */ 
#line 817
    res_spec = 0;
#line 819
    s___3 = opj_optarg;
    {
#line 820
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 821
      sep = (char )0;
#line 822
      sscanf((char const   *)s___3, "[%d,%d]%c", & parameters->prcw_init[res_spec],
             & parameters->prch_init[res_spec], & sep);
#line 824
      parameters->csty |= 1;
#line 825
      res_spec ++;
#line 826
      __cil_tmp54 = strpbrk((char const   *)s___3, "]");
#line 826
      s___3 = __cil_tmp54 + 2;
      }
#line 820
      if (! ((int )sep == 44)) {
#line 820
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 829
    parameters->res_spec = res_spec;
#line 831
    goto switch_break;
    case_98: /* CIL Label */ 
#line 837
    cblockw_init = 0;
    {
#line 837
    cblockh_init = 0;
#line 838
    sscanf((char const   *)opj_optarg, "%d,%d", & cblockw_init, & cblockh_init);
    }
#line 839
    if (cblockw_init * cblockh_init > 4096) {
      {
      {
      {
      {
      {
#line 841
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 844
      return (1);
    } else
#line 839
    if (cblockw_init > 1024) {
      {
      {
      {
      {
      {
#line 841
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 844
      return (1);
    } else
#line 839
    if (cblockw_init < 4) {
      {
      {
      {
      {
      {
#line 841
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 844
      return (1);
    } else
#line 839
    if (cblockh_init > 1024) {
      {
      {
      {
      {
      {
#line 841
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 844
      return (1);
    } else
#line 839
    if (cblockh_init < 4) {
      {
      {
      {
      {
      {
#line 841
      fprintf(stderr, "!! Size of code_block error (option -b) !!\n\nRestriction :\n    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
      }
      }
      }
      }
      }
#line 844
      return (1);
    }
#line 846
    parameters->cblockw_init = cblockw_init;
#line 847
    parameters->cblockh_init = cblockh_init;
#line 849
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 855
    index___67 = opj_optarg;
#line 856
    strncpy(indexfilename, (char const   *)index___67, (unsigned long )4096);
    }
#line 858
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 866
    strncpy((char *)progression, (char const   *)opj_optarg, (unsigned long )4);
#line 867
    parameters->prog_order = give_progression((char *)progression);
    }
#line 868
    if ((int )parameters->prog_order == -1) {
      {
#line 869
      fprintf(stderr, "Unrecognized progression order [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
      }
#line 871
      return (1);
    }
#line 874
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 880
    __cil_tmp60 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->subsampling_dx,
                         & parameters->subsampling_dy);
    }
#line 880
    if (__cil_tmp60 != 2) {
      {
#line 882
      fprintf(stderr, "\'-s\' sub-sampling argument error !  [-s dx,dy]\n");
      }
#line 883
      return (1);
    }
#line 886
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 892
    __cil_tmp61 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->image_offset_x0,
                         & parameters->image_offset_y0);
    }
#line 892
    if (__cil_tmp61 != 2) {
      {
#line 894
      fprintf(stderr, "-d \'coordonnate of the reference grid\' argument error !! [-d x0,y0]\n\220");
      }
#line 896
      return (1);
    }
#line 899
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 904
    encode_help_display();
    }
#line 905
    return (1);
    case_80: /* CIL Label */ 
#line 911
    numpocs = 0;
#line 912
    POC = (opj_poc_t *)((void *)0);
#line 914
    s___4 = opj_optarg;
#line 915
    POC = (opj_poc_t *)parameters->POC;
    {
#line 917
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 917
      __cil_tmp65 = sscanf((char const   *)s___4, "T%d=%d,%d,%d,%d,%d,%4s", & (POC + numpocs)->tile,
                           & (POC + numpocs)->resno0, & (POC + numpocs)->compno0,
                           & (POC + numpocs)->layno1, & (POC + numpocs)->resno1, & (POC + numpocs)->compno1,
                           (char *)(POC + numpocs)->progorder);
      }
#line 917
      if (! (__cil_tmp65 == 7)) {
#line 917
        goto while_break___7;
      }
      {
#line 921
      (POC + numpocs)->prg1 = give_progression((char *)(POC + numpocs)->progorder);
#line 922
      numpocs ++;
      }
      {
#line 923
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 923
        if (! ((int )*s___4 && (int )*s___4 != 47)) {
#line 923
          goto while_break___8;
        }
#line 924
        s___4 ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 926
      if (! *s___4) {
#line 927
        goto while_break___7;
      }
#line 929
      s___4 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 931
    parameters->numpocs = numpocs;
#line 933
    goto switch_break;
    case_83: /* CIL Label */ 
#line 939
    parameters->csty |= 2;
#line 941
    goto switch_break;
    case_69: /* CIL Label */ 
#line 947
    parameters->csty |= 4;
#line 949
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 955
    value = 0;
#line 956
    __cil_tmp71 = sscanf((char const   *)opj_optarg, "%d", & value);
    }
#line 956
    if (__cil_tmp71 == 1) {
#line 957
      i = 0;
      {
#line 957
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 957
        if (! (i <= 5)) {
#line 957
          goto while_break___9;
        }
#line 958
        cache = value & (1 << i);
#line 959
        if (cache) {
#line 960
          parameters->mode |= 1 << i;
        }
#line 957
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 964
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 970
    __cil_tmp74 = sscanf((char const   *)opj_optarg, "c=%d,U=%d", & parameters->roi_compno,
                         & parameters->roi_shift);
    }
#line 970
    if (__cil_tmp74 != 2) {
      {
#line 972
      fprintf(stderr, "ROI error !! [-ROI c=\'compno\',U=\'shift\']\n");
      }
#line 973
      return (1);
    }
#line 976
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 982
    __cil_tmp75 = sscanf((char const   *)opj_optarg, "%d,%d", & parameters->cp_tx0,
                         & parameters->cp_ty0);
    }
#line 982
    if (__cil_tmp75 != 2) {
      {
#line 983
      fprintf(stderr, "-T \'tile offset\' argument error !! [-T X0,Y0]");
      }
#line 984
      return (1);
    }
#line 987
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 993
    __cil_tmp76 = strlen((char const   *)opj_optarg);
#line 993
    __cil_tmp77 = malloc(__cil_tmp76 + 1UL);
#line 993
    parameters->cp_comment = (char *)__cil_tmp77;
    }
#line 994
    if (parameters->cp_comment) {
      {
#line 995
      strcpy(parameters->cp_comment, (char const   *)opj_optarg);
      }
    }
#line 998
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1005
    parameters->irreversible = 1;
#line 1007
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1013
    parameters->tp_flag = *(opj_optarg + 0);
#line 1014
    parameters->tp_on = (char )1;
#line 1016
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 1022
    __cil_tmp78 = strlen((char const   *)opj_optarg);
#line 1022
    __cil_tmp79 = malloc(__cil_tmp78 + 1UL);
#line 1022
    img_fol->imgdirpath = (char *)__cil_tmp79;
#line 1023
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 1024
    img_fol->set_imgdir = (char )1;
    }
#line 1026
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 1032
    fps = 0;
#line 1033
    sscanf((char const   *)opj_optarg, "%d", & fps);
    }
#line 1034
    if (fps == 24) {
#line 1035
      parameters->cp_cinema = (OPJ_CINEMA_MODE )1;
    } else
#line 1036
    if (fps == 48) {
#line 1037
      parameters->cp_cinema = (OPJ_CINEMA_MODE )2;
    } else {
      {
#line 1039
      fprintf(stderr, "Incorrect value!! must be 24 or 48\n");
      }
#line 1040
      return (1);
    }
    {
#line 1042
    fprintf(stdout, "CINEMA 2K compliant codestream\n");
#line 1043
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )3;
    }
#line 1046
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 1052
    parameters->cp_cinema = (OPJ_CINEMA_MODE )3;
#line 1053
    fprintf(stdout, "CINEMA 4K compliant codestream\n");
#line 1054
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )4;
    }
#line 1056
    goto switch_break;
    case_74: /* CIL Label */ 
#line 1383
    parameters->jpip_on = 1;
#line 1385
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 1390
    fprintf(stderr, "ERROR -> Command line not valid\n\220");
    }
#line 1391
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 607
    if (! (c != -1)) {
#line 607
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  if (parameters->cp_cinema) {
#line 1397
    if (parameters->tcp_numlayers > 1) {
      {
#line 1398
      parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 1399
      fprintf(stdout, "Warning: DC profiles do not allow more than one quality layer. The codestream created will not be compliant with the DC profile\n\220");
      }
    }
  }
#line 1402
  if ((int )img_fol->set_imgdir == 1) {
#line 1403
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 1404
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 1405
      return (1);
    }
#line 1407
    if ((int )img_fol->set_out_format == 0) {
      {
#line 1408
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 1409
      fprintf(stderr, "Only one format allowed! Valid formats are j2k and jp2!!\n");
      }
#line 1410
      return (1);
    }
#line 1412
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 1413
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
#line 1414
      fprintf(stderr, "Specify OutputFormat using -OutFor<FORMAT> !!\n");
      }
#line 1415
      return (1);
    }
  } else
#line 1418
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 1419
    fprintf(stderr, "Example: %s -i image.ppm  -o image.j2k\n", *(argv + 0));
    }
    {
#line 1420
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 1421
    return (1);
  } else
#line 1418
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 1419
    fprintf(stderr, "Example: %s -i image.ppm  -o image.j2k\n", *(argv + 0));
    }
    {
#line 1420
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 1421
    return (1);
  }
#line 1425
  if (parameters->decod_format == 15) {
#line 1425
    if (raw_cp->rawWidth == 0) {
      {
#line 1426
      fprintf(stderr, "\nError: invalid raw image parameters\n");
#line 1427
      fprintf(stderr, "Please use the Format option -F:\n");
#line 1428
      fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 1429
      fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 1430
      fprintf(stderr, "Aborting\n");
      }
#line 1431
      return (1);
    }
  }
#line 1434
  if (parameters->cp_disto_alloc) {
    _L: /* CIL Label */ 
    _L___68: /* CIL Label */ 
#line 1434
    if (! ((parameters->cp_disto_alloc ^ parameters->cp_fixed_alloc) ^ parameters->cp_fixed_quality)) {
      {
#line 1436
      fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
      }
#line 1437
      return (1);
    }
  } else
#line 1434
  if (parameters->cp_fixed_alloc) {
#line 1434
    goto _L;
  } else
#line 1434
  if (parameters->cp_fixed_quality) {
#line 1434
    goto _L;
  }
#line 1441
  if (parameters->tcp_numlayers == 0) {
#line 1442
    parameters->tcp_rates[0] = (float )0;
#line 1443
    (parameters->tcp_numlayers) ++;
#line 1444
    parameters->cp_disto_alloc = 1;
  }
#line 1447
  if (parameters->cp_tx0 > parameters->image_offset_x0) {
    {
    {
#line 1448
    fprintf(stderr, "Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters->cp_tx0, parameters->image_offset_x0, parameters->cp_ty0, parameters->image_offset_y0);
    }
    }
#line 1451
    return (1);
  } else
#line 1447
  if (parameters->cp_ty0 > parameters->image_offset_y0) {
    {
    {
#line 1448
    fprintf(stderr, "Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
            parameters->cp_tx0, parameters->image_offset_x0, parameters->cp_ty0, parameters->image_offset_y0);
    }
    }
#line 1451
    return (1);
  }
#line 1454
  i = 0;
  {
#line 1454
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1454
    if (! (i < parameters->numpocs)) {
#line 1454
      goto while_break___10;
    }
#line 1455
    if ((int )parameters->POC[i].prg == -1) {
      {
#line 1456
      fprintf(stderr, "Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",
              i + 1);
      }
    }
#line 1454
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1462
  return (0);
}
}
#line 1470 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void error_callback___0(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 1471
  stream = (FILE *)client_data;
#line 1472
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 1477 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void warning_callback___0(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 1478
  stream = (FILE *)client_data;
#line 1479
  fprintf(stream, "[WARNING] %s", msg);
  }
  return;
}
}
#line 1484 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/image_to_j2k.c"
static void info_callback___0(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 1485
  stream = (FILE *)client_data;
#line 1486
  fprintf(stream, "[INFO] %s", msg);
  }
  return;
}
}
#line 56 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int int_floorlog2___21(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned short get_ushort___0(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int tga_readheader___0(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                              unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 124
    free(tga);
    }
#line 125
    return (0);
  }
  {
#line 127
  id_len = (unsigned char )*(tga + 0);
#line 128
  cmap_type = (unsigned char )*(tga + 1);
#line 130
  image_type = (unsigned char )*(tga + 2);
#line 131
  cmap_index = get_ushort___0(*((unsigned short *)(tga + 3)));
#line 133
  cmap_len = get_ushort___0(*((unsigned short *)(tga + 5)));
#line 134
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 137
  x_origin = get_ushort___0(*((unsigned short *)(tga + 8)));
#line 139
  y_origin = get_ushort___0(*((unsigned short *)(tga + 10)));
#line 141
  image_w = get_ushort___0(*((unsigned short *)(tga + 12)));
#line 142
  image_h = get_ushort___0(*((unsigned short *)(tga + 14)));
#line 143
  pixel_depth = (unsigned char )*(tga + 16);
#line 144
  image_desc = (unsigned char )*(tga + 17);
#line 146
  free(tga);
#line 148
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 149
  *width = (unsigned int )image_w;
#line 150
  *height = (unsigned int )image_h;
  }
#line 153
  if (id_len) {
    {
#line 155
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 155
    id = (unsigned char *)__cil_tmp29;
#line 156
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 156
    if (! __cil_tmp30) {
      {
#line 158
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 159
      free(id);
      }
#line 160
      return (0);
    }
    {
#line 162
    free(id);
    }
  }
#line 168
  if ((int )image_type > 8) {
    {
#line 170
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 171
    return (0);
  }
#line 174
  *flip_image = ! ((int )image_desc & 32);
#line 177
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 179
  if (palette_size > 0) {
    {
#line 181
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 182
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 184
  return (1);
}
}
#line 197 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int tga_writeheader___0(FILE *fp , int bits_per_pixel , int width , int height ,
                               opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 204
  if (! bits_per_pixel) {
#line 205
    return (0);
  } else
#line 204
  if (! width) {
#line 205
    return (0);
  } else
#line 204
  if (! height) {
#line 205
    return (0);
  }
#line 207
  pixel_depth = (unsigned char )0;
#line 209
  if (bits_per_pixel < 256) {
#line 210
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 212
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerV");
    }
#line 213
    return (0);
  }
  {
#line 215
  uc0 = (unsigned char )0;
#line 217
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 217
  if (__cil_tmp13 != 1UL) {
#line 217
    goto fails;
  }
  {
#line 218
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 218
  if (__cil_tmp14 != 1UL) {
#line 218
    goto fails;
  }
  {
#line 220
  image_type = (unsigned char )2;
#line 221
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp15 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  us0 = (unsigned short )0;
#line 224
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp16 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 225
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 225
  if (__cil_tmp17 != 1UL) {
#line 225
    goto fails;
  }
  {
#line 226
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 226
  if (__cil_tmp18 != 1UL) {
#line 226
    goto fails;
  }
  {
#line 228
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 228
  if (__cil_tmp19 != 1UL) {
#line 228
    goto fails;
  }
  {
#line 229
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 229
  if (__cil_tmp20 != 1UL) {
#line 229
    goto fails;
  }
  {
#line 231
  image_w = (unsigned short )width;
#line 232
  image_h = (unsigned short )height;
#line 235
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 235
  if (__cil_tmp21 != 1UL) {
#line 235
    goto fails;
  }
  {
#line 236
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 236
  if (__cil_tmp22 != 1UL) {
#line 236
    goto fails;
  }
  {
#line 244
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 244
  if (__cil_tmp23 != 1UL) {
#line 244
    goto fails;
  }
#line 246
  image_desc = (unsigned char )8;
#line 248
  if (flip_image) {
#line 249
    image_desc |= 32;
  }
  {
#line 250
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 250
  if (__cil_tmp24 != 1UL) {
#line 250
    goto fails;
  }
#line 252
  return (1);
  fails: 
  {
#line 255
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 256
  return (0);
}
}
#line 572 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static void BMP_read_RGB8___0(int *red , int *green , int *blue , unsigned int line ,
                              BITMAPINFOHEADER_t *hdr , struct bmp_cmap bmap[256] ,
                              FILE *reader , unsigned int offset ) 
{ 
  unsigned int w ;
  unsigned int start_pos ;
  unsigned int y ;
  unsigned int x ;
  unsigned int pixel ;
  unsigned int i ;
  int __cil_tmp15 ;

  {
  {
#line 577
  i = (unsigned int )0;
#line 579
  w = hdr->biWidth;
#line 581
  start_pos = ((w * (unsigned int )hdr->biBitCount + 31U) & 4294967264U) >> 3;
#line 582
  y = (hdr->biHeight - line) - 1U;
#line 583
  fseek(reader, (long )(offset + y * start_pos), 0);
#line 585
  x = (unsigned int )0;
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (x < w)) {
#line 585
      goto while_break;
    }
    {
#line 587
    __cil_tmp15 = fgetc(reader);
#line 587
    pixel = (unsigned int )__cil_tmp15;
#line 588
    *(red + i) = (int )((unsigned char )bmap[pixel].red);
#line 589
    *(green + i) = (int )((unsigned char )bmap[pixel].green);
#line 590
    *(blue + i) = (int )((unsigned char )bmap[pixel].blue);
#line 591
    i ++;
    }
#line 585
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1220 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned char readuchar___0(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1223
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1223
  if (! __cil_tmp3) {
    {
#line 1225
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1226
    return ((unsigned char )0);
  }
#line 1228
  return (c1);
}
}
#line 1231 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned short readushort___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1234
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1234
  if (! __cil_tmp5) {
    {
#line 1236
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1237
    return ((unsigned short )0);
  }
  {
#line 1239
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1239
  if (! __cil_tmp6) {
    {
#line 1241
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1242
    return ((unsigned short )0);
  }
#line 1244
  if (bigendian) {
#line 1245
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1247
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1250 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static unsigned int readuint___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1253
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp7) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
  {
#line 1258
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1258
  if (! __cil_tmp8) {
    {
#line 1260
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1261
    return ((unsigned int )0);
  }
  {
#line 1263
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1263
  if (! __cil_tmp9) {
    {
#line 1265
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1266
    return ((unsigned int )0);
  }
  {
#line 1268
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1268
  if (! __cil_tmp10) {
    {
#line 1270
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1271
    return ((unsigned int )0);
  }
#line 1273
  if (bigendian) {
#line 1274
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1276
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1501 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_white___0(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! *s) {
#line 1503
      goto while_break;
    }
#line 1505
    if ((int )*s == 10) {
#line 1505
      return ((char *)((void *)0));
    } else
#line 1505
    if ((int )*s == 13) {
#line 1505
      return ((char *)((void *)0));
    }
    {
#line 1506
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1506
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1506
      s ++;
#line 1506
      goto while_continue;
    }
#line 1507
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1509
  return ((char *)((void *)0));
}
}
#line 1512 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_int___0(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1517
  *out_n = 0;
#line 1517
  s = start;
#line 1519
  s = skip_white___0(start);
  }
#line 1520
  if (s == (void *)0) {
#line 1520
    return ((char *)((void *)0));
  }
#line 1521
  start = s;
  {
#line 1523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1523
    if (! *s) {
#line 1523
      goto while_break;
    }
    {
#line 1525
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1525
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1525
      goto while_break;
    }
#line 1526
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1528
  c = *s;
#line 1528
  *s = (char )0;
#line 1528
  *out_n = atoi((char const   *)start);
#line 1528
  *s = c;
  }
#line 1529
  return (s);
}
}
#line 1532 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static char *skip_idf___0(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1537
  s = skip_white___0(start);
  }
#line 1538
  if (s == (void *)0) {
#line 1538
    return ((char *)((void *)0));
  }
#line 1539
  start = s;
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (! *s) {
#line 1541
      goto while_break;
    }
    {
#line 1543
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1543
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1543
      s ++;
#line 1543
      goto while_continue;
    } else
#line 1543
    if ((int )*s == 95) {
#line 1543
      s ++;
#line 1543
      goto while_continue;
    }
#line 1544
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1546
  c = *s;
#line 1546
  *s = (char )0;
#line 1546
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1546
  *s = c;
  }
#line 1547
  return (s);
}
}
#line 1550 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static void read_pnm_header___0(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1557
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1557
  if (__cil_tmp11 == (void *)0) {
    {
#line 1559
    fprintf(stderr, "\nWARNING: fgets return a NULL value");
    }
#line 1560
    return;
  }
#line 1563
  if ((int )line[0] != 80) {
    {
#line 1565
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1565
    return;
  }
  {
#line 1567
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1568
  if (format < 1) {
    {
    {
#line 1570
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1571
    return;
  } else
#line 1568
  if (format > 7) {
    {
    {
#line 1570
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1571
    return;
  }
#line 1573
  ph->format = format;
#line 1574
  have_wh = 0;
#line 1574
  end = have_wh;
#line 1574
  ttype = end;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1576
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1576
    if (! __cil_tmp13) {
#line 1576
      goto while_break;
    }
#line 1578
    if ((int )*((char *)line) == 35) {
#line 1578
      goto while_continue;
    }
#line 1580
    s = (char *)line;
#line 1582
    if (format == 7) {
      {
#line 1584
      s = skip_idf___0(s, (char *)idf);
      }
#line 1586
      if (s == (void *)0) {
#line 1586
        return;
      } else
#line 1586
      if ((int )*s == 0) {
#line 1586
        return;
      }
      {
#line 1588
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1588
      if (__cil_tmp15 == 0) {
#line 1590
        end = 1;
#line 1590
        goto while_break;
      }
      {
#line 1592
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHV");
      }
#line 1592
      if (__cil_tmp16 == 0) {
        {
#line 1594
        s = skip_int___0(s, & ph->width);
        }
#line 1595
        if (s == (void *)0) {
#line 1595
          return;
        } else
#line 1595
        if ((int )*s == 0) {
#line 1595
          return;
        }
#line 1597
        goto while_continue;
      }
      {
#line 1599
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1599
      if (__cil_tmp18 == 0) {
        {
#line 1601
        s = skip_int___0(s, & ph->height);
        }
#line 1602
        if (s == (void *)0) {
#line 1602
          return;
        } else
#line 1602
        if ((int )*s == 0) {
#line 1602
          return;
        }
#line 1604
        goto while_continue;
      }
      {
#line 1606
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTH");
      }
#line 1606
      if (__cil_tmp20 == 0) {
        {
#line 1608
        s = skip_int___0(s, & ph->depth);
        }
#line 1609
        if (s == (void *)0) {
#line 1609
          return;
        } else
#line 1609
        if ((int )*s == 0) {
#line 1609
          return;
        }
#line 1611
        goto while_continue;
      }
      {
#line 1613
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1613
      if (__cil_tmp22 == 0) {
        {
#line 1615
        s = skip_int___0(s, & ph->maxval);
        }
#line 1616
        if (s == (void *)0) {
#line 1616
          return;
        } else
#line 1616
        if ((int )*s == 0) {
#line 1616
          return;
        }
#line 1618
        goto while_continue;
      }
      {
#line 1620
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1620
      if (__cil_tmp24 == 0) {
        {
#line 1622
        s = skip_idf___0(s, (char *)type);
        }
#line 1623
        if (s == (void *)0) {
#line 1623
          return;
        } else
#line 1623
        if ((int )*s == 0) {
#line 1623
          return;
        }
        {
#line 1625
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1625
        if (__cil_tmp26 == 0) {
#line 1627
          ph->bw = (char )1;
#line 1627
          ttype = 1;
#line 1627
          goto while_continue;
        }
        {
#line 1629
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE");
        }
#line 1629
        if (__cil_tmp27 == 0) {
#line 1631
          ph->gray = (char )1;
#line 1631
          ttype = 1;
#line 1631
          goto while_continue;
        }
        {
#line 1633
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1633
        if (__cil_tmp28 == 0) {
#line 1635
          ph->graya = (char )1;
#line 1635
          ttype = 1;
#line 1635
          goto while_continue;
        }
        {
#line 1637
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1637
        if (__cil_tmp29 == 0) {
#line 1639
          ph->rgb = (char )1;
#line 1639
          ttype = 1;
#line 1639
          goto while_continue;
        }
        {
#line 1641
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\222\001");
        }
#line 1641
        if (__cil_tmp30 == 0) {
#line 1643
          ph->rgba = (char )1;
#line 1643
          ttype = 1;
#line 1643
          goto while_continue;
        }
        {
#line 1645
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1646
        return;
      }
      {
#line 1648
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n", (char *)idf);
      }
#line 1649
      return;
    }
#line 1652
    if (! have_wh) {
      {
#line 1654
      s = skip_int___0(s, & ph->width);
#line 1656
      s = skip_int___0(s, & ph->height);
#line 1658
      have_wh = 1;
      }
#line 1660
      if (format == 1) {
#line 1660
        goto while_break;
      } else
#line 1660
      if (format == 4) {
#line 1660
        goto while_break;
      }
#line 1662
      goto while_continue;
    }
#line 1664
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___80: /* CIL Label */ 
      _L___81: /* CIL Label */ 
      {
#line 1667
      s = skip_int___0(s, & ph->maxval);
      }
#line 1669
      if (ph->maxval > 65535) {
#line 1669
        return;
      }
    } else
#line 1664
    if (format == 3) {
#line 1664
      goto _L;
    } else
#line 1664
    if (format == 5) {
#line 1664
      goto _L;
    } else
#line 1664
    if (format == 6) {
#line 1664
      goto _L;
    }
#line 1671
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1673
  if (format == 2) {
    _L___82: /* CIL Label */ 
    _L___83: /* CIL Label */ 
#line 1675
    if (ph->maxval < 1) {
#line 1675
      return;
    } else
#line 1675
    if (ph->maxval > 65535) {
#line 1675
      return;
    }
  } else
#line 1673
  if (format == 3) {
#line 1673
    goto _L___82;
  } else
#line 1673
  if (format > 4) {
#line 1673
    goto _L___82;
  }
#line 1677
  if (ph->width < 1) {
#line 1677
    return;
  } else
#line 1677
  if (ph->height < 1) {
#line 1677
    return;
  }
#line 1679
  if (format == 7) {
#line 1681
    if (! end) {
      {
#line 1683
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1683
      return;
    }
#line 1685
    if (ph->depth < 1) {
#line 1685
      return;
    } else
#line 1685
    if (ph->depth > 4) {
#line 1685
      return;
    }
#line 1687
    if (ph->width) {
#line 1687
      if (ph->height) {
#line 1687
        if (ph->depth & ph->maxval) {
#line 1687
          if (ttype) {
#line 1688
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1692
  if (format != 1) {
#line 1692
    if (format != 4) {
#line 1694
      if (ph->width) {
#line 1694
        if (ph->height) {
#line 1694
          if (ph->maxval) {
#line 1694
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1692
      goto _L___84;
    }
  } else {
    _L___84: /* CIL Label */ 
#line 1698
    if (ph->width) {
#line 1698
      if (ph->height) {
#line 1698
        ph->ok = (char )1;
      }
    }
#line 1699
    ph->maxval = 255;
  }
  return;
}
}
#line 1704 "/doner/openjpeg/openjpeg-910af7ed/applications/codec/convert.c"
static int has_prec___0(int val ) 
{ 


  {
#line 1706
  if (val < 2) {
#line 1706
    return (1);
  }
#line 1707
  if (val < 4) {
#line 1707
    return (2);
  }
#line 1708
  if (val < 8) {
#line 1708
    return (3);
  }
#line 1709
  if (val < 16) {
#line 1709
    return (4);
  }
#line 1710
  if (val < 32) {
#line 1710
    return (5);
  }
#line 1711
  if (val < 64) {
#line 1711
    return (6);
  }
#line 1712
  if (val < 128) {
#line 1712
    return (7);
  }
#line 1713
  if (val < 256) {
#line 1713
    return (8);
  }
#line 1714
  if (val < 512) {
#line 1714
    return (9);
  }
#line 1715
  if (val < 1024) {
#line 1715
    return (10);
  }
#line 1716
  if (val < 2048) {
#line 1716
    return (11);
  }
#line 1717
  if (val < 4096) {
#line 1717
    return (12);
  }
#line 1718
  if (val < 8192) {
#line 1718
    return (13);
  }
#line 1719
  if (val < 16384) {
#line 1719
    return (14);
  }
#line 1720
  if (val < 32768) {
#line 1720
    return (15);
  }
#line 1721
  return (16);
}
}
